; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\objdef.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\objdef.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\objdef.crf etherCAT\objdef.c]
                          THUMB

                          AREA ||i.CheckSyncTypeValue||, CODE, READONLY, ALIGN=2

                  CheckSyncTypeValue PROC
;;;821    *////////////////////////////////////////////////////////////////////////////////////////
;;;822    UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
000000  4602              MOV      r2,r0
;;;823    {
;;;824        switch (NewSyncType)
000002  2902              CMP      r1,#2
000004  d040              BEQ      |L1.136|
000006  dc03              BGT      |L1.16|
000008  b139              CBZ      r1,|L1.26|
00000a  2901              CMP      r1,#1
00000c  d16e              BNE      |L1.236|
00000e  e006              B        |L1.30|
                  |L1.16|
000010  2903              CMP      r1,#3
000012  d052              BEQ      |L1.186|
000014  2922              CMP      r1,#0x22
000016  d169              BNE      |L1.236|
000018  e025              B        |L1.102|
                  |L1.26|
;;;825        {
;;;826        case SYNCTYPE_FREERUN:
;;;827            return 0; //free run sync mode is always accepted
00001a  2000              MOVS     r0,#0
                  |L1.28|
;;;828    
;;;829        case SYNCTYPE_SM_SYNCHRON:
;;;830            if ((index == 0x1C32) 
;;;831                && (nPdOutputSize > 0) 
;;;832                && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
;;;833            {
;;;834                /*SyncManager sync mode is supported and output process data is configured*/
;;;835                return 0;
;;;836            }
;;;837            else
;;;838            if ((index == 0x1C33) 
;;;839                && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
;;;840                && (nPdOutputSize == 0) 
;;;841                && (nPdInputSize > 0))
;;;842                {
;;;843                    /*SyncManager sync mode is supported and input only shall be configured*/
;;;844                    return 0;
;;;845                }
;;;846            break;
;;;847    
;;;848        case SYNCTYPE_SM2_SYNCHRON:
;;;849            if ((index == 0x1C33) 
;;;850                && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
;;;851                && (nPdOutputSize > 0))
;;;852                {
;;;853                    /*SyncManager sync mode is supported and outputs are defined*/
;;;854                    return 0;
;;;855                }
;;;856            break;
;;;857    
;;;858        case SYNCTYPE_DCSYNC0:
;;;859            if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
;;;860            {
;;;861                return 0;
;;;862            }
;;;863            else
;;;864            if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
;;;865            {
;;;866                return 0;
;;;867            }
;;;868            break;
;;;869    
;;;870        case SYNCTYPE_DCSYNC1:
;;;871            if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
;;;872            {
;;;873                return 0;
;;;874            }
;;;875            else
;;;876            if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
;;;877            {
;;;878                return 0;
;;;879            }
;;;880            break;
;;;881        } //switch 
;;;882        return ABORTIDX_VALUE_EXCEEDED;
;;;883    
;;;884    }
00001c  4770              BX       lr
                  |L1.30|
00001e  f6414032          MOV      r0,#0x1c32            ;830
000022  4282              CMP      r2,r0                 ;830
000024  d10b              BNE      |L1.62|
000026  4833              LDR      r0,|L1.244|
000028  8800              LDRH     r0,[r0,#0]            ;831  ; nPdOutputSize
00002a  2800              CMP      r0,#0                 ;831
00002c  dd07              BLE      |L1.62|
00002e  4832              LDR      r0,|L1.248|
000030  7b00              LDRB     r0,[r0,#0xc]          ;832  ; sSyncManOutPar
000032  f0000002          AND      r0,r0,#2              ;832
000036  2800              CMP      r0,#0                 ;832
000038  dd01              BLE      |L1.62|
00003a  2000              MOVS     r0,#0                 ;835
00003c  e7ee              B        |L1.28|
                  |L1.62|
00003e  f6414033          MOV      r0,#0x1c33            ;838
000042  4282              CMP      r2,r0                 ;838
000044  d10e              BNE      |L1.100|
000046  482d              LDR      r0,|L1.252|
000048  7b00              LDRB     r0,[r0,#0xc]          ;839  ; sSyncManInPar
00004a  f0000002          AND      r0,r0,#2              ;839
00004e  2800              CMP      r0,#0                 ;839
000050  dd08              BLE      |L1.100|
000052  4828              LDR      r0,|L1.244|
000054  8800              LDRH     r0,[r0,#0]            ;840  ; nPdOutputSize
000056  b928              CBNZ     r0,|L1.100|
000058  4829              LDR      r0,|L1.256|
00005a  8800              LDRH     r0,[r0,#0]            ;841  ; nPdInputSize
00005c  2800              CMP      r0,#0                 ;841
00005e  dd01              BLE      |L1.100|
000060  2000              MOVS     r0,#0                 ;844
000062  e7db              B        |L1.28|
                  |L1.100|
000064  e042              B        |L1.236|
                  |L1.102|
000066  f6414033          MOV      r0,#0x1c33            ;849
00006a  4282              CMP      r2,r0                 ;849
00006c  d10b              BNE      |L1.134|
00006e  4823              LDR      r0,|L1.252|
000070  7b00              LDRB     r0,[r0,#0xc]          ;850  ; sSyncManInPar
000072  f0000002          AND      r0,r0,#2              ;850
000076  2800              CMP      r0,#0                 ;850
000078  dd05              BLE      |L1.134|
00007a  481e              LDR      r0,|L1.244|
00007c  8800              LDRH     r0,[r0,#0]            ;851  ; nPdOutputSize
00007e  2800              CMP      r0,#0                 ;851
000080  dd01              BLE      |L1.134|
000082  2000              MOVS     r0,#0                 ;854
000084  e7ca              B        |L1.28|
                  |L1.134|
000086  e031              B        |L1.236|
                  |L1.136|
000088  f6414032          MOV      r0,#0x1c32            ;859
00008c  4282              CMP      r2,r0                 ;859
00008e  d107              BNE      |L1.160|
000090  4819              LDR      r0,|L1.248|
000092  7b00              LDRB     r0,[r0,#0xc]          ;859  ; sSyncManOutPar
000094  f0000004          AND      r0,r0,#4              ;859
000098  2800              CMP      r0,#0                 ;859
00009a  dd01              BLE      |L1.160|
00009c  2000              MOVS     r0,#0                 ;861
00009e  e7bd              B        |L1.28|
                  |L1.160|
0000a0  f6414033          MOV      r0,#0x1c33            ;864
0000a4  4282              CMP      r2,r0                 ;864
0000a6  d107              BNE      |L1.184|
0000a8  4814              LDR      r0,|L1.252|
0000aa  7b00              LDRB     r0,[r0,#0xc]          ;864  ; sSyncManInPar
0000ac  f0000004          AND      r0,r0,#4              ;864
0000b0  2800              CMP      r0,#0                 ;864
0000b2  dd01              BLE      |L1.184|
0000b4  2000              MOVS     r0,#0                 ;866
0000b6  e7b1              B        |L1.28|
                  |L1.184|
0000b8  e018              B        |L1.236|
                  |L1.186|
0000ba  f6414032          MOV      r0,#0x1c32            ;871
0000be  4282              CMP      r2,r0                 ;871
0000c0  d107              BNE      |L1.210|
0000c2  480d              LDR      r0,|L1.248|
0000c4  7b00              LDRB     r0,[r0,#0xc]          ;871  ; sSyncManOutPar
0000c6  f0000008          AND      r0,r0,#8              ;871
0000ca  2800              CMP      r0,#0                 ;871
0000cc  dd01              BLE      |L1.210|
0000ce  2000              MOVS     r0,#0                 ;873
0000d0  e7a4              B        |L1.28|
                  |L1.210|
0000d2  f6414033          MOV      r0,#0x1c33            ;876
0000d6  4282              CMP      r2,r0                 ;876
0000d8  d107              BNE      |L1.234|
0000da  4808              LDR      r0,|L1.252|
0000dc  7b00              LDRB     r0,[r0,#0xc]          ;876  ; sSyncManInPar
0000de  f0000008          AND      r0,r0,#8              ;876
0000e2  2800              CMP      r0,#0                 ;876
0000e4  dd01              BLE      |L1.234|
0000e6  2000              MOVS     r0,#0                 ;878
0000e8  e798              B        |L1.28|
                  |L1.234|
0000ea  bf00              NOP                            ;880
                  |L1.236|
0000ec  bf00              NOP                            ;846
0000ee  2012              MOVS     r0,#0x12              ;882
0000f0  e794              B        |L1.28|
;;;885    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L1.244|
                          DCD      nPdOutputSize
                  |L1.248|
                          DCD      sSyncManOutPar
                  |L1.252|
                          DCD      sSyncManInPar
                  |L1.256|
                          DCD      nPdInputSize

                          AREA ||i.OBJ_CopyNumberToString||, CODE, READONLY, ALIGN=1

                  OBJ_CopyNumberToString PROC
;;;333    
;;;334    void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
000000  b510              PUSH     {r4,lr}
;;;335    {
;;;336        UINT8 Modulo;
;;;337    
;;;338        pStr[2] = '0';
000002  2330              MOVS     r3,#0x30
000004  7083              STRB     r3,[r0,#2]
;;;339        pStr[0] += (Number / 100);
000006  2364              MOVS     r3,#0x64
000008  fb91f3f3          SDIV     r3,r1,r3
00000c  7804              LDRB     r4,[r0,#0]
00000e  4423              ADD      r3,r3,r4
000010  7003              STRB     r3,[r0,#0]
;;;340        Modulo = Number % 100;
000012  2364              MOVS     r3,#0x64
000014  fb91f4f3          SDIV     r4,r1,r3
000018  fb031314          MLS      r3,r3,r4,r1
00001c  b2da              UXTB     r2,r3
;;;341        pStr[1] += (Modulo / 10);
00001e  230a              MOVS     r3,#0xa
000020  fb92f3f3          SDIV     r3,r2,r3
000024  7844              LDRB     r4,[r0,#1]
000026  4423              ADD      r3,r3,r4
000028  7043              STRB     r3,[r0,#1]
;;;342        pStr[2] += (Modulo % 10);
00002a  230a              MOVS     r3,#0xa
00002c  fb92f4f3          SDIV     r4,r2,r3
000030  fb032314          MLS      r3,r3,r4,r2
000034  7884              LDRB     r4,[r0,#2]
000036  4423              ADD      r3,r3,r4
000038  7083              STRB     r3,[r0,#2]
;;;343    }
00003a  bd10              POP      {r4,pc}
;;;344    
                          ENDP


                          AREA ||i.OBJ_GetDesc||, CODE, READONLY, ALIGN=2

                  OBJ_GetDesc PROC
;;;529    
;;;530    UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData )
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;531    {
000004  460f              MOV      r7,r1
000006  4690              MOV      r8,r2
000008  461c              MOV      r4,r3
;;;532        UINT16 strSize = 0;
00000a  2600              MOVS     r6,#0
;;;533        OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
00000c  f8d89014          LDR      r9,[r8,#0x14]
;;;534    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
;;;535        UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
000010  f8b8000c          LDRH     r0,[r8,#0xc]
000014  f3c02b03          UBFX     r11,r0,#8,#4
;;;536    
;;;537    
;;;538    
;;;539        if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
000018  b117              CBZ      r7,|L3.32|
00001a  f1bb0f07          CMP      r11,#7
00001e  d10b              BNE      |L3.56|
                  |L3.32|
;;;540        {
;;;541            // Get object description length
;;;542           strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pDesc);
000020  4648              MOV      r0,r9
000022  f7fffffe          BL       strlen
000026  b286              UXTH     r6,r0
;;;543    
;;;544            // If there is a pointer given, copy data:
;;;545            if ( pData )
000028  2c00              CMP      r4,#0
00002a  d047              BEQ      |L3.188|
;;;546            {
;;;547                OBJTOMBXSTRCPY( pData, pDesc, strSize );
00002c  4632              MOV      r2,r6
00002e  4649              MOV      r1,r9
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       __aeabi_memcpy
000036  e041              B        |L3.188|
                  |L3.56|
;;;548            }
;;;549        }
;;;550        else
;;;551        {
;;;552            if ( objCode == OBJCODE_REC )
000038  f1bb0f09          CMP      r11,#9
00003c  d12c              BNE      |L3.152|
;;;553            {
;;;554    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 632 to 653 deleted*/
;;;555                {
;;;556                // get pointer to description of subindex 1 :
;;;557                // 16bit variable to avoid overflow if subindex 0xFF is read
;;;558                UINT16 i = 1;
00003e  f04f0a01          MOV      r10,#1
;;;559                UINT16 tmpSubindex = subindex;
000042  9703              STR      r7,[sp,#0xc]
;;;560    
;;;561    /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 660 to 666 deleted*/
;;;562                {
;;;563    
;;;564                OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       strlen
00004a  1c40              ADDS     r0,r0,#1
00004c  eb000509          ADD      r5,r0,r9
;;;565                while (( i <= tmpSubindex )
000050  e017              B        |L3.130|
                  |L3.82|
;;;566                    &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
;;;567    /* ECATCHANGE_START(V5.13) COE9*/
;;;568    /*ET9300 Project Handler :(#if MEMORY_UNIT_16BIT) lines 673 to 676 deleted*/
;;;569    /* ECATCHANGE_END(V5.13) COE9*/
;;;570                        ))
;;;571                {
;;;572                    if ( i == tmpSubindex )
000052  9803              LDR      r0,[sp,#0xc]
000054  4582              CMP      r10,r0
000056  d10b              BNE      |L3.112|
;;;573                    {
;;;574                       strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       strlen
00005e  b286              UXTH     r6,r0
;;;575                        if ( pData && strSize )
000060  b12c              CBZ      r4,|L3.110|
000062  b126              CBZ      r6,|L3.110|
;;;576                        {
;;;577                            OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
000064  4632              MOV      r2,r6
000066  4629              MOV      r1,r5
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       __aeabi_memcpy
                  |L3.110|
;;;578                        }
;;;579                        break;
00006e  e011              B        |L3.148|
                  |L3.112|
;;;580                    }
;;;581                    else
;;;582                    {
;;;583                        i++;
000070  f10a0001          ADD      r0,r10,#1
000074  fa1ffa80          UXTH     r10,r0
;;;584                        pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       strlen
00007e  1c40              ADDS     r0,r0,#1
000080  4405              ADD      r5,r5,r0
                  |L3.130|
000082  9803              LDR      r0,[sp,#0xc]          ;565
000084  4582              CMP      r10,r0                ;565
000086  dc05              BGT      |L3.148|
000088  7828              LDRB     r0,[r5,#0]            ;566
00008a  28ff              CMP      r0,#0xff              ;566
00008c  d002              BEQ      |L3.148|
00008e  7828              LDRB     r0,[r5,#0]            ;566
000090  28fe              CMP      r0,#0xfe              ;566
000092  d1de              BNE      |L3.82|
                  |L3.148|
000094  bf00              NOP                            ;579
;;;585                    }
;;;586                }
;;;587                }
;;;588                }
000096  bf00              NOP      
                  |L3.152|
;;;589            }
;;;590    
;;;591            if ( strSize == 0 )
000098  b986              CBNZ     r6,|L3.188|
;;;592            {
;;;593                // no string found for subindex x -> name is Subindex x
;;;594                strSize =    12;
00009a  260c              MOVS     r6,#0xc
;;;595    
;;;596                if ( pData )
00009c  b174              CBZ      r4,|L3.188|
;;;597                {
;;;598                    UCHAR OBJMEM         TmpDescr[13];
;;;599                    /* ECATCHANGE_START(V5.13) COE4*/
;;;600                    MEMCPY(TmpDescr, aSubindexDesc, SIZEOF(TmpDescr));
00009e  4b09              LDR      r3,|L3.196|
0000a0  cb0f              LDM      r3,{r0-r3}
0000a2  e88d000f          STM      sp,{r0-r3}
;;;601                    /* ECATCHANGE_END(V5.13) COE4*/
;;;602                    
;;;603                    OBJ_CopyNumberToString( &TmpDescr[9], subindex );
0000a6  4639              MOV      r1,r7
0000a8  f10d0009          ADD      r0,sp,#9
0000ac  f7fffffe          BL       OBJ_CopyNumberToString
;;;604                    MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
0000b0  220d              MOVS     r2,#0xd
0000b2  4669              MOV      r1,sp
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       __aeabi_memcpy
;;;605                }
0000ba  bf00              NOP      
                  |L3.188|
;;;606            }
;;;607        }
;;;608    
;;;609        return strSize;
0000bc  4630              MOV      r0,r6
;;;610    }
0000be  b004              ADD      sp,sp,#0x10
0000c0  e8bd9ff0          POP      {r4-r12,pc}
;;;611    
                          ENDP

                  |L3.196|
                          DCD      aSubindexDesc

                          AREA ||i.OBJ_GetEntryDesc||, CODE, READONLY, ALIGN=1

                  OBJ_GetEntryDesc PROC
;;;624    
;;;625    OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Subindex)
000000  b530              PUSH     {r4,r5,lr}
;;;626    {
000002  4602              MOV      r2,r0
;;;627        OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
;;;628        UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
000004  8994              LDRH     r4,[r2,#0xc]
000006  f3c42303          UBFX     r3,r4,#8,#4
;;;629    
;;;630        if ((objCode == OBJCODE_ARR)
00000a  2b08              CMP      r3,#8
00000c  d105              BNE      |L4.26|
;;;631    /*ET9300 Project Handler :(#if USE_SINGLE_PDO_MAPPING_ENTRY_DESCR) lines 739 to 741 deleted*/
;;;632    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 742 to 746 deleted*/
;;;633            )
;;;634        {
;;;635            /* object is an array */
;;;636            if ( Subindex == 0 )
00000e  b909              CBNZ     r1,|L4.20|
;;;637            {
;;;638                /* subindex 0 has a description */
;;;639                pEntry = &pObjEntry->pEntryDesc[0];
000010  6910              LDR      r0,[r2,#0x10]
000012  e007              B        |L4.36|
                  |L4.20|
;;;640            }
;;;641            else
;;;642            {
;;;643                /* and all other elements have the same description */
;;;644                pEntry = &pObjEntry->pEntryDesc[1];
000014  6914              LDR      r4,[r2,#0x10]
000016  1da0              ADDS     r0,r4,#6
000018  e004              B        |L4.36|
                  |L4.26|
;;;645            }
;;;646        }
;;;647        else
;;;648        {
;;;649    /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 763 to 771 deleted*/
;;;650            {
;;;651                /* object is a variable or a record return the corresponding entry */
;;;652                pEntry = &pObjEntry->pEntryDesc[Subindex];
00001a  eb010541          ADD      r5,r1,r1,LSL #1
00001e  6914              LDR      r4,[r2,#0x10]
000020  eb040045          ADD      r0,r4,r5,LSL #1
                  |L4.36|
;;;653            }
;;;654        }
;;;655    
;;;656        return pEntry;
;;;657    }
000024  bd30              POP      {r4,r5,pc}
;;;658    
                          ENDP


                          AREA ||i.OBJ_GetEntryOffset||, CODE, READONLY, ALIGN=1

                  OBJ_GetEntryOffset PROC
;;;686    
;;;687    UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
000000  b5f0              PUSH     {r4-r7,lr}
;;;688    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;689        UINT16 i;
;;;690        /* bitOffset will be initialized with the bit offset of subindex 1 */
;;;691        UINT16 bitOffset = 0;
000006  2100              MOVS     r1,#0
;;;692        UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
000008  89a8              LDRH     r0,[r5,#0xc]
00000a  f3c02603          UBFX     r6,r0,#8,#4
;;;693        OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
;;;694    
;;;695        
;;;696        if(subindex > 0)
00000e  2c00              CMP      r4,#0
000010  dd02              BLE      |L5.24|
;;;697        {
;;;698            /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
;;;699            bitOffset +=16;
000012  f1010010          ADD      r0,r1,#0x10
000016  b281              UXTH     r1,r0
                  |L5.24|
;;;700        }
;;;701    
;;;702        if (objCode == OBJCODE_VAR)
000018  2e07              CMP      r6,#7
00001a  d101              BNE      |L5.32|
;;;703        {
;;;704            return 0;
00001c  2000              MOVS     r0,#0
                  |L5.30|
;;;705        }
;;;706    
;;;707        for (i = 1; i <= subindex; i++)
;;;708        {
;;;709            /* get the entry description */
;;;710            if ((objCode == OBJCODE_ARR)
;;;711    /*ET9300 Project Handler :(#if USE_SINGLE_PDO_MAPPING_ENTRY_DESCR) lines 833 to 835 deleted*/
;;;712               )
;;;713               {
;;;714                pEntry = &pObjEntry->pEntryDesc[1];
;;;715               }
;;;716            else
;;;717            {
;;;718                pEntry = &pObjEntry->pEntryDesc[i];
;;;719            }
;;;720    
;;;721            switch (pEntry->DataType)
;;;722            {
;;;723            case    DEFTYPE_INTEGER16:
;;;724            case    DEFTYPE_UNSIGNED16:
;;;725            case    DEFTYPE_BITARR16:
;;;726            case    DEFTYPE_WORD:
;;;727            case    DEFTYPE_UNICODE_STRING:
;;;728            case    DEFTYPE_ARRAY_OF_INT :
;;;729    
;;;730    #if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
;;;731                /* the 16-bit variables in the structure are word-aligned,
;;;732                   align the actual bitOffset to a word */
;;;733                bitOffset = (bitOffset+15) & 0xFFF0;
;;;734    #endif
;;;735    
;;;736    
;;;737                if (i < subindex)
;;;738                {
;;;739                    if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
;;;740                        ||(pEntry->DataType == DEFTYPE_ARRAY_OF_INT))
;;;741                    {
;;;742                        bitOffset += pEntry->BitLength;
;;;743                    }
;;;744                    else
;;;745                    {
;;;746                        bitOffset += 16;
;;;747                    }
;;;748                }
;;;749                break;
;;;750            case    DEFTYPE_UNSIGNED32:
;;;751            case    DEFTYPE_INTEGER32:
;;;752            case    DEFTYPE_REAL32:
;;;753            case    DEFTYPE_BITARR32:
;;;754            case    DEFTYPE_DWORD:
;;;755            case    DEFTYPE_ARRAY_OF_DINT :
;;;756            case    DEFTYPE_ARRAY_OF_UDINT:
;;;757    #if OBJ_DWORD_ALIGN
;;;758                /* the 32-bit variables in the structure are dword-aligned,
;;;759                   align the actual bitOffset to a dword */
;;;760                bitOffset = (bitOffset+31) & 0xFFE0;
;;;761    #elif OBJ_WORD_ALIGN
;;;762                /* the 32-bit variables in the structure are word-aligned,
;;;763                   align the actual bitOffset to a word */
;;;764                bitOffset = (bitOffset+15) & 0xFFF0;
;;;765    #endif
;;;766    
;;;767                if (i < subindex)
;;;768                {
;;;769                    if((pEntry->DataType == DEFTYPE_ARRAY_OF_DINT)
;;;770                        ||(pEntry->DataType == DEFTYPE_ARRAY_OF_UDINT))
;;;771                    {
;;;772                        bitOffset += pEntry->BitLength;
;;;773                    }
;;;774                    else
;;;775                    {
;;;776                       bitOffset += 32;
;;;777                    }
;;;778                }
;;;779                break;
;;;780            
;;;781            case DEFTYPE_REAL64:
;;;782            case DEFTYPE_INTEGER64:
;;;783            case DEFTYPE_UNSIGNED64:
;;;784    #if OBJ_DWORD_ALIGN
;;;785                /* the 64-bit variables in the structure are dword-aligned,
;;;786                   align the actual bitOffset to a dword */
;;;787                bitOffset = (bitOffset + 31) & 0xFFE0;
;;;788    #elif OBJ_WORD_ALIGN
;;;789                /* the 64-bit variables in the structure are word-aligned,
;;;790                   align the actual bitOffset to a word */
;;;791                bitOffset = (bitOffset + 15) & 0xFFF0;
;;;792    #endif
;;;793    
;;;794                if (i < subindex)
;;;795                {
;;;796    
;;;797                    bitOffset += 64;
;;;798                }
;;;799                break;
;;;800            default:
;;;801                /* align the actual bitOffset to a byte */
;;;802                if (i < subindex)
;;;803                {
;;;804                    bitOffset += pEntry->BitLength;
;;;805                }
;;;806                break;
;;;807            }
;;;808        }
;;;809    
;;;810        return bitOffset;
;;;811    }
00001e  bdf0              POP      {r4-r7,pc}
                  |L5.32|
000020  2201              MOVS     r2,#1                 ;707
000022  e085              B        |L5.304|
                  |L5.36|
000024  2e08              CMP      r6,#8                 ;710
000026  d102              BNE      |L5.46|
000028  6928              LDR      r0,[r5,#0x10]         ;714
00002a  1d83              ADDS     r3,r0,#6              ;714
00002c  e004              B        |L5.56|
                  |L5.46|
00002e  eb020742          ADD      r7,r2,r2,LSL #1       ;718
000032  6928              LDR      r0,[r5,#0x10]         ;718
000034  eb000347          ADD      r3,r0,r7,LSL #1       ;718
                  |L5.56|
000038  8818              LDRH     r0,[r3,#0]            ;721
00003a  281b              CMP      r0,#0x1b              ;721
00003c  d063              BEQ      |L5.262|
00003e  dc12              BGT      |L5.102|
000040  2808              CMP      r0,#8                 ;721
000042  d041              BEQ      |L5.200|
000044  dc08              BGT      |L5.88|
000046  2803              CMP      r0,#3                 ;721
000048  d020              BEQ      |L5.140|
00004a  2804              CMP      r0,#4                 ;721
00004c  d03b              BEQ      |L5.198|
00004e  2806              CMP      r0,#6                 ;721
000050  d01d              BEQ      |L5.142|
000052  2807              CMP      r0,#7                 ;721
000054  d163              BNE      |L5.286|
000056  e035              B        |L5.196|
                  |L5.88|
000058  280b              CMP      r0,#0xb               ;721
00005a  d01b              BEQ      |L5.148|
00005c  2811              CMP      r0,#0x11              ;721
00005e  d050              BEQ      |L5.258|
000060  2815              CMP      r0,#0x15              ;721
000062  d15c              BNE      |L5.286|
000064  e04e              B        |L5.260|
                  |L5.102|
000066  282f              CMP      r0,#0x2f              ;721
000068  d02f              BEQ      |L5.202|
00006a  dc06              BGT      |L5.122|
00006c  281f              CMP      r0,#0x1f              ;721
00006e  d010              BEQ      |L5.146|
000070  2820              CMP      r0,#0x20              ;721
000072  d02b              BEQ      |L5.204|
000074  282e              CMP      r0,#0x2e              ;721
000076  d152              BNE      |L5.286|
000078  e00a              B        |L5.144|
                  |L5.122|
00007a  f5b07f18          CMP      r0,#0x260             ;721
00007e  d00a              BEQ      |L5.150|
000080  f2a02062          SUB      r0,r0,#0x262          ;721
000084  b318              CBZ      r0,|L5.206|
000086  2801              CMP      r0,#1                 ;721
000088  d149              BNE      |L5.286|
00008a  e021              B        |L5.208|
                  |L5.140|
00008c  bf00              NOP                            ;724
                  |L5.142|
00008e  bf00              NOP                            ;725
                  |L5.144|
000090  bf00              NOP                            ;726
                  |L5.146|
000092  bf00              NOP                            ;727
                  |L5.148|
000094  bf00              NOP                            ;728
                  |L5.150|
000096  f101000f          ADD      r0,r1,#0xf            ;733
00009a  f64f77f0          MOV      r7,#0xfff0            ;733
00009e  ea000107          AND      r1,r0,r7              ;733
0000a2  42a2              CMP      r2,r4                 ;737
0000a4  da0d              BGE      |L5.194|
0000a6  8818              LDRH     r0,[r3,#0]            ;739
0000a8  280b              CMP      r0,#0xb               ;739
0000aa  d003              BEQ      |L5.180|
0000ac  8818              LDRH     r0,[r3,#0]            ;740
0000ae  f5b07f18          CMP      r0,#0x260             ;740
0000b2  d103              BNE      |L5.188|
                  |L5.180|
0000b4  8858              LDRH     r0,[r3,#2]            ;742
0000b6  4408              ADD      r0,r0,r1              ;742
0000b8  b281              UXTH     r1,r0                 ;742
0000ba  e002              B        |L5.194|
                  |L5.188|
0000bc  f1010010          ADD      r0,r1,#0x10           ;746
0000c0  b281              UXTH     r1,r0                 ;746
                  |L5.194|
0000c2  e032              B        |L5.298|
                  |L5.196|
0000c4  bf00              NOP                            ;751
                  |L5.198|
0000c6  bf00              NOP                            ;752
                  |L5.200|
0000c8  bf00              NOP                            ;753
                  |L5.202|
0000ca  bf00              NOP                            ;754
                  |L5.204|
0000cc  bf00              NOP                            ;755
                  |L5.206|
0000ce  bf00              NOP                            ;756
                  |L5.208|
0000d0  f101001f          ADD      r0,r1,#0x1f           ;760
0000d4  f64f77e0          MOV      r7,#0xffe0            ;760
0000d8  ea000107          AND      r1,r0,r7              ;760
0000dc  42a2              CMP      r2,r4                 ;767
0000de  da0f              BGE      |L5.256|
0000e0  8818              LDRH     r0,[r3,#0]            ;769
0000e2  f2402762          MOV      r7,#0x262             ;769
0000e6  42b8              CMP      r0,r7                 ;769
0000e8  d003              BEQ      |L5.242|
0000ea  8818              LDRH     r0,[r3,#0]            ;770
0000ec  1c7f              ADDS     r7,r7,#1              ;770
0000ee  42b8              CMP      r0,r7                 ;770
0000f0  d103              BNE      |L5.250|
                  |L5.242|
0000f2  8858              LDRH     r0,[r3,#2]            ;772
0000f4  4408              ADD      r0,r0,r1              ;772
0000f6  b281              UXTH     r1,r0                 ;772
0000f8  e002              B        |L5.256|
                  |L5.250|
0000fa  f1010020          ADD      r0,r1,#0x20           ;776
0000fe  b281              UXTH     r1,r0                 ;776
                  |L5.256|
000100  e013              B        |L5.298|
                  |L5.258|
000102  bf00              NOP                            ;782
                  |L5.260|
000104  bf00              NOP                            ;783
                  |L5.262|
000106  f101001f          ADD      r0,r1,#0x1f           ;787
00010a  f64f77e0          MOV      r7,#0xffe0            ;787
00010e  ea000107          AND      r1,r0,r7              ;787
000112  42a2              CMP      r2,r4                 ;794
000114  da02              BGE      |L5.284|
000116  f1010040          ADD      r0,r1,#0x40           ;797
00011a  b281              UXTH     r1,r0                 ;797
                  |L5.284|
00011c  e005              B        |L5.298|
                  |L5.286|
00011e  42a2              CMP      r2,r4                 ;802
000120  da02              BGE      |L5.296|
000122  8858              LDRH     r0,[r3,#2]            ;804
000124  4408              ADD      r0,r0,r1              ;804
000126  b281              UXTH     r1,r0                 ;804
                  |L5.296|
000128  bf00              NOP                            ;806
                  |L5.298|
00012a  bf00              NOP                            ;749
00012c  1c50              ADDS     r0,r2,#1              ;707
00012e  b282              UXTH     r2,r0                 ;707
                  |L5.304|
000130  42a2              CMP      r2,r4                 ;707
000132  f77faf77          BLE      |L5.36|
000136  4608              MOV      r0,r1                 ;810
000138  e771              B        |L5.30|
;;;812    
                          ENDP


                          AREA ||i.OBJ_GetNoOfObjects||, CODE, READONLY, ALIGN=1

                  OBJ_GetNoOfObjects PROC
;;;355    
;;;356    UINT16    OBJ_GetNoOfObjects(UINT8 listType)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;357    {
000004  4605              MOV      r5,r0
;;;358        /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
;;;359           see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
;;;360           all objects has to be counted */
;;;361        
;;;362        UINT16 listFlags = 0x0020 << listType;
000006  2020              MOVS     r0,#0x20
000008  40a8              LSLS     r0,r0,r5
00000a  fa1ff980          UXTH     r9,r0
;;;363        
;;;364        /* set pObjEntry to the beginning of the object dictionary */
;;;365        OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
00000e  f7fffffe          BL       COE_GetObjectDictionary
000012  4604              MOV      r4,r0
;;;366        UINT16 n = 0;
000014  f04f0800          MOV      r8,#0
;;;367    
;;;368    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 416 to 422 deleted*/
;;;369    
;;;370        while (pObjEntry != NULL)
000018  e01f              B        |L6.90|
                  |L6.26|
;;;371    /*ET9300 Project Handler :(#if !STATIC_OBJECT_DIC #else) lines 426 to 428 deleted*/
;;;372        {
;;;373            /* count the objects of the requested list type */
;;;374            if ( pObjEntry->Index >= 0x1000 )
00001a  8920              LDRH     r0,[r4,#8]
00001c  f5b05f80          CMP      r0,#0x1000
000020  db1a              BLT      |L6.88|
;;;375            {
;;;376                UINT8 t = listType;
000022  462e              MOV      r6,r5
;;;377                if ( t )
000024  b196              CBZ      r6,|L6.76|
;;;378                {
;;;379                    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
000026  f894a00c          LDRB     r10,[r4,#0xc]
;;;380                    UINT16 i = 0;
00002a  2700              MOVS     r7,#0
;;;381    
;;;382                    while ( t && i <= maxSubindex )
00002c  e00a              B        |L6.68|
                  |L6.46|
;;;383                    {
;;;384                        if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
00002e  b2f9              UXTB     r1,r7
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       OBJ_GetEntryDesc
000036  8880              LDRH     r0,[r0,#4]
000038  ea000009          AND      r0,r0,r9
00003c  b100              CBZ      r0,|L6.64|
;;;385                        {
;;;386                            t = 0;
00003e  2600              MOVS     r6,#0
                  |L6.64|
;;;387                        }
;;;388                        i++;
000040  1c78              ADDS     r0,r7,#1
000042  b287              UXTH     r7,r0
                  |L6.68|
000044  b10e              CBZ      r6,|L6.74|
000046  4557              CMP      r7,r10                ;382
000048  ddf1              BLE      |L6.46|
                  |L6.74|
;;;389                    }
;;;390                }
00004a  bf00              NOP      
                  |L6.76|
;;;391                if ( !t )
00004c  b91e              CBNZ     r6,|L6.86|
;;;392                {
;;;393                    /* object from listType found */
;;;394                    n++;
00004e  f1080001          ADD      r0,r8,#1
000052  fa1ff880          UXTH     r8,r0
                  |L6.86|
;;;395                }
;;;396            }
000056  bf00              NOP      
                  |L6.88|
;;;397            /* next object in object dictionary */
;;;398            pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
000058  6864              LDR      r4,[r4,#4]
                  |L6.90|
00005a  2c00              CMP      r4,#0                 ;370
00005c  d1dd              BNE      |L6.26|
;;;399    /*ET9300 Project Handler :(#if !STATIC_OBJECT_DIC #else) lines 457 to 459 deleted*/
;;;400        }
;;;401    
;;;402        return n;
00005e  4640              MOV      r0,r8
;;;403    }
000060  e8bd87f0          POP      {r4-r10,pc}
;;;404    
                          ENDP


                          AREA ||i.OBJ_GetObjDesc||, CODE, READONLY, ALIGN=1

                  OBJ_GetObjDesc PROC
;;;670    
;;;671    OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
000000  4601              MOV      r1,r0
;;;672    {
;;;673        return &pObjEntry->ObjDesc;
000002  f101000a          ADD      r0,r1,#0xa
;;;674    }
000006  4770              BX       lr
;;;675    
                          ENDP


                          AREA ||i.OBJ_GetObjectHandle||, CODE, READONLY, ALIGN=1

                  OBJ_GetObjectHandle PROC
;;;190    
;;;191    OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
000000  b570              PUSH     {r4-r6,lr}
;;;192    {
000002  4605              MOV      r5,r0
;;;193        OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
000004  f7fffffe          BL       COE_GetObjectDictionary
000008  4604              MOV      r4,r0
;;;194    
;;;195        while (pObjEntry!= NULL)
00000a  e005              B        |L8.24|
                  |L8.12|
;;;196    /*ET9300 Project Handler :(#if !STATIC_OBJECT_DIC #else) lines 201 to 203 deleted*/
;;;197        {
;;;198            
;;;199            if (pObjEntry->Index == index)
00000c  8920              LDRH     r0,[r4,#8]
00000e  42a8              CMP      r0,r5
000010  d101              BNE      |L8.22|
;;;200            {
;;;201                return pObjEntry;
000012  4620              MOV      r0,r4
                  |L8.20|
;;;202            }
;;;203            pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
;;;204    /*ET9300 Project Handler :(#if !STATIC_OBJECT_DIC #else) lines 212 to 214 deleted*/
;;;205        }
;;;206        return 0;
;;;207    }
000014  bd70              POP      {r4-r6,pc}
                  |L8.22|
000016  6864              LDR      r4,[r4,#4]            ;203
                  |L8.24|
000018  2c00              CMP      r4,#0                 ;195
00001a  d1f7              BNE      |L8.12|
00001c  2000              MOVS     r0,#0                 ;206
00001e  e7f9              B        |L8.20|
;;;208    
                          ENDP


                          AREA ||i.OBJ_GetObjectLength||, CODE, READONLY, ALIGN=1

                  OBJ_GetObjectLength PROC
;;;222    *////////////////////////////////////////////////////////////////////////////////////////
;;;223    UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 bCompleteAccess)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;224    {
000004  4684              MOV      r12,r0
000006  461f              MOV      r7,r3
;;;225        /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
;;;226        UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
000008  8990              LDRH     r0,[r2,#0xc]
00000a  f3c02403          UBFX     r4,r0,#8,#4
;;;227        
;;;228        UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
00000e  7b15              LDRB     r5,[r2,#0xc]
;;;229        UINT32 size = 0;
000010  2300              MOVS     r3,#0
;;;230    
;;;231        if ( bCompleteAccess )
000012  b32f              CBZ      r7,|L9.96|
;;;232        {
;;;233            if ( objCode == OBJCODE_VAR )
000014  2c07              CMP      r4,#7
000016  d102              BNE      |L9.30|
;;;234            {
;;;235                return 0;
000018  2000              MOVS     r0,#0
                  |L9.26|
;;;236            }
;;;237            else if ((objCode == OBJCODE_ARR)
;;;238    /*ET9300 Project Handler :(#if USE_SINGLE_PDO_MAPPING_ENTRY_DESCR) lines 249 to 251 deleted*/
;;;239    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 252 to 255 deleted*/
;;;240                )
;;;241            {
;;;242    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 258 to 270 deleted*/
;;;243    
;;;244                /* we have to get the maxSubindex from the actual value of subindex 0,
;;;245                    which is stored as UINT16 at the beginning of the object's variable */
;;;246                maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
;;;247    
;;;248    
;;;249                size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
;;;250    
;;;251    /* no padding required: Bit entries within an array object may overlap byte borders*/
;;;252    
;;;253                /* we have to convert the size in bytes */
;;;254                size = BIT2BYTE(size);
;;;255    
;;;256                if ( subindex == 0 )
;;;257                {
;;;258                    /* add size for subindex 0 (is transmitted as UINT16) */
;;;259                    size += 2;
;;;260                }
;;;261                return size;
;;;262            }
;;;263            else
;;;264            {
;;;265    /*ECATCHANGE_START(V5.13) COE1*/
;;;266                UINT16 i;
;;;267    /*ECATCHANGE_END(V5.13) COE1*/
;;;268    
;;;269                /* add the sizes of all entries */
;;;270                for (i = 1; i <= maxSubindex; i++)
;;;271                {
;;;272                    size += pObjEntry->pEntryDesc[i].BitLength;
;;;273                }
;;;274                /* we have to convert the size in bytes */
;;;275                size = BIT2BYTE(size);
;;;276    
;;;277                if ( subindex == 0 )
;;;278                {
;;;279                    /* add size for subindex 0 (is transmitted as UINT16) */
;;;280                    size += 2;
;;;281                }
;;;282                return size;
;;;283            }
;;;284        }
;;;285        else
;;;286        {
;;;287            if ( objCode == OBJCODE_VAR )
;;;288            {
;;;289    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 318 to 326 deleted*/
;;;290    
;;;291                return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
;;;292    
;;;293            }
;;;294            else if ( subindex == 0 )
;;;295            {
;;;296                /* for single access subindex 0 is transmitted as UINT8 */
;;;297                return 1;
;;;298            }
;;;299            else if((objCode == OBJCODE_ARR)
;;;300    /*ET9300 Project Handler :(#if USE_SINGLE_PDO_MAPPING_ENTRY_DESCR) lines 337 to 339 deleted*/
;;;301    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 340 to 343 deleted*/
;;;302                )
;;;303            {
;;;304                return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
;;;305            }
;;;306            else
;;;307            {
;;;308    /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 350 to 356 deleted*/
;;;309                {
;;;310                    if (maxSubindex < subindex)
;;;311                    {
;;;312                        return 0;
;;;313    
;;;314                    }
;;;315                    else
;;;316                    {
;;;317                        return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
;;;318                    }
;;;319                }
;;;320            }
;;;321        }
;;;322    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L9.30|
00001e  2c08              CMP      r4,#8                 ;237
000020  d10b              BNE      |L9.58|
000022  6990              LDR      r0,[r2,#0x18]         ;246
000024  7805              LDRB     r5,[r0,#0]            ;246
000026  6910              LDR      r0,[r2,#0x10]         ;249
000028  8900              LDRH     r0,[r0,#8]            ;249
00002a  fb00f305          MUL      r3,r0,r5              ;249
00002e  1dd8              ADDS     r0,r3,#7              ;254
000030  08c3              LSRS     r3,r0,#3              ;254
000032  b901              CBNZ     r1,|L9.54|
000034  1c9b              ADDS     r3,r3,#2              ;259
                  |L9.54|
000036  4618              MOV      r0,r3                 ;261
000038  e7ef              B        |L9.26|
                  |L9.58|
00003a  2601              MOVS     r6,#1                 ;270
00003c  e008              B        |L9.80|
                  |L9.62|
00003e  eb060846          ADD      r8,r6,r6,LSL #1       ;272
000042  6910              LDR      r0,[r2,#0x10]         ;272
000044  eb000048          ADD      r0,r0,r8,LSL #1       ;272
000048  8840              LDRH     r0,[r0,#2]            ;272
00004a  4403              ADD      r3,r3,r0              ;272
00004c  1c70              ADDS     r0,r6,#1              ;270
00004e  b286              UXTH     r6,r0                 ;270
                  |L9.80|
000050  42ae              CMP      r6,r5                 ;270
000052  ddf4              BLE      |L9.62|
000054  1dd8              ADDS     r0,r3,#7              ;275
000056  08c3              LSRS     r3,r0,#3              ;275
000058  b901              CBNZ     r1,|L9.92|
00005a  1c9b              ADDS     r3,r3,#2              ;280
                  |L9.92|
00005c  4618              MOV      r0,r3                 ;282
00005e  e7dc              B        |L9.26|
                  |L9.96|
000060  2c07              CMP      r4,#7                 ;287
000062  d104              BNE      |L9.110|
000064  6910              LDR      r0,[r2,#0x10]         ;291
000066  8840              LDRH     r0,[r0,#2]            ;291
000068  1dc0              ADDS     r0,r0,#7              ;291
00006a  10c0              ASRS     r0,r0,#3              ;291
00006c  e7d5              B        |L9.26|
                  |L9.110|
00006e  b909              CBNZ     r1,|L9.116|
000070  2001              MOVS     r0,#1                 ;297
000072  e7d2              B        |L9.26|
                  |L9.116|
000074  2c08              CMP      r4,#8                 ;299
000076  d104              BNE      |L9.130|
000078  6910              LDR      r0,[r2,#0x10]         ;304
00007a  8900              LDRH     r0,[r0,#8]            ;304
00007c  1dc0              ADDS     r0,r0,#7              ;304
00007e  10c0              ASRS     r0,r0,#3              ;304
000080  e7cb              B        |L9.26|
                  |L9.130|
000082  428d              CMP      r5,r1                 ;310
000084  da01              BGE      |L9.138|
000086  2000              MOVS     r0,#0                 ;312
000088  e7c7              B        |L9.26|
                  |L9.138|
00008a  eb010641          ADD      r6,r1,r1,LSL #1       ;317
00008e  6910              LDR      r0,[r2,#0x10]         ;317
000090  eb000046          ADD      r0,r0,r6,LSL #1       ;317
000094  8840              LDRH     r0,[r0,#2]            ;317
000096  1dc0              ADDS     r0,r0,#7              ;317
000098  10c0              ASRS     r0,r0,#3              ;317
00009a  e7be              B        |L9.26|
;;;323    
                          ENDP


                          AREA ||i.OBJ_GetObjectList||, CODE, READONLY, ALIGN=2

                  OBJ_GetObjectList PROC
;;;419    *////////////////////////////////////////////////////////////////////////////////////////
;;;420    UINT16    OBJ_GetObjectList(UINT16 listType, UINT16 *pIndex, UINT16 size, UINT16 MBXMEM *pData,UINT8 *pAbort)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;421    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8ddb030          LDR      r11,[sp,#0x30]
;;;422        /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
;;;423           see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
;;;424           all objects has to be counted */
;;;425        UINT16 listFlags = 0x0020 << listType;
000010  2020              MOVS     r0,#0x20
000012  40a8              LSLS     r0,r0,r5
000014  b280              UXTH     r0,r0
000016  9001              STR      r0,[sp,#4]
;;;426        OBJCONST TOBJECT OBJMEM * pObjEntry;
;;;427    
;;;428    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 488 to 500 deleted*/
;;;429    
;;;430        if ( pIndex[0] == 0x1000 )
000018  8830              LDRH     r0,[r6,#0]
00001a  f5b05f80          CMP      r0,#0x1000
00001e  d10a              BNE      |L10.54|
;;;431        {
;;;432            /* beginning of object list, set pObjEntry to the beginning of the object dictionary */
;;;433           pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
000020  f7fffffe          BL       COE_GetObjectDictionary
000024  4604              MOV      r4,r0
;;;434            // set abort code if no object dictionary is available
;;;435            if((pObjEntry == NULL) && (pAbort != NULL))
000026  b944              CBNZ     r4,|L10.58|
000028  f1bb0f00          CMP      r11,#0
00002c  d005              BEQ      |L10.58|
;;;436            {
;;;437                *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
00002e  201b              MOVS     r0,#0x1b
000030  f88b0000          STRB     r0,[r11,#0]
000034  e001              B        |L10.58|
                  |L10.54|
;;;438            }
;;;439        }
;;;440        else
;;;441        {
;;;442            /* next fragment, the next object to be handled was stored in pSdoInfoObjEntry */
;;;443            pObjEntry = pSdoInfoObjEntry;
000036  4821              LDR      r0,|L10.188|
000038  6804              LDR      r4,[r0,#0]  ; pSdoInfoObjEntry
                  |L10.58|
;;;444        }
;;;445    
;;;446        if ( pObjEntry != NULL )
00003a  2c00              CMP      r4,#0
00003c  d032              BEQ      |L10.164|
;;;447        {
;;;448            while (pObjEntry != NULL && size > 1 )
00003e  e02e              B        |L10.158|
                  |L10.64|
;;;449    /*ET9300 Project Handler :(#if !STATIC_OBJECT_DIC #else) lines 522 to 524 deleted*/
;;;450            {
;;;451                /* get the next index of the requested object list if there is enough space in the mailbox buffer */
;;;452                if ( pObjEntry->Index >= 0x1000 )
000040  8920              LDRH     r0,[r4,#8]
000042  f5b05f80          CMP      r0,#0x1000
000046  db29              BLT      |L10.156|
;;;453                {
;;;454                    /* UINT8 was changed to UINT16 */
;;;455                    UINT16 t = listType;
000048  46a9              MOV      r9,r5
;;;456                    if ( t )
00004a  f1b90f00          CMP      r9,#0
00004e  d01a              BEQ      |L10.134|
;;;457                    {
;;;458                        UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
000050  7b20              LDRB     r0,[r4,#0xc]
000052  9000              STR      r0,[sp,#0]
;;;459    /*ECATCHANGE_START(V5.13) COE1*/
;;;460                        UINT16 i = 0;
000054  f04f0a00          MOV      r10,#0
;;;461    /*ECATCHANGE_END(V5.13) COE1*/
;;;462    
;;;463                        while ( t && i <= maxSubindex )
000058  e00e              B        |L10.120|
                  |L10.90|
;;;464                        {
;;;465                            if ( OBJ_GetEntryDesc(pObjEntry, (UINT8)i)->ObjAccess & listFlags )
00005a  f00a01ff          AND      r1,r10,#0xff
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       OBJ_GetEntryDesc
000064  8880              LDRH     r0,[r0,#4]
000066  9901              LDR      r1,[sp,#4]
000068  4008              ANDS     r0,r0,r1
00006a  b108              CBZ      r0,|L10.112|
;;;466                            {
;;;467                                t = 0;
00006c  f04f0900          MOV      r9,#0
                  |L10.112|
;;;468                            }
;;;469                            i++;
000070  f10a0001          ADD      r0,r10,#1
000074  fa1ffa80          UXTH     r10,r0
                  |L10.120|
000078  f1b90f00          CMP      r9,#0                 ;463
00007c  d002              BEQ      |L10.132|
00007e  9800              LDR      r0,[sp,#0]            ;463
000080  4582              CMP      r10,r0                ;463
000082  ddea              BLE      |L10.90|
                  |L10.132|
;;;470                        }
;;;471                    }
000084  bf00              NOP      
                  |L10.134|
;;;472                    if ( !t )
000086  f1b90f00          CMP      r9,#0
00008a  d106              BNE      |L10.154|
;;;473                    {
;;;474                        /* store the index in the mailbox buffer */
;;;475                        *pData = SWAPWORD(pObjEntry->Index);
00008c  8920              LDRH     r0,[r4,#8]
00008e  f8a80000          STRH     r0,[r8,#0]
;;;476                        pData++;
000092  f1080802          ADD      r8,r8,#2
;;;477                        size -= 2;
000096  1eb8              SUBS     r0,r7,#2
000098  b287              UXTH     r7,r0
                  |L10.154|
;;;478                    }
;;;479                }
00009a  bf00              NOP      
                  |L10.156|
;;;480            pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
00009c  6864              LDR      r4,[r4,#4]
                  |L10.158|
00009e  b10c              CBZ      r4,|L10.164|
0000a0  2f01              CMP      r7,#1                 ;448
0000a2  dccd              BGT      |L10.64|
                  |L10.164|
;;;481    /*ET9300 Project Handler :(#if !STATIC_OBJECT_DIC #else) lines 557 to 559 deleted*/
;;;482            }
;;;483        }
;;;484    
;;;485            /* return the next Index to be handled */
;;;486            if(pObjEntry != NULL)
0000a4  b114              CBZ      r4,|L10.172|
;;;487            {
;;;488                pIndex[0] = pObjEntry->Index;
0000a6  8920              LDRH     r0,[r4,#8]
0000a8  8030              STRH     r0,[r6,#0]
0000aa  e002              B        |L10.178|
                  |L10.172|
;;;489            }
;;;490            else
;;;491            {
;;;492                /*last entry reached*/
;;;493                pIndex[0] = 0xFFFF;
0000ac  f64f70ff          MOV      r0,#0xffff
0000b0  8030              STRH     r0,[r6,#0]
                  |L10.178|
;;;494            }
;;;495    
;;;496        /* store object description pointer and index for next fragment */
;;;497        pSdoInfoObjEntry = pObjEntry;
0000b2  4802              LDR      r0,|L10.188|
0000b4  6004              STR      r4,[r0,#0]  ; pSdoInfoObjEntry
;;;498    
;;;499        /* return the size of the available mailbox buffer which was not copied to */
;;;500        return size;
0000b6  4638              MOV      r0,r7
;;;501    }
0000b8  e8bd9ffc          POP      {r2-r12,pc}
;;;502    
                          ENDP

                  |L10.188|
                          DCD      pSdoInfoObjEntry

                          AREA ||i.OBJ_Read||, CODE, READONLY, ALIGN=2

                  OBJ_Read PROC
;;;903    
;;;904    UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;905    {
000004  b087              SUB      sp,sp,#0x1c
000006  4689              MOV      r9,r1
000008  461f              MOV      r7,r3
00000a  e9dd4a14          LDRD     r4,r10,[sp,#0x50]
;;;906        UINT16 i = subindex;
00000e  46c8              MOV      r8,r9
;;;907        /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
;;;908        UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
000010  89b8              LDRH     r0,[r7,#0xc]
000012  f3c02003          UBFX     r0,r0,#8,#4
000016  9006              STR      r0,[sp,#0x18]
;;;909        UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
000018  7b38              LDRB     r0,[r7,#0xc]
00001a  9005              STR      r0,[sp,#0x14]
;;;910        OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
;;;911        /* lastSubindex is used for complete access to make loop over the requested entries
;;;912        to be read, we initialize this variable with the requested subindex that only
;;;913        one loop will be done for a single access */
;;;914        UINT16 lastSubindex = subindex;
00001c  f8cd9010          STR      r9,[sp,#0x10]
;;;915    
;;;916        if ( objCode != OBJCODE_VAR && index >= 0x1000 )
000020  9806              LDR      r0,[sp,#0x18]
000022  2807              CMP      r0,#7
000024  d006              BEQ      |L11.52|
000026  9807              LDR      r0,[sp,#0x1c]
000028  f5b05f80          CMP      r0,#0x1000
00002c  db02              BLT      |L11.52|
;;;917        {
;;;918            /* if the object is an array or record we have to get the maxSubindex from the
;;;919            actual value of subindex 0, which is stored as UINT16 at the beginning of the
;;;920            object's variable */
;;;921            maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
00002e  69b8              LDR      r0,[r7,#0x18]
000030  7800              LDRB     r0,[r0,#0]
000032  9005              STR      r0,[sp,#0x14]
                  |L11.52|
;;;922    
;;;923    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1067 to 1080 deleted*/
;;;924        }
;;;925    
;;;926        if ( bCompleteAccess )
000034  f1ba0f00          CMP      r10,#0
000038  d00d              BEQ      |L11.86|
;;;927        {
;;;928            if ( objCode == OBJCODE_VAR || index < 0x1000 )
00003a  9806              LDR      r0,[sp,#0x18]
00003c  2807              CMP      r0,#7
00003e  d003              BEQ      |L11.72|
000040  9807              LDR      r0,[sp,#0x1c]
000042  f5b05f80          CMP      r0,#0x1000
000046  da03              BGE      |L11.80|
                  |L11.72|
;;;929            {
;;;930                /* complete access is not supported with simple objects or ENUM descriptions */
;;;931                return ABORTIDX_UNSUPPORTED_ACCESS;
000048  2005              MOVS     r0,#5
                  |L11.74|
;;;932            }
;;;933    
;;;934    
;;;935            /* we read until the maximum subindex */
;;;936            lastSubindex = maxSubindex;
;;;937        }
;;;938        else
;;;939            if ( subindex > maxSubindex )
;;;940            {
;;;941                /* the maximum subindex is reached */
;;;942                return ABORTIDX_SUBINDEX_NOT_EXISTING;
;;;943            }
;;;944            else
;;;945            {
;;;946                /* get the corresponding entry description */
;;;947                pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
;;;948    
;;;949                /*Check access only for non-align entries*/
;;;950                if(pEntry->ObjAccess != 0x0)
;;;951                {
;;;952                    /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
;;;953                    by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
;;;954                    if (0 == (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)))
;;;955                    {
;;;956                        /* we don't have read access */
;;;957                        if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
;;;958                        {
;;;959                            /* it is a write only entry */
;;;960                            return ABORTIDX_WRITE_ONLY_ENTRY;
;;;961                        }
;;;962                        else
;;;963                        {
;;;964                            /* we don't have read access in this state */
;;;965                            return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
;;;966                        }
;;;967                    }
;;;968                }
;;;969                else
;;;970                {
;;;971                    return ABORTIDX_UNSUPPORTED_ACCESS;
;;;972                }
;;;973    
;;;974    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1133 to 1140 deleted*/
;;;975            }
;;;976    
;;;977        /* ECATCHANGE_START(V5.13) COE4*/
;;;978            if (pAPPL_CoeReadInd != NULL)
;;;979            {
;;;980                pAPPL_CoeReadInd(index, subindex, bCompleteAccess);
;;;981            }
;;;982            /* ECATCHANGE_END(V5.13) COE4*/
;;;983    
;;;984            if ( pObjEntry->Read != NULL )
;;;985            {
;;;986                /* Read function is defined, we call the object specific read function */
;;;987                return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
;;;988            }
;;;989            else if ( index < 0x1000 && subindex != 0 )
;;;990            {
;;;991                /* an ENUM description is read */
;;;992                UINT16 size;
;;;993                UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
;;;994                CHAR **p;
;;;995    
;;;996                /* we get the corresponding entry description */
;;;997                pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
;;;998                size = BIT2BYTE(pEntry->BitLength);
;;;999    
;;;1000               p = (CHAR **) pVarPtr;
;;;1001               pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
;;;1002   
;;;1003               /*ECATCHANGE_START(V5.13) */
;;;1004               if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
;;;1005               {
;;;1006                   /*enum is stored at an odd word address*/
;;;1007   /*ECATCHANGE_END(V5.13) */
;;;1008                   UINT16 cnt = 0;
;;;1009   
;;;1010                   //get last even WORD address
;;;1011                   pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
;;;1012   
;;;1013                   for(cnt = 0; cnt < (size / 2);cnt++)
;;;1014                   {
;;;1015                       //clear destination buffer
;;;1016                       pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
;;;1017                       pData[0] |= (pVarPtr[1] & 0xFF) << 8;
;;;1018   
;;;1019   /*ET9300 Project Handler :(#if (BIG_ENDIAN_16BIT || BIG_ENDIAN_FORMAT)) lines 1186 to 1188 deleted*/
;;;1020                       pData++;
;;;1021                       pVarPtr++;
;;;1022                   }
;;;1023   
;;;1024                   if((size % 2) == 1)
;;;1025                   {
;;;1026                       pData[0] &= 0xFF00; //Clear last Byte
;;;1027                       pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
;;;1028                   }
;;;1029               }
;;;1030               else
;;;1031               {
;;;1032               // Get enum value (first 32Bit)
;;;1033   /*ECATCHANGE_START(V5.13) */
;;;1034   /*ET9300 Project Handler :(#if MEMORY_UNIT_16BIT) lines 1204 to 1210 deleted*/
;;;1035   
;;;1036   /*ET9300 Project Handler :(#if (BIG_ENDIAN_16BIT || BIG_ENDIAN_FORMAT)) lines 1212 to 1215 deleted*/
;;;1037               pData[0] = pVarPtr[0];
;;;1038               pData[1] = pVarPtr[1];
;;;1039               pData += 2;
;;;1040               pVarPtr += 2;
;;;1041   /*ECATCHANGE_END(V5.13) */
;;;1042   
;;;1043               // Get enum description
;;;1044               OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
;;;1045               }
;;;1046           }
;;;1047           else
;;;1048           {
;;;1049               UINT8 bRead = 0x0;
;;;1050               UINT8 result = 0;
;;;1051   
;;;1052   
;;;1053               /* a variable object is read */
;;;1054               for (i = subindex; i <= lastSubindex; i++)
;;;1055               {
;;;1056                   /* if only a single entry is requested, this loop will only be done once */
;;;1057                   UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
;;;1058                   UINT16 bitOffset = 0;
;;;1059   
;;;1060                   
;;;1061                   if (i == 0)
;;;1062                   {
;;;1063                       /* subindex 0 is requested, the entry's data is at the beginning of the object's variable */
;;;1064                   }
;;;1065                   else if ( index >= 0x1000 )
;;;1066                   {
;;;1067                       /* subindex 1-n of an variable object is requested, we get the offset of the variable here */
;;;1068                       bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
;;;1069                   }
;;;1070   
;;;1071                   /* we increment the variable pointer to the corresponding word address */
;;;1072                   pVarPtr += (bitOffset >> 4);
;;;1073   
;;;1074                   /* get the corresponding entry description */
;;;1075                   pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
;;;1076                   if (0 != (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)) )
;;;1077                   {
;;;1078                       if ( i == subindex                                     /* requested entry */
;;;1079                           || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
;;;1080                       {
;;;1081                           UINT16 bitMask;
;;;1082   
;;;1083                           /* we have to copy the entry */
;;;1084                           if ( i == 0 && objCode != OBJCODE_VAR )
;;;1085                           {
;;;1086                               /* we read subindex 0 of an array or record */
;;;1087   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1270 to 1276 deleted*/
;;;1088                               {
;;;1089                                   pData[0] = SWAPWORD((UINT16)maxSubindex);
;;;1090                               }
;;;1091   
;;;1092                               /* we increment the destination pointer by 2 because the subindex 0 will be
;;;1093                               transmitted as UINT16 for a complete access */
;;;1094                               pData++;
;;;1095                           }
;;;1096                           else
;;;1097                           {
;;;1098                               UINT16 dataType = pEntry->DataType;
;;;1099                               
;;;1100                               if (pEntry->DataType >= 0x700)
;;;1101                               {
;;;1102                                   /* the ENUM data types are defined from index 0x700 in this example
;;;1103                                   convert in standard data type for the read access */
;;;1104                                   if ( pEntry->BitLength <= 8 )
;;;1105                                   {
;;;1106                                       dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
;;;1107                                   }
;;;1108                                   else if ( pEntry->BitLength == 16 )
;;;1109                                   {
;;;1110                                       dataType = DEFTYPE_UNSIGNED16;
;;;1111                                   }
;;;1112                                   else if ( pEntry->BitLength == 32 )
;;;1113                                   {
;;;1114                                       dataType = DEFTYPE_UNSIGNED32;
;;;1115                                   }
;;;1116                               }
;;;1117   
;;;1118                               switch (dataType)
;;;1119                               {
;;;1120                               case DEFTYPE_NULL:
;;;1121                                   if(bCompleteAccess)
;;;1122                                   {
;;;1123                                       /*Handle alignment entry*/
;;;1124                                       if (((pEntry->BitLength & 0xF) > 0)
;;;1125                                           && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
;;;1126                                       {
;;;1127                                           /* we have reached the UINT16 border */
;;;1128                                           pData++;
;;;1129                                       }
;;;1130   
;;;1131                                       /*increment WORD offset*/
;;;1132                                       pData += ((pEntry->BitLength & 0xF0) >> 4);
;;;1133                                   }
;;;1134                                   else
;;;1135                                   {
;;;1136                                       return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
;;;1137                                   }
;;;1138                                   break;
;;;1139                               case     DEFTYPE_BOOLEAN:
;;;1140                               case     DEFTYPE_BIT1:
;;;1141                               case     DEFTYPE_BIT2:
;;;1142                               case     DEFTYPE_BIT3:
;;;1143                               case     DEFTYPE_BIT4:
;;;1144                               case     DEFTYPE_BIT5:
;;;1145                               case     DEFTYPE_BIT6:
;;;1146                               case     DEFTYPE_BIT7:
;;;1147                               case     DEFTYPE_BIT8:
;;;1148   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1337 to 1348 deleted*/
;;;1149                               case     DEFTYPE_BITARR8:
;;;1150                                   /* in this example the objects are defined in that way,
;;;1151                                   that the bit types are always inside a 16-bit field,
;;;1152                                   and they shall not overlap a byte border*/
;;;1153                               case    DEFTYPE_INTEGER8:
;;;1154                               case    DEFTYPE_UNSIGNED8:
;;;1155                               case    DEFTYPE_BYTE :
;;;1156                                   {
;;;1157                                       /* depending on the bitOffset we have to copy the Hi or the Lo-Byte */
;;;1158                                       UINT16 TmpValue = 0x0000;
;;;1159   
;;;1160                                       
;;;1161                                       bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
;;;1162   
;;;1163                                       /*Swap object data (if required); all masks and offsets are defined for little endian format*/
;;;1164                                       TmpValue = SWAPWORD(pVarPtr[0]);
;;;1165   
;;;1166                                       /*Clear pData if the first bits within the WORD memory will be copied*/
;;;1167                                       if ((bitOffset & 0x0F) == 0) 
;;;1168                                       {
;;;1169                                           pData[0] = 0;
;;;1170                                       }
;;;1171   
;;;1172                                       pData[0] = SWAPWORD(pData[0]);
;;;1173   
;;;1174                                       if (bCompleteAccess) 
;;;1175                                       {
;;;1176                                           /*shifting is not required for Complete access because the bits are set to the correct offset by the master*/
;;;1177                                           pData[0] |= TmpValue & bitMask;
;;;1178                                       }
;;;1179                                       else
;;;1180                                       {
;;;1181                                           /*Shift Bits to the beginning of the mailbox memory*/
;;;1182                                           pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
;;;1183                                       }
;;;1184   
;;;1185                                       pData[0] = SWAPWORD(pData[0]);
;;;1186                                       if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
;;;1187                                       {
;;;1188                                           /* we have reached the UINT16 border */
;;;1189                                           pData++;
;;;1190                                       }
;;;1191   
;;;1192                                   }
;;;1193                                   break;
;;;1194                               case    DEFTYPE_INTEGER16:
;;;1195                               case    DEFTYPE_UNSIGNED16:
;;;1196                               case    DEFTYPE_BITARR16:
;;;1197                               case    DEFTYPE_WORD:
;;;1198   
;;;1199                                   if(bitOffset & 0xF)
;;;1200                                   {
;;;1201                                       /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1202                                       return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1203                                   }
;;;1204                                   /* in this example the objects are defined in that way,
;;;1205                                   that the 16 bit type are always starting at an exact WORD offset */
;;;1206                                   pData[0] = SWAPWORD(pVarPtr[0]);
;;;1207                                   pData++;
;;;1208                                   break;
;;;1209                               case    DEFTYPE_UNSIGNED32:
;;;1210                               case    DEFTYPE_INTEGER32:
;;;1211                               case    DEFTYPE_REAL32:
;;;1212                               case    DEFTYPE_BITARR32:
;;;1213                               case    DEFTYPE_DWORD:
;;;1214                                   if(bitOffset & 0xF)
;;;1215                                   {
;;;1216                                       /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1217                                       return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1218                                   }
;;;1219   
;;;1220                                   /* in this example the objects are defined in that way,
;;;1221                                   that the 32 bit type are always starting at an exact WORD offset */
;;;1222   /*ET9300 Project Handler :(#if BIG_ENDIAN_16BIT || BIG_ENDIAN_FORMAT) lines 1422 to 1425 deleted*/
;;;1223                                   pData[0] = pVarPtr[0];
;;;1224                                   pData[1] = pVarPtr[1];
;;;1225                                   pData += 2;
;;;1226                                   break;
;;;1227                               case    DEFTYPE_REAL64:
;;;1228                               case 	DEFTYPE_INTEGER64:
;;;1229                               case    DEFTYPE_UNSIGNED64:
;;;1230                                   if(bitOffset & 0xF)
;;;1231                                   {
;;;1232                                       /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1233                                       return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1234                                   }
;;;1235   
;;;1236                                   /* in this example the objects are defined in that way,
;;;1237                                   that the 64 bit type are always starting at an exact WORD offset */
;;;1238   /*ET9300 Project Handler :(#if BIG_ENDIAN_16BIT || BIG_ENDIAN_FORMAT) lines 1442 to 1447 deleted*/
;;;1239                                   pData[0] = pVarPtr[0];
;;;1240                                   pData[1] = pVarPtr[1];
;;;1241                                   pData[2] = pVarPtr[2];
;;;1242                                   pData[3] = pVarPtr[3];
;;;1243                                   pData += 4;
;;;1244                                   break;
;;;1245                               case    DEFTYPE_OCTETSTRING:
;;;1246                               case    DEFTYPE_UNICODE_STRING:
;;;1247                               case DEFTYPE_ARRAY_OF_INT :
;;;1248                               case DEFTYPE_ARRAY_OF_SINT :
;;;1249                               case DEFTYPE_ARRAY_OF_DINT :
;;;1250                               case DEFTYPE_ARRAY_OF_UDINT:
;;;1251   
;;;1252                                   if(bitOffset & 0xF)
;;;1253                                   {
;;;1254                                       /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1255                                       return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1256                                   }
;;;1257   
;;;1258                                   OBJTOMBXMEMCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
;;;1259   
;;;1260                                   pData += BIT2WORD((pEntry->BitLength & ~0xF));
;;;1261                                   
;;;1262                                   if((pEntry->BitLength & 0xF) != 0)
;;;1263                                   {
;;;1264                                       /*current entry has an odd word length => clear last byte of next word*/
;;;1265                                       *pData &= 0xFF;
;;;1266                                   }
;;;1267   
;;;1268                                   break;
;;;1269                               case    DEFTYPE_VISIBLESTRING:
;;;1270                                   if(bitOffset & 0xF)
;;;1271                                   {
;;;1272                                       /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1273                                       return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1274                                   }
;;;1275   
;;;1276                                   /* in this example the objects are defined in that way,
;;;1277                                   that these types are always starting at an even WORD offset */
;;;1278                                   OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
;;;1279                                   pData += BIT2WORD((pEntry->BitLength & ~0xF));
;;;1280   
;;;1281                                   if((pEntry->BitLength & 0xF) != 0)
;;;1282                                   {
;;;1283                                       /*current entry has an odd word length => clear last byte of next word*/
;;;1284                                       *pData &= 0xFF;
;;;1285                                   }
;;;1286                                   
;;;1287                                   break;
;;;1288                               default:
;;;1289                                   /* other data types are not supported from this example */
;;;1290                                   return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
;;;1291                               } //switch (deftype)
;;;1292   
;;;1293                               bRead = 1;
;;;1294                           }
;;;1295                       }
;;;1296                   }
;;;1297                   else
;;;1298                   {
;;;1299                       /*No access to current object entry => shift pData if required*/
;;;1300                       UINT8 cnt = 0;
;;;1301   
;;;1302                       /*If this entry is the first in the 16Bit block clear the memory*/
;;;1303                       if ((bitOffset & 0x0F) == 0) 
;;;1304                       {
;;;1305                           *pData = 0;
;;;1306                       }
;;;1307   
;;;1308                       /*Handle Bit/Byte Offset*/
;;;1309                       if (((pEntry->BitLength & 0xF) > 0)
;;;1310                           && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
;;;1311                       {
;;;1312                           /* we have reached the UINT16 border */
;;;1313                           pData++;
;;;1314                           
;;;1315                           /*Clear new buffer*/
;;;1316                           *pData = 0;
;;;1317                       }
;;;1318   
;;;1319                       /*increment WORD offset*/
;;;1320                       for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
;;;1321                       {
;;;1322                           
;;;1323                           /*current 16Bit are skipped => clear current buffer */
;;;1324                           pData++;
;;;1325   
;;;1326                           /*Clear new buffer*/
;;;1327                           *pData = 0;
;;;1328                       }
;;;1329   
;;;1330   
;;;1331                       
;;;1332   
;;;1333                       /* we don't have read access */
;;;1334                       if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
;;;1335                       {
;;;1336                           /* it is a write only entry */
;;;1337                           result = ABORTIDX_WRITE_ONLY_ENTRY;
;;;1338                       }
;;;1339                       else
;;;1340                       {
;;;1341                           /* we don't have read access in this state */
;;;1342                           result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
;;;1343                       }
;;;1344                   }
;;;1345               }
;;;1346   
;;;1347               if(bRead == 0)
;;;1348               {
;;;1349                   return result;
;;;1350               }
;;;1351           }
;;;1352   
;;;1353       return 0;
;;;1354   }
00004a  b00b              ADD      sp,sp,#0x2c
00004c  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.80|
000050  9805              LDR      r0,[sp,#0x14]         ;936
000052  9004              STR      r0,[sp,#0x10]         ;936
000054  e01e              B        |L11.148|
                  |L11.86|
000056  9805              LDR      r0,[sp,#0x14]         ;939
000058  4581              CMP      r9,r0                 ;939
00005a  dd01              BLE      |L11.96|
00005c  2011              MOVS     r0,#0x11              ;942
00005e  e7f4              B        |L11.74|
                  |L11.96|
000060  f00801ff          AND      r1,r8,#0xff           ;947
000064  4638              MOV      r0,r7                 ;947
000066  f7fffffe          BL       OBJ_GetEntryDesc
00006a  4605              MOV      r5,r0                 ;947
00006c  88a8              LDRH     r0,[r5,#4]            ;950
00006e  b178              CBZ      r0,|L11.144|
000070  48fd              LDR      r0,|L11.1128|
000072  7800              LDRB     r0,[r0,#0]            ;954  ; nAlStatus
000074  f000000f          AND      r0,r0,#0xf            ;954
000078  88a9              LDRH     r1,[r5,#4]            ;954
00007a  ea000041          AND      r0,r0,r1,LSL #1       ;954
00007e  b948              CBNZ     r0,|L11.148|
000080  7928              LDRB     r0,[r5,#4]            ;957
000082  f0000007          AND      r0,r0,#7              ;957
000086  b908              CBNZ     r0,|L11.140|
000088  2006              MOVS     r0,#6                 ;960
00008a  e7de              B        |L11.74|
                  |L11.140|
00008c  201a              MOVS     r0,#0x1a              ;965
00008e  e7dc              B        |L11.74|
                  |L11.144|
000090  2005              MOVS     r0,#5                 ;971
000092  e7da              B        |L11.74|
                  |L11.148|
000094  48f5              LDR      r0,|L11.1132|
000096  6800              LDR      r0,[r0,#0]            ;978  ; pAPPL_CoeReadInd
000098  b128              CBZ      r0,|L11.166|
00009a  4652              MOV      r2,r10                ;980
00009c  4649              MOV      r1,r9                 ;980
00009e  4bf3              LDR      r3,|L11.1132|
0000a0  9807              LDR      r0,[sp,#0x1c]         ;980
0000a2  681b              LDR      r3,[r3,#0]            ;980  ; pAPPL_CoeReadInd
0000a4  4798              BLX      r3                    ;980
                  |L11.166|
0000a6  69f8              LDR      r0,[r7,#0x1c]         ;984
0000a8  b140              CBZ      r0,|L11.188|
0000aa  f8cda000          STR      r10,[sp,#0]           ;987
0000ae  4623              MOV      r3,r4                 ;987
0000b0  69fe              LDR      r6,[r7,#0x1c]         ;987
0000b2  4649              MOV      r1,r9                 ;987
0000b4  9a09              LDR      r2,[sp,#0x24]         ;987
0000b6  9807              LDR      r0,[sp,#0x1c]         ;987
0000b8  47b0              BLX      r6                    ;987
0000ba  e7c6              B        |L11.74|
                  |L11.188|
0000bc  9807              LDR      r0,[sp,#0x1c]         ;989
0000be  f5b05f80          CMP      r0,#0x1000            ;989
0000c2  da4a              BGE      |L11.346|
0000c4  f1b90f00          CMP      r9,#0                 ;989
0000c8  d047              BEQ      |L11.346|
0000ca  69be              LDR      r6,[r7,#0x18]         ;993
0000cc  4649              MOV      r1,r9                 ;997
0000ce  4638              MOV      r0,r7                 ;997
0000d0  f7fffffe          BL       OBJ_GetEntryDesc
0000d4  4605              MOV      r5,r0                 ;997
0000d6  8868              LDRH     r0,[r5,#2]            ;998
0000d8  1dc0              ADDS     r0,r0,#7              ;998
0000da  ea4f0be0          ASR      r11,r0,#3             ;998
0000de  9603              STR      r6,[sp,#0xc]          ;1000
0000e0  f1a90001          SUB      r0,r9,#1              ;1001
0000e4  9e03              LDR      r6,[sp,#0xc]          ;1001
0000e6  f8566020          LDR      r6,[r6,r0,LSL #2]     ;1001
0000ea  f0060001          AND      r0,r6,#1              ;1004
0000ee  b338              CBZ      r0,|L11.320|
0000f0  2000              MOVS     r0,#0                 ;1008
0000f2  f00606fe          AND      r6,r6,#0xfe           ;1011
0000f6  bf00              NOP                            ;1013
0000f8  e00b              B        |L11.274|
                  |L11.250|
0000fa  8831              LDRH     r1,[r6,#0]            ;1016
0000fc  0a09              LSRS     r1,r1,#8              ;1016
0000fe  8021              STRH     r1,[r4,#0]            ;1016
000100  8821              LDRH     r1,[r4,#0]            ;1017
000102  78b2              LDRB     r2,[r6,#2]            ;1017
000104  ea412102          ORR      r1,r1,r2,LSL #8       ;1017
000108  8021              STRH     r1,[r4,#0]            ;1017
00010a  1ca4              ADDS     r4,r4,#2              ;1020
00010c  1cb6              ADDS     r6,r6,#2              ;1021
00010e  1c41              ADDS     r1,r0,#1              ;1013
000110  b288              UXTH     r0,r1                 ;1013
                  |L11.274|
000112  eb0b72db          ADD      r2,r11,r11,LSR #31    ;1013
000116  ebb00f62          CMP      r0,r2,ASR #1          ;1013
00011a  dbee              BLT      |L11.250|
00011c  4659              MOV      r1,r11                ;1024
00011e  eb0b72d1          ADD      r2,r11,r1,LSR #31     ;1024
000122  1052              ASRS     r2,r2,#1              ;1024
000124  ebab0242          SUB      r2,r11,r2,LSL #1      ;1024
000128  2a01              CMP      r2,#1                 ;1024
00012a  d108              BNE      |L11.318|
00012c  8821              LDRH     r1,[r4,#0]            ;1026
00012e  f401417f          AND      r1,r1,#0xff00         ;1026
000132  8021              STRH     r1,[r4,#0]            ;1026
000134  8821              LDRH     r1,[r4,#0]            ;1027
000136  8832              LDRH     r2,[r6,#0]            ;1027
000138  ea412112          ORR      r1,r1,r2,LSR #8       ;1027
00013c  8021              STRH     r1,[r4,#0]            ;1027
                  |L11.318|
00013e  e00b              B        |L11.344|
                  |L11.320|
000140  8830              LDRH     r0,[r6,#0]            ;1037
000142  8020              STRH     r0,[r4,#0]            ;1037
000144  8870              LDRH     r0,[r6,#2]            ;1038
000146  8060              STRH     r0,[r4,#2]            ;1038
000148  1d24              ADDS     r4,r4,#4              ;1039
00014a  1d36              ADDS     r6,r6,#4              ;1040
00014c  f1ab0204          SUB      r2,r11,#4             ;1044
000150  4631              MOV      r1,r6                 ;1044
000152  4620              MOV      r0,r4                 ;1044
000154  f7fffffe          BL       __aeabi_memcpy
                  |L11.344|
000158  e19c              B        |L11.1172|
                  |L11.346|
00015a  2000              MOVS     r0,#0                 ;1049
00015c  9003              STR      r0,[sp,#0xc]          ;1049
00015e  9002              STR      r0,[sp,#8]            ;1050
000160  46c8              MOV      r8,r9                 ;1054
000162  e18e              B        |L11.1154|
                  |L11.356|
000164  f8d7b018          LDR      r11,[r7,#0x18]        ;1057
000168  2600              MOVS     r6,#0                 ;1058
00016a  f1b80f00          CMP      r8,#0                 ;1061
00016e  d009              BEQ      |L11.388|
000170  9807              LDR      r0,[sp,#0x1c]         ;1065
000172  f5b05f80          CMP      r0,#0x1000            ;1065
000176  db05              BLT      |L11.388|
000178  f00800ff          AND      r0,r8,#0xff           ;1068
00017c  4639              MOV      r1,r7                 ;1068
00017e  f7fffffe          BL       OBJ_GetEntryOffset
000182  4606              MOV      r6,r0                 ;1068
                  |L11.388|
000184  1130              ASRS     r0,r6,#4              ;1072
000186  eb0b0b40          ADD      r11,r11,r0,LSL #1     ;1072
00018a  f00801ff          AND      r1,r8,#0xff           ;1075
00018e  4638              MOV      r0,r7                 ;1075
000190  f7fffffe          BL       OBJ_GetEntryDesc
000194  4605              MOV      r5,r0                 ;1075
000196  48b4              LDR      r0,|L11.1128|
000198  7800              LDRB     r0,[r0,#0]            ;1076  ; nAlStatus
00019a  f000000f          AND      r0,r0,#0xf            ;1076
00019e  88a9              LDRH     r1,[r5,#4]            ;1076
0001a0  ea000041          AND      r0,r0,r1,LSL #1       ;1076
0001a4  2800              CMP      r0,#0                 ;1076
0001a6  d07c              BEQ      |L11.674|
0001a8  45c8              CMP      r8,r9                 ;1078
0001aa  d004              BEQ      |L11.438|
0001ac  f1ba0f00          CMP      r10,#0                ;1079
0001b0  d078              BEQ      |L11.676|
0001b2  45c8              CMP      r8,r9                 ;1079
0001b4  db76              BLT      |L11.676|
                  |L11.438|
0001b6  f1b80f00          CMP      r8,#0                 ;1084
0001ba  d106              BNE      |L11.458|
0001bc  9806              LDR      r0,[sp,#0x18]         ;1084
0001be  2807              CMP      r0,#7                 ;1084
0001c0  d003              BEQ      |L11.458|
0001c2  9805              LDR      r0,[sp,#0x14]         ;1089
0001c4  8020              STRH     r0,[r4,#0]            ;1089
0001c6  1ca4              ADDS     r4,r4,#2              ;1094
0001c8  e126              B        |L11.1048|
                  |L11.458|
0001ca  8828              LDRH     r0,[r5,#0]            ;1098
0001cc  9000              STR      r0,[sp,#0]            ;1098
0001ce  8828              LDRH     r0,[r5,#0]            ;1100
0001d0  f5b06fe0          CMP      r0,#0x700             ;1100
0001d4  db12              BLT      |L11.508|
0001d6  8868              LDRH     r0,[r5,#2]            ;1104
0001d8  2808              CMP      r0,#8                 ;1104
0001da  dc04              BGT      |L11.486|
0001dc  8868              LDRH     r0,[r5,#2]            ;1106
0001de  302f              ADDS     r0,r0,#0x2f           ;1106
0001e0  b280              UXTH     r0,r0                 ;1106
0001e2  9000              STR      r0,[sp,#0]            ;1106
0001e4  e00a              B        |L11.508|
                  |L11.486|
0001e6  8868              LDRH     r0,[r5,#2]            ;1108
0001e8  2810              CMP      r0,#0x10              ;1108
0001ea  d102              BNE      |L11.498|
0001ec  2006              MOVS     r0,#6                 ;1110
0001ee  9000              STR      r0,[sp,#0]            ;1110
0001f0  e004              B        |L11.508|
                  |L11.498|
0001f2  8868              LDRH     r0,[r5,#2]            ;1112
0001f4  2820              CMP      r0,#0x20              ;1112
0001f6  d101              BNE      |L11.508|
0001f8  2007              MOVS     r0,#7                 ;1114
0001fa  9000              STR      r0,[sp,#0]            ;1114
                  |L11.508|
0001fc  9800              LDR      r0,[sp,#0]            ;1118
0001fe  281f              CMP      r0,#0x1f              ;1118
000200  d07e              BEQ      |L11.768|
000202  dc12              BGT      |L11.554|
000204  d27d              BCS      |L11.770|
000206  e8dff000          TBB      [pc,r0]               ;1118
00020a  3a54              DCB      0x3a,0x54
00020c  5e93a15f          DCB      0x5e,0x93,0xa1,0x5f
000210  94a0a2e7          DCB      0x94,0xa0,0xa2,0xe7
000214  c8c97c7c          DCB      0xc8,0xc9,0x7c,0x7c
000218  7c7c7cb3          DCB      0x7c,0x7c,0x7c,0xb3
00021c  7c7c7cb4          DCB      0x7c,0x7c,0x7c,0xb4
000220  7c7c7c7c          DCB      0x7c,0x7c,0x7c,0x7c
000224  7cb57c7c          DCB      0x7c,0xb5,0x7c,0x7c
000228  6000              DCB      0x60,0x00
                  |L11.554|
00022a  2834              CMP      r0,#0x34              ;1118
00022c  d046              BEQ      |L11.700|
00022e  dc12              BGT      |L11.598|
000230  2830              CMP      r0,#0x30              ;1118
000232  d03f              BEQ      |L11.692|
000234  dc08              BGT      |L11.584|
000236  2820              CMP      r0,#0x20              ;1118
000238  d077              BEQ      |L11.810|
00023a  282d              CMP      r0,#0x2d              ;1118
00023c  d042              BEQ      |L11.708|
00023e  282e              CMP      r0,#0x2e              ;1118
000240  d078              BEQ      |L11.820|
000242  282f              CMP      r0,#0x2f              ;1118
                  |L11.580|
000244  d15d              BNE      |L11.770|
000246  e083              B        |L11.848|
                  |L11.584|
000248  2831              CMP      r0,#0x31              ;1118
00024a  d034              BEQ      |L11.694|
00024c  2832              CMP      r0,#0x32              ;1118
00024e  d033              BEQ      |L11.696|
000250  2833              CMP      r0,#0x33              ;1118
000252  d1f7              BNE      |L11.580|
000254  e031              B        |L11.698|
                  |L11.598|
000256  f5b07f18          CMP      r0,#0x260             ;1118
00025a  d068              BEQ      |L11.814|
00025c  dc06              BGT      |L11.620|
00025e  2835              CMP      r0,#0x35              ;1118
000260  d02d              BEQ      |L11.702|
000262  2836              CMP      r0,#0x36              ;1118
000264  d02c              BEQ      |L11.704|
000266  2837              CMP      r0,#0x37              ;1118
000268  d1ec              BNE      |L11.580|
00026a  e02a              B        |L11.706|
                  |L11.620|
00026c  f2a02061          SUB      r0,r0,#0x261          ;1118
000270  2800              CMP      r0,#0                 ;1118
000272  d073              BEQ      |L11.860|
000274  2801              CMP      r0,#1                 ;1118
000276  d072              BEQ      |L11.862|
000278  2802              CMP      r0,#2                 ;1118
00027a  d1e3              BNE      |L11.580|
00027c  e092              B        |L11.932|
00027e  f1ba0f00          CMP      r10,#0                ;1121
000282  d013              BEQ      |L11.684|
000284  78a8              LDRB     r0,[r5,#2]            ;1124
000286  f000000f          AND      r0,r0,#0xf            ;1124
00028a  2800              CMP      r0,#0                 ;1124
00028c  dd05              BLE      |L11.666|
00028e  78a8              LDRB     r0,[r5,#2]            ;1125
000290  4430              ADD      r0,r0,r6              ;1125
000292  f000000f          AND      r0,r0,#0xf            ;1125
000296  b900              CBNZ     r0,|L11.666|
000298  1ca4              ADDS     r4,r4,#2              ;1128
                  |L11.666|
00029a  78a8              LDRB     r0,[r5,#2]            ;1132
00029c  f3c01003          UBFX     r0,r0,#4,#4           ;1132
0002a0  e001              B        |L11.678|
                  |L11.674|
0002a2  e0ba              B        |L11.1050|
                  |L11.676|
0002a4  e0e9              B        |L11.1146|
                  |L11.678|
0002a6  eb040440          ADD      r4,r4,r0,LSL #1       ;1132
0002aa  e001              B        |L11.688|
                  |L11.684|
0002ac  2018              MOVS     r0,#0x18              ;1136
0002ae  e6cc              B        |L11.74|
                  |L11.688|
0002b0  e0ae              B        |L11.1040|
0002b2  bf00              NOP                            ;1140
                  |L11.692|
0002b4  bf00              NOP                            ;1141
                  |L11.694|
0002b6  bf00              NOP                            ;1142
                  |L11.696|
0002b8  bf00              NOP                            ;1143
                  |L11.698|
0002ba  bf00              NOP                            ;1144
                  |L11.700|
0002bc  bf00              NOP                            ;1145
                  |L11.702|
0002be  bf00              NOP                            ;1146
                  |L11.704|
0002c0  bf00              NOP                            ;1147
                  |L11.706|
0002c2  bf00              NOP                            ;1149
                  |L11.708|
0002c4  bf00              NOP                            ;1153
0002c6  bf00              NOP                            ;1154
0002c8  bf00              NOP                            ;1155
0002ca  2000              MOVS     r0,#0                 ;1158
0002cc  8869              LDRH     r1,[r5,#2]            ;1161
0002ce  4a68              LDR      r2,|L11.1136|
0002d0  f8321011          LDRH     r1,[r2,r1,LSL #1]     ;1161
0002d4  f006020f          AND      r2,r6,#0xf            ;1161
0002d8  4091              LSLS     r1,r1,r2              ;1161
0002da  b289              UXTH     r1,r1                 ;1161
0002dc  9101              STR      r1,[sp,#4]            ;1161
0002de  f8bb0000          LDRH     r0,[r11,#0]           ;1164
0002e2  f006010f          AND      r1,r6,#0xf            ;1167
0002e6  b909              CBNZ     r1,|L11.748|
0002e8  2100              MOVS     r1,#0                 ;1169
0002ea  8021              STRH     r1,[r4,#0]            ;1169
                  |L11.748|
0002ec  8821              LDRH     r1,[r4,#0]            ;1172
0002ee  8021              STRH     r1,[r4,#0]            ;1172
0002f0  f1ba0f00          CMP      r10,#0                ;1174
0002f4  d008              BEQ      |L11.776|
0002f6  8821              LDRH     r1,[r4,#0]            ;1177
0002f8  9a01              LDR      r2,[sp,#4]            ;1177
0002fa  4002              ANDS     r2,r2,r0              ;1177
0002fc  4311              ORRS     r1,r1,r2              ;1177
0002fe  e001              B        |L11.772|
                  |L11.768|
000300  e019              B        |L11.822|
                  |L11.770|
000302  e083              B        |L11.1036|
                  |L11.772|
000304  8021              STRH     r1,[r4,#0]            ;1177
000306  e007              B        |L11.792|
                  |L11.776|
000308  9901              LDR      r1,[sp,#4]            ;1182
00030a  4001              ANDS     r1,r1,r0              ;1182
00030c  f006020f          AND      r2,r6,#0xf            ;1182
000310  4111              ASRS     r1,r1,r2              ;1182
000312  8822              LDRH     r2,[r4,#0]            ;1182
000314  4311              ORRS     r1,r1,r2              ;1182
000316  8021              STRH     r1,[r4,#0]            ;1182
                  |L11.792|
000318  8821              LDRH     r1,[r4,#0]            ;1185
00031a  8021              STRH     r1,[r4,#0]            ;1185
00031c  78a9              LDRB     r1,[r5,#2]            ;1186
00031e  4431              ADD      r1,r1,r6              ;1186
000320  f001010f          AND      r1,r1,#0xf            ;1186
000324  b901              CBNZ     r1,|L11.808|
000326  1ca4              ADDS     r4,r4,#2              ;1189
                  |L11.808|
000328  e072              B        |L11.1040|
                  |L11.810|
00032a  e012              B        |L11.850|
00032c  e002              B        |L11.820|
                  |L11.814|
00032e  e036              B        |L11.926|
000330  bf00              NOP                            ;1195
000332  bf00              NOP                            ;1196
                  |L11.820|
000334  bf00              NOP                            ;1197
                  |L11.822|
000336  f006000f          AND      r0,r6,#0xf            ;1199
00033a  b108              CBZ      r0,|L11.832|
00033c  2005              MOVS     r0,#5                 ;1202
00033e  e684              B        |L11.74|
                  |L11.832|
000340  f8bb0000          LDRH     r0,[r11,#0]           ;1206
000344  8020              STRH     r0,[r4,#0]            ;1206
000346  1ca4              ADDS     r4,r4,#2              ;1207
000348  e062              B        |L11.1040|
00034a  bf00              NOP                            ;1210
00034c  bf00              NOP                            ;1211
00034e  bf00              NOP                            ;1212
                  |L11.848|
000350  bf00              NOP                            ;1213
                  |L11.850|
000352  f006000f          AND      r0,r6,#0xf            ;1214
000356  b118              CBZ      r0,|L11.864|
000358  2005              MOVS     r0,#5                 ;1217
00035a  e676              B        |L11.74|
                  |L11.860|
00035c  e020              B        |L11.928|
                  |L11.862|
00035e  e020              B        |L11.930|
                  |L11.864|
000360  f8bb0000          LDRH     r0,[r11,#0]           ;1223
000364  8020              STRH     r0,[r4,#0]            ;1223
000366  f8bb0002          LDRH     r0,[r11,#2]           ;1224
00036a  8060              STRH     r0,[r4,#2]            ;1224
00036c  1d24              ADDS     r4,r4,#4              ;1225
00036e  e04f              B        |L11.1040|
000370  bf00              NOP                            ;1228
000372  bf00              NOP                            ;1229
000374  f006000f          AND      r0,r6,#0xf            ;1230
000378  b108              CBZ      r0,|L11.894|
00037a  2005              MOVS     r0,#5                 ;1233
00037c  e665              B        |L11.74|
                  |L11.894|
00037e  f8bb0000          LDRH     r0,[r11,#0]           ;1239
000382  8020              STRH     r0,[r4,#0]            ;1239
000384  f8bb0002          LDRH     r0,[r11,#2]           ;1240
000388  8060              STRH     r0,[r4,#2]            ;1240
00038a  f8bb0004          LDRH     r0,[r11,#4]           ;1241
00038e  80a0              STRH     r0,[r4,#4]            ;1241
000390  f8bb0006          LDRH     r0,[r11,#6]           ;1242
000394  80e0              STRH     r0,[r4,#6]            ;1242
000396  3408              ADDS     r4,r4,#8              ;1243
000398  e03a              B        |L11.1040|
00039a  bf00              NOP                            ;1246
00039c  bf00              NOP                            ;1247
                  |L11.926|
00039e  bf00              NOP                            ;1248
                  |L11.928|
0003a0  bf00              NOP                            ;1249
                  |L11.930|
0003a2  bf00              NOP                            ;1250
                  |L11.932|
0003a4  f006000f          AND      r0,r6,#0xf            ;1252
0003a8  b108              CBZ      r0,|L11.942|
0003aa  2005              MOVS     r0,#5                 ;1255
0003ac  e64d              B        |L11.74|
                  |L11.942|
0003ae  8868              LDRH     r0,[r5,#2]            ;1258
0003b0  1dc0              ADDS     r0,r0,#7              ;1258
0003b2  10c2              ASRS     r2,r0,#3              ;1258
0003b4  4659              MOV      r1,r11                ;1258
0003b6  4620              MOV      r0,r4                 ;1258
0003b8  f7fffffe          BL       __aeabi_memcpy
0003bc  8868              LDRH     r0,[r5,#2]            ;1260
0003be  f020000f          BIC      r0,r0,#0xf            ;1260
0003c2  300f              ADDS     r0,r0,#0xf            ;1260
0003c4  1100              ASRS     r0,r0,#4              ;1260
0003c6  eb040440          ADD      r4,r4,r0,LSL #1       ;1260
0003ca  78a8              LDRB     r0,[r5,#2]            ;1262
0003cc  f000000f          AND      r0,r0,#0xf            ;1262
0003d0  b108              CBZ      r0,|L11.982|
0003d2  7820              LDRB     r0,[r4,#0]            ;1265
0003d4  8020              STRH     r0,[r4,#0]            ;1265
                  |L11.982|
0003d6  e01b              B        |L11.1040|
0003d8  f006000f          AND      r0,r6,#0xf            ;1270
0003dc  b108              CBZ      r0,|L11.994|
0003de  2005              MOVS     r0,#5                 ;1273
0003e0  e633              B        |L11.74|
                  |L11.994|
0003e2  8868              LDRH     r0,[r5,#2]            ;1278
0003e4  1dc0              ADDS     r0,r0,#7              ;1278
0003e6  10c2              ASRS     r2,r0,#3              ;1278
0003e8  4659              MOV      r1,r11                ;1278
0003ea  4620              MOV      r0,r4                 ;1278
0003ec  f7fffffe          BL       __aeabi_memcpy
0003f0  8868              LDRH     r0,[r5,#2]            ;1279
0003f2  f020000f          BIC      r0,r0,#0xf            ;1279
0003f6  300f              ADDS     r0,r0,#0xf            ;1279
0003f8  1100              ASRS     r0,r0,#4              ;1279
0003fa  eb040440          ADD      r4,r4,r0,LSL #1       ;1279
0003fe  78a8              LDRB     r0,[r5,#2]            ;1281
000400  f000000f          AND      r0,r0,#0xf            ;1281
000404  b108              CBZ      r0,|L11.1034|
000406  7820              LDRB     r0,[r4,#0]            ;1284
000408  8020              STRH     r0,[r4,#0]            ;1284
                  |L11.1034|
00040a  e001              B        |L11.1040|
                  |L11.1036|
00040c  2018              MOVS     r0,#0x18              ;1290
00040e  e61c              B        |L11.74|
                  |L11.1040|
000410  bf00              NOP                            ;1138
000412  2001              MOVS     r0,#1                 ;1293
000414  9003              STR      r0,[sp,#0xc]          ;1293
000416  bf00              NOP                            ;1294
                  |L11.1048|
000418  e02f              B        |L11.1146|
                  |L11.1050|
00041a  2000              MOVS     r0,#0                 ;1300
00041c  f006010f          AND      r1,r6,#0xf            ;1303
000420  b909              CBNZ     r1,|L11.1062|
000422  2100              MOVS     r1,#0                 ;1305
000424  8021              STRH     r1,[r4,#0]            ;1305
                  |L11.1062|
000426  78a9              LDRB     r1,[r5,#2]            ;1309
000428  f001010f          AND      r1,r1,#0xf            ;1309
00042c  2900              CMP      r1,#0                 ;1309
00042e  dd07              BLE      |L11.1088|
000430  78a9              LDRB     r1,[r5,#2]            ;1310
000432  4431              ADD      r1,r1,r6              ;1310
000434  f001010f          AND      r1,r1,#0xf            ;1310
000438  b911              CBNZ     r1,|L11.1088|
00043a  1ca4              ADDS     r4,r4,#2              ;1313
00043c  2100              MOVS     r1,#0                 ;1316
00043e  8021              STRH     r1,[r4,#0]            ;1316
                  |L11.1088|
000440  2000              MOVS     r0,#0                 ;1320
000442  e004              B        |L11.1102|
                  |L11.1092|
000444  1ca4              ADDS     r4,r4,#2              ;1324
000446  2100              MOVS     r1,#0                 ;1327
000448  8021              STRH     r1,[r4,#0]            ;1327
00044a  1c41              ADDS     r1,r0,#1              ;1320
00044c  b2c8              UXTB     r0,r1                 ;1320
                  |L11.1102|
00044e  78a9              LDRB     r1,[r5,#2]            ;1320
000450  f3c11103          UBFX     r1,r1,#4,#4           ;1320
000454  4281              CMP      r1,r0                 ;1320
000456  dcf5              BGT      |L11.1092|
000458  7929              LDRB     r1,[r5,#4]            ;1334
00045a  f0010107          AND      r1,r1,#7              ;1334
00045e  b949              CBNZ     r1,|L11.1140|
000460  2106              MOVS     r1,#6                 ;1337
000462  9102              STR      r1,[sp,#8]            ;1337
000464  e008              B        |L11.1144|
000466  0000              DCW      0x0000
                  |L11.1128|
                          DCD      nAlStatus
                  |L11.1132|
                          DCD      pAPPL_CoeReadInd
                  |L11.1136|
                          DCD      cBitMask
                  |L11.1140|
000474  211a              MOVS     r1,#0x1a              ;1342
000476  9102              STR      r1,[sp,#8]            ;1342
                  |L11.1144|
000478  bf00              NOP                            ;1344
                  |L11.1146|
00047a  f1080001          ADD      r0,r8,#1              ;1054
00047e  fa1ff880          UXTH     r8,r0                 ;1054
                  |L11.1154|
000482  9804              LDR      r0,[sp,#0x10]         ;1054
000484  4580              CMP      r8,r0                 ;1054
000486  f77fae6d          BLE      |L11.356|
00048a  9803              LDR      r0,[sp,#0xc]          ;1347
00048c  b908              CBNZ     r0,|L11.1170|
00048e  9802              LDR      r0,[sp,#8]            ;1349
000490  e5db              B        |L11.74|
                  |L11.1170|
000492  bf00              NOP                            ;1351
                  |L11.1172|
000494  2000              MOVS     r0,#0                 ;1353
000496  e5d8              B        |L11.74|
;;;1355   
                          ENDP


                          AREA ||i.OBJ_Write||, CODE, READONLY, ALIGN=2

                  OBJ_Write PROC
;;;1372   
;;;1373   UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1374   {
000004  b089              SUB      sp,sp,#0x24
000006  4606              MOV      r6,r0
000008  468b              MOV      r11,r1
00000a  469a              MOV      r10,r3
00000c  9c16              LDR      r4,[sp,#0x58]
;;;1375       UINT16 i = subindex;
00000e  46d8              MOV      r8,r11
;;;1376       /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
;;;1377       UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
000010  f8ba000c          LDRH     r0,[r10,#0xc]
000014  f3c02003          UBFX     r0,r0,#8,#4
000018  9008              STR      r0,[sp,#0x20]
;;;1378       UINT16 maxSubindex = 0;
00001a  2000              MOVS     r0,#0
00001c  9007              STR      r0,[sp,#0x1c]
;;;1379       UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
00001e  f89a000c          LDRB     r0,[r10,#0xc]
000022  9006              STR      r0,[sp,#0x18]
;;;1380       OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
;;;1381       BOOL bClearSubindex0Required = FALSE;
000024  2000              MOVS     r0,#0
000026  9005              STR      r0,[sp,#0x14]
;;;1382       /* lastSubindex is used for complete access to make loop over the requested entries
;;;1383          to be read, we initialize this variable with the requested subindex that only
;;;1384          one loop will be done for a single access */
;;;1385       UINT16 lastSubindex = subindex;
000028  f8cdb010          STR      r11,[sp,#0x10]
;;;1386   
;;;1387       /* if subindex 0 is writable, the maximum subindex should be checked in an object specific function,
;;;1388           because for the PDO mapping and PDO assign the object shall only be written if subindex 0 is 0. */
;;;1389       if ( objCode != OBJCODE_VAR )
00002c  9808              LDR      r0,[sp,#0x20]
00002e  2807              CMP      r0,#7
000030  d01f              BEQ      |L12.114|
;;;1390       {
;;;1391           /* if the object is an array or record we have to get the maxSubindex from the
;;;1392              actual value of subindex 0, which is stored as UINT16 at the beginning of the
;;;1393               object's variable */
;;;1394           maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
000032  f8da0018          LDR      r0,[r10,#0x18]
000036  7800              LDRB     r0,[r0,#0]
000038  9007              STR      r0,[sp,#0x1c]
;;;1395   
;;;1396           /*If the subindex0 of a PDO assign or PDO mapping object is 0 the maximum subindex is specified by the object description*/
;;;1397           if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
00003a  9807              LDR      r0,[sp,#0x1c]
00003c  b9c8              CBNZ     r0,|L12.114|
00003e  f6414010          MOV      r0,#0x1c10
000042  4286              CMP      r6,r0
000044  db03              BLT      |L12.78|
000046  f641402f          MOV      r0,#0x1c2f
00004a  4286              CMP      r6,r0
00004c  dd0f              BLE      |L12.110|
                  |L12.78|
00004e  f5b65fb0          CMP      r6,#0x1600
000052  db02              BLT      |L12.90|
000054  f5b65fc0          CMP      r6,#0x1800
000058  db09              BLT      |L12.110|
                  |L12.90|
00005a  f5b65fd0          CMP      r6,#0x1a00
00005e  db02              BLT      |L12.102|
000060  f5b65fe0          CMP      r6,#0x1c00
000064  db03              BLT      |L12.110|
                  |L12.102|
000066  f24f0030          MOV      r0,#0xf030
00006a  4286              CMP      r6,r0
00006c  d101              BNE      |L12.114|
                  |L12.110|
;;;1398           {
;;;1399               maxSubindex = maxConfiguredSubindex;
00006e  9806              LDR      r0,[sp,#0x18]
000070  9007              STR      r0,[sp,#0x1c]
                  |L12.114|
;;;1400           }
;;;1401       }
;;;1402   
;;;1403   
;;;1404       if ( bCompleteAccess )
000072  9817              LDR      r0,[sp,#0x5c]
000074  b180              CBZ      r0,|L12.152|
;;;1405       {
;;;1406           if ( objCode == OBJCODE_VAR )
000076  9808              LDR      r0,[sp,#0x20]
000078  2807              CMP      r0,#7
00007a  d103              BNE      |L12.132|
;;;1407           {
;;;1408               /* complete access is not supported with simple objects */
;;;1409               return ABORTIDX_UNSUPPORTED_ACCESS;
00007c  2005              MOVS     r0,#5
                  |L12.126|
;;;1410           }
;;;1411   
;;;1412           if ((subindex == 0) && (dataSize > 0))
;;;1413           {
;;;1414               /* we change the subindex 0 */
;;;1415               maxSubindex = (UINT8) SWAPWORD(pData[0]);
;;;1416           }
;;;1417   
;;;1418   
;;;1419           /* we write until the maximum subindex */
;;;1420           lastSubindex = maxSubindex;
;;;1421       }
;;;1422       else
;;;1423       if (subindex > maxSubindex)
;;;1424       {
;;;1425           /* the maximum subindex is reached */
;;;1426           return ABORTIDX_SUBINDEX_NOT_EXISTING;
;;;1427       }
;;;1428       else
;;;1429       {
;;;1430           /* we check the write access for single accesses here, a complete write access
;;;1431              is allowed if at least one entry is writable (in this case the values for the
;;;1432               read only entries shall be ignored) */
;;;1433           /* we get the corresponding entry description */
;;;1434           pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
;;;1435   
;;;1436           /* check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
;;;1437              by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
;;;1438           if (0 == (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
;;;1439           {
;;;1440               /* we don't have write access */
;;;1441               if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
;;;1442               {
;;;1443                   if (pEntry->ObjAccess == 0)
;;;1444                   {
;;;1445                           return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1446                   }
;;;1447                   else
;;;1448                   {
;;;1449                           /* it is a read only entry */
;;;1450                           return ABORTIDX_READ_ONLY_ENTRY;
;;;1451                   }
;;;1452               }
;;;1453               else
;;;1454               {
;;;1455                   /* we don't have write access in this state */
;;;1456                   return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
;;;1457               }
;;;1458           }
;;;1459   
;;;1460   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1674 to 1681 deleted*/
;;;1461   
;;;1462       }
;;;1463   
;;;1464       /* Subindex 0 shall be set to zero if a single PDO / PDO assign entry is written
;;;1465       or a complete access without subindex0 is requested */
;;;1466       if((subindex > 0) &&
;;;1467           (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
;;;1468           )
;;;1469       {
;;;1470           /*Check if Subindex0 was cleared before*/
;;;1471           UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
;;;1472           if(Subindex0 != 0x00)
;;;1473           {
;;;1474               bClearSubindex0Required = TRUE;
;;;1475           }
;;;1476       }
;;;1477   
;;;1478       if ( pObjEntry->Write != NULL )
;;;1479       {
;;;1480           /* Write function is defined, we call the object specific write function */
;;;1481           /* ECATCHANGE_START(V5.13) COE4*/
;;;1482           UINT8 result = 0;
;;;1483   
;;;1484           result = pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
;;;1485   
;;;1486           if ((result == 0) && (pAPPL_CoeWriteInd != NULL))
;;;1487           {
;;;1488               pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
;;;1489           }
;;;1490           
;;;1491           return result;
;;;1492           /* ECATCHANGE_END(V5.13) COE4*/
;;;1493       }
;;;1494       else
;;;1495       {
;;;1496           UINT8 bWritten = 0;
;;;1497           UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
;;;1498   
;;;1499           if (dataSize == 0)
;;;1500           {
;;;1501              return 0; //no error
;;;1502           }
;;;1503   
;;;1504   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1725 to 1731 deleted*/
;;;1505           /* we use the standard write function */
;;;1506           for (i = subindex; i <= lastSubindex; i++)
;;;1507           {
;;;1508               /* if only a single entry is requested, this loop will only be done once */
;;;1509               UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
;;;1510               UINT16 bitOffset = 0;
;;;1511   
;;;1512               /* we get the corresponding entry description */
;;;1513               pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
;;;1514   
;;;1515               /*Get the bitOffset before check the access rights to calculate pData offset*/
;;;1516               bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
;;;1517   
;;;1518               /* we check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
;;;1519                  by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
;;;1520               if (0 != (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
;;;1521               {
;;;1522                   /* we have write access for this entry */
;;;1523                   if (i != 0)
;;;1524                   {
;;;1525                       /* we increment the variable pointer to the corresponding word address */
;;;1526                       pVarPtr += (bitOffset >> 4);
;;;1527                   }
;;;1528   
;;;1529   
;;;1530                   if ( i == subindex                                     /* requested entry */
;;;1531                     || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
;;;1532                   {
;;;1533                       UINT16 bitMask;
;;;1534   
;;;1535                       /* we have to copy the entry */
;;;1536                       if (i == 0 && objCode != OBJCODE_VAR)
;;;1537                       {
;;;1538                           /*check if the value for subindex0 is valid */
;;;1539                           UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
;;;1540                           
;;;1541                           if(maxConfiguredSubindex < NewSubindex0)
;;;1542                           {
;;;1543                               return ABORTIDX_VALUE_TOO_GREAT;
;;;1544                           }
;;;1545   
;;;1546                           /* subindex 0 of an array or record shall be written */
;;;1547                           pVarPtr[0] = SWAPWORD(pData[0]);
;;;1548                           /* we increment the destination pointer by 2 because the subindex 0 will be
;;;1549                              transmitted as UINT16 for a complete access */
;;;1550                           pData++;
;;;1551                       }
;;;1552                       else
;;;1553                       {
;;;1554                           UINT16 dataType = pEntry->DataType;
;;;1555                           if (pEntry->DataType >= 0x700)
;;;1556                           {
;;;1557                               /* the ENUM data types are defined from index 0x700 in this example
;;;1558                                  convert in standard data type for the write access */
;;;1559                               if ( pEntry->BitLength <= 8 )
;;;1560                               {
;;;1561                                   dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
;;;1562                               }
;;;1563                               else if ( pEntry->BitLength == 16 )
;;;1564                               {
;;;1565                                   dataType = DEFTYPE_UNSIGNED16;
;;;1566                               }
;;;1567                               else if ( pEntry->BitLength == 32 )
;;;1568                               {
;;;1569                                   dataType = DEFTYPE_UNSIGNED32;
;;;1570                               }
;;;1571                           }
;;;1572   
;;;1573                           switch (dataType)
;;;1574                           {
;;;1575                           case DEFTYPE_NULL:
;;;1576                               if(bCompleteAccess)
;;;1577                               {
;;;1578                                   /*Handle alignment entry*/
;;;1579                                   if (((pEntry->BitLength & 0xF) > 0)
;;;1580                                       && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
;;;1581                                   {
;;;1582                                       /* we have reached the UINT16 border */
;;;1583                                       pData++;
;;;1584                                   }
;;;1585   
;;;1586                                   /*increment WORD offset*/
;;;1587                                   pData += ((pEntry->BitLength & 0xF0) >> 4);
;;;1588                               }
;;;1589                               else
;;;1590                               {
;;;1591                                   return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
;;;1592                               }
;;;1593                               break;
;;;1594                           case     DEFTYPE_BOOLEAN:
;;;1595                           case     DEFTYPE_BIT1:
;;;1596                           case     DEFTYPE_BIT2:
;;;1597                           case     DEFTYPE_BIT3:
;;;1598                           case     DEFTYPE_BIT4:
;;;1599                           case     DEFTYPE_BIT5:
;;;1600                           case     DEFTYPE_BIT6:
;;;1601                           case     DEFTYPE_BIT7:
;;;1602                           case     DEFTYPE_BIT8:
;;;1603   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1832 to 1843 deleted*/
;;;1604                           case     DEFTYPE_BITARR8:
;;;1605                               /* in this example the objects are defined in that way,
;;;1606                                  that the bit types are always inside a 16-bit field,
;;;1607                                  and shall not overlap a byte border*/
;;;1608                           case    DEFTYPE_INTEGER8:
;;;1609                           case    DEFTYPE_UNSIGNED8:
;;;1610                           case    DEFTYPE_BYTE :
;;;1611                           {
;;;1612                               /* depending on the bitOffset we have to copy the Hi or the Lo-Byte */
;;;1613                               UINT16 TmpValue = 0x0000;
;;;1614   
;;;1615                               bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
;;;1616   
;;;1617                               /*Swap object data (if required); all masks and offsets are defined for little endian format*/
;;;1618                               TmpValue = SWAPWORD(pVarPtr[0]);
;;;1619   
;;;1620                               /*Clear corresponding bits*/
;;;1621                               TmpValue &= ~bitMask;
;;;1622   
;;;1623                               if (bCompleteAccess) 
;;;1624                               {
;;;1625                                   /*shifting is not required for Complete access because the bits are set to the correct offset by the master*/
;;;1626                                   TmpValue |= (SWAPWORD(pData[0]) & bitMask);
;;;1627                               }
;;;1628                               else
;;;1629                               {
;;;1630                                   if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
;;;1631                                   {
;;;1632                                       /*written value exceed entry range*/
;;;1633                                       return ABORTIDX_VALUE_EXCEEDED;
;;;1634                                   }
;;;1635                                   else
;;;1636                                   {
;;;1637                                       /*Shift Bits to corresponding offset within the object memory*/
;;;1638                                       TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength]) << (bitOffset & 0x0F));
;;;1639                                   }
;;;1640                               }
;;;1641   
;;;1642                               /*Swap written data to big endian format (if required)*/
;;;1643                               pVarPtr[0] = SWAPWORD(TmpValue);
;;;1644   
;;;1645                               if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
;;;1646                               {
;;;1647                                   /* we have reached the UINT16 border */
;;;1648                                   pData++;
;;;1649                               }
;;;1650                           }
;;;1651                               break;
;;;1652                           case    DEFTYPE_INTEGER16:
;;;1653                           case    DEFTYPE_UNSIGNED16:
;;;1654                           case    DEFTYPE_BITARR16:
;;;1655                           case    DEFTYPE_WORD:
;;;1656                               if(bitOffset & 0xF)
;;;1657                               {
;;;1658                                   /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1659                                   return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1660                               }
;;;1661   
;;;1662                               {
;;;1663                               /* in this example the objects are defined in that way,
;;;1664                               that the 16 bit type are always starting at an exact WORD offset */
;;;1665                               UINT16 u16NewData = SWAPWORD(pData[0]);
;;;1666                               if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
;;;1667                               {
;;;1668                                   /* try to write new data when subindex0 shall be reset*/
;;;1669                                   return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
;;;1670                               }
;;;1671   
;;;1672                               /*check value if a new PDO assign entry should be written*/
;;;1673                               if(IS_PDO_ASSIGN(index))  //PDO assign
;;;1674                               {
;;;1675                                   if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData != 0)) //check if the new assign entry value is valid
;;;1676                                   {
;;;1677                                       return ABORTIDX_VALUE_EXCEEDED;
;;;1678                                   }
;;;1679                               }
;;;1680   
;;;1681                               if(index == 0x1C32 || index == 0x1C33)
;;;1682                               {
;;;1683                                  if (i == 1) /* "Synchronisation type" written */
;;;1684                                  {
;;;1685                                     /* The Synchronisation type (0x1C3x.1) was written by the user => the Sync type will not be calculated based on the register settings (if they don't match an error will be returned P_2_S)*/
;;;1686                                     if (pVarPtr[0] != u16NewData)
;;;1687                                     {
;;;1688                                        result = CheckSyncTypeValue(index, u16NewData);
;;;1689   
;;;1690                                        if (result != 0)
;;;1691                                        {
;;;1692                                           return result;
;;;1693                                        }
;;;1694                                     }
;;;1695   
;;;1696                                     /* The user may force to current Sync Mode for that reason the flag has also to be set if the same value was written */
;;;1697                                     bSyncSetByUser = TRUE;
;;;1698                                  }
;;;1699   
;;;1700                                  if (i == 8) /* "Get Cycle Time" written*/
;;;1701                                  {
;;;1702   
;;;1703                                      sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
;;;1704                                      sSyncManOutPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
;;;1705                                      sSyncManOutPar.u32CycleTime = 0;
;;;1706   
;;;1707                                      sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
;;;1708                                      sSyncManInPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
;;;1709                                      sSyncManInPar.u32CycleTime = 0;
;;;1710   
;;;1711   
;;;1712                                     if ((u16NewData & 0x2) == 0x2)
;;;1713                                     {
;;;1714                                        /* reset the error counters*/
;;;1715                                        sSyncManOutPar.u16CycleExceededCounter = 0;
;;;1716                                        sSyncManOutPar.u16SmEventMissedCounter = 0;
;;;1717                                        sSyncManOutPar.u8SyncError = 0;
;;;1718   
;;;1719                                        sSyncManInPar.u16CycleExceededCounter = 0;
;;;1720                                        sSyncManInPar.u16SmEventMissedCounter = 0;
;;;1721                                        sSyncManInPar.u8SyncError = 0;
;;;1722                                     }
;;;1723                                  } /* Subindex 8 written*/
;;;1724                               }
;;;1725   
;;;1726                               pVarPtr[0] = u16NewData;
;;;1727                               pData++;
;;;1728                               }
;;;1729                               break;
;;;1730                           case    DEFTYPE_UNSIGNED32:
;;;1731                           case    DEFTYPE_INTEGER32:
;;;1732                           case    DEFTYPE_REAL32:
;;;1733                           case    DEFTYPE_BITARR32:
;;;1734                           case    DEFTYPE_DWORD:
;;;1735                               if(bitOffset & 0xF)
;;;1736                               {
;;;1737                                   /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1738                                   return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1739                               }
;;;1740                               {
;;;1741   
;;;1742                               /* in this example the objects are defined in that way,
;;;1743                                  that the 32 bit type are always starting at an exact WORD offset */
;;;1744   /*ET9300 Project Handler :(#if BIG_ENDIAN_16BIT || BIG_ENDIAN_FORMAT) lines 1992 to 2003 deleted*/
;;;1745                               if(bClearSubindex0Required && 
;;;1746                                   ((pVarPtr[0] != pData[0])
;;;1747                                   || (pVarPtr[1] != pData[1])))
;;;1748                               {
;;;1749                                   /* try to write new data when subindex0 shall be reset*/
;;;1750                                   return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
;;;1751                               }
;;;1752   
;;;1753                               pVarPtr[0] = pData[0];
;;;1754                               pVarPtr[1] = pData[1];
;;;1755                               pData += 2;
;;;1756                               }
;;;1757   /*ET9300 Project Handler :(#if TEST_APPLICATION && DIAGNOSIS_SUPPORTED) lines 2017 to 2028 deleted*/
;;;1758                               break;
;;;1759                           case    DEFTYPE_REAL64:
;;;1760                           case 	DEFTYPE_INTEGER64:
;;;1761                           case    DEFTYPE_UNSIGNED64:
;;;1762                               if(bitOffset & 0xF)
;;;1763                               {
;;;1764                                   /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1765                                   return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1766                               }
;;;1767                               /* in this example the objects are defined in that way,
;;;1768                                  that the 64 bit type are always starting at an exact WORD offset */
;;;1769   /*ET9300 Project Handler :(#if BIG_ENDIAN_16BIT || BIG_ENDIAN_FORMAT) lines 2040 to 2045 deleted*/
;;;1770                               pVarPtr[0] = pData[0];
;;;1771                               pVarPtr[1] = pData[1];
;;;1772                               pVarPtr[2] = pData[2];
;;;1773                               pVarPtr[3] = pData[3];
;;;1774                               pData += 4;
;;;1775                               break;
;;;1776                           case    DEFTYPE_VISIBLESTRING:
;;;1777                               if(bitOffset & 0xF)
;;;1778                               {
;;;1779                                   /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1780                                   return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1781                               }
;;;1782   
;;;1783                               OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
;;;1784   
;;;1785                               pData += BIT2WORD((pEntry->BitLength)& ~0xF);
;;;1786                               break;
;;;1787                           case    DEFTYPE_OCTETSTRING:
;;;1788                           case    DEFTYPE_UNICODE_STRING:
;;;1789                               case DEFTYPE_ARRAY_OF_INT :
;;;1790                               case DEFTYPE_ARRAY_OF_SINT :
;;;1791                               case DEFTYPE_ARRAY_OF_DINT :
;;;1792                               case DEFTYPE_ARRAY_OF_UDINT:
;;;1793                               if(bitOffset & 0xF)
;;;1794                               {
;;;1795                                   /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
;;;1796                                   return ABORTIDX_UNSUPPORTED_ACCESS;
;;;1797                               }
;;;1798   
;;;1799                               /* in this example the objects are defined in that way,
;;;1800                                  that the other types are always starting at an even byte offset */
;;;1801                               OBJTOMBXMEMCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
;;;1802                               pData += BIT2WORD((pEntry->BitLength) & ~0xF);
;;;1803   
;;;1804                               break;
;;;1805                           default:
;;;1806                               /* other data types are not supported from this example */
;;;1807                               return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
;;;1808                           }
;;;1809                       }
;;;1810   
;;;1811                       /* set flag */
;;;1812                       bWritten = 1;
;;;1813   
;;;1814   /*ET9300 Project Handler :(#if STORE_BACKUP_PARAMETER_IMMEDIATELY && BACKUP_PARAMETER_SUPPORTED) lines 2091 to 2098 deleted*/
;;;1815                   }
;;;1816               }
;;;1817               else
;;;1818               {
;;;1819                   if(i == 0)
;;;1820                   {
;;;1821                       /* For SubIndex0 16Bit are reserved even if the BitLength is 8 */
;;;1822                       pData++;
;;;1823                   }
;;;1824                   else
;;;1825                   {
;;;1826                       /*Handle Bit/Byte Offset*/
;;;1827                       if (((pEntry->BitLength & 0xF) > 0)
;;;1828                           && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
;;;1829                       {
;;;1830                           /* we have reached the UINT16 border */
;;;1831                           pData++;
;;;1832                       }
;;;1833   
;;;1834                       /*increment WORD offset*/
;;;1835                       pData += ((pEntry->BitLength & 0xFFF0) >> 4);
;;;1836                   }
;;;1837                   /*If no other entry was written this result will be returned*/
;;;1838                   result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
;;;1839               }
;;;1840           }
;;;1841   
;;;1842           if (bWritten == 0)
;;;1843           {
;;;1844               /* we didn't write anything, so we have to return the stored error code */
;;;1845               return result;
;;;1846           }
;;;1847       }
;;;1848   
;;;1849       /* ECATCHANGE_START(V5.13) COE4*/
;;;1850       if (pAPPL_CoeWriteInd != NULL)
;;;1851       {
;;;1852           pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
;;;1853       }
;;;1854       /* ECATCHANGE_END(V5.13) COE4*/
;;;1855   
;;;1856       return 0;
;;;1857   }
00007e  b00d              ADD      sp,sp,#0x34
000080  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.132|
000084  f1bb0f00          CMP      r11,#0                ;1412
000088  d103              BNE      |L12.146|
00008a  980b              LDR      r0,[sp,#0x2c]         ;1412
00008c  b108              CBZ      r0,|L12.146|
00008e  7820              LDRB     r0,[r4,#0]            ;1415
000090  9007              STR      r0,[sp,#0x1c]         ;1415
                  |L12.146|
000092  9807              LDR      r0,[sp,#0x1c]         ;1420
000094  9004              STR      r0,[sp,#0x10]         ;1420
000096  e01d              B        |L12.212|
                  |L12.152|
000098  9807              LDR      r0,[sp,#0x1c]         ;1423
00009a  4583              CMP      r11,r0                ;1423
00009c  dd01              BLE      |L12.162|
00009e  2011              MOVS     r0,#0x11              ;1426
0000a0  e7ed              B        |L12.126|
                  |L12.162|
0000a2  4659              MOV      r1,r11                ;1434
0000a4  4650              MOV      r0,r10                ;1434
0000a6  f7fffffe          BL       OBJ_GetEntryDesc
0000aa  4605              MOV      r5,r0                 ;1434
0000ac  7928              LDRB     r0,[r5,#4]            ;1438
0000ae  f0000038          AND      r0,r0,#0x38           ;1438
0000b2  49fa              LDR      r1,|L12.1180|
0000b4  7809              LDRB     r1,[r1,#0]            ;1438  ; nAlStatus
0000b6  ea0100a0          AND      r0,r1,r0,ASR #2       ;1438
0000ba  b958              CBNZ     r0,|L12.212|
0000bc  7928              LDRB     r0,[r5,#4]            ;1441
0000be  f0000038          AND      r0,r0,#0x38           ;1441
0000c2  b928              CBNZ     r0,|L12.208|
0000c4  88a8              LDRH     r0,[r5,#4]            ;1443
0000c6  b908              CBNZ     r0,|L12.204|
0000c8  2005              MOVS     r0,#5                 ;1445
0000ca  e7d8              B        |L12.126|
                  |L12.204|
0000cc  2007              MOVS     r0,#7                 ;1450
0000ce  e7d6              B        |L12.126|
                  |L12.208|
0000d0  201a              MOVS     r0,#0x1a              ;1456
0000d2  e7d4              B        |L12.126|
                  |L12.212|
0000d4  f1bb0f00          CMP      r11,#0                ;1466
0000d8  dd1e              BLE      |L12.280|
0000da  f6414010          MOV      r0,#0x1c10            ;1467
0000de  4286              CMP      r6,r0                 ;1467
0000e0  db03              BLT      |L12.234|
0000e2  f641402f          MOV      r0,#0x1c2f            ;1467
0000e6  4286              CMP      r6,r0                 ;1467
0000e8  dd0f              BLE      |L12.266|
                  |L12.234|
0000ea  f5b65fb0          CMP      r6,#0x1600            ;1467
0000ee  db02              BLT      |L12.246|
0000f0  f5b65fc0          CMP      r6,#0x1800            ;1467
0000f4  db09              BLT      |L12.266|
                  |L12.246|
0000f6  f5b65fd0          CMP      r6,#0x1a00            ;1467
0000fa  db02              BLT      |L12.258|
0000fc  f5b65fe0          CMP      r6,#0x1c00            ;1467
000100  db03              BLT      |L12.266|
                  |L12.258|
000102  f24f0030          MOV      r0,#0xf030            ;1467
000106  4286              CMP      r6,r0                 ;1467
000108  d106              BNE      |L12.280|
                  |L12.266|
00010a  f8da1018          LDR      r1,[r10,#0x18]        ;1471
00010e  7808              LDRB     r0,[r1,#0]            ;1471
000110  b108              CBZ      r0,|L12.278|
000112  2101              MOVS     r1,#1                 ;1474
000114  9105              STR      r1,[sp,#0x14]         ;1474
                  |L12.278|
000116  bf00              NOP                            ;1476
                  |L12.280|
000118  f8da0020          LDR      r0,[r10,#0x20]        ;1478
00011c  b1b0              CBZ      r0,|L12.332|
00011e  2700              MOVS     r7,#0                 ;1482
000120  9817              LDR      r0,[sp,#0x5c]         ;1484
000122  9000              STR      r0,[sp,#0]            ;1484
000124  4623              MOV      r3,r4                 ;1484
000126  f8dac020          LDR      r12,[r10,#0x20]       ;1484
00012a  4659              MOV      r1,r11                ;1484
00012c  4630              MOV      r0,r6                 ;1484
00012e  9a0b              LDR      r2,[sp,#0x2c]         ;1484
000130  47e0              BLX      r12                   ;1484
000132  4607              MOV      r7,r0                 ;1484
000134  b947              CBNZ     r7,|L12.328|
000136  48da              LDR      r0,|L12.1184|
000138  6800              LDR      r0,[r0,#0]            ;1486  ; pAPPL_CoeWriteInd
00013a  b128              CBZ      r0,|L12.328|
00013c  4659              MOV      r1,r11                ;1488
00013e  4630              MOV      r0,r6                 ;1488
000140  4bd7              LDR      r3,|L12.1184|
000142  9a17              LDR      r2,[sp,#0x5c]         ;1488
000144  681b              LDR      r3,[r3,#0]            ;1488  ; pAPPL_CoeWriteInd
000146  4798              BLX      r3                    ;1488
                  |L12.328|
000148  4638              MOV      r0,r7                 ;1491
00014a  e798              B        |L12.126|
                  |L12.332|
00014c  2000              MOVS     r0,#0                 ;1496
00014e  9003              STR      r0,[sp,#0xc]          ;1496
000150  2007              MOVS     r0,#7                 ;1497
000152  9002              STR      r0,[sp,#8]            ;1497
000154  980b              LDR      r0,[sp,#0x2c]         ;1499
000156  b908              CBNZ     r0,|L12.348|
000158  2000              MOVS     r0,#0                 ;1501
00015a  e790              B        |L12.126|
                  |L12.348|
00015c  46d8              MOV      r8,r11                ;1506
00015e  e1d9              B        |L12.1300|
                  |L12.352|
000160  f8da7018          LDR      r7,[r10,#0x18]        ;1509
000164  f04f0900          MOV      r9,#0                 ;1510
000168  f00801ff          AND      r1,r8,#0xff           ;1513
00016c  4650              MOV      r0,r10                ;1513
00016e  f7fffffe          BL       OBJ_GetEntryDesc
000172  4605              MOV      r5,r0                 ;1513
000174  f00800ff          AND      r0,r8,#0xff           ;1516
000178  4651              MOV      r1,r10                ;1516
00017a  f7fffffe          BL       OBJ_GetEntryOffset
00017e  4681              MOV      r9,r0                 ;1516
000180  7928              LDRB     r0,[r5,#4]            ;1520
000182  f0000038          AND      r0,r0,#0x38           ;1520
000186  49c5              LDR      r1,|L12.1180|
000188  7809              LDRB     r1,[r1,#0]            ;1520  ; nAlStatus
00018a  ea0100a0          AND      r0,r1,r0,ASR #2       ;1520
00018e  2800              CMP      r0,#0                 ;1520
000190  d077              BEQ      |L12.642|
000192  f1b80f00          CMP      r8,#0                 ;1523
000196  d003              BEQ      |L12.416|
000198  ea4f1029          ASR      r0,r9,#4              ;1526
00019c  eb070740          ADD      r7,r7,r0,LSL #1       ;1526
                  |L12.416|
0001a0  45d8              CMP      r8,r11                ;1530
0001a2  d004              BEQ      |L12.430|
0001a4  9817              LDR      r0,[sp,#0x5c]         ;1531
0001a6  2800              CMP      r0,#0                 ;1531
0001a8  d06c              BEQ      |L12.644|
0001aa  45d8              CMP      r8,r11                ;1531
0001ac  db6a              BLT      |L12.644|
                  |L12.430|
0001ae  f1b80f00          CMP      r8,#0                 ;1536
0001b2  d10c              BNE      |L12.462|
0001b4  9808              LDR      r0,[sp,#0x20]         ;1536
0001b6  2807              CMP      r0,#7                 ;1536
0001b8  d009              BEQ      |L12.462|
0001ba  7821              LDRB     r1,[r4,#0]            ;1539
0001bc  9806              LDR      r0,[sp,#0x18]         ;1541
0001be  4288              CMP      r0,r1                 ;1541
0001c0  da01              BGE      |L12.454|
0001c2  2013              MOVS     r0,#0x13              ;1543
0001c4  e75b              B        |L12.126|
                  |L12.454|
0001c6  8820              LDRH     r0,[r4,#0]            ;1547
0001c8  8038              STRH     r0,[r7,#0]            ;1547
0001ca  1ca4              ADDS     r4,r4,#2              ;1550
0001cc  e185              B        |L12.1242|
                  |L12.462|
0001ce  8828              LDRH     r0,[r5,#0]            ;1554
0001d0  9000              STR      r0,[sp,#0]            ;1554
0001d2  8828              LDRH     r0,[r5,#0]            ;1555
0001d4  f5b06fe0          CMP      r0,#0x700             ;1555
0001d8  db12              BLT      |L12.512|
0001da  8868              LDRH     r0,[r5,#2]            ;1559
0001dc  2808              CMP      r0,#8                 ;1559
0001de  dc04              BGT      |L12.490|
0001e0  8868              LDRH     r0,[r5,#2]            ;1561
0001e2  302f              ADDS     r0,r0,#0x2f           ;1561
0001e4  b280              UXTH     r0,r0                 ;1561
0001e6  9000              STR      r0,[sp,#0]            ;1561
0001e8  e00a              B        |L12.512|
                  |L12.490|
0001ea  8868              LDRH     r0,[r5,#2]            ;1563
0001ec  2810              CMP      r0,#0x10              ;1563
0001ee  d102              BNE      |L12.502|
0001f0  2006              MOVS     r0,#6                 ;1565
0001f2  9000              STR      r0,[sp,#0]            ;1565
0001f4  e004              B        |L12.512|
                  |L12.502|
0001f6  8868              LDRH     r0,[r5,#2]            ;1567
0001f8  2820              CMP      r0,#0x20              ;1567
0001fa  d101              BNE      |L12.512|
0001fc  2007              MOVS     r0,#7                 ;1569
0001fe  9000              STR      r0,[sp,#0]            ;1569
                  |L12.512|
000200  9800              LDR      r0,[sp,#0]            ;1573
000202  281f              CMP      r0,#0x1f              ;1573
000204  d075              BEQ      |L12.754|
000206  dc12              BGT      |L12.558|
000208  d274              BCS      |L12.756|
00020a  e8dff000          TBB      [pc,r0]               ;1573
00020e  3c52              DCB      0x3c,0x52
000210  5c93fe5d          DCB      0x5c,0x93,0xfe,0x5d
000214  94fdfff9          DCB      0x94,0xfd,0xff,0xf9
000218  f8f77373          DCB      0xf8,0xf7,0x73,0x73
00021c  737373f6          DCB      0x73,0x73,0x73,0xf6
000220  737373f5          DCB      0x73,0x73,0x73,0xf5
000224  73737373          DCB      0x73,0x73,0x73,0x73
000228  73f47373          DCB      0x73,0xf4,0x73,0x73
00022c  5e00              DCB      0x5e,0x00
                  |L12.558|
00022e  2834              CMP      r0,#0x34              ;1573
000230  d044              BEQ      |L12.700|
000232  dc12              BGT      |L12.602|
000234  2830              CMP      r0,#0x30              ;1573
000236  d03d              BEQ      |L12.692|
000238  dc08              BGT      |L12.588|
00023a  2820              CMP      r0,#0x20              ;1573
00023c  d077              BEQ      |L12.814|
00023e  282d              CMP      r0,#0x2d              ;1573
000240  d040              BEQ      |L12.708|
000242  282e              CMP      r0,#0x2e              ;1573
000244  d078              BEQ      |L12.824|
000246  282f              CMP      r0,#0x2f              ;1573
                  |L12.584|
000248  d154              BNE      |L12.756|
00024a  e0e0              B        |L12.1038|
                  |L12.588|
00024c  2831              CMP      r0,#0x31              ;1573
00024e  d032              BEQ      |L12.694|
000250  2832              CMP      r0,#0x32              ;1573
000252  d031              BEQ      |L12.696|
000254  2833              CMP      r0,#0x33              ;1573
000256  d1f7              BNE      |L12.584|
000258  e02f              B        |L12.698|
                  |L12.602|
00025a  f5b07f18          CMP      r0,#0x260             ;1573
00025e  d068              BEQ      |L12.818|
000260  dc06              BGT      |L12.624|
000262  2835              CMP      r0,#0x35              ;1573
000264  d02b              BEQ      |L12.702|
000266  2836              CMP      r0,#0x36              ;1573
000268  d02a              BEQ      |L12.704|
00026a  2837              CMP      r0,#0x37              ;1573
00026c  d1ec              BNE      |L12.584|
00026e  e028              B        |L12.706|
                  |L12.624|
000270  f2a02061          SUB      r0,r0,#0x261          ;1573
000274  2800              CMP      r0,#0                 ;1573
000276  d07c              BEQ      |L12.882|
000278  2801              CMP      r0,#1                 ;1573
00027a  d07b              BEQ      |L12.884|
00027c  2802              CMP      r0,#2                 ;1573
00027e  d1e3              BNE      |L12.584|
000280  e107              B        |L12.1170|
                  |L12.642|
000282  e12d              B        |L12.1248|
                  |L12.644|
000284  e142              B        |L12.1292|
000286  9817              LDR      r0,[sp,#0x5c]         ;1576
000288  b180              CBZ      r0,|L12.684|
00028a  78a8              LDRB     r0,[r5,#2]            ;1579
00028c  f000000f          AND      r0,r0,#0xf            ;1579
000290  2800              CMP      r0,#0                 ;1579
000292  dd05              BLE      |L12.672|
000294  78a8              LDRB     r0,[r5,#2]            ;1580
000296  4448              ADD      r0,r0,r9              ;1580
000298  f000000f          AND      r0,r0,#0xf            ;1580
00029c  b900              CBNZ     r0,|L12.672|
00029e  1ca4              ADDS     r4,r4,#2              ;1583
                  |L12.672|
0002a0  78a8              LDRB     r0,[r5,#2]            ;1587
0002a2  f3c01003          UBFX     r0,r0,#4,#4           ;1587
0002a6  eb040440          ADD      r4,r4,r0,LSL #1       ;1587
0002aa  e001              B        |L12.688|
                  |L12.684|
0002ac  2018              MOVS     r0,#0x18              ;1591
0002ae  e6e6              B        |L12.126|
                  |L12.688|
0002b0  e111              B        |L12.1238|
0002b2  bf00              NOP                            ;1595
                  |L12.692|
0002b4  bf00              NOP                            ;1596
                  |L12.694|
0002b6  bf00              NOP                            ;1597
                  |L12.696|
0002b8  bf00              NOP                            ;1598
                  |L12.698|
0002ba  bf00              NOP                            ;1599
                  |L12.700|
0002bc  bf00              NOP                            ;1600
                  |L12.702|
0002be  bf00              NOP                            ;1601
                  |L12.704|
0002c0  bf00              NOP                            ;1602
                  |L12.706|
0002c2  bf00              NOP                            ;1604
                  |L12.708|
0002c4  bf00              NOP                            ;1608
0002c6  bf00              NOP                            ;1609
0002c8  bf00              NOP                            ;1610
0002ca  2100              MOVS     r1,#0                 ;1613
0002cc  8868              LDRH     r0,[r5,#2]            ;1615
0002ce  4a75              LDR      r2,|L12.1188|
0002d0  f8320010          LDRH     r0,[r2,r0,LSL #1]     ;1615
0002d4  f009020f          AND      r2,r9,#0xf            ;1615
0002d8  4090              LSLS     r0,r0,r2              ;1615
0002da  b280              UXTH     r0,r0                 ;1615
0002dc  9001              STR      r0,[sp,#4]            ;1615
0002de  8839              LDRH     r1,[r7,#0]            ;1618
0002e0  9801              LDR      r0,[sp,#4]            ;1621
0002e2  4381              BICS     r1,r1,r0              ;1621
0002e4  9817              LDR      r0,[sp,#0x5c]         ;1623
0002e6  b130              CBZ      r0,|L12.758|
0002e8  8820              LDRH     r0,[r4,#0]            ;1626
0002ea  9a01              LDR      r2,[sp,#4]            ;1626
0002ec  4010              ANDS     r0,r0,r2              ;1626
0002ee  4301              ORRS     r1,r1,r0              ;1626
0002f0  e015              B        |L12.798|
                  |L12.754|
0002f2  e022              B        |L12.826|
                  |L12.756|
0002f4  e0ed              B        |L12.1234|
                  |L12.758|
0002f6  8820              LDRH     r0,[r4,#0]            ;1630
0002f8  886a              LDRH     r2,[r5,#2]            ;1630
0002fa  4b6a              LDR      r3,|L12.1188|
0002fc  f8332012          LDRH     r2,[r3,r2,LSL #1]     ;1630
000300  4390              BICS     r0,r0,r2              ;1630
000302  b108              CBZ      r0,|L12.776|
000304  2012              MOVS     r0,#0x12              ;1633
000306  e6ba              B        |L12.126|
                  |L12.776|
000308  8820              LDRH     r0,[r4,#0]            ;1638
00030a  886a              LDRH     r2,[r5,#2]            ;1638
00030c  4b65              LDR      r3,|L12.1188|
00030e  f8332012          LDRH     r2,[r3,r2,LSL #1]     ;1638
000312  4010              ANDS     r0,r0,r2              ;1638
000314  f009020f          AND      r2,r9,#0xf            ;1638
000318  4090              LSLS     r0,r0,r2              ;1638
00031a  4308              ORRS     r0,r0,r1              ;1638
00031c  b281              UXTH     r1,r0                 ;1638
                  |L12.798|
00031e  8039              STRH     r1,[r7,#0]            ;1643
000320  78a8              LDRB     r0,[r5,#2]            ;1645
000322  4448              ADD      r0,r0,r9              ;1645
000324  f000000f          AND      r0,r0,#0xf            ;1645
000328  b900              CBNZ     r0,|L12.812|
00032a  1ca4              ADDS     r4,r4,#2              ;1648
                  |L12.812|
00032c  e0d3              B        |L12.1238|
                  |L12.814|
00032e  e06f              B        |L12.1040|
000330  e002              B        |L12.824|
                  |L12.818|
000332  e0ab              B        |L12.1164|
000334  bf00              NOP                            ;1653
000336  bf00              NOP                            ;1654
                  |L12.824|
000338  bf00              NOP                            ;1655
                  |L12.826|
00033a  f009000f          AND      r0,r9,#0xf            ;1656
00033e  b108              CBZ      r0,|L12.836|
000340  2005              MOVS     r0,#5                 ;1659
000342  e69c              B        |L12.126|
                  |L12.836|
000344  8823              LDRH     r3,[r4,#0]            ;1665
000346  9805              LDR      r0,[sp,#0x14]         ;1666
000348  b120              CBZ      r0,|L12.852|
00034a  8838              LDRH     r0,[r7,#0]            ;1666
00034c  4298              CMP      r0,r3                 ;1666
00034e  d001              BEQ      |L12.852|
000350  201c              MOVS     r0,#0x1c              ;1669
000352  e694              B        |L12.126|
                  |L12.852|
000354  f6414010          MOV      r0,#0x1c10            ;1673
000358  4286              CMP      r6,r0                 ;1673
00035a  db15              BLT      |L12.904|
00035c  f641402f          MOV      r0,#0x1c2f            ;1673
000360  4286              CMP      r6,r0                 ;1673
000362  dc11              BGT      |L12.904|
000364  f5b35fb0          CMP      r3,#0x1600            ;1675
000368  db02              BLT      |L12.880|
00036a  f5b35fc0          CMP      r3,#0x1800            ;1675
00036e  db0b              BLT      |L12.904|
                  |L12.880|
000370  e001              B        |L12.886|
                  |L12.882|
000372  e08c              B        |L12.1166|
                  |L12.884|
000374  e08c              B        |L12.1168|
                  |L12.886|
000376  f5b35fd0          CMP      r3,#0x1a00            ;1675
00037a  db02              BLT      |L12.898|
00037c  f5b35fe0          CMP      r3,#0x1c00            ;1675
000380  db02              BLT      |L12.904|
                  |L12.898|
000382  b10b              CBZ      r3,|L12.904|
000384  2012              MOVS     r0,#0x12              ;1677
000386  e67a              B        |L12.126|
                  |L12.904|
000388  f6414032          MOV      r0,#0x1c32            ;1681
00038c  4286              CMP      r6,r0                 ;1681
00038e  d002              BEQ      |L12.918|
000390  1c40              ADDS     r0,r0,#1              ;1681
000392  4286              CMP      r6,r0                 ;1681
000394  d12c              BNE      |L12.1008|
                  |L12.918|
000396  f1b80f01          CMP      r8,#1                 ;1683
00039a  d10e              BNE      |L12.954|
00039c  8838              LDRH     r0,[r7,#0]            ;1686
00039e  4298              CMP      r0,r3                 ;1686
0003a0  d008              BEQ      |L12.948|
0003a2  4619              MOV      r1,r3                 ;1688
0003a4  4630              MOV      r0,r6                 ;1688
0003a6  f7fffffe          BL       CheckSyncTypeValue
0003aa  9002              STR      r0,[sp,#8]            ;1688
0003ac  9802              LDR      r0,[sp,#8]            ;1690
0003ae  b108              CBZ      r0,|L12.948|
0003b0  9802              LDR      r0,[sp,#8]            ;1692
0003b2  e664              B        |L12.126|
                  |L12.948|
0003b4  2001              MOVS     r0,#1                 ;1697
0003b6  493c              LDR      r1,|L12.1192|
0003b8  7008              STRB     r0,[r1,#0]            ;1697
                  |L12.954|
0003ba  f1b80f08          CMP      r8,#8                 ;1700
0003be  d117              BNE      |L12.1008|
0003c0  2000              MOVS     r0,#0                 ;1703
0003c2  493a              LDR      r1,|L12.1196|
0003c4  6148              STR      r0,[r1,#0x14]         ;1703  ; sSyncManOutPar
0003c6  6108              STR      r0,[r1,#0x10]         ;1704  ; sSyncManOutPar
0003c8  6048              STR      r0,[r1,#4]            ;1705  ; sSyncManOutPar
0003ca  4939              LDR      r1,|L12.1200|
0003cc  6148              STR      r0,[r1,#0x14]         ;1707  ; sSyncManInPar
0003ce  6108              STR      r0,[r1,#0x10]         ;1708  ; sSyncManInPar
0003d0  6048              STR      r0,[r1,#4]            ;1709  ; sSyncManInPar
0003d2  f0030002          AND      r0,r3,#2              ;1712
0003d6  2802              CMP      r0,#2                 ;1712
0003d8  d10a              BNE      |L12.1008|
0003da  2000              MOVS     r0,#0                 ;1715
0003dc  4933              LDR      r1,|L12.1196|
0003de  8548              STRH     r0,[r1,#0x2a]         ;1715
0003e0  8508              STRH     r0,[r1,#0x28]         ;1716
0003e2  f8810040          STRB     r0,[r1,#0x40]         ;1717
0003e6  4932              LDR      r1,|L12.1200|
0003e8  8548              STRH     r0,[r1,#0x2a]         ;1719
0003ea  8508              STRH     r0,[r1,#0x28]         ;1720
0003ec  f8810040          STRB     r0,[r1,#0x40]         ;1721
                  |L12.1008|
0003f0  803b              STRH     r3,[r7,#0]            ;1726
0003f2  1ca4              ADDS     r4,r4,#2              ;1727
0003f4  e06f              B        |L12.1238|
0003f6  e024              B        |L12.1090|
0003f8  e022              B        |L12.1088|
0003fa  e020              B        |L12.1086|
0003fc  e045              B        |L12.1162|
0003fe  e043              B        |L12.1160|
000400  e02e              B        |L12.1120|
000402  e003              B        |L12.1036|
000404  e000              B        |L12.1032|
000406  e000              B        |L12.1034|
                  |L12.1032|
000408  bf00              NOP                            ;1731
                  |L12.1034|
00040a  bf00              NOP                            ;1732
                  |L12.1036|
00040c  bf00              NOP                            ;1733
                  |L12.1038|
00040e  bf00              NOP                            ;1734
                  |L12.1040|
000410  f009000f          AND      r0,r9,#0xf            ;1735
000414  b108              CBZ      r0,|L12.1050|
000416  2005              MOVS     r0,#5                 ;1738
000418  e631              B        |L12.126|
                  |L12.1050|
00041a  9805              LDR      r0,[sp,#0x14]         ;1745
00041c  b148              CBZ      r0,|L12.1074|
00041e  8838              LDRH     r0,[r7,#0]            ;1746
000420  8821              LDRH     r1,[r4,#0]            ;1746
000422  4288              CMP      r0,r1                 ;1746
000424  d103              BNE      |L12.1070|
000426  8878              LDRH     r0,[r7,#2]            ;1747
000428  8861              LDRH     r1,[r4,#2]            ;1747
00042a  4288              CMP      r0,r1                 ;1747
00042c  d001              BEQ      |L12.1074|
                  |L12.1070|
00042e  201c              MOVS     r0,#0x1c              ;1750
000430  e625              B        |L12.126|
                  |L12.1074|
000432  8820              LDRH     r0,[r4,#0]            ;1753
000434  8038              STRH     r0,[r7,#0]            ;1753
000436  8860              LDRH     r0,[r4,#2]            ;1754
000438  8078              STRH     r0,[r7,#2]            ;1754
00043a  1d24              ADDS     r4,r4,#4              ;1755
00043c  e04b              B        |L12.1238|
                  |L12.1086|
00043e  bf00              NOP                            ;1760
                  |L12.1088|
000440  bf00              NOP                            ;1761
                  |L12.1090|
000442  f009000f          AND      r0,r9,#0xf            ;1762
000446  b108              CBZ      r0,|L12.1100|
000448  2005              MOVS     r0,#5                 ;1765
00044a  e618              B        |L12.126|
                  |L12.1100|
00044c  8820              LDRH     r0,[r4,#0]            ;1770
00044e  8038              STRH     r0,[r7,#0]            ;1770
000450  8860              LDRH     r0,[r4,#2]            ;1771
000452  8078              STRH     r0,[r7,#2]            ;1771
000454  88a0              LDRH     r0,[r4,#4]            ;1772
000456  80b8              STRH     r0,[r7,#4]            ;1772
000458  88e0              LDRH     r0,[r4,#6]            ;1773
00045a  80f8              STRH     r0,[r7,#6]            ;1773
00045c  3408              ADDS     r4,r4,#8              ;1774
00045e  e03a              B        |L12.1238|
                  |L12.1120|
000460  f009000f          AND      r0,r9,#0xf            ;1777
000464  b108              CBZ      r0,|L12.1130|
000466  2005              MOVS     r0,#5                 ;1780
000468  e609              B        |L12.126|
                  |L12.1130|
00046a  8868              LDRH     r0,[r5,#2]            ;1783
00046c  1dc0              ADDS     r0,r0,#7              ;1783
00046e  10c2              ASRS     r2,r0,#3              ;1783
000470  4621              MOV      r1,r4                 ;1783
000472  4638              MOV      r0,r7                 ;1783
000474  f7fffffe          BL       __aeabi_memcpy
000478  8868              LDRH     r0,[r5,#2]            ;1785
00047a  f020000f          BIC      r0,r0,#0xf            ;1785
00047e  300f              ADDS     r0,r0,#0xf            ;1785
000480  1100              ASRS     r0,r0,#4              ;1785
000482  eb040440          ADD      r4,r4,r0,LSL #1       ;1785
000486  e026              B        |L12.1238|
                  |L12.1160|
000488  bf00              NOP                            ;1788
                  |L12.1162|
00048a  bf00              NOP                            ;1789
                  |L12.1164|
00048c  bf00              NOP                            ;1790
                  |L12.1166|
00048e  bf00              NOP                            ;1791
                  |L12.1168|
000490  bf00              NOP                            ;1792
                  |L12.1170|
000492  f009000f          AND      r0,r9,#0xf            ;1793
000496  b168              CBZ      r0,|L12.1204|
000498  2005              MOVS     r0,#5                 ;1796
00049a  e5f0              B        |L12.126|
                  |L12.1180|
                          DCD      nAlStatus
                  |L12.1184|
                          DCD      pAPPL_CoeWriteInd
                  |L12.1188|
                          DCD      cBitMask
                  |L12.1192|
                          DCD      bSyncSetByUser
                  |L12.1196|
                          DCD      sSyncManOutPar
                  |L12.1200|
                          DCD      sSyncManInPar
                  |L12.1204|
0004b4  8868              LDRH     r0,[r5,#2]            ;1801
0004b6  1dc0              ADDS     r0,r0,#7              ;1801
0004b8  10c2              ASRS     r2,r0,#3              ;1801
0004ba  4621              MOV      r1,r4                 ;1801
0004bc  4638              MOV      r0,r7                 ;1801
0004be  f7fffffe          BL       __aeabi_memcpy
0004c2  8868              LDRH     r0,[r5,#2]            ;1802
0004c4  f020000f          BIC      r0,r0,#0xf            ;1802
0004c8  300f              ADDS     r0,r0,#0xf            ;1802
0004ca  1100              ASRS     r0,r0,#4              ;1802
0004cc  eb040440          ADD      r4,r4,r0,LSL #1       ;1802
0004d0  e001              B        |L12.1238|
                  |L12.1234|
0004d2  2018              MOVS     r0,#0x18              ;1807
0004d4  e5d3              B        |L12.126|
                  |L12.1238|
0004d6  bf00              NOP                            ;1593
0004d8  bf00              NOP                            ;1809
                  |L12.1242|
0004da  2001              MOVS     r0,#1                 ;1812
0004dc  9003              STR      r0,[sp,#0xc]          ;1812
0004de  e015              B        |L12.1292|
                  |L12.1248|
0004e0  f1b80f00          CMP      r8,#0                 ;1819
0004e4  d101              BNE      |L12.1258|
0004e6  1ca4              ADDS     r4,r4,#2              ;1822
0004e8  e00e              B        |L12.1288|
                  |L12.1258|
0004ea  78a8              LDRB     r0,[r5,#2]            ;1827
0004ec  f000000f          AND      r0,r0,#0xf            ;1827
0004f0  2800              CMP      r0,#0                 ;1827
0004f2  dd05              BLE      |L12.1280|
0004f4  78a8              LDRB     r0,[r5,#2]            ;1828
0004f6  4448              ADD      r0,r0,r9              ;1828
0004f8  f000000f          AND      r0,r0,#0xf            ;1828
0004fc  b900              CBNZ     r0,|L12.1280|
0004fe  1ca4              ADDS     r4,r4,#2              ;1831
                  |L12.1280|
000500  8868              LDRH     r0,[r5,#2]            ;1835
000502  0900              LSRS     r0,r0,#4              ;1835
000504  eb040440          ADD      r4,r4,r0,LSL #1       ;1835
                  |L12.1288|
000508  2018              MOVS     r0,#0x18              ;1838
00050a  9002              STR      r0,[sp,#8]            ;1838
                  |L12.1292|
00050c  f1080001          ADD      r0,r8,#1              ;1506
000510  fa1ff880          UXTH     r8,r0                 ;1506
                  |L12.1300|
000514  9804              LDR      r0,[sp,#0x10]         ;1506
000516  4580              CMP      r8,r0                 ;1506
000518  f77fae22          BLE      |L12.352|
00051c  9803              LDR      r0,[sp,#0xc]          ;1842
00051e  b908              CBNZ     r0,|L12.1316|
000520  9802              LDR      r0,[sp,#8]            ;1845
000522  e5ac              B        |L12.126|
                  |L12.1316|
000524  bf00              NOP                            ;1847
000526  4805              LDR      r0,|L12.1340|
000528  6800              LDR      r0,[r0,#0]            ;1850  ; pAPPL_CoeWriteInd
00052a  b128              CBZ      r0,|L12.1336|
00052c  4659              MOV      r1,r11                ;1852
00052e  4630              MOV      r0,r6                 ;1852
000530  4b02              LDR      r3,|L12.1340|
000532  9a17              LDR      r2,[sp,#0x5c]         ;1852
000534  681b              LDR      r3,[r3,#0]            ;1852  ; pAPPL_CoeWriteInd
000536  4798              BLX      r3                    ;1852
                  |L12.1336|
000538  2000              MOVS     r0,#0                 ;1856
00053a  e5a0              B        |L12.126|
;;;1858   /** @} */
                          ENDP

                  |L12.1340|
                          DCD      pAPPL_CoeWriteInd

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sSyncManOutPar
                          %        68
                  sSyncManInPar
                          %        68

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  cBitMask
000000  00000001          DCW      0x0000,0x0001
000004  00030007          DCW      0x0003,0x0007
000008  000f001f          DCW      0x000f,0x001f
00000c  003f007f          DCW      0x003f,0x007f
000010  00ff01ff          DCW      0x00ff,0x01ff
000014  03ff07ff          DCW      0x03ff,0x07ff
000018  0fff1fff          DCW      0x0fff,0x1fff
00001c  3fff7fff          DCW      0x3fff,0x7fff

                          AREA ||.data||, DATA, ALIGN=2

                  bSyncSetByUser
000000  0000              DCB      0x00,0x00
                  sCycleDiag
000002  0000              DCB      0x00,0x00
                  sErrorSettings
000004  0002              DCW      0x0002
000006  0000              DCB      0x00,0x00
                          DCD      0x00000001
00000c  0004              DCW      0x0004
00000e  0000              DCB      0x00,0x00
                  aSubindexDesc
000010  53756249          DCB      0x53,0x75,0x62,0x49
000014  6e646578          DCB      0x6e,0x64,0x65,0x78
000018  20303030          DCB      0x20,0x30,0x30,0x30
00001c  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "etherCAT\\objdef.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_objdef_c_0e8090ec____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_objdef_c_0e8090ec____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_objdef_c_0e8090ec____REVSH|
#line 402
|__asm___8_objdef_c_0e8090ec____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_objdef_c_0e8090ec____RRX|
#line 587
|__asm___8_objdef_c_0e8090ec____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
