; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\sdoserv.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\sdoserv.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\sdoserv.crf etherCAT\sdoserv.c]
                          THUMB

                          AREA ||i.SDOS_ClearPendingResponse||, CODE, READONLY, ALIGN=2

                  SDOS_ClearPendingResponse PROC
;;;1083   
;;;1084   void  SDOS_ClearPendingResponse(void)
000000  b510              PUSH     {r4,lr}
;;;1085   {
;;;1086   	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
000002  481d              LDR      r0,|L1.120|
000004  7800              LDRB     r0,[r0,#0]  ; bSdoInWork
000006  2801              CMP      r0,#1
000008  d115              BNE      |L1.54|
00000a  481c              LDR      r0,|L1.124|
00000c  6800              LDR      r0,[r0,#0]  ; pSdoResStored
00000e  b190              CBZ      r0,|L1.54|
000010  481a              LDR      r0,|L1.124|
000012  6800              LDR      r0,[r0,#0]  ; pSdoResStored
000014  491a              LDR      r1,|L1.128|
000016  6809              LDR      r1,[r1,#0]  ; psRepeatMbx
000018  4288              CMP      r0,r1
00001a  d00c              BEQ      |L1.54|
00001c  4817              LDR      r0,|L1.124|
00001e  6800              LDR      r0,[r0,#0]  ; pSdoResStored
000020  4918              LDR      r1,|L1.132|
000022  6809              LDR      r1,[r1,#0]  ; psStoreMbx
000024  4288              CMP      r0,r1
000026  d006              BEQ      |L1.54|
;;;1087   	{
;;;1088   		APPL_FreeMailboxBuffer(pSdoResStored);
000028  4814              LDR      r0,|L1.124|
00002a  6800              LDR      r0,[r0,#0]  ; pSdoResStored
00002c  f7fffffe          BL       free
;;;1089   		pSdoResStored = NULL;
000030  2000              MOVS     r0,#0
000032  4912              LDR      r1,|L1.124|
000034  6008              STR      r0,[r1,#0]  ; pSdoResStored
                  |L1.54|
;;;1090   	}
;;;1091   
;;;1092   	u8PendingSdo = 0;
000036  2000              MOVS     r0,#0
000038  4913              LDR      r1,|L1.136|
00003a  7008              STRB     r0,[r1,#0]
;;;1093   	bStoreCompleteAccess = FALSE;
00003c  4913              LDR      r1,|L1.140|
00003e  7008              STRB     r0,[r1,#0]
;;;1094   	u16StoreIndex = 0;
000040  4913              LDR      r1,|L1.144|
000042  8008              STRH     r0,[r1,#0]
;;;1095   	u8StoreSubindex = 0;
000044  4913              LDR      r1,|L1.148|
000046  7008              STRB     r0,[r1,#0]
;;;1096   	u32StoreDataSize = 0;
000048  4913              LDR      r1,|L1.152|
00004a  6008              STR      r0,[r1,#0]  ; u32StoreDataSize
;;;1097   	pStoreData = NULL;
00004c  4913              LDR      r1,|L1.156|
00004e  6008              STR      r0,[r1,#0]  ; pStoreData
;;;1098   	pSdoPendFunc = NULL;
000050  4913              LDR      r1,|L1.160|
000052  6008              STR      r0,[r1,#0]  ; pSdoPendFunc
;;;1099   	bSdoInWork = FALSE;
000054  4908              LDR      r1,|L1.120|
000056  7008              STRB     r0,[r1,#0]
;;;1100   
;;;1101   	if (pSdoSegData != NULL)
000058  4812              LDR      r0,|L1.164|
00005a  6800              LDR      r0,[r0,#0]  ; pSdoSegData
00005c  b130              CBZ      r0,|L1.108|
;;;1102   	{
;;;1103   		FREEMEM((UINT16 VARMEM *) pSdoSegData);
00005e  4811              LDR      r0,|L1.164|
000060  6800              LDR      r0,[r0,#0]  ; pSdoSegData
000062  f7fffffe          BL       free
;;;1104   		pSdoSegData = NULL;
000066  2000              MOVS     r0,#0
000068  490e              LDR      r1,|L1.164|
00006a  6008              STR      r0,[r1,#0]  ; pSdoSegData
                  |L1.108|
;;;1105   	}
;;;1106   
;;;1107   	nSdoSegBytesToHandle = 0;
00006c  2000              MOVS     r0,#0
00006e  490e              LDR      r1,|L1.168|
000070  6008              STR      r0,[r1,#0]  ; nSdoSegBytesToHandle
;;;1108   	nSdoSegService = 0;
000072  490e              LDR      r1,|L1.172|
000074  7008              STRB     r0,[r1,#0]
;;;1109   
;;;1110   }
000076  bd10              POP      {r4,pc}
;;;1111   
                          ENDP

                  |L1.120|
                          DCD      bSdoInWork
                  |L1.124|
                          DCD      pSdoResStored
                  |L1.128|
                          DCD      psRepeatMbx
                  |L1.132|
                          DCD      psStoreMbx
                  |L1.136|
                          DCD      u8PendingSdo
                  |L1.140|
                          DCD      bStoreCompleteAccess
                  |L1.144|
                          DCD      u16StoreIndex
                  |L1.148|
                          DCD      u8StoreSubindex
                  |L1.152|
                          DCD      u32StoreDataSize
                  |L1.156|
                          DCD      pStoreData
                  |L1.160|
                          DCD      pSdoPendFunc
                  |L1.164|
                          DCD      pSdoSegData
                  |L1.168|
                          DCD      nSdoSegBytesToHandle
                  |L1.172|
                          DCD      nSdoSegService

                          AREA ||i.SDOS_SdoInd||, CODE, READONLY, ALIGN=2

                  SDOS_SdoInd PROC
;;;637    
;;;638    UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;639    {
000004  b089              SUB      sp,sp,#0x24
000006  4604              MOV      r4,r0
;;;640    	UINT8 abort = 0;
000008  2600              MOVS     r6,#0
;;;641    	UINT8 sdoHeader = (pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK) >> SDOHEADER_COMMANDSHIFT;
00000a  7a27              LDRB     r7,[r4,#8]
;;;642    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 710 to 712 deleted*/
;;;643    	/* the SDO-command is in bit 5-7 of the first SDO-Byte */
;;;644    	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
00000c  f00708e0          AND      r8,r7,#0xe0
;;;645    	/* mbxSize contains the size of the mailbox (CoE-Header (2 Bytes) + SDO-Header (8 Bytes) + SDO-Data (if the data length is greater than 4)) */
;;;646    	UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
000010  8820              LDRH     r0,[r4,#0]
000012  9008              STR      r0,[sp,#0x20]
;;;647    	UINT16 index;
;;;648    	UINT8 subindex;
;;;649    	OBJCONST TOBJECT OBJMEM * pObjEntry;
;;;650    	/* this variable contains the information, if all entries of an object will be read (bCompleteAccess > 0) or a single entry */
;;;651    	UINT8 bCompleteAccess = 0;
000014  46b2              MOV      r10,r6
;;;652    	UINT32 objLength = 0;
000016  46b3              MOV      r11,r6
;;;653    	UINT32 dataSize = 0;
000018  2000              MOVS     r0,#0
00001a  9006              STR      r0,[sp,#0x18]
;;;654    
;;;655    	if (bSdoInWork)
00001c  48fb              LDR      r0,|L2.1036|
00001e  7800              LDRB     r0,[r0,#0]  ; bSdoInWork
000020  b118              CBZ      r0,|L2.42|
;;;656    	{
;;;657    		/* the last SDO is still in work */
;;;658    		return MBXERR_SERVICEINWORK;
000022  2009              MOVS     r0,#9
                  |L2.36|
;;;659    	}
;;;660    
;;;661    /* ECATCHANGE_START(V5.13) COE5*/
;;;662    	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
;;;663    	{
;;;664    		bCompleteAccess = 1;
;;;665    	}
;;;666    /* ECATCHANGE_END(V5.13) COE5*/
;;;667    
;;;668    	switch (command)
;;;669    	{
;;;670    	case SDOSERVICE_INITIATEDOWNLOADREQ:
;;;671    	case SDOSERVICE_INITIATEUPLOADREQ:
;;;672    		/* the variable index contains the requested index of the SDO service */
;;;673    		index = pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK;
;;;674    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 747 to 749 deleted*/
;;;675    		index <<= 8;
;;;676    		index += (pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET] >> SDOHEADER_INDEXLOSHIFT) & SDOHEADER_INDEXLOMASK;
;;;677    		/* the variable subindex contains the requested subindex of the SDO service */
;;;678    		subindex = (pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET] >> SDOHEADER_SUBINDEXSHIFT) & SDOHEADER_SUBINDEXMASK;
;;;679    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 757 to 761 deleted*/
;;;680    
;;;681    
;;;682    /*ET9300 Project Handler :(#if TEST_APPLICATION && EOE_SUPPORTED) lines 764 to 834 deleted*/
;;;683    
;;;684    
;;;685    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 837 to 855 deleted*/
;;;686    
;;;687    		/* OBJ_GetObjectHandle checks if the requested index is defined in the object dictionary */
;;;688    		pObjEntry = OBJ_GetObjectHandle(index);
;;;689    
;;;690    		if (pObjEntry)
;;;691    		{
;;;692    			/* transferType contains the information if the SDO Download Request or the SDO Upload Response
;;;693    			   can be an expedited service (SDO data length <= 4, that means the data is stored in the
;;;694    				SDO-Header completely */
;;;695    			UINT8 bTransferType = 0;
;;;696    			/* pData is the pointer to the received (SDO-Download) or sent (SDO-Upload) SDO data in the mailbox */
;;;697    			UINT16 MBXMEM * pData = NULL;
;;;698    			UINT8 segTransfer = 0;
;;;699    
;;;700    			{
;;;701    				UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
;;;702    
;;;703    				if (subindex > maxSubindex)
;;;704    				{
;;;705    					abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
;;;706    				}
;;;707    				else
;;;708    				{
;;;709    					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
;;;710    				}
;;;711    
;;;712    				if (abort == 0)
;;;713    				{
;;;714    					if (command == SDOSERVICE_INITIATEUPLOADREQ)
;;;715    					{
;;;716    						/* SDO Upload */
;;;717    						if (mbxSize != EXPEDITED_FRAME_SIZE)
;;;718    						{
;;;719    							/* a SDO Upload request has always a fixed size (2 Byte CoE-Header plus 8 Byte SDO-Header) */
;;;720    							return MBXERR_INVALIDSIZE;
;;;721    						}
;;;722    						/* distinguish between expedited and normal upload response within the length of the response data */
;;;723    						if ((objLength <= MAX_EXPEDITED_DATA) && objLength != 0)
;;;724    						{
;;;725    							/* Expedited Upload */
;;;726    							bTransferType = 1;
;;;727    							/* pData is the pointer where the object data has to be copied for the response */
;;;728    							pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)->Data;
;;;729    													/* initialize the 4 data bytes of the SDO upload response because the requested object data
;;;730    														could be less than 4 */
;;;731    							pData[0] = 0;
;;;732    							pData[1] = 0;
;;;733    						}
;;;734    						else
;;;735    						{
;;;736    							/* HBu 06.02.06: the variable dataSize has to be set to the available size in one mailbox */
;;;737    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 910 to 920 deleted*/
;;;738    							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
;;;739    							if (dataSize < objLength)
;;;740    							{
;;;741    								/* Segmented Upload */
;;;742    								segTransfer = 1;
;;;743    							}
;;;744    
;;;745    
;;;746    /*ET9300 Project Handler :(#if SEGMENTED_SDO_SUPPORTED #else) lines 930 to 946 deleted*/
;;;747    							else
;;;748    							{
;;;749    								/* Normal Upload */
;;;750    
;;;751    								/* pData is the pointer where the object data has to be copied for the response */
;;;752    								pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data;
;;;753    							}
;;;754    						}
;;;755    					}
;;;756    					else
;;;757    					{
;;;758    						/* SDO-Download: store if the request is a expedited or normal request  */
;;;759    						bTransferType = sdoHeader & SDOHEADER_TRANSFERTYPE;
;;;760    					}
;;;761    				}
;;;762    			}
;;;763    
;;;764    			if ((abort == 0) && (command == SDOSERVICE_INITIATEDOWNLOADREQ))
;;;765    			{
;;;766    				/* SDO Download */
;;;767    				if (bTransferType)
;;;768    				{
;;;769    					/* Expedited Download */
;;;770    					if (mbxSize != EXPEDITED_FRAME_SIZE)
;;;771    					{
;;;772    						/* an Expedited SDO Download request has always a fixed size (2 Byte CoE-Header plus 8 Byte SDO-Header) */
;;;773    						return MBXERR_INVALIDSIZE;
;;;774    					}
;;;775    					/* dataSize gets the real size of the downloaded object data (1,2,3 or 4) */
;;;776    					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
;;;777    					/* pData is the pointer to the downloaded object data */
;;;778    					pData = (UINT16 MBXMEM *) &pSdoInd[1];
;;;779    				}
;;;780    				else
;;;781    				{
;;;782    					/* Normal Download */
;;;783    					/* downloadSize gets the real size of the downloaded data */
;;;784    					/* '&' operator was too much */
;;;785    
;;;786    					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
;;;787    
;;;788    					/* HBu 29.03.06: if it is a segmented download the mbxSize has to be the complete mailbox size */
;;;789    					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
;;;790    					{
;;;791    						if (mbxSize != (u16ReceiveMbxSize - MBX_HEADER_SIZE))
;;;792    						{
;;;793    							return MBXERR_INVALIDSIZE;
;;;794    						}
;;;795    					}
;;;796    					else
;;;797    					{
;;;798    						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
;;;799    						{
;;;800    							/* the mbxSize and the downloadSize are not consistent (mbxSize = downloadSize + 2 byte CoE-Header + 8 byte SDO Header */
;;;801    							return MBXERR_INVALIDSIZE;
;;;802    						}
;;;803    					}
;;;804    
;;;805    					/* pData is the pointer to the downloaded object data */
;;;806    					pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data;
;;;807    					/* the received dataSize will be checked in the object specific functions called from
;;;808    					   OBJ_Write (in objdef.c) */
;;;809    					dataSize = downloadSize;
;;;810    					if (dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE))
;;;811    					{
;;;812    						/* Segmented Download */
;;;813    						segTransfer = 1;
;;;814    /*ET9300 Project Handler :(#if SEGMENTED_SDO_SUPPORTED #else) lines 1015 to 1017 deleted*/
;;;815    					}
;;;816    				}
;;;817    			}
;;;818    
;;;819    /* ECATCHANGE_START(V5.13) COE5*/
;;;820    			if ((abort == 0) && (bCompleteAccess == 1))
;;;821    /* ECATCHANGE_END(V5.13) COE5*/
;;;822    			{
;;;823    				// HBu 02.05.06: Complete Access is only supported with subindex 0 and 1
;;;824    				if (subindex > 1)
;;;825    				{
;;;826    					abort = ABORTIDX_UNSUPPORTED_ACCESS;
;;;827    				}
;;;828    			}
;;;829    /*ET9300 Project Handler :(#if COMPLETE_ACCESS_SUPPORTED #else) lines 1033 to 1037 deleted*/
;;;830    
;;;831    			if (abort == 0)
;;;832    			{
;;;833    				if (segTransfer)
;;;834    				{
;;;835    					bSdoSegFollows = TRUE;
;;;836    					bSdoSegLastToggle = 1;
;;;837    					bSdoSegAccess = bCompleteAccess;
;;;838    					nSdoSegIndex = index;
;;;839    					nSdoSegSubindex = subindex;
;;;840    					pSdoSegObjEntry = pObjEntry;
;;;841    					if (command == SDOSERVICE_INITIATEUPLOADREQ)
;;;842    					{
;;;843    						nSdoSegCompleteSize = objLength;
;;;844    					}
;;;845    					else
;;;846    					{
;;;847    						nSdoSegCompleteSize = dataSize;
;;;848    					}
;;;849    
;;;850    					if (pSdoSegData != NULL)
;;;851    					{
;;;852    						FREEMEM((UINT16 VARMEM *) pSdoSegData);
;;;853    						pSdoSegData = NULL;
;;;854    					}
;;;855    					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
;;;856    
;;;857    					if (pSdoSegData == NULL)
;;;858    					{
;;;859    						if (bCompleteAccess)
;;;860    						{
;;;861    							abort = ABORTIDX_UNSUPPORTED_ACCESS;
;;;862    						}
;;;863    						else
;;;864    						{
;;;865    							abort = ABORTIDX_OUT_OF_MEMORY;
;;;866    						}
;;;867    					}
;;;868    					else
;;;869    					{
;;;870    						if (command == SDOSERVICE_INITIATEUPLOADREQ)
;;;871    						{
;;;872    							/* Segmented Upload */
;;;873    							abort = OBJ_Read(index, subindex, objLength, pObjEntry, (UINT16 MBXMEM *) pSdoSegData, bCompleteAccess);
;;;874    							if (abort == 0)
;;;875    							{
;;;876    								MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data, pSdoSegData, dataSize);
;;;877    								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
;;;878    							}
;;;879    							else if (abort == ABORTIDX_WORKING)
;;;880    							{
;;;881    								/* the application generates the SDO-Response later on by calling SDOS_SdoRes (only possible if object access function pointer is defined) */
;;;882    								u8PendingSdo = SDO_PENDING_SEG_READ;
;;;883    								bStoreCompleteAccess = bCompleteAccess;
;;;884    								u8StoreSubindex = subindex;
;;;885    								u16StoreIndex = index;
;;;886    								u32StoreDataSize = objLength;
;;;887    								pStoreData = pSdoSegData;
;;;888    								pSdoPendFunc = pObjEntry->Read;
;;;889    
;;;890    								bSdoInWork = TRUE;
;;;891    								/* we have to store the buffer and the response header */
;;;892    								pSdoResStored = pSdoInd;
;;;893    
;;;894    								/*update command field*/
;;;895    								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
;;;896    								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
;;;897    								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
;;;898    								return 0;
;;;899    							}
;;;900    						}
;;;901    						else
;;;902    						{
;;;903    							/* Segmented Download */
;;;904    							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
;;;905    							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
;;;906    							dataSize = (mbxSize - DOWNLOAD_NORM_REQ_SIZE);
;;;907    						}
;;;908    
;;;909    						nSdoSegBytesToHandle = dataSize;
;;;910    					}
;;;911    				}
;;;912    				else
;;;913    				{
;;;914    					if (objLength == 0)
;;;915    					{
;;;916    						/* the objLength is not known, therefore the variables for a possible segmented transfer
;;;917    							should be initialized */
;;;918    						nSdoSegIndex = index;
;;;919    						nSdoSegSubindex = subindex;
;;;920    						pSdoSegObjEntry = pObjEntry;
;;;921    					}
;;;922    					if (command == SDOSERVICE_INITIATEUPLOADREQ)
;;;923    					{
;;;924    						/* Expedited or Normal Upload */
;;;925    						abort = OBJ_Read(index, subindex, objLength, pObjEntry, pData, bCompleteAccess);
;;;926    						if (abort == ABORTIDX_WORKING)
;;;927    						{
;;;928    							/* the application generates the SDO-Response later on by calling SDOS_SdoRes (only possible if object access function pointer is defined) */
;;;929    							u8PendingSdo = SDO_PENDING_READ;
;;;930    							bStoreCompleteAccess = bCompleteAccess;
;;;931    							u8StoreSubindex = subindex;
;;;932    							u16StoreIndex = index;
;;;933    							u32StoreDataSize = objLength;
;;;934    							pStoreData = pData;
;;;935    							pSdoPendFunc = pObjEntry->Read;
;;;936    
;;;937    							bSdoInWork = TRUE;
;;;938    							/* we have to store the buffer and the response header */
;;;939    							pSdoResStored = pSdoInd;
;;;940    
;;;941    							/*update command field*/
;;;942    							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
;;;943    							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
;;;944    							return 0;
;;;945    						}
;;;946    					}
;;;947    					else
;;;948    					{
;;;949    						/* Expedited or Normal Download */
;;;950    						abort = OBJ_Write(index, subindex, dataSize, pObjEntry, pData, bCompleteAccess);
;;;951    						if (abort == ABORTIDX_WORKING)
;;;952    						{
;;;953    							/* the application generates the SDO-Response later on by calling SDOS_SdoRes (only possible if object access function pointer is defined) */
;;;954    							u8PendingSdo = SDO_PENDING_WRITE;
;;;955    							bStoreCompleteAccess = bCompleteAccess;
;;;956    							u8StoreSubindex = subindex;
;;;957    							u16StoreIndex = index;
;;;958    							u32StoreDataSize = dataSize;
;;;959    							pStoreData = pData;
;;;960    							pSdoPendFunc = pObjEntry->Write;
;;;961    
;;;962    							bSdoInWork = TRUE;
;;;963    							/* we have to store the buffer and the response header */
;;;964    							pSdoResStored = pSdoInd;
;;;965    
;;;966    							/*update command field*/
;;;967    							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
;;;968    							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
;;;969    							return 0;
;;;970    						}
;;;971    					}
;;;972    				} /* else if ( objLength == 0 ) */
;;;973    			} /* if ( abort == 0 ) */
;;;974    
;;;975    		} //if(pObjEntry) (Object handle found)
;;;976    		else
;;;977    		{
;;;978    			abort = ABORTIDX_OBJECT_NOT_EXISTING;
;;;979    		}
;;;980    		break;
;;;981    
;;;982    	case SDOSERVICE_DOWNLOADSEGMENTREQ:
;;;983    	case SDOSERVICE_UPLOADSEGMENTREQ:
;;;984    		if (command == nSdoSegService)
;;;985    		{
;;;986    			if (command == SDOSERVICE_DOWNLOADSEGMENTREQ)
;;;987    			{
;;;988    				abort = SdoDownloadSegmentInd((TDOWNLOADSDOSEGREQMBX MBXMEM *) pSdoInd);
;;;989    			}
;;;990    			else
;;;991    			{
;;;992    				abort = SdoUploadSegmentInd((TUPLOADSDOSEGREQMBX MBXMEM *) pSdoInd);
;;;993    			}
;;;994    		}
;;;995    		else
;;;996    		{
;;;997    			abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
;;;998    		}
;;;999    		break;
;;;1000   
;;;1001   	default:
;;;1002   		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
;;;1003   		break;
;;;1004   	}
;;;1005   
;;;1006   	if (abort != ABORTIDX_WORKING)
;;;1007   	{
;;;1008   		/*  type cast was added because of warning */
;;;1009   		SdoRes(abort, command, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16)dataSize, objLength, pSdoInd);
;;;1010   	}
;;;1011   
;;;1012   	return 0;
;;;1013   }
000024  b009              ADD      sp,sp,#0x24
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.42|
00002a  f0070010          AND      r0,r7,#0x10           ;662
00002e  b108              CBZ      r0,|L2.52|
000030  f04f0a01          MOV      r10,#1                ;664
                  |L2.52|
000034  f1b80f00          CMP      r8,#0                 ;668
000038  d074              BEQ      |L2.292|
00003a  f1b80f20          CMP      r8,#0x20              ;668
00003e  d006              BEQ      |L2.78|
000040  f1b80f40          CMP      r8,#0x40              ;668
000044  d004              BEQ      |L2.80|
000046  f1b80f60          CMP      r8,#0x60              ;668
00004a  d16c              BNE      |L2.294|
00004c  e1ba              B        |L2.964|
                  |L2.78|
00004e  bf00              NOP                            ;671
                  |L2.80|
000050  7aa0              LDRB     r0,[r4,#0xa]          ;673
000052  9007              STR      r0,[sp,#0x1c]         ;673
000054  f64f71ff          MOV      r1,#0xffff            ;675
000058  9807              LDR      r0,[sp,#0x1c]         ;675
00005a  ea012000          AND      r0,r1,r0,LSL #8       ;675
00005e  9007              STR      r0,[sp,#0x1c]         ;675
000060  8921              LDRH     r1,[r4,#8]            ;676
000062  9807              LDR      r0,[sp,#0x1c]         ;676
000064  eb002011          ADD      r0,r0,r1,LSR #8       ;676
000068  b280              UXTH     r0,r0                 ;676
00006a  9007              STR      r0,[sp,#0x1c]         ;676
00006c  8960              LDRH     r0,[r4,#0xa]          ;678
00006e  ea4f2910          LSR      r9,r0,#8              ;678
000072  9807              LDR      r0,[sp,#0x1c]         ;688
000074  f7fffffe          BL       OBJ_GetObjectHandle
000078  4605              MOV      r5,r0                 ;688
00007a  2d00              CMP      r5,#0                 ;690
00007c  d06e              BEQ      |L2.348|
00007e  2000              MOVS     r0,#0                 ;695
000080  9005              STR      r0,[sp,#0x14]         ;695
000082  9004              STR      r0,[sp,#0x10]         ;697
000084  9003              STR      r0,[sp,#0xc]          ;698
000086  7b28              LDRB     r0,[r5,#0xc]          ;701
000088  9002              STR      r0,[sp,#8]            ;701
00008a  9802              LDR      r0,[sp,#8]            ;703
00008c  4581              CMP      r9,r0                 ;703
00008e  dd01              BLE      |L2.148|
000090  2611              MOVS     r6,#0x11              ;705
000092  e008              B        |L2.166|
                  |L2.148|
000094  f0070310          AND      r3,r7,#0x10           ;709
000098  462a              MOV      r2,r5                 ;709
00009a  4649              MOV      r1,r9                 ;709
00009c  9807              LDR      r0,[sp,#0x1c]         ;709
00009e  f7fffffe          BL       OBJ_GetObjectLength
0000a2  4683              MOV      r11,r0                ;709
0000a4  9006              STR      r0,[sp,#0x18]         ;709
                  |L2.166|
0000a6  bb0e              CBNZ     r6,|L2.236|
0000a8  f1b80f40          CMP      r8,#0x40              ;714
0000ac  d123              BNE      |L2.246|
0000ae  9808              LDR      r0,[sp,#0x20]         ;717
0000b0  280a              CMP      r0,#0xa               ;717
0000b2  d001              BEQ      |L2.184|
0000b4  2008              MOVS     r0,#8                 ;720
0000b6  e7b5              B        |L2.36|
                  |L2.184|
0000b8  f1bb0f04          CMP      r11,#4                ;723
0000bc  d80d              BHI      |L2.218|
0000be  f1bb0f00          CMP      r11,#0                ;723
0000c2  d00a              BEQ      |L2.218|
0000c4  2001              MOVS     r0,#1                 ;726
0000c6  9005              STR      r0,[sp,#0x14]         ;726
0000c8  f104000c          ADD      r0,r4,#0xc            ;728
0000cc  9004              STR      r0,[sp,#0x10]         ;728
0000ce  2100              MOVS     r1,#0                 ;731
0000d0  9804              LDR      r0,[sp,#0x10]         ;731
0000d2  8001              STRH     r1,[r0,#0]            ;731
0000d4  9804              LDR      r0,[sp,#0x10]         ;732
0000d6  8041              STRH     r1,[r0,#2]            ;732
0000d8  e010              B        |L2.252|
                  |L2.218|
0000da  48cd              LDR      r0,|L2.1040|
0000dc  8800              LDRH     r0,[r0,#0]            ;738  ; u16SendMbxSize
0000de  3810              SUBS     r0,r0,#0x10           ;738
0000e0  9006              STR      r0,[sp,#0x18]         ;738
0000e2  9806              LDR      r0,[sp,#0x18]         ;739
0000e4  4558              CMP      r0,r11                ;739
0000e6  d202              BCS      |L2.238|
0000e8  2001              MOVS     r0,#1                 ;742
0000ea  9003              STR      r0,[sp,#0xc]          ;742
                  |L2.236|
0000ec  e006              B        |L2.252|
                  |L2.238|
0000ee  f1040010          ADD      r0,r4,#0x10           ;752
0000f2  9004              STR      r0,[sp,#0x10]         ;752
0000f4  e002              B        |L2.252|
                  |L2.246|
0000f6  f0070002          AND      r0,r7,#2              ;759
0000fa  9005              STR      r0,[sp,#0x14]         ;759
                  |L2.252|
0000fc  bb6e              CBNZ     r6,|L2.346|
0000fe  f1b80f20          CMP      r8,#0x20              ;764
000102  d138              BNE      |L2.374|
000104  9805              LDR      r0,[sp,#0x14]         ;767
000106  b178              CBZ      r0,|L2.296|
000108  9808              LDR      r0,[sp,#0x20]         ;770
00010a  280a              CMP      r0,#0xa               ;770
00010c  d001              BEQ      |L2.274|
00010e  2008              MOVS     r0,#8                 ;773
000110  e788              B        |L2.36|
                  |L2.274|
000112  f3c70081          UBFX     r0,r7,#2,#2           ;776
000116  f1c00004          RSB      r0,r0,#4              ;776
00011a  9006              STR      r0,[sp,#0x18]         ;776
00011c  f104000c          ADD      r0,r4,#0xc            ;778
000120  9004              STR      r0,[sp,#0x10]         ;778
000122  e028              B        |L2.374|
                  |L2.292|
000124  e14d              B        |L2.962|
                  |L2.294|
000126  e160              B        |L2.1002|
                  |L2.296|
000128  89a2              LDRH     r2,[r4,#0xc]          ;786
00012a  89e0              LDRH     r0,[r4,#0xe]          ;786
00012c  eb024100          ADD      r1,r2,r0,LSL #16      ;786
000130  f1010010          ADD      r0,r1,#0x10           ;789
000134  4ab7              LDR      r2,|L2.1044|
000136  8812              LDRH     r2,[r2,#0]            ;789  ; u16ReceiveMbxSize
000138  4290              CMP      r0,r2                 ;789
00013a  d907              BLS      |L2.332|
00013c  48b5              LDR      r0,|L2.1044|
00013e  8800              LDRH     r0,[r0,#0]            ;791  ; u16ReceiveMbxSize
000140  1f80              SUBS     r0,r0,#6              ;791
000142  9a08              LDR      r2,[sp,#0x20]         ;791
000144  4290              CMP      r0,r2                 ;791
000146  d00a              BEQ      |L2.350|
000148  2008              MOVS     r0,#8                 ;793
00014a  e76b              B        |L2.36|
                  |L2.332|
00014c  f101000a          ADD      r0,r1,#0xa            ;798
000150  9a08              LDR      r2,[sp,#0x20]         ;798
000152  4290              CMP      r0,r2                 ;798
000154  d003              BEQ      |L2.350|
000156  2008              MOVS     r0,#8                 ;801
000158  e764              B        |L2.36|
                  |L2.346|
00015a  e00c              B        |L2.374|
                  |L2.348|
00015c  e12f              B        |L2.958|
                  |L2.350|
00015e  f1040010          ADD      r0,r4,#0x10           ;806
000162  9004              STR      r0,[sp,#0x10]         ;806
000164  9106              STR      r1,[sp,#0x18]         ;809
000166  9808              LDR      r0,[sp,#0x20]         ;810
000168  380a              SUBS     r0,r0,#0xa            ;810
00016a  9906              LDR      r1,[sp,#0x18]         ;810
00016c  4288              CMP      r0,r1                 ;810
00016e  d201              BCS      |L2.372|
000170  2001              MOVS     r0,#1                 ;813
000172  9003              STR      r0,[sp,#0xc]          ;813
                  |L2.372|
000174  bf00              NOP                            ;816
                  |L2.374|
000176  b936              CBNZ     r6,|L2.390|
000178  f1ba0f01          CMP      r10,#1                ;820
00017c  d103              BNE      |L2.390|
00017e  f1b90f01          CMP      r9,#1                 ;824
000182  dd00              BLE      |L2.390|
000184  2605              MOVS     r6,#5                 ;826
                  |L2.390|
000186  2e00              CMP      r6,#0                 ;831
000188  d136              BNE      |L2.504|
00018a  9803              LDR      r0,[sp,#0xc]          ;833
00018c  2800              CMP      r0,#0                 ;833
00018e  d07d              BEQ      |L2.652|
000190  2001              MOVS     r0,#1                 ;835
000192  49a1              LDR      r1,|L2.1048|
000194  7008              STRB     r0,[r1,#0]            ;835
000196  49a1              LDR      r1,|L2.1052|
000198  7008              STRB     r0,[r1,#0]            ;836
00019a  48a1              LDR      r0,|L2.1056|
00019c  f880a000          STRB     r10,[r0,#0]           ;837
0001a0  49a0              LDR      r1,|L2.1060|
0001a2  9807              LDR      r0,[sp,#0x1c]         ;838
0001a4  8008              STRH     r0,[r1,#0]            ;838
0001a6  48a0              LDR      r0,|L2.1064|
0001a8  f8809000          STRB     r9,[r0,#0]            ;839
0001ac  489f              LDR      r0,|L2.1068|
0001ae  6005              STR      r5,[r0,#0]            ;840  ; pSdoSegObjEntry
0001b0  f1b80f40          CMP      r8,#0x40              ;841
0001b4  d103              BNE      |L2.446|
0001b6  489e              LDR      r0,|L2.1072|
0001b8  f8c0b000          STR      r11,[r0,#0]           ;843  ; nSdoSegCompleteSize
0001bc  e002              B        |L2.452|
                  |L2.446|
0001be  499c              LDR      r1,|L2.1072|
0001c0  9806              LDR      r0,[sp,#0x18]         ;847
0001c2  6008              STR      r0,[r1,#0]            ;847  ; nSdoSegCompleteSize
                  |L2.452|
0001c4  489b              LDR      r0,|L2.1076|
0001c6  6800              LDR      r0,[r0,#0]            ;850  ; pSdoSegData
0001c8  b130              CBZ      r0,|L2.472|
0001ca  489a              LDR      r0,|L2.1076|
0001cc  6800              LDR      r0,[r0,#0]            ;852  ; pSdoSegData
0001ce  f7fffffe          BL       free
0001d2  2000              MOVS     r0,#0                 ;853
0001d4  4997              LDR      r1,|L2.1076|
0001d6  6008              STR      r0,[r1,#0]            ;853  ; pSdoSegData
                  |L2.472|
0001d8  4995              LDR      r1,|L2.1072|
0001da  6809              LDR      r1,[r1,#0]            ;855  ; nSdoSegCompleteSize
0001dc  1c49              ADDS     r1,r1,#1              ;855
0001de  0849              LSRS     r1,r1,#1              ;855
0001e0  0048              LSLS     r0,r1,#1              ;855
0001e2  f7fffffe          BL       malloc
0001e6  4993              LDR      r1,|L2.1076|
0001e8  6008              STR      r0,[r1,#0]            ;855  ; pSdoSegData
0001ea  4608              MOV      r0,r1                 ;857
0001ec  6800              LDR      r0,[r0,#0]            ;857  ; pSdoSegData
0001ee  b930              CBNZ     r0,|L2.510|
0001f0  f1ba0f00          CMP      r10,#0                ;859
0001f4  d001              BEQ      |L2.506|
0001f6  2605              MOVS     r6,#5                 ;861
                  |L2.504|
0001f8  e0e0              B        |L2.956|
                  |L2.506|
0001fa  2604              MOVS     r6,#4                 ;865
0001fc  e0de              B        |L2.956|
                  |L2.510|
0001fe  f1b80f40          CMP      r8,#0x40              ;870
000202  d14a              BNE      |L2.666|
000204  488b              LDR      r0,|L2.1076|
000206  6800              LDR      r0,[r0,#0]            ;873  ; pSdoSegData
000208  462b              MOV      r3,r5                 ;873
00020a  465a              MOV      r2,r11                ;873
00020c  4649              MOV      r1,r9                 ;873
00020e  e9cd0a00          STRD     r0,r10,[sp,#0]        ;873
000212  9807              LDR      r0,[sp,#0x1c]         ;873
000214  f7fffffe          BL       OBJ_Read
000218  4606              MOV      r6,r0                 ;873
00021a  b956              CBNZ     r6,|L2.562|
00021c  4885              LDR      r0,|L2.1076|
00021e  9a06              LDR      r2,[sp,#0x18]         ;876
000220  6801              LDR      r1,[r0,#0]            ;876  ; pSdoSegData
000222  f1040010          ADD      r0,r4,#0x10           ;876
000226  f7fffffe          BL       __aeabi_memcpy
00022a  2060              MOVS     r0,#0x60              ;877
00022c  4982              LDR      r1,|L2.1080|
00022e  7008              STRB     r0,[r1,#0]            ;877
000230  e042              B        |L2.696|
                  |L2.562|
000232  2eff              CMP      r6,#0xff              ;879
000234  d140              BNE      |L2.696|
000236  2004              MOVS     r0,#4                 ;882
000238  4980              LDR      r1,|L2.1084|
00023a  7008              STRB     r0,[r1,#0]            ;882
00023c  4880              LDR      r0,|L2.1088|
00023e  f880a000          STRB     r10,[r0,#0]           ;883
000242  4880              LDR      r0,|L2.1092|
000244  f8809000          STRB     r9,[r0,#0]            ;884
000248  497f              LDR      r1,|L2.1096|
00024a  9807              LDR      r0,[sp,#0x1c]         ;885
00024c  8008              STRH     r0,[r1,#0]            ;885
00024e  487f              LDR      r0,|L2.1100|
000250  f8c0b000          STR      r11,[r0,#0]           ;886  ; u32StoreDataSize
000254  4877              LDR      r0,|L2.1076|
000256  6800              LDR      r0,[r0,#0]            ;887  ; pSdoSegData
000258  497d              LDR      r1,|L2.1104|
00025a  6008              STR      r0,[r1,#0]            ;887  ; pStoreData
00025c  497d              LDR      r1,|L2.1108|
00025e  69e8              LDR      r0,[r5,#0x1c]         ;888
000260  6008              STR      r0,[r1,#0]            ;888  ; pSdoPendFunc
000262  2001              MOVS     r0,#1                 ;890
000264  4969              LDR      r1,|L2.1036|
000266  7008              STRB     r0,[r1,#0]            ;890
000268  487b              LDR      r0,|L2.1112|
00026a  6004              STR      r4,[r0,#0]            ;892  ; pSdoResStored
00026c  6800              LDR      r0,[r0,#0]            ;895  ; pSdoResStored
00026e  8900              LDRH     r0,[r0,#8]            ;895
000270  f02000ff          BIC      r0,r0,#0xff           ;895
000274  4978              LDR      r1,|L2.1112|
000276  6809              LDR      r1,[r1,#0]            ;895  ; pSdoResStored
000278  8108              STRH     r0,[r1,#8]            ;895
00027a  4877              LDR      r0,|L2.1112|
00027c  6800              LDR      r0,[r0,#0]            ;896  ; pSdoResStored
00027e  8900              LDRH     r0,[r0,#8]            ;896
000280  f00701f0          AND      r1,r7,#0xf0           ;896
000284  4308              ORRS     r0,r0,r1              ;896
000286  4974              LDR      r1,|L2.1112|
000288  6809              LDR      r1,[r1,#0]            ;896  ; pSdoResStored
00028a  e000              B        |L2.654|
                  |L2.652|
00028c  e018              B        |L2.704|
                  |L2.654|
00028e  8108              STRH     r0,[r1,#8]            ;896
000290  2060              MOVS     r0,#0x60              ;897
000292  4969              LDR      r1,|L2.1080|
000294  7008              STRB     r0,[r1,#0]            ;897
000296  2000              MOVS     r0,#0                 ;898
000298  e6c4              B        |L2.36|
                  |L2.666|
00029a  9808              LDR      r0,[sp,#0x20]         ;904
00029c  f1a0020a          SUB      r2,r0,#0xa            ;904
0002a0  f1040110          ADD      r1,r4,#0x10           ;904
0002a4  4863              LDR      r0,|L2.1076|
0002a6  6800              LDR      r0,[r0,#0]            ;904  ; pSdoSegData
0002a8  f7fffffe          BL       __aeabi_memcpy
0002ac  2000              MOVS     r0,#0                 ;905
0002ae  4962              LDR      r1,|L2.1080|
0002b0  7008              STRB     r0,[r1,#0]            ;905
0002b2  9808              LDR      r0,[sp,#0x20]         ;906
0002b4  380a              SUBS     r0,r0,#0xa            ;906
0002b6  9006              STR      r0,[sp,#0x18]         ;906
                  |L2.696|
0002b8  4968              LDR      r1,|L2.1116|
0002ba  9806              LDR      r0,[sp,#0x18]         ;909
0002bc  6008              STR      r0,[r1,#0]            ;909  ; nSdoSegBytesToHandle
0002be  e07d              B        |L2.956|
                  |L2.704|
0002c0  f1bb0f00          CMP      r11,#0                ;914
0002c4  d107              BNE      |L2.726|
0002c6  4957              LDR      r1,|L2.1060|
0002c8  9807              LDR      r0,[sp,#0x1c]         ;918
0002ca  8008              STRH     r0,[r1,#0]            ;918
0002cc  4856              LDR      r0,|L2.1064|
0002ce  f8809000          STRB     r9,[r0,#0]            ;919
0002d2  4856              LDR      r0,|L2.1068|
0002d4  6005              STR      r5,[r0,#0]            ;920  ; pSdoSegObjEntry
                  |L2.726|
0002d6  f1b80f40          CMP      r8,#0x40              ;922
0002da  d137              BNE      |L2.844|
0002dc  9804              LDR      r0,[sp,#0x10]         ;925
0002de  462b              MOV      r3,r5                 ;925
0002e0  465a              MOV      r2,r11                ;925
0002e2  4649              MOV      r1,r9                 ;925
0002e4  e9cd0a00          STRD     r0,r10,[sp,#0]        ;925
0002e8  9807              LDR      r0,[sp,#0x1c]         ;925
0002ea  f7fffffe          BL       OBJ_Read
0002ee  4606              MOV      r6,r0                 ;925
0002f0  2eff              CMP      r6,#0xff              ;926
0002f2  d163              BNE      |L2.956|
0002f4  2003              MOVS     r0,#3                 ;929
0002f6  4951              LDR      r1,|L2.1084|
0002f8  7008              STRB     r0,[r1,#0]            ;929
0002fa  4851              LDR      r0,|L2.1088|
0002fc  f880a000          STRB     r10,[r0,#0]           ;930
000300  4850              LDR      r0,|L2.1092|
000302  f8809000          STRB     r9,[r0,#0]            ;931
000306  4950              LDR      r1,|L2.1096|
000308  9807              LDR      r0,[sp,#0x1c]         ;932
00030a  8008              STRH     r0,[r1,#0]            ;932
00030c  484f              LDR      r0,|L2.1100|
00030e  f8c0b000          STR      r11,[r0,#0]           ;933  ; u32StoreDataSize
000312  494f              LDR      r1,|L2.1104|
000314  9804              LDR      r0,[sp,#0x10]         ;934
000316  6008              STR      r0,[r1,#0]            ;934  ; pStoreData
000318  484e              LDR      r0,|L2.1108|
00031a  69e9              LDR      r1,[r5,#0x1c]         ;935
00031c  6001              STR      r1,[r0,#0]            ;935  ; pSdoPendFunc
00031e  2001              MOVS     r0,#1                 ;937
000320  493a              LDR      r1,|L2.1036|
000322  7008              STRB     r0,[r1,#0]            ;937
000324  484c              LDR      r0,|L2.1112|
000326  6004              STR      r4,[r0,#0]            ;939  ; pSdoResStored
000328  6800              LDR      r0,[r0,#0]            ;942  ; pSdoResStored
00032a  8900              LDRH     r0,[r0,#8]            ;942
00032c  f02000ff          BIC      r0,r0,#0xff           ;942
000330  4949              LDR      r1,|L2.1112|
000332  6809              LDR      r1,[r1,#0]            ;942  ; pSdoResStored
000334  8108              STRH     r0,[r1,#8]            ;942
000336  4848              LDR      r0,|L2.1112|
000338  6800              LDR      r0,[r0,#0]            ;943  ; pSdoResStored
00033a  8900              LDRH     r0,[r0,#8]            ;943
00033c  f00701f0          AND      r1,r7,#0xf0           ;943
000340  4308              ORRS     r0,r0,r1              ;943
000342  4945              LDR      r1,|L2.1112|
000344  6809              LDR      r1,[r1,#0]            ;943  ; pSdoResStored
000346  8108              STRH     r0,[r1,#8]            ;943
000348  2000              MOVS     r0,#0                 ;944
00034a  e66b              B        |L2.36|
                  |L2.844|
00034c  9804              LDR      r0,[sp,#0x10]         ;950
00034e  462b              MOV      r3,r5                 ;950
000350  e9cd0a00          STRD     r0,r10,[sp,#0]        ;950
000354  4649              MOV      r1,r9                 ;950
000356  e9dd2006          LDRD     r2,r0,[sp,#0x18]      ;950
00035a  f7fffffe          BL       OBJ_Write
00035e  4606              MOV      r6,r0                 ;950
000360  2eff              CMP      r6,#0xff              ;951
000362  d12b              BNE      |L2.956|
000364  2001              MOVS     r0,#1                 ;954
000366  4935              LDR      r1,|L2.1084|
000368  7008              STRB     r0,[r1,#0]            ;954
00036a  4835              LDR      r0,|L2.1088|
00036c  f880a000          STRB     r10,[r0,#0]           ;955
000370  4834              LDR      r0,|L2.1092|
000372  f8809000          STRB     r9,[r0,#0]            ;956
000376  4934              LDR      r1,|L2.1096|
000378  9807              LDR      r0,[sp,#0x1c]         ;957
00037a  8008              STRH     r0,[r1,#0]            ;957
00037c  4933              LDR      r1,|L2.1100|
00037e  9806              LDR      r0,[sp,#0x18]         ;958
000380  6008              STR      r0,[r1,#0]            ;958  ; u32StoreDataSize
000382  4933              LDR      r1,|L2.1104|
000384  9804              LDR      r0,[sp,#0x10]         ;959
000386  6008              STR      r0,[r1,#0]            ;959  ; pStoreData
000388  4932              LDR      r1,|L2.1108|
00038a  6a28              LDR      r0,[r5,#0x20]         ;960
00038c  6008              STR      r0,[r1,#0]            ;960  ; pSdoPendFunc
00038e  2001              MOVS     r0,#1                 ;962
000390  491e              LDR      r1,|L2.1036|
000392  7008              STRB     r0,[r1,#0]            ;962
000394  4830              LDR      r0,|L2.1112|
000396  6004              STR      r4,[r0,#0]            ;964  ; pSdoResStored
000398  6800              LDR      r0,[r0,#0]            ;967  ; pSdoResStored
00039a  8900              LDRH     r0,[r0,#8]            ;967
00039c  f02000ff          BIC      r0,r0,#0xff           ;967
0003a0  492d              LDR      r1,|L2.1112|
0003a2  6809              LDR      r1,[r1,#0]            ;967  ; pSdoResStored
0003a4  8108              STRH     r0,[r1,#8]            ;967
0003a6  482c              LDR      r0,|L2.1112|
0003a8  6800              LDR      r0,[r0,#0]            ;968  ; pSdoResStored
0003aa  8900              LDRH     r0,[r0,#8]            ;968
0003ac  f00701f0          AND      r1,r7,#0xf0           ;968
0003b0  4308              ORRS     r0,r0,r1              ;968
0003b2  4929              LDR      r1,|L2.1112|
0003b4  6809              LDR      r1,[r1,#0]            ;968  ; pSdoResStored
0003b6  8108              STRH     r0,[r1,#8]            ;968
0003b8  2000              MOVS     r0,#0                 ;969
0003ba  e633              B        |L2.36|
                  |L2.956|
0003bc  e000              B        |L2.960|
                  |L2.958|
0003be  2608              MOVS     r6,#8                 ;978
                  |L2.960|
0003c0  e015              B        |L2.1006|
                  |L2.962|
0003c2  bf00              NOP                            ;983
                  |L2.964|
0003c4  481c              LDR      r0,|L2.1080|
0003c6  7800              LDRB     r0,[r0,#0]            ;984  ; nSdoSegService
0003c8  4580              CMP      r8,r0                 ;984
0003ca  d10c              BNE      |L2.998|
0003cc  f1b80f00          CMP      r8,#0                 ;986
0003d0  d104              BNE      |L2.988|
0003d2  4620              MOV      r0,r4                 ;988
0003d4  f7fffffe          BL       SdoDownloadSegmentInd
0003d8  4606              MOV      r6,r0                 ;988
0003da  e005              B        |L2.1000|
                  |L2.988|
0003dc  4620              MOV      r0,r4                 ;992
0003de  f7fffffe          BL       SdoUploadSegmentInd
0003e2  4606              MOV      r6,r0                 ;992
0003e4  e000              B        |L2.1000|
                  |L2.998|
0003e6  2603              MOVS     r6,#3                 ;997
                  |L2.1000|
0003e8  e001              B        |L2.1006|
                  |L2.1002|
0003ea  2603              MOVS     r6,#3                 ;1002
0003ec  bf00              NOP                            ;1003
                  |L2.1006|
0003ee  bf00              NOP                            ;980
0003f0  2eff              CMP      r6,#0xff              ;1006
0003f2  d009              BEQ      |L2.1032|
0003f4  e9cdb400          STRD     r11,r4,[sp,#0]        ;1009
0003f8  9806              LDR      r0,[sp,#0x18]         ;1009
0003fa  b283              UXTH     r3,r0                 ;1009
0003fc  f0070210          AND      r2,r7,#0x10           ;1009
000400  4641              MOV      r1,r8                 ;1009
000402  4630              MOV      r0,r6                 ;1009
000404  f7fffffe          BL       SdoRes
                  |L2.1032|
000408  2000              MOVS     r0,#0                 ;1012
00040a  e60b              B        |L2.36|
                  |L2.1036|
                          DCD      bSdoInWork
                  |L2.1040|
                          DCD      u16SendMbxSize
                  |L2.1044|
                          DCD      u16ReceiveMbxSize
                  |L2.1048|
                          DCD      bSdoSegFollows
                  |L2.1052|
                          DCD      bSdoSegLastToggle
                  |L2.1056|
                          DCD      bSdoSegAccess
                  |L2.1060|
                          DCD      nSdoSegIndex
                  |L2.1064|
                          DCD      nSdoSegSubindex
                  |L2.1068|
                          DCD      pSdoSegObjEntry
                  |L2.1072|
                          DCD      nSdoSegCompleteSize
                  |L2.1076|
                          DCD      pSdoSegData
                  |L2.1080|
                          DCD      nSdoSegService
                  |L2.1084|
                          DCD      u8PendingSdo
                  |L2.1088|
                          DCD      bStoreCompleteAccess
                  |L2.1092|
                          DCD      u8StoreSubindex
                  |L2.1096|
                          DCD      u16StoreIndex
                  |L2.1100|
                          DCD      u32StoreDataSize
                  |L2.1104|
                          DCD      pStoreData
                  |L2.1108|
                          DCD      pSdoPendFunc
                  |L2.1112|
                          DCD      pSdoResStored
                  |L2.1116|
                          DCD      nSdoSegBytesToHandle
                          ENDP


                          AREA ||i.SDOS_SdoInfoInd||, CODE, READONLY, ALIGN=2

                  SDOS_SdoInfoInd PROC
;;;1122   
;;;1123   UINT8 SDOS_SdoInfoInd(TSDOINFORMATION MBXMEM *pSdoInfoInd)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1124   {
000004  4604              MOV      r4,r0
;;;1125   	UINT8 abort = 0;
000006  2000              MOVS     r0,#0
000008  9002              STR      r0,[sp,#8]
;;;1126   	/* the variable opCode contains the requested SDO Information type */
;;;1127   	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
00000a  7a20              LDRB     r0,[r4,#8]
00000c  f000067f          AND      r6,r0,#0x7f
;;;1128   	OBJCONST TOBJECT OBJMEM * pObjEntry;
;;;1129   	UINT16 index;
;;;1130   	UINT8 flags = COE_SERVICE;
000010  f04f0902          MOV      r9,#2
;;;1131   
;;;1132   	/* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
;;;1133   	   great enough for the service header of the requested SDO Information type */
;;;1134   	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
000014  2e05              CMP      r6,#5
000016  d105              BNE      |L3.36|
;;;1135   	{
;;;1136   		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT)
000018  8820              LDRH     r0,[r4,#0]
00001a  280a              CMP      r0,#0xa
00001c  da07              BGE      |L3.46|
;;;1137   		{
;;;1138   			return MBXERR_SIZETOOSHORT;
00001e  2006              MOVS     r0,#6
                  |L3.32|
;;;1139   		}
;;;1140   	}
;;;1141   	else
;;;1142   	{
;;;1143   		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT)
;;;1144   		{
;;;1145   			return MBXERR_SIZETOOSHORT;
;;;1146   		}
;;;1147   	}
;;;1148   
;;;1149   	switch (opCode)
;;;1150   	{
;;;1151   	case SDOINFOSERVICE_OBJDICTIONARYLIST_Q:
;;;1152   		/* an object list is requested, check if the list type is supported */
;;;1153   		if (SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX)
;;;1154   		{
;;;1155   			UINT16 size = 0;
;;;1156   			/* the variable listType contains the requested listType */
;;;1157   			UINT8 listType = (UINT8)SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType);
;;;1158   
;;;1159   			/* the SDO Information Header has to be stored because this function will be
;;;1160   			   called again if the response could not be sent with one mailbox service, the
;;;1161   			   variable nSdoInfoFragmentsLeft is 0 zero for the first call and unequal 0
;;;1162   			   for the following calls */
;;;1163   			MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
;;;1164   			if (listType-- == 0)
;;;1165   			{
;;;1166   				/* List-Type 0: length of the lists */
;;;1167   				UINT8 i;
;;;1168   
;;;1169   				/* the needed mailbox size for List-Type 0 response is just 24 bytes, the mailbox has always
;;;1170   				   to be at least 24 bytes to support the SDO Information service */
;;;1171   				nSdoInfoFragmentsLeft = 0;
;;;1172   				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
;;;1173   				{
;;;1174   					UINT16 n = OBJ_GetNoOfObjects(i);
;;;1175   
;;;1176   					/* copy the number of objects of the list type in the SDO Information response */
;;;1177   					((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT >> 1) + i] = SWAPWORD(n);
;;;1178   				}
;;;1179   
;;;1180   				/* size of the mailbox service response */
;;;1181   				size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
;;;1182   			}
;;;1183   			else
;;;1184   			{
;;;1185   				/* object list with indexes is requested */
;;;1186   				UINT16 MBXMEM * pData;
;;;1187   				UINT16 n = 0;
;;;1188   
;;;1189   				if (nSdoInfoFragmentsLeft)
;;;1190   				{
;;;1191   					/* the next fragment of the SDO Information response shall be sent */
;;;1192   					/* initialize size with the maximum size fits into one mailbox service */
;;;1193   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1436 to 1443 deleted*/
;;;1194   					{
;;;1195   						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
;;;1196   					}
;;;1197   					/* initialize pData with the pointer where the fragment has to be copied */
;;;1198   					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO >> 1];
;;;1199   					/* initialize index with the next index to be sent */
;;;1200   					index = nSdoInfoIndex;
;;;1201   					/* decrement the number of fragments to be sent */
;;;1202   					nSdoInfoFragmentsLeft--;
;;;1203   				}
;;;1204   				else
;;;1205   				{
;;;1206   					/* the first fragment of the SDO Information response has to be sent */
;;;1207   					/* get the number of objects of the requested object list */
;;;1208   					n = OBJ_GetNoOfObjects(listType);
;;;1209   					/* we start with index 0x1000 */
;;;1210   					index = 0x1000;
;;;1211   					/* initialize size with the maximum size fits into one mailbox service */
;;;1212   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1463 to 1470 deleted*/
;;;1213   					{
;;;1214   						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
;;;1215   					}
;;;1216   					/* initialize pData with the pointer where the fragment has to be copied */
;;;1217   					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT >> 1];
;;;1218   					/*Check if List need to be send in fragments*/
;;;1219   					if ((n << 1) > size)
;;;1220   					{
;;;1221   						/*number of Bytes to transmit don't fit into one mailbox datagram*/
;;;1222   
;;;1223   						/*calculate number of fragments which need to be send
;;;1224   						total number of bytes - bytes which will be transmitted with the current response plus the fragment size - 1 (to round up) divided by the size of the following fragments
;;;1225   						*/
;;;1226   						UINT16 Fragsize = size + 2;
;;;1227   
;;;1228   						nSdoInfoFragmentsLeft = (((n << 1) - size + (Fragsize - 1)) / Fragsize);
;;;1229   					}
;;;1230   					else
;;;1231   					{
;;;1232   						nSdoInfoFragmentsLeft = 0;
;;;1233   					}
;;;1234   /*ET9300 Project Handler :(#if SEGMENTED_SDO_SUPPORTED #else) lines 1493 to 1497 deleted*/
;;;1235   				}
;;;1236   
;;;1237   				/* get the next part of the requested object list */
;;;1238   				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
;;;1239   
;;;1240   				/* store index for next fragment */
;;;1241   				nSdoInfoIndex = index;
;;;1242   				/* size contains before the instruction the size still available in the mailbox buffer
;;;1243   					and shall contain the size of the mailbox response data after the next instruction */
;;;1244   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1507 to 1514 deleted*/
;;;1245   				{
;;;1246   					size = u16SendMbxSize - size - MBX_HEADER_SIZE;
;;;1247   				}
;;;1248   			}
;;;1249   
;;;1250   			/* size of the mailbox response data */
;;;1251   			pSdoInfoInd->MbxHeader.Length = size;
;;;1252   
;;;1253   			if (abort == 0)
;;;1254   			{
;;;1255   				pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
;;;1256   				pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_OBJDICTIONARYLIST_S << INFOHEAD_OPCODE_SHIFT);
;;;1257   /*ET9300 Project Handler :(#if !SEGMENTED_SDO_SUPPORTED) lines 1527 to 1529 deleted*/
;;;1258   				/* number of fragments still has to be sent */
;;;1259   				pSdoInfoInd->SdoHeader.FragmentsLeft = SWAPWORD(nSdoInfoFragmentsLeft);
;;;1260   
;;;1261   				if (nSdoInfoFragmentsLeft)
;;;1262   				{
;;;1263   					/* there still are fragments to be sent,
;;;1264   					   the InComplete flag in the SDO Information response has to be sent */
;;;1265   					pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEADER_INCOMPLETE_MASK;
;;;1266   					pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_INCOMPLETE << INFOHEAD_OPCODE_SHIFT);
;;;1267   					/* the FRAGMENTS_FOLLOW flag has to be set for the function MBX_MailboxSendReq to
;;;1268   					   indicate the mailbox handler that still fragments has to be sent so that this
;;;1269   						function shall be called again from COE_ContinueInd when the actual mailbox buffer
;;;1270   						was sent */
;;;1271   					flags = FRAGMENTS_FOLLOW | COE_SERVICE;
;;;1272   				}
;;;1273   			}
;;;1274   		}
;;;1275   		break;
;;;1276   
;;;1277   	case SDOINFOSERVICE_OBJDESCRIPTION_Q:
;;;1278   	case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
;;;1279   		/* get the requested index */
;;;1280   		index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
;;;1281   
;;;1282   /*ET9300 Project Handler :(#if TEST_APPLICATION && EOE_SUPPORTED) lines 1555 to 1623 deleted*/
;;;1283   
;;;1284   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1625 to 1642 deleted*/
;;;1285   
;;;1286   		if (index < 0x1000)
;;;1287   		{
;;;1288   			/*SDO Info access is only allowed for objects >= 0x1000*/
;;;1289   			abort = ABORTIDX_UNSUPPORTED_ACCESS;
;;;1290   		}
;;;1291   		else
;;;1292   		{
;;;1293   			/* get the object handle of the requested index */
;;;1294   			pObjEntry = OBJ_GetObjectHandle(index);
;;;1295   
;;;1296   			if (pObjEntry)
;;;1297   			{
;;;1298   				/* object exists */
;;;1299   				UINT16 size = 0;
;;;1300   
;;;1301   				if (opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q)
;;;1302   				{
;;;1303   					/* object description is requested */
;;;1304   /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 1662 to 1666 deleted*/
;;;1305   					OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry), SDO_INFO_OBJ_DESC_SIZE);
;;;1306   
;;;1307   
;;;1308   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1671 to 1683 deleted*/
;;;1309   					/* the mailbox should be big enough that the maximum object description
;;;1310   					fits in the mailbox (the fragmentation is not done in the sample code),
;;;1311   					so it will be checked only if the object description fits */
;;;1312   					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
;;;1313   
;;;1314   					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
;;;1315   					{
;;;1316   						/* size of the object description does not fit in the mailbox,
;;;1317   						the object description will be sent without the name */
;;;1318   						size = SIZEOF_SDOINFOOBJSTRUCT;
;;;1319   					}
;;;1320   					else
;;;1321   					{
;;;1322   						/* object description fits in the mailbox, get the name of the object */
;;;1323   						size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Obj.Res)[1])) + SIZEOF_SDOINFOOBJSTRUCT;
;;;1324   					}
;;;1325   				}
;;;1326   				else
;;;1327   				{
;;;1328   					/* entry description is requested,
;;;1329   					get the requested subindex */
;;;1330   					UINT8 subindex = (UINT8)((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_SUBINDEX) >> ENTRY_SUBINDEX_SHIFT);
;;;1331   
;;;1332   					/* get the maximum subindex */
;;;1333   					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
;;;1334   
;;;1335   					if (subindex <= maxSubindex)
;;;1336   					{
;;;1337   						UINT16 ObjectFlags;
;;;1338   						/* requested subindex is not too great */
;;;1339   						/* get the entry description of the requested entry */
;;;1340   /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 1715 to 1720 deleted*/
;;;1341   						OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pObjEntry, subindex), SIZEOF(TSDOINFOENTRYDESC));
;;;1342   
;;;1343   						/* the transmission of the value info is not supported yet of the sample code */
;;;1344   						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
;;;1345   						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
;;;1346   						ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
;;;1347   
;;;1348   						if (((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subindex == 0))
;;;1349   						{
;;;1350   							OBJTOMBXSTRCPY(((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1]), aSubindexDesc, SIZEOF(aSubindexDesc));
;;;1351   							size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "SubIndex 000"
;;;1352   						}
;;;1353   						else
;;;1354   						{
;;;1355   							/* the mailbox should be big enough that the maximum entry description
;;;1356   							fits in the mailbox (the fragmentation is not done in the sample code),
;;;1357   							so it will be checked only if the entry description fits */
;;;1358   							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
;;;1359   							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
;;;1360   							{
;;;1361   								/* size of the object description does not fit in the mailbox,
;;;1362   								the object description will be sent without the name */
;;;1363   								size = SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
;;;1364   							}
;;;1365   							else
;;;1366   							{
;;;1367   								/* object description fits in the mailbox, get the name of the entry */
;;;1368   								size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1])) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
;;;1369   							}
;;;1370   						}
;;;1371   					}
;;;1372   					else
;;;1373   					{
;;;1374   						abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
;;;1375   					}
;;;1376   				}
;;;1377   
;;;1378   				if (abort == 0)
;;;1379   				{
;;;1380   					{
;;;1381   						/* for the object and entry description the sample code does not support the fragmentation,
;;;1382   						the mailbox has to be big enough */
;;;1383   						pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
;;;1384   						/* store the size of the mailbox data in the mailbox buffer */
;;;1385   						pSdoInfoInd->MbxHeader.Length = size;
;;;1386   						/* set the opCode of the SDO Information response */
;;;1387   						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
;;;1388   						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
;;;1389   					}
;;;1390   				}
;;;1391   			}
;;;1392   			else
;;;1393   			{
;;;1394   				abort = ABORTIDX_OBJECT_NOT_EXISTING;
;;;1395   			}
;;;1396   		}
;;;1397   		break;
;;;1398   	default:
;;;1399   		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
;;;1400   	}
;;;1401   
;;;1402   	if (abort)
;;;1403   	{
;;;1404   		/* send a SDO Information Error response */
;;;1405   		pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
;;;1406   
;;;1407   		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
;;;1408   		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);
;;;1409   
;;;1410   		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
;;;1411   /*ET9300 Project Handler :(#if BIG_ENDIAN_16BIT) lines 1792 to 1795 deleted*/
;;;1412   		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
;;;1413   
;;;1414   		nSdoInfoFragmentsLeft = 0;
;;;1415   	}
;;;1416   
;;;1417   	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
;;;1418   	{
;;;1419   		/* if the mailbox response could not be sent (or stored), the response will be
;;;1420   		   stored in the variable pCoeSendStored and will be sent automatically
;;;1421   			from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
;;;1422   			the next time from the master */
;;;1423   		pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
;;;1424   	}
;;;1425   
;;;1426   	return 0;
;;;1427   }
000020  e8bd8ffe          POP      {r1-r11,pc}
                  |L3.36|
000024  8820              LDRH     r0,[r4,#0]            ;1143
000026  2808              CMP      r0,#8                 ;1143
000028  da01              BGE      |L3.46|
00002a  2006              MOVS     r0,#6                 ;1145
00002c  e7f8              B        |L3.32|
                  |L3.46|
00002e  2e01              CMP      r6,#1                 ;1149
000030  d004              BEQ      |L3.60|
000032  2e03              CMP      r6,#3                 ;1149
000034  d07e              BEQ      |L3.308|
000036  2e05              CMP      r6,#5                 ;1149
000038  d17d              BNE      |L3.310|
00003a  e08d              B        |L3.344|
                  |L3.60|
00003c  89a0              LDRH     r0,[r4,#0xc]          ;1153
00003e  2805              CMP      r0,#5                 ;1153
000040  dc7a              BGT      |L3.312|
000042  2500              MOVS     r5,#0                 ;1155
000044  f894a00c          LDRB     r10,[r4,#0xc]         ;1157
000048  220e              MOVS     r2,#0xe               ;1163
00004a  4621              MOV      r1,r4                 ;1163
00004c  489e              LDR      r0,|L3.712|
00004e  f7fffffe          BL       __aeabi_memcpy4
000052  f1ba0000          SUBS     r0,r10,#0             ;1164
000056  f1aa0101          SUB      r1,r10,#1             ;1164
00005a  f0010aff          AND      r10,r1,#0xff          ;1164
00005e  d114              BNE      |L3.138|
000060  499a              LDR      r1,|L3.716|
000062  8008              STRH     r0,[r1,#0]            ;1171
000064  4680              MOV      r8,r0                 ;1172
000066  e00b              B        |L3.128|
                  |L3.104|
000068  4640              MOV      r0,r8                 ;1174
00006a  f7fffffe          BL       OBJ_GetNoOfObjects
00006e  4683              MOV      r11,r0                ;1174
000070  f1080004          ADD      r0,r8,#4              ;1177
000074  1da1              ADDS     r1,r4,#6              ;1177
000076  f821b010          STRH     r11,[r1,r0,LSL #1]    ;1177
00007a  1ec0              SUBS     r0,r0,#3              ;1172
00007c  f00008ff          AND      r8,r0,#0xff           ;1172
                  |L3.128|
000080  f1b80f05          CMP      r8,#5                 ;1172
000084  dbf0              BLT      |L3.104|
000086  2512              MOVS     r5,#0x12              ;1181
000088  e044              B        |L3.276|
                  |L3.138|
00008a  f04f0b00          MOV      r11,#0                ;1187
00008e  488f              LDR      r0,|L3.716|
000090  8800              LDRH     r0,[r0,#0]            ;1189  ; nSdoInfoFragmentsLeft
000092  b170              CBZ      r0,|L3.178|
000094  488e              LDR      r0,|L3.720|
000096  8800              LDRH     r0,[r0,#0]            ;1195  ; u16SendMbxSize
000098  380c              SUBS     r0,r0,#0xc            ;1195
00009a  b285              UXTH     r5,r0                 ;1195
00009c  f104080c          ADD      r8,r4,#0xc            ;1198
0000a0  488c              LDR      r0,|L3.724|
0000a2  8800              LDRH     r0,[r0,#0]            ;1200  ; nSdoInfoIndex
0000a4  9001              STR      r0,[sp,#4]            ;1200
0000a6  4889              LDR      r0,|L3.716|
0000a8  8800              LDRH     r0,[r0,#0]            ;1202  ; nSdoInfoFragmentsLeft
0000aa  1e40              SUBS     r0,r0,#1              ;1202
0000ac  4987              LDR      r1,|L3.716|
0000ae  8008              STRH     r0,[r1,#0]            ;1202
0000b0  e01d              B        |L3.238|
                  |L3.178|
0000b2  4650              MOV      r0,r10                ;1208
0000b4  f7fffffe          BL       OBJ_GetNoOfObjects
0000b8  4683              MOV      r11,r0                ;1208
0000ba  f44f5080          MOV      r0,#0x1000            ;1210
0000be  9001              STR      r0,[sp,#4]            ;1210
0000c0  4883              LDR      r0,|L3.720|
0000c2  8800              LDRH     r0,[r0,#0]            ;1214  ; u16SendMbxSize
0000c4  380e              SUBS     r0,r0,#0xe            ;1214
0000c6  b285              UXTH     r5,r0                 ;1214
0000c8  f104080e          ADD      r8,r4,#0xe            ;1217
0000cc  ebb50f4b          CMP      r5,r11,LSL #1         ;1219
0000d0  da0a              BGE      |L3.232|
0000d2  1ca9              ADDS     r1,r5,#2              ;1226
0000d4  b288              UXTH     r0,r1                 ;1226
0000d6  ebc5024b          RSB      r2,r5,r11,LSL #1      ;1228
0000da  1e41              SUBS     r1,r0,#1              ;1228
0000dc  4411              ADD      r1,r1,r2              ;1228
0000de  fb91f1f0          SDIV     r1,r1,r0              ;1228
0000e2  4a7a              LDR      r2,|L3.716|
0000e4  8011              STRH     r1,[r2,#0]            ;1228
0000e6  e002              B        |L3.238|
                  |L3.232|
0000e8  2000              MOVS     r0,#0                 ;1232
0000ea  4978              LDR      r1,|L3.716|
0000ec  8008              STRH     r0,[r1,#0]            ;1232
                  |L3.238|
0000ee  a802              ADD      r0,sp,#8              ;1238
0000f0  4643              MOV      r3,r8                 ;1238
0000f2  462a              MOV      r2,r5                 ;1238
0000f4  a901              ADD      r1,sp,#4              ;1238
0000f6  9000              STR      r0,[sp,#0]            ;1238
0000f8  4650              MOV      r0,r10                ;1238
0000fa  f7fffffe          BL       OBJ_GetObjectList
0000fe  4605              MOV      r5,r0                 ;1238
000100  f8bd0004          LDRH     r0,[sp,#4]            ;1241
000104  4973              LDR      r1,|L3.724|
000106  8008              STRH     r0,[r1,#0]            ;1241
000108  4871              LDR      r0,|L3.720|
00010a  8800              LDRH     r0,[r0,#0]            ;1246  ; u16SendMbxSize
00010c  1b40              SUBS     r0,r0,r5              ;1246
00010e  1f80              SUBS     r0,r0,#6              ;1246
000110  b285              UXTH     r5,r0                 ;1246
000112  bf00              NOP                            ;1248
                  |L3.276|
000114  8025              STRH     r5,[r4,#0]            ;1251
000116  f89d0008          LDRB     r0,[sp,#8]            ;1253
00011a  b9d0              CBNZ     r0,|L3.338|
00011c  8920              LDRH     r0,[r4,#8]            ;1255
00011e  f020007f          BIC      r0,r0,#0x7f           ;1255
000122  8120              STRH     r0,[r4,#8]            ;1255
000124  8920              LDRH     r0,[r4,#8]            ;1256
000126  f0400002          ORR      r0,r0,#2              ;1256
00012a  8120              STRH     r0,[r4,#8]            ;1256
00012c  4867              LDR      r0,|L3.716|
00012e  8801              LDRH     r1,[r0,#0]            ;1259  ; nSdoInfoFragmentsLeft
000130  8161              STRH     r1,[r4,#0xa]          ;1259
000132  e002              B        |L3.314|
                  |L3.308|
000134  e00f              B        |L3.342|
                  |L3.310|
000136  e0a2              B        |L3.638|
                  |L3.312|
000138  e00c              B        |L3.340|
                  |L3.314|
00013a  8800              LDRH     r0,[r0,#0]            ;1261  ; nSdoInfoFragmentsLeft
00013c  b148              CBZ      r0,|L3.338|
00013e  8920              LDRH     r0,[r4,#8]            ;1265
000140  f0200080          BIC      r0,r0,#0x80           ;1265
000144  8120              STRH     r0,[r4,#8]            ;1265
000146  8920              LDRH     r0,[r4,#8]            ;1266
000148  f0400080          ORR      r0,r0,#0x80           ;1266
00014c  8120              STRH     r0,[r4,#8]            ;1266
00014e  f04f0982          MOV      r9,#0x82              ;1271
                  |L3.338|
000152  bf00              NOP                            ;1274
                  |L3.340|
000154  e096              B        |L3.644|
                  |L3.342|
000156  bf00              NOP                            ;1278
                  |L3.344|
000158  89a0              LDRH     r0,[r4,#0xc]          ;1280
00015a  9001              STR      r0,[sp,#4]            ;1280
00015c  f8bd0004          LDRH     r0,[sp,#4]            ;1286
000160  f5b05f80          CMP      r0,#0x1000            ;1286
000164  da02              BGE      |L3.364|
000166  2005              MOVS     r0,#5                 ;1289
000168  9002              STR      r0,[sp,#8]            ;1289
00016a  e087              B        |L3.636|
                  |L3.364|
00016c  f8bd0004          LDRH     r0,[sp,#4]            ;1294
000170  f7fffffe          BL       OBJ_GetObjectHandle
000174  4607              MOV      r7,r0                 ;1294
000176  2f00              CMP      r7,#0                 ;1296
000178  d07e              BEQ      |L3.632|
00017a  2500              MOVS     r5,#0                 ;1299
00017c  2e03              CMP      r6,#3                 ;1301
00017e  d121              BNE      |L3.452|
000180  4638              MOV      r0,r7                 ;1305
000182  f7fffffe          BL       OBJ_GetObjDesc
000186  4601              MOV      r1,r0                 ;1305
000188  6809              LDR      r1,[r1,#0]            ;1305
00018a  f8c4100e          STR      r1,[r4,#0xe]          ;1305
00018e  2300              MOVS     r3,#0                 ;1312
000190  463a              MOV      r2,r7                 ;1312
000192  4619              MOV      r1,r3                 ;1312
000194  f8bd0004          LDRH     r0,[sp,#4]            ;1312
000198  f7fffffe          BL       OBJ_GetDesc
00019c  300c              ADDS     r0,r0,#0xc            ;1312
00019e  b285              UXTH     r5,r0                 ;1312
0001a0  484b              LDR      r0,|L3.720|
0001a2  8800              LDRH     r0,[r0,#0]            ;1314  ; u16SendMbxSize
0001a4  1f80              SUBS     r0,r0,#6              ;1314
0001a6  42a8              CMP      r0,r5                 ;1314
0001a8  da01              BGE      |L3.430|
0001aa  250c              MOVS     r5,#0xc               ;1318
0001ac  e054              B        |L3.600|
                  |L3.430|
0001ae  f1040312          ADD      r3,r4,#0x12           ;1323
0001b2  463a              MOV      r2,r7                 ;1323
0001b4  2100              MOVS     r1,#0                 ;1323
0001b6  f8bd0004          LDRH     r0,[sp,#4]            ;1323
0001ba  f7fffffe          BL       OBJ_GetDesc
0001be  300c              ADDS     r0,r0,#0xc            ;1323
0001c0  b285              UXTH     r5,r0                 ;1323
0001c2  e049              B        |L3.600|
                  |L3.452|
0001c4  f894800e          LDRB     r8,[r4,#0xe]          ;1330
0001c8  4638              MOV      r0,r7                 ;1333
0001ca  f7fffffe          BL       OBJ_GetObjDesc
0001ce  f890b002          LDRB     r11,[r0,#2]           ;1333
0001d2  45d8              CMP      r8,r11                ;1335
0001d4  dc3d              BGT      |L3.594|
0001d6  4641              MOV      r1,r8                 ;1341
0001d8  4638              MOV      r0,r7                 ;1341
0001da  f7fffffe          BL       OBJ_GetEntryDesc
0001de  4601              MOV      r1,r0                 ;1341
0001e0  680a              LDR      r2,[r1,#0]            ;1341
0001e2  6122              STR      r2,[r4,#0x10]         ;1341
0001e4  8889              LDRH     r1,[r1,#4]            ;1341
0001e6  82a1              STRH     r1,[r4,#0x14]         ;1341
0001e8  7ba1              LDRB     r1,[r4,#0xe]          ;1344
0001ea  81e1              STRH     r1,[r4,#0xe]          ;1344
0001ec  4638              MOV      r0,r7                 ;1345
0001ee  f7fffffe          BL       OBJ_GetObjDesc
0001f2  f8b0a002          LDRH     r10,[r0,#2]           ;1345
0001f6  f3ca2a03          UBFX     r10,r10,#8,#4         ;1346
0001fa  f1ba0f08          CMP      r10,#8                ;1348
0001fe  d002              BEQ      |L3.518|
000200  f1ba0f09          CMP      r10,#9                ;1348
000204  d10a              BNE      |L3.540|
                  |L3.518|
000206  f1b80f00          CMP      r8,#0                 ;1348
00020a  d107              BNE      |L3.540|
00020c  220d              MOVS     r2,#0xd               ;1350
00020e  4932              LDR      r1,|L3.728|
000210  f1040016          ADD      r0,r4,#0x16           ;1350
000214  f7fffffe          BL       __aeabi_memcpy
000218  251c              MOVS     r5,#0x1c              ;1351
00021a  e019              B        |L3.592|
                  |L3.540|
00021c  2300              MOVS     r3,#0                 ;1358
00021e  463a              MOV      r2,r7                 ;1358
000220  4641              MOV      r1,r8                 ;1358
000222  f8bd0004          LDRH     r0,[sp,#4]            ;1358
000226  f7fffffe          BL       OBJ_GetDesc
00022a  3010              ADDS     r0,r0,#0x10           ;1358
00022c  b285              UXTH     r5,r0                 ;1358
00022e  4828              LDR      r0,|L3.720|
000230  8800              LDRH     r0,[r0,#0]            ;1359  ; u16SendMbxSize
000232  1f80              SUBS     r0,r0,#6              ;1359
000234  42a8              CMP      r0,r5                 ;1359
000236  da01              BGE      |L3.572|
000238  2510              MOVS     r5,#0x10              ;1363
00023a  e009              B        |L3.592|
                  |L3.572|
00023c  f1040316          ADD      r3,r4,#0x16           ;1368
000240  463a              MOV      r2,r7                 ;1368
000242  4641              MOV      r1,r8                 ;1368
000244  f8bd0004          LDRH     r0,[sp,#4]            ;1368
000248  f7fffffe          BL       OBJ_GetDesc
00024c  3010              ADDS     r0,r0,#0x10           ;1368
00024e  b285              UXTH     r5,r0                 ;1368
                  |L3.592|
000250  e001              B        |L3.598|
                  |L3.594|
000252  2011              MOVS     r0,#0x11              ;1374
000254  9002              STR      r0,[sp,#8]            ;1374
                  |L3.598|
000256  bf00              NOP                            ;1376
                  |L3.600|
000258  f89d0008          LDRB     r0,[sp,#8]            ;1378
00025c  b950              CBNZ     r0,|L3.628|
00025e  2100              MOVS     r1,#0                 ;1383
000260  8161              STRH     r1,[r4,#0xa]          ;1383
000262  8025              STRH     r5,[r4,#0]            ;1385
000264  8920              LDRH     r0,[r4,#8]            ;1387
000266  f020007f          BIC      r0,r0,#0x7f           ;1387
00026a  8120              STRH     r0,[r4,#8]            ;1387
00026c  8920              LDRH     r0,[r4,#8]            ;1388
00026e  1c71              ADDS     r1,r6,#1              ;1388
000270  4308              ORRS     r0,r0,r1              ;1388
000272  8120              STRH     r0,[r4,#8]            ;1388
                  |L3.628|
000274  e002              B        |L3.636|
000276  e7ff              B        |L3.632|
                  |L3.632|
000278  2008              MOVS     r0,#8                 ;1394
00027a  9002              STR      r0,[sp,#8]            ;1394
                  |L3.636|
00027c  e002              B        |L3.644|
                  |L3.638|
00027e  2003              MOVS     r0,#3                 ;1399
000280  9002              STR      r0,[sp,#8]            ;1399
000282  bf00              NOP                            ;1149
                  |L3.644|
000284  bf00              NOP                            ;1275
000286  f89d0008          LDRB     r0,[sp,#8]            ;1402
00028a  b1a0              CBZ      r0,|L3.694|
00028c  200a              MOVS     r0,#0xa               ;1405
00028e  8020              STRH     r0,[r4,#0]            ;1405
000290  8920              LDRH     r0,[r4,#8]            ;1407
000292  f020007f          BIC      r0,r0,#0x7f           ;1407
000296  8120              STRH     r0,[r4,#8]            ;1407
000298  8920              LDRH     r0,[r4,#8]            ;1408
00029a  f0400007          ORR      r0,r0,#7              ;1408
00029e  8120              STRH     r0,[r4,#8]            ;1408
0002a0  2100              MOVS     r1,#0                 ;1410
0002a2  8161              STRH     r1,[r4,#0xa]          ;1410
0002a4  480d              LDR      r0,|L3.732|
0002a6  f89d1008          LDRB     r1,[sp,#8]            ;1412
0002aa  f8501021          LDR      r1,[r0,r1,LSL #2]     ;1412
0002ae  60e1              STR      r1,[r4,#0xc]          ;1412
0002b0  2000              MOVS     r0,#0                 ;1414
0002b2  4906              LDR      r1,|L3.716|
0002b4  8008              STRH     r0,[r1,#0]            ;1414
                  |L3.694|
0002b6  4649              MOV      r1,r9                 ;1417
0002b8  4620              MOV      r0,r4                 ;1417
0002ba  f7fffffe          BL       MBX_MailboxSendReq
0002be  b108              CBZ      r0,|L3.708|
0002c0  4807              LDR      r0,|L3.736|
0002c2  6004              STR      r4,[r0,#0]            ;1423  ; pCoeSendStored
                  |L3.708|
0002c4  2000              MOVS     r0,#0                 ;1426
0002c6  e6ab              B        |L3.32|
;;;1428   
                          ENDP

                  |L3.712|
                          DCD      aSdoInfoHeader
                  |L3.716|
                          DCD      nSdoInfoFragmentsLeft
                  |L3.720|
                          DCD      u16SendMbxSize
                  |L3.724|
                          DCD      nSdoInfoIndex
                  |L3.728|
                          DCD      aSubindexDesc
                  |L3.732|
                          DCD      cAbortCode
                  |L3.736|
                          DCD      pCoeSendStored

                          AREA ||i.SDOS_SdoRes||, CODE, READONLY, ALIGN=2

                  SDOS_SdoRes PROC
;;;1023   
;;;1024   void SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1025   {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1026   	UINT16 dataSize = 0;
00000a  2600              MOVS     r6,#0
;;;1027   
;;;1028   	if (bSdoInWork)
00000c  482d              LDR      r0,|L4.196|
00000e  7800              LDRB     r0,[r0,#0]  ; bSdoInWork
000010  2800              CMP      r0,#0
000012  d054              BEQ      |L4.190|
;;;1029   	{
;;;1030   		/* SDO-Response is expected */
;;;1031   		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
000014  482c              LDR      r0,|L4.200|
000016  6800              LDR      r0,[r0,#0]  ; pSdoResStored
000018  7a00              LDRB     r0,[r0,#8]
00001a  f00007e0          AND      r7,r0,#0xe0
;;;1032   		UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMPLETEACCESS;
00001e  482a              LDR      r0,|L4.200|
000020  6800              LDR      r0,[r0,#0]  ; pSdoResStored
000022  7a00              LDRB     r0,[r0,#8]
000024  f0000810          AND      r8,r0,#0x10
;;;1033   
;;;1034   		if (command == SDOSERVICE_INITIATEUPLOADREQ)
000028  2f40              CMP      r7,#0x40
00002a  d13a              BNE      |L4.162|
;;;1035   		{
;;;1036   			/* dataSize contains the available size in one mailbox */
;;;1037   			dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
00002c  4827              LDR      r0,|L4.204|
00002e  8800              LDRH     r0,[r0,#0]  ; u16SendMbxSize
000030  3810              SUBS     r0,r0,#0x10
000032  b286              UXTH     r6,r0
;;;1038   			if (dataSize < objLength)
000034  42a6              CMP      r6,r4
000036  d218              BCS      |L4.106|
;;;1039   			{
;;;1040   				/* Segmented Upload, the variables for the segmented transfer should be initialized */
;;;1041   				bSdoSegFollows = TRUE;
000038  2001              MOVS     r0,#1
00003a  4925              LDR      r1,|L4.208|
00003c  7008              STRB     r0,[r1,#0]
;;;1042   				bSdoSegLastToggle = 1;
00003e  4925              LDR      r1,|L4.212|
000040  7008              STRB     r0,[r1,#0]
;;;1043   				bSdoSegAccess = completeAccess;
000042  4825              LDR      r0,|L4.216|
000044  f8808000          STRB     r8,[r0,#0]
;;;1044   				nSdoSegCompleteSize = objLength;
000048  4824              LDR      r0,|L4.220|
00004a  6004              STR      r4,[r0,#0]  ; nSdoSegCompleteSize
;;;1045   				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
00004c  2060              MOVS     r0,#0x60
00004e  4924              LDR      r1,|L4.224|
000050  7008              STRB     r0,[r1,#0]
;;;1046   				pSdoSegData = (UINT16 VARMEM *) pData;
000052  4824              LDR      r0,|L4.228|
000054  6005              STR      r5,[r0,#0]  ; pSdoSegData
;;;1047   				/* the first segment shall be copied */
;;;1048   				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
000056  4632              MOV      r2,r6
000058  4629              MOV      r1,r5
00005a  481b              LDR      r0,|L4.200|
00005c  6800              LDR      r0,[r0,#0]  ; pSdoResStored
00005e  3010              ADDS     r0,r0,#0x10
000060  f7fffffe          BL       __aeabi_memcpy
;;;1049   				nSdoSegBytesToHandle = dataSize;
000064  4820              LDR      r0,|L4.232|
000066  6006              STR      r6,[r0,#0]  ; nSdoSegBytesToHandle
000068  e01b              B        |L4.162|
                  |L4.106|
;;;1050   			}
;;;1051   			else
;;;1052   				if ((objLength <= 4) && (objLength > 0))
00006a  2c04              CMP      r4,#4
00006c  d80d              BHI      |L4.138|
00006e  b164              CBZ      r4,|L4.138|
;;;1053   				{
;;;1054   					/* Expedited response */
;;;1055   					if (pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data)
000070  4815              LDR      r0,|L4.200|
000072  6800              LDR      r0,[r0,#0]  ; pSdoResStored
000074  300c              ADDS     r0,r0,#0xc
000076  4285              CMP      r5,r0
000078  d013              BEQ      |L4.162|
;;;1056   					{
;;;1057   						/* the data is not in the response buffer yet, it shall be copied */
;;;1058   						MBXMEMCPY((UINT16 *)((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
00007a  4622              MOV      r2,r4
00007c  4629              MOV      r1,r5
00007e  4812              LDR      r0,|L4.200|
000080  6800              LDR      r0,[r0,#0]  ; pSdoResStored
000082  300c              ADDS     r0,r0,#0xc
000084  f7fffffe          BL       __aeabi_memcpy
000088  e00b              B        |L4.162|
                  |L4.138|
;;;1059   					}
;;;1060   				}
;;;1061   				else
;;;1062   				{
;;;1063   					/* Normal response */
;;;1064   					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
00008a  480f              LDR      r0,|L4.200|
00008c  6800              LDR      r0,[r0,#0]  ; pSdoResStored
00008e  3010              ADDS     r0,r0,#0x10
000090  4285              CMP      r5,r0
000092  d006              BEQ      |L4.162|
;;;1065   					{
;;;1066   						/* the data is not in the response buffer yet, it shall be copied */
;;;1067   						MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
000094  4622              MOV      r2,r4
000096  4629              MOV      r1,r5
000098  480b              LDR      r0,|L4.200|
00009a  6800              LDR      r0,[r0,#0]  ; pSdoResStored
00009c  3010              ADDS     r0,r0,#0x10
00009e  f7fffffe          BL       __aeabi_memcpy
                  |L4.162|
;;;1068   					}
;;;1069   				}
;;;1070   		}
;;;1071   
;;;1072   		/* SDO access is finished, send the response */
;;;1073   		bSdoInWork = FALSE;
0000a2  2000              MOVS     r0,#0
0000a4  4907              LDR      r1,|L4.196|
0000a6  7008              STRB     r0,[r1,#0]
;;;1074   		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
0000a8  4807              LDR      r0,|L4.200|
0000aa  6800              LDR      r0,[r0,#0]  ; pSdoResStored
0000ac  4633              MOV      r3,r6
0000ae  4642              MOV      r2,r8
0000b0  4639              MOV      r1,r7
0000b2  e9cd4000          STRD     r4,r0,[sp,#0]
0000b6  4648              MOV      r0,r9
0000b8  f7fffffe          BL       SdoRes
;;;1075   	}
0000bc  bf00              NOP      
                  |L4.190|
;;;1076   }
0000be  e8bd87fc          POP      {r2-r10,pc}
;;;1077   
                          ENDP

0000c2  0000              DCW      0x0000
                  |L4.196|
                          DCD      bSdoInWork
                  |L4.200|
                          DCD      pSdoResStored
                  |L4.204|
                          DCD      u16SendMbxSize
                  |L4.208|
                          DCD      bSdoSegFollows
                  |L4.212|
                          DCD      bSdoSegLastToggle
                  |L4.216|
                          DCD      bSdoSegAccess
                  |L4.220|
                          DCD      nSdoSegCompleteSize
                  |L4.224|
                          DCD      nSdoSegService
                  |L4.228|
                          DCD      pSdoSegData
                  |L4.232|
                          DCD      nSdoSegBytesToHandle

                          AREA ||i.SdoDownloadSegmentInd||, CODE, READONLY, ALIGN=2

                  SdoDownloadSegmentInd PROC
;;;213    
;;;214    static UINT8 SdoDownloadSegmentInd(TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;215    {
000004  4604              MOV      r4,r0
;;;216    	UINT8 abort = 0;
000006  2700              MOVS     r7,#0
;;;217    	UINT32 bytesToSave = 0;
000008  2500              MOVS     r5,#0
;;;218    
;;;219    	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
00000a  7a20              LDRB     r0,[r4,#8]
00000c  f0000010          AND      r0,r0,#0x10
000010  4990              LDR      r1,|L5.596|
000012  7809              LDRB     r1,[r1,#0]  ; bSdoSegLastToggle
000014  4288              CMP      r0,r1
000016  d101              BNE      |L5.28|
;;;220    	{
;;;221    		/* toggle bit has not toggled... */
;;;222    		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
000018  2701              MOVS     r7,#1
00001a  e0e4              B        |L5.486|
                  |L5.28|
;;;223    	}
;;;224    	else
;;;225    	{
;;;226    		/* maxData contains the maximum data to be received with a SDO-DownloadSegment */
;;;227    		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
00001c  488e              LDR      r0,|L5.600|
00001e  8800              LDRH     r0,[r0,#0]  ; u16ReceiveMbxSize
000020  3809              SUBS     r0,r0,#9
000022  fa1ff880          UXTH     r8,r0
;;;228    		/* the new toggle bit is stored in bSdoSegLastToggle */
;;;229    		bSdoSegLastToggle = SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE);
000026  7a20              LDRB     r0,[r4,#8]
000028  f0000010          AND      r0,r0,#0x10
00002c  4989              LDR      r1,|L5.596|
00002e  7008              STRB     r0,[r1,#0]
;;;230    
;;;231    		/* a SDO-Download Segment is only allowed if a SDO-Download Request was received before,
;;;232    		   in that case a buffer for the received data was allocated in SDOS_SdoInd before */
;;;233    		if (pSdoSegData)
000030  488a              LDR      r0,|L5.604|
000032  6800              LDR      r0,[r0,#0]  ; pSdoSegData
000034  2800              CMP      r0,#0
000036  d06f              BEQ      |L5.280|
;;;234    		{
;;;235    			/* bytesToSave contains the remaining data with this and maybe the following
;;;236    			   SDO-Download Segment services */
;;;237    			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
000038  4889              LDR      r0,|L5.608|
00003a  6800              LDR      r0,[r0,#0]  ; nSdoSegCompleteSize
00003c  4989              LDR      r1,|L5.612|
00003e  6809              LDR      r1,[r1,#0]  ; nSdoSegBytesToHandle
000040  1a45              SUBS     r5,r0,r1
;;;238    
;;;239    			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
000042  7a20              LDRB     r0,[r4,#8]
000044  f0000001          AND      r0,r0,#1
000048  b1c8              CBZ      r0,|L5.126|
;;;240    			{
;;;241    				/* the last segment is received, check if the length of the remaining data is the
;;;242    				   same as the length of the received data */
;;;243    				if (bytesToSave <= maxData)
00004a  4545              CMP      r5,r8
00004c  d815              BHI      |L5.122|
;;;244    				{
;;;245    					UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
00004e  8820              LDRH     r0,[r4,#0]
;;;246    
;;;247    					/* for the check it is distinguished if the remaining bytes are less than 8 (in that
;;;248    					   case 7 data bytes were sent and the SDO-Download Segment header contains the information
;;;249    						how much bytes are valid (CAN-compatibility)), otherwise the length has to match exactly
;;;250    						and the SDO-Download Segment-Headerbyte is ignored */
;;;251    					if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
000050  1ec1              SUBS     r1,r0,#3
000052  42a9              CMP      r1,r5
000054  d306              BCC      |L5.100|
;;;252    						&& (bytesToSave == ((UINT16)(MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.SegHeader & SEGHEADER_SEGDATASIZE) >> SEGHEADERSHIFT_SEGDATASIZE))))
000056  7a21              LDRB     r1,[r4,#8]
000058  f3c10142          UBFX     r1,r1,#1,#3
00005c  f1c10107          RSB      r1,r1,#7
000060  42a9              CMP      r1,r5
000062  d004              BEQ      |L5.110|
                  |L5.100|
;;;253    						)
;;;254    						|| ((bytesToSave > MIN_SEGMENTED_DATA)
000064  2d07              CMP      r5,#7
000066  d906              BLS      |L5.118|
;;;255    							&& (bytesToSave == (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
000068  1ec1              SUBS     r1,r0,#3
00006a  42a9              CMP      r1,r5
00006c  d103              BNE      |L5.118|
                  |L5.110|
;;;256    							))
;;;257    					{
;;;258    						/* length is correct */
;;;259    						bSdoSegFollows = FALSE;
00006e  2100              MOVS     r1,#0
000070  4a7d              LDR      r2,|L5.616|
000072  7011              STRB     r1,[r2,#0]
000074  e000              B        |L5.120|
                  |L5.118|
;;;260    					}
;;;261    					else
;;;262    					{
;;;263    						abort = ABORTIDX_PARAM_LENGTH_ERROR;
000076  270e              MOVS     r7,#0xe
                  |L5.120|
;;;264    					}
;;;265    				}
000078  e009              B        |L5.142|
                  |L5.122|
;;;266    				else
;;;267    				{
;;;268    					abort = ABORTIDX_PARAM_LENGTH_ERROR;
00007a  270e              MOVS     r7,#0xe
00007c  e007              B        |L5.142|
                  |L5.126|
;;;269    				}
;;;270    			}
;;;271    			else
;;;272    			{
;;;273    				/* its not the last segment */
;;;274    				bSdoSegFollows = TRUE;
00007e  2001              MOVS     r0,#1
000080  4979              LDR      r1,|L5.616|
000082  7008              STRB     r0,[r1,#0]
;;;275    				/* we have to check if we expect less bytes than the maximum size which can be send with a single
;;;276    				   SDO Download Segment */
;;;277    				if (bytesToSave <= maxData)
000084  4545              CMP      r5,r8
000086  d801              BHI      |L5.140|
;;;278    				{
;;;279    					abort = ABORTIDX_PARAM_LENGTH_ERROR;
000088  270e              MOVS     r7,#0xe
00008a  e000              B        |L5.142|
                  |L5.140|
;;;280    				}
;;;281    				else
;;;282    				{
;;;283    					/* length is okay, bytesToSave contains the data size to be copied */
;;;284    					bytesToSave = maxData;
00008c  4645              MOV      r5,r8
                  |L5.142|
;;;285    				}
;;;286    			}
;;;287    
;;;288    			if (abort == 0)
00008e  2f00              CMP      r7,#0
000090  d17e              BNE      |L5.400|
;;;289    			{
;;;290    				/* the received data is copied in the buffer */
;;;291    				UINT16 i = 0;
000092  2600              MOVS     r6,#0
;;;292    
;;;293    				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
000094  4873              LDR      r0,|L5.612|
000096  7800              LDRB     r0,[r0,#0]  ; nSdoSegBytesToHandle
000098  f0000001          AND      r0,r0,#1
00009c  b370              CBZ      r0,|L5.252|
;;;294    				{
;;;295    					// Data0 will be copied to an odd address of pSdoSegData, Data1 to an even address (Segment 2, 4, ...)
;;;296    					// Read Data0
;;;297    					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
00009e  4871              LDR      r0,|L5.612|
0000a0  6800              LDR      r0,[r0,#0]  ; nSdoSegBytesToHandle
0000a2  0840              LSRS     r0,r0,#1
0000a4  496d              LDR      r1,|L5.604|
0000a6  6809              LDR      r1,[r1,#0]  ; pSdoSegData
0000a8  f8110010          LDRB     r0,[r1,r0,LSL #1]
0000ac  496d              LDR      r1,|L5.612|
0000ae  6809              LDR      r1,[r1,#0]  ; nSdoSegBytesToHandle
0000b0  0849              LSRS     r1,r1,#1
0000b2  4a6a              LDR      r2,|L5.604|
0000b4  6812              LDR      r2,[r2,#0]  ; pSdoSegData
0000b6  f8220011          STRH     r0,[r2,r1,LSL #1]
;;;298    					pSdoSegData[(nSdoSegBytesToHandle >> 1)] |= (pSdoInd->SdoHeader.SegHeader & SEGHDATA_MASK);
0000ba  486a              LDR      r0,|L5.612|
0000bc  6800              LDR      r0,[r0,#0]  ; nSdoSegBytesToHandle
0000be  0840              LSRS     r0,r0,#1
0000c0  4966              LDR      r1,|L5.604|
0000c2  6809              LDR      r1,[r1,#0]  ; pSdoSegData
0000c4  f8310010          LDRH     r0,[r1,r0,LSL #1]
0000c8  8921              LDRH     r1,[r4,#8]
0000ca  f401417f          AND      r1,r1,#0xff00
0000ce  4308              ORRS     r0,r0,r1
0000d0  4964              LDR      r1,|L5.612|
0000d2  6809              LDR      r1,[r1,#0]  ; nSdoSegBytesToHandle
0000d4  0849              LSRS     r1,r1,#1
0000d6  4a61              LDR      r2,|L5.604|
0000d8  6812              LDR      r2,[r2,#0]  ; pSdoSegData
0000da  f8220011          STRH     r0,[r2,r1,LSL #1]
;;;299    					// Copy Data1 - DataN
;;;300    					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
0000de  1e6a              SUBS     r2,r5,#1
0000e0  4960              LDR      r1,|L5.612|
0000e2  6809              LDR      r1,[r1,#0]  ; nSdoSegBytesToHandle
0000e4  2301              MOVS     r3,#1
0000e6  eb030151          ADD      r1,r3,r1,LSR #1
0000ea  4b5c              LDR      r3,|L5.604|
0000ec  681b              LDR      r3,[r3,#0]  ; pSdoSegData
0000ee  eb030041          ADD      r0,r3,r1,LSL #1
0000f2  f104010a          ADD      r1,r4,#0xa
0000f6  f7fffffe          BL       __aeabi_memcpy
0000fa  e026              B        |L5.330|
                  |L5.252|
;;;301    				}
;;;302    				else
;;;303    				{
;;;304    					// Data0 will be copied to an even address of pSdoSegData, Data1 to an odd address (Segment 1, 3,...)
;;;305    					// Read Data0 and Data1
;;;306    					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
0000fc  7aa1              LDRB     r1,[r4,#0xa]
0000fe  8920              LDRH     r0,[r4,#8]
000100  1200              ASRS     r0,r0,#8
000102  f361200f          BFI      r0,r1,#8,#8
000106  4957              LDR      r1,|L5.612|
000108  6809              LDR      r1,[r1,#0]  ; nSdoSegBytesToHandle
00010a  0849              LSRS     r1,r1,#1
00010c  4a53              LDR      r2,|L5.604|
00010e  6812              LDR      r2,[r2,#0]  ; pSdoSegData
000110  f8220011          STRH     r0,[r2,r1,LSL #1]
;;;307    
;;;308    					// Copy Data2 - DataN
;;;309    					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
000114  2601              MOVS     r6,#1
000116  e014              B        |L5.322|
                  |L5.280|
000118  e063              B        |L5.482|
                  |L5.282|
;;;310    					{
;;;311    						pSdoSegData[(nSdoSegBytesToHandle >> 1) + i] = ((pSdoInd->SdoHeader.Data[i - 1] >> SEGDATASHIFT) & ~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[i] << 8) & SEGHDATA_MASK);
00011a  f104000a          ADD      r0,r4,#0xa
00011e  f8102016          LDRB     r2,[r0,r6,LSL #1]
000122  1e71              SUBS     r1,r6,#1
000124  f8300011          LDRH     r0,[r0,r1,LSL #1]
000128  1200              ASRS     r0,r0,#8
00012a  f362200f          BFI      r0,r2,#8,#8
00012e  494d              LDR      r1,|L5.612|
000130  6809              LDR      r1,[r1,#0]  ; nSdoSegBytesToHandle
000132  eb060151          ADD      r1,r6,r1,LSR #1
000136  4a49              LDR      r2,|L5.604|
000138  6812              LDR      r2,[r2,#0]  ; pSdoSegData
00013a  f8220011          STRH     r0,[r2,r1,LSL #1]
00013e  1c70              ADDS     r0,r6,#1              ;309
000140  b286              UXTH     r6,r0                 ;309
                  |L5.322|
000142  1c68              ADDS     r0,r5,#1              ;309
000144  ebb60f50          CMP      r6,r0,LSR #1          ;309
000148  d3e7              BCC      |L5.282|
                  |L5.330|
;;;312    						// (If bytesToSave is odd, one byte too much is copied. But, that is not a problem.)
;;;313    					}
;;;314    				}
;;;315    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 334 to 336 deleted*/
;;;316    
;;;317    				if (bSdoSegFollows == FALSE)
00014a  4847              LDR      r0,|L5.616|
00014c  7800              LDRB     r0,[r0,#0]  ; bSdoSegFollows
00014e  2800              CMP      r0,#0
000150  d146              BNE      |L5.480|
;;;318    				{
;;;319    					/* it was the last segment, OBJ_Write will called to make the Write-operation */
;;;320    					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
000152  4846              LDR      r0,|L5.620|
000154  7800              LDRB     r0,[r0,#0]  ; bSdoSegAccess
000156  4941              LDR      r1,|L5.604|
000158  6809              LDR      r1,[r1,#0]  ; pSdoSegData
00015a  e9cd1000          STRD     r1,r0,[sp,#0]
00015e  4844              LDR      r0,|L5.624|
000160  6803              LDR      r3,[r0,#0]  ; pSdoSegObjEntry
000162  483f              LDR      r0,|L5.608|
000164  6802              LDR      r2,[r0,#0]  ; nSdoSegCompleteSize
000166  4843              LDR      r0,|L5.628|
000168  7801              LDRB     r1,[r0,#0]  ; nSdoSegSubindex
00016a  4843              LDR      r0,|L5.632|
00016c  8800              LDRH     r0,[r0,#0]  ; nSdoSegIndex
00016e  f7fffffe          BL       OBJ_Write
000172  4607              MOV      r7,r0
;;;321    					if (abort == ABORTIDX_WORKING)
000174  2fff              CMP      r7,#0xff
000176  d12c              BNE      |L5.466|
;;;322    					{
;;;323    						/* the application generates the SDO-Response later on by calling SDOS_SdoRes (only possible if object access function pointer is defined) */
;;;324    						u8PendingSdo = SDO_PENDING_SEG_WRITE;
000178  2002              MOVS     r0,#2
00017a  4940              LDR      r1,|L5.636|
00017c  7008              STRB     r0,[r1,#0]
;;;325    						bStoreCompleteAccess = bSdoSegAccess;
00017e  483b              LDR      r0,|L5.620|
000180  7800              LDRB     r0,[r0,#0]  ; bSdoSegAccess
000182  493f              LDR      r1,|L5.640|
000184  7008              STRB     r0,[r1,#0]
;;;326    						u8StoreSubindex = nSdoSegSubindex;
000186  483b              LDR      r0,|L5.628|
000188  7800              LDRB     r0,[r0,#0]  ; nSdoSegSubindex
00018a  493e              LDR      r1,|L5.644|
00018c  7008              STRB     r0,[r1,#0]
;;;327    						u16StoreIndex = nSdoSegIndex;
00018e  e000              B        |L5.402|
                  |L5.400|
000190  e028              B        |L5.484|
                  |L5.402|
000192  4839              LDR      r0,|L5.632|
000194  8800              LDRH     r0,[r0,#0]  ; nSdoSegIndex
000196  493c              LDR      r1,|L5.648|
000198  8008              STRH     r0,[r1,#0]
;;;328    						u32StoreDataSize = nSdoSegCompleteSize;
00019a  4831              LDR      r0,|L5.608|
00019c  6800              LDR      r0,[r0,#0]  ; nSdoSegCompleteSize
00019e  493b              LDR      r1,|L5.652|
0001a0  6008              STR      r0,[r1,#0]  ; u32StoreDataSize
;;;329    						pStoreData = pSdoSegData;
0001a2  482e              LDR      r0,|L5.604|
0001a4  6800              LDR      r0,[r0,#0]  ; pSdoSegData
0001a6  493a              LDR      r1,|L5.656|
0001a8  6008              STR      r0,[r1,#0]  ; pStoreData
;;;330    
;;;331    						pSdoPendFunc = pSdoSegObjEntry->Write;
0001aa  4831              LDR      r0,|L5.624|
0001ac  6800              LDR      r0,[r0,#0]  ; pSdoSegObjEntry
0001ae  6a00              LDR      r0,[r0,#0x20]
0001b0  4938              LDR      r1,|L5.660|
0001b2  6008              STR      r0,[r1,#0]  ; pSdoPendFunc
;;;332    
;;;333    						bSdoInWork = TRUE;
0001b4  2001              MOVS     r0,#1
0001b6  4938              LDR      r1,|L5.664|
0001b8  7008              STRB     r0,[r1,#0]
;;;334    						pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
0001ba  4838              LDR      r0,|L5.668|
0001bc  6004              STR      r4,[r0,#0]  ; pSdoResStored
;;;335    
;;;336    						bSdoSegFollows = FALSE;
0001be  2000              MOVS     r0,#0
0001c0  4929              LDR      r1,|L5.616|
0001c2  7008              STRB     r0,[r1,#0]
;;;337    						nSdoSegService = 0;
0001c4  4936              LDR      r1,|L5.672|
0001c6  7008              STRB     r0,[r1,#0]
;;;338    						nSdoSegBytesToHandle = 0;
0001c8  4926              LDR      r1,|L5.612|
0001ca  6008              STR      r0,[r1,#0]  ; nSdoSegBytesToHandle
;;;339    
;;;340    						return ABORTIDX_WORKING;
0001cc  20ff              MOVS     r0,#0xff
                  |L5.462|
;;;341    					}
;;;342    					else
;;;343    					{
;;;344    						/* the allocated buffer can be released */
;;;345    						FREEMEM((UINT16 VARMEM *) pSdoSegData);
;;;346    						pSdoSegData = NULL;
;;;347    					}
;;;348    				}
;;;349    			}
;;;350    		}
;;;351    		else
;;;352    		{
;;;353    			abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
;;;354    		}
;;;355    	}
;;;356    
;;;357    	if (abort == 0)
;;;358    	{
;;;359    		/* send the SDO Download Segment response */
;;;360    		pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
;;;361    		pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
;;;362    		pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
;;;363    		/* the SDO Download Segment header depends if it was the last segment or not */
;;;364    		if (bSdoSegLastToggle)
;;;365    		{
;;;366    			pSdoInd->SdoHeader.SegHeader = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES | SEGHEADER_TOGGLE);
;;;367    		}
;;;368    		else
;;;369    		{
;;;370    			pSdoInd->SdoHeader.SegHeader = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
;;;371    		}
;;;372    
;;;373    		if (bSdoSegFollows == TRUE)
;;;374    		{
;;;375    			/* segments are still expected, nSdoSegBytesToHandle contains the number of received data bytes */
;;;376    			nSdoSegBytesToHandle += bytesToSave;
;;;377    		}
;;;378    		else
;;;379    		{
;;;380    			/* the last segment was received, the variables are reset */
;;;381    			nSdoSegBytesToHandle = 0;
;;;382    			nSdoSegService = 0;
;;;383    		}
;;;384    	}
;;;385    	else
;;;386    	{
;;;387    		/* the Abort-Response will be sent in SDOS_SdoInd*/
;;;388    		bSdoSegFollows = FALSE;
;;;389    		nSdoSegService = 0;
;;;390    		if (pSdoSegData)
;;;391    		{
;;;392    			/* the memory has to be released if it is not released before.
;;;393    			In case of AbortIdx_Working the buffer will be freed in SDOS_SdoRes*/
;;;394    			FREEMEM((UINT16 VARMEM *) pSdoSegData);
;;;395    			pSdoSegData = NULL;
;;;396    		}
;;;397    
;;;398    		nSdoSegBytesToHandle = 0;
;;;399    	}
;;;400    
;;;401    	return abort;
;;;402    }
0001ce  e8bd81fc          POP      {r2-r8,pc}
                  |L5.466|
0001d2  4822              LDR      r0,|L5.604|
0001d4  6800              LDR      r0,[r0,#0]            ;345  ; pSdoSegData
0001d6  f7fffffe          BL       free
0001da  2000              MOVS     r0,#0                 ;346
0001dc  491f              LDR      r1,|L5.604|
0001de  6008              STR      r0,[r1,#0]            ;346  ; pSdoSegData
                  |L5.480|
0001e0  e000              B        |L5.484|
                  |L5.482|
0001e2  2703              MOVS     r7,#3                 ;353
                  |L5.484|
0001e4  bf00              NOP                            ;355
                  |L5.486|
0001e6  bb0f              CBNZ     r7,|L5.556|
0001e8  200a              MOVS     r0,#0xa               ;360
0001ea  8020              STRH     r0,[r4,#0]            ;360
0001ec  88e0              LDRH     r0,[r4,#6]            ;361
0001ee  f4204070          BIC      r0,r0,#0xf000         ;361
0001f2  80e0              STRH     r0,[r4,#6]            ;361
0001f4  88e0              LDRH     r0,[r4,#6]            ;362
0001f6  f4405040          ORR      r0,r0,#0x3000         ;362
0001fa  80e0              STRH     r0,[r4,#6]            ;362
0001fc  4815              LDR      r0,|L5.596|
0001fe  7800              LDRB     r0,[r0,#0]            ;364  ; bSdoSegLastToggle
000200  b110              CBZ      r0,|L5.520|
000202  2030              MOVS     r0,#0x30              ;366
000204  8120              STRH     r0,[r4,#8]            ;366
000206  e001              B        |L5.524|
                  |L5.520|
000208  2020              MOVS     r0,#0x20              ;370
00020a  8120              STRH     r0,[r4,#8]            ;370
                  |L5.524|
00020c  4816              LDR      r0,|L5.616|
00020e  7800              LDRB     r0,[r0,#0]            ;373  ; bSdoSegFollows
000210  2801              CMP      r0,#1                 ;373
000212  d105              BNE      |L5.544|
000214  4813              LDR      r0,|L5.612|
000216  6800              LDR      r0,[r0,#0]            ;376  ; nSdoSegBytesToHandle
000218  4428              ADD      r0,r0,r5              ;376
00021a  4912              LDR      r1,|L5.612|
00021c  6008              STR      r0,[r1,#0]            ;376  ; nSdoSegBytesToHandle
00021e  e017              B        |L5.592|
                  |L5.544|
000220  2000              MOVS     r0,#0                 ;381
000222  4910              LDR      r1,|L5.612|
000224  6008              STR      r0,[r1,#0]            ;381  ; nSdoSegBytesToHandle
000226  491e              LDR      r1,|L5.672|
000228  7008              STRB     r0,[r1,#0]            ;382
00022a  e011              B        |L5.592|
                  |L5.556|
00022c  2000              MOVS     r0,#0                 ;388
00022e  490e              LDR      r1,|L5.616|
000230  7008              STRB     r0,[r1,#0]            ;388
000232  491b              LDR      r1,|L5.672|
000234  7008              STRB     r0,[r1,#0]            ;389
000236  4809              LDR      r0,|L5.604|
000238  6800              LDR      r0,[r0,#0]            ;390  ; pSdoSegData
00023a  b130              CBZ      r0,|L5.586|
00023c  4807              LDR      r0,|L5.604|
00023e  6800              LDR      r0,[r0,#0]            ;394  ; pSdoSegData
000240  f7fffffe          BL       free
000244  2000              MOVS     r0,#0                 ;395
000246  4905              LDR      r1,|L5.604|
000248  6008              STR      r0,[r1,#0]            ;395  ; pSdoSegData
                  |L5.586|
00024a  2000              MOVS     r0,#0                 ;398
00024c  4905              LDR      r1,|L5.612|
00024e  6008              STR      r0,[r1,#0]            ;398  ; nSdoSegBytesToHandle
                  |L5.592|
000250  4638              MOV      r0,r7                 ;401
000252  e7bc              B        |L5.462|
;;;403    
                          ENDP

                  |L5.596|
                          DCD      bSdoSegLastToggle
                  |L5.600|
                          DCD      u16ReceiveMbxSize
                  |L5.604|
                          DCD      pSdoSegData
                  |L5.608|
                          DCD      nSdoSegCompleteSize
                  |L5.612|
                          DCD      nSdoSegBytesToHandle
                  |L5.616|
                          DCD      bSdoSegFollows
                  |L5.620|
                          DCD      bSdoSegAccess
                  |L5.624|
                          DCD      pSdoSegObjEntry
                  |L5.628|
                          DCD      nSdoSegSubindex
                  |L5.632|
                          DCD      nSdoSegIndex
                  |L5.636|
                          DCD      u8PendingSdo
                  |L5.640|
                          DCD      bStoreCompleteAccess
                  |L5.644|
                          DCD      u8StoreSubindex
                  |L5.648|
                          DCD      u16StoreIndex
                  |L5.652|
                          DCD      u32StoreDataSize
                  |L5.656|
                          DCD      pStoreData
                  |L5.660|
                          DCD      pSdoPendFunc
                  |L5.664|
                          DCD      bSdoInWork
                  |L5.668|
                          DCD      pSdoResStored
                  |L5.672|
                          DCD      nSdoSegService

                          AREA ||i.SdoRes||, CODE, READONLY, ALIGN=2

                  SdoRes PROC
;;;540    
;;;541    void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TINITSDOMBX MBXMEM *pSdoRes)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;542    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9dd5408          LDRD     r5,r4,[sp,#0x20]
;;;543    	/* for an upload segment response the toggle bit was overwritten */
;;;544    	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
000010  2e60              CMP      r6,#0x60
000012  d004              BEQ      |L6.30|
000014  b11e              CBZ      r6,|L6.30|
;;;545    	{
;;;546    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 581 to 583 deleted*/
;;;547    		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
000016  8920              LDRH     r0,[r4,#8]
000018  f400407f          AND      r0,r0,#0xff00
00001c  8120              STRH     r0,[r4,#8]
                  |L6.30|
;;;548    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 586 to 588 deleted*/
;;;549    	}
;;;550    	if (abort == 0)
00001e  2f00              CMP      r7,#0
000020  d13e              BNE      |L6.160|
;;;551    	{
;;;552    		/* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
;;;553    		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
000022  88e0              LDRH     r0,[r4,#6]
000024  f4204070          BIC      r0,r0,#0xf000
000028  80e0              STRH     r0,[r4,#6]
;;;554    		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
00002a  88e0              LDRH     r0,[r4,#6]
00002c  f4405040          ORR      r0,r0,#0x3000
000030  80e0              STRH     r0,[r4,#6]
;;;555    		if (command == SDOSERVICE_INITIATEUPLOADREQ)
000032  2e40              CMP      r6,#0x40
000034  d123              BNE      |L6.126|
;;;556    		{
;;;557    			// HBu 06.02.06: Complete Access Bit in the SDO-Upload-Response too */
;;;558    			if ((objLength <= 4) && (objLength > 0))
000036  2d04              CMP      r5,#4
000038  d80f              BHI      |L6.90|
00003a  b175              CBZ      r5,|L6.90|
;;;559    			{
;;;560    				/* Expedited Upload Response */
;;;561    				pSdoRes->MbxHeader.Length = EXPEDITED_FRAME_SIZE;
00003c  200a              MOVS     r0,#0xa
00003e  8020              STRH     r0,[r4,#0]
;;;562    				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
000040  f0480003          ORR      r0,r8,#3
000044  b2e9              UXTB     r1,r5
000046  f1c10104          RSB      r1,r1,#4
00004a  ea400081          ORR      r0,r0,r1,LSL #2
00004e  f0400040          ORR      r0,r0,#0x40
000052  8921              LDRH     r1,[r4,#8]
000054  4308              ORRS     r0,r0,r1
000056  8120              STRH     r0,[r4,#8]
000058  e034              B        |L6.196|
                  |L6.90|
;;;563    					SDOHEADER_TRANSFERTYPE |
;;;564    					completeAccess |
;;;565    					((MAX_EXPEDITED_DATA - ((UINT8)objLength)) << SDOHEADERSHIFT_DATASETSIZE) |
;;;566    					SDOSERVICE_INITIATEUPLOADRES);
;;;567    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 608 to 614 deleted*/
;;;568    			}
;;;569    			else
;;;570    			{
;;;571    				/* Normal or Segmented Upload Response */
;;;572    				if (dataSize < objLength)
00005a  45a9              CMP      r9,r5
00005c  d203              BCS      |L6.102|
;;;573    				{
;;;574    					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
00005e  f109000a          ADD      r0,r9,#0xa
000062  8020              STRH     r0,[r4,#0]
000064  e002              B        |L6.108|
                  |L6.102|
;;;575    				}
;;;576    				else
;;;577    				{
;;;578    					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + ((UINT16)objLength);
000066  f105000a          ADD      r0,r5,#0xa
00006a  8020              STRH     r0,[r4,#0]
                  |L6.108|
;;;579    				}
;;;580    				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT16)objLength);
00006c  81a5              STRH     r5,[r4,#0xc]
;;;581    				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
00006e  0c29              LSRS     r1,r5,#16
000070  81e1              STRH     r1,[r4,#0xe]
;;;582    				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
000072  8920              LDRH     r0,[r4,#8]
000074  f0480141          ORR      r1,r8,#0x41
000078  4308              ORRS     r0,r0,r1
00007a  8120              STRH     r0,[r4,#8]
00007c  e022              B        |L6.196|
                  |L6.126|
;;;583    					completeAccess |
;;;584    					SDOSERVICE_INITIATEUPLOADRES);
;;;585    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 635 to 639 deleted*/
;;;586    
;;;587    			}
;;;588    		}
;;;589    		/* for a segmented response the command was wrong in the response */
;;;590    		else if (command == SDOSERVICE_DOWNLOADSEGMENTREQ)
00007e  b936              CBNZ     r6,|L6.142|
;;;591    		{
;;;592    			/* Download segmented response */
;;;593    			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
000080  200a              MOVS     r0,#0xa
000082  8020              STRH     r0,[r4,#0]
;;;594    			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
000084  8920              LDRH     r0,[r4,#8]
000086  f0400020          ORR      r0,r0,#0x20
00008a  8120              STRH     r0,[r4,#8]
00008c  e01a              B        |L6.196|
                  |L6.142|
;;;595    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 650 to 652 deleted*/
;;;596    		}
;;;597    		else if (command != SDOSERVICE_UPLOADSEGMENTREQ)
00008e  2e60              CMP      r6,#0x60
000090  d018              BEQ      |L6.196|
;;;598    		{
;;;599    			/* Download response */
;;;600    			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
000092  200a              MOVS     r0,#0xa
000094  8020              STRH     r0,[r4,#0]
;;;601    			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
000096  8920              LDRH     r0,[r4,#8]
000098  f0400060          ORR      r0,r0,#0x60
00009c  8120              STRH     r0,[r4,#8]
00009e  e011              B        |L6.196|
                  |L6.160|
;;;602    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 660 to 662 deleted*/
;;;603    		}
;;;604    	}
;;;605    	else
;;;606    	{
;;;607    		/* generate a SDO-Abort-Request */
;;;608    		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
0000a0  200a              MOVS     r0,#0xa
0000a2  8020              STRH     r0,[r4,#0]
;;;609    		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
0000a4  88e0              LDRH     r0,[r4,#6]
0000a6  f4204070          BIC      r0,r0,#0xf000
0000aa  80e0              STRH     r0,[r4,#6]
;;;610    		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
0000ac  88e0              LDRH     r0,[r4,#6]
0000ae  f4405000          ORR      r0,r0,#0x2000
0000b2  80e0              STRH     r0,[r4,#6]
;;;611    		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
0000b4  8920              LDRH     r0,[r4,#8]
0000b6  f0400080          ORR      r0,r0,#0x80
0000ba  8120              STRH     r0,[r4,#8]
;;;612    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 673 to 675 deleted*/
;;;613    
;;;614    /*ET9300 Project Handler :(#if BIG_ENDIAN_16BIT) lines 677 to 680 deleted*/
;;;615    		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
0000bc  4806              LDR      r0,|L6.216|
0000be  f8500027          LDR      r0,[r0,r7,LSL #2]
0000c2  60e0              STR      r0,[r4,#0xc]
                  |L6.196|
;;;616    	}
;;;617    
;;;618    	// HBu 02.05.06: if the CoE-response could not be sent because the
;;;619    	//               send mailbox is full it should be stored
;;;620    	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
0000c4  2102              MOVS     r1,#2
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       MBX_MailboxSendReq
0000cc  b108              CBZ      r0,|L6.210|
;;;621    	{
;;;622    		/* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox is read */
;;;623    		pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
0000ce  4803              LDR      r0,|L6.220|
0000d0  6004              STR      r4,[r0,#0]  ; pCoeSendStored
                  |L6.210|
;;;624    	}
;;;625    }
0000d2  e8bd87f0          POP      {r4-r10,pc}
;;;626    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L6.216|
                          DCD      cAbortCode
                  |L6.220|
                          DCD      pCoeSendStored

                          AREA ||i.SdoUploadSegmentInd||, CODE, READONLY, ALIGN=2

                  SdoUploadSegmentInd PROC
;;;414    
;;;415    static UINT8 SdoUploadSegmentInd(TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;416    {
000004  4606              MOV      r6,r0
;;;417    	UINT8 abort = 0;
000006  f04f0800          MOV      r8,#0
;;;418    	TUPLOADSDOSEGRESMBX MBXMEM * pSdoSegRes = (TUPLOADSDOSEGRESMBX MBXMEM *)pSdoInd;
00000a  4634              MOV      r4,r6
;;;419    
;;;420    	if (SWAPWORD(pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
00000c  7a30              LDRB     r0,[r6,#8]
00000e  f0000010          AND      r0,r0,#0x10
000012  495c              LDR      r1,|L7.388|
000014  7809              LDRB     r1,[r1,#0]  ; bSdoSegLastToggle
000016  4288              CMP      r0,r1
000018  d102              BNE      |L7.32|
;;;421    	{
;;;422    		/* toggle bit has not toggled... */
;;;423    		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
00001a  f04f0801          MOV      r8,#1
00001e  e0ae              B        |L7.382|
                  |L7.32|
;;;424    	}
;;;425    	else
;;;426    	{
;;;427    		/* maxData contains the maximum data to be sent with a SDO-Upload Segment response */
;;;428    
;;;429    		UINT32 size = 0;
000020  2500              MOVS     r5,#0
;;;430    		UINT16 maxData;
;;;431    
;;;432    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 455 to 462 deleted*/
;;;433    		{
;;;434    			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
000022  4859              LDR      r0,|L7.392|
000024  8800              LDRH     r0,[r0,#0]  ; u16SendMbxSize
000026  3809              SUBS     r0,r0,#9
000028  b287              UXTH     r7,r0
;;;435    		}
;;;436    
;;;437    		/* the new toggle bit is stored in bSdoSegLastToggle */
;;;438    		bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
00002a  7a30              LDRB     r0,[r6,#8]
00002c  f0000010          AND      r0,r0,#0x10
000030  4954              LDR      r1,|L7.388|
000032  7008              STRB     r0,[r1,#0]
;;;439    
;;;440    		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
000034  4855              LDR      r0,|L7.396|
000036  6800              LDR      r0,[r0,#0]  ; nSdoSegBytesToHandle
000038  4438              ADD      r0,r0,r7
00003a  4955              LDR      r1,|L7.400|
00003c  6809              LDR      r1,[r1,#0]  ; nSdoSegCompleteSize
00003e  4288              CMP      r0,r1
000040  d908              BLS      |L7.84|
;;;441    		{
;;;442    			/* the remaining data can be send with one SDO Upload Segment response,
;;;443    			   size contains the data to be copied */
;;;444    			size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
000042  4853              LDR      r0,|L7.400|
000044  6800              LDR      r0,[r0,#0]  ; nSdoSegCompleteSize
000046  4951              LDR      r1,|L7.396|
000048  6809              LDR      r1,[r1,#0]  ; nSdoSegBytesToHandle
00004a  1a45              SUBS     r5,r0,r1
;;;445    			bSdoSegFollows = FALSE;
00004c  2000              MOVS     r0,#0
00004e  4951              LDR      r1,|L7.404|
000050  7008              STRB     r0,[r1,#0]
000052  e003              B        |L7.92|
                  |L7.84|
;;;446    		}
;;;447    		else
;;;448    		{
;;;449    			/* more data will follow, size contains the data to be copied */
;;;450    			size = maxData;
000054  463d              MOV      r5,r7
;;;451    			bSdoSegFollows = TRUE;
000056  2001              MOVS     r0,#1
000058  494e              LDR      r1,|L7.404|
00005a  7008              STRB     r0,[r1,#0]
                  |L7.92|
;;;452    		}
;;;453    
;;;454    		/* copy the object data in the SDO Upload segment response */
;;;455    		// Clear Data0
;;;456    		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
00005c  7a20              LDRB     r0,[r4,#8]
00005e  8120              STRH     r0,[r4,#8]
;;;457    		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
000060  484a              LDR      r0,|L7.396|
000062  7800              LDRB     r0,[r0,#0]  ; nSdoSegBytesToHandle
000064  f0000001          AND      r0,r0,#1
000068  b1d0              CBZ      r0,|L7.160|
;;;458    		{
;;;459    			// Data starts at odd byte number (Segment 2, 4,...): Data0 is at high byte, Data1 lies at an even address
;;;460    			// Write Data0
;;;461    			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
00006a  8920              LDRH     r0,[r4,#8]
00006c  4947              LDR      r1,|L7.396|
00006e  6809              LDR      r1,[r1,#0]  ; nSdoSegBytesToHandle
000070  0849              LSRS     r1,r1,#1
000072  4a49              LDR      r2,|L7.408|
000074  6812              LDR      r2,[r2,#0]  ; pSdoSegData
000076  f8321011          LDRH     r1,[r2,r1,LSL #1]
00007a  f401417f          AND      r1,r1,#0xff00
00007e  4308              ORRS     r0,r0,r1
000080  8120              STRH     r0,[r4,#8]
;;;462    			// Copy Data1 - DataN
;;;463    			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
000082  1e6a              SUBS     r2,r5,#1
000084  4841              LDR      r0,|L7.396|
000086  6800              LDR      r0,[r0,#0]  ; nSdoSegBytesToHandle
000088  2301              MOVS     r3,#1
00008a  eb030050          ADD      r0,r3,r0,LSR #1
00008e  4b42              LDR      r3,|L7.408|
000090  681b              LDR      r3,[r3,#0]  ; pSdoSegData
000092  eb030140          ADD      r1,r3,r0,LSL #1
000096  f104000a          ADD      r0,r4,#0xa
00009a  f7fffffe          BL       __aeabi_memcpy
00009e  e02f              B        |L7.256|
                  |L7.160|
;;;464    		}
;;;465    		else
;;;466    		{
;;;467    			UINT16 i = 0;
0000a0  2000              MOVS     r0,#0
;;;468    			UINT32 nIndexOffset = nSdoSegBytesToHandle >> 1;
0000a2  4a3a              LDR      r2,|L7.396|
0000a4  6812              LDR      r2,[r2,#0]  ; nSdoSegBytesToHandle
0000a6  0851              LSRS     r1,r2,#1
;;;469    
;;;470    			// Data starts at even byte number (Segment 1,3, ...): Data0 is at low byte, Data1 lies at an odd address
;;;471    			// Write Data0
;;;472    			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
0000a8  8922              LDRH     r2,[r4,#8]
0000aa  4b38              LDR      r3,|L7.396|
0000ac  681b              LDR      r3,[r3,#0]  ; nSdoSegBytesToHandle
0000ae  085b              LSRS     r3,r3,#1
0000b0  f8dfc0e4          LDR      r12,|L7.408|
0000b4  f8dcc000          LDR      r12,[r12,#0]  ; pSdoSegData
0000b8  f83c3013          LDRH     r3,[r12,r3,LSL #1]
0000bc  f44f4c7f          MOV      r12,#0xff00
0000c0  ea0c2303          AND      r3,r12,r3,LSL #8
0000c4  431a              ORRS     r2,r2,r3
0000c6  8122              STRH     r2,[r4,#8]
;;;473    			// Copy Data1 - DataN
;;;474    
;;;475    			for (i = 0; i < (size >> 1); i++)
0000c8  bf00              NOP      
0000ca  e015              B        |L7.248|
                  |L7.204|
;;;476    			{
;;;477    				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
0000cc  1842              ADDS     r2,r0,r1
0000ce  4b32              LDR      r3,|L7.408|
0000d0  681b              LDR      r3,[r3,#0]  ; pSdoSegData
0000d2  f8332012          LDRH     r2,[r3,r2,LSL #1]
0000d6  0a13              LSRS     r3,r2,#8
0000d8  1842              ADDS     r2,r0,r1
0000da  1c52              ADDS     r2,r2,#1
0000dc  f8dfc0b8          LDR      r12,|L7.408|
0000e0  f8dcc000          LDR      r12,[r12,#0]  ; pSdoSegData
0000e4  f81c2012          LDRB     r2,[r12,r2,LSL #1]
0000e8  ea432302          ORR      r3,r3,r2,LSL #8
0000ec  f104020a          ADD      r2,r4,#0xa
0000f0  f8223010          STRH     r3,[r2,r0,LSL #1]
0000f4  1c42              ADDS     r2,r0,#1              ;475
0000f6  b290              UXTH     r0,r2                 ;475
                  |L7.248|
0000f8  ebb00f55          CMP      r0,r5,LSR #1          ;475
0000fc  d3e6              BCC      |L7.204|
;;;478    				// (If size is even, one byte too much is copied. But, that is not a problem.)
;;;479    			}
;;;480    		}
0000fe  bf00              NOP      
                  |L7.256|
;;;481    /*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 512 to 514 deleted*/
;;;482    
;;;483    		/* the SDO Upload Segment header depends if there is still data to be sent */
;;;484    		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
000100  88e0              LDRH     r0,[r4,#6]
000102  f4204070          BIC      r0,r0,#0xf000
000106  80e0              STRH     r0,[r4,#6]
;;;485    		pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
000108  88e0              LDRH     r0,[r4,#6]
00010a  f4405040          ORR      r0,r0,#0x3000
00010e  80e0              STRH     r0,[r4,#6]
;;;486    
;;;487    		/*Clear SDO header*/
;;;488    		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
000110  8920              LDRH     r0,[r4,#8]
000112  f02000ff          BIC      r0,r0,#0xff
000116  8120              STRH     r0,[r4,#8]
;;;489    		if (bSdoSegFollows)
000118  481e              LDR      r0,|L7.404|
00011a  7800              LDRB     r0,[r0,#0]  ; bSdoSegFollows
00011c  b128              CBZ      r0,|L7.298|
;;;490    		{
;;;491    			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle);
00011e  8920              LDRH     r0,[r4,#8]
000120  4918              LDR      r1,|L7.388|
000122  7809              LDRB     r1,[r1,#0]  ; bSdoSegLastToggle
000124  4308              ORRS     r0,r0,r1
000126  8120              STRH     r0,[r4,#8]
000128  e006              B        |L7.312|
                  |L7.298|
;;;492    		}
;;;493    		else
;;;494    		{
;;;495    			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle | SEGHEADER_NOMOREFOLLOWS);
00012a  8920              LDRH     r0,[r4,#8]
00012c  4915              LDR      r1,|L7.388|
00012e  7809              LDRB     r1,[r1,#0]  ; bSdoSegLastToggle
000130  f0410101          ORR      r1,r1,#1
000134  4308              ORRS     r0,r0,r1
000136  8120              STRH     r0,[r4,#8]
                  |L7.312|
;;;496    		}
;;;497    
;;;498    				// operate CAN specific flag segDataSize:
;;;499    				/* HBu 06.02.06: the sizes were wrong */
;;;500    		if (size < MIN_SEGMENTED_DATA)
000138  2d07              CMP      r5,#7
00013a  d208              BCS      |L7.334|
;;;501    		{
;;;502    			// at least    MIN_SEGMENTED_DATA bytes have to be send:
;;;503    			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
00013c  200a              MOVS     r0,#0xa
00013e  8020              STRH     r0,[r4,#0]
;;;504    			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
000140  8920              LDRH     r0,[r4,#8]
000142  f1c50107          RSB      r1,r5,#7
000146  ea400041          ORR      r0,r0,r1,LSL #1
00014a  8120              STRH     r0,[r4,#8]
00014c  e001              B        |L7.338|
                  |L7.334|
;;;505    		}
;;;506    		else
;;;507    		{
;;;508    			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
00014e  1ce8              ADDS     r0,r5,#3
000150  8020              STRH     r0,[r4,#0]
                  |L7.338|
;;;509    		}
;;;510    
;;;511    		if (bSdoSegFollows == TRUE)
000152  4810              LDR      r0,|L7.404|
000154  7800              LDRB     r0,[r0,#0]  ; bSdoSegFollows
000156  2801              CMP      r0,#1
000158  d105              BNE      |L7.358|
;;;512    		{
;;;513    			// updating the value of send bytes:
;;;514    			nSdoSegBytesToHandle += size;
00015a  480c              LDR      r0,|L7.396|
00015c  6800              LDR      r0,[r0,#0]  ; nSdoSegBytesToHandle
00015e  4428              ADD      r0,r0,r5
000160  490a              LDR      r1,|L7.396|
000162  6008              STR      r0,[r1,#0]  ; nSdoSegBytesToHandle
000164  e00a              B        |L7.380|
                  |L7.358|
;;;515    		}
;;;516    		else
;;;517    		{
;;;518    			FREEMEM((UINT16 VARMEM *) pSdoSegData);
000166  480c              LDR      r0,|L7.408|
000168  6800              LDR      r0,[r0,#0]  ; pSdoSegData
00016a  f7fffffe          BL       free
;;;519    			pSdoSegData = NULL;
00016e  2000              MOVS     r0,#0
000170  4909              LDR      r1,|L7.408|
000172  6008              STR      r0,[r1,#0]  ; pSdoSegData
;;;520    			nSdoSegBytesToHandle = 0;
000174  4905              LDR      r1,|L7.396|
000176  6008              STR      r0,[r1,#0]  ; nSdoSegBytesToHandle
;;;521    			nSdoSegService = 0;
000178  4908              LDR      r1,|L7.412|
00017a  7008              STRB     r0,[r1,#0]
                  |L7.380|
;;;522    		}
;;;523    	}
00017c  bf00              NOP      
                  |L7.382|
;;;524    
;;;525    	return abort;
00017e  4640              MOV      r0,r8
;;;526    }
000180  e8bd81f0          POP      {r4-r8,pc}
;;;527    
                          ENDP

                  |L7.388|
                          DCD      bSdoSegLastToggle
                  |L7.392|
                          DCD      u16SendMbxSize
                  |L7.396|
                          DCD      nSdoSegBytesToHandle
                  |L7.400|
                          DCD      nSdoSegCompleteSize
                  |L7.404|
                          DCD      bSdoSegFollows
                  |L7.408|
                          DCD      pSdoSegData
                  |L7.412|
                          DCD      nSdoSegService

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  cAbortCode
                          DCD      0x00000000
                          DCD      0x05030000
                          DCD      0x05040000
                          DCD      0x05040001
                          DCD      0x05040005
                          DCD      0x06010000
                          DCD      0x06010001
                          DCD      0x06010002
                          DCD      0x06020000
                          DCD      0x06040041
                          DCD      0x06040042
                          DCD      0x06040043
                          DCD      0x06040047
                          DCD      0x06060000
                          DCD      0x06070010
                          DCD      0x06070012
                          DCD      0x06070013
                          DCD      0x06090011
                          DCD      0x06090030
                          DCD      0x06090031
                          DCD      0x06090032
                          DCD      0x06090033
                          DCD      0x06090036
                          DCD      0x08000000
                          DCD      0x08000020
                          DCD      0x08000021
                          DCD      0x08000022
                          DCD      0x08000023
                          DCD      0x06010003
                          DCD      0x06010004

                          AREA ||.data||, DATA, ALIGN=2

                  u8PendingSdo
000000  00                DCB      0x00
                  bStoreCompleteAccess
000001  00                DCB      0x00
                  u8StoreSubindex
000002  0000              DCB      0x00,0x00
                  u16StoreIndex
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  u32StoreDataSize
                          DCD      0x00000000
                  pStoreData
                          DCD      0x00000000
                  pSdoPendFunc
                          DCD      0x00000000
                  aSdoInfoHeader
                          DCD      0x00000000
                  pSdoSegData
                          DCD      0x00000000
                  nSdoInfoFragmentsLeft
00001c  0000              DCB      0x00,0x00
                  nSdoInfoIndex
00001e  0000              DCB      0x00,0x00
                  pSdoInfoObjEntry
                          DCD      0x00000000
                  pSdoResStored
                          DCD      0x00000000
                  bSdoInWork
000028  00                DCB      0x00
                  nSdoSegService
000029  00                DCB      0x00
                  bSdoSegFollows
00002a  00                DCB      0x00
                  bSdoSegAccess
00002b  00                DCB      0x00
                  nSdoSegIndex
00002c  0000              DCB      0x00,0x00
                  nSdoSegSubindex
00002e  0000              DCB      0x00,0x00
                  nSdoSegBytesToHandle
                          DCD      0x00000000
                  bSdoSegLastToggle
000034  00000000          DCB      0x00,0x00,0x00,0x00
                  nSdoSegCompleteSize
                          DCD      0x00000000
                  pSdoSegObjEntry
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "etherCAT\\sdoserv.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_sdoserv_c_4358f1f4____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_sdoserv_c_4358f1f4____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_sdoserv_c_4358f1f4____REVSH|
#line 402
|__asm___9_sdoserv_c_4358f1f4____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_sdoserv_c_4358f1f4____RRX|
#line 587
|__asm___9_sdoserv_c_4358f1f4____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
