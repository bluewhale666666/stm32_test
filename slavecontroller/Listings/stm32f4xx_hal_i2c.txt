; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_hal_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hal_i2c.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\stm32f4xx_hal_i2c.crf D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c]
                          THUMB

                          AREA ||i.HAL_I2C_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AbortCpltCallback PROC
;;;5177     */
;;;5178   __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5179   {
;;;5180     /* Prevent unused argument(s) compilation warning */
;;;5181     UNUSED(hi2c);
;;;5182   
;;;5183     /* NOTE : This function should not be modified, when the callback is needed,
;;;5184               the HAL_I2C_AbortCpltCallback could be implemented in the user file
;;;5185      */
;;;5186   }
;;;5187   
                          ENDP


                          AREA ||i.HAL_I2C_AddrCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AddrCallback PROC
;;;5095     */
;;;5096   __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
000000  4770              BX       lr
;;;5097   {
;;;5098     /* Prevent unused argument(s) compilation warning */
;;;5099     UNUSED(hi2c);
;;;5100     UNUSED(TransferDirection);
;;;5101     UNUSED(AddrMatchCode);
;;;5102   
;;;5103     /* NOTE : This function should not be modified, when the callback is needed,
;;;5104               the HAL_I2C_AddrCallback() could be implemented in the user file
;;;5105      */
;;;5106   }
;;;5107   
                          ENDP


                          AREA ||i.HAL_I2C_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DeInit PROC
;;;549      */
;;;550    HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;551    {
000002  4604              MOV      r4,r0
;;;552      /* Check the I2C handle allocation */
;;;553      if (hi2c == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;554      {
;;;555        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;556      }
;;;557    
;;;558      /* Check the parameters */
;;;559      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;560    
;;;561      hi2c->State = HAL_I2C_STATE_BUSY;
;;;562    
;;;563      /* Disable the I2C Peripheral Clock */
;;;564      __HAL_I2C_DISABLE(hi2c);
;;;565    
;;;566    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;567      if (hi2c->MspDeInitCallback == NULL)
;;;568      {
;;;569        hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */
;;;570      }
;;;571    
;;;572      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;573      hi2c->MspDeInitCallback(hi2c);
;;;574    #else
;;;575      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;576      HAL_I2C_MspDeInit(hi2c);
;;;577    #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;578    
;;;579      hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
;;;580      hi2c->State         = HAL_I2C_STATE_RESET;
;;;581      hi2c->PreviousState = I2C_STATE_NONE;
;;;582      hi2c->Mode          = HAL_I2C_MODE_NONE;
;;;583    
;;;584      /* Release Lock */
;;;585      __HAL_UNLOCK(hi2c);
;;;586    
;;;587      return HAL_OK;
;;;588    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  2024              MOVS     r0,#0x24              ;561
00000c  f884003d          STRB     r0,[r4,#0x3d]         ;561
000010  6820              LDR      r0,[r4,#0]            ;564
000012  6800              LDR      r0,[r0,#0]            ;564
000014  f0200001          BIC      r0,r0,#1              ;564
000018  6821              LDR      r1,[r4,#0]            ;564
00001a  6008              STR      r0,[r1,#0]            ;564
00001c  4620              MOV      r0,r4                 ;576
00001e  f7fffffe          BL       HAL_I2C_MspDeInit
000022  2000              MOVS     r0,#0                 ;579
000024  6420              STR      r0,[r4,#0x40]         ;579
000026  f884003d          STRB     r0,[r4,#0x3d]         ;580
00002a  6320              STR      r0,[r4,#0x30]         ;581
00002c  f884003e          STRB     r0,[r4,#0x3e]         ;582
000030  bf00              NOP                            ;585
000032  f884003c          STRB     r0,[r4,#0x3c]         ;585
000036  bf00              NOP                            ;585
000038  bf00              NOP                            ;587
00003a  e7e5              B        |L3.8|
;;;589    
                          ENDP


                          AREA ||i.HAL_I2C_DisableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DisableListen_IT PROC
;;;4687     */
;;;4688   HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;4689   {
;;;4690     /* Declaration of tmp to prevent undefined behavior of volatile usage */
;;;4691     uint32_t tmp;
;;;4692   
;;;4693     /* Disable Address listen mode only if a transfer is not ongoing */
;;;4694     if (hi2c->State == HAL_I2C_STATE_LISTEN)
000002  f891003d          LDRB     r0,[r1,#0x3d]
000006  2828              CMP      r0,#0x28
000008  d11b              BNE      |L4.66|
;;;4695     {
;;;4696       tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
00000a  f891003d          LDRB     r0,[r1,#0x3d]
00000e  f0000203          AND      r2,r0,#3
;;;4697       hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
000012  f891003e          LDRB     r0,[r1,#0x3e]
000016  4310              ORRS     r0,r0,r2
000018  6308              STR      r0,[r1,#0x30]
;;;4698       hi2c->State = HAL_I2C_STATE_READY;
00001a  2020              MOVS     r0,#0x20
00001c  f881003d          STRB     r0,[r1,#0x3d]
;;;4699       hi2c->Mode = HAL_I2C_MODE_NONE;
000020  2000              MOVS     r0,#0
000022  f881003e          STRB     r0,[r1,#0x3e]
;;;4700   
;;;4701       /* Disable Address Acknowledge */
;;;4702       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4206080          BIC      r0,r0,#0x400
00002e  680b              LDR      r3,[r1,#0]
000030  6018              STR      r0,[r3,#0]
;;;4703   
;;;4704       /* Disable EVT and ERR interrupt */
;;;4705       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000032  6808              LDR      r0,[r1,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f4207040          BIC      r0,r0,#0x300
00003a  680b              LDR      r3,[r1,#0]
00003c  6058              STR      r0,[r3,#4]
;;;4706   
;;;4707       return HAL_OK;
00003e  2000              MOVS     r0,#0
                  |L4.64|
;;;4708     }
;;;4709     else
;;;4710     {
;;;4711       return HAL_BUSY;
;;;4712     }
;;;4713   }
000040  4770              BX       lr
                  |L4.66|
000042  2002              MOVS     r0,#2                 ;4711
000044  e7fc              B        |L4.64|
;;;4714   
                          ENDP


                          AREA ||i.HAL_I2C_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ER_IRQHandler PROC
;;;4950     */
;;;4951   void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4952   {
000004  4604              MOV      r4,r0
;;;4953     HAL_I2C_ModeTypeDef tmp1;
;;;4954     uint32_t tmp2;
;;;4955     HAL_I2C_StateTypeDef tmp3;
;;;4956     uint32_t tmp4;
;;;4957     uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
000006  6820              LDR      r0,[r4,#0]
000008  6947              LDR      r7,[r0,#0x14]
;;;4958     uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
00000a  6820              LDR      r0,[r4,#0]
00000c  f8d08004          LDR      r8,[r0,#4]
;;;4959     uint32_t error      = HAL_I2C_ERROR_NONE;
000010  2500              MOVS     r5,#0
;;;4960     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
000012  f894903e          LDRB     r9,[r4,#0x3e]
;;;4961   
;;;4962     /* I2C Bus error interrupt occurred ----------------------------------------*/
;;;4963     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
000016  f3c72000          UBFX     r0,r7,#8,#1
00001a  b140              CBZ      r0,|L5.46|
00001c  f3c82000          UBFX     r0,r8,#8,#1
000020  b128              CBZ      r0,|L5.46|
;;;4964     {
;;;4965       error |= HAL_I2C_ERROR_BERR;
000022  f0450501          ORR      r5,r5,#1
;;;4966   
;;;4967       /* Clear BERR flag */
;;;4968       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
000026  f46f7080          MVN      r0,#0x100
00002a  6821              LDR      r1,[r4,#0]
00002c  6148              STR      r0,[r1,#0x14]
                  |L5.46|
;;;4969     }
;;;4970   
;;;4971     /* I2C Arbitration Lost error interrupt occurred ---------------------------*/
;;;4972     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
00002e  f3c72040          UBFX     r0,r7,#9,#1
000032  b140              CBZ      r0,|L5.70|
000034  f3c82000          UBFX     r0,r8,#8,#1
000038  b128              CBZ      r0,|L5.70|
;;;4973     {
;;;4974       error |= HAL_I2C_ERROR_ARLO;
00003a  f0450502          ORR      r5,r5,#2
;;;4975   
;;;4976       /* Clear ARLO flag */
;;;4977       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
00003e  f46f7000          MVN      r0,#0x200
000042  6821              LDR      r1,[r4,#0]
000044  6148              STR      r0,[r1,#0x14]
                  |L5.70|
;;;4978     }
;;;4979   
;;;4980     /* I2C Acknowledge failure error interrupt occurred ------------------------*/
;;;4981     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
000046  f3c72080          UBFX     r0,r7,#10,#1
00004a  b370              CBZ      r0,|L5.170|
00004c  f3c82000          UBFX     r0,r8,#8,#1
000050  b358              CBZ      r0,|L5.170|
;;;4982     {
;;;4983       tmp1 = CurrentMode;
000052  46ca              MOV      r10,r9
;;;4984       tmp2 = hi2c->XferCount;
000054  f8b4b02a          LDRH     r11,[r4,#0x2a]
;;;4985       tmp3 = hi2c->State;
000058  f894603d          LDRB     r6,[r4,#0x3d]
;;;4986       tmp4 = hi2c->PreviousState;
00005c  6b20              LDR      r0,[r4,#0x30]
00005e  9000              STR      r0,[sp,#0]
;;;4987       if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
000060  f1ba0f20          CMP      r10,#0x20
000064  d10f              BNE      |L5.134|
000066  f1bb0f00          CMP      r11,#0
00006a  d10c              BNE      |L5.134|
;;;4988           ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
00006c  2e21              CMP      r6,#0x21
00006e  d006              BEQ      |L5.126|
000070  2e29              CMP      r6,#0x29
000072  d004              BEQ      |L5.126|
;;;4989            ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
000074  2e28              CMP      r6,#0x28
000076  d106              BNE      |L5.134|
000078  9800              LDR      r0,[sp,#0]
00007a  2821              CMP      r0,#0x21
00007c  d103              BNE      |L5.134|
                  |L5.126|
;;;4990       {
;;;4991         I2C_Slave_AF(hi2c);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       I2C_Slave_AF
000084  e011              B        |L5.170|
                  |L5.134|
;;;4992       }
;;;4993       else
;;;4994       {
;;;4995         /* Clear AF flag */
;;;4996         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000086  f46f6080          MVN      r0,#0x400
00008a  6821              LDR      r1,[r4,#0]
00008c  6148              STR      r0,[r1,#0x14]
;;;4997   
;;;4998         error |= HAL_I2C_ERROR_AF;
00008e  f0450504          ORR      r5,r5,#4
;;;4999   
;;;5000         /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
;;;5001         if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
000092  f1b90f10          CMP      r9,#0x10
000096  d002              BEQ      |L5.158|
000098  f1b90f40          CMP      r9,#0x40
00009c  d105              BNE      |L5.170|
                  |L5.158|
;;;5002         {
;;;5003           /* Generate Stop */
;;;5004           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00009e  6820              LDR      r0,[r4,#0]
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f4407000          ORR      r0,r0,#0x200
0000a6  6821              LDR      r1,[r4,#0]
0000a8  6008              STR      r0,[r1,#0]
                  |L5.170|
;;;5005         }
;;;5006       }
;;;5007     }
;;;5008   
;;;5009     /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
;;;5010     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
0000aa  f3c720c0          UBFX     r0,r7,#11,#1
0000ae  b140              CBZ      r0,|L5.194|
0000b0  f3c82000          UBFX     r0,r8,#8,#1
0000b4  b128              CBZ      r0,|L5.194|
;;;5011     {
;;;5012       error |= HAL_I2C_ERROR_OVR;
0000b6  f0450508          ORR      r5,r5,#8
;;;5013       /* Clear OVR flag */
;;;5014       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
0000ba  f46f6000          MVN      r0,#0x800
0000be  6821              LDR      r1,[r4,#0]
0000c0  6148              STR      r0,[r1,#0x14]
                  |L5.194|
;;;5015     }
;;;5016   
;;;5017     /* Call the Error Callback in case of Error detected -----------------------*/
;;;5018     if (error != HAL_I2C_ERROR_NONE)
0000c2  b12d              CBZ      r5,|L5.208|
;;;5019     {
;;;5020       hi2c->ErrorCode |= error;
0000c4  6c20              LDR      r0,[r4,#0x40]
0000c6  4328              ORRS     r0,r0,r5
0000c8  6420              STR      r0,[r4,#0x40]
;;;5021       I2C_ITError(hi2c);
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       I2C_ITError
                  |L5.208|
;;;5022     }
;;;5023   }
0000d0  e8bd8ff8          POP      {r3-r11,pc}
;;;5024   
                          ENDP


                          AREA ||i.HAL_I2C_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EV_IRQHandler PROC
;;;4781     */
;;;4782   void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4783   {
000004  4605              MOV      r5,r0
;;;4784     uint32_t sr1itflags;
;;;4785     uint32_t sr2itflags               = 0U;
000006  f04f0900          MOV      r9,#0
;;;4786     uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
00000a  6828              LDR      r0,[r5,#0]
00000c  6846              LDR      r6,[r0,#4]
;;;4787     uint32_t CurrentXferOptions       = hi2c->XferOptions;
00000e  f8d5a02c          LDR      r10,[r5,#0x2c]
;;;4788     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
000012  f895703e          LDRB     r7,[r5,#0x3e]
;;;4789     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000016  f895803d          LDRB     r8,[r5,#0x3d]
;;;4790   
;;;4791     /* Master or Memory mode selected */
;;;4792     if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
00001a  2f10              CMP      r7,#0x10
00001c  d001              BEQ      |L6.34|
00001e  2f40              CMP      r7,#0x40
000020  d175              BNE      |L6.270|
                  |L6.34|
;;;4793     {
;;;4794       sr2itflags   = READ_REG(hi2c->Instance->SR2);
000022  6828              LDR      r0,[r5,#0]
000024  f8d09018          LDR      r9,[r0,#0x18]
;;;4795       sr1itflags   = READ_REG(hi2c->Instance->SR1);
000028  6828              LDR      r0,[r5,#0]
00002a  6944              LDR      r4,[r0,#0x14]
;;;4796   
;;;4797       /* Exit IRQ event until Start Bit detected in case of Other frame requested */
;;;4798       if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
00002c  f0040001          AND      r0,r4,#1
000030  b960              CBNZ     r0,|L6.76|
000032  f5ba0f2a          CMP      r10,#0xaa0000
000036  d002              BEQ      |L6.62|
000038  f1ba4f2a          CMP      r10,#0xaa000000
00003c  d101              BNE      |L6.66|
                  |L6.62|
00003e  2001              MOVS     r0,#1
000040  e000              B        |L6.68|
                  |L6.66|
000042  2000              MOVS     r0,#0
                  |L6.68|
000044  2801              CMP      r0,#1
000046  d101              BNE      |L6.76|
                  |L6.72|
;;;4799       {
;;;4800         return;
;;;4801       }
;;;4802   
;;;4803       /* SB Set ----------------------------------------------------------------*/
;;;4804       if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4805       {
;;;4806         /* Convert OTHER_xxx XferOptions if any */
;;;4807         I2C_ConvertOtherXferOptions(hi2c);
;;;4808   
;;;4809         I2C_Master_SB(hi2c);
;;;4810       }
;;;4811       /* ADD10 Set -------------------------------------------------------------*/
;;;4812       else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4813       {
;;;4814         I2C_Master_ADD10(hi2c);
;;;4815       }
;;;4816       /* ADDR Set --------------------------------------------------------------*/
;;;4817       else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4818       {
;;;4819         I2C_Master_ADDR(hi2c);
;;;4820       }
;;;4821       /* I2C in mode Transmitter -----------------------------------------------*/
;;;4822       else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
;;;4823       {
;;;4824         /* Do not check buffer and BTF flag if a Xfer DMA is on going */
;;;4825         if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
;;;4826         {
;;;4827           /* TXE set and BTF reset -----------------------------------------------*/
;;;4828           if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4829           {
;;;4830             I2C_MasterTransmit_TXE(hi2c);
;;;4831           }
;;;4832           /* BTF set -------------------------------------------------------------*/
;;;4833           else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4834           {
;;;4835             if (CurrentState == HAL_I2C_STATE_BUSY_TX)
;;;4836             {
;;;4837               I2C_MasterTransmit_BTF(hi2c);
;;;4838             }
;;;4839             else /* HAL_I2C_MODE_MEM */
;;;4840             {
;;;4841               if (CurrentMode == HAL_I2C_MODE_MEM)
;;;4842               {
;;;4843                 I2C_MemoryTransmit_TXE_BTF(hi2c);
;;;4844               }
;;;4845             }
;;;4846           }
;;;4847           else
;;;4848           {
;;;4849             /* Do nothing */
;;;4850           }
;;;4851         }
;;;4852       }
;;;4853       /* I2C in mode Receiver --------------------------------------------------*/
;;;4854       else
;;;4855       {
;;;4856         /* Do not check buffer and BTF flag if a Xfer DMA is on going */
;;;4857         if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
;;;4858         {
;;;4859           /* RXNE set and BTF reset -----------------------------------------------*/
;;;4860           if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4861           {
;;;4862             I2C_MasterReceive_RXNE(hi2c);
;;;4863           }
;;;4864           /* BTF set -------------------------------------------------------------*/
;;;4865           else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4866           {
;;;4867             I2C_MasterReceive_BTF(hi2c);
;;;4868           }
;;;4869           else
;;;4870           {
;;;4871             /* Do nothing */
;;;4872           }
;;;4873         }
;;;4874       }
;;;4875     }
;;;4876     /* Slave mode selected */
;;;4877     else
;;;4878     {
;;;4879       /* If an error is detected, read only SR1 register to prevent */
;;;4880       /* a clear of ADDR flags by reading SR2 after reading SR1 in Error treatment */
;;;4881       if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
;;;4882       {
;;;4883         sr1itflags   = READ_REG(hi2c->Instance->SR1);
;;;4884       }
;;;4885       else
;;;4886       {
;;;4887         sr2itflags   = READ_REG(hi2c->Instance->SR2);
;;;4888         sr1itflags   = READ_REG(hi2c->Instance->SR1);
;;;4889       }
;;;4890   
;;;4891       /* ADDR set --------------------------------------------------------------*/
;;;4892       if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4893       {
;;;4894         /* Now time to read SR2, this will clear ADDR flag automatically */
;;;4895         if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
;;;4896         {
;;;4897           sr2itflags   = READ_REG(hi2c->Instance->SR2);
;;;4898         }
;;;4899         I2C_Slave_ADDR(hi2c, sr2itflags);
;;;4900       }
;;;4901       /* STOPF set --------------------------------------------------------------*/
;;;4902       else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4903       {
;;;4904         I2C_Slave_STOPF(hi2c);
;;;4905       }
;;;4906       /* I2C in mode Transmitter -----------------------------------------------*/
;;;4907       else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
;;;4908       {
;;;4909         /* TXE set and BTF reset -----------------------------------------------*/
;;;4910         if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4911         {
;;;4912           I2C_SlaveTransmit_TXE(hi2c);
;;;4913         }
;;;4914         /* BTF set -------------------------------------------------------------*/
;;;4915         else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4916         {
;;;4917           I2C_SlaveTransmit_BTF(hi2c);
;;;4918         }
;;;4919         else
;;;4920         {
;;;4921           /* Do nothing */
;;;4922         }
;;;4923       }
;;;4924       /* I2C in mode Receiver --------------------------------------------------*/
;;;4925       else
;;;4926       {
;;;4927         /* RXNE set and BTF reset ----------------------------------------------*/
;;;4928         if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4929         {
;;;4930           I2C_SlaveReceive_RXNE(hi2c);
;;;4931         }
;;;4932         /* BTF set -------------------------------------------------------------*/
;;;4933         else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4934         {
;;;4935           I2C_SlaveReceive_BTF(hi2c);
;;;4936         }
;;;4937         else
;;;4938         {
;;;4939           /* Do nothing */
;;;4940         }
;;;4941       }
;;;4942     }
;;;4943   }
000048  e8bd87f0          POP      {r4-r10,pc}
                  |L6.76|
00004c  f0040001          AND      r0,r4,#1              ;4804
000050  b148              CBZ      r0,|L6.102|
000052  f3c62040          UBFX     r0,r6,#9,#1           ;4804
000056  b130              CBZ      r0,|L6.102|
000058  4628              MOV      r0,r5                 ;4807
00005a  f7fffffe          BL       I2C_ConvertOtherXferOptions
00005e  4628              MOV      r0,r5                 ;4809
000060  f7fffffe          BL       I2C_Master_SB
                  |L6.100|
000064  e0b7              B        |L6.470|
                  |L6.102|
000066  f3c400c0          UBFX     r0,r4,#3,#1           ;4812
00006a  b130              CBZ      r0,|L6.122|
00006c  f3c62040          UBFX     r0,r6,#9,#1           ;4812
000070  b118              CBZ      r0,|L6.122|
000072  4628              MOV      r0,r5                 ;4814
000074  f7fffffe          BL       I2C_Master_ADD10
000078  e0ad              B        |L6.470|
                  |L6.122|
00007a  f3c40040          UBFX     r0,r4,#1,#1           ;4817
00007e  b130              CBZ      r0,|L6.142|
000080  f3c62040          UBFX     r0,r6,#9,#1           ;4817
000084  b118              CBZ      r0,|L6.142|
000086  4628              MOV      r0,r5                 ;4819
000088  f7fffffe          BL       I2C_Master_ADDR
00008c  e0a3              B        |L6.470|
                  |L6.142|
00008e  f3c90080          UBFX     r0,r9,#2,#1           ;4822
000092  b340              CBZ      r0,|L6.230|
000094  6828              LDR      r0,[r5,#0]            ;4825
000096  6840              LDR      r0,[r0,#4]            ;4825
000098  f4006000          AND      r0,r0,#0x800          ;4825
00009c  f5b06f00          CMP      r0,#0x800             ;4825
0000a0  d0e0              BEQ      |L6.100|
0000a2  f3c410c0          UBFX     r0,r4,#7,#1           ;4828
0000a6  b148              CBZ      r0,|L6.188|
0000a8  f3c62080          UBFX     r0,r6,#10,#1          ;4828
0000ac  b130              CBZ      r0,|L6.188|
0000ae  f3c40080          UBFX     r0,r4,#2,#1           ;4828
0000b2  b918              CBNZ     r0,|L6.188|
0000b4  4628              MOV      r0,r5                 ;4830
0000b6  f7fffffe          BL       I2C_MasterTransmit_TXE
0000ba  e08c              B        |L6.470|
                  |L6.188|
0000bc  f3c40080          UBFX     r0,r4,#2,#1           ;4833
0000c0  2800              CMP      r0,#0                 ;4833
0000c2  d0cf              BEQ      |L6.100|
0000c4  f3c62040          UBFX     r0,r6,#9,#1           ;4833
0000c8  2800              CMP      r0,#0                 ;4833
0000ca  d0cb              BEQ      |L6.100|
0000cc  f1b80f21          CMP      r8,#0x21              ;4835
0000d0  d103              BNE      |L6.218|
0000d2  4628              MOV      r0,r5                 ;4837
0000d4  f7fffffe          BL       I2C_MasterTransmit_BTF
0000d8  e07d              B        |L6.470|
                  |L6.218|
0000da  2f40              CMP      r7,#0x40              ;4841
0000dc  d17b              BNE      |L6.470|
0000de  4628              MOV      r0,r5                 ;4843
0000e0  f7fffffe          BL       I2C_MemoryTransmit_TXE_BTF
0000e4  e077              B        |L6.470|
                  |L6.230|
0000e6  6828              LDR      r0,[r5,#0]            ;4857
0000e8  6840              LDR      r0,[r0,#4]            ;4857
0000ea  f4006000          AND      r0,r0,#0x800          ;4857
0000ee  f5b06f00          CMP      r0,#0x800             ;4857
0000f2  d070              BEQ      |L6.470|
0000f4  f3c41080          UBFX     r0,r4,#6,#1           ;4860
0000f8  b150              CBZ      r0,|L6.272|
0000fa  f3c62080          UBFX     r0,r6,#10,#1          ;4860
0000fe  b138              CBZ      r0,|L6.272|
000100  f3c40080          UBFX     r0,r4,#2,#1           ;4860
000104  b920              CBNZ     r0,|L6.272|
000106  4628              MOV      r0,r5                 ;4862
000108  f7fffffe          BL       I2C_MasterReceive_RXNE
00010c  e063              B        |L6.470|
                  |L6.270|
00010e  e00b              B        |L6.296|
                  |L6.272|
000110  f3c40080          UBFX     r0,r4,#2,#1           ;4865
000114  2800              CMP      r0,#0                 ;4865
000116  d05e              BEQ      |L6.470|
000118  f3c62040          UBFX     r0,r6,#9,#1           ;4865
00011c  2800              CMP      r0,#0                 ;4865
00011e  d05a              BEQ      |L6.470|
000120  4628              MOV      r0,r5                 ;4867
000122  f7fffffe          BL       I2C_MasterReceive_BTF
000126  e056              B        |L6.470|
                  |L6.296|
000128  6c28              LDR      r0,[r5,#0x40]         ;4881
00012a  b110              CBZ      r0,|L6.306|
00012c  6828              LDR      r0,[r5,#0]            ;4883
00012e  6944              LDR      r4,[r0,#0x14]         ;4883
000130  e004              B        |L6.316|
                  |L6.306|
000132  6828              LDR      r0,[r5,#0]            ;4887
000134  f8d09018          LDR      r9,[r0,#0x18]         ;4887
000138  6828              LDR      r0,[r5,#0]            ;4888
00013a  6944              LDR      r4,[r0,#0x14]         ;4888
                  |L6.316|
00013c  f3c40040          UBFX     r0,r4,#1,#1           ;4892
000140  b160              CBZ      r0,|L6.348|
000142  f3c62040          UBFX     r0,r6,#9,#1           ;4892
000146  b148              CBZ      r0,|L6.348|
000148  6c28              LDR      r0,[r5,#0x40]         ;4895
00014a  b110              CBZ      r0,|L6.338|
00014c  6828              LDR      r0,[r5,#0]            ;4897
00014e  f8d09018          LDR      r9,[r0,#0x18]         ;4897
                  |L6.338|
000152  4649              MOV      r1,r9                 ;4899
000154  4628              MOV      r0,r5                 ;4899
000156  f7fffffe          BL       I2C_Slave_ADDR
00015a  e03c              B        |L6.470|
                  |L6.348|
00015c  f3c41000          UBFX     r0,r4,#4,#1           ;4902
000160  b130              CBZ      r0,|L6.368|
000162  f3c62040          UBFX     r0,r6,#9,#1           ;4902
000166  b118              CBZ      r0,|L6.368|
000168  4628              MOV      r0,r5                 ;4904
00016a  f7fffffe          BL       I2C_Slave_STOPF
00016e  e032              B        |L6.470|
                  |L6.368|
000170  f1b80f21          CMP      r8,#0x21              ;4907
000174  d002              BEQ      |L6.380|
000176  f1b80f29          CMP      r8,#0x29              ;4907
00017a  d116              BNE      |L6.426|
                  |L6.380|
00017c  f3c410c0          UBFX     r0,r4,#7,#1           ;4910
000180  b148              CBZ      r0,|L6.406|
000182  f3c62080          UBFX     r0,r6,#10,#1          ;4910
000186  b130              CBZ      r0,|L6.406|
000188  f3c40080          UBFX     r0,r4,#2,#1           ;4910
00018c  b918              CBNZ     r0,|L6.406|
00018e  4628              MOV      r0,r5                 ;4912
000190  f7fffffe          BL       I2C_SlaveTransmit_TXE
000194  e01f              B        |L6.470|
                  |L6.406|
000196  f3c40080          UBFX     r0,r4,#2,#1           ;4915
00019a  b1e0              CBZ      r0,|L6.470|
00019c  f3c62040          UBFX     r0,r6,#9,#1           ;4915
0001a0  b1c8              CBZ      r0,|L6.470|
0001a2  4628              MOV      r0,r5                 ;4917
0001a4  f7fffffe          BL       I2C_SlaveTransmit_BTF
0001a8  e015              B        |L6.470|
                  |L6.426|
0001aa  f3c41080          UBFX     r0,r4,#6,#1           ;4928
0001ae  b148              CBZ      r0,|L6.452|
0001b0  f3c62080          UBFX     r0,r6,#10,#1          ;4928
0001b4  b130              CBZ      r0,|L6.452|
0001b6  f3c40080          UBFX     r0,r4,#2,#1           ;4928
0001ba  b918              CBNZ     r0,|L6.452|
0001bc  4628              MOV      r0,r5                 ;4930
0001be  f7fffffe          BL       I2C_SlaveReceive_RXNE
0001c2  e008              B        |L6.470|
                  |L6.452|
0001c4  f3c40080          UBFX     r0,r4,#2,#1           ;4933
0001c8  b128              CBZ      r0,|L6.470|
0001ca  f3c62040          UBFX     r0,r6,#9,#1           ;4933
0001ce  b110              CBZ      r0,|L6.470|
0001d0  4628              MOV      r0,r5                 ;4935
0001d2  f7fffffe          BL       I2C_SlaveReceive_BTF
                  |L6.470|
0001d6  bf00              NOP      
0001d8  e736              B        |L6.72|
;;;4944   
                          ENDP


                          AREA ||i.HAL_I2C_EnableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EnableListen_IT PROC
;;;4654     */
;;;4655   HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;4656   {
;;;4657     if (hi2c->State == HAL_I2C_STATE_READY)
000002  f891003d          LDRB     r0,[r1,#0x3d]
000006  2820              CMP      r0,#0x20
000008  d11b              BNE      |L7.66|
;;;4658     {
;;;4659       hi2c->State = HAL_I2C_STATE_LISTEN;
00000a  2028              MOVS     r0,#0x28
00000c  f881003d          STRB     r0,[r1,#0x3d]
;;;4660   
;;;4661       /* Check if the I2C is already enabled */
;;;4662       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
000010  6808              LDR      r0,[r1,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0000001          AND      r0,r0,#1
000018  b928              CBNZ     r0,|L7.38|
;;;4663       {
;;;4664         /* Enable I2C peripheral */
;;;4665         __HAL_I2C_ENABLE(hi2c);
00001a  6808              LDR      r0,[r1,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400001          ORR      r0,r0,#1
000022  680a              LDR      r2,[r1,#0]
000024  6010              STR      r0,[r2,#0]
                  |L7.38|
;;;4666       }
;;;4667   
;;;4668       /* Enable Address Acknowledge */
;;;4669       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4406080          ORR      r0,r0,#0x400
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
;;;4670   
;;;4671       /* Enable EVT and ERR interrupt */
;;;4672       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000032  6808              LDR      r0,[r1,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f4407040          ORR      r0,r0,#0x300
00003a  680a              LDR      r2,[r1,#0]
00003c  6050              STR      r0,[r2,#4]
;;;4673   
;;;4674       return HAL_OK;
00003e  2000              MOVS     r0,#0
                  |L7.64|
;;;4675     }
;;;4676     else
;;;4677     {
;;;4678       return HAL_BUSY;
;;;4679     }
;;;4680   }
000040  4770              BX       lr
                  |L7.66|
000042  2002              MOVS     r0,#2                 ;4678
000044  e7fc              B        |L7.64|
;;;4681   
                          ENDP


                          AREA ||i.HAL_I2C_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ErrorCallback PROC
;;;5161     */
;;;5162   __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5163   {
;;;5164     /* Prevent unused argument(s) compilation warning */
;;;5165     UNUSED(hi2c);
;;;5166   
;;;5167     /* NOTE : This function should not be modified, when the callback is needed,
;;;5168               the HAL_I2C_ErrorCallback could be implemented in the user file
;;;5169      */
;;;5170   }
;;;5171   
                          ENDP


                          AREA ||i.HAL_I2C_GetError||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetError PROC
;;;5235     */
;;;5236   uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;5237   {
;;;5238     return hi2c->ErrorCode;
000002  6c08              LDR      r0,[r1,#0x40]
;;;5239   }
000004  4770              BX       lr
;;;5240   
                          ENDP


                          AREA ||i.HAL_I2C_GetMode||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetMode PROC
;;;5224     */
;;;5225   HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;5226   {
;;;5227     return hi2c->Mode;
000002  f891003e          LDRB     r0,[r1,#0x3e]
;;;5228   }
000006  4770              BX       lr
;;;5229   
                          ENDP


                          AREA ||i.HAL_I2C_GetState||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetState PROC
;;;5212     */
;;;5213   HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;5214   {
;;;5215     /* Return I2C handle state */
;;;5216     return hi2c->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;5217   }
000006  4770              BX       lr
;;;5218   
                          ENDP


                          AREA ||i.HAL_I2C_Init||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Init PROC
;;;434      */
;;;435    HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;436    {
000002  4604              MOV      r4,r0
;;;437      uint32_t freqrange;
;;;438      uint32_t pclk1;
;;;439    
;;;440      /* Check the I2C handle allocation */
;;;441      if (hi2c == NULL)
000004  b90c              CBNZ     r4,|L12.10|
;;;442      {
;;;443        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L12.8|
;;;444      }
;;;445    
;;;446      /* Check the parameters */
;;;447      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;448      assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
;;;449      assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
;;;450      assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
;;;451      assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
;;;452      assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
;;;453      assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
;;;454      assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
;;;455      assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
;;;456    
;;;457      if (hi2c->State == HAL_I2C_STATE_RESET)
;;;458      {
;;;459        /* Allocate lock resource and initialize it */
;;;460        hi2c->Lock = HAL_UNLOCKED;
;;;461    
;;;462    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;463        /* Init the I2C Callback settings */
;;;464        hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
;;;465        hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
;;;466        hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */
;;;467        hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */
;;;468        hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */
;;;469        hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */
;;;470        hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */
;;;471        hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */
;;;472        hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
;;;473        hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */
;;;474    
;;;475        if (hi2c->MspInitCallback == NULL)
;;;476        {
;;;477          hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */
;;;478        }
;;;479    
;;;480        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;481        hi2c->MspInitCallback(hi2c);
;;;482    #else
;;;483        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;484        HAL_I2C_MspInit(hi2c);
;;;485    #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;486      }
;;;487    
;;;488      hi2c->State = HAL_I2C_STATE_BUSY;
;;;489    
;;;490      /* Disable the selected I2C peripheral */
;;;491      __HAL_I2C_DISABLE(hi2c);
;;;492    
;;;493      /*Reset I2C*/
;;;494      hi2c->Instance->CR1 |= I2C_CR1_SWRST;
;;;495      hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
;;;496    
;;;497      /* Get PCLK1 frequency */
;;;498      pclk1 = HAL_RCC_GetPCLK1Freq();
;;;499    
;;;500      /* Check the minimum allowed PCLK1 frequency */
;;;501      if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
;;;502      {
;;;503        return HAL_ERROR;
;;;504      }
;;;505    
;;;506      /* Calculate frequency range */
;;;507      freqrange = I2C_FREQRANGE(pclk1);
;;;508    
;;;509      /*---------------------------- I2Cx CR2 Configuration ----------------------*/
;;;510      /* Configure I2Cx: Frequency range */
;;;511      MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
;;;512    
;;;513      /*---------------------------- I2Cx TRISE Configuration --------------------*/
;;;514      /* Configure I2Cx: Rise Time */
;;;515      MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
;;;516    
;;;517      /*---------------------------- I2Cx CCR Configuration ----------------------*/
;;;518      /* Configure I2Cx: Speed */
;;;519      MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
;;;520    
;;;521      /*---------------------------- I2Cx CR1 Configuration ----------------------*/
;;;522      /* Configure I2Cx: Generalcall and NoStretch mode */
;;;523      MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
;;;524    
;;;525      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;526      /* Configure I2Cx: Own Address1 and addressing mode */
;;;527      MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
;;;528    
;;;529      /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
;;;530      /* Configure I2Cx: Dual mode and Own Address2 */
;;;531      MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
;;;532    
;;;533      /* Enable the selected I2C peripheral */
;;;534      __HAL_I2C_ENABLE(hi2c);
;;;535    
;;;536      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;537      hi2c->State = HAL_I2C_STATE_READY;
;;;538      hi2c->PreviousState = I2C_STATE_NONE;
;;;539      hi2c->Mode = HAL_I2C_MODE_NONE;
;;;540    
;;;541      return HAL_OK;
;;;542    }
000008  bd70              POP      {r4-r6,pc}
                  |L12.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;457
00000e  b928              CBNZ     r0,|L12.28|
000010  2000              MOVS     r0,#0                 ;460
000012  f884003c          STRB     r0,[r4,#0x3c]         ;460
000016  4620              MOV      r0,r4                 ;484
000018  f7fffffe          BL       HAL_I2C_MspInit
                  |L12.28|
00001c  2024              MOVS     r0,#0x24              ;488
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;488
000022  6820              LDR      r0,[r4,#0]            ;491
000024  6800              LDR      r0,[r0,#0]            ;491
000026  f0200001          BIC      r0,r0,#1              ;491
00002a  6821              LDR      r1,[r4,#0]            ;491
00002c  6008              STR      r0,[r1,#0]            ;491
00002e  6820              LDR      r0,[r4,#0]            ;494
000030  6800              LDR      r0,[r0,#0]            ;494
000032  f4404000          ORR      r0,r0,#0x8000         ;494
000036  6821              LDR      r1,[r4,#0]            ;494
000038  6008              STR      r0,[r1,#0]            ;494
00003a  6820              LDR      r0,[r4,#0]            ;495
00003c  6800              LDR      r0,[r0,#0]            ;495
00003e  f4204000          BIC      r0,r0,#0x8000         ;495
000042  6821              LDR      r1,[r4,#0]            ;495
000044  6008              STR      r0,[r1,#0]            ;495
000046  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00004a  4605              MOV      r5,r0                 ;498
00004c  495c              LDR      r1,|L12.448|
00004e  6860              LDR      r0,[r4,#4]            ;501
000050  4288              CMP      r0,r1                 ;501
000052  d806              BHI      |L12.98|
000054  485b              LDR      r0,|L12.452|
000056  4285              CMP      r5,r0                 ;501
000058  d201              BCS      |L12.94|
00005a  2001              MOVS     r0,#1                 ;501
00005c  e007              B        |L12.110|
                  |L12.94|
00005e  2000              MOVS     r0,#0                 ;501
000060  e005              B        |L12.110|
                  |L12.98|
000062  4859              LDR      r0,|L12.456|
000064  4285              CMP      r5,r0                 ;501
000066  d201              BCS      |L12.108|
000068  2001              MOVS     r0,#1                 ;501
00006a  e000              B        |L12.110|
                  |L12.108|
00006c  2000              MOVS     r0,#0                 ;501
                  |L12.110|
00006e  2801              CMP      r0,#1                 ;501
000070  d100              BNE      |L12.116|
000072  e7c9              B        |L12.8|
                  |L12.116|
000074  4855              LDR      r0,|L12.460|
000076  fbb5f6f0          UDIV     r6,r5,r0              ;507
00007a  6820              LDR      r0,[r4,#0]            ;511
00007c  6840              LDR      r0,[r0,#4]            ;511
00007e  f020003f          BIC      r0,r0,#0x3f           ;511
000082  4330              ORRS     r0,r0,r6              ;511
000084  6821              LDR      r1,[r4,#0]            ;511
000086  6048              STR      r0,[r1,#4]            ;511
000088  494d              LDR      r1,|L12.448|
00008a  6860              LDR      r0,[r4,#4]            ;515
00008c  4288              CMP      r0,r1                 ;515
00008e  d801              BHI      |L12.148|
000090  1c70              ADDS     r0,r6,#1              ;515
000092  e007              B        |L12.164|
                  |L12.148|
000094  f44f7096          MOV      r0,#0x12c             ;515
000098  4370              MULS     r0,r6,r0              ;515
00009a  f44f717a          MOV      r1,#0x3e8             ;515
00009e  fbb0f0f1          UDIV     r0,r0,r1              ;515
0000a2  1c40              ADDS     r0,r0,#1              ;515
                  |L12.164|
0000a4  6821              LDR      r1,[r4,#0]            ;515
0000a6  6a09              LDR      r1,[r1,#0x20]         ;515
0000a8  f021013f          BIC      r1,r1,#0x3f           ;515
0000ac  4308              ORRS     r0,r0,r1              ;515
0000ae  6821              LDR      r1,[r4,#0]            ;515
0000b0  6208              STR      r0,[r1,#0x20]         ;515
0000b2  4943              LDR      r1,|L12.448|
0000b4  6860              LDR      r0,[r4,#4]            ;519
0000b6  4288              CMP      r0,r1                 ;519
0000b8  d814              BHI      |L12.228|
0000ba  1e68              SUBS     r0,r5,#1              ;519
0000bc  6861              LDR      r1,[r4,#4]            ;519
0000be  0049              LSLS     r1,r1,#1              ;519
0000c0  fbb0f0f1          UDIV     r0,r0,r1              ;519
0000c4  1c40              ADDS     r0,r0,#1              ;519
0000c6  f3c0000b          UBFX     r0,r0,#0,#12          ;519
0000ca  2804              CMP      r0,#4                 ;519
0000cc  d201              BCS      |L12.210|
0000ce  2004              MOVS     r0,#4                 ;519
0000d0  e03d              B        |L12.334|
                  |L12.210|
0000d2  1e68              SUBS     r0,r5,#1              ;519
0000d4  6861              LDR      r1,[r4,#4]            ;519
0000d6  0049              LSLS     r1,r1,#1              ;519
0000d8  fbb0f0f1          UDIV     r0,r0,r1              ;519
0000dc  1c40              ADDS     r0,r0,#1              ;519
0000de  f3c0000b          UBFX     r0,r0,#0,#12          ;519
0000e2  e034              B        |L12.334|
                  |L12.228|
0000e4  68a0              LDR      r0,[r4,#8]            ;519
0000e6  b938              CBNZ     r0,|L12.248|
0000e8  1e68              SUBS     r0,r5,#1              ;519
0000ea  6861              LDR      r1,[r4,#4]            ;519
0000ec  eb010141          ADD      r1,r1,r1,LSL #1       ;519
0000f0  fbb0f0f1          UDIV     r0,r0,r1              ;519
0000f4  1c40              ADDS     r0,r0,#1              ;519
0000f6  e00a              B        |L12.270|
                  |L12.248|
0000f8  1e68              SUBS     r0,r5,#1              ;519
0000fa  6861              LDR      r1,[r4,#4]            ;519
0000fc  eb0102c1          ADD      r2,r1,r1,LSL #3       ;519
000100  eb021101          ADD      r1,r2,r1,LSL #4       ;519
000104  fbb0f0f1          UDIV     r0,r0,r1              ;519
000108  1c40              ADDS     r0,r0,#1              ;519
00010a  f4404080          ORR      r0,r0,#0x4000         ;519
                  |L12.270|
00010e  f3c0000b          UBFX     r0,r0,#0,#12          ;519
000112  b908              CBNZ     r0,|L12.280|
000114  2001              MOVS     r0,#1                 ;519
000116  e01a              B        |L12.334|
                  |L12.280|
000118  68a0              LDR      r0,[r4,#8]            ;519
00011a  b948              CBNZ     r0,|L12.304|
00011c  1e68              SUBS     r0,r5,#1              ;519
00011e  6861              LDR      r1,[r4,#4]            ;519
000120  eb010141          ADD      r1,r1,r1,LSL #1       ;519
000124  fbb0f0f1          UDIV     r0,r0,r1              ;519
000128  1c40              ADDS     r0,r0,#1              ;519
00012a  f3c0000b          UBFX     r0,r0,#0,#12          ;519
00012e  e00c              B        |L12.330|
                  |L12.304|
000130  1e68              SUBS     r0,r5,#1              ;519
000132  6861              LDR      r1,[r4,#4]            ;519
000134  eb0102c1          ADD      r2,r1,r1,LSL #3       ;519
000138  eb021101          ADD      r1,r2,r1,LSL #4       ;519
00013c  fbb0f0f1          UDIV     r0,r0,r1              ;519
000140  1c40              ADDS     r0,r0,#1              ;519
000142  f3c0000b          UBFX     r0,r0,#0,#12          ;519
000146  f4404080          ORR      r0,r0,#0x4000         ;519
                  |L12.330|
00014a  f4404000          ORR      r0,r0,#0x8000         ;519
                  |L12.334|
00014e  6821              LDR      r1,[r4,#0]            ;519
000150  69c9              LDR      r1,[r1,#0x1c]         ;519
000152  f64c72ff          MOV      r2,#0xcfff            ;519
000156  4391              BICS     r1,r1,r2              ;519
000158  4308              ORRS     r0,r0,r1              ;519
00015a  6821              LDR      r1,[r4,#0]            ;519
00015c  61c8              STR      r0,[r1,#0x1c]         ;519
00015e  e9d40107          LDRD     r0,r1,[r4,#0x1c]      ;523
000162  4308              ORRS     r0,r0,r1              ;523
000164  6821              LDR      r1,[r4,#0]            ;523
000166  6809              LDR      r1,[r1,#0]            ;523
000168  f02101c0          BIC      r1,r1,#0xc0           ;523
00016c  4308              ORRS     r0,r0,r1              ;523
00016e  6821              LDR      r1,[r4,#0]            ;523
000170  6008              STR      r0,[r1,#0]            ;523
000172  e9d41003          LDRD     r1,r0,[r4,#0xc]       ;527
000176  4308              ORRS     r0,r0,r1              ;527
000178  6821              LDR      r1,[r4,#0]            ;527
00017a  6889              LDR      r1,[r1,#8]            ;527
00017c  f24832ff          MOV      r2,#0x83ff            ;527
000180  4391              BICS     r1,r1,r2              ;527
000182  4308              ORRS     r0,r0,r1              ;527
000184  6821              LDR      r1,[r4,#0]            ;527
000186  6088              STR      r0,[r1,#8]            ;527
000188  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;531
00018c  4308              ORRS     r0,r0,r1              ;531
00018e  6821              LDR      r1,[r4,#0]            ;531
000190  68c9              LDR      r1,[r1,#0xc]          ;531
000192  f02101ff          BIC      r1,r1,#0xff           ;531
000196  4308              ORRS     r0,r0,r1              ;531
000198  6821              LDR      r1,[r4,#0]            ;531
00019a  60c8              STR      r0,[r1,#0xc]          ;531
00019c  6820              LDR      r0,[r4,#0]            ;534
00019e  6800              LDR      r0,[r0,#0]            ;534
0001a0  f0400001          ORR      r0,r0,#1              ;534
0001a4  6821              LDR      r1,[r4,#0]            ;534
0001a6  6008              STR      r0,[r1,#0]            ;534
0001a8  2000              MOVS     r0,#0                 ;536
0001aa  6420              STR      r0,[r4,#0x40]         ;536
0001ac  2020              MOVS     r0,#0x20              ;537
0001ae  f884003d          STRB     r0,[r4,#0x3d]         ;537
0001b2  2000              MOVS     r0,#0                 ;538
0001b4  6320              STR      r0,[r4,#0x30]         ;538
0001b6  f884003e          STRB     r0,[r4,#0x3e]         ;539
0001ba  bf00              NOP                            ;541
0001bc  e724              B        |L12.8|
;;;543    
                          ENDP

0001be  0000              DCW      0x0000
                  |L12.448|
                          DCD      0x000186a0
                  |L12.452|
                          DCD      0x001e8480
                  |L12.456|
                          DCD      0x003d0900
                  |L12.460|
                          DCD      0x000f4240

                          AREA ||i.HAL_I2C_IsDeviceReady||, CODE, READONLY, ALIGN=2

                  HAL_I2C_IsDeviceReady PROC
;;;3419     */
;;;3420   HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3421   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;3422     /* Get tick */
;;;3423     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;3424     uint32_t I2C_Trials = 1U;
000012  f04f0901          MOV      r9,#1
;;;3425     FlagStatus tmp1;
;;;3426     FlagStatus tmp2;
;;;3427   
;;;3428     if (hi2c->State == HAL_I2C_STATE_READY)
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2820              CMP      r0,#0x20
00001c  d17e              BNE      |L13.284|
;;;3429     {
;;;3430       /* Wait until BUSY flag is reset */
;;;3431       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
00001e  2319              MOVS     r3,#0x19
000020  2201              MOVS     r2,#1
000022  4963              LDR      r1,|L13.432|
000024  4620              MOV      r0,r4
000026  9500              STR      r5,[sp,#0]
000028  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002c  b110              CBZ      r0,|L13.52|
;;;3432       {
;;;3433         return HAL_BUSY;
00002e  2002              MOVS     r0,#2
                  |L13.48|
;;;3434       }
;;;3435   
;;;3436       /* Process Locked */
;;;3437       __HAL_LOCK(hi2c);
;;;3438   
;;;3439       /* Check if the I2C is already enabled */
;;;3440       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3441       {
;;;3442         /* Enable I2C peripheral */
;;;3443         __HAL_I2C_ENABLE(hi2c);
;;;3444       }
;;;3445   
;;;3446       /* Disable Pos */
;;;3447       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3448   
;;;3449       hi2c->State = HAL_I2C_STATE_BUSY;
;;;3450       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3451       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3452   
;;;3453       do
;;;3454       {
;;;3455         /* Generate Start */
;;;3456         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3457   
;;;3458         /* Wait until SB flag is set */
;;;3459         if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, tickstart) != HAL_OK)
;;;3460         {
;;;3461           if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
;;;3462           {
;;;3463             hi2c->ErrorCode = HAL_I2C_WRONG_START;
;;;3464           }
;;;3465           return HAL_TIMEOUT;
;;;3466         }
;;;3467   
;;;3468         /* Send slave address */
;;;3469         hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;3470   
;;;3471         /* Wait until ADDR or AF flag are set */
;;;3472         /* Get tick */
;;;3473         tickstart = HAL_GetTick();
;;;3474   
;;;3475         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3476         tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3477         while ((hi2c->State != HAL_I2C_STATE_TIMEOUT) && (tmp1 == RESET) && (tmp2 == RESET))
;;;3478         {
;;;3479           if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;3480           {
;;;3481             hi2c->State = HAL_I2C_STATE_TIMEOUT;
;;;3482           }
;;;3483           tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3484           tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3485         }
;;;3486   
;;;3487         hi2c->State = HAL_I2C_STATE_READY;
;;;3488   
;;;3489         /* Check if the ADDR flag has been set */
;;;3490         if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
;;;3491         {
;;;3492           /* Generate Stop */
;;;3493           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3494   
;;;3495           /* Clear ADDR Flag */
;;;3496           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3497   
;;;3498           /* Wait until BUSY flag is reset */
;;;3499           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;3500           {
;;;3501             return HAL_ERROR;
;;;3502           }
;;;3503   
;;;3504           hi2c->State = HAL_I2C_STATE_READY;
;;;3505   
;;;3506           /* Process Unlocked */
;;;3507           __HAL_UNLOCK(hi2c);
;;;3508   
;;;3509           return HAL_OK;
;;;3510         }
;;;3511         else
;;;3512         {
;;;3513           /* Generate Stop */
;;;3514           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3515   
;;;3516           /* Clear AF Flag */
;;;3517           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3518   
;;;3519           /* Wait until BUSY flag is reset */
;;;3520           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;3521           {
;;;3522             return HAL_ERROR;
;;;3523           }
;;;3524         }
;;;3525   
;;;3526         /* Increment Trials */
;;;3527         I2C_Trials++;
;;;3528       }
;;;3529       while (I2C_Trials < Trials);
;;;3530   
;;;3531       hi2c->State = HAL_I2C_STATE_READY;
;;;3532   
;;;3533       /* Process Unlocked */
;;;3534       __HAL_UNLOCK(hi2c);
;;;3535   
;;;3536       return HAL_ERROR;
;;;3537     }
;;;3538     else
;;;3539     {
;;;3540       return HAL_BUSY;
;;;3541     }
;;;3542   }
000030  e8bd8ff8          POP      {r3-r11,pc}
                  |L13.52|
000034  bf00              NOP                            ;3437
000036  f894003c          LDRB     r0,[r4,#0x3c]         ;3437
00003a  2801              CMP      r0,#1                 ;3437
00003c  d101              BNE      |L13.66|
00003e  2002              MOVS     r0,#2                 ;3437
000040  e7f6              B        |L13.48|
                  |L13.66|
000042  2001              MOVS     r0,#1                 ;3437
000044  f884003c          STRB     r0,[r4,#0x3c]         ;3437
000048  bf00              NOP                            ;3437
00004a  6820              LDR      r0,[r4,#0]            ;3440
00004c  6800              LDR      r0,[r0,#0]            ;3440
00004e  f0000001          AND      r0,r0,#1              ;3440
000052  b928              CBNZ     r0,|L13.96|
000054  6820              LDR      r0,[r4,#0]            ;3443
000056  6800              LDR      r0,[r0,#0]            ;3443
000058  f0400001          ORR      r0,r0,#1              ;3443
00005c  6821              LDR      r1,[r4,#0]            ;3443
00005e  6008              STR      r0,[r1,#0]            ;3443
                  |L13.96|
000060  6820              LDR      r0,[r4,#0]            ;3447
000062  6800              LDR      r0,[r0,#0]            ;3447
000064  f4206000          BIC      r0,r0,#0x800          ;3447
000068  6821              LDR      r1,[r4,#0]            ;3447
00006a  6008              STR      r0,[r1,#0]            ;3447
00006c  2024              MOVS     r0,#0x24              ;3449
00006e  f884003d          STRB     r0,[r4,#0x3d]         ;3449
000072  2000              MOVS     r0,#0                 ;3450
000074  6420              STR      r0,[r4,#0x40]         ;3450
000076  484f              LDR      r0,|L13.436|
000078  62e0              STR      r0,[r4,#0x2c]         ;3451
00007a  bf00              NOP                            ;3453
                  |L13.124|
00007c  6820              LDR      r0,[r4,#0]            ;3456
00007e  6800              LDR      r0,[r0,#0]            ;3456
000080  f4407080          ORR      r0,r0,#0x100          ;3456
000084  6821              LDR      r1,[r4,#0]            ;3456
000086  6008              STR      r0,[r1,#0]            ;3456
000088  4633              MOV      r3,r6                 ;3459
00008a  2200              MOVS     r2,#0                 ;3459
00008c  f04f1101          MOV      r1,#0x10001           ;3459
000090  4620              MOV      r0,r4                 ;3459
000092  9500              STR      r5,[sp,#0]            ;3459
000094  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000098  b158              CBZ      r0,|L13.178|
00009a  6820              LDR      r0,[r4,#0]            ;3461
00009c  6800              LDR      r0,[r0,#0]            ;3461
00009e  f4007080          AND      r0,r0,#0x100          ;3461
0000a2  f5b07f80          CMP      r0,#0x100             ;3461
0000a6  d102              BNE      |L13.174|
0000a8  f44f7000          MOV      r0,#0x200             ;3463
0000ac  6420              STR      r0,[r4,#0x40]         ;3463
                  |L13.174|
0000ae  2003              MOVS     r0,#3                 ;3465
0000b0  e7be              B        |L13.48|
                  |L13.178|
0000b2  f00700fe          AND      r0,r7,#0xfe           ;3469
0000b6  6821              LDR      r1,[r4,#0]            ;3469
0000b8  6108              STR      r0,[r1,#0x10]         ;3469
0000ba  f7fffffe          BL       HAL_GetTick
0000be  4605              MOV      r5,r0                 ;3473
0000c0  6820              LDR      r0,[r4,#0]            ;3475
0000c2  6940              LDR      r0,[r0,#0x14]         ;3475
0000c4  f3c00a40          UBFX     r10,r0,#1,#1          ;3475
0000c8  6820              LDR      r0,[r4,#0]            ;3476
0000ca  6940              LDR      r0,[r0,#0x14]         ;3476
0000cc  f3c02b80          UBFX     r11,r0,#10,#1         ;3476
0000d0  e010              B        |L13.244|
                  |L13.210|
0000d2  f7fffffe          BL       HAL_GetTick
0000d6  1b40              SUBS     r0,r0,r5              ;3479
0000d8  42b0              CMP      r0,r6                 ;3479
0000da  d800              BHI      |L13.222|
0000dc  b916              CBNZ     r6,|L13.228|
                  |L13.222|
0000de  20a0              MOVS     r0,#0xa0              ;3481
0000e0  f884003d          STRB     r0,[r4,#0x3d]         ;3481
                  |L13.228|
0000e4  6820              LDR      r0,[r4,#0]            ;3483
0000e6  6940              LDR      r0,[r0,#0x14]         ;3483
0000e8  f3c00a40          UBFX     r10,r0,#1,#1          ;3483
0000ec  6820              LDR      r0,[r4,#0]            ;3484
0000ee  6940              LDR      r0,[r0,#0x14]         ;3484
0000f0  f3c02b80          UBFX     r11,r0,#10,#1         ;3484
                  |L13.244|
0000f4  f894003d          LDRB     r0,[r4,#0x3d]         ;3477
0000f8  28a0              CMP      r0,#0xa0              ;3477
0000fa  d005              BEQ      |L13.264|
0000fc  f1ba0f00          CMP      r10,#0                ;3477
000100  d102              BNE      |L13.264|
000102  f1bb0f00          CMP      r11,#0                ;3477
000106  d0e4              BEQ      |L13.210|
                  |L13.264|
000108  2020              MOVS     r0,#0x20              ;3487
00010a  f884003d          STRB     r0,[r4,#0x3d]         ;3487
00010e  6820              LDR      r0,[r4,#0]            ;3490
000110  6940              LDR      r0,[r0,#0x14]         ;3490
000112  f3c00040          UBFX     r0,r0,#1,#1           ;3490
000116  b328              CBZ      r0,|L13.356|
000118  6820              LDR      r0,[r4,#0]            ;3493
00011a  e000              B        |L13.286|
                  |L13.284|
00011c  e045              B        |L13.426|
                  |L13.286|
00011e  6800              LDR      r0,[r0,#0]            ;3493
000120  f4407000          ORR      r0,r0,#0x200          ;3493
000124  6821              LDR      r1,[r4,#0]            ;3493
000126  6008              STR      r0,[r1,#0]            ;3493
000128  bf00              NOP                            ;3496
00012a  2000              MOVS     r0,#0                 ;3496
00012c  9000              STR      r0,[sp,#0]            ;3496
00012e  6820              LDR      r0,[r4,#0]            ;3496
000130  6940              LDR      r0,[r0,#0x14]         ;3496
000132  9000              STR      r0,[sp,#0]            ;3496
000134  6820              LDR      r0,[r4,#0]            ;3496
000136  6980              LDR      r0,[r0,#0x18]         ;3496
000138  9000              STR      r0,[sp,#0]            ;3496
00013a  bf00              NOP                            ;3496
00013c  bf00              NOP                            ;3496
00013e  2319              MOVS     r3,#0x19              ;3499
000140  2201              MOVS     r2,#1                 ;3499
000142  491b              LDR      r1,|L13.432|
000144  4620              MOV      r0,r4                 ;3499
000146  9500              STR      r5,[sp,#0]            ;3499
000148  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00014c  b108              CBZ      r0,|L13.338|
00014e  2001              MOVS     r0,#1                 ;3501
000150  e76e              B        |L13.48|
                  |L13.338|
000152  2020              MOVS     r0,#0x20              ;3504
000154  f884003d          STRB     r0,[r4,#0x3d]         ;3504
000158  bf00              NOP                            ;3507
00015a  2000              MOVS     r0,#0                 ;3507
00015c  f884003c          STRB     r0,[r4,#0x3c]         ;3507
000160  bf00              NOP                            ;3507
000162  e765              B        |L13.48|
                  |L13.356|
000164  6820              LDR      r0,[r4,#0]            ;3514
000166  6800              LDR      r0,[r0,#0]            ;3514
000168  f4407000          ORR      r0,r0,#0x200          ;3514
00016c  6821              LDR      r1,[r4,#0]            ;3514
00016e  6008              STR      r0,[r1,#0]            ;3514
000170  f46f6080          MVN      r0,#0x400             ;3517
000174  6821              LDR      r1,[r4,#0]            ;3517
000176  6148              STR      r0,[r1,#0x14]         ;3517
000178  2319              MOVS     r3,#0x19              ;3520
00017a  2201              MOVS     r2,#1                 ;3520
00017c  490c              LDR      r1,|L13.432|
00017e  4620              MOV      r0,r4                 ;3520
000180  9500              STR      r5,[sp,#0]            ;3520
000182  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000186  b108              CBZ      r0,|L13.396|
000188  2001              MOVS     r0,#1                 ;3522
00018a  e751              B        |L13.48|
                  |L13.396|
00018c  f1090901          ADD      r9,r9,#1              ;3527
000190  45c1              CMP      r9,r8                 ;3529
000192  f4ffaf73          BCC      |L13.124|
000196  2020              MOVS     r0,#0x20              ;3531
000198  f884003d          STRB     r0,[r4,#0x3d]         ;3531
00019c  bf00              NOP                            ;3534
00019e  2000              MOVS     r0,#0                 ;3534
0001a0  f884003c          STRB     r0,[r4,#0x3c]         ;3534
0001a4  bf00              NOP                            ;3534
0001a6  2001              MOVS     r0,#1                 ;3536
0001a8  e742              B        |L13.48|
                  |L13.426|
0001aa  2002              MOVS     r0,#2                 ;3540
0001ac  e740              B        |L13.48|
;;;3543   
                          ENDP

0001ae  0000              DCW      0x0000
                  |L13.432|
                          DCD      0x00100002
                  |L13.436|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_ListenCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ListenCpltCallback PROC
;;;5113     */
;;;5114   __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5115   {
;;;5116     /* Prevent unused argument(s) compilation warning */
;;;5117     UNUSED(hi2c);
;;;5118   
;;;5119     /* NOTE : This function should not be modified, when the callback is needed,
;;;5120               the HAL_I2C_ListenCpltCallback() could be implemented in the user file
;;;5121     */
;;;5122   }
;;;5123   
                          ENDP


                          AREA ||i.HAL_I2C_MasterRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterRxCpltCallback PROC
;;;5046     */
;;;5047   __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5048   {
;;;5049     /* Prevent unused argument(s) compilation warning */
;;;5050     UNUSED(hi2c);
;;;5051   
;;;5052     /* NOTE : This function should not be modified, when the callback is needed,
;;;5053               the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
;;;5054      */
;;;5055   }
;;;5056   
                          ENDP


                          AREA ||i.HAL_I2C_MasterTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterTxCpltCallback PROC
;;;5030     */
;;;5031   __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5032   {
;;;5033     /* Prevent unused argument(s) compilation warning */
;;;5034     UNUSED(hi2c);
;;;5035   
;;;5036     /* NOTE : This function should not be modified, when the callback is needed,
;;;5037               the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
;;;5038      */
;;;5039   }
;;;5040   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Master_Abort_IT PROC
;;;4722     */
;;;4723   HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
000000  b570              PUSH     {r4-r6,lr}
;;;4724   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;4725     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;4726     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
000006  f894503e          LDRB     r5,[r4,#0x3e]
;;;4727   
;;;4728     /* Prevent unused argument(s) compilation warning */
;;;4729     UNUSED(DevAddress);
;;;4730   
;;;4731     /* Abort Master transfer during Receive or Transmit process    */
;;;4732     if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && (CurrentMode == HAL_I2C_MODE_MASTER))
00000a  6820              LDR      r0,[r4,#0]
00000c  6980              LDR      r0,[r0,#0x18]
00000e  f3c00040          UBFX     r0,r0,#1,#1
000012  b378              CBZ      r0,|L17.116|
000014  2d10              CMP      r5,#0x10
000016  d12e              BNE      |L17.118|
;;;4733     {
;;;4734       /* Process Locked */
;;;4735       __HAL_LOCK(hi2c);
000018  bf00              NOP      
00001a  f894003c          LDRB     r0,[r4,#0x3c]
00001e  2801              CMP      r0,#1
000020  d101              BNE      |L17.38|
000022  2002              MOVS     r0,#2
                  |L17.36|
;;;4736   
;;;4737       hi2c->PreviousState = I2C_STATE_NONE;
;;;4738       hi2c->State = HAL_I2C_STATE_ABORT;
;;;4739   
;;;4740       /* Disable Acknowledge */
;;;4741       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4742   
;;;4743       /* Generate Stop */
;;;4744       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;4745   
;;;4746       hi2c->XferCount = 0U;
;;;4747   
;;;4748       /* Disable EVT, BUF and ERR interrupt */
;;;4749       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4750   
;;;4751       /* Process Unlocked */
;;;4752       __HAL_UNLOCK(hi2c);
;;;4753   
;;;4754       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4755       I2C_ITError(hi2c);
;;;4756   
;;;4757       return HAL_OK;
;;;4758     }
;;;4759     else
;;;4760     {
;;;4761       /* Wrong usage of abort function */
;;;4762       /* This function should be used only in case of abort monitored by master device */
;;;4763       /* Or periphal is not in busy state, mean there is no active sequence to be abort */
;;;4764       return HAL_ERROR;
;;;4765     }
;;;4766   }
000024  bd70              POP      {r4-r6,pc}
                  |L17.38|
000026  2001              MOVS     r0,#1                 ;4735
000028  f884003c          STRB     r0,[r4,#0x3c]         ;4735
00002c  bf00              NOP                            ;4735
00002e  2000              MOVS     r0,#0                 ;4737
000030  6320              STR      r0,[r4,#0x30]         ;4737
000032  2060              MOVS     r0,#0x60              ;4738
000034  f884003d          STRB     r0,[r4,#0x3d]         ;4738
000038  6820              LDR      r0,[r4,#0]            ;4741
00003a  6800              LDR      r0,[r0,#0]            ;4741
00003c  f4206080          BIC      r0,r0,#0x400          ;4741
000040  6821              LDR      r1,[r4,#0]            ;4741
000042  6008              STR      r0,[r1,#0]            ;4741
000044  6820              LDR      r0,[r4,#0]            ;4744
000046  6800              LDR      r0,[r0,#0]            ;4744
000048  f4407000          ORR      r0,r0,#0x200          ;4744
00004c  6821              LDR      r1,[r4,#0]            ;4744
00004e  6008              STR      r0,[r1,#0]            ;4744
000050  2000              MOVS     r0,#0                 ;4746
000052  8560              STRH     r0,[r4,#0x2a]         ;4746
000054  6820              LDR      r0,[r4,#0]            ;4749
000056  6840              LDR      r0,[r0,#4]            ;4749
000058  f42060e0          BIC      r0,r0,#0x700          ;4749
00005c  6821              LDR      r1,[r4,#0]            ;4749
00005e  6048              STR      r0,[r1,#4]            ;4749
000060  bf00              NOP                            ;4752
000062  2000              MOVS     r0,#0                 ;4752
000064  f884003c          STRB     r0,[r4,#0x3c]         ;4752
000068  bf00              NOP                            ;4752
00006a  4620              MOV      r0,r4                 ;4755
00006c  f7fffffe          BL       I2C_ITError
000070  2000              MOVS     r0,#0                 ;4757
000072  e7d7              B        |L17.36|
                  |L17.116|
000074  e7ff              B        |L17.118|
                  |L17.118|
000076  2001              MOVS     r0,#1                 ;4764
000078  e7d4              B        |L17.36|
;;;4767   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive PROC
;;;1152     */
;;;1153   HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1154   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e08              LDR      r6,[sp,#0x20]
;;;1155     /* Init tickstart for timeout management*/
;;;1156     uint32_t tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4605              MOV      r5,r0
;;;1157   
;;;1158     if (hi2c->State == HAL_I2C_STATE_READY)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2820              CMP      r0,#0x20
00001a  d17d              BNE      |L18.280|
;;;1159     {
;;;1160       /* Wait until BUSY flag is reset */
;;;1161       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
00001c  2319              MOVS     r3,#0x19
00001e  2201              MOVS     r2,#1
000020  49b2              LDR      r1,|L18.748|
000022  4620              MOV      r0,r4
000024  9500              STR      r5,[sp,#0]
000026  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002a  b110              CBZ      r0,|L18.50|
;;;1162       {
;;;1163         return HAL_BUSY;
00002c  2002              MOVS     r0,#2
                  |L18.46|
;;;1164       }
;;;1165   
;;;1166       /* Process Locked */
;;;1167       __HAL_LOCK(hi2c);
;;;1168   
;;;1169       /* Check if the I2C is already enabled */
;;;1170       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1171       {
;;;1172         /* Enable I2C peripheral */
;;;1173         __HAL_I2C_ENABLE(hi2c);
;;;1174       }
;;;1175   
;;;1176       /* Disable Pos */
;;;1177       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1178   
;;;1179       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1180       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1181       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1182   
;;;1183       /* Prepare transfer parameters */
;;;1184       hi2c->pBuffPtr    = pData;
;;;1185       hi2c->XferCount   = Size;
;;;1186       hi2c->XferSize    = hi2c->XferCount;
;;;1187       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1188   
;;;1189       /* Send Slave Address */
;;;1190       if (I2C_MasterRequestRead(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
;;;1191       {
;;;1192         return HAL_ERROR;
;;;1193       }
;;;1194   
;;;1195       if (hi2c->XferSize == 0U)
;;;1196       {
;;;1197         /* Clear ADDR flag */
;;;1198         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1199   
;;;1200         /* Generate Stop */
;;;1201         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1202       }
;;;1203       else if (hi2c->XferSize == 1U)
;;;1204       {
;;;1205         /* Disable Acknowledge */
;;;1206         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1207   
;;;1208         /* Clear ADDR flag */
;;;1209         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1210   
;;;1211         /* Generate Stop */
;;;1212         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1213       }
;;;1214       else if (hi2c->XferSize == 2U)
;;;1215       {
;;;1216         /* Disable Acknowledge */
;;;1217         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1218   
;;;1219         /* Enable Pos */
;;;1220         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1221   
;;;1222         /* Clear ADDR flag */
;;;1223         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1224       }
;;;1225       else
;;;1226       {
;;;1227         /* Enable Acknowledge */
;;;1228         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1229   
;;;1230         /* Clear ADDR flag */
;;;1231         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1232       }
;;;1233   
;;;1234       while (hi2c->XferSize > 0U)
;;;1235       {
;;;1236         if (hi2c->XferSize <= 3U)
;;;1237         {
;;;1238           /* One byte */
;;;1239           if (hi2c->XferSize == 1U)
;;;1240           {
;;;1241             /* Wait until RXNE flag is set */
;;;1242             if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1243             {
;;;1244               return HAL_ERROR;
;;;1245             }
;;;1246   
;;;1247             /* Read data from DR */
;;;1248             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1249   
;;;1250             /* Increment Buffer pointer */
;;;1251             hi2c->pBuffPtr++;
;;;1252   
;;;1253             /* Update counter */
;;;1254             hi2c->XferSize--;
;;;1255             hi2c->XferCount--;
;;;1256           }
;;;1257           /* Two bytes */
;;;1258           else if (hi2c->XferSize == 2U)
;;;1259           {
;;;1260             /* Wait until BTF flag is set */
;;;1261             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;1262             {
;;;1263               return HAL_ERROR;
;;;1264             }
;;;1265   
;;;1266             /* Generate Stop */
;;;1267             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1268   
;;;1269             /* Read data from DR */
;;;1270             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1271   
;;;1272             /* Increment Buffer pointer */
;;;1273             hi2c->pBuffPtr++;
;;;1274   
;;;1275             /* Update counter */
;;;1276             hi2c->XferSize--;
;;;1277             hi2c->XferCount--;
;;;1278   
;;;1279             /* Read data from DR */
;;;1280             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1281   
;;;1282             /* Increment Buffer pointer */
;;;1283             hi2c->pBuffPtr++;
;;;1284   
;;;1285             /* Update counter */
;;;1286             hi2c->XferSize--;
;;;1287             hi2c->XferCount--;
;;;1288           }
;;;1289           /* 3 Last bytes */
;;;1290           else
;;;1291           {
;;;1292             /* Wait until BTF flag is set */
;;;1293             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;1294             {
;;;1295               return HAL_ERROR;
;;;1296             }
;;;1297   
;;;1298             /* Disable Acknowledge */
;;;1299             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1300   
;;;1301             /* Read data from DR */
;;;1302             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1303   
;;;1304             /* Increment Buffer pointer */
;;;1305             hi2c->pBuffPtr++;
;;;1306   
;;;1307             /* Update counter */
;;;1308             hi2c->XferSize--;
;;;1309             hi2c->XferCount--;
;;;1310   
;;;1311             /* Wait until BTF flag is set */
;;;1312             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;1313             {
;;;1314               return HAL_ERROR;
;;;1315             }
;;;1316   
;;;1317             /* Generate Stop */
;;;1318             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1319   
;;;1320             /* Read data from DR */
;;;1321             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1322   
;;;1323             /* Increment Buffer pointer */
;;;1324             hi2c->pBuffPtr++;
;;;1325   
;;;1326             /* Update counter */
;;;1327             hi2c->XferSize--;
;;;1328             hi2c->XferCount--;
;;;1329   
;;;1330             /* Read data from DR */
;;;1331             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1332   
;;;1333             /* Increment Buffer pointer */
;;;1334             hi2c->pBuffPtr++;
;;;1335   
;;;1336             /* Update counter */
;;;1337             hi2c->XferSize--;
;;;1338             hi2c->XferCount--;
;;;1339           }
;;;1340         }
;;;1341         else
;;;1342         {
;;;1343           /* Wait until RXNE flag is set */
;;;1344           if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1345           {
;;;1346             return HAL_ERROR;
;;;1347           }
;;;1348   
;;;1349           /* Read data from DR */
;;;1350           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1351   
;;;1352           /* Increment Buffer pointer */
;;;1353           hi2c->pBuffPtr++;
;;;1354   
;;;1355           /* Update counter */
;;;1356           hi2c->XferSize--;
;;;1357           hi2c->XferCount--;
;;;1358   
;;;1359           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;1360           {
;;;1361             /* Read data from DR */
;;;1362             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1363   
;;;1364             /* Increment Buffer pointer */
;;;1365             hi2c->pBuffPtr++;
;;;1366   
;;;1367             /* Update counter */
;;;1368             hi2c->XferSize--;
;;;1369             hi2c->XferCount--;
;;;1370           }
;;;1371         }
;;;1372       }
;;;1373   
;;;1374       hi2c->State = HAL_I2C_STATE_READY;
;;;1375       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1376   
;;;1377       /* Process Unlocked */
;;;1378       __HAL_UNLOCK(hi2c);
;;;1379   
;;;1380       return HAL_OK;
;;;1381     }
;;;1382     else
;;;1383     {
;;;1384       return HAL_BUSY;
;;;1385     }
;;;1386   }
00002e  e8bd83f8          POP      {r3-r9,pc}
                  |L18.50|
000032  bf00              NOP                            ;1167
000034  f894003c          LDRB     r0,[r4,#0x3c]         ;1167
000038  2801              CMP      r0,#1                 ;1167
00003a  d101              BNE      |L18.64|
00003c  2002              MOVS     r0,#2                 ;1167
00003e  e7f6              B        |L18.46|
                  |L18.64|
000040  2001              MOVS     r0,#1                 ;1167
000042  f884003c          STRB     r0,[r4,#0x3c]         ;1167
000046  bf00              NOP                            ;1167
000048  6820              LDR      r0,[r4,#0]            ;1170
00004a  6800              LDR      r0,[r0,#0]            ;1170
00004c  f0000001          AND      r0,r0,#1              ;1170
000050  b928              CBNZ     r0,|L18.94|
000052  6820              LDR      r0,[r4,#0]            ;1173
000054  6800              LDR      r0,[r0,#0]            ;1173
000056  f0400001          ORR      r0,r0,#1              ;1173
00005a  6821              LDR      r1,[r4,#0]            ;1173
00005c  6008              STR      r0,[r1,#0]            ;1173
                  |L18.94|
00005e  6820              LDR      r0,[r4,#0]            ;1177
000060  6800              LDR      r0,[r0,#0]            ;1177
000062  f4206000          BIC      r0,r0,#0x800          ;1177
000066  6821              LDR      r1,[r4,#0]            ;1177
000068  6008              STR      r0,[r1,#0]            ;1177
00006a  2022              MOVS     r0,#0x22              ;1179
00006c  f884003d          STRB     r0,[r4,#0x3d]         ;1179
000070  2010              MOVS     r0,#0x10              ;1180
000072  f884003e          STRB     r0,[r4,#0x3e]         ;1180
000076  2000              MOVS     r0,#0                 ;1181
000078  6420              STR      r0,[r4,#0x40]         ;1181
00007a  6267              STR      r7,[r4,#0x24]         ;1184
00007c  f8a4802a          STRH     r8,[r4,#0x2a]         ;1185
000080  8d60              LDRH     r0,[r4,#0x2a]         ;1186
000082  8520              STRH     r0,[r4,#0x28]         ;1186
000084  489a              LDR      r0,|L18.752|
000086  62e0              STR      r0,[r4,#0x2c]         ;1187
000088  462b              MOV      r3,r5                 ;1190
00008a  4632              MOV      r2,r6                 ;1190
00008c  4649              MOV      r1,r9                 ;1190
00008e  4620              MOV      r0,r4                 ;1190
000090  f7fffffe          BL       I2C_MasterRequestRead
000094  b108              CBZ      r0,|L18.154|
000096  2001              MOVS     r0,#1                 ;1192
000098  e7c9              B        |L18.46|
                  |L18.154|
00009a  8d20              LDRH     r0,[r4,#0x28]         ;1195
00009c  b988              CBNZ     r0,|L18.194|
00009e  bf00              NOP                            ;1198
0000a0  2000              MOVS     r0,#0                 ;1198
0000a2  9000              STR      r0,[sp,#0]            ;1198
0000a4  6820              LDR      r0,[r4,#0]            ;1198
0000a6  6940              LDR      r0,[r0,#0x14]         ;1198
0000a8  9000              STR      r0,[sp,#0]            ;1198
0000aa  6820              LDR      r0,[r4,#0]            ;1198
0000ac  6980              LDR      r0,[r0,#0x18]         ;1198
0000ae  9000              STR      r0,[sp,#0]            ;1198
0000b0  bf00              NOP                            ;1198
0000b2  bf00              NOP                            ;1198
0000b4  6820              LDR      r0,[r4,#0]            ;1201
0000b6  6800              LDR      r0,[r0,#0]            ;1201
0000b8  f4407000          ORR      r0,r0,#0x200          ;1201
0000bc  6821              LDR      r1,[r4,#0]            ;1201
0000be  6008              STR      r0,[r1,#0]            ;1201
0000c0  e047              B        |L18.338|
                  |L18.194|
0000c2  8d20              LDRH     r0,[r4,#0x28]         ;1203
0000c4  2801              CMP      r0,#1                 ;1203
0000c6  d117              BNE      |L18.248|
0000c8  6820              LDR      r0,[r4,#0]            ;1206
0000ca  6800              LDR      r0,[r0,#0]            ;1206
0000cc  f4206080          BIC      r0,r0,#0x400          ;1206
0000d0  6821              LDR      r1,[r4,#0]            ;1206
0000d2  6008              STR      r0,[r1,#0]            ;1206
0000d4  bf00              NOP                            ;1209
0000d6  2000              MOVS     r0,#0                 ;1209
0000d8  9000              STR      r0,[sp,#0]            ;1209
0000da  6820              LDR      r0,[r4,#0]            ;1209
0000dc  6940              LDR      r0,[r0,#0x14]         ;1209
0000de  9000              STR      r0,[sp,#0]            ;1209
0000e0  6820              LDR      r0,[r4,#0]            ;1209
0000e2  6980              LDR      r0,[r0,#0x18]         ;1209
0000e4  9000              STR      r0,[sp,#0]            ;1209
0000e6  bf00              NOP                            ;1209
0000e8  bf00              NOP                            ;1209
0000ea  6820              LDR      r0,[r4,#0]            ;1212
0000ec  6800              LDR      r0,[r0,#0]            ;1212
0000ee  f4407000          ORR      r0,r0,#0x200          ;1212
0000f2  6821              LDR      r1,[r4,#0]            ;1212
0000f4  6008              STR      r0,[r1,#0]            ;1212
0000f6  e02c              B        |L18.338|
                  |L18.248|
0000f8  8d20              LDRH     r0,[r4,#0x28]         ;1214
0000fa  2802              CMP      r0,#2                 ;1214
0000fc  d118              BNE      |L18.304|
0000fe  6820              LDR      r0,[r4,#0]            ;1217
000100  6800              LDR      r0,[r0,#0]            ;1217
000102  f4206080          BIC      r0,r0,#0x400          ;1217
000106  6821              LDR      r1,[r4,#0]            ;1217
000108  6008              STR      r0,[r1,#0]            ;1217
00010a  6820              LDR      r0,[r4,#0]            ;1220
00010c  6800              LDR      r0,[r0,#0]            ;1220
00010e  f4406000          ORR      r0,r0,#0x800          ;1220
000112  6821              LDR      r1,[r4,#0]            ;1220
000114  6008              STR      r0,[r1,#0]            ;1220
000116  e000              B        |L18.282|
                  |L18.280|
000118  e0e6              B        |L18.744|
                  |L18.282|
00011a  bf00              NOP                            ;1223
00011c  2000              MOVS     r0,#0                 ;1223
00011e  9000              STR      r0,[sp,#0]            ;1223
000120  6820              LDR      r0,[r4,#0]            ;1223
000122  6940              LDR      r0,[r0,#0x14]         ;1223
000124  9000              STR      r0,[sp,#0]            ;1223
000126  6820              LDR      r0,[r4,#0]            ;1223
000128  6980              LDR      r0,[r0,#0x18]         ;1223
00012a  9000              STR      r0,[sp,#0]            ;1223
00012c  bf00              NOP                            ;1223
00012e  e010              B        |L18.338|
                  |L18.304|
000130  6820              LDR      r0,[r4,#0]            ;1228
000132  6800              LDR      r0,[r0,#0]            ;1228
000134  f4406080          ORR      r0,r0,#0x400          ;1228
000138  6821              LDR      r1,[r4,#0]            ;1228
00013a  6008              STR      r0,[r1,#0]            ;1228
00013c  bf00              NOP                            ;1231
00013e  2000              MOVS     r0,#0                 ;1231
000140  9000              STR      r0,[sp,#0]            ;1231
000142  6820              LDR      r0,[r4,#0]            ;1231
000144  6940              LDR      r0,[r0,#0x14]         ;1231
000146  9000              STR      r0,[sp,#0]            ;1231
000148  6820              LDR      r0,[r4,#0]            ;1231
00014a  6980              LDR      r0,[r0,#0x18]         ;1231
00014c  9000              STR      r0,[sp,#0]            ;1231
00014e  bf00              NOP                            ;1231
000150  bf00              NOP                            ;1231
                  |L18.338|
000152  e0ba              B        |L18.714|
                  |L18.340|
000154  8d20              LDRH     r0,[r4,#0x28]         ;1236
000156  2803              CMP      r0,#3                 ;1236
000158  d87e              BHI      |L18.600|
00015a  8d20              LDRH     r0,[r4,#0x28]         ;1239
00015c  2801              CMP      r0,#1                 ;1239
00015e  d115              BNE      |L18.396|
000160  462a              MOV      r2,r5                 ;1242
000162  4631              MOV      r1,r6                 ;1242
000164  4620              MOV      r0,r4                 ;1242
000166  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
00016a  b108              CBZ      r0,|L18.368|
00016c  2001              MOVS     r0,#1                 ;1244
00016e  e75e              B        |L18.46|
                  |L18.368|
000170  6820              LDR      r0,[r4,#0]            ;1248
000172  6900              LDR      r0,[r0,#0x10]         ;1248
000174  6a61              LDR      r1,[r4,#0x24]         ;1248
000176  7008              STRB     r0,[r1,#0]            ;1248
000178  6a60              LDR      r0,[r4,#0x24]         ;1251
00017a  1c40              ADDS     r0,r0,#1              ;1251
00017c  6260              STR      r0,[r4,#0x24]         ;1251
00017e  8d20              LDRH     r0,[r4,#0x28]         ;1254
000180  1e40              SUBS     r0,r0,#1              ;1254
000182  8520              STRH     r0,[r4,#0x28]         ;1254
000184  8d60              LDRH     r0,[r4,#0x2a]         ;1255
000186  1e40              SUBS     r0,r0,#1              ;1255
000188  8560              STRH     r0,[r4,#0x2a]         ;1255
00018a  e09e              B        |L18.714|
                  |L18.396|
00018c  8d20              LDRH     r0,[r4,#0x28]         ;1258
00018e  2802              CMP      r0,#2                 ;1258
000190  d12a              BNE      |L18.488|
000192  4633              MOV      r3,r6                 ;1261
000194  2200              MOVS     r2,#0                 ;1261
000196  4957              LDR      r1,|L18.756|
000198  4620              MOV      r0,r4                 ;1261
00019a  9500              STR      r5,[sp,#0]            ;1261
00019c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001a0  b108              CBZ      r0,|L18.422|
0001a2  2001              MOVS     r0,#1                 ;1263
0001a4  e743              B        |L18.46|
                  |L18.422|
0001a6  6820              LDR      r0,[r4,#0]            ;1267
0001a8  6800              LDR      r0,[r0,#0]            ;1267
0001aa  f4407000          ORR      r0,r0,#0x200          ;1267
0001ae  6821              LDR      r1,[r4,#0]            ;1267
0001b0  6008              STR      r0,[r1,#0]            ;1267
0001b2  6820              LDR      r0,[r4,#0]            ;1270
0001b4  6900              LDR      r0,[r0,#0x10]         ;1270
0001b6  6a61              LDR      r1,[r4,#0x24]         ;1270
0001b8  7008              STRB     r0,[r1,#0]            ;1270
0001ba  6a60              LDR      r0,[r4,#0x24]         ;1273
0001bc  1c40              ADDS     r0,r0,#1              ;1273
0001be  6260              STR      r0,[r4,#0x24]         ;1273
0001c0  8d20              LDRH     r0,[r4,#0x28]         ;1276
0001c2  1e40              SUBS     r0,r0,#1              ;1276
0001c4  8520              STRH     r0,[r4,#0x28]         ;1276
0001c6  8d60              LDRH     r0,[r4,#0x2a]         ;1277
0001c8  1e40              SUBS     r0,r0,#1              ;1277
0001ca  8560              STRH     r0,[r4,#0x2a]         ;1277
0001cc  6820              LDR      r0,[r4,#0]            ;1280
0001ce  6900              LDR      r0,[r0,#0x10]         ;1280
0001d0  6a61              LDR      r1,[r4,#0x24]         ;1280
0001d2  7008              STRB     r0,[r1,#0]            ;1280
0001d4  6a60              LDR      r0,[r4,#0x24]         ;1283
0001d6  1c40              ADDS     r0,r0,#1              ;1283
0001d8  6260              STR      r0,[r4,#0x24]         ;1283
0001da  8d20              LDRH     r0,[r4,#0x28]         ;1286
0001dc  1e40              SUBS     r0,r0,#1              ;1286
0001de  8520              STRH     r0,[r4,#0x28]         ;1286
0001e0  8d60              LDRH     r0,[r4,#0x2a]         ;1287
0001e2  1e40              SUBS     r0,r0,#1              ;1287
0001e4  8560              STRH     r0,[r4,#0x2a]         ;1287
0001e6  e070              B        |L18.714|
                  |L18.488|
0001e8  4633              MOV      r3,r6                 ;1293
0001ea  2200              MOVS     r2,#0                 ;1293
0001ec  4941              LDR      r1,|L18.756|
0001ee  4620              MOV      r0,r4                 ;1293
0001f0  9500              STR      r5,[sp,#0]            ;1293
0001f2  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001f6  b108              CBZ      r0,|L18.508|
0001f8  2001              MOVS     r0,#1                 ;1295
0001fa  e718              B        |L18.46|
                  |L18.508|
0001fc  6820              LDR      r0,[r4,#0]            ;1299
0001fe  6800              LDR      r0,[r0,#0]            ;1299
000200  f4206080          BIC      r0,r0,#0x400          ;1299
000204  6821              LDR      r1,[r4,#0]            ;1299
000206  6008              STR      r0,[r1,#0]            ;1299
000208  6820              LDR      r0,[r4,#0]            ;1302
00020a  6900              LDR      r0,[r0,#0x10]         ;1302
00020c  6a61              LDR      r1,[r4,#0x24]         ;1302
00020e  7008              STRB     r0,[r1,#0]            ;1302
000210  6a60              LDR      r0,[r4,#0x24]         ;1305
000212  1c40              ADDS     r0,r0,#1              ;1305
000214  6260              STR      r0,[r4,#0x24]         ;1305
000216  8d20              LDRH     r0,[r4,#0x28]         ;1308
000218  1e40              SUBS     r0,r0,#1              ;1308
00021a  8520              STRH     r0,[r4,#0x28]         ;1308
00021c  8d60              LDRH     r0,[r4,#0x2a]         ;1309
00021e  1e40              SUBS     r0,r0,#1              ;1309
000220  8560              STRH     r0,[r4,#0x2a]         ;1309
000222  4633              MOV      r3,r6                 ;1312
000224  2200              MOVS     r2,#0                 ;1312
000226  4933              LDR      r1,|L18.756|
000228  4620              MOV      r0,r4                 ;1312
00022a  9500              STR      r5,[sp,#0]            ;1312
00022c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000230  b108              CBZ      r0,|L18.566|
000232  2001              MOVS     r0,#1                 ;1314
000234  e6fb              B        |L18.46|
                  |L18.566|
000236  6820              LDR      r0,[r4,#0]            ;1318
000238  6800              LDR      r0,[r0,#0]            ;1318
00023a  f4407000          ORR      r0,r0,#0x200          ;1318
00023e  6821              LDR      r1,[r4,#0]            ;1318
000240  6008              STR      r0,[r1,#0]            ;1318
000242  6820              LDR      r0,[r4,#0]            ;1321
000244  6900              LDR      r0,[r0,#0x10]         ;1321
000246  6a61              LDR      r1,[r4,#0x24]         ;1321
000248  7008              STRB     r0,[r1,#0]            ;1321
00024a  6a60              LDR      r0,[r4,#0x24]         ;1324
00024c  1c40              ADDS     r0,r0,#1              ;1324
00024e  6260              STR      r0,[r4,#0x24]         ;1324
000250  8d20              LDRH     r0,[r4,#0x28]         ;1327
000252  1e40              SUBS     r0,r0,#1              ;1327
000254  8520              STRH     r0,[r4,#0x28]         ;1327
000256  e000              B        |L18.602|
                  |L18.600|
000258  e010              B        |L18.636|
                  |L18.602|
00025a  8d60              LDRH     r0,[r4,#0x2a]         ;1328
00025c  1e40              SUBS     r0,r0,#1              ;1328
00025e  8560              STRH     r0,[r4,#0x2a]         ;1328
000260  6820              LDR      r0,[r4,#0]            ;1331
000262  6900              LDR      r0,[r0,#0x10]         ;1331
000264  6a61              LDR      r1,[r4,#0x24]         ;1331
000266  7008              STRB     r0,[r1,#0]            ;1331
000268  6a60              LDR      r0,[r4,#0x24]         ;1334
00026a  1c40              ADDS     r0,r0,#1              ;1334
00026c  6260              STR      r0,[r4,#0x24]         ;1334
00026e  8d20              LDRH     r0,[r4,#0x28]         ;1337
000270  1e40              SUBS     r0,r0,#1              ;1337
000272  8520              STRH     r0,[r4,#0x28]         ;1337
000274  8d60              LDRH     r0,[r4,#0x2a]         ;1338
000276  1e40              SUBS     r0,r0,#1              ;1338
000278  8560              STRH     r0,[r4,#0x2a]         ;1338
00027a  e026              B        |L18.714|
                  |L18.636|
00027c  462a              MOV      r2,r5                 ;1344
00027e  4631              MOV      r1,r6                 ;1344
000280  4620              MOV      r0,r4                 ;1344
000282  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000286  b108              CBZ      r0,|L18.652|
000288  2001              MOVS     r0,#1                 ;1346
00028a  e6d0              B        |L18.46|
                  |L18.652|
00028c  6820              LDR      r0,[r4,#0]            ;1350
00028e  6900              LDR      r0,[r0,#0x10]         ;1350
000290  6a61              LDR      r1,[r4,#0x24]         ;1350
000292  7008              STRB     r0,[r1,#0]            ;1350
000294  6a60              LDR      r0,[r4,#0x24]         ;1353
000296  1c40              ADDS     r0,r0,#1              ;1353
000298  6260              STR      r0,[r4,#0x24]         ;1353
00029a  8d20              LDRH     r0,[r4,#0x28]         ;1356
00029c  1e40              SUBS     r0,r0,#1              ;1356
00029e  8520              STRH     r0,[r4,#0x28]         ;1356
0002a0  8d60              LDRH     r0,[r4,#0x2a]         ;1357
0002a2  1e40              SUBS     r0,r0,#1              ;1357
0002a4  8560              STRH     r0,[r4,#0x2a]         ;1357
0002a6  6820              LDR      r0,[r4,#0]            ;1359
0002a8  6940              LDR      r0,[r0,#0x14]         ;1359
0002aa  f3c00080          UBFX     r0,r0,#2,#1           ;1359
0002ae  b160              CBZ      r0,|L18.714|
0002b0  6820              LDR      r0,[r4,#0]            ;1362
0002b2  6900              LDR      r0,[r0,#0x10]         ;1362
0002b4  6a61              LDR      r1,[r4,#0x24]         ;1362
0002b6  7008              STRB     r0,[r1,#0]            ;1362
0002b8  6a60              LDR      r0,[r4,#0x24]         ;1365
0002ba  1c40              ADDS     r0,r0,#1              ;1365
0002bc  6260              STR      r0,[r4,#0x24]         ;1365
0002be  8d20              LDRH     r0,[r4,#0x28]         ;1368
0002c0  1e40              SUBS     r0,r0,#1              ;1368
0002c2  8520              STRH     r0,[r4,#0x28]         ;1368
0002c4  8d60              LDRH     r0,[r4,#0x2a]         ;1369
0002c6  1e40              SUBS     r0,r0,#1              ;1369
0002c8  8560              STRH     r0,[r4,#0x2a]         ;1369
                  |L18.714|
0002ca  8d20              LDRH     r0,[r4,#0x28]         ;1234
0002cc  2800              CMP      r0,#0                 ;1234
0002ce  f47faf41          BNE      |L18.340|
0002d2  2020              MOVS     r0,#0x20              ;1374
0002d4  f884003d          STRB     r0,[r4,#0x3d]         ;1374
0002d8  2000              MOVS     r0,#0                 ;1375
0002da  f884003e          STRB     r0,[r4,#0x3e]         ;1375
0002de  bf00              NOP                            ;1378
0002e0  f884003c          STRB     r0,[r4,#0x3c]         ;1378
0002e4  bf00              NOP                            ;1378
0002e6  e6a2              B        |L18.46|
                  |L18.744|
0002e8  2002              MOVS     r0,#2                 ;1384
0002ea  e6a0              B        |L18.46|
;;;1387   
                          ENDP

                  |L18.748|
                          DCD      0x00100002
                  |L18.752|
                          DCD      0xffff0000
                  |L18.756|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Master_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_DMA PROC
;;;2094     */
;;;2095   HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2096   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;2097     __IO uint32_t count = 0U;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;2098     HAL_StatusTypeDef dmaxferstatus;
;;;2099   
;;;2100     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d178              BNE      |L19.266|
;;;2101     {
;;;2102       /* Wait until BUSY flag is reset */
;;;2103       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000018  486a              LDR      r0,|L19.452|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  2119              MOVS     r1,#0x19
00001e  fbb0f0f1          UDIV     r0,r0,r1
000022  f44f717a          MOV      r1,#0x3e8
000026  fbb0f0f1          UDIV     r0,r0,r1
00002a  eb0001c0          ADD      r1,r0,r0,LSL #3
00002e  eb011000          ADD      r0,r1,r0,LSL #4
000032  9000              STR      r0,[sp,#0]
;;;2104       do
000034  bf00              NOP      
                  |L19.54|
;;;2105       {
;;;2106         count--;
000036  9800              LDR      r0,[sp,#0]
000038  1e40              SUBS     r0,r0,#1
00003a  9000              STR      r0,[sp,#0]
;;;2107         if (count == 0U)
00003c  9800              LDR      r0,[sp,#0]
00003e  b998              CBNZ     r0,|L19.104|
;;;2108         {
;;;2109           hi2c->PreviousState       = I2C_STATE_NONE;
000040  2000              MOVS     r0,#0
000042  6320              STR      r0,[r4,#0x30]
;;;2110           hi2c->State               = HAL_I2C_STATE_READY;
000044  2020              MOVS     r0,#0x20
000046  f884003d          STRB     r0,[r4,#0x3d]
;;;2111           hi2c->Mode                = HAL_I2C_MODE_NONE;
00004a  2000              MOVS     r0,#0
00004c  f884003e          STRB     r0,[r4,#0x3e]
;;;2112           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000050  6c20              LDR      r0,[r4,#0x40]
000052  f0400020          ORR      r0,r0,#0x20
000056  6420              STR      r0,[r4,#0x40]
;;;2113   
;;;2114           /* Process Unlocked */
;;;2115           __HAL_UNLOCK(hi2c);
000058  bf00              NOP      
00005a  2000              MOVS     r0,#0
00005c  f884003c          STRB     r0,[r4,#0x3c]
000060  bf00              NOP      
;;;2116   
;;;2117           return HAL_ERROR;
000062  2001              MOVS     r0,#1
                  |L19.100|
;;;2118         }
;;;2119       }
;;;2120       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2121   
;;;2122       /* Process Locked */
;;;2123       __HAL_LOCK(hi2c);
;;;2124   
;;;2125       /* Check if the I2C is already enabled */
;;;2126       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2127       {
;;;2128         /* Enable I2C peripheral */
;;;2129         __HAL_I2C_ENABLE(hi2c);
;;;2130       }
;;;2131   
;;;2132       /* Disable Pos */
;;;2133       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2134   
;;;2135       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2136       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;2137       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2138   
;;;2139       /* Prepare transfer parameters */
;;;2140       hi2c->pBuffPtr    = pData;
;;;2141       hi2c->XferCount   = Size;
;;;2142       hi2c->XferSize    = hi2c->XferCount;
;;;2143       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2144       hi2c->Devaddress  = DevAddress;
;;;2145   
;;;2146       if (hi2c->XferSize > 0U)
;;;2147       {
;;;2148         if (hi2c->hdmarx != NULL)
;;;2149         {
;;;2150           /* Set the I2C DMA transfer complete callback */
;;;2151           hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;2152   
;;;2153           /* Set the DMA error callback */
;;;2154           hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2155   
;;;2156           /* Set the unused DMA callbacks to NULL */
;;;2157           hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2158           hi2c->hdmarx->XferM1CpltCallback = NULL;
;;;2159           hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
;;;2160           hi2c->hdmarx->XferAbortCallback = NULL;
;;;2161   
;;;2162           /* Enable the DMA stream */
;;;2163           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;2164         }
;;;2165         else
;;;2166         {
;;;2167           /* Update I2C state */
;;;2168           hi2c->State     = HAL_I2C_STATE_READY;
;;;2169           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2170   
;;;2171           /* Update I2C error code */
;;;2172           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;2173   
;;;2174           /* Process Unlocked */
;;;2175           __HAL_UNLOCK(hi2c);
;;;2176   
;;;2177           return HAL_ERROR;
;;;2178         }
;;;2179   
;;;2180         if (dmaxferstatus == HAL_OK)
;;;2181         {
;;;2182           /* Enable Acknowledge */
;;;2183           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2184   
;;;2185           /* Generate Start */
;;;2186           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2187   
;;;2188           /* Process Unlocked */
;;;2189           __HAL_UNLOCK(hi2c);
;;;2190   
;;;2191           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2192           to avoid the risk of I2C interrupt handle execution before current
;;;2193           process unlock */
;;;2194   
;;;2195           /* Enable EVT and ERR interrupt */
;;;2196           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2197   
;;;2198           /* Enable DMA Request */
;;;2199           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2200         }
;;;2201         else
;;;2202         {
;;;2203           /* Update I2C state */
;;;2204           hi2c->State     = HAL_I2C_STATE_READY;
;;;2205           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2206   
;;;2207           /* Update I2C error code */
;;;2208           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2209   
;;;2210           /* Process Unlocked */
;;;2211           __HAL_UNLOCK(hi2c);
;;;2212   
;;;2213           return HAL_ERROR;
;;;2214         }
;;;2215       }
;;;2216       else
;;;2217       {
;;;2218         /* Process Unlocked */
;;;2219         __HAL_UNLOCK(hi2c);
;;;2220   
;;;2221         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2222         to avoid the risk of I2C interrupt handle execution before current
;;;2223         process unlock */
;;;2224   
;;;2225         /* Enable EVT, BUF and ERR interrupt */
;;;2226         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2227   
;;;2228         /* Enable Acknowledge */
;;;2229         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2230   
;;;2231         /* Generate Start */
;;;2232         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2233       }
;;;2234   
;;;2235       return HAL_OK;
;;;2236     }
;;;2237     else
;;;2238     {
;;;2239       return HAL_BUSY;
;;;2240     }
;;;2241   }
000064  e8bd83f8          POP      {r3-r9,pc}
                  |L19.104|
000068  6820              LDR      r0,[r4,#0]            ;2120
00006a  6980              LDR      r0,[r0,#0x18]         ;2120
00006c  f3c00040          UBFX     r0,r0,#1,#1           ;2120
000070  2800              CMP      r0,#0                 ;2120
000072  d1e0              BNE      |L19.54|
000074  bf00              NOP                            ;2123
000076  f894003c          LDRB     r0,[r4,#0x3c]         ;2123
00007a  2801              CMP      r0,#1                 ;2123
00007c  d101              BNE      |L19.130|
00007e  2002              MOVS     r0,#2                 ;2123
000080  e7f0              B        |L19.100|
                  |L19.130|
000082  2001              MOVS     r0,#1                 ;2123
000084  f884003c          STRB     r0,[r4,#0x3c]         ;2123
000088  bf00              NOP                            ;2123
00008a  6820              LDR      r0,[r4,#0]            ;2126
00008c  6800              LDR      r0,[r0,#0]            ;2126
00008e  f0000001          AND      r0,r0,#1              ;2126
000092  b928              CBNZ     r0,|L19.160|
000094  6820              LDR      r0,[r4,#0]            ;2129
000096  6800              LDR      r0,[r0,#0]            ;2129
000098  f0400001          ORR      r0,r0,#1              ;2129
00009c  6821              LDR      r1,[r4,#0]            ;2129
00009e  6008              STR      r0,[r1,#0]            ;2129
                  |L19.160|
0000a0  6820              LDR      r0,[r4,#0]            ;2133
0000a2  6800              LDR      r0,[r0,#0]            ;2133
0000a4  f4206000          BIC      r0,r0,#0x800          ;2133
0000a8  6821              LDR      r1,[r4,#0]            ;2133
0000aa  6008              STR      r0,[r1,#0]            ;2133
0000ac  2022              MOVS     r0,#0x22              ;2135
0000ae  f884003d          STRB     r0,[r4,#0x3d]         ;2135
0000b2  2010              MOVS     r0,#0x10              ;2136
0000b4  f884003e          STRB     r0,[r4,#0x3e]         ;2136
0000b8  2000              MOVS     r0,#0                 ;2137
0000ba  6420              STR      r0,[r4,#0x40]         ;2137
0000bc  6267              STR      r7,[r4,#0x24]         ;2140
0000be  f8a4802a          STRH     r8,[r4,#0x2a]         ;2141
0000c2  8d60              LDRH     r0,[r4,#0x2a]         ;2142
0000c4  8520              STRH     r0,[r4,#0x28]         ;2142
0000c6  4840              LDR      r0,|L19.456|
0000c8  62e0              STR      r0,[r4,#0x2c]         ;2143
0000ca  6466              STR      r6,[r4,#0x44]         ;2144
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;2146
0000ce  2800              CMP      r0,#0                 ;2146
0000d0  d05d              BEQ      |L19.398|
0000d2  6ba0              LDR      r0,[r4,#0x38]         ;2148
0000d4  b1d0              CBZ      r0,|L19.268|
0000d6  483d              LDR      r0,|L19.460|
0000d8  6ba1              LDR      r1,[r4,#0x38]         ;2151
0000da  63c8              STR      r0,[r1,#0x3c]         ;2151
0000dc  483c              LDR      r0,|L19.464|
0000de  6ba1              LDR      r1,[r4,#0x38]         ;2154
0000e0  64c8              STR      r0,[r1,#0x4c]         ;2154
0000e2  2000              MOVS     r0,#0                 ;2157
0000e4  6ba1              LDR      r1,[r4,#0x38]         ;2157
0000e6  6408              STR      r0,[r1,#0x40]         ;2157
0000e8  6ba1              LDR      r1,[r4,#0x38]         ;2158
0000ea  6448              STR      r0,[r1,#0x44]         ;2158
0000ec  6ba1              LDR      r1,[r4,#0x38]         ;2159
0000ee  6488              STR      r0,[r1,#0x48]         ;2159
0000f0  6ba1              LDR      r1,[r4,#0x38]         ;2160
0000f2  6508              STR      r0,[r1,#0x50]         ;2160
0000f4  8d23              LDRH     r3,[r4,#0x28]         ;2163
0000f6  f8d4c000          LDR      r12,[r4,#0]           ;2163
0000fa  f10c0110          ADD      r1,r12,#0x10          ;2163
0000fe  6a62              LDR      r2,[r4,#0x24]         ;2163
000100  6ba0              LDR      r0,[r4,#0x38]         ;2163
000102  f7fffffe          BL       HAL_DMA_Start_IT
000106  4605              MOV      r5,r0                 ;2163
000108  e011              B        |L19.302|
                  |L19.266|
00010a  e059              B        |L19.448|
                  |L19.268|
00010c  2020              MOVS     r0,#0x20              ;2168
00010e  f884003d          STRB     r0,[r4,#0x3d]         ;2168
000112  2000              MOVS     r0,#0                 ;2169
000114  f884003e          STRB     r0,[r4,#0x3e]         ;2169
000118  6c20              LDR      r0,[r4,#0x40]         ;2172
00011a  f0400080          ORR      r0,r0,#0x80           ;2172
00011e  6420              STR      r0,[r4,#0x40]         ;2172
000120  bf00              NOP                            ;2175
000122  2000              MOVS     r0,#0                 ;2175
000124  f884003c          STRB     r0,[r4,#0x3c]         ;2175
000128  bf00              NOP                            ;2175
00012a  2001              MOVS     r0,#1                 ;2177
00012c  e79a              B        |L19.100|
                  |L19.302|
00012e  b9ed              CBNZ     r5,|L19.364|
000130  6820              LDR      r0,[r4,#0]            ;2183
000132  6800              LDR      r0,[r0,#0]            ;2183
000134  f4406080          ORR      r0,r0,#0x400          ;2183
000138  6821              LDR      r1,[r4,#0]            ;2183
00013a  6008              STR      r0,[r1,#0]            ;2183
00013c  6820              LDR      r0,[r4,#0]            ;2186
00013e  6800              LDR      r0,[r0,#0]            ;2186
000140  f4407080          ORR      r0,r0,#0x100          ;2186
000144  6821              LDR      r1,[r4,#0]            ;2186
000146  6008              STR      r0,[r1,#0]            ;2186
000148  bf00              NOP                            ;2189
00014a  2000              MOVS     r0,#0                 ;2189
00014c  f884003c          STRB     r0,[r4,#0x3c]         ;2189
000150  bf00              NOP                            ;2189
000152  6820              LDR      r0,[r4,#0]            ;2196
000154  6840              LDR      r0,[r0,#4]            ;2196
000156  f4407040          ORR      r0,r0,#0x300          ;2196
00015a  6821              LDR      r1,[r4,#0]            ;2196
00015c  6048              STR      r0,[r1,#4]            ;2196
00015e  6820              LDR      r0,[r4,#0]            ;2199
000160  6840              LDR      r0,[r0,#4]            ;2199
000162  f4406000          ORR      r0,r0,#0x800          ;2199
000166  6821              LDR      r1,[r4,#0]            ;2199
000168  6048              STR      r0,[r1,#4]            ;2199
00016a  e027              B        |L19.444|
                  |L19.364|
00016c  2020              MOVS     r0,#0x20              ;2204
00016e  f884003d          STRB     r0,[r4,#0x3d]         ;2204
000172  2000              MOVS     r0,#0                 ;2205
000174  f884003e          STRB     r0,[r4,#0x3e]         ;2205
000178  6c20              LDR      r0,[r4,#0x40]         ;2208
00017a  f0400010          ORR      r0,r0,#0x10           ;2208
00017e  6420              STR      r0,[r4,#0x40]         ;2208
000180  bf00              NOP                            ;2211
000182  2000              MOVS     r0,#0                 ;2211
000184  f884003c          STRB     r0,[r4,#0x3c]         ;2211
000188  bf00              NOP                            ;2211
00018a  2001              MOVS     r0,#1                 ;2213
00018c  e76a              B        |L19.100|
                  |L19.398|
00018e  bf00              NOP                            ;2219
000190  2000              MOVS     r0,#0                 ;2219
000192  f884003c          STRB     r0,[r4,#0x3c]         ;2219
000196  bf00              NOP                            ;2219
000198  6820              LDR      r0,[r4,#0]            ;2226
00019a  6840              LDR      r0,[r0,#4]            ;2226
00019c  f44060e0          ORR      r0,r0,#0x700          ;2226
0001a0  6821              LDR      r1,[r4,#0]            ;2226
0001a2  6048              STR      r0,[r1,#4]            ;2226
0001a4  6820              LDR      r0,[r4,#0]            ;2229
0001a6  6800              LDR      r0,[r0,#0]            ;2229
0001a8  f4406080          ORR      r0,r0,#0x400          ;2229
0001ac  6821              LDR      r1,[r4,#0]            ;2229
0001ae  6008              STR      r0,[r1,#0]            ;2229
0001b0  6820              LDR      r0,[r4,#0]            ;2232
0001b2  6800              LDR      r0,[r0,#0]            ;2232
0001b4  f4407080          ORR      r0,r0,#0x100          ;2232
0001b8  6821              LDR      r1,[r4,#0]            ;2232
0001ba  6008              STR      r0,[r1,#0]            ;2232
                  |L19.444|
0001bc  2000              MOVS     r0,#0                 ;2235
0001be  e751              B        |L19.100|
                  |L19.448|
0001c0  2002              MOVS     r0,#2                 ;2239
0001c2  e74f              B        |L19.100|
;;;2242   
                          ENDP

                  |L19.452|
                          DCD      SystemCoreClock
                  |L19.456|
                          DCD      0xffff0000
                  |L19.460|
                          DCD      I2C_DMAXferCplt
                  |L19.464|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_IT PROC
;;;1727     */
;;;1728   HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b538              PUSH     {r3-r5,lr}
;;;1729   {
000002  4604              MOV      r4,r0
;;;1730     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1731   
;;;1732     if (hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d171              BNE      |L20.244|
;;;1733     {
;;;1734       /* Wait until BUSY flag is reset */
;;;1735       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000010  4839              LDR      r0,|L20.248|
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  2519              MOVS     r5,#0x19
000016  fbb0f0f5          UDIV     r0,r0,r5
00001a  f44f757a          MOV      r5,#0x3e8
00001e  fbb0f0f5          UDIV     r0,r0,r5
000022  eb0005c0          ADD      r5,r0,r0,LSL #3
000026  eb051000          ADD      r0,r5,r0,LSL #4
00002a  9000              STR      r0,[sp,#0]
;;;1736       do
00002c  bf00              NOP      
                  |L20.46|
;;;1737       {
;;;1738         count--;
00002e  9800              LDR      r0,[sp,#0]
000030  1e40              SUBS     r0,r0,#1
000032  9000              STR      r0,[sp,#0]
;;;1739         if (count == 0U)
000034  9800              LDR      r0,[sp,#0]
000036  b990              CBNZ     r0,|L20.94|
;;;1740         {
;;;1741           hi2c->PreviousState       = I2C_STATE_NONE;
000038  2000              MOVS     r0,#0
00003a  6320              STR      r0,[r4,#0x30]
;;;1742           hi2c->State               = HAL_I2C_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;1743           hi2c->Mode                = HAL_I2C_MODE_NONE;
000042  2000              MOVS     r0,#0
000044  f884003e          STRB     r0,[r4,#0x3e]
;;;1744           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000048  6c20              LDR      r0,[r4,#0x40]
00004a  f0400020          ORR      r0,r0,#0x20
00004e  6420              STR      r0,[r4,#0x40]
;;;1745   
;;;1746           /* Process Unlocked */
;;;1747           __HAL_UNLOCK(hi2c);
000050  bf00              NOP      
000052  2000              MOVS     r0,#0
000054  f884003c          STRB     r0,[r4,#0x3c]
000058  bf00              NOP      
;;;1748   
;;;1749           return HAL_ERROR;
00005a  2001              MOVS     r0,#1
                  |L20.92|
;;;1750         }
;;;1751       }
;;;1752       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1753   
;;;1754       /* Process Locked */
;;;1755       __HAL_LOCK(hi2c);
;;;1756   
;;;1757       /* Check if the I2C is already enabled */
;;;1758       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1759       {
;;;1760         /* Enable I2C peripheral */
;;;1761         __HAL_I2C_ENABLE(hi2c);
;;;1762       }
;;;1763   
;;;1764       /* Disable Pos */
;;;1765       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1766   
;;;1767       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1768       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1769       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1770   
;;;1771       /* Prepare transfer parameters */
;;;1772       hi2c->pBuffPtr    = pData;
;;;1773       hi2c->XferCount   = Size;
;;;1774       hi2c->XferSize    = hi2c->XferCount;
;;;1775       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1776       hi2c->Devaddress  = DevAddress;
;;;1777   
;;;1778   
;;;1779       /* Process Unlocked */
;;;1780       __HAL_UNLOCK(hi2c);
;;;1781   
;;;1782       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1783       to avoid the risk of I2C interrupt handle execution before current
;;;1784       process unlock */
;;;1785   
;;;1786       /* Enable EVT, BUF and ERR interrupt */
;;;1787       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1788   
;;;1789       /* Enable Acknowledge */
;;;1790       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1791   
;;;1792       /* Generate Start */
;;;1793       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;1794   
;;;1795       return HAL_OK;
;;;1796     }
;;;1797     else
;;;1798     {
;;;1799       return HAL_BUSY;
;;;1800     }
;;;1801   }
00005c  bd38              POP      {r3-r5,pc}
                  |L20.94|
00005e  6820              LDR      r0,[r4,#0]            ;1752
000060  6980              LDR      r0,[r0,#0x18]         ;1752
000062  f3c00040          UBFX     r0,r0,#1,#1           ;1752
000066  2800              CMP      r0,#0                 ;1752
000068  d1e1              BNE      |L20.46|
00006a  bf00              NOP                            ;1755
00006c  f894003c          LDRB     r0,[r4,#0x3c]         ;1755
000070  2801              CMP      r0,#1                 ;1755
000072  d101              BNE      |L20.120|
000074  2002              MOVS     r0,#2                 ;1755
000076  e7f1              B        |L20.92|
                  |L20.120|
000078  2001              MOVS     r0,#1                 ;1755
00007a  f884003c          STRB     r0,[r4,#0x3c]         ;1755
00007e  bf00              NOP                            ;1755
000080  6820              LDR      r0,[r4,#0]            ;1758
000082  6800              LDR      r0,[r0,#0]            ;1758
000084  f0000001          AND      r0,r0,#1              ;1758
000088  b928              CBNZ     r0,|L20.150|
00008a  6820              LDR      r0,[r4,#0]            ;1761
00008c  6800              LDR      r0,[r0,#0]            ;1761
00008e  f0400001          ORR      r0,r0,#1              ;1761
000092  6825              LDR      r5,[r4,#0]            ;1761
000094  6028              STR      r0,[r5,#0]            ;1761
                  |L20.150|
000096  6820              LDR      r0,[r4,#0]            ;1765
000098  6800              LDR      r0,[r0,#0]            ;1765
00009a  f4206000          BIC      r0,r0,#0x800          ;1765
00009e  6825              LDR      r5,[r4,#0]            ;1765
0000a0  6028              STR      r0,[r5,#0]            ;1765
0000a2  2022              MOVS     r0,#0x22              ;1767
0000a4  f884003d          STRB     r0,[r4,#0x3d]         ;1767
0000a8  2010              MOVS     r0,#0x10              ;1768
0000aa  f884003e          STRB     r0,[r4,#0x3e]         ;1768
0000ae  2000              MOVS     r0,#0                 ;1769
0000b0  6420              STR      r0,[r4,#0x40]         ;1769
0000b2  6262              STR      r2,[r4,#0x24]         ;1772
0000b4  8563              STRH     r3,[r4,#0x2a]         ;1773
0000b6  8d60              LDRH     r0,[r4,#0x2a]         ;1774
0000b8  8520              STRH     r0,[r4,#0x28]         ;1774
0000ba  4810              LDR      r0,|L20.252|
0000bc  62e0              STR      r0,[r4,#0x2c]         ;1775
0000be  6461              STR      r1,[r4,#0x44]         ;1776
0000c0  bf00              NOP                            ;1780
0000c2  2000              MOVS     r0,#0                 ;1780
0000c4  f884003c          STRB     r0,[r4,#0x3c]         ;1780
0000c8  bf00              NOP                            ;1780
0000ca  6820              LDR      r0,[r4,#0]            ;1787
0000cc  6840              LDR      r0,[r0,#4]            ;1787
0000ce  f44060e0          ORR      r0,r0,#0x700          ;1787
0000d2  6825              LDR      r5,[r4,#0]            ;1787
0000d4  6068              STR      r0,[r5,#4]            ;1787
0000d6  6820              LDR      r0,[r4,#0]            ;1790
0000d8  6800              LDR      r0,[r0,#0]            ;1790
0000da  f4406080          ORR      r0,r0,#0x400          ;1790
0000de  6825              LDR      r5,[r4,#0]            ;1790
0000e0  6028              STR      r0,[r5,#0]            ;1790
0000e2  6820              LDR      r0,[r4,#0]            ;1793
0000e4  6800              LDR      r0,[r0,#0]            ;1793
0000e6  f4407080          ORR      r0,r0,#0x100          ;1793
0000ea  6825              LDR      r5,[r4,#0]            ;1793
0000ec  6028              STR      r0,[r5,#0]            ;1793
0000ee  2000              MOVS     r0,#0                 ;1795
0000f0  e7b4              B        |L20.92|
0000f2  e7ff              B        |L20.244|
                  |L20.244|
0000f4  2002              MOVS     r0,#2                 ;1799
0000f6  e7b1              B        |L20.92|
;;;1802   
                          ENDP

                  |L20.248|
                          DCD      SystemCoreClock
                  |L20.252|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Master_Seq_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Receive_DMA PROC
;;;3960     */
;;;3961   HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3962   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;3963     __IO uint32_t Prev_State = 0x00U;
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
;;;3964     __IO uint32_t count = 0U;
000012  9000              STR      r0,[sp,#0]
;;;3965     uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000014  f44f6ae0          MOV      r10,#0x700
;;;3966     HAL_StatusTypeDef dmaxferstatus;
;;;3967   
;;;3968     /* Check the parameters */
;;;3969     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3970   
;;;3971     if (hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d17c              BNE      |L21.282|
;;;3972     {
;;;3973       /* Check Busy Flag only if FIRST call of Master interface */
;;;3974       if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f4007000          AND      r0,r0,#0x200
000028  f5b07f00          CMP      r0,#0x200
00002c  d003              BEQ      |L21.54|
00002e  2d08              CMP      r5,#8
000030  d001              BEQ      |L21.54|
000032  2d01              CMP      r5,#1
000034  d12d              BNE      |L21.146|
                  |L21.54|
;;;3975       {
;;;3976         /* Wait until BUSY flag is reset */
;;;3977         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000036  489a              LDR      r0,|L21.672|
000038  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00003a  2119              MOVS     r1,#0x19
00003c  fbb0f0f1          UDIV     r0,r0,r1
000040  f44f717a          MOV      r1,#0x3e8
000044  fbb0f0f1          UDIV     r0,r0,r1
000048  eb0001c0          ADD      r1,r0,r0,LSL #3
00004c  eb011000          ADD      r0,r1,r0,LSL #4
000050  9000              STR      r0,[sp,#0]
;;;3978         do
000052  bf00              NOP      
                  |L21.84|
;;;3979         {
;;;3980           count--;
000054  9800              LDR      r0,[sp,#0]
000056  1e40              SUBS     r0,r0,#1
000058  9000              STR      r0,[sp,#0]
;;;3981           if (count == 0U)
00005a  9800              LDR      r0,[sp,#0]
00005c  b998              CBNZ     r0,|L21.134|
;;;3982           {
;;;3983             hi2c->PreviousState       = I2C_STATE_NONE;
00005e  2000              MOVS     r0,#0
000060  6320              STR      r0,[r4,#0x30]
;;;3984             hi2c->State               = HAL_I2C_STATE_READY;
000062  2020              MOVS     r0,#0x20
000064  f884003d          STRB     r0,[r4,#0x3d]
;;;3985             hi2c->Mode                = HAL_I2C_MODE_NONE;
000068  2000              MOVS     r0,#0
00006a  f884003e          STRB     r0,[r4,#0x3e]
;;;3986             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00006e  6c20              LDR      r0,[r4,#0x40]
000070  f0400020          ORR      r0,r0,#0x20
000074  6420              STR      r0,[r4,#0x40]
;;;3987   
;;;3988             /* Process Unlocked */
;;;3989             __HAL_UNLOCK(hi2c);
000076  bf00              NOP      
000078  2000              MOVS     r0,#0
00007a  f884003c          STRB     r0,[r4,#0x3c]
00007e  bf00              NOP      
;;;3990   
;;;3991             return HAL_ERROR;
000080  2001              MOVS     r0,#1
                  |L21.130|
;;;3992           }
;;;3993         }
;;;3994         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3995       }
;;;3996   
;;;3997       /* Process Locked */
;;;3998       __HAL_LOCK(hi2c);
;;;3999   
;;;4000       /* Check if the I2C is already enabled */
;;;4001       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4002       {
;;;4003         /* Enable I2C peripheral */
;;;4004         __HAL_I2C_ENABLE(hi2c);
;;;4005       }
;;;4006   
;;;4007       /* Disable Pos */
;;;4008       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4009   
;;;4010       /* Clear Last DMA bit */
;;;4011       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;4012   
;;;4013       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;4014       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;4015       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4016   
;;;4017       /* Prepare transfer parameters */
;;;4018       hi2c->pBuffPtr    = pData;
;;;4019       hi2c->XferCount   = Size;
;;;4020       hi2c->XferSize    = hi2c->XferCount;
;;;4021       hi2c->XferOptions = XferOptions;
;;;4022       hi2c->Devaddress  = DevAddress;
;;;4023   
;;;4024       Prev_State = hi2c->PreviousState;
;;;4025   
;;;4026       if (hi2c->XferSize > 0U)
;;;4027       {
;;;4028         if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
;;;4029         {
;;;4030           if (Prev_State == I2C_STATE_MASTER_BUSY_RX)
;;;4031           {
;;;4032             /* Disable Acknowledge */
;;;4033             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4034   
;;;4035             /* Enable Pos */
;;;4036             SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4037   
;;;4038             /* Enable Last DMA bit */
;;;4039             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;4040           }
;;;4041           else
;;;4042           {
;;;4043             /* Enable Acknowledge */
;;;4044             SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4045           }
;;;4046         }
;;;4047         else
;;;4048         {
;;;4049           /* Enable Acknowledge */
;;;4050           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4051   
;;;4052           if ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_OTHER_AND_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
;;;4053           {
;;;4054             /* Enable Last DMA bit */
;;;4055             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;4056           }
;;;4057         }
;;;4058         if (hi2c->hdmarx != NULL)
;;;4059         {
;;;4060           /* Set the I2C DMA transfer complete callback */
;;;4061           hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;4062   
;;;4063           /* Set the DMA error callback */
;;;4064           hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;4065   
;;;4066           /* Set the unused DMA callbacks to NULL */
;;;4067           hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;4068           hi2c->hdmarx->XferAbortCallback = NULL;
;;;4069   
;;;4070           /* Enable the DMA stream */
;;;4071           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;4072         }
;;;4073         else
;;;4074         {
;;;4075           /* Update I2C state */
;;;4076           hi2c->State     = HAL_I2C_STATE_READY;
;;;4077           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4078   
;;;4079           /* Update I2C error code */
;;;4080           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;4081   
;;;4082           /* Process Unlocked */
;;;4083           __HAL_UNLOCK(hi2c);
;;;4084   
;;;4085           return HAL_ERROR;
;;;4086         }
;;;4087         if (dmaxferstatus == HAL_OK)
;;;4088         {
;;;4089           /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;4090           /* Mean Previous state is same as current state */
;;;4091           if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;4092           {
;;;4093             /* Generate Start */
;;;4094             SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;4095   
;;;4096             /* Update interrupt for only EVT and ERR */
;;;4097             enableIT = (I2C_IT_EVT | I2C_IT_ERR);
;;;4098           }
;;;4099           else
;;;4100           {
;;;4101             /* Update interrupt for only ERR */
;;;4102             enableIT = I2C_IT_ERR;
;;;4103           }
;;;4104   
;;;4105           /* Process Unlocked */
;;;4106           __HAL_UNLOCK(hi2c);
;;;4107   
;;;4108           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4109           to avoid the risk of I2C interrupt handle execution before current
;;;4110           process unlock */
;;;4111   
;;;4112           /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
;;;4113           /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
;;;4114           if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
;;;4115           {
;;;4116             /* Enable DMA Request */
;;;4117             SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4118           }
;;;4119   
;;;4120           /* Enable EVT and ERR interrupt */
;;;4121           __HAL_I2C_ENABLE_IT(hi2c, enableIT);
;;;4122         }
;;;4123         else
;;;4124         {
;;;4125           /* Update I2C state */
;;;4126           hi2c->State     = HAL_I2C_STATE_READY;
;;;4127           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4128   
;;;4129           /* Update I2C error code */
;;;4130           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;4131   
;;;4132           /* Process Unlocked */
;;;4133           __HAL_UNLOCK(hi2c);
;;;4134   
;;;4135           return HAL_ERROR;
;;;4136         }
;;;4137       }
;;;4138       else
;;;4139       {
;;;4140         /* Enable Acknowledge */
;;;4141         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4142   
;;;4143         /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;4144         /* Mean Previous state is same as current state */
;;;4145         if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;4146         {
;;;4147           /* Generate Start */
;;;4148           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;4149         }
;;;4150   
;;;4151         /* Process Unlocked */
;;;4152         __HAL_UNLOCK(hi2c);
;;;4153   
;;;4154         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4155         to avoid the risk of I2C interrupt handle execution before current
;;;4156         process unlock */
;;;4157   
;;;4158         /* Enable interrupts */
;;;4159         __HAL_I2C_ENABLE_IT(hi2c, enableIT);
;;;4160       }
;;;4161       return HAL_OK;
;;;4162     }
;;;4163     else
;;;4164     {
;;;4165       return HAL_BUSY;
;;;4166     }
;;;4167   }
000082  e8bd87fc          POP      {r2-r10,pc}
                  |L21.134|
000086  6820              LDR      r0,[r4,#0]            ;3994
000088  6980              LDR      r0,[r0,#0x18]         ;3994
00008a  f3c00040          UBFX     r0,r0,#1,#1           ;3994
00008e  2800              CMP      r0,#0                 ;3994
000090  d1e0              BNE      |L21.84|
                  |L21.146|
000092  bf00              NOP                            ;3998
000094  f894003c          LDRB     r0,[r4,#0x3c]         ;3998
000098  2801              CMP      r0,#1                 ;3998
00009a  d101              BNE      |L21.160|
00009c  2002              MOVS     r0,#2                 ;3998
00009e  e7f0              B        |L21.130|
                  |L21.160|
0000a0  2001              MOVS     r0,#1                 ;3998
0000a2  f884003c          STRB     r0,[r4,#0x3c]         ;3998
0000a6  bf00              NOP                            ;3998
0000a8  6820              LDR      r0,[r4,#0]            ;4001
0000aa  6800              LDR      r0,[r0,#0]            ;4001
0000ac  f0000001          AND      r0,r0,#1              ;4001
0000b0  b928              CBNZ     r0,|L21.190|
0000b2  6820              LDR      r0,[r4,#0]            ;4004
0000b4  6800              LDR      r0,[r0,#0]            ;4004
0000b6  f0400001          ORR      r0,r0,#1              ;4004
0000ba  6821              LDR      r1,[r4,#0]            ;4004
0000bc  6008              STR      r0,[r1,#0]            ;4004
                  |L21.190|
0000be  6820              LDR      r0,[r4,#0]            ;4008
0000c0  6800              LDR      r0,[r0,#0]            ;4008
0000c2  f4206000          BIC      r0,r0,#0x800          ;4008
0000c6  6821              LDR      r1,[r4,#0]            ;4008
0000c8  6008              STR      r0,[r1,#0]            ;4008
0000ca  6820              LDR      r0,[r4,#0]            ;4011
0000cc  6840              LDR      r0,[r0,#4]            ;4011
0000ce  f4205080          BIC      r0,r0,#0x1000         ;4011
0000d2  6821              LDR      r1,[r4,#0]            ;4011
0000d4  6048              STR      r0,[r1,#4]            ;4011
0000d6  2022              MOVS     r0,#0x22              ;4013
0000d8  f884003d          STRB     r0,[r4,#0x3d]         ;4013
0000dc  2010              MOVS     r0,#0x10              ;4014
0000de  f884003e          STRB     r0,[r4,#0x3e]         ;4014
0000e2  2000              MOVS     r0,#0                 ;4015
0000e4  6420              STR      r0,[r4,#0x40]         ;4015
0000e6  f8c48024          STR      r8,[r4,#0x24]         ;4018
0000ea  f8a4902a          STRH     r9,[r4,#0x2a]         ;4019
0000ee  8d60              LDRH     r0,[r4,#0x2a]         ;4020
0000f0  8520              STRH     r0,[r4,#0x28]         ;4020
0000f2  62e5              STR      r5,[r4,#0x2c]         ;4021
0000f4  6467              STR      r7,[r4,#0x44]         ;4022
0000f6  6b20              LDR      r0,[r4,#0x30]         ;4024
0000f8  9001              STR      r0,[sp,#4]            ;4024
0000fa  8d20              LDRH     r0,[r4,#0x28]         ;4026
0000fc  2800              CMP      r0,#0                 ;4026
0000fe  d079              BEQ      |L21.500|
000100  8d60              LDRH     r0,[r4,#0x2a]         ;4028
000102  2802              CMP      r0,#2                 ;4028
000104  d122              BNE      |L21.332|
000106  2d20              CMP      r5,#0x20              ;4028
000108  d001              BEQ      |L21.270|
00010a  2d10              CMP      r5,#0x10              ;4028
00010c  d11e              BNE      |L21.332|
                  |L21.270|
00010e  9801              LDR      r0,[sp,#4]            ;4030
000110  2812              CMP      r0,#0x12              ;4030
000112  d114              BNE      |L21.318|
000114  6820              LDR      r0,[r4,#0]            ;4033
000116  6800              LDR      r0,[r0,#0]            ;4033
000118  e000              B        |L21.284|
                  |L21.282|
00011a  e0bf              B        |L21.668|
                  |L21.284|
00011c  f4206080          BIC      r0,r0,#0x400          ;4033
000120  6821              LDR      r1,[r4,#0]            ;4033
000122  6008              STR      r0,[r1,#0]            ;4033
000124  6820              LDR      r0,[r4,#0]            ;4036
000126  6800              LDR      r0,[r0,#0]            ;4036
000128  f4406000          ORR      r0,r0,#0x800          ;4036
00012c  6821              LDR      r1,[r4,#0]            ;4036
00012e  6008              STR      r0,[r1,#0]            ;4036
000130  6820              LDR      r0,[r4,#0]            ;4039
000132  6840              LDR      r0,[r0,#4]            ;4039
000134  f4405080          ORR      r0,r0,#0x1000         ;4039
000138  6821              LDR      r1,[r4,#0]            ;4039
00013a  6048              STR      r0,[r1,#4]            ;4039
00013c  e019              B        |L21.370|
                  |L21.318|
00013e  6820              LDR      r0,[r4,#0]            ;4044
000140  6800              LDR      r0,[r0,#0]            ;4044
000142  f4406080          ORR      r0,r0,#0x400          ;4044
000146  6821              LDR      r1,[r4,#0]            ;4044
000148  6008              STR      r0,[r1,#0]            ;4044
00014a  e012              B        |L21.370|
                  |L21.332|
00014c  6820              LDR      r0,[r4,#0]            ;4050
00014e  6800              LDR      r0,[r0,#0]            ;4050
000150  f4406080          ORR      r0,r0,#0x400          ;4050
000154  6821              LDR      r1,[r4,#0]            ;4050
000156  6008              STR      r0,[r1,#0]            ;4050
000158  2d20              CMP      r5,#0x20              ;4052
00015a  d004              BEQ      |L21.358|
00015c  f1b54f2a          CMP      r5,#0xaa000000        ;4052
000160  d001              BEQ      |L21.358|
000162  2d10              CMP      r5,#0x10              ;4052
000164  d105              BNE      |L21.370|
                  |L21.358|
000166  6820              LDR      r0,[r4,#0]            ;4055
000168  6840              LDR      r0,[r0,#4]            ;4055
00016a  f4405080          ORR      r0,r0,#0x1000         ;4055
00016e  6821              LDR      r1,[r4,#0]            ;4055
000170  6048              STR      r0,[r1,#4]            ;4055
                  |L21.370|
000172  6ba0              LDR      r0,[r4,#0x38]         ;4058
000174  b1a8              CBZ      r0,|L21.418|
000176  484b              LDR      r0,|L21.676|
000178  6ba1              LDR      r1,[r4,#0x38]         ;4061
00017a  63c8              STR      r0,[r1,#0x3c]         ;4061
00017c  484a              LDR      r0,|L21.680|
00017e  6ba1              LDR      r1,[r4,#0x38]         ;4064
000180  64c8              STR      r0,[r1,#0x4c]         ;4064
000182  2000              MOVS     r0,#0                 ;4067
000184  6ba1              LDR      r1,[r4,#0x38]         ;4067
000186  6408              STR      r0,[r1,#0x40]         ;4067
000188  6ba1              LDR      r1,[r4,#0x38]         ;4068
00018a  6508              STR      r0,[r1,#0x50]         ;4068
00018c  8d23              LDRH     r3,[r4,#0x28]         ;4071
00018e  f8d4c000          LDR      r12,[r4,#0]           ;4071
000192  f10c0110          ADD      r1,r12,#0x10          ;4071
000196  6a62              LDR      r2,[r4,#0x24]         ;4071
000198  6ba0              LDR      r0,[r4,#0x38]         ;4071
00019a  f7fffffe          BL       HAL_DMA_Start_IT
00019e  4606              MOV      r6,r0                 ;4071
0001a0  e010              B        |L21.452|
                  |L21.418|
0001a2  2020              MOVS     r0,#0x20              ;4076
0001a4  f884003d          STRB     r0,[r4,#0x3d]         ;4076
0001a8  2000              MOVS     r0,#0                 ;4077
0001aa  f884003e          STRB     r0,[r4,#0x3e]         ;4077
0001ae  6c20              LDR      r0,[r4,#0x40]         ;4080
0001b0  f0400080          ORR      r0,r0,#0x80           ;4080
0001b4  6420              STR      r0,[r4,#0x40]         ;4080
0001b6  bf00              NOP                            ;4083
0001b8  2000              MOVS     r0,#0                 ;4083
0001ba  f884003c          STRB     r0,[r4,#0x3c]         ;4083
0001be  bf00              NOP                            ;4083
0001c0  2001              MOVS     r0,#1                 ;4085
0001c2  e75e              B        |L21.130|
                  |L21.452|
0001c4  bb8e              CBNZ     r6,|L21.554|
0001c6  9801              LDR      r0,[sp,#4]            ;4091
0001c8  2812              CMP      r0,#0x12              ;4091
0001ca  d10a              BNE      |L21.482|
0001cc  f5b50f2a          CMP      r5,#0xaa0000          ;4091
0001d0  d002              BEQ      |L21.472|
0001d2  f1b54f2a          CMP      r5,#0xaa000000        ;4091
0001d6  d101              BNE      |L21.476|
                  |L21.472|
0001d8  2001              MOVS     r0,#1                 ;4091
0001da  e000              B        |L21.478|
                  |L21.476|
0001dc  2000              MOVS     r0,#0                 ;4091
                  |L21.478|
0001de  2801              CMP      r0,#1                 ;4091
0001e0  d109              BNE      |L21.502|
                  |L21.482|
0001e2  6820              LDR      r0,[r4,#0]            ;4094
0001e4  6800              LDR      r0,[r0,#0]            ;4094
0001e6  f4407080          ORR      r0,r0,#0x100          ;4094
0001ea  6821              LDR      r1,[r4,#0]            ;4094
0001ec  6008              STR      r0,[r1,#0]            ;4094
0001ee  f44f7a40          MOV      r10,#0x300            ;4097
0001f2  e002              B        |L21.506|
                  |L21.500|
0001f4  e02b              B        |L21.590|
                  |L21.502|
0001f6  f44f7a80          MOV      r10,#0x100            ;4102
                  |L21.506|
0001fa  bf00              NOP                            ;4106
0001fc  2000              MOVS     r0,#0                 ;4106
0001fe  f884003c          STRB     r0,[r4,#0x3c]         ;4106
000202  bf00              NOP                            ;4106
000204  2d04              CMP      r5,#4                 ;4114
000206  d003              BEQ      |L21.528|
000208  2d20              CMP      r5,#0x20              ;4114
00020a  d001              BEQ      |L21.528|
00020c  2d10              CMP      r5,#0x10              ;4114
00020e  d105              BNE      |L21.540|
                  |L21.528|
000210  6820              LDR      r0,[r4,#0]            ;4117
000212  6840              LDR      r0,[r0,#4]            ;4117
000214  f4406000          ORR      r0,r0,#0x800          ;4117
000218  6821              LDR      r1,[r4,#0]            ;4117
00021a  6048              STR      r0,[r1,#4]            ;4117
                  |L21.540|
00021c  6820              LDR      r0,[r4,#0]            ;4121
00021e  6840              LDR      r0,[r0,#4]            ;4121
000220  ea40000a          ORR      r0,r0,r10             ;4121
000224  6821              LDR      r1,[r4,#0]            ;4121
000226  6048              STR      r0,[r1,#4]            ;4121
000228  e036              B        |L21.664|
                  |L21.554|
00022a  e7ff              B        |L21.556|
                  |L21.556|
00022c  2020              MOVS     r0,#0x20              ;4126
00022e  f884003d          STRB     r0,[r4,#0x3d]         ;4126
000232  2000              MOVS     r0,#0                 ;4127
000234  f884003e          STRB     r0,[r4,#0x3e]         ;4127
000238  6c20              LDR      r0,[r4,#0x40]         ;4130
00023a  f0400010          ORR      r0,r0,#0x10           ;4130
00023e  6420              STR      r0,[r4,#0x40]         ;4130
000240  bf00              NOP                            ;4133
000242  2000              MOVS     r0,#0                 ;4133
000244  f884003c          STRB     r0,[r4,#0x3c]         ;4133
000248  bf00              NOP                            ;4133
00024a  2001              MOVS     r0,#1                 ;4135
00024c  e719              B        |L21.130|
                  |L21.590|
00024e  6820              LDR      r0,[r4,#0]            ;4141
000250  6800              LDR      r0,[r0,#0]            ;4141
000252  f4406080          ORR      r0,r0,#0x400          ;4141
000256  6821              LDR      r1,[r4,#0]            ;4141
000258  6008              STR      r0,[r1,#0]            ;4141
00025a  9801              LDR      r0,[sp,#4]            ;4145
00025c  2812              CMP      r0,#0x12              ;4145
00025e  d10a              BNE      |L21.630|
000260  f5b50f2a          CMP      r5,#0xaa0000          ;4145
000264  d002              BEQ      |L21.620|
000266  f1b54f2a          CMP      r5,#0xaa000000        ;4145
00026a  d101              BNE      |L21.624|
                  |L21.620|
00026c  2001              MOVS     r0,#1                 ;4145
00026e  e000              B        |L21.626|
                  |L21.624|
000270  2000              MOVS     r0,#0                 ;4145
                  |L21.626|
000272  2801              CMP      r0,#1                 ;4145
000274  d105              BNE      |L21.642|
                  |L21.630|
000276  6820              LDR      r0,[r4,#0]            ;4148
000278  6800              LDR      r0,[r0,#0]            ;4148
00027a  f4407080          ORR      r0,r0,#0x100          ;4148
00027e  6821              LDR      r1,[r4,#0]            ;4148
000280  6008              STR      r0,[r1,#0]            ;4148
                  |L21.642|
000282  bf00              NOP                            ;4152
000284  2000              MOVS     r0,#0                 ;4152
000286  f884003c          STRB     r0,[r4,#0x3c]         ;4152
00028a  bf00              NOP                            ;4152
00028c  6820              LDR      r0,[r4,#0]            ;4159
00028e  6840              LDR      r0,[r0,#4]            ;4159
000290  ea40000a          ORR      r0,r0,r10             ;4159
000294  6821              LDR      r1,[r4,#0]            ;4159
000296  6048              STR      r0,[r1,#4]            ;4159
                  |L21.664|
000298  2000              MOVS     r0,#0                 ;4161
00029a  e6f2              B        |L21.130|
                  |L21.668|
00029c  2002              MOVS     r0,#2                 ;4165
00029e  e6f0              B        |L21.130|
;;;4168   
                          ENDP

                  |L21.672|
                          DCD      SystemCoreClock
                  |L21.676|
                          DCD      I2C_DMAXferCplt
                  |L21.680|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Seq_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Receive_IT PROC
;;;3836     */
;;;3837   HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b5fc              PUSH     {r2-r7,lr}
;;;3838   {
000002  4604              MOV      r4,r0
000004  9d07              LDR      r5,[sp,#0x1c]
;;;3839     __IO uint32_t Prev_State = 0x00U;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;3840     __IO uint32_t count = 0U;
00000a  9000              STR      r0,[sp,#0]
;;;3841     uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00000c  f44f66e0          MOV      r6,#0x700
;;;3842   
;;;3843     /* Check the parameters */
;;;3844     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3845   
;;;3846     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d17c              BNE      |L22.274|
;;;3847     {
;;;3848       /* Check Busy Flag only if FIRST call of Master interface */
;;;3849       if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
000018  6820              LDR      r0,[r4,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  f4007000          AND      r0,r0,#0x200
000020  f5b07f00          CMP      r0,#0x200
000024  d003              BEQ      |L22.46|
000026  2d08              CMP      r5,#8
000028  d001              BEQ      |L22.46|
00002a  2d01              CMP      r5,#1
00002c  d12c              BNE      |L22.136|
                  |L22.46|
;;;3850       {
;;;3851         /* Wait until BUSY flag is reset */
;;;3852         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
00002e  4851              LDR      r0,|L22.372|
000030  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000032  2719              MOVS     r7,#0x19
000034  fbb0f0f7          UDIV     r0,r0,r7
000038  f44f777a          MOV      r7,#0x3e8
00003c  fbb0f0f7          UDIV     r0,r0,r7
000040  eb0007c0          ADD      r7,r0,r0,LSL #3
000044  eb071000          ADD      r0,r7,r0,LSL #4
000048  9000              STR      r0,[sp,#0]
;;;3853         do
00004a  bf00              NOP      
                  |L22.76|
;;;3854         {
;;;3855           count--;
00004c  9800              LDR      r0,[sp,#0]
00004e  1e40              SUBS     r0,r0,#1
000050  9000              STR      r0,[sp,#0]
;;;3856           if (count == 0U)
000052  9800              LDR      r0,[sp,#0]
000054  b990              CBNZ     r0,|L22.124|
;;;3857           {
;;;3858             hi2c->PreviousState       = I2C_STATE_NONE;
000056  2000              MOVS     r0,#0
000058  6320              STR      r0,[r4,#0x30]
;;;3859             hi2c->State               = HAL_I2C_STATE_READY;
00005a  2020              MOVS     r0,#0x20
00005c  f884003d          STRB     r0,[r4,#0x3d]
;;;3860             hi2c->Mode                = HAL_I2C_MODE_NONE;
000060  2000              MOVS     r0,#0
000062  f884003e          STRB     r0,[r4,#0x3e]
;;;3861             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000066  6c20              LDR      r0,[r4,#0x40]
000068  f0400020          ORR      r0,r0,#0x20
00006c  6420              STR      r0,[r4,#0x40]
;;;3862   
;;;3863             /* Process Unlocked */
;;;3864             __HAL_UNLOCK(hi2c);
00006e  bf00              NOP      
000070  2000              MOVS     r0,#0
000072  f884003c          STRB     r0,[r4,#0x3c]
000076  bf00              NOP      
;;;3865   
;;;3866             return HAL_ERROR;
000078  2001              MOVS     r0,#1
                  |L22.122|
;;;3867           }
;;;3868         }
;;;3869         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3870       }
;;;3871   
;;;3872       /* Process Locked */
;;;3873       __HAL_LOCK(hi2c);
;;;3874   
;;;3875       /* Check if the I2C is already enabled */
;;;3876       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3877       {
;;;3878         /* Enable I2C peripheral */
;;;3879         __HAL_I2C_ENABLE(hi2c);
;;;3880       }
;;;3881   
;;;3882       /* Disable Pos */
;;;3883       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3884   
;;;3885       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3886       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3887       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3888   
;;;3889       /* Prepare transfer parameters */
;;;3890       hi2c->pBuffPtr    = pData;
;;;3891       hi2c->XferCount   = Size;
;;;3892       hi2c->XferSize    = hi2c->XferCount;
;;;3893       hi2c->XferOptions = XferOptions;
;;;3894       hi2c->Devaddress  = DevAddress;
;;;3895   
;;;3896       Prev_State = hi2c->PreviousState;
;;;3897   
;;;3898       if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
;;;3899       {
;;;3900         if (Prev_State == I2C_STATE_MASTER_BUSY_RX)
;;;3901         {
;;;3902           /* Disable Acknowledge */
;;;3903           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3904   
;;;3905           /* Enable Pos */
;;;3906           SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3907   
;;;3908           /* Remove Enabling of IT_BUF, mean RXNE treatment, treat the 2 bytes through BTF */
;;;3909           enableIT &= ~I2C_IT_BUF;
;;;3910         }
;;;3911         else
;;;3912         {
;;;3913           /* Enable Acknowledge */
;;;3914           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3915         }
;;;3916       }
;;;3917       else
;;;3918       {
;;;3919         /* Enable Acknowledge */
;;;3920         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3921       }
;;;3922   
;;;3923       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3924       /* Mean Previous state is same as current state */
;;;3925       if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3926       {
;;;3927         /* Generate Start */
;;;3928         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3929       }
;;;3930   
;;;3931       /* Process Unlocked */
;;;3932       __HAL_UNLOCK(hi2c);
;;;3933   
;;;3934       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3935       to avoid the risk of I2C interrupt handle execution before current
;;;3936       process unlock */
;;;3937   
;;;3938       /* Enable interrupts */
;;;3939       __HAL_I2C_ENABLE_IT(hi2c, enableIT);
;;;3940   
;;;3941       return HAL_OK;
;;;3942     }
;;;3943     else
;;;3944     {
;;;3945       return HAL_BUSY;
;;;3946     }
;;;3947   }
00007a  bdfc              POP      {r2-r7,pc}
                  |L22.124|
00007c  6820              LDR      r0,[r4,#0]            ;3869
00007e  6980              LDR      r0,[r0,#0x18]         ;3869
000080  f3c00040          UBFX     r0,r0,#1,#1           ;3869
000084  2800              CMP      r0,#0                 ;3869
000086  d1e1              BNE      |L22.76|
                  |L22.136|
000088  bf00              NOP                            ;3873
00008a  f894003c          LDRB     r0,[r4,#0x3c]         ;3873
00008e  2801              CMP      r0,#1                 ;3873
000090  d101              BNE      |L22.150|
000092  2002              MOVS     r0,#2                 ;3873
000094  e7f1              B        |L22.122|
                  |L22.150|
000096  2001              MOVS     r0,#1                 ;3873
000098  f884003c          STRB     r0,[r4,#0x3c]         ;3873
00009c  bf00              NOP                            ;3873
00009e  6820              LDR      r0,[r4,#0]            ;3876
0000a0  6800              LDR      r0,[r0,#0]            ;3876
0000a2  f0000001          AND      r0,r0,#1              ;3876
0000a6  b928              CBNZ     r0,|L22.180|
0000a8  6820              LDR      r0,[r4,#0]            ;3879
0000aa  6800              LDR      r0,[r0,#0]            ;3879
0000ac  f0400001          ORR      r0,r0,#1              ;3879
0000b0  6827              LDR      r7,[r4,#0]            ;3879
0000b2  6038              STR      r0,[r7,#0]            ;3879
                  |L22.180|
0000b4  6820              LDR      r0,[r4,#0]            ;3883
0000b6  6800              LDR      r0,[r0,#0]            ;3883
0000b8  f4206000          BIC      r0,r0,#0x800          ;3883
0000bc  6827              LDR      r7,[r4,#0]            ;3883
0000be  6038              STR      r0,[r7,#0]            ;3883
0000c0  2022              MOVS     r0,#0x22              ;3885
0000c2  f884003d          STRB     r0,[r4,#0x3d]         ;3885
0000c6  2010              MOVS     r0,#0x10              ;3886
0000c8  f884003e          STRB     r0,[r4,#0x3e]         ;3886
0000cc  2000              MOVS     r0,#0                 ;3887
0000ce  6420              STR      r0,[r4,#0x40]         ;3887
0000d0  6262              STR      r2,[r4,#0x24]         ;3890
0000d2  8563              STRH     r3,[r4,#0x2a]         ;3891
0000d4  8d60              LDRH     r0,[r4,#0x2a]         ;3892
0000d6  8520              STRH     r0,[r4,#0x28]         ;3892
0000d8  62e5              STR      r5,[r4,#0x2c]         ;3893
0000da  6461              STR      r1,[r4,#0x44]         ;3894
0000dc  6b20              LDR      r0,[r4,#0x30]         ;3896
0000de  9001              STR      r0,[sp,#4]            ;3896
0000e0  8d60              LDRH     r0,[r4,#0x2a]         ;3898
0000e2  2802              CMP      r0,#2                 ;3898
0000e4  d11d              BNE      |L22.290|
0000e6  2d20              CMP      r5,#0x20              ;3898
0000e8  d001              BEQ      |L22.238|
0000ea  2d10              CMP      r5,#0x10              ;3898
0000ec  d119              BNE      |L22.290|
                  |L22.238|
0000ee  9801              LDR      r0,[sp,#4]            ;3900
0000f0  2812              CMP      r0,#0x12              ;3900
0000f2  d10f              BNE      |L22.276|
0000f4  6820              LDR      r0,[r4,#0]            ;3903
0000f6  6800              LDR      r0,[r0,#0]            ;3903
0000f8  f4206080          BIC      r0,r0,#0x400          ;3903
0000fc  6827              LDR      r7,[r4,#0]            ;3903
0000fe  6038              STR      r0,[r7,#0]            ;3903
000100  6820              LDR      r0,[r4,#0]            ;3906
000102  6800              LDR      r0,[r0,#0]            ;3906
000104  f4406000          ORR      r0,r0,#0x800          ;3906
000108  6827              LDR      r7,[r4,#0]            ;3906
00010a  6038              STR      r0,[r7,#0]            ;3906
00010c  f4266680          BIC      r6,r6,#0x400          ;3909
000110  e00d              B        |L22.302|
                  |L22.274|
000112  e02c              B        |L22.366|
                  |L22.276|
000114  6820              LDR      r0,[r4,#0]            ;3914
000116  6800              LDR      r0,[r0,#0]            ;3914
000118  f4406080          ORR      r0,r0,#0x400          ;3914
00011c  6827              LDR      r7,[r4,#0]            ;3914
00011e  6038              STR      r0,[r7,#0]            ;3914
000120  e005              B        |L22.302|
                  |L22.290|
000122  6820              LDR      r0,[r4,#0]            ;3920
000124  6800              LDR      r0,[r0,#0]            ;3920
000126  f4406080          ORR      r0,r0,#0x400          ;3920
00012a  6827              LDR      r7,[r4,#0]            ;3920
00012c  6038              STR      r0,[r7,#0]            ;3920
                  |L22.302|
00012e  9801              LDR      r0,[sp,#4]            ;3925
000130  2812              CMP      r0,#0x12              ;3925
000132  d10a              BNE      |L22.330|
000134  f5b50f2a          CMP      r5,#0xaa0000          ;3925
000138  d002              BEQ      |L22.320|
00013a  f1b54f2a          CMP      r5,#0xaa000000        ;3925
00013e  d101              BNE      |L22.324|
                  |L22.320|
000140  2001              MOVS     r0,#1                 ;3925
000142  e000              B        |L22.326|
                  |L22.324|
000144  2000              MOVS     r0,#0                 ;3925
                  |L22.326|
000146  2801              CMP      r0,#1                 ;3925
000148  d105              BNE      |L22.342|
                  |L22.330|
00014a  6820              LDR      r0,[r4,#0]            ;3928
00014c  6800              LDR      r0,[r0,#0]            ;3928
00014e  f4407080          ORR      r0,r0,#0x100          ;3928
000152  6827              LDR      r7,[r4,#0]            ;3928
000154  6038              STR      r0,[r7,#0]            ;3928
                  |L22.342|
000156  bf00              NOP                            ;3932
000158  2000              MOVS     r0,#0                 ;3932
00015a  f884003c          STRB     r0,[r4,#0x3c]         ;3932
00015e  bf00              NOP                            ;3932
000160  6820              LDR      r0,[r4,#0]            ;3939
000162  6840              LDR      r0,[r0,#4]            ;3939
000164  4330              ORRS     r0,r0,r6              ;3939
000166  6827              LDR      r7,[r4,#0]            ;3939
000168  6078              STR      r0,[r7,#4]            ;3939
00016a  2000              MOVS     r0,#0                 ;3941
00016c  e785              B        |L22.122|
                  |L22.366|
00016e  2002              MOVS     r0,#2                 ;3945
000170  e783              B        |L22.122|
;;;3948   
                          ENDP

000172  0000              DCW      0x0000
                  |L22.372|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_I2C_Master_Seq_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Transmit_DMA PROC
;;;3653     */
;;;3654   HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3655   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;3656     __IO uint32_t Prev_State = 0x00U;
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
;;;3657     __IO uint32_t count      = 0x00U;
000012  9000              STR      r0,[sp,#0]
;;;3658     HAL_StatusTypeDef dmaxferstatus;
;;;3659   
;;;3660     /* Check the parameters */
;;;3661     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3662   
;;;3663     if (hi2c->State == HAL_I2C_STATE_READY)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2820              CMP      r0,#0x20
00001a  d17d              BNE      |L23.280|
;;;3664     {
;;;3665       /* Check Busy Flag only if FIRST call of Master interface */
;;;3666       if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
00001c  6820              LDR      r0,[r4,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  f4007000          AND      r0,r0,#0x200
000024  f5b07f00          CMP      r0,#0x200
000028  d003              BEQ      |L23.50|
00002a  2d08              CMP      r5,#8
00002c  d001              BEQ      |L23.50|
00002e  2d01              CMP      r5,#1
000030  d12d              BNE      |L23.142|
                  |L23.50|
;;;3667       {
;;;3668         /* Wait until BUSY flag is reset */
;;;3669         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000032  487c              LDR      r0,|L23.548|
000034  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000036  2119              MOVS     r1,#0x19
000038  fbb0f0f1          UDIV     r0,r0,r1
00003c  f44f717a          MOV      r1,#0x3e8
000040  fbb0f0f1          UDIV     r0,r0,r1
000044  eb0001c0          ADD      r1,r0,r0,LSL #3
000048  eb011000          ADD      r0,r1,r0,LSL #4
00004c  9000              STR      r0,[sp,#0]
;;;3670         do
00004e  bf00              NOP      
                  |L23.80|
;;;3671         {
;;;3672           count--;
000050  9800              LDR      r0,[sp,#0]
000052  1e40              SUBS     r0,r0,#1
000054  9000              STR      r0,[sp,#0]
;;;3673           if (count == 0U)
000056  9800              LDR      r0,[sp,#0]
000058  b998              CBNZ     r0,|L23.130|
;;;3674           {
;;;3675             hi2c->PreviousState       = I2C_STATE_NONE;
00005a  2000              MOVS     r0,#0
00005c  6320              STR      r0,[r4,#0x30]
;;;3676             hi2c->State               = HAL_I2C_STATE_READY;
00005e  2020              MOVS     r0,#0x20
000060  f884003d          STRB     r0,[r4,#0x3d]
;;;3677             hi2c->Mode                = HAL_I2C_MODE_NONE;
000064  2000              MOVS     r0,#0
000066  f884003e          STRB     r0,[r4,#0x3e]
;;;3678             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00006a  6c20              LDR      r0,[r4,#0x40]
00006c  f0400020          ORR      r0,r0,#0x20
000070  6420              STR      r0,[r4,#0x40]
;;;3679   
;;;3680             /* Process Unlocked */
;;;3681             __HAL_UNLOCK(hi2c);
000072  bf00              NOP      
000074  2000              MOVS     r0,#0
000076  f884003c          STRB     r0,[r4,#0x3c]
00007a  bf00              NOP      
;;;3682   
;;;3683             return HAL_ERROR;
00007c  2001              MOVS     r0,#1
                  |L23.126|
;;;3684           }
;;;3685         }
;;;3686         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3687       }
;;;3688   
;;;3689       /* Process Locked */
;;;3690       __HAL_LOCK(hi2c);
;;;3691   
;;;3692       /* Check if the I2C is already enabled */
;;;3693       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3694       {
;;;3695         /* Enable I2C peripheral */
;;;3696         __HAL_I2C_ENABLE(hi2c);
;;;3697       }
;;;3698   
;;;3699       /* Disable Pos */
;;;3700       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3701   
;;;3702       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3703       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3704       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3705   
;;;3706       /* Prepare transfer parameters */
;;;3707       hi2c->pBuffPtr    = pData;
;;;3708       hi2c->XferCount   = Size;
;;;3709       hi2c->XferSize    = hi2c->XferCount;
;;;3710       hi2c->XferOptions = XferOptions;
;;;3711       hi2c->Devaddress  = DevAddress;
;;;3712   
;;;3713       Prev_State = hi2c->PreviousState;
;;;3714   
;;;3715       if (hi2c->XferSize > 0U)
;;;3716       {
;;;3717         if (hi2c->hdmatx != NULL)
;;;3718         {
;;;3719           /* Set the I2C DMA transfer complete callback */
;;;3720           hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;3721   
;;;3722           /* Set the DMA error callback */
;;;3723           hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;3724   
;;;3725           /* Set the unused DMA callbacks to NULL */
;;;3726           hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;3727           hi2c->hdmatx->XferAbortCallback = NULL;
;;;3728   
;;;3729           /* Enable the DMA stream */
;;;3730           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;3731         }
;;;3732         else
;;;3733         {
;;;3734           /* Update I2C state */
;;;3735           hi2c->State     = HAL_I2C_STATE_READY;
;;;3736           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3737   
;;;3738           /* Update I2C error code */
;;;3739           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;3740   
;;;3741           /* Process Unlocked */
;;;3742           __HAL_UNLOCK(hi2c);
;;;3743   
;;;3744           return HAL_ERROR;
;;;3745         }
;;;3746   
;;;3747         if (dmaxferstatus == HAL_OK)
;;;3748         {
;;;3749           /* Enable Acknowledge */
;;;3750           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3751   
;;;3752           /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3753           /* Mean Previous state is same as current state */
;;;3754           if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3755           {
;;;3756             /* Generate Start */
;;;3757             SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3758           }
;;;3759   
;;;3760           /* Process Unlocked */
;;;3761           __HAL_UNLOCK(hi2c);
;;;3762   
;;;3763           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3764           to avoid the risk of I2C interrupt handle execution before current
;;;3765           process unlock */
;;;3766   
;;;3767           /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
;;;3768           /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
;;;3769           if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
;;;3770           {
;;;3771             /* Enable DMA Request */
;;;3772             SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;3773           }
;;;3774   
;;;3775           /* Enable EVT and ERR interrupt */
;;;3776           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;3777         }
;;;3778         else
;;;3779         {
;;;3780           /* Update I2C state */
;;;3781           hi2c->State     = HAL_I2C_STATE_READY;
;;;3782           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3783   
;;;3784           /* Update I2C error code */
;;;3785           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3786   
;;;3787           /* Process Unlocked */
;;;3788           __HAL_UNLOCK(hi2c);
;;;3789   
;;;3790           return HAL_ERROR;
;;;3791         }
;;;3792       }
;;;3793       else
;;;3794       {
;;;3795         /* Enable Acknowledge */
;;;3796         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3797   
;;;3798         /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3799         /* Mean Previous state is same as current state */
;;;3800         if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3801         {
;;;3802           /* Generate Start */
;;;3803           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3804         }
;;;3805   
;;;3806         /* Process Unlocked */
;;;3807         __HAL_UNLOCK(hi2c);
;;;3808   
;;;3809         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3810         to avoid the risk of I2C interrupt handle execution before current
;;;3811         process unlock */
;;;3812   
;;;3813         /* Enable EVT, BUF and ERR interrupt */
;;;3814         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3815       }
;;;3816   
;;;3817       return HAL_OK;
;;;3818     }
;;;3819     else
;;;3820     {
;;;3821       return HAL_BUSY;
;;;3822     }
;;;3823   }
00007e  e8bd87fc          POP      {r2-r10,pc}
                  |L23.130|
000082  6820              LDR      r0,[r4,#0]            ;3686
000084  6980              LDR      r0,[r0,#0x18]         ;3686
000086  f3c00040          UBFX     r0,r0,#1,#1           ;3686
00008a  2800              CMP      r0,#0                 ;3686
00008c  d1e0              BNE      |L23.80|
                  |L23.142|
00008e  bf00              NOP                            ;3690
000090  f894003c          LDRB     r0,[r4,#0x3c]         ;3690
000094  2801              CMP      r0,#1                 ;3690
000096  d101              BNE      |L23.156|
000098  2002              MOVS     r0,#2                 ;3690
00009a  e7f0              B        |L23.126|
                  |L23.156|
00009c  2001              MOVS     r0,#1                 ;3690
00009e  f884003c          STRB     r0,[r4,#0x3c]         ;3690
0000a2  bf00              NOP                            ;3690
0000a4  6820              LDR      r0,[r4,#0]            ;3693
0000a6  6800              LDR      r0,[r0,#0]            ;3693
0000a8  f0000001          AND      r0,r0,#1              ;3693
0000ac  b928              CBNZ     r0,|L23.186|
0000ae  6820              LDR      r0,[r4,#0]            ;3696
0000b0  6800              LDR      r0,[r0,#0]            ;3696
0000b2  f0400001          ORR      r0,r0,#1              ;3696
0000b6  6821              LDR      r1,[r4,#0]            ;3696
0000b8  6008              STR      r0,[r1,#0]            ;3696
                  |L23.186|
0000ba  6820              LDR      r0,[r4,#0]            ;3700
0000bc  6800              LDR      r0,[r0,#0]            ;3700
0000be  f4206000          BIC      r0,r0,#0x800          ;3700
0000c2  6821              LDR      r1,[r4,#0]            ;3700
0000c4  6008              STR      r0,[r1,#0]            ;3700
0000c6  2021              MOVS     r0,#0x21              ;3702
0000c8  f884003d          STRB     r0,[r4,#0x3d]         ;3702
0000cc  2010              MOVS     r0,#0x10              ;3703
0000ce  f884003e          STRB     r0,[r4,#0x3e]         ;3703
0000d2  2000              MOVS     r0,#0                 ;3704
0000d4  6420              STR      r0,[r4,#0x40]         ;3704
0000d6  f8c48024          STR      r8,[r4,#0x24]         ;3707
0000da  f8a4902a          STRH     r9,[r4,#0x2a]         ;3708
0000de  8d60              LDRH     r0,[r4,#0x2a]         ;3709
0000e0  8520              STRH     r0,[r4,#0x28]         ;3709
0000e2  62e5              STR      r5,[r4,#0x2c]         ;3710
0000e4  6467              STR      r7,[r4,#0x44]         ;3711
0000e6  6b20              LDR      r0,[r4,#0x30]         ;3713
0000e8  9001              STR      r0,[sp,#4]            ;3713
0000ea  8d20              LDRH     r0,[r4,#0x28]         ;3715
0000ec  2800              CMP      r0,#0                 ;3715
0000ee  d070              BEQ      |L23.466|
0000f0  6b60              LDR      r0,[r4,#0x34]         ;3717
0000f2  b1b8              CBZ      r0,|L23.292|
0000f4  484c              LDR      r0,|L23.552|
0000f6  6b61              LDR      r1,[r4,#0x34]         ;3720
0000f8  63c8              STR      r0,[r1,#0x3c]         ;3720
0000fa  484c              LDR      r0,|L23.556|
0000fc  6b61              LDR      r1,[r4,#0x34]         ;3723
0000fe  64c8              STR      r0,[r1,#0x4c]         ;3723
000100  2000              MOVS     r0,#0                 ;3726
000102  6b61              LDR      r1,[r4,#0x34]         ;3726
000104  6408              STR      r0,[r1,#0x40]         ;3726
000106  6b61              LDR      r1,[r4,#0x34]         ;3727
000108  6508              STR      r0,[r1,#0x50]         ;3727
00010a  8d23              LDRH     r3,[r4,#0x28]         ;3730
00010c  f8d4c000          LDR      r12,[r4,#0]           ;3730
000110  f10c0210          ADD      r2,r12,#0x10          ;3730
000114  6a61              LDR      r1,[r4,#0x24]         ;3730
000116  e000              B        |L23.282|
                  |L23.280|
000118  e082              B        |L23.544|
                  |L23.282|
00011a  6b60              LDR      r0,[r4,#0x34]         ;3730
00011c  f7fffffe          BL       HAL_DMA_Start_IT
000120  4606              MOV      r6,r0                 ;3730
000122  e010              B        |L23.326|
                  |L23.292|
000124  2020              MOVS     r0,#0x20              ;3735
000126  f884003d          STRB     r0,[r4,#0x3d]         ;3735
00012a  2000              MOVS     r0,#0                 ;3736
00012c  f884003e          STRB     r0,[r4,#0x3e]         ;3736
000130  6c20              LDR      r0,[r4,#0x40]         ;3739
000132  f0400080          ORR      r0,r0,#0x80           ;3739
000136  6420              STR      r0,[r4,#0x40]         ;3739
000138  bf00              NOP                            ;3742
00013a  2000              MOVS     r0,#0                 ;3742
00013c  f884003c          STRB     r0,[r4,#0x3c]         ;3742
000140  bf00              NOP                            ;3742
000142  2001              MOVS     r0,#1                 ;3744
000144  e79b              B        |L23.126|
                  |L23.326|
000146  bb8e              CBNZ     r6,|L23.428|
000148  6820              LDR      r0,[r4,#0]            ;3750
00014a  6800              LDR      r0,[r0,#0]            ;3750
00014c  f4406080          ORR      r0,r0,#0x400          ;3750
000150  6821              LDR      r1,[r4,#0]            ;3750
000152  6008              STR      r0,[r1,#0]            ;3750
000154  9801              LDR      r0,[sp,#4]            ;3754
000156  2811              CMP      r0,#0x11              ;3754
000158  d10a              BNE      |L23.368|
00015a  f5b50f2a          CMP      r5,#0xaa0000          ;3754
00015e  d002              BEQ      |L23.358|
000160  f1b54f2a          CMP      r5,#0xaa000000        ;3754
000164  d101              BNE      |L23.362|
                  |L23.358|
000166  2001              MOVS     r0,#1                 ;3754
000168  e000              B        |L23.364|
                  |L23.362|
00016a  2000              MOVS     r0,#0                 ;3754
                  |L23.364|
00016c  2801              CMP      r0,#1                 ;3754
00016e  d105              BNE      |L23.380|
                  |L23.368|
000170  6820              LDR      r0,[r4,#0]            ;3757
000172  6800              LDR      r0,[r0,#0]            ;3757
000174  f4407080          ORR      r0,r0,#0x100          ;3757
000178  6821              LDR      r1,[r4,#0]            ;3757
00017a  6008              STR      r0,[r1,#0]            ;3757
                  |L23.380|
00017c  bf00              NOP                            ;3761
00017e  2000              MOVS     r0,#0                 ;3761
000180  f884003c          STRB     r0,[r4,#0x3c]         ;3761
000184  bf00              NOP                            ;3761
000186  2d04              CMP      r5,#4                 ;3769
000188  d003              BEQ      |L23.402|
00018a  2d20              CMP      r5,#0x20              ;3769
00018c  d001              BEQ      |L23.402|
00018e  2d10              CMP      r5,#0x10              ;3769
000190  d105              BNE      |L23.414|
                  |L23.402|
000192  6820              LDR      r0,[r4,#0]            ;3772
000194  6840              LDR      r0,[r0,#4]            ;3772
000196  f4406000          ORR      r0,r0,#0x800          ;3772
00019a  6821              LDR      r1,[r4,#0]            ;3772
00019c  6048              STR      r0,[r1,#4]            ;3772
                  |L23.414|
00019e  6820              LDR      r0,[r4,#0]            ;3776
0001a0  6840              LDR      r0,[r0,#4]            ;3776
0001a2  f4407040          ORR      r0,r0,#0x300          ;3776
0001a6  6821              LDR      r1,[r4,#0]            ;3776
0001a8  6048              STR      r0,[r1,#4]            ;3776
0001aa  e037              B        |L23.540|
                  |L23.428|
0001ac  e7ff              B        |L23.430|
                  |L23.430|
0001ae  2020              MOVS     r0,#0x20              ;3781
0001b0  f884003d          STRB     r0,[r4,#0x3d]         ;3781
0001b4  2000              MOVS     r0,#0                 ;3782
0001b6  f884003e          STRB     r0,[r4,#0x3e]         ;3782
0001ba  6c20              LDR      r0,[r4,#0x40]         ;3785
0001bc  f0400010          ORR      r0,r0,#0x10           ;3785
0001c0  6420              STR      r0,[r4,#0x40]         ;3785
0001c2  bf00              NOP                            ;3788
0001c4  2000              MOVS     r0,#0                 ;3788
0001c6  f884003c          STRB     r0,[r4,#0x3c]         ;3788
0001ca  bf00              NOP                            ;3788
0001cc  2001              MOVS     r0,#1                 ;3790
0001ce  e756              B        |L23.126|
0001d0  e7ff              B        |L23.466|
                  |L23.466|
0001d2  6820              LDR      r0,[r4,#0]            ;3796
0001d4  6800              LDR      r0,[r0,#0]            ;3796
0001d6  f4406080          ORR      r0,r0,#0x400          ;3796
0001da  6821              LDR      r1,[r4,#0]            ;3796
0001dc  6008              STR      r0,[r1,#0]            ;3796
0001de  9801              LDR      r0,[sp,#4]            ;3800
0001e0  2811              CMP      r0,#0x11              ;3800
0001e2  d10a              BNE      |L23.506|
0001e4  f5b50f2a          CMP      r5,#0xaa0000          ;3800
0001e8  d002              BEQ      |L23.496|
0001ea  f1b54f2a          CMP      r5,#0xaa000000        ;3800
0001ee  d101              BNE      |L23.500|
                  |L23.496|
0001f0  2001              MOVS     r0,#1                 ;3800
0001f2  e000              B        |L23.502|
                  |L23.500|
0001f4  2000              MOVS     r0,#0                 ;3800
                  |L23.502|
0001f6  2801              CMP      r0,#1                 ;3800
0001f8  d105              BNE      |L23.518|
                  |L23.506|
0001fa  6820              LDR      r0,[r4,#0]            ;3803
0001fc  6800              LDR      r0,[r0,#0]            ;3803
0001fe  f4407080          ORR      r0,r0,#0x100          ;3803
000202  6821              LDR      r1,[r4,#0]            ;3803
000204  6008              STR      r0,[r1,#0]            ;3803
                  |L23.518|
000206  bf00              NOP                            ;3807
000208  2000              MOVS     r0,#0                 ;3807
00020a  f884003c          STRB     r0,[r4,#0x3c]         ;3807
00020e  bf00              NOP                            ;3807
000210  6820              LDR      r0,[r4,#0]            ;3814
000212  6840              LDR      r0,[r0,#4]            ;3814
000214  f44060e0          ORR      r0,r0,#0x700          ;3814
000218  6821              LDR      r1,[r4,#0]            ;3814
00021a  6048              STR      r0,[r1,#4]            ;3814
                  |L23.540|
00021c  2000              MOVS     r0,#0                 ;3817
00021e  e72e              B        |L23.126|
                  |L23.544|
000220  2002              MOVS     r0,#2                 ;3821
000222  e72c              B        |L23.126|
;;;3824   
                          ENDP

                  |L23.548|
                          DCD      SystemCoreClock
                  |L23.552|
                          DCD      I2C_DMAXferCplt
                  |L23.556|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Seq_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Transmit_IT PROC
;;;3555     */
;;;3556   HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b57c              PUSH     {r2-r6,lr}
;;;3557   {
000002  4604              MOV      r4,r0
000004  9d06              LDR      r5,[sp,#0x18]
;;;3558     __IO uint32_t Prev_State = 0x00U;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;3559     __IO uint32_t count      = 0x00U;
00000a  9000              STR      r0,[sp,#0]
;;;3560   
;;;3561     /* Check the parameters */
;;;3562     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3563   
;;;3564     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2820              CMP      r0,#0x20
000012  d16e              BNE      |L24.242|
;;;3565     {
;;;3566       /* Check Busy Flag only if FIRST call of Master interface */
;;;3567       if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
000014  6820              LDR      r0,[r4,#0]
000016  6800              LDR      r0,[r0,#0]
000018  f4007000          AND      r0,r0,#0x200
00001c  f5b07f00          CMP      r0,#0x200
000020  d003              BEQ      |L24.42|
000022  2d08              CMP      r5,#8
000024  d001              BEQ      |L24.42|
000026  2d01              CMP      r5,#1
000028  d12c              BNE      |L24.132|
                  |L24.42|
;;;3568       {
;;;3569         /* Wait until BUSY flag is reset */
;;;3570         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
00002a  483e              LDR      r0,|L24.292|
00002c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00002e  2619              MOVS     r6,#0x19
000030  fbb0f0f6          UDIV     r0,r0,r6
000034  f44f767a          MOV      r6,#0x3e8
000038  fbb0f0f6          UDIV     r0,r0,r6
00003c  eb0006c0          ADD      r6,r0,r0,LSL #3
000040  eb061000          ADD      r0,r6,r0,LSL #4
000044  9000              STR      r0,[sp,#0]
;;;3571         do
000046  bf00              NOP      
                  |L24.72|
;;;3572         {
;;;3573           count--;
000048  9800              LDR      r0,[sp,#0]
00004a  1e40              SUBS     r0,r0,#1
00004c  9000              STR      r0,[sp,#0]
;;;3574           if (count == 0U)
00004e  9800              LDR      r0,[sp,#0]
000050  b990              CBNZ     r0,|L24.120|
;;;3575           {
;;;3576             hi2c->PreviousState       = I2C_STATE_NONE;
000052  2000              MOVS     r0,#0
000054  6320              STR      r0,[r4,#0x30]
;;;3577             hi2c->State               = HAL_I2C_STATE_READY;
000056  2020              MOVS     r0,#0x20
000058  f884003d          STRB     r0,[r4,#0x3d]
;;;3578             hi2c->Mode                = HAL_I2C_MODE_NONE;
00005c  2000              MOVS     r0,#0
00005e  f884003e          STRB     r0,[r4,#0x3e]
;;;3579             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000062  6c20              LDR      r0,[r4,#0x40]
000064  f0400020          ORR      r0,r0,#0x20
000068  6420              STR      r0,[r4,#0x40]
;;;3580   
;;;3581             /* Process Unlocked */
;;;3582             __HAL_UNLOCK(hi2c);
00006a  bf00              NOP      
00006c  2000              MOVS     r0,#0
00006e  f884003c          STRB     r0,[r4,#0x3c]
000072  bf00              NOP      
;;;3583   
;;;3584             return HAL_ERROR;
000074  2001              MOVS     r0,#1
                  |L24.118|
;;;3585           }
;;;3586         }
;;;3587         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3588       }
;;;3589   
;;;3590       /* Process Locked */
;;;3591       __HAL_LOCK(hi2c);
;;;3592   
;;;3593       /* Check if the I2C is already enabled */
;;;3594       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3595       {
;;;3596         /* Enable I2C peripheral */
;;;3597         __HAL_I2C_ENABLE(hi2c);
;;;3598       }
;;;3599   
;;;3600       /* Disable Pos */
;;;3601       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3602   
;;;3603       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3604       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3605       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3606   
;;;3607       /* Prepare transfer parameters */
;;;3608       hi2c->pBuffPtr    = pData;
;;;3609       hi2c->XferCount   = Size;
;;;3610       hi2c->XferSize    = hi2c->XferCount;
;;;3611       hi2c->XferOptions = XferOptions;
;;;3612       hi2c->Devaddress  = DevAddress;
;;;3613   
;;;3614       Prev_State = hi2c->PreviousState;
;;;3615   
;;;3616       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3617       /* Mean Previous state is same as current state */
;;;3618       if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3619       {
;;;3620         /* Generate Start */
;;;3621         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3622       }
;;;3623   
;;;3624       /* Process Unlocked */
;;;3625       __HAL_UNLOCK(hi2c);
;;;3626   
;;;3627       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3628       to avoid the risk of I2C interrupt handle execution before current
;;;3629       process unlock */
;;;3630   
;;;3631       /* Enable EVT, BUF and ERR interrupt */
;;;3632       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3633   
;;;3634       return HAL_OK;
;;;3635     }
;;;3636     else
;;;3637     {
;;;3638       return HAL_BUSY;
;;;3639     }
;;;3640   }
000076  bd7c              POP      {r2-r6,pc}
                  |L24.120|
000078  6820              LDR      r0,[r4,#0]            ;3587
00007a  6980              LDR      r0,[r0,#0x18]         ;3587
00007c  f3c00040          UBFX     r0,r0,#1,#1           ;3587
000080  2800              CMP      r0,#0                 ;3587
000082  d1e1              BNE      |L24.72|
                  |L24.132|
000084  bf00              NOP                            ;3591
000086  f894003c          LDRB     r0,[r4,#0x3c]         ;3591
00008a  2801              CMP      r0,#1                 ;3591
00008c  d101              BNE      |L24.146|
00008e  2002              MOVS     r0,#2                 ;3591
000090  e7f1              B        |L24.118|
                  |L24.146|
000092  2001              MOVS     r0,#1                 ;3591
000094  f884003c          STRB     r0,[r4,#0x3c]         ;3591
000098  bf00              NOP                            ;3591
00009a  6820              LDR      r0,[r4,#0]            ;3594
00009c  6800              LDR      r0,[r0,#0]            ;3594
00009e  f0000001          AND      r0,r0,#1              ;3594
0000a2  b928              CBNZ     r0,|L24.176|
0000a4  6820              LDR      r0,[r4,#0]            ;3597
0000a6  6800              LDR      r0,[r0,#0]            ;3597
0000a8  f0400001          ORR      r0,r0,#1              ;3597
0000ac  6826              LDR      r6,[r4,#0]            ;3597
0000ae  6030              STR      r0,[r6,#0]            ;3597
                  |L24.176|
0000b0  6820              LDR      r0,[r4,#0]            ;3601
0000b2  6800              LDR      r0,[r0,#0]            ;3601
0000b4  f4206000          BIC      r0,r0,#0x800          ;3601
0000b8  6826              LDR      r6,[r4,#0]            ;3601
0000ba  6030              STR      r0,[r6,#0]            ;3601
0000bc  2021              MOVS     r0,#0x21              ;3603
0000be  f884003d          STRB     r0,[r4,#0x3d]         ;3603
0000c2  2010              MOVS     r0,#0x10              ;3604
0000c4  f884003e          STRB     r0,[r4,#0x3e]         ;3604
0000c8  2000              MOVS     r0,#0                 ;3605
0000ca  6420              STR      r0,[r4,#0x40]         ;3605
0000cc  6262              STR      r2,[r4,#0x24]         ;3608
0000ce  8563              STRH     r3,[r4,#0x2a]         ;3609
0000d0  8d60              LDRH     r0,[r4,#0x2a]         ;3610
0000d2  8520              STRH     r0,[r4,#0x28]         ;3610
0000d4  62e5              STR      r5,[r4,#0x2c]         ;3611
0000d6  6461              STR      r1,[r4,#0x44]         ;3612
0000d8  6b20              LDR      r0,[r4,#0x30]         ;3614
0000da  9001              STR      r0,[sp,#4]            ;3614
0000dc  9801              LDR      r0,[sp,#4]            ;3618
0000de  2811              CMP      r0,#0x11              ;3618
0000e0  d10b              BNE      |L24.250|
0000e2  f5b50f2a          CMP      r5,#0xaa0000          ;3618
0000e6  d002              BEQ      |L24.238|
0000e8  f1b54f2a          CMP      r5,#0xaa000000        ;3618
0000ec  d102              BNE      |L24.244|
                  |L24.238|
0000ee  2001              MOVS     r0,#1                 ;3618
0000f0  e001              B        |L24.246|
                  |L24.242|
0000f2  e015              B        |L24.288|
                  |L24.244|
0000f4  2000              MOVS     r0,#0                 ;3618
                  |L24.246|
0000f6  2801              CMP      r0,#1                 ;3618
0000f8  d105              BNE      |L24.262|
                  |L24.250|
0000fa  6820              LDR      r0,[r4,#0]            ;3621
0000fc  6800              LDR      r0,[r0,#0]            ;3621
0000fe  f4407080          ORR      r0,r0,#0x100          ;3621
000102  6826              LDR      r6,[r4,#0]            ;3621
000104  6030              STR      r0,[r6,#0]            ;3621
                  |L24.262|
000106  bf00              NOP                            ;3625
000108  2000              MOVS     r0,#0                 ;3625
00010a  f884003c          STRB     r0,[r4,#0x3c]         ;3625
00010e  bf00              NOP                            ;3625
000110  6820              LDR      r0,[r4,#0]            ;3632
000112  6840              LDR      r0,[r0,#4]            ;3632
000114  f44060e0          ORR      r0,r0,#0x700          ;3632
000118  6826              LDR      r6,[r4,#0]            ;3632
00011a  6070              STR      r0,[r6,#4]            ;3632
00011c  2000              MOVS     r0,#0                 ;3634
00011e  e7aa              B        |L24.118|
                  |L24.288|
000120  2002              MOVS     r0,#2                 ;3638
000122  e7a8              B        |L24.118|
;;;3641   
                          ENDP

                  |L24.292|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_I2C_Master_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit PROC
;;;1031     */
;;;1032   HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1033   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;1034     /* Init tickstart for timeout management*/
;;;1035     uint32_t tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4605              MOV      r5,r0
;;;1036   
;;;1037     if (hi2c->State == HAL_I2C_STATE_READY)
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2820              CMP      r0,#0x20
00001c  d17e              BNE      |L25.284|
;;;1038     {
;;;1039       /* Wait until BUSY flag is reset */
;;;1040       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
00001e  2319              MOVS     r3,#0x19
000020  2201              MOVS     r2,#1
000022  4951              LDR      r1,|L25.360|
000024  4620              MOV      r0,r4
000026  9500              STR      r5,[sp,#0]
000028  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002c  b110              CBZ      r0,|L25.52|
;;;1041       {
;;;1042         return HAL_BUSY;
00002e  2002              MOVS     r0,#2
                  |L25.48|
;;;1043       }
;;;1044   
;;;1045       /* Process Locked */
;;;1046       __HAL_LOCK(hi2c);
;;;1047   
;;;1048       /* Check if the I2C is already enabled */
;;;1049       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1050       {
;;;1051         /* Enable I2C peripheral */
;;;1052         __HAL_I2C_ENABLE(hi2c);
;;;1053       }
;;;1054   
;;;1055       /* Disable Pos */
;;;1056       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1057   
;;;1058       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1059       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1060       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1061   
;;;1062       /* Prepare transfer parameters */
;;;1063       hi2c->pBuffPtr    = pData;
;;;1064       hi2c->XferCount   = Size;
;;;1065       hi2c->XferSize    = hi2c->XferCount;
;;;1066       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1067   
;;;1068       /* Send Slave Address */
;;;1069       if (I2C_MasterRequestWrite(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
;;;1070       {
;;;1071         return HAL_ERROR;
;;;1072       }
;;;1073   
;;;1074       /* Clear ADDR flag */
;;;1075       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1076   
;;;1077       while (hi2c->XferSize > 0U)
;;;1078       {
;;;1079         /* Wait until TXE flag is set */
;;;1080         if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1081         {
;;;1082           if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1083           {
;;;1084             /* Generate Stop */
;;;1085             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1086           }
;;;1087           return HAL_ERROR;
;;;1088         }
;;;1089   
;;;1090         /* Write data to DR */
;;;1091         hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1092   
;;;1093         /* Increment Buffer pointer */
;;;1094         hi2c->pBuffPtr++;
;;;1095   
;;;1096         /* Update counter */
;;;1097         hi2c->XferCount--;
;;;1098         hi2c->XferSize--;
;;;1099   
;;;1100         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1101         {
;;;1102           /* Write data to DR */
;;;1103           hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1104   
;;;1105           /* Increment Buffer pointer */
;;;1106           hi2c->pBuffPtr++;
;;;1107   
;;;1108           /* Update counter */
;;;1109           hi2c->XferCount--;
;;;1110           hi2c->XferSize--;
;;;1111         }
;;;1112   
;;;1113         /* Wait until BTF flag is set */
;;;1114         if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1115         {
;;;1116           if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1117           {
;;;1118             /* Generate Stop */
;;;1119             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1120           }
;;;1121           return HAL_ERROR;
;;;1122         }
;;;1123       }
;;;1124   
;;;1125       /* Generate Stop */
;;;1126       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1127   
;;;1128       hi2c->State = HAL_I2C_STATE_READY;
;;;1129       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1130   
;;;1131       /* Process Unlocked */
;;;1132       __HAL_UNLOCK(hi2c);
;;;1133   
;;;1134       return HAL_OK;
;;;1135     }
;;;1136     else
;;;1137     {
;;;1138       return HAL_BUSY;
;;;1139     }
;;;1140   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L25.52|
000034  bf00              NOP                            ;1046
000036  f894003c          LDRB     r0,[r4,#0x3c]         ;1046
00003a  2801              CMP      r0,#1                 ;1046
00003c  d101              BNE      |L25.66|
00003e  2002              MOVS     r0,#2                 ;1046
000040  e7f6              B        |L25.48|
                  |L25.66|
000042  2001              MOVS     r0,#1                 ;1046
000044  f884003c          STRB     r0,[r4,#0x3c]         ;1046
000048  bf00              NOP                            ;1046
00004a  6820              LDR      r0,[r4,#0]            ;1049
00004c  6800              LDR      r0,[r0,#0]            ;1049
00004e  f0000001          AND      r0,r0,#1              ;1049
000052  b928              CBNZ     r0,|L25.96|
000054  6820              LDR      r0,[r4,#0]            ;1052
000056  6800              LDR      r0,[r0,#0]            ;1052
000058  f0400001          ORR      r0,r0,#1              ;1052
00005c  6821              LDR      r1,[r4,#0]            ;1052
00005e  6008              STR      r0,[r1,#0]            ;1052
                  |L25.96|
000060  6820              LDR      r0,[r4,#0]            ;1056
000062  6800              LDR      r0,[r0,#0]            ;1056
000064  f4206000          BIC      r0,r0,#0x800          ;1056
000068  6821              LDR      r1,[r4,#0]            ;1056
00006a  6008              STR      r0,[r1,#0]            ;1056
00006c  2021              MOVS     r0,#0x21              ;1058
00006e  f884003d          STRB     r0,[r4,#0x3d]         ;1058
000072  2010              MOVS     r0,#0x10              ;1059
000074  f884003e          STRB     r0,[r4,#0x3e]         ;1059
000078  2000              MOVS     r0,#0                 ;1060
00007a  6420              STR      r0,[r4,#0x40]         ;1060
00007c  6266              STR      r6,[r4,#0x24]         ;1063
00007e  8567              STRH     r7,[r4,#0x2a]         ;1064
000080  8d60              LDRH     r0,[r4,#0x2a]         ;1065
000082  8520              STRH     r0,[r4,#0x28]         ;1065
000084  4839              LDR      r0,|L25.364|
000086  62e0              STR      r0,[r4,#0x2c]         ;1066
000088  462b              MOV      r3,r5                 ;1069
00008a  4642              MOV      r2,r8                 ;1069
00008c  4649              MOV      r1,r9                 ;1069
00008e  4620              MOV      r0,r4                 ;1069
000090  f7fffffe          BL       I2C_MasterRequestWrite
000094  b108              CBZ      r0,|L25.154|
000096  2001              MOVS     r0,#1                 ;1071
000098  e7ca              B        |L25.48|
                  |L25.154|
00009a  bf00              NOP                            ;1075
00009c  2000              MOVS     r0,#0                 ;1075
00009e  9000              STR      r0,[sp,#0]            ;1075
0000a0  6820              LDR      r0,[r4,#0]            ;1075
0000a2  6940              LDR      r0,[r0,#0x14]         ;1075
0000a4  9000              STR      r0,[sp,#0]            ;1075
0000a6  6820              LDR      r0,[r4,#0]            ;1075
0000a8  6980              LDR      r0,[r0,#0x18]         ;1075
0000aa  9000              STR      r0,[sp,#0]            ;1075
0000ac  bf00              NOP                            ;1075
0000ae  bf00              NOP                            ;1075
0000b0  e044              B        |L25.316|
                  |L25.178|
0000b2  462a              MOV      r2,r5                 ;1080
0000b4  4641              MOV      r1,r8                 ;1080
0000b6  4620              MOV      r0,r4                 ;1080
0000b8  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000bc  b150              CBZ      r0,|L25.212|
0000be  6c20              LDR      r0,[r4,#0x40]         ;1082
0000c0  2804              CMP      r0,#4                 ;1082
0000c2  d105              BNE      |L25.208|
0000c4  6820              LDR      r0,[r4,#0]            ;1085
0000c6  6800              LDR      r0,[r0,#0]            ;1085
0000c8  f4407000          ORR      r0,r0,#0x200          ;1085
0000cc  6821              LDR      r1,[r4,#0]            ;1085
0000ce  6008              STR      r0,[r1,#0]            ;1085
                  |L25.208|
0000d0  2001              MOVS     r0,#1                 ;1087
0000d2  e7ad              B        |L25.48|
                  |L25.212|
0000d4  6a60              LDR      r0,[r4,#0x24]         ;1091
0000d6  7800              LDRB     r0,[r0,#0]            ;1091
0000d8  6821              LDR      r1,[r4,#0]            ;1091
0000da  6108              STR      r0,[r1,#0x10]         ;1091
0000dc  6a60              LDR      r0,[r4,#0x24]         ;1094
0000de  1c40              ADDS     r0,r0,#1              ;1094
0000e0  6260              STR      r0,[r4,#0x24]         ;1094
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;1097
0000e4  1e40              SUBS     r0,r0,#1              ;1097
0000e6  8560              STRH     r0,[r4,#0x2a]         ;1097
0000e8  8d20              LDRH     r0,[r4,#0x28]         ;1098
0000ea  1e40              SUBS     r0,r0,#1              ;1098
0000ec  8520              STRH     r0,[r4,#0x28]         ;1098
0000ee  6820              LDR      r0,[r4,#0]            ;1100
0000f0  6940              LDR      r0,[r0,#0x14]         ;1100
0000f2  f3c00080          UBFX     r0,r0,#2,#1           ;1100
0000f6  b170              CBZ      r0,|L25.278|
0000f8  8d20              LDRH     r0,[r4,#0x28]         ;1100
0000fa  b160              CBZ      r0,|L25.278|
0000fc  6a60              LDR      r0,[r4,#0x24]         ;1103
0000fe  7800              LDRB     r0,[r0,#0]            ;1103
000100  6821              LDR      r1,[r4,#0]            ;1103
000102  6108              STR      r0,[r1,#0x10]         ;1103
000104  6a60              LDR      r0,[r4,#0x24]         ;1106
000106  1c40              ADDS     r0,r0,#1              ;1106
000108  6260              STR      r0,[r4,#0x24]         ;1106
00010a  8d60              LDRH     r0,[r4,#0x2a]         ;1109
00010c  1e40              SUBS     r0,r0,#1              ;1109
00010e  8560              STRH     r0,[r4,#0x2a]         ;1109
000110  8d20              LDRH     r0,[r4,#0x28]         ;1110
000112  1e40              SUBS     r0,r0,#1              ;1110
000114  8520              STRH     r0,[r4,#0x28]         ;1110
                  |L25.278|
000116  462a              MOV      r2,r5                 ;1114
000118  4641              MOV      r1,r8                 ;1114
00011a  e000              B        |L25.286|
                  |L25.284|
00011c  e022              B        |L25.356|
                  |L25.286|
00011e  4620              MOV      r0,r4                 ;1114
000120  f7fffffe          BL       I2C_WaitOnBTFFlagUntilTimeout
000124  b150              CBZ      r0,|L25.316|
000126  6c20              LDR      r0,[r4,#0x40]         ;1116
000128  2804              CMP      r0,#4                 ;1116
00012a  d105              BNE      |L25.312|
00012c  6820              LDR      r0,[r4,#0]            ;1119
00012e  6800              LDR      r0,[r0,#0]            ;1119
000130  f4407000          ORR      r0,r0,#0x200          ;1119
000134  6821              LDR      r1,[r4,#0]            ;1119
000136  6008              STR      r0,[r1,#0]            ;1119
                  |L25.312|
000138  2001              MOVS     r0,#1                 ;1121
00013a  e779              B        |L25.48|
                  |L25.316|
00013c  8d20              LDRH     r0,[r4,#0x28]         ;1077
00013e  2800              CMP      r0,#0                 ;1077
000140  d1b7              BNE      |L25.178|
000142  6820              LDR      r0,[r4,#0]            ;1126
000144  6800              LDR      r0,[r0,#0]            ;1126
000146  f4407000          ORR      r0,r0,#0x200          ;1126
00014a  6821              LDR      r1,[r4,#0]            ;1126
00014c  6008              STR      r0,[r1,#0]            ;1126
00014e  2020              MOVS     r0,#0x20              ;1128
000150  f884003d          STRB     r0,[r4,#0x3d]         ;1128
000154  2000              MOVS     r0,#0                 ;1129
000156  f884003e          STRB     r0,[r4,#0x3e]         ;1129
00015a  bf00              NOP                            ;1132
00015c  f884003c          STRB     r0,[r4,#0x3c]         ;1132
000160  bf00              NOP                            ;1132
000162  e765              B        |L25.48|
                  |L25.356|
000164  2002              MOVS     r0,#2                 ;1138
000166  e763              B        |L25.48|
;;;1141   
                          ENDP

                  |L25.360|
                          DCD      0x00100002
                  |L25.364|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Master_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_DMA PROC
;;;1936     */
;;;1937   HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1938   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1939     __IO uint32_t count = 0U;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;1940     HAL_StatusTypeDef dmaxferstatus;
;;;1941   
;;;1942     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d178              BNE      |L26.266|
;;;1943     {
;;;1944       /* Wait until BUSY flag is reset */
;;;1945       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000018  486a              LDR      r0,|L26.452|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  2119              MOVS     r1,#0x19
00001e  fbb0f0f1          UDIV     r0,r0,r1
000022  f44f717a          MOV      r1,#0x3e8
000026  fbb0f0f1          UDIV     r0,r0,r1
00002a  eb0001c0          ADD      r1,r0,r0,LSL #3
00002e  eb011000          ADD      r0,r1,r0,LSL #4
000032  9000              STR      r0,[sp,#0]
;;;1946       do
000034  bf00              NOP      
                  |L26.54|
;;;1947       {
;;;1948         count--;
000036  9800              LDR      r0,[sp,#0]
000038  1e40              SUBS     r0,r0,#1
00003a  9000              STR      r0,[sp,#0]
;;;1949         if (count == 0U)
00003c  9800              LDR      r0,[sp,#0]
00003e  b998              CBNZ     r0,|L26.104|
;;;1950         {
;;;1951           hi2c->PreviousState       = I2C_STATE_NONE;
000040  2000              MOVS     r0,#0
000042  6320              STR      r0,[r4,#0x30]
;;;1952           hi2c->State               = HAL_I2C_STATE_READY;
000044  2020              MOVS     r0,#0x20
000046  f884003d          STRB     r0,[r4,#0x3d]
;;;1953           hi2c->Mode                = HAL_I2C_MODE_NONE;
00004a  2000              MOVS     r0,#0
00004c  f884003e          STRB     r0,[r4,#0x3e]
;;;1954           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000050  6c20              LDR      r0,[r4,#0x40]
000052  f0400020          ORR      r0,r0,#0x20
000056  6420              STR      r0,[r4,#0x40]
;;;1955   
;;;1956           /* Process Unlocked */
;;;1957           __HAL_UNLOCK(hi2c);
000058  bf00              NOP      
00005a  2000              MOVS     r0,#0
00005c  f884003c          STRB     r0,[r4,#0x3c]
000060  bf00              NOP      
;;;1958   
;;;1959           return HAL_ERROR;
000062  2001              MOVS     r0,#1
                  |L26.100|
;;;1960         }
;;;1961       }
;;;1962       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1963   
;;;1964       /* Process Locked */
;;;1965       __HAL_LOCK(hi2c);
;;;1966   
;;;1967       /* Check if the I2C is already enabled */
;;;1968       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1969       {
;;;1970         /* Enable I2C peripheral */
;;;1971         __HAL_I2C_ENABLE(hi2c);
;;;1972       }
;;;1973   
;;;1974       /* Disable Pos */
;;;1975       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1976   
;;;1977       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1978       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1979       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1980   
;;;1981       /* Prepare transfer parameters */
;;;1982       hi2c->pBuffPtr    = pData;
;;;1983       hi2c->XferCount   = Size;
;;;1984       hi2c->XferSize    = hi2c->XferCount;
;;;1985       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1986       hi2c->Devaddress  = DevAddress;
;;;1987   
;;;1988       if (hi2c->XferSize > 0U)
;;;1989       {
;;;1990         if (hi2c->hdmatx != NULL)
;;;1991         {
;;;1992           /* Set the I2C DMA transfer complete callback */
;;;1993           hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;1994   
;;;1995           /* Set the DMA error callback */
;;;1996           hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;1997   
;;;1998           /* Set the unused DMA callbacks to NULL */
;;;1999           hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;2000           hi2c->hdmatx->XferM1CpltCallback = NULL;
;;;2001           hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
;;;2002           hi2c->hdmatx->XferAbortCallback = NULL;
;;;2003   
;;;2004           /* Enable the DMA stream */
;;;2005           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;2006         }
;;;2007         else
;;;2008         {
;;;2009           /* Update I2C state */
;;;2010           hi2c->State     = HAL_I2C_STATE_READY;
;;;2011           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2012   
;;;2013           /* Update I2C error code */
;;;2014           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;2015   
;;;2016           /* Process Unlocked */
;;;2017           __HAL_UNLOCK(hi2c);
;;;2018   
;;;2019           return HAL_ERROR;
;;;2020         }
;;;2021   
;;;2022         if (dmaxferstatus == HAL_OK)
;;;2023         {
;;;2024           /* Process Unlocked */
;;;2025           __HAL_UNLOCK(hi2c);
;;;2026   
;;;2027           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2028           to avoid the risk of I2C interrupt handle execution before current
;;;2029           process unlock */
;;;2030   
;;;2031           /* Enable EVT and ERR interrupt */
;;;2032           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2033   
;;;2034           /* Enable DMA Request */
;;;2035           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2036   
;;;2037           /* Enable Acknowledge */
;;;2038           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2039   
;;;2040           /* Generate Start */
;;;2041           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2042         }
;;;2043         else
;;;2044         {
;;;2045           /* Update I2C state */
;;;2046           hi2c->State     = HAL_I2C_STATE_READY;
;;;2047           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2048   
;;;2049           /* Update I2C error code */
;;;2050           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2051   
;;;2052           /* Process Unlocked */
;;;2053           __HAL_UNLOCK(hi2c);
;;;2054   
;;;2055           return HAL_ERROR;
;;;2056         }
;;;2057       }
;;;2058       else
;;;2059       {
;;;2060         /* Enable Acknowledge */
;;;2061         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2062   
;;;2063         /* Generate Start */
;;;2064         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2065   
;;;2066         /* Process Unlocked */
;;;2067         __HAL_UNLOCK(hi2c);
;;;2068   
;;;2069         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2070         to avoid the risk of I2C interrupt handle execution before current
;;;2071         process unlock */
;;;2072   
;;;2073         /* Enable EVT, BUF and ERR interrupt */
;;;2074         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2075       }
;;;2076   
;;;2077       return HAL_OK;
;;;2078     }
;;;2079     else
;;;2080     {
;;;2081       return HAL_BUSY;
;;;2082     }
;;;2083   }
000064  e8bd83f8          POP      {r3-r9,pc}
                  |L26.104|
000068  6820              LDR      r0,[r4,#0]            ;1962
00006a  6980              LDR      r0,[r0,#0x18]         ;1962
00006c  f3c00040          UBFX     r0,r0,#1,#1           ;1962
000070  2800              CMP      r0,#0                 ;1962
000072  d1e0              BNE      |L26.54|
000074  bf00              NOP                            ;1965
000076  f894003c          LDRB     r0,[r4,#0x3c]         ;1965
00007a  2801              CMP      r0,#1                 ;1965
00007c  d101              BNE      |L26.130|
00007e  2002              MOVS     r0,#2                 ;1965
000080  e7f0              B        |L26.100|
                  |L26.130|
000082  2001              MOVS     r0,#1                 ;1965
000084  f884003c          STRB     r0,[r4,#0x3c]         ;1965
000088  bf00              NOP                            ;1965
00008a  6820              LDR      r0,[r4,#0]            ;1968
00008c  6800              LDR      r0,[r0,#0]            ;1968
00008e  f0000001          AND      r0,r0,#1              ;1968
000092  b928              CBNZ     r0,|L26.160|
000094  6820              LDR      r0,[r4,#0]            ;1971
000096  6800              LDR      r0,[r0,#0]            ;1971
000098  f0400001          ORR      r0,r0,#1              ;1971
00009c  6821              LDR      r1,[r4,#0]            ;1971
00009e  6008              STR      r0,[r1,#0]            ;1971
                  |L26.160|
0000a0  6820              LDR      r0,[r4,#0]            ;1975
0000a2  6800              LDR      r0,[r0,#0]            ;1975
0000a4  f4206000          BIC      r0,r0,#0x800          ;1975
0000a8  6821              LDR      r1,[r4,#0]            ;1975
0000aa  6008              STR      r0,[r1,#0]            ;1975
0000ac  2021              MOVS     r0,#0x21              ;1977
0000ae  f884003d          STRB     r0,[r4,#0x3d]         ;1977
0000b2  2010              MOVS     r0,#0x10              ;1978
0000b4  f884003e          STRB     r0,[r4,#0x3e]         ;1978
0000b8  2000              MOVS     r0,#0                 ;1979
0000ba  6420              STR      r0,[r4,#0x40]         ;1979
0000bc  6267              STR      r7,[r4,#0x24]         ;1982
0000be  f8a4802a          STRH     r8,[r4,#0x2a]         ;1983
0000c2  8d60              LDRH     r0,[r4,#0x2a]         ;1984
0000c4  8520              STRH     r0,[r4,#0x28]         ;1984
0000c6  4840              LDR      r0,|L26.456|
0000c8  62e0              STR      r0,[r4,#0x2c]         ;1985
0000ca  6466              STR      r6,[r4,#0x44]         ;1986
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;1988
0000ce  2800              CMP      r0,#0                 ;1988
0000d0  d05d              BEQ      |L26.398|
0000d2  6b60              LDR      r0,[r4,#0x34]         ;1990
0000d4  b1d0              CBZ      r0,|L26.268|
0000d6  483d              LDR      r0,|L26.460|
0000d8  6b61              LDR      r1,[r4,#0x34]         ;1993
0000da  63c8              STR      r0,[r1,#0x3c]         ;1993
0000dc  483c              LDR      r0,|L26.464|
0000de  6b61              LDR      r1,[r4,#0x34]         ;1996
0000e0  64c8              STR      r0,[r1,#0x4c]         ;1996
0000e2  2000              MOVS     r0,#0                 ;1999
0000e4  6b61              LDR      r1,[r4,#0x34]         ;1999
0000e6  6408              STR      r0,[r1,#0x40]         ;1999
0000e8  6b61              LDR      r1,[r4,#0x34]         ;2000
0000ea  6448              STR      r0,[r1,#0x44]         ;2000
0000ec  6b61              LDR      r1,[r4,#0x34]         ;2001
0000ee  6488              STR      r0,[r1,#0x48]         ;2001
0000f0  6b61              LDR      r1,[r4,#0x34]         ;2002
0000f2  6508              STR      r0,[r1,#0x50]         ;2002
0000f4  8d23              LDRH     r3,[r4,#0x28]         ;2005
0000f6  f8d4c000          LDR      r12,[r4,#0]           ;2005
0000fa  f10c0210          ADD      r2,r12,#0x10          ;2005
0000fe  6a61              LDR      r1,[r4,#0x24]         ;2005
000100  6b60              LDR      r0,[r4,#0x34]         ;2005
000102  f7fffffe          BL       HAL_DMA_Start_IT
000106  4605              MOV      r5,r0                 ;2005
000108  e011              B        |L26.302|
                  |L26.266|
00010a  e059              B        |L26.448|
                  |L26.268|
00010c  2020              MOVS     r0,#0x20              ;2010
00010e  f884003d          STRB     r0,[r4,#0x3d]         ;2010
000112  2000              MOVS     r0,#0                 ;2011
000114  f884003e          STRB     r0,[r4,#0x3e]         ;2011
000118  6c20              LDR      r0,[r4,#0x40]         ;2014
00011a  f0400080          ORR      r0,r0,#0x80           ;2014
00011e  6420              STR      r0,[r4,#0x40]         ;2014
000120  bf00              NOP                            ;2017
000122  2000              MOVS     r0,#0                 ;2017
000124  f884003c          STRB     r0,[r4,#0x3c]         ;2017
000128  bf00              NOP                            ;2017
00012a  2001              MOVS     r0,#1                 ;2019
00012c  e79a              B        |L26.100|
                  |L26.302|
00012e  b9ed              CBNZ     r5,|L26.364|
000130  bf00              NOP                            ;2025
000132  2000              MOVS     r0,#0                 ;2025
000134  f884003c          STRB     r0,[r4,#0x3c]         ;2025
000138  bf00              NOP                            ;2025
00013a  6820              LDR      r0,[r4,#0]            ;2032
00013c  6840              LDR      r0,[r0,#4]            ;2032
00013e  f4407040          ORR      r0,r0,#0x300          ;2032
000142  6821              LDR      r1,[r4,#0]            ;2032
000144  6048              STR      r0,[r1,#4]            ;2032
000146  6820              LDR      r0,[r4,#0]            ;2035
000148  6840              LDR      r0,[r0,#4]            ;2035
00014a  f4406000          ORR      r0,r0,#0x800          ;2035
00014e  6821              LDR      r1,[r4,#0]            ;2035
000150  6048              STR      r0,[r1,#4]            ;2035
000152  6820              LDR      r0,[r4,#0]            ;2038
000154  6800              LDR      r0,[r0,#0]            ;2038
000156  f4406080          ORR      r0,r0,#0x400          ;2038
00015a  6821              LDR      r1,[r4,#0]            ;2038
00015c  6008              STR      r0,[r1,#0]            ;2038
00015e  6820              LDR      r0,[r4,#0]            ;2041
000160  6800              LDR      r0,[r0,#0]            ;2041
000162  f4407080          ORR      r0,r0,#0x100          ;2041
000166  6821              LDR      r1,[r4,#0]            ;2041
000168  6008              STR      r0,[r1,#0]            ;2041
00016a  e027              B        |L26.444|
                  |L26.364|
00016c  2020              MOVS     r0,#0x20              ;2046
00016e  f884003d          STRB     r0,[r4,#0x3d]         ;2046
000172  2000              MOVS     r0,#0                 ;2047
000174  f884003e          STRB     r0,[r4,#0x3e]         ;2047
000178  6c20              LDR      r0,[r4,#0x40]         ;2050
00017a  f0400010          ORR      r0,r0,#0x10           ;2050
00017e  6420              STR      r0,[r4,#0x40]         ;2050
000180  bf00              NOP                            ;2053
000182  2000              MOVS     r0,#0                 ;2053
000184  f884003c          STRB     r0,[r4,#0x3c]         ;2053
000188  bf00              NOP                            ;2053
00018a  2001              MOVS     r0,#1                 ;2055
00018c  e76a              B        |L26.100|
                  |L26.398|
00018e  6820              LDR      r0,[r4,#0]            ;2061
000190  6800              LDR      r0,[r0,#0]            ;2061
000192  f4406080          ORR      r0,r0,#0x400          ;2061
000196  6821              LDR      r1,[r4,#0]            ;2061
000198  6008              STR      r0,[r1,#0]            ;2061
00019a  6820              LDR      r0,[r4,#0]            ;2064
00019c  6800              LDR      r0,[r0,#0]            ;2064
00019e  f4407080          ORR      r0,r0,#0x100          ;2064
0001a2  6821              LDR      r1,[r4,#0]            ;2064
0001a4  6008              STR      r0,[r1,#0]            ;2064
0001a6  bf00              NOP                            ;2067
0001a8  2000              MOVS     r0,#0                 ;2067
0001aa  f884003c          STRB     r0,[r4,#0x3c]         ;2067
0001ae  bf00              NOP                            ;2067
0001b0  6820              LDR      r0,[r4,#0]            ;2074
0001b2  6840              LDR      r0,[r0,#4]            ;2074
0001b4  f44060e0          ORR      r0,r0,#0x700          ;2074
0001b8  6821              LDR      r1,[r4,#0]            ;2074
0001ba  6048              STR      r0,[r1,#4]            ;2074
                  |L26.444|
0001bc  2000              MOVS     r0,#0                 ;2077
0001be  e751              B        |L26.100|
                  |L26.448|
0001c0  2002              MOVS     r0,#2                 ;2081
0001c2  e74f              B        |L26.100|
;;;2084   
                          ENDP

                  |L26.452|
                          DCD      SystemCoreClock
                  |L26.456|
                          DCD      0xffff0000
                  |L26.460|
                          DCD      I2C_DMAXferCplt
                  |L26.464|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_IT PROC
;;;1647     */
;;;1648   HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b538              PUSH     {r3-r5,lr}
;;;1649   {
000002  4604              MOV      r4,r0
;;;1650     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1651   
;;;1652     if (hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d16a              BNE      |L27.230|
;;;1653     {
;;;1654       /* Wait until BUSY flag is reset */
;;;1655       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000010  4836              LDR      r0,|L27.236|
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  2519              MOVS     r5,#0x19
000016  fbb0f0f5          UDIV     r0,r0,r5
00001a  f44f757a          MOV      r5,#0x3e8
00001e  fbb0f0f5          UDIV     r0,r0,r5
000022  eb0005c0          ADD      r5,r0,r0,LSL #3
000026  eb051000          ADD      r0,r5,r0,LSL #4
00002a  9000              STR      r0,[sp,#0]
;;;1656       do
00002c  bf00              NOP      
                  |L27.46|
;;;1657       {
;;;1658         count--;
00002e  9800              LDR      r0,[sp,#0]
000030  1e40              SUBS     r0,r0,#1
000032  9000              STR      r0,[sp,#0]
;;;1659         if (count == 0U)
000034  9800              LDR      r0,[sp,#0]
000036  b990              CBNZ     r0,|L27.94|
;;;1660         {
;;;1661           hi2c->PreviousState       = I2C_STATE_NONE;
000038  2000              MOVS     r0,#0
00003a  6320              STR      r0,[r4,#0x30]
;;;1662           hi2c->State               = HAL_I2C_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;1663           hi2c->Mode                = HAL_I2C_MODE_NONE;
000042  2000              MOVS     r0,#0
000044  f884003e          STRB     r0,[r4,#0x3e]
;;;1664           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000048  6c20              LDR      r0,[r4,#0x40]
00004a  f0400020          ORR      r0,r0,#0x20
00004e  6420              STR      r0,[r4,#0x40]
;;;1665   
;;;1666           /* Process Unlocked */
;;;1667           __HAL_UNLOCK(hi2c);
000050  bf00              NOP      
000052  2000              MOVS     r0,#0
000054  f884003c          STRB     r0,[r4,#0x3c]
000058  bf00              NOP      
;;;1668   
;;;1669           return HAL_ERROR;
00005a  2001              MOVS     r0,#1
                  |L27.92|
;;;1670         }
;;;1671       }
;;;1672       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1673   
;;;1674       /* Process Locked */
;;;1675       __HAL_LOCK(hi2c);
;;;1676   
;;;1677       /* Check if the I2C is already enabled */
;;;1678       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1679       {
;;;1680         /* Enable I2C peripheral */
;;;1681         __HAL_I2C_ENABLE(hi2c);
;;;1682       }
;;;1683   
;;;1684       /* Disable Pos */
;;;1685       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1686   
;;;1687       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1688       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1689       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1690   
;;;1691       /* Prepare transfer parameters */
;;;1692       hi2c->pBuffPtr    = pData;
;;;1693       hi2c->XferCount   = Size;
;;;1694       hi2c->XferSize    = hi2c->XferCount;
;;;1695       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1696       hi2c->Devaddress  = DevAddress;
;;;1697   
;;;1698       /* Process Unlocked */
;;;1699       __HAL_UNLOCK(hi2c);
;;;1700   
;;;1701       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1702                 to avoid the risk of I2C interrupt handle execution before current
;;;1703                 process unlock */
;;;1704       /* Enable EVT, BUF and ERR interrupt */
;;;1705       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1706   
;;;1707       /* Generate Start */
;;;1708       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;1709   
;;;1710       return HAL_OK;
;;;1711     }
;;;1712     else
;;;1713     {
;;;1714       return HAL_BUSY;
;;;1715     }
;;;1716   }
00005c  bd38              POP      {r3-r5,pc}
                  |L27.94|
00005e  6820              LDR      r0,[r4,#0]            ;1672
000060  6980              LDR      r0,[r0,#0x18]         ;1672
000062  f3c00040          UBFX     r0,r0,#1,#1           ;1672
000066  2800              CMP      r0,#0                 ;1672
000068  d1e1              BNE      |L27.46|
00006a  bf00              NOP                            ;1675
00006c  f894003c          LDRB     r0,[r4,#0x3c]         ;1675
000070  2801              CMP      r0,#1                 ;1675
000072  d101              BNE      |L27.120|
000074  2002              MOVS     r0,#2                 ;1675
000076  e7f1              B        |L27.92|
                  |L27.120|
000078  2001              MOVS     r0,#1                 ;1675
00007a  f884003c          STRB     r0,[r4,#0x3c]         ;1675
00007e  bf00              NOP                            ;1675
000080  6820              LDR      r0,[r4,#0]            ;1678
000082  6800              LDR      r0,[r0,#0]            ;1678
000084  f0000001          AND      r0,r0,#1              ;1678
000088  b928              CBNZ     r0,|L27.150|
00008a  6820              LDR      r0,[r4,#0]            ;1681
00008c  6800              LDR      r0,[r0,#0]            ;1681
00008e  f0400001          ORR      r0,r0,#1              ;1681
000092  6825              LDR      r5,[r4,#0]            ;1681
000094  6028              STR      r0,[r5,#0]            ;1681
                  |L27.150|
000096  6820              LDR      r0,[r4,#0]            ;1685
000098  6800              LDR      r0,[r0,#0]            ;1685
00009a  f4206000          BIC      r0,r0,#0x800          ;1685
00009e  6825              LDR      r5,[r4,#0]            ;1685
0000a0  6028              STR      r0,[r5,#0]            ;1685
0000a2  2021              MOVS     r0,#0x21              ;1687
0000a4  f884003d          STRB     r0,[r4,#0x3d]         ;1687
0000a8  2010              MOVS     r0,#0x10              ;1688
0000aa  f884003e          STRB     r0,[r4,#0x3e]         ;1688
0000ae  2000              MOVS     r0,#0                 ;1689
0000b0  6420              STR      r0,[r4,#0x40]         ;1689
0000b2  6262              STR      r2,[r4,#0x24]         ;1692
0000b4  8563              STRH     r3,[r4,#0x2a]         ;1693
0000b6  8d60              LDRH     r0,[r4,#0x2a]         ;1694
0000b8  8520              STRH     r0,[r4,#0x28]         ;1694
0000ba  480d              LDR      r0,|L27.240|
0000bc  62e0              STR      r0,[r4,#0x2c]         ;1695
0000be  6461              STR      r1,[r4,#0x44]         ;1696
0000c0  bf00              NOP                            ;1699
0000c2  2000              MOVS     r0,#0                 ;1699
0000c4  f884003c          STRB     r0,[r4,#0x3c]         ;1699
0000c8  bf00              NOP                            ;1699
0000ca  6820              LDR      r0,[r4,#0]            ;1705
0000cc  6840              LDR      r0,[r0,#4]            ;1705
0000ce  f44060e0          ORR      r0,r0,#0x700          ;1705
0000d2  6825              LDR      r5,[r4,#0]            ;1705
0000d4  6068              STR      r0,[r5,#4]            ;1705
0000d6  6820              LDR      r0,[r4,#0]            ;1708
0000d8  6800              LDR      r0,[r0,#0]            ;1708
0000da  f4407080          ORR      r0,r0,#0x100          ;1708
0000de  6825              LDR      r5,[r4,#0]            ;1708
0000e0  6028              STR      r0,[r5,#0]            ;1708
0000e2  2000              MOVS     r0,#0                 ;1710
0000e4  e7ba              B        |L27.92|
                  |L27.230|
0000e6  2002              MOVS     r0,#2                 ;1714
0000e8  e7b8              B        |L27.92|
;;;1717   
                          ENDP

0000ea  0000              DCW      0x0000
                  |L27.236|
                          DCD      SystemCoreClock
                  |L27.240|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_MemRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemRxCpltCallback PROC
;;;5145     */
;;;5146   __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5147   {
;;;5148     /* Prevent unused argument(s) compilation warning */
;;;5149     UNUSED(hi2c);
;;;5150   
;;;5151     /* NOTE : This function should not be modified, when the callback is needed,
;;;5152               the HAL_I2C_MemRxCpltCallback could be implemented in the user file
;;;5153      */
;;;5154   }
;;;5155   
                          ENDP


                          AREA ||i.HAL_I2C_MemTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemTxCpltCallback PROC
;;;5129     */
;;;5130   __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5131   {
;;;5132     /* Prevent unused argument(s) compilation warning */
;;;5133     UNUSED(hi2c);
;;;5134   
;;;5135     /* NOTE : This function should not be modified, when the callback is needed,
;;;5136               the HAL_I2C_MemTxCpltCallback could be implemented in the user file
;;;5137      */
;;;5138   }
;;;5139   
                          ENDP


                          AREA ||i.HAL_I2C_Mem_Read||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read PROC
;;;2606     */
;;;2607   HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2608   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
000010  9e0e              LDR      r6,[sp,#0x38]
;;;2609     /* Init tickstart for timeout management*/
;;;2610     uint32_t tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;2611   
;;;2612     /* Check the parameters */
;;;2613     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2614   
;;;2615     if (hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d170              BNE      |L30.258|
;;;2616     {
;;;2617       /* Wait until BUSY flag is reset */
;;;2618       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
000020  2319              MOVS     r3,#0x19
000022  2201              MOVS     r2,#1
000024  49b0              LDR      r1,|L30.744|
000026  4620              MOV      r0,r4
000028  9500              STR      r5,[sp,#0]
00002a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002e  b110              CBZ      r0,|L30.54|
;;;2619       {
;;;2620         return HAL_BUSY;
000030  2002              MOVS     r0,#2
                  |L30.50|
;;;2621       }
;;;2622   
;;;2623       /* Process Locked */
;;;2624       __HAL_LOCK(hi2c);
;;;2625   
;;;2626       /* Check if the I2C is already enabled */
;;;2627       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2628       {
;;;2629         /* Enable I2C peripheral */
;;;2630         __HAL_I2C_ENABLE(hi2c);
;;;2631       }
;;;2632   
;;;2633       /* Disable Pos */
;;;2634       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2635   
;;;2636       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2637       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2638       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2639   
;;;2640       /* Prepare transfer parameters */
;;;2641       hi2c->pBuffPtr    = pData;
;;;2642       hi2c->XferCount   = Size;
;;;2643       hi2c->XferSize    = hi2c->XferCount;
;;;2644       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2645   
;;;2646       /* Send Slave Address and Memory Address */
;;;2647       if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2648       {
;;;2649         return HAL_ERROR;
;;;2650       }
;;;2651   
;;;2652       if (hi2c->XferSize == 0U)
;;;2653       {
;;;2654         /* Clear ADDR flag */
;;;2655         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2656   
;;;2657         /* Generate Stop */
;;;2658         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2659       }
;;;2660       else if (hi2c->XferSize == 1U)
;;;2661       {
;;;2662         /* Disable Acknowledge */
;;;2663         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2664   
;;;2665         /* Clear ADDR flag */
;;;2666         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2667   
;;;2668         /* Generate Stop */
;;;2669         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2670       }
;;;2671       else if (hi2c->XferSize == 2U)
;;;2672       {
;;;2673         /* Disable Acknowledge */
;;;2674         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2675   
;;;2676         /* Enable Pos */
;;;2677         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2678   
;;;2679         /* Clear ADDR flag */
;;;2680         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2681       }
;;;2682       else
;;;2683       {
;;;2684         /* Clear ADDR flag */
;;;2685         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2686       }
;;;2687   
;;;2688       while (hi2c->XferSize > 0U)
;;;2689       {
;;;2690         if (hi2c->XferSize <= 3U)
;;;2691         {
;;;2692           /* One byte */
;;;2693           if (hi2c->XferSize == 1U)
;;;2694           {
;;;2695             /* Wait until RXNE flag is set */
;;;2696             if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2697             {
;;;2698               return HAL_ERROR;
;;;2699             }
;;;2700   
;;;2701             /* Read data from DR */
;;;2702             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2703   
;;;2704             /* Increment Buffer pointer */
;;;2705             hi2c->pBuffPtr++;
;;;2706   
;;;2707             /* Update counter */
;;;2708             hi2c->XferSize--;
;;;2709             hi2c->XferCount--;
;;;2710           }
;;;2711           /* Two bytes */
;;;2712           else if (hi2c->XferSize == 2U)
;;;2713           {
;;;2714             /* Wait until BTF flag is set */
;;;2715             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2716             {
;;;2717               return HAL_ERROR;
;;;2718             }
;;;2719   
;;;2720             /* Generate Stop */
;;;2721             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2722   
;;;2723             /* Read data from DR */
;;;2724             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2725   
;;;2726             /* Increment Buffer pointer */
;;;2727             hi2c->pBuffPtr++;
;;;2728   
;;;2729             /* Update counter */
;;;2730             hi2c->XferSize--;
;;;2731             hi2c->XferCount--;
;;;2732   
;;;2733             /* Read data from DR */
;;;2734             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2735   
;;;2736             /* Increment Buffer pointer */
;;;2737             hi2c->pBuffPtr++;
;;;2738   
;;;2739             /* Update counter */
;;;2740             hi2c->XferSize--;
;;;2741             hi2c->XferCount--;
;;;2742           }
;;;2743           /* 3 Last bytes */
;;;2744           else
;;;2745           {
;;;2746             /* Wait until BTF flag is set */
;;;2747             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2748             {
;;;2749               return HAL_ERROR;
;;;2750             }
;;;2751   
;;;2752             /* Disable Acknowledge */
;;;2753             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2754   
;;;2755             /* Read data from DR */
;;;2756             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2757   
;;;2758             /* Increment Buffer pointer */
;;;2759             hi2c->pBuffPtr++;
;;;2760   
;;;2761             /* Update counter */
;;;2762             hi2c->XferSize--;
;;;2763             hi2c->XferCount--;
;;;2764   
;;;2765             /* Wait until BTF flag is set */
;;;2766             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2767             {
;;;2768               return HAL_ERROR;
;;;2769             }
;;;2770   
;;;2771             /* Generate Stop */
;;;2772             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2773   
;;;2774             /* Read data from DR */
;;;2775             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2776   
;;;2777             /* Increment Buffer pointer */
;;;2778             hi2c->pBuffPtr++;
;;;2779   
;;;2780             /* Update counter */
;;;2781             hi2c->XferSize--;
;;;2782             hi2c->XferCount--;
;;;2783   
;;;2784             /* Read data from DR */
;;;2785             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2786   
;;;2787             /* Increment Buffer pointer */
;;;2788             hi2c->pBuffPtr++;
;;;2789   
;;;2790             /* Update counter */
;;;2791             hi2c->XferSize--;
;;;2792             hi2c->XferCount--;
;;;2793           }
;;;2794         }
;;;2795         else
;;;2796         {
;;;2797           /* Wait until RXNE flag is set */
;;;2798           if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2799           {
;;;2800             return HAL_ERROR;
;;;2801           }
;;;2802   
;;;2803           /* Read data from DR */
;;;2804           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2805   
;;;2806           /* Increment Buffer pointer */
;;;2807           hi2c->pBuffPtr++;
;;;2808   
;;;2809           /* Update counter */
;;;2810           hi2c->XferSize--;
;;;2811           hi2c->XferCount--;
;;;2812   
;;;2813           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;2814           {
;;;2815             /* Read data from DR */
;;;2816             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2817   
;;;2818             /* Increment Buffer pointer */
;;;2819             hi2c->pBuffPtr++;
;;;2820   
;;;2821             /* Update counter */
;;;2822             hi2c->XferSize--;
;;;2823             hi2c->XferCount--;
;;;2824           }
;;;2825         }
;;;2826       }
;;;2827   
;;;2828       hi2c->State = HAL_I2C_STATE_READY;
;;;2829       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;2830   
;;;2831       /* Process Unlocked */
;;;2832       __HAL_UNLOCK(hi2c);
;;;2833   
;;;2834       return HAL_OK;
;;;2835     }
;;;2836     else
;;;2837     {
;;;2838       return HAL_BUSY;
;;;2839     }
;;;2840   }
000032  e8bd9ffc          POP      {r2-r12,pc}
                  |L30.54|
000036  bf00              NOP                            ;2624
000038  f894003c          LDRB     r0,[r4,#0x3c]         ;2624
00003c  2801              CMP      r0,#1                 ;2624
00003e  d101              BNE      |L30.68|
000040  2002              MOVS     r0,#2                 ;2624
000042  e7f6              B        |L30.50|
                  |L30.68|
000044  2001              MOVS     r0,#1                 ;2624
000046  f884003c          STRB     r0,[r4,#0x3c]         ;2624
00004a  bf00              NOP                            ;2624
00004c  6820              LDR      r0,[r4,#0]            ;2627
00004e  6800              LDR      r0,[r0,#0]            ;2627
000050  f0000001          AND      r0,r0,#1              ;2627
000054  b928              CBNZ     r0,|L30.98|
000056  6820              LDR      r0,[r4,#0]            ;2630
000058  6800              LDR      r0,[r0,#0]            ;2630
00005a  f0400001          ORR      r0,r0,#1              ;2630
00005e  6821              LDR      r1,[r4,#0]            ;2630
000060  6008              STR      r0,[r1,#0]            ;2630
                  |L30.98|
000062  6820              LDR      r0,[r4,#0]            ;2634
000064  6800              LDR      r0,[r0,#0]            ;2634
000066  f4206000          BIC      r0,r0,#0x800          ;2634
00006a  6821              LDR      r1,[r4,#0]            ;2634
00006c  6008              STR      r0,[r1,#0]            ;2634
00006e  2022              MOVS     r0,#0x22              ;2636
000070  f884003d          STRB     r0,[r4,#0x3d]         ;2636
000074  2040              MOVS     r0,#0x40              ;2637
000076  f884003e          STRB     r0,[r4,#0x3e]         ;2637
00007a  2000              MOVS     r0,#0                 ;2638
00007c  6420              STR      r0,[r4,#0x40]         ;2638
00007e  f8c4a024          STR      r10,[r4,#0x24]        ;2641
000082  f8a4b02a          STRH     r11,[r4,#0x2a]        ;2642
000086  8d60              LDRH     r0,[r4,#0x2a]         ;2643
000088  8520              STRH     r0,[r4,#0x28]         ;2643
00008a  4898              LDR      r0,|L30.748|
00008c  62e0              STR      r0,[r4,#0x2c]         ;2644
00008e  464b              MOV      r3,r9                 ;2647
000090  4642              MOV      r2,r8                 ;2647
000092  4639              MOV      r1,r7                 ;2647
000094  4620              MOV      r0,r4                 ;2647
000096  e9cd6500          STRD     r6,r5,[sp,#0]         ;2647
00009a  f7fffffe          BL       I2C_RequestMemoryRead
00009e  b108              CBZ      r0,|L30.164|
0000a0  2001              MOVS     r0,#1                 ;2649
0000a2  e7c6              B        |L30.50|
                  |L30.164|
0000a4  8d20              LDRH     r0,[r4,#0x28]         ;2652
0000a6  b988              CBNZ     r0,|L30.204|
0000a8  bf00              NOP                            ;2655
0000aa  2000              MOVS     r0,#0                 ;2655
0000ac  9001              STR      r0,[sp,#4]            ;2655
0000ae  6820              LDR      r0,[r4,#0]            ;2655
0000b0  6940              LDR      r0,[r0,#0x14]         ;2655
0000b2  9001              STR      r0,[sp,#4]            ;2655
0000b4  6820              LDR      r0,[r4,#0]            ;2655
0000b6  6980              LDR      r0,[r0,#0x18]         ;2655
0000b8  9001              STR      r0,[sp,#4]            ;2655
0000ba  bf00              NOP                            ;2655
0000bc  bf00              NOP                            ;2655
0000be  6820              LDR      r0,[r4,#0]            ;2658
0000c0  6800              LDR      r0,[r0,#0]            ;2658
0000c2  f4407000          ORR      r0,r0,#0x200          ;2658
0000c6  6821              LDR      r1,[r4,#0]            ;2658
0000c8  6008              STR      r0,[r1,#0]            ;2658
0000ca  e040              B        |L30.334|
                  |L30.204|
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;2660
0000ce  2801              CMP      r0,#1                 ;2660
0000d0  d118              BNE      |L30.260|
0000d2  6820              LDR      r0,[r4,#0]            ;2663
0000d4  6800              LDR      r0,[r0,#0]            ;2663
0000d6  f4206080          BIC      r0,r0,#0x400          ;2663
0000da  6821              LDR      r1,[r4,#0]            ;2663
0000dc  6008              STR      r0,[r1,#0]            ;2663
0000de  bf00              NOP                            ;2666
0000e0  2000              MOVS     r0,#0                 ;2666
0000e2  9001              STR      r0,[sp,#4]            ;2666
0000e4  6820              LDR      r0,[r4,#0]            ;2666
0000e6  6940              LDR      r0,[r0,#0x14]         ;2666
0000e8  9001              STR      r0,[sp,#4]            ;2666
0000ea  6820              LDR      r0,[r4,#0]            ;2666
0000ec  6980              LDR      r0,[r0,#0x18]         ;2666
0000ee  9001              STR      r0,[sp,#4]            ;2666
0000f0  bf00              NOP                            ;2666
0000f2  bf00              NOP                            ;2666
0000f4  6820              LDR      r0,[r4,#0]            ;2669
0000f6  6800              LDR      r0,[r0,#0]            ;2669
0000f8  f4407000          ORR      r0,r0,#0x200          ;2669
0000fc  6821              LDR      r1,[r4,#0]            ;2669
0000fe  6008              STR      r0,[r1,#0]            ;2669
000100  e025              B        |L30.334|
                  |L30.258|
000102  e0ef              B        |L30.740|
                  |L30.260|
000104  8d20              LDRH     r0,[r4,#0x28]         ;2671
000106  2802              CMP      r0,#2                 ;2671
000108  d116              BNE      |L30.312|
00010a  6820              LDR      r0,[r4,#0]            ;2674
00010c  6800              LDR      r0,[r0,#0]            ;2674
00010e  f4206080          BIC      r0,r0,#0x400          ;2674
000112  6821              LDR      r1,[r4,#0]            ;2674
000114  6008              STR      r0,[r1,#0]            ;2674
000116  6820              LDR      r0,[r4,#0]            ;2677
000118  6800              LDR      r0,[r0,#0]            ;2677
00011a  f4406000          ORR      r0,r0,#0x800          ;2677
00011e  6821              LDR      r1,[r4,#0]            ;2677
000120  6008              STR      r0,[r1,#0]            ;2677
000122  bf00              NOP                            ;2680
000124  2000              MOVS     r0,#0                 ;2680
000126  9001              STR      r0,[sp,#4]            ;2680
000128  6820              LDR      r0,[r4,#0]            ;2680
00012a  6940              LDR      r0,[r0,#0x14]         ;2680
00012c  9001              STR      r0,[sp,#4]            ;2680
00012e  6820              LDR      r0,[r4,#0]            ;2680
000130  6980              LDR      r0,[r0,#0x18]         ;2680
000132  9001              STR      r0,[sp,#4]            ;2680
000134  bf00              NOP                            ;2680
000136  e00a              B        |L30.334|
                  |L30.312|
000138  bf00              NOP                            ;2685
00013a  2000              MOVS     r0,#0                 ;2685
00013c  9001              STR      r0,[sp,#4]            ;2685
00013e  6820              LDR      r0,[r4,#0]            ;2685
000140  6940              LDR      r0,[r0,#0x14]         ;2685
000142  9001              STR      r0,[sp,#4]            ;2685
000144  6820              LDR      r0,[r4,#0]            ;2685
000146  6980              LDR      r0,[r0,#0x18]         ;2685
000148  9001              STR      r0,[sp,#4]            ;2685
00014a  bf00              NOP                            ;2685
00014c  bf00              NOP                            ;2685
                  |L30.334|
00014e  e0ba              B        |L30.710|
                  |L30.336|
000150  8d20              LDRH     r0,[r4,#0x28]         ;2690
000152  2803              CMP      r0,#3                 ;2690
000154  d87e              BHI      |L30.596|
000156  8d20              LDRH     r0,[r4,#0x28]         ;2693
000158  2801              CMP      r0,#1                 ;2693
00015a  d115              BNE      |L30.392|
00015c  462a              MOV      r2,r5                 ;2696
00015e  4631              MOV      r1,r6                 ;2696
000160  4620              MOV      r0,r4                 ;2696
000162  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000166  b108              CBZ      r0,|L30.364|
000168  2001              MOVS     r0,#1                 ;2698
00016a  e762              B        |L30.50|
                  |L30.364|
00016c  6820              LDR      r0,[r4,#0]            ;2702
00016e  6900              LDR      r0,[r0,#0x10]         ;2702
000170  6a61              LDR      r1,[r4,#0x24]         ;2702
000172  7008              STRB     r0,[r1,#0]            ;2702
000174  6a60              LDR      r0,[r4,#0x24]         ;2705
000176  1c40              ADDS     r0,r0,#1              ;2705
000178  6260              STR      r0,[r4,#0x24]         ;2705
00017a  8d20              LDRH     r0,[r4,#0x28]         ;2708
00017c  1e40              SUBS     r0,r0,#1              ;2708
00017e  8520              STRH     r0,[r4,#0x28]         ;2708
000180  8d60              LDRH     r0,[r4,#0x2a]         ;2709
000182  1e40              SUBS     r0,r0,#1              ;2709
000184  8560              STRH     r0,[r4,#0x2a]         ;2709
000186  e09e              B        |L30.710|
                  |L30.392|
000188  8d20              LDRH     r0,[r4,#0x28]         ;2712
00018a  2802              CMP      r0,#2                 ;2712
00018c  d12a              BNE      |L30.484|
00018e  4633              MOV      r3,r6                 ;2715
000190  2200              MOVS     r2,#0                 ;2715
000192  4957              LDR      r1,|L30.752|
000194  4620              MOV      r0,r4                 ;2715
000196  9500              STR      r5,[sp,#0]            ;2715
000198  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00019c  b108              CBZ      r0,|L30.418|
00019e  2001              MOVS     r0,#1                 ;2717
0001a0  e747              B        |L30.50|
                  |L30.418|
0001a2  6820              LDR      r0,[r4,#0]            ;2721
0001a4  6800              LDR      r0,[r0,#0]            ;2721
0001a6  f4407000          ORR      r0,r0,#0x200          ;2721
0001aa  6821              LDR      r1,[r4,#0]            ;2721
0001ac  6008              STR      r0,[r1,#0]            ;2721
0001ae  6820              LDR      r0,[r4,#0]            ;2724
0001b0  6900              LDR      r0,[r0,#0x10]         ;2724
0001b2  6a61              LDR      r1,[r4,#0x24]         ;2724
0001b4  7008              STRB     r0,[r1,#0]            ;2724
0001b6  6a60              LDR      r0,[r4,#0x24]         ;2727
0001b8  1c40              ADDS     r0,r0,#1              ;2727
0001ba  6260              STR      r0,[r4,#0x24]         ;2727
0001bc  8d20              LDRH     r0,[r4,#0x28]         ;2730
0001be  1e40              SUBS     r0,r0,#1              ;2730
0001c0  8520              STRH     r0,[r4,#0x28]         ;2730
0001c2  8d60              LDRH     r0,[r4,#0x2a]         ;2731
0001c4  1e40              SUBS     r0,r0,#1              ;2731
0001c6  8560              STRH     r0,[r4,#0x2a]         ;2731
0001c8  6820              LDR      r0,[r4,#0]            ;2734
0001ca  6900              LDR      r0,[r0,#0x10]         ;2734
0001cc  6a61              LDR      r1,[r4,#0x24]         ;2734
0001ce  7008              STRB     r0,[r1,#0]            ;2734
0001d0  6a60              LDR      r0,[r4,#0x24]         ;2737
0001d2  1c40              ADDS     r0,r0,#1              ;2737
0001d4  6260              STR      r0,[r4,#0x24]         ;2737
0001d6  8d20              LDRH     r0,[r4,#0x28]         ;2740
0001d8  1e40              SUBS     r0,r0,#1              ;2740
0001da  8520              STRH     r0,[r4,#0x28]         ;2740
0001dc  8d60              LDRH     r0,[r4,#0x2a]         ;2741
0001de  1e40              SUBS     r0,r0,#1              ;2741
0001e0  8560              STRH     r0,[r4,#0x2a]         ;2741
0001e2  e070              B        |L30.710|
                  |L30.484|
0001e4  4633              MOV      r3,r6                 ;2747
0001e6  2200              MOVS     r2,#0                 ;2747
0001e8  4941              LDR      r1,|L30.752|
0001ea  4620              MOV      r0,r4                 ;2747
0001ec  9500              STR      r5,[sp,#0]            ;2747
0001ee  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001f2  b108              CBZ      r0,|L30.504|
0001f4  2001              MOVS     r0,#1                 ;2749
0001f6  e71c              B        |L30.50|
                  |L30.504|
0001f8  6820              LDR      r0,[r4,#0]            ;2753
0001fa  6800              LDR      r0,[r0,#0]            ;2753
0001fc  f4206080          BIC      r0,r0,#0x400          ;2753
000200  6821              LDR      r1,[r4,#0]            ;2753
000202  6008              STR      r0,[r1,#0]            ;2753
000204  6820              LDR      r0,[r4,#0]            ;2756
000206  6900              LDR      r0,[r0,#0x10]         ;2756
000208  6a61              LDR      r1,[r4,#0x24]         ;2756
00020a  7008              STRB     r0,[r1,#0]            ;2756
00020c  6a60              LDR      r0,[r4,#0x24]         ;2759
00020e  1c40              ADDS     r0,r0,#1              ;2759
000210  6260              STR      r0,[r4,#0x24]         ;2759
000212  8d20              LDRH     r0,[r4,#0x28]         ;2762
000214  1e40              SUBS     r0,r0,#1              ;2762
000216  8520              STRH     r0,[r4,#0x28]         ;2762
000218  8d60              LDRH     r0,[r4,#0x2a]         ;2763
00021a  1e40              SUBS     r0,r0,#1              ;2763
00021c  8560              STRH     r0,[r4,#0x2a]         ;2763
00021e  4633              MOV      r3,r6                 ;2766
000220  2200              MOVS     r2,#0                 ;2766
000222  4933              LDR      r1,|L30.752|
000224  4620              MOV      r0,r4                 ;2766
000226  9500              STR      r5,[sp,#0]            ;2766
000228  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00022c  b108              CBZ      r0,|L30.562|
00022e  2001              MOVS     r0,#1                 ;2768
000230  e6ff              B        |L30.50|
                  |L30.562|
000232  6820              LDR      r0,[r4,#0]            ;2772
000234  6800              LDR      r0,[r0,#0]            ;2772
000236  f4407000          ORR      r0,r0,#0x200          ;2772
00023a  6821              LDR      r1,[r4,#0]            ;2772
00023c  6008              STR      r0,[r1,#0]            ;2772
00023e  6820              LDR      r0,[r4,#0]            ;2775
000240  6900              LDR      r0,[r0,#0x10]         ;2775
000242  6a61              LDR      r1,[r4,#0x24]         ;2775
000244  7008              STRB     r0,[r1,#0]            ;2775
000246  6a60              LDR      r0,[r4,#0x24]         ;2778
000248  1c40              ADDS     r0,r0,#1              ;2778
00024a  6260              STR      r0,[r4,#0x24]         ;2778
00024c  8d20              LDRH     r0,[r4,#0x28]         ;2781
00024e  1e40              SUBS     r0,r0,#1              ;2781
000250  8520              STRH     r0,[r4,#0x28]         ;2781
000252  e000              B        |L30.598|
                  |L30.596|
000254  e010              B        |L30.632|
                  |L30.598|
000256  8d60              LDRH     r0,[r4,#0x2a]         ;2782
000258  1e40              SUBS     r0,r0,#1              ;2782
00025a  8560              STRH     r0,[r4,#0x2a]         ;2782
00025c  6820              LDR      r0,[r4,#0]            ;2785
00025e  6900              LDR      r0,[r0,#0x10]         ;2785
000260  6a61              LDR      r1,[r4,#0x24]         ;2785
000262  7008              STRB     r0,[r1,#0]            ;2785
000264  6a60              LDR      r0,[r4,#0x24]         ;2788
000266  1c40              ADDS     r0,r0,#1              ;2788
000268  6260              STR      r0,[r4,#0x24]         ;2788
00026a  8d20              LDRH     r0,[r4,#0x28]         ;2791
00026c  1e40              SUBS     r0,r0,#1              ;2791
00026e  8520              STRH     r0,[r4,#0x28]         ;2791
000270  8d60              LDRH     r0,[r4,#0x2a]         ;2792
000272  1e40              SUBS     r0,r0,#1              ;2792
000274  8560              STRH     r0,[r4,#0x2a]         ;2792
000276  e026              B        |L30.710|
                  |L30.632|
000278  462a              MOV      r2,r5                 ;2798
00027a  4631              MOV      r1,r6                 ;2798
00027c  4620              MOV      r0,r4                 ;2798
00027e  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000282  b108              CBZ      r0,|L30.648|
000284  2001              MOVS     r0,#1                 ;2800
000286  e6d4              B        |L30.50|
                  |L30.648|
000288  6820              LDR      r0,[r4,#0]            ;2804
00028a  6900              LDR      r0,[r0,#0x10]         ;2804
00028c  6a61              LDR      r1,[r4,#0x24]         ;2804
00028e  7008              STRB     r0,[r1,#0]            ;2804
000290  6a60              LDR      r0,[r4,#0x24]         ;2807
000292  1c40              ADDS     r0,r0,#1              ;2807
000294  6260              STR      r0,[r4,#0x24]         ;2807
000296  8d20              LDRH     r0,[r4,#0x28]         ;2810
000298  1e40              SUBS     r0,r0,#1              ;2810
00029a  8520              STRH     r0,[r4,#0x28]         ;2810
00029c  8d60              LDRH     r0,[r4,#0x2a]         ;2811
00029e  1e40              SUBS     r0,r0,#1              ;2811
0002a0  8560              STRH     r0,[r4,#0x2a]         ;2811
0002a2  6820              LDR      r0,[r4,#0]            ;2813
0002a4  6940              LDR      r0,[r0,#0x14]         ;2813
0002a6  f3c00080          UBFX     r0,r0,#2,#1           ;2813
0002aa  b160              CBZ      r0,|L30.710|
0002ac  6820              LDR      r0,[r4,#0]            ;2816
0002ae  6900              LDR      r0,[r0,#0x10]         ;2816
0002b0  6a61              LDR      r1,[r4,#0x24]         ;2816
0002b2  7008              STRB     r0,[r1,#0]            ;2816
0002b4  6a60              LDR      r0,[r4,#0x24]         ;2819
0002b6  1c40              ADDS     r0,r0,#1              ;2819
0002b8  6260              STR      r0,[r4,#0x24]         ;2819
0002ba  8d20              LDRH     r0,[r4,#0x28]         ;2822
0002bc  1e40              SUBS     r0,r0,#1              ;2822
0002be  8520              STRH     r0,[r4,#0x28]         ;2822
0002c0  8d60              LDRH     r0,[r4,#0x2a]         ;2823
0002c2  1e40              SUBS     r0,r0,#1              ;2823
0002c4  8560              STRH     r0,[r4,#0x2a]         ;2823
                  |L30.710|
0002c6  8d20              LDRH     r0,[r4,#0x28]         ;2688
0002c8  2800              CMP      r0,#0                 ;2688
0002ca  f47faf41          BNE      |L30.336|
0002ce  2020              MOVS     r0,#0x20              ;2828
0002d0  f884003d          STRB     r0,[r4,#0x3d]         ;2828
0002d4  2000              MOVS     r0,#0                 ;2829
0002d6  f884003e          STRB     r0,[r4,#0x3e]         ;2829
0002da  bf00              NOP                            ;2832
0002dc  f884003c          STRB     r0,[r4,#0x3c]         ;2832
0002e0  bf00              NOP                            ;2832
0002e2  e6a6              B        |L30.50|
                  |L30.740|
0002e4  2002              MOVS     r0,#2                 ;2838
0002e6  e6a4              B        |L30.50|
;;;2841   
                          ENDP

                  |L30.744|
                          DCD      0x00100002
                  |L30.748|
                          DCD      0xffff0000
                  |L30.752|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Mem_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_DMA PROC
;;;3220     */
;;;3221   HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;3222   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
;;;3223     /* Init tickstart for timeout management*/
;;;3224     uint32_t tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4681              MOV      r9,r0
;;;3225     __IO uint32_t count = 0U;
000016  2000              MOVS     r0,#0
000018  9002              STR      r0,[sp,#8]
;;;3226     HAL_StatusTypeDef dmaxferstatus;
;;;3227   
;;;3228     /* Check the parameters */
;;;3229     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;3230   
;;;3231     if (hi2c->State == HAL_I2C_STATE_READY)
00001a  f894003d          LDRB     r0,[r4,#0x3d]
00001e  2820              CMP      r0,#0x20
000020  d17e              BNE      |L31.288|
;;;3232     {
;;;3233       /* Wait until BUSY flag is reset */
;;;3234       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000022  488f              LDR      r0,|L31.608|
000024  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000026  2119              MOVS     r1,#0x19
000028  fbb0f0f1          UDIV     r0,r0,r1
00002c  f44f717a          MOV      r1,#0x3e8
000030  fbb0f0f1          UDIV     r0,r0,r1
000034  eb0001c0          ADD      r1,r0,r0,LSL #3
000038  eb011000          ADD      r0,r1,r0,LSL #4
00003c  9002              STR      r0,[sp,#8]
;;;3235       do
00003e  bf00              NOP      
                  |L31.64|
;;;3236       {
;;;3237         count--;
000040  9802              LDR      r0,[sp,#8]
000042  1e40              SUBS     r0,r0,#1
000044  9002              STR      r0,[sp,#8]
;;;3238         if (count == 0U)
000046  9802              LDR      r0,[sp,#8]
000048  b998              CBNZ     r0,|L31.114|
;;;3239         {
;;;3240           hi2c->PreviousState       = I2C_STATE_NONE;
00004a  2000              MOVS     r0,#0
00004c  6320              STR      r0,[r4,#0x30]
;;;3241           hi2c->State               = HAL_I2C_STATE_READY;
00004e  2020              MOVS     r0,#0x20
000050  f884003d          STRB     r0,[r4,#0x3d]
;;;3242           hi2c->Mode                = HAL_I2C_MODE_NONE;
000054  2000              MOVS     r0,#0
000056  f884003e          STRB     r0,[r4,#0x3e]
;;;3243           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00005a  6c20              LDR      r0,[r4,#0x40]
00005c  f0400020          ORR      r0,r0,#0x20
000060  6420              STR      r0,[r4,#0x40]
;;;3244   
;;;3245           /* Process Unlocked */
;;;3246           __HAL_UNLOCK(hi2c);
000062  bf00              NOP      
000064  2000              MOVS     r0,#0
000066  f884003c          STRB     r0,[r4,#0x3c]
00006a  bf00              NOP      
;;;3247   
;;;3248           return HAL_ERROR;
00006c  2001              MOVS     r0,#1
                  |L31.110|
;;;3249         }
;;;3250       }
;;;3251       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3252   
;;;3253       /* Process Locked */
;;;3254       __HAL_LOCK(hi2c);
;;;3255   
;;;3256       /* Check if the I2C is already enabled */
;;;3257       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3258       {
;;;3259         /* Enable I2C peripheral */
;;;3260         __HAL_I2C_ENABLE(hi2c);
;;;3261       }
;;;3262   
;;;3263       /* Disable Pos */
;;;3264       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3265   
;;;3266       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3267       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;3268       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3269   
;;;3270       /* Prepare transfer parameters */
;;;3271       hi2c->pBuffPtr    = pData;
;;;3272       hi2c->XferCount   = Size;
;;;3273       hi2c->XferSize    = hi2c->XferCount;
;;;3274       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3275       hi2c->Devaddress  = DevAddress;
;;;3276       hi2c->Memaddress  = MemAddress;
;;;3277       hi2c->MemaddSize  = MemAddSize;
;;;3278       hi2c->EventCount  = 0U;
;;;3279   
;;;3280       if (hi2c->XferSize > 0U)
;;;3281       {
;;;3282         if (hi2c->hdmarx != NULL)
;;;3283         {
;;;3284           /* Set the I2C DMA transfer complete callback */
;;;3285           hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;3286   
;;;3287           /* Set the DMA error callback */
;;;3288           hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;3289   
;;;3290           /* Set the unused DMA callbacks to NULL */
;;;3291           hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;3292           hi2c->hdmarx->XferM1CpltCallback = NULL;
;;;3293           hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
;;;3294           hi2c->hdmarx->XferAbortCallback = NULL;
;;;3295   
;;;3296           /* Enable the DMA stream */
;;;3297           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;3298         }
;;;3299         else
;;;3300         {
;;;3301           /* Update I2C state */
;;;3302           hi2c->State     = HAL_I2C_STATE_READY;
;;;3303           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3304   
;;;3305           /* Update I2C error code */
;;;3306           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;3307   
;;;3308           /* Process Unlocked */
;;;3309           __HAL_UNLOCK(hi2c);
;;;3310   
;;;3311           return HAL_ERROR;
;;;3312         }
;;;3313   
;;;3314         if (dmaxferstatus == HAL_OK)
;;;3315         {
;;;3316           /* Send Slave Address and Memory Address */
;;;3317           if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3318           {
;;;3319             /* Abort the ongoing DMA */
;;;3320             dmaxferstatus = HAL_DMA_Abort_IT(hi2c->hdmarx);
;;;3321   
;;;3322             /* Prevent unused argument(s) compilation and MISRA warning */
;;;3323             UNUSED(dmaxferstatus);
;;;3324   
;;;3325             /* Set the unused I2C DMA transfer complete callback to NULL */
;;;3326             hi2c->hdmarx->XferCpltCallback = NULL;
;;;3327   
;;;3328             /* Disable Acknowledge */
;;;3329             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3330   
;;;3331             hi2c->XferSize = 0U;
;;;3332             hi2c->XferCount = 0U;
;;;3333   
;;;3334             /* Disable I2C peripheral to prevent dummy data in buffer */
;;;3335             __HAL_I2C_DISABLE(hi2c);
;;;3336   
;;;3337             return HAL_ERROR;
;;;3338           }
;;;3339   
;;;3340           if (hi2c->XferSize == 1U)
;;;3341           {
;;;3342             /* Disable Acknowledge */
;;;3343             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3344           }
;;;3345           else
;;;3346           {
;;;3347             /* Enable Last DMA bit */
;;;3348             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;3349           }
;;;3350   
;;;3351           /* Clear ADDR flag */
;;;3352           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3353   
;;;3354           /* Process Unlocked */
;;;3355           __HAL_UNLOCK(hi2c);
;;;3356   
;;;3357           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3358           to avoid the risk of I2C interrupt handle execution before current
;;;3359           process unlock */
;;;3360           /* Enable ERR interrupt */
;;;3361           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
;;;3362   
;;;3363           /* Enable DMA Request */
;;;3364           hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;3365         }
;;;3366         else
;;;3367         {
;;;3368           /* Update I2C state */
;;;3369           hi2c->State     = HAL_I2C_STATE_READY;
;;;3370           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3371   
;;;3372           /* Update I2C error code */
;;;3373           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3374   
;;;3375           /* Process Unlocked */
;;;3376           __HAL_UNLOCK(hi2c);
;;;3377   
;;;3378           return HAL_ERROR;
;;;3379         }
;;;3380       }
;;;3381       else
;;;3382       {
;;;3383         /* Send Slave Address and Memory Address */
;;;3384         if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3385         {
;;;3386           return HAL_ERROR;
;;;3387         }
;;;3388   
;;;3389         /* Clear ADDR flag */
;;;3390         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3391   
;;;3392         /* Generate Stop */
;;;3393         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3394   
;;;3395         hi2c->State = HAL_I2C_STATE_READY;
;;;3396   
;;;3397         /* Process Unlocked */
;;;3398         __HAL_UNLOCK(hi2c);
;;;3399       }
;;;3400   
;;;3401       return HAL_OK;
;;;3402     }
;;;3403     else
;;;3404     {
;;;3405       return HAL_BUSY;
;;;3406     }
;;;3407   }
00006e  e8bd8ffe          POP      {r1-r11,pc}
                  |L31.114|
000072  6820              LDR      r0,[r4,#0]            ;3251
000074  6980              LDR      r0,[r0,#0x18]         ;3251
000076  f3c00040          UBFX     r0,r0,#1,#1           ;3251
00007a  2800              CMP      r0,#0                 ;3251
00007c  d1e0              BNE      |L31.64|
00007e  bf00              NOP                            ;3254
000080  f894003c          LDRB     r0,[r4,#0x3c]         ;3254
000084  2801              CMP      r0,#1                 ;3254
000086  d101              BNE      |L31.140|
000088  2002              MOVS     r0,#2                 ;3254
00008a  e7f0              B        |L31.110|
                  |L31.140|
00008c  2001              MOVS     r0,#1                 ;3254
00008e  f884003c          STRB     r0,[r4,#0x3c]         ;3254
000092  bf00              NOP                            ;3254
000094  6820              LDR      r0,[r4,#0]            ;3257
000096  6800              LDR      r0,[r0,#0]            ;3257
000098  f0000001          AND      r0,r0,#1              ;3257
00009c  b928              CBNZ     r0,|L31.170|
00009e  6820              LDR      r0,[r4,#0]            ;3260
0000a0  6800              LDR      r0,[r0,#0]            ;3260
0000a2  f0400001          ORR      r0,r0,#1              ;3260
0000a6  6821              LDR      r1,[r4,#0]            ;3260
0000a8  6008              STR      r0,[r1,#0]            ;3260
                  |L31.170|
0000aa  6820              LDR      r0,[r4,#0]            ;3264
0000ac  6800              LDR      r0,[r0,#0]            ;3264
0000ae  f4206000          BIC      r0,r0,#0x800          ;3264
0000b2  6821              LDR      r1,[r4,#0]            ;3264
0000b4  6008              STR      r0,[r1,#0]            ;3264
0000b6  2022              MOVS     r0,#0x22              ;3266
0000b8  f884003d          STRB     r0,[r4,#0x3d]         ;3266
0000bc  2040              MOVS     r0,#0x40              ;3267
0000be  f884003e          STRB     r0,[r4,#0x3e]         ;3267
0000c2  2000              MOVS     r0,#0                 ;3268
0000c4  6420              STR      r0,[r4,#0x40]         ;3268
0000c6  f8c4a024          STR      r10,[r4,#0x24]        ;3271
0000ca  f8a4b02a          STRH     r11,[r4,#0x2a]        ;3272
0000ce  8d60              LDRH     r0,[r4,#0x2a]         ;3273
0000d0  8520              STRH     r0,[r4,#0x28]         ;3273
0000d2  4864              LDR      r0,|L31.612|
0000d4  62e0              STR      r0,[r4,#0x2c]         ;3274
0000d6  6466              STR      r6,[r4,#0x44]         ;3275
0000d8  64a7              STR      r7,[r4,#0x48]         ;3276
0000da  f8c4804c          STR      r8,[r4,#0x4c]         ;3277
0000de  2000              MOVS     r0,#0                 ;3278
0000e0  6520              STR      r0,[r4,#0x50]         ;3278
0000e2  8d20              LDRH     r0,[r4,#0x28]         ;3280
0000e4  2800              CMP      r0,#0                 ;3280
0000e6  d07d              BEQ      |L31.484|
0000e8  6ba0              LDR      r0,[r4,#0x38]         ;3282
0000ea  b1d0              CBZ      r0,|L31.290|
0000ec  485e              LDR      r0,|L31.616|
0000ee  6ba1              LDR      r1,[r4,#0x38]         ;3285
0000f0  63c8              STR      r0,[r1,#0x3c]         ;3285
0000f2  485e              LDR      r0,|L31.620|
0000f4  6ba1              LDR      r1,[r4,#0x38]         ;3288
0000f6  64c8              STR      r0,[r1,#0x4c]         ;3288
0000f8  2000              MOVS     r0,#0                 ;3291
0000fa  6ba1              LDR      r1,[r4,#0x38]         ;3291
0000fc  6408              STR      r0,[r1,#0x40]         ;3291
0000fe  6ba1              LDR      r1,[r4,#0x38]         ;3292
000100  6448              STR      r0,[r1,#0x44]         ;3292
000102  6ba1              LDR      r1,[r4,#0x38]         ;3293
000104  6488              STR      r0,[r1,#0x48]         ;3293
000106  6ba1              LDR      r1,[r4,#0x38]         ;3294
000108  6508              STR      r0,[r1,#0x50]         ;3294
00010a  8d23              LDRH     r3,[r4,#0x28]         ;3297
00010c  f8d4c000          LDR      r12,[r4,#0]           ;3297
000110  f10c0110          ADD      r1,r12,#0x10          ;3297
000114  6a62              LDR      r2,[r4,#0x24]         ;3297
000116  6ba0              LDR      r0,[r4,#0x38]         ;3297
000118  f7fffffe          BL       HAL_DMA_Start_IT
00011c  4605              MOV      r5,r0                 ;3297
00011e  e011              B        |L31.324|
                  |L31.288|
000120  e09b              B        |L31.602|
                  |L31.290|
000122  2020              MOVS     r0,#0x20              ;3302
000124  f884003d          STRB     r0,[r4,#0x3d]         ;3302
000128  2000              MOVS     r0,#0                 ;3303
00012a  f884003e          STRB     r0,[r4,#0x3e]         ;3303
00012e  6c20              LDR      r0,[r4,#0x40]         ;3306
000130  f0400080          ORR      r0,r0,#0x80           ;3306
000134  6420              STR      r0,[r4,#0x40]         ;3306
000136  bf00              NOP                            ;3309
000138  2000              MOVS     r0,#0                 ;3309
00013a  f884003c          STRB     r0,[r4,#0x3c]         ;3309
00013e  bf00              NOP                            ;3309
000140  2001              MOVS     r0,#1                 ;3311
000142  e794              B        |L31.110|
                  |L31.324|
000144  2d00              CMP      r5,#0                 ;3314
000146  d150              BNE      |L31.490|
000148  2023              MOVS     r0,#0x23              ;3317
00014a  4643              MOV      r3,r8                 ;3317
00014c  463a              MOV      r2,r7                 ;3317
00014e  4631              MOV      r1,r6                 ;3317
000150  e9cd0900          STRD     r0,r9,[sp,#0]         ;3317
000154  4620              MOV      r0,r4                 ;3317
000156  f7fffffe          BL       I2C_RequestMemoryRead
00015a  b1b8              CBZ      r0,|L31.396|
00015c  6ba0              LDR      r0,[r4,#0x38]         ;3320
00015e  f7fffffe          BL       HAL_DMA_Abort_IT
000162  4605              MOV      r5,r0                 ;3320
000164  2000              MOVS     r0,#0                 ;3326
000166  6ba1              LDR      r1,[r4,#0x38]         ;3326
000168  63c8              STR      r0,[r1,#0x3c]         ;3326
00016a  6820              LDR      r0,[r4,#0]            ;3329
00016c  6800              LDR      r0,[r0,#0]            ;3329
00016e  f4206080          BIC      r0,r0,#0x400          ;3329
000172  6821              LDR      r1,[r4,#0]            ;3329
000174  6008              STR      r0,[r1,#0]            ;3329
000176  2000              MOVS     r0,#0                 ;3331
000178  8520              STRH     r0,[r4,#0x28]         ;3331
00017a  8560              STRH     r0,[r4,#0x2a]         ;3332
00017c  6820              LDR      r0,[r4,#0]            ;3335
00017e  6800              LDR      r0,[r0,#0]            ;3335
000180  f0200001          BIC      r0,r0,#1              ;3335
000184  6821              LDR      r1,[r4,#0]            ;3335
000186  6008              STR      r0,[r1,#0]            ;3335
000188  2001              MOVS     r0,#1                 ;3337
00018a  e770              B        |L31.110|
                  |L31.396|
00018c  8d20              LDRH     r0,[r4,#0x28]         ;3340
00018e  2801              CMP      r0,#1                 ;3340
000190  d106              BNE      |L31.416|
000192  6820              LDR      r0,[r4,#0]            ;3343
000194  6800              LDR      r0,[r0,#0]            ;3343
000196  f4206080          BIC      r0,r0,#0x400          ;3343
00019a  6821              LDR      r1,[r4,#0]            ;3343
00019c  6008              STR      r0,[r1,#0]            ;3343
00019e  e005              B        |L31.428|
                  |L31.416|
0001a0  6820              LDR      r0,[r4,#0]            ;3348
0001a2  6840              LDR      r0,[r0,#4]            ;3348
0001a4  f4405080          ORR      r0,r0,#0x1000         ;3348
0001a8  6821              LDR      r1,[r4,#0]            ;3348
0001aa  6048              STR      r0,[r1,#4]            ;3348
                  |L31.428|
0001ac  bf00              NOP                            ;3352
0001ae  2000              MOVS     r0,#0                 ;3352
0001b0  9001              STR      r0,[sp,#4]            ;3352
0001b2  6820              LDR      r0,[r4,#0]            ;3352
0001b4  6940              LDR      r0,[r0,#0x14]         ;3352
0001b6  9001              STR      r0,[sp,#4]            ;3352
0001b8  6820              LDR      r0,[r4,#0]            ;3352
0001ba  6980              LDR      r0,[r0,#0x18]         ;3352
0001bc  9001              STR      r0,[sp,#4]            ;3352
0001be  bf00              NOP                            ;3352
0001c0  bf00              NOP                            ;3352
0001c2  bf00              NOP                            ;3355
0001c4  2000              MOVS     r0,#0                 ;3355
0001c6  f884003c          STRB     r0,[r4,#0x3c]         ;3355
0001ca  bf00              NOP                            ;3355
0001cc  6820              LDR      r0,[r4,#0]            ;3361
0001ce  6840              LDR      r0,[r0,#4]            ;3361
0001d0  f4407080          ORR      r0,r0,#0x100          ;3361
0001d4  6821              LDR      r1,[r4,#0]            ;3361
0001d6  6048              STR      r0,[r1,#4]            ;3361
0001d8  6820              LDR      r0,[r4,#0]            ;3364
0001da  6840              LDR      r0,[r0,#4]            ;3364
0001dc  f4406000          ORR      r0,r0,#0x800          ;3364
0001e0  6821              LDR      r1,[r4,#0]            ;3364
0001e2  e000              B        |L31.486|
                  |L31.484|
0001e4  e012              B        |L31.524|
                  |L31.486|
0001e6  6048              STR      r0,[r1,#4]            ;3364
0001e8  e035              B        |L31.598|
                  |L31.490|
0001ea  2020              MOVS     r0,#0x20              ;3369
0001ec  f884003d          STRB     r0,[r4,#0x3d]         ;3369
0001f0  2000              MOVS     r0,#0                 ;3370
0001f2  f884003e          STRB     r0,[r4,#0x3e]         ;3370
0001f6  6c20              LDR      r0,[r4,#0x40]         ;3373
0001f8  f0400010          ORR      r0,r0,#0x10           ;3373
0001fc  6420              STR      r0,[r4,#0x40]         ;3373
0001fe  bf00              NOP                            ;3376
000200  2000              MOVS     r0,#0                 ;3376
000202  f884003c          STRB     r0,[r4,#0x3c]         ;3376
000206  bf00              NOP                            ;3376
000208  2001              MOVS     r0,#1                 ;3378
00020a  e730              B        |L31.110|
                  |L31.524|
00020c  2023              MOVS     r0,#0x23              ;3384
00020e  4643              MOV      r3,r8                 ;3384
000210  463a              MOV      r2,r7                 ;3384
000212  4631              MOV      r1,r6                 ;3384
000214  e9cd0900          STRD     r0,r9,[sp,#0]         ;3384
000218  4620              MOV      r0,r4                 ;3384
00021a  f7fffffe          BL       I2C_RequestMemoryRead
00021e  b108              CBZ      r0,|L31.548|
000220  2001              MOVS     r0,#1                 ;3386
000222  e724              B        |L31.110|
                  |L31.548|
000224  bf00              NOP                            ;3390
000226  2000              MOVS     r0,#0                 ;3390
000228  9001              STR      r0,[sp,#4]            ;3390
00022a  6820              LDR      r0,[r4,#0]            ;3390
00022c  6940              LDR      r0,[r0,#0x14]         ;3390
00022e  9001              STR      r0,[sp,#4]            ;3390
000230  6820              LDR      r0,[r4,#0]            ;3390
000232  6980              LDR      r0,[r0,#0x18]         ;3390
000234  9001              STR      r0,[sp,#4]            ;3390
000236  bf00              NOP                            ;3390
000238  bf00              NOP                            ;3390
00023a  6820              LDR      r0,[r4,#0]            ;3393
00023c  6800              LDR      r0,[r0,#0]            ;3393
00023e  f4407000          ORR      r0,r0,#0x200          ;3393
000242  6821              LDR      r1,[r4,#0]            ;3393
000244  6008              STR      r0,[r1,#0]            ;3393
000246  2020              MOVS     r0,#0x20              ;3395
000248  f884003d          STRB     r0,[r4,#0x3d]         ;3395
00024c  bf00              NOP                            ;3398
00024e  2000              MOVS     r0,#0                 ;3398
000250  f884003c          STRB     r0,[r4,#0x3c]         ;3398
000254  bf00              NOP                            ;3398
                  |L31.598|
000256  2000              MOVS     r0,#0                 ;3401
000258  e709              B        |L31.110|
                  |L31.602|
00025a  2002              MOVS     r0,#2                 ;3405
00025c  e707              B        |L31.110|
;;;3408   
                          ENDP

00025e  0000              DCW      0x0000
                  |L31.608|
                          DCD      SystemCoreClock
                  |L31.612|
                          DCD      0xffff0000
                  |L31.616|
                          DCD      I2C_DMAXferCplt
                  |L31.620|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Read_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_IT PROC
;;;2941     */
;;;2942   HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2943   {
000002  4604              MOV      r4,r0
000004  e9dd5606          LDRD     r5,r6,[sp,#0x18]
;;;2944     __IO uint32_t count = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2945   
;;;2946     /* Check the parameters */
;;;2947     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2948   
;;;2949     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2820              CMP      r0,#0x20
000012  d177              BNE      |L32.260|
;;;2950     {
;;;2951       /* Wait until BUSY flag is reset */
;;;2952       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000014  483c              LDR      r0,|L32.264|
000016  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000018  2719              MOVS     r7,#0x19
00001a  fbb0f0f7          UDIV     r0,r0,r7
00001e  f44f777a          MOV      r7,#0x3e8
000022  fbb0f0f7          UDIV     r0,r0,r7
000026  eb0007c0          ADD      r7,r0,r0,LSL #3
00002a  eb071000          ADD      r0,r7,r0,LSL #4
00002e  9000              STR      r0,[sp,#0]
;;;2953       do
000030  bf00              NOP      
                  |L32.50|
;;;2954       {
;;;2955         count--;
000032  9800              LDR      r0,[sp,#0]
000034  1e40              SUBS     r0,r0,#1
000036  9000              STR      r0,[sp,#0]
;;;2956         if (count == 0U)
000038  9800              LDR      r0,[sp,#0]
00003a  b990              CBNZ     r0,|L32.98|
;;;2957         {
;;;2958           hi2c->PreviousState       = I2C_STATE_NONE;
00003c  2000              MOVS     r0,#0
00003e  6320              STR      r0,[r4,#0x30]
;;;2959           hi2c->State               = HAL_I2C_STATE_READY;
000040  2020              MOVS     r0,#0x20
000042  f884003d          STRB     r0,[r4,#0x3d]
;;;2960           hi2c->Mode                = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;2961           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00004c  6c20              LDR      r0,[r4,#0x40]
00004e  f0400020          ORR      r0,r0,#0x20
000052  6420              STR      r0,[r4,#0x40]
;;;2962   
;;;2963           /* Process Unlocked */
;;;2964           __HAL_UNLOCK(hi2c);
000054  bf00              NOP      
000056  2000              MOVS     r0,#0
000058  f884003c          STRB     r0,[r4,#0x3c]
00005c  bf00              NOP      
;;;2965   
;;;2966           return HAL_ERROR;
00005e  2001              MOVS     r0,#1
                  |L32.96|
;;;2967         }
;;;2968       }
;;;2969       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2970   
;;;2971       /* Process Locked */
;;;2972       __HAL_LOCK(hi2c);
;;;2973   
;;;2974       /* Check if the I2C is already enabled */
;;;2975       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2976       {
;;;2977         /* Enable I2C peripheral */
;;;2978         __HAL_I2C_ENABLE(hi2c);
;;;2979       }
;;;2980   
;;;2981       /* Disable Pos */
;;;2982       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2983   
;;;2984       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2985       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2986       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2987   
;;;2988       /* Prepare transfer parameters */
;;;2989       hi2c->pBuffPtr    = pData;
;;;2990       hi2c->XferCount   = Size;
;;;2991       hi2c->XferSize    = hi2c->XferCount;
;;;2992       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2993       hi2c->Devaddress  = DevAddress;
;;;2994       hi2c->Memaddress  = MemAddress;
;;;2995       hi2c->MemaddSize  = MemAddSize;
;;;2996       hi2c->EventCount  = 0U;
;;;2997   
;;;2998       /* Enable Acknowledge */
;;;2999       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3000   
;;;3001       /* Generate Start */
;;;3002       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3003   
;;;3004       /* Process Unlocked */
;;;3005       __HAL_UNLOCK(hi2c);
;;;3006   
;;;3007       if (hi2c->XferSize > 0U)
;;;3008       {
;;;3009         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3010         to avoid the risk of I2C interrupt handle execution before current
;;;3011         process unlock */
;;;3012   
;;;3013         /* Enable EVT, BUF and ERR interrupt */
;;;3014         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3015       }
;;;3016       return HAL_OK;
;;;3017     }
;;;3018     else
;;;3019     {
;;;3020       return HAL_BUSY;
;;;3021     }
;;;3022   }
000060  bdf8              POP      {r3-r7,pc}
                  |L32.98|
000062  6820              LDR      r0,[r4,#0]            ;2969
000064  6980              LDR      r0,[r0,#0x18]         ;2969
000066  f3c00040          UBFX     r0,r0,#1,#1           ;2969
00006a  2800              CMP      r0,#0                 ;2969
00006c  d1e1              BNE      |L32.50|
00006e  bf00              NOP                            ;2972
000070  f894003c          LDRB     r0,[r4,#0x3c]         ;2972
000074  2801              CMP      r0,#1                 ;2972
000076  d101              BNE      |L32.124|
000078  2002              MOVS     r0,#2                 ;2972
00007a  e7f1              B        |L32.96|
                  |L32.124|
00007c  2001              MOVS     r0,#1                 ;2972
00007e  f884003c          STRB     r0,[r4,#0x3c]         ;2972
000082  bf00              NOP                            ;2972
000084  6820              LDR      r0,[r4,#0]            ;2975
000086  6800              LDR      r0,[r0,#0]            ;2975
000088  f0000001          AND      r0,r0,#1              ;2975
00008c  b928              CBNZ     r0,|L32.154|
00008e  6820              LDR      r0,[r4,#0]            ;2978
000090  6800              LDR      r0,[r0,#0]            ;2978
000092  f0400001          ORR      r0,r0,#1              ;2978
000096  6827              LDR      r7,[r4,#0]            ;2978
000098  6038              STR      r0,[r7,#0]            ;2978
                  |L32.154|
00009a  6820              LDR      r0,[r4,#0]            ;2982
00009c  6800              LDR      r0,[r0,#0]            ;2982
00009e  f4206000          BIC      r0,r0,#0x800          ;2982
0000a2  6827              LDR      r7,[r4,#0]            ;2982
0000a4  6038              STR      r0,[r7,#0]            ;2982
0000a6  2022              MOVS     r0,#0x22              ;2984
0000a8  f884003d          STRB     r0,[r4,#0x3d]         ;2984
0000ac  2040              MOVS     r0,#0x40              ;2985
0000ae  f884003e          STRB     r0,[r4,#0x3e]         ;2985
0000b2  2000              MOVS     r0,#0                 ;2986
0000b4  6420              STR      r0,[r4,#0x40]         ;2986
0000b6  6265              STR      r5,[r4,#0x24]         ;2989
0000b8  8566              STRH     r6,[r4,#0x2a]         ;2990
0000ba  8d60              LDRH     r0,[r4,#0x2a]         ;2991
0000bc  8520              STRH     r0,[r4,#0x28]         ;2991
0000be  4813              LDR      r0,|L32.268|
0000c0  62e0              STR      r0,[r4,#0x2c]         ;2992
0000c2  6461              STR      r1,[r4,#0x44]         ;2993
0000c4  64a2              STR      r2,[r4,#0x48]         ;2994
0000c6  64e3              STR      r3,[r4,#0x4c]         ;2995
0000c8  2000              MOVS     r0,#0                 ;2996
0000ca  6520              STR      r0,[r4,#0x50]         ;2996
0000cc  6820              LDR      r0,[r4,#0]            ;2999
0000ce  6800              LDR      r0,[r0,#0]            ;2999
0000d0  f4406080          ORR      r0,r0,#0x400          ;2999
0000d4  6827              LDR      r7,[r4,#0]            ;2999
0000d6  6038              STR      r0,[r7,#0]            ;2999
0000d8  6820              LDR      r0,[r4,#0]            ;3002
0000da  6800              LDR      r0,[r0,#0]            ;3002
0000dc  f4407080          ORR      r0,r0,#0x100          ;3002
0000e0  6827              LDR      r7,[r4,#0]            ;3002
0000e2  6038              STR      r0,[r7,#0]            ;3002
0000e4  bf00              NOP                            ;3005
0000e6  2000              MOVS     r0,#0                 ;3005
0000e8  f884003c          STRB     r0,[r4,#0x3c]         ;3005
0000ec  bf00              NOP                            ;3005
0000ee  8d20              LDRH     r0,[r4,#0x28]         ;3007
0000f0  b128              CBZ      r0,|L32.254|
0000f2  6820              LDR      r0,[r4,#0]            ;3014
0000f4  6840              LDR      r0,[r0,#4]            ;3014
0000f6  f44060e0          ORR      r0,r0,#0x700          ;3014
0000fa  6827              LDR      r7,[r4,#0]            ;3014
0000fc  6078              STR      r0,[r7,#4]            ;3014
                  |L32.254|
0000fe  2000              MOVS     r0,#0                 ;3016
000100  e7ae              B        |L32.96|
000102  e7ff              B        |L32.260|
                  |L32.260|
000104  2002              MOVS     r0,#2                 ;3020
000106  e7ab              B        |L32.96|
;;;3023   
                          ENDP

                  |L32.264|
                          DCD      SystemCoreClock
                  |L32.268|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Mem_Write||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write PROC
;;;2483     */
;;;2484   HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2485   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
000010  9e0e              LDR      r6,[sp,#0x38]
;;;2486     /* Init tickstart for timeout management*/
;;;2487     uint32_t tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;2488   
;;;2489     /* Check the parameters */
;;;2490     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2491   
;;;2492     if (hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d17d              BNE      |L33.284|
;;;2493     {
;;;2494       /* Wait until BUSY flag is reset */
;;;2495       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
000020  2319              MOVS     r3,#0x19
000022  2201              MOVS     r2,#1
000024  494d              LDR      r1,|L33.348|
000026  4620              MOV      r0,r4
000028  9500              STR      r5,[sp,#0]
00002a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002e  b110              CBZ      r0,|L33.54|
;;;2496       {
;;;2497         return HAL_BUSY;
000030  2002              MOVS     r0,#2
                  |L33.50|
;;;2498       }
;;;2499   
;;;2500       /* Process Locked */
;;;2501       __HAL_LOCK(hi2c);
;;;2502   
;;;2503       /* Check if the I2C is already enabled */
;;;2504       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2505       {
;;;2506         /* Enable I2C peripheral */
;;;2507         __HAL_I2C_ENABLE(hi2c);
;;;2508       }
;;;2509   
;;;2510       /* Disable Pos */
;;;2511       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2512   
;;;2513       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2514       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2515       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2516   
;;;2517       /* Prepare transfer parameters */
;;;2518       hi2c->pBuffPtr    = pData;
;;;2519       hi2c->XferCount   = Size;
;;;2520       hi2c->XferSize    = hi2c->XferCount;
;;;2521       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2522   
;;;2523       /* Send Slave Address and Memory Address */
;;;2524       if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2525       {
;;;2526         return HAL_ERROR;
;;;2527       }
;;;2528   
;;;2529       while (hi2c->XferSize > 0U)
;;;2530       {
;;;2531         /* Wait until TXE flag is set */
;;;2532         if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2533         {
;;;2534           if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2535           {
;;;2536             /* Generate Stop */
;;;2537             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2538           }
;;;2539           return HAL_ERROR;
;;;2540         }
;;;2541   
;;;2542         /* Write data to DR */
;;;2543         hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;2544   
;;;2545         /* Increment Buffer pointer */
;;;2546         hi2c->pBuffPtr++;
;;;2547   
;;;2548         /* Update counter */
;;;2549         hi2c->XferSize--;
;;;2550         hi2c->XferCount--;
;;;2551   
;;;2552         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;2553         {
;;;2554           /* Write data to DR */
;;;2555           hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;2556   
;;;2557           /* Increment Buffer pointer */
;;;2558           hi2c->pBuffPtr++;
;;;2559   
;;;2560           /* Update counter */
;;;2561           hi2c->XferSize--;
;;;2562           hi2c->XferCount--;
;;;2563         }
;;;2564       }
;;;2565   
;;;2566       /* Wait until BTF flag is set */
;;;2567       if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2568       {
;;;2569         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2570         {
;;;2571           /* Generate Stop */
;;;2572           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2573         }
;;;2574         return HAL_ERROR;
;;;2575       }
;;;2576   
;;;2577       /* Generate Stop */
;;;2578       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2579   
;;;2580       hi2c->State = HAL_I2C_STATE_READY;
;;;2581       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;2582   
;;;2583       /* Process Unlocked */
;;;2584       __HAL_UNLOCK(hi2c);
;;;2585   
;;;2586       return HAL_OK;
;;;2587     }
;;;2588     else
;;;2589     {
;;;2590       return HAL_BUSY;
;;;2591     }
;;;2592   }
000032  e8bd9ffc          POP      {r2-r12,pc}
                  |L33.54|
000036  bf00              NOP                            ;2501
000038  f894003c          LDRB     r0,[r4,#0x3c]         ;2501
00003c  2801              CMP      r0,#1                 ;2501
00003e  d101              BNE      |L33.68|
000040  2002              MOVS     r0,#2                 ;2501
000042  e7f6              B        |L33.50|
                  |L33.68|
000044  2001              MOVS     r0,#1                 ;2501
000046  f884003c          STRB     r0,[r4,#0x3c]         ;2501
00004a  bf00              NOP                            ;2501
00004c  6820              LDR      r0,[r4,#0]            ;2504
00004e  6800              LDR      r0,[r0,#0]            ;2504
000050  f0000001          AND      r0,r0,#1              ;2504
000054  b928              CBNZ     r0,|L33.98|
000056  6820              LDR      r0,[r4,#0]            ;2507
000058  6800              LDR      r0,[r0,#0]            ;2507
00005a  f0400001          ORR      r0,r0,#1              ;2507
00005e  6821              LDR      r1,[r4,#0]            ;2507
000060  6008              STR      r0,[r1,#0]            ;2507
                  |L33.98|
000062  6820              LDR      r0,[r4,#0]            ;2511
000064  6800              LDR      r0,[r0,#0]            ;2511
000066  f4206000          BIC      r0,r0,#0x800          ;2511
00006a  6821              LDR      r1,[r4,#0]            ;2511
00006c  6008              STR      r0,[r1,#0]            ;2511
00006e  2021              MOVS     r0,#0x21              ;2513
000070  f884003d          STRB     r0,[r4,#0x3d]         ;2513
000074  2040              MOVS     r0,#0x40              ;2514
000076  f884003e          STRB     r0,[r4,#0x3e]         ;2514
00007a  2000              MOVS     r0,#0                 ;2515
00007c  6420              STR      r0,[r4,#0x40]         ;2515
00007e  f8c4a024          STR      r10,[r4,#0x24]        ;2518
000082  f8a4b02a          STRH     r11,[r4,#0x2a]        ;2519
000086  8d60              LDRH     r0,[r4,#0x2a]         ;2520
000088  8520              STRH     r0,[r4,#0x28]         ;2520
00008a  4835              LDR      r0,|L33.352|
00008c  62e0              STR      r0,[r4,#0x2c]         ;2521
00008e  464b              MOV      r3,r9                 ;2524
000090  4642              MOV      r2,r8                 ;2524
000092  4639              MOV      r1,r7                 ;2524
000094  4620              MOV      r0,r4                 ;2524
000096  e9cd6500          STRD     r6,r5,[sp,#0]         ;2524
00009a  f7fffffe          BL       I2C_RequestMemoryWrite
00009e  b108              CBZ      r0,|L33.164|
0000a0  2001              MOVS     r0,#1                 ;2526
0000a2  e7c6              B        |L33.50|
                  |L33.164|
0000a4  e031              B        |L33.266|
                  |L33.166|
0000a6  462a              MOV      r2,r5                 ;2532
0000a8  4631              MOV      r1,r6                 ;2532
0000aa  4620              MOV      r0,r4                 ;2532
0000ac  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000b0  b150              CBZ      r0,|L33.200|
0000b2  6c20              LDR      r0,[r4,#0x40]         ;2534
0000b4  2804              CMP      r0,#4                 ;2534
0000b6  d105              BNE      |L33.196|
0000b8  6820              LDR      r0,[r4,#0]            ;2537
0000ba  6800              LDR      r0,[r0,#0]            ;2537
0000bc  f4407000          ORR      r0,r0,#0x200          ;2537
0000c0  6821              LDR      r1,[r4,#0]            ;2537
0000c2  6008              STR      r0,[r1,#0]            ;2537
                  |L33.196|
0000c4  2001              MOVS     r0,#1                 ;2539
0000c6  e7b4              B        |L33.50|
                  |L33.200|
0000c8  6a60              LDR      r0,[r4,#0x24]         ;2543
0000ca  7800              LDRB     r0,[r0,#0]            ;2543
0000cc  6821              LDR      r1,[r4,#0]            ;2543
0000ce  6108              STR      r0,[r1,#0x10]         ;2543
0000d0  6a60              LDR      r0,[r4,#0x24]         ;2546
0000d2  1c40              ADDS     r0,r0,#1              ;2546
0000d4  6260              STR      r0,[r4,#0x24]         ;2546
0000d6  8d20              LDRH     r0,[r4,#0x28]         ;2549
0000d8  1e40              SUBS     r0,r0,#1              ;2549
0000da  8520              STRH     r0,[r4,#0x28]         ;2549
0000dc  8d60              LDRH     r0,[r4,#0x2a]         ;2550
0000de  1e40              SUBS     r0,r0,#1              ;2550
0000e0  8560              STRH     r0,[r4,#0x2a]         ;2550
0000e2  6820              LDR      r0,[r4,#0]            ;2552
0000e4  6940              LDR      r0,[r0,#0x14]         ;2552
0000e6  f3c00080          UBFX     r0,r0,#2,#1           ;2552
0000ea  b170              CBZ      r0,|L33.266|
0000ec  8d20              LDRH     r0,[r4,#0x28]         ;2552
0000ee  b160              CBZ      r0,|L33.266|
0000f0  6a60              LDR      r0,[r4,#0x24]         ;2555
0000f2  7800              LDRB     r0,[r0,#0]            ;2555
0000f4  6821              LDR      r1,[r4,#0]            ;2555
0000f6  6108              STR      r0,[r1,#0x10]         ;2555
0000f8  6a60              LDR      r0,[r4,#0x24]         ;2558
0000fa  1c40              ADDS     r0,r0,#1              ;2558
0000fc  6260              STR      r0,[r4,#0x24]         ;2558
0000fe  8d20              LDRH     r0,[r4,#0x28]         ;2561
000100  1e40              SUBS     r0,r0,#1              ;2561
000102  8520              STRH     r0,[r4,#0x28]         ;2561
000104  8d60              LDRH     r0,[r4,#0x2a]         ;2562
000106  1e40              SUBS     r0,r0,#1              ;2562
000108  8560              STRH     r0,[r4,#0x2a]         ;2562
                  |L33.266|
00010a  8d20              LDRH     r0,[r4,#0x28]         ;2529
00010c  2800              CMP      r0,#0                 ;2529
00010e  d1ca              BNE      |L33.166|
000110  462a              MOV      r2,r5                 ;2567
000112  4631              MOV      r1,r6                 ;2567
000114  4620              MOV      r0,r4                 ;2567
000116  f7fffffe          BL       I2C_WaitOnBTFFlagUntilTimeout
00011a  e000              B        |L33.286|
                  |L33.284|
00011c  e01c              B        |L33.344|
                  |L33.286|
00011e  b150              CBZ      r0,|L33.310|
000120  6c20              LDR      r0,[r4,#0x40]         ;2569
000122  2804              CMP      r0,#4                 ;2569
000124  d105              BNE      |L33.306|
000126  6820              LDR      r0,[r4,#0]            ;2572
000128  6800              LDR      r0,[r0,#0]            ;2572
00012a  f4407000          ORR      r0,r0,#0x200          ;2572
00012e  6821              LDR      r1,[r4,#0]            ;2572
000130  6008              STR      r0,[r1,#0]            ;2572
                  |L33.306|
000132  2001              MOVS     r0,#1                 ;2574
000134  e77d              B        |L33.50|
                  |L33.310|
000136  6820              LDR      r0,[r4,#0]            ;2578
000138  6800              LDR      r0,[r0,#0]            ;2578
00013a  f4407000          ORR      r0,r0,#0x200          ;2578
00013e  6821              LDR      r1,[r4,#0]            ;2578
000140  6008              STR      r0,[r1,#0]            ;2578
000142  2020              MOVS     r0,#0x20              ;2580
000144  f884003d          STRB     r0,[r4,#0x3d]         ;2580
000148  2000              MOVS     r0,#0                 ;2581
00014a  f884003e          STRB     r0,[r4,#0x3e]         ;2581
00014e  bf00              NOP                            ;2584
000150  f884003c          STRB     r0,[r4,#0x3c]         ;2584
000154  bf00              NOP                            ;2584
000156  e76c              B        |L33.50|
                  |L33.344|
000158  2002              MOVS     r0,#2                 ;2590
00015a  e76a              B        |L33.50|
;;;2593   
                          ENDP

                  |L33.348|
                          DCD      0x00100002
                  |L33.352|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Mem_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_DMA PROC
;;;3035     */
;;;3036   HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;3037   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;3038     __IO uint32_t count = 0U;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;3039     HAL_StatusTypeDef dmaxferstatus;
;;;3040   
;;;3041     /* Init tickstart for timeout management*/
;;;3042     uint32_t tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4683              MOV      r11,r0
;;;3043   
;;;3044     /* Check the parameters */
;;;3045     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;3046   
;;;3047     if (hi2c->State == HAL_I2C_STATE_READY)
00001a  f894003d          LDRB     r0,[r4,#0x3d]
00001e  2820              CMP      r0,#0x20
000020  d17e              BNE      |L34.288|
;;;3048     {
;;;3049       /* Wait until BUSY flag is reset */
;;;3050       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000022  487c              LDR      r0,|L34.532|
000024  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000026  2119              MOVS     r1,#0x19
000028  fbb0f0f1          UDIV     r0,r0,r1
00002c  f44f717a          MOV      r1,#0x3e8
000030  fbb0f0f1          UDIV     r0,r0,r1
000034  eb0001c0          ADD      r1,r0,r0,LSL #3
000038  eb011000          ADD      r0,r1,r0,LSL #4
00003c  9002              STR      r0,[sp,#8]
;;;3051       do
00003e  bf00              NOP      
                  |L34.64|
;;;3052       {
;;;3053         count--;
000040  9802              LDR      r0,[sp,#8]
000042  1e40              SUBS     r0,r0,#1
000044  9002              STR      r0,[sp,#8]
;;;3054         if (count == 0U)
000046  9802              LDR      r0,[sp,#8]
000048  b998              CBNZ     r0,|L34.114|
;;;3055         {
;;;3056           hi2c->PreviousState       = I2C_STATE_NONE;
00004a  2000              MOVS     r0,#0
00004c  6320              STR      r0,[r4,#0x30]
;;;3057           hi2c->State               = HAL_I2C_STATE_READY;
00004e  2020              MOVS     r0,#0x20
000050  f884003d          STRB     r0,[r4,#0x3d]
;;;3058           hi2c->Mode                = HAL_I2C_MODE_NONE;
000054  2000              MOVS     r0,#0
000056  f884003e          STRB     r0,[r4,#0x3e]
;;;3059           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00005a  6c20              LDR      r0,[r4,#0x40]
00005c  f0400020          ORR      r0,r0,#0x20
000060  6420              STR      r0,[r4,#0x40]
;;;3060   
;;;3061           /* Process Unlocked */
;;;3062           __HAL_UNLOCK(hi2c);
000062  bf00              NOP      
000064  2000              MOVS     r0,#0
000066  f884003c          STRB     r0,[r4,#0x3c]
00006a  bf00              NOP      
;;;3063   
;;;3064           return HAL_ERROR;
00006c  2001              MOVS     r0,#1
                  |L34.110|
;;;3065         }
;;;3066       }
;;;3067       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3068   
;;;3069       /* Process Locked */
;;;3070       __HAL_LOCK(hi2c);
;;;3071   
;;;3072       /* Check if the I2C is already enabled */
;;;3073       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3074       {
;;;3075         /* Enable I2C peripheral */
;;;3076         __HAL_I2C_ENABLE(hi2c);
;;;3077       }
;;;3078   
;;;3079       /* Disable Pos */
;;;3080       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3081   
;;;3082       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3083       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;3084       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3085   
;;;3086       /* Prepare transfer parameters */
;;;3087       hi2c->pBuffPtr    = pData;
;;;3088       hi2c->XferCount   = Size;
;;;3089       hi2c->XferSize    = hi2c->XferCount;
;;;3090       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3091       hi2c->Devaddress  = DevAddress;
;;;3092       hi2c->Memaddress  = MemAddress;
;;;3093       hi2c->MemaddSize  = MemAddSize;
;;;3094       hi2c->EventCount  = 0U;
;;;3095   
;;;3096       if (hi2c->XferSize > 0U)
;;;3097       {
;;;3098         if (hi2c->hdmatx != NULL)
;;;3099         {
;;;3100           /* Set the I2C DMA transfer complete callback */
;;;3101           hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;3102   
;;;3103           /* Set the DMA error callback */
;;;3104           hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;3105   
;;;3106           /* Set the unused DMA callbacks to NULL */
;;;3107           hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;3108           hi2c->hdmatx->XferM1CpltCallback = NULL;
;;;3109           hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
;;;3110           hi2c->hdmatx->XferAbortCallback = NULL;
;;;3111   
;;;3112           /* Enable the DMA stream */
;;;3113           dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;3114         }
;;;3115         else
;;;3116         {
;;;3117           /* Update I2C state */
;;;3118           hi2c->State     = HAL_I2C_STATE_READY;
;;;3119           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3120   
;;;3121           /* Update I2C error code */
;;;3122           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;3123   
;;;3124           /* Process Unlocked */
;;;3125           __HAL_UNLOCK(hi2c);
;;;3126   
;;;3127           return HAL_ERROR;
;;;3128         }
;;;3129   
;;;3130         if (dmaxferstatus == HAL_OK)
;;;3131         {
;;;3132           /* Send Slave Address and Memory Address */
;;;3133           if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3134           {
;;;3135             /* Abort the ongoing DMA */
;;;3136             dmaxferstatus = HAL_DMA_Abort_IT(hi2c->hdmatx);
;;;3137   
;;;3138             /* Prevent unused argument(s) compilation and MISRA warning */
;;;3139             UNUSED(dmaxferstatus);
;;;3140   
;;;3141             /* Set the unused I2C DMA transfer complete callback to NULL */
;;;3142             hi2c->hdmatx->XferCpltCallback = NULL;
;;;3143   
;;;3144             /* Disable Acknowledge */
;;;3145             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3146   
;;;3147             hi2c->XferSize = 0U;
;;;3148             hi2c->XferCount = 0U;
;;;3149   
;;;3150             /* Disable I2C peripheral to prevent dummy data in buffer */
;;;3151             __HAL_I2C_DISABLE(hi2c);
;;;3152   
;;;3153             return HAL_ERROR;
;;;3154           }
;;;3155   
;;;3156           /* Clear ADDR flag */
;;;3157           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3158   
;;;3159           /* Process Unlocked */
;;;3160           __HAL_UNLOCK(hi2c);
;;;3161   
;;;3162           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3163           to avoid the risk of I2C interrupt handle execution before current
;;;3164           process unlock */
;;;3165           /* Enable ERR interrupt */
;;;3166           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
;;;3167   
;;;3168           /* Enable DMA Request */
;;;3169           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;3170   
;;;3171           return HAL_OK;
;;;3172         }
;;;3173         else
;;;3174         {
;;;3175           /* Update I2C state */
;;;3176           hi2c->State     = HAL_I2C_STATE_READY;
;;;3177           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3178   
;;;3179           /* Update I2C error code */
;;;3180           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3181   
;;;3182           /* Process Unlocked */
;;;3183           __HAL_UNLOCK(hi2c);
;;;3184   
;;;3185           return HAL_ERROR;
;;;3186         }
;;;3187       }
;;;3188       else
;;;3189       {
;;;3190         /* Update I2C state */
;;;3191         hi2c->State     = HAL_I2C_STATE_READY;
;;;3192         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3193   
;;;3194         /* Update I2C error code */
;;;3195         hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
;;;3196   
;;;3197         /* Process Unlocked */
;;;3198         __HAL_UNLOCK(hi2c);
;;;3199   
;;;3200         return HAL_ERROR;
;;;3201       }
;;;3202     }
;;;3203     else
;;;3204     {
;;;3205       return HAL_BUSY;
;;;3206     }
;;;3207   }
00006e  e8bd8ffe          POP      {r1-r11,pc}
                  |L34.114|
000072  6820              LDR      r0,[r4,#0]            ;3067
000074  6980              LDR      r0,[r0,#0x18]         ;3067
000076  f3c00040          UBFX     r0,r0,#1,#1           ;3067
00007a  2800              CMP      r0,#0                 ;3067
00007c  d1e0              BNE      |L34.64|
00007e  bf00              NOP                            ;3070
000080  f894003c          LDRB     r0,[r4,#0x3c]         ;3070
000084  2801              CMP      r0,#1                 ;3070
000086  d101              BNE      |L34.140|
000088  2002              MOVS     r0,#2                 ;3070
00008a  e7f0              B        |L34.110|
                  |L34.140|
00008c  2001              MOVS     r0,#1                 ;3070
00008e  f884003c          STRB     r0,[r4,#0x3c]         ;3070
000092  bf00              NOP                            ;3070
000094  6820              LDR      r0,[r4,#0]            ;3073
000096  6800              LDR      r0,[r0,#0]            ;3073
000098  f0000001          AND      r0,r0,#1              ;3073
00009c  b928              CBNZ     r0,|L34.170|
00009e  6820              LDR      r0,[r4,#0]            ;3076
0000a0  6800              LDR      r0,[r0,#0]            ;3076
0000a2  f0400001          ORR      r0,r0,#1              ;3076
0000a6  6821              LDR      r1,[r4,#0]            ;3076
0000a8  6008              STR      r0,[r1,#0]            ;3076
                  |L34.170|
0000aa  6820              LDR      r0,[r4,#0]            ;3080
0000ac  6800              LDR      r0,[r0,#0]            ;3080
0000ae  f4206000          BIC      r0,r0,#0x800          ;3080
0000b2  6821              LDR      r1,[r4,#0]            ;3080
0000b4  6008              STR      r0,[r1,#0]            ;3080
0000b6  2021              MOVS     r0,#0x21              ;3082
0000b8  f884003d          STRB     r0,[r4,#0x3d]         ;3082
0000bc  2040              MOVS     r0,#0x40              ;3083
0000be  f884003e          STRB     r0,[r4,#0x3e]         ;3083
0000c2  2000              MOVS     r0,#0                 ;3084
0000c4  6420              STR      r0,[r4,#0x40]         ;3084
0000c6  f8c49024          STR      r9,[r4,#0x24]         ;3087
0000ca  f8a4a02a          STRH     r10,[r4,#0x2a]        ;3088
0000ce  8d60              LDRH     r0,[r4,#0x2a]         ;3089
0000d0  8520              STRH     r0,[r4,#0x28]         ;3089
0000d2  4851              LDR      r0,|L34.536|
0000d4  62e0              STR      r0,[r4,#0x2c]         ;3090
0000d6  6466              STR      r6,[r4,#0x44]         ;3091
0000d8  64a7              STR      r7,[r4,#0x48]         ;3092
0000da  f8c4804c          STR      r8,[r4,#0x4c]         ;3093
0000de  2000              MOVS     r0,#0                 ;3094
0000e0  6520              STR      r0,[r4,#0x50]         ;3094
0000e2  8d20              LDRH     r0,[r4,#0x28]         ;3096
0000e4  2800              CMP      r0,#0                 ;3096
0000e6  d06e              BEQ      |L34.454|
0000e8  6b60              LDR      r0,[r4,#0x34]         ;3098
0000ea  b1d0              CBZ      r0,|L34.290|
0000ec  484b              LDR      r0,|L34.540|
0000ee  6b61              LDR      r1,[r4,#0x34]         ;3101
0000f0  63c8              STR      r0,[r1,#0x3c]         ;3101
0000f2  484b              LDR      r0,|L34.544|
0000f4  6b61              LDR      r1,[r4,#0x34]         ;3104
0000f6  64c8              STR      r0,[r1,#0x4c]         ;3104
0000f8  2000              MOVS     r0,#0                 ;3107
0000fa  6b61              LDR      r1,[r4,#0x34]         ;3107
0000fc  6408              STR      r0,[r1,#0x40]         ;3107
0000fe  6b61              LDR      r1,[r4,#0x34]         ;3108
000100  6448              STR      r0,[r1,#0x44]         ;3108
000102  6b61              LDR      r1,[r4,#0x34]         ;3109
000104  6488              STR      r0,[r1,#0x48]         ;3109
000106  6b61              LDR      r1,[r4,#0x34]         ;3110
000108  6508              STR      r0,[r1,#0x50]         ;3110
00010a  8d23              LDRH     r3,[r4,#0x28]         ;3113
00010c  f8d4c000          LDR      r12,[r4,#0]           ;3113
000110  f10c0210          ADD      r2,r12,#0x10          ;3113
000114  6a61              LDR      r1,[r4,#0x24]         ;3113
000116  6b60              LDR      r0,[r4,#0x34]         ;3113
000118  f7fffffe          BL       HAL_DMA_Start_IT
00011c  4605              MOV      r5,r0                 ;3113
00011e  e011              B        |L34.324|
                  |L34.288|
000120  e076              B        |L34.528|
                  |L34.290|
000122  2020              MOVS     r0,#0x20              ;3118
000124  f884003d          STRB     r0,[r4,#0x3d]         ;3118
000128  2000              MOVS     r0,#0                 ;3119
00012a  f884003e          STRB     r0,[r4,#0x3e]         ;3119
00012e  6c20              LDR      r0,[r4,#0x40]         ;3122
000130  f0400080          ORR      r0,r0,#0x80           ;3122
000134  6420              STR      r0,[r4,#0x40]         ;3122
000136  bf00              NOP                            ;3125
000138  2000              MOVS     r0,#0                 ;3125
00013a  f884003c          STRB     r0,[r4,#0x3c]         ;3125
00013e  bf00              NOP                            ;3125
000140  2001              MOVS     r0,#1                 ;3127
000142  e794              B        |L34.110|
                  |L34.324|
000144  bbf5              CBNZ     r5,|L34.452|
000146  2023              MOVS     r0,#0x23              ;3133
000148  4643              MOV      r3,r8                 ;3133
00014a  463a              MOV      r2,r7                 ;3133
00014c  4631              MOV      r1,r6                 ;3133
00014e  e9cd0b00          STRD     r0,r11,[sp,#0]        ;3133
000152  4620              MOV      r0,r4                 ;3133
000154  f7fffffe          BL       I2C_RequestMemoryWrite
000158  b1b8              CBZ      r0,|L34.394|
00015a  6b60              LDR      r0,[r4,#0x34]         ;3136
00015c  f7fffffe          BL       HAL_DMA_Abort_IT
000160  4605              MOV      r5,r0                 ;3136
000162  2000              MOVS     r0,#0                 ;3142
000164  6b61              LDR      r1,[r4,#0x34]         ;3142
000166  63c8              STR      r0,[r1,#0x3c]         ;3142
000168  6820              LDR      r0,[r4,#0]            ;3145
00016a  6800              LDR      r0,[r0,#0]            ;3145
00016c  f4206080          BIC      r0,r0,#0x400          ;3145
000170  6821              LDR      r1,[r4,#0]            ;3145
000172  6008              STR      r0,[r1,#0]            ;3145
000174  2000              MOVS     r0,#0                 ;3147
000176  8520              STRH     r0,[r4,#0x28]         ;3147
000178  8560              STRH     r0,[r4,#0x2a]         ;3148
00017a  6820              LDR      r0,[r4,#0]            ;3151
00017c  6800              LDR      r0,[r0,#0]            ;3151
00017e  f0200001          BIC      r0,r0,#1              ;3151
000182  6821              LDR      r1,[r4,#0]            ;3151
000184  6008              STR      r0,[r1,#0]            ;3151
000186  2001              MOVS     r0,#1                 ;3153
000188  e771              B        |L34.110|
                  |L34.394|
00018a  bf00              NOP                            ;3157
00018c  2000              MOVS     r0,#0                 ;3157
00018e  9001              STR      r0,[sp,#4]            ;3157
000190  6820              LDR      r0,[r4,#0]            ;3157
000192  6940              LDR      r0,[r0,#0x14]         ;3157
000194  9001              STR      r0,[sp,#4]            ;3157
000196  6820              LDR      r0,[r4,#0]            ;3157
000198  6980              LDR      r0,[r0,#0x18]         ;3157
00019a  9001              STR      r0,[sp,#4]            ;3157
00019c  bf00              NOP                            ;3157
00019e  bf00              NOP                            ;3157
0001a0  bf00              NOP                            ;3160
0001a2  2000              MOVS     r0,#0                 ;3160
0001a4  f884003c          STRB     r0,[r4,#0x3c]         ;3160
0001a8  bf00              NOP                            ;3160
0001aa  6820              LDR      r0,[r4,#0]            ;3166
0001ac  6840              LDR      r0,[r0,#4]            ;3166
0001ae  f4407080          ORR      r0,r0,#0x100          ;3166
0001b2  6821              LDR      r1,[r4,#0]            ;3166
0001b4  6048              STR      r0,[r1,#4]            ;3166
0001b6  6820              LDR      r0,[r4,#0]            ;3169
0001b8  6840              LDR      r0,[r0,#4]            ;3169
0001ba  f4406000          ORR      r0,r0,#0x800          ;3169
0001be  6821              LDR      r1,[r4,#0]            ;3169
0001c0  6048              STR      r0,[r1,#4]            ;3169
0001c2  e001              B        |L34.456|
                  |L34.452|
0001c4  e002              B        |L34.460|
                  |L34.454|
0001c6  e012              B        |L34.494|
                  |L34.456|
0001c8  2000              MOVS     r0,#0                 ;3171
0001ca  e750              B        |L34.110|
                  |L34.460|
0001cc  2020              MOVS     r0,#0x20              ;3176
0001ce  f884003d          STRB     r0,[r4,#0x3d]         ;3176
0001d2  2000              MOVS     r0,#0                 ;3177
0001d4  f884003e          STRB     r0,[r4,#0x3e]         ;3177
0001d8  6c20              LDR      r0,[r4,#0x40]         ;3180
0001da  f0400010          ORR      r0,r0,#0x10           ;3180
0001de  6420              STR      r0,[r4,#0x40]         ;3180
0001e0  bf00              NOP                            ;3183
0001e2  2000              MOVS     r0,#0                 ;3183
0001e4  f884003c          STRB     r0,[r4,#0x3c]         ;3183
0001e8  bf00              NOP                            ;3183
0001ea  2001              MOVS     r0,#1                 ;3185
0001ec  e73f              B        |L34.110|
                  |L34.494|
0001ee  2020              MOVS     r0,#0x20              ;3191
0001f0  f884003d          STRB     r0,[r4,#0x3d]         ;3191
0001f4  2000              MOVS     r0,#0                 ;3192
0001f6  f884003e          STRB     r0,[r4,#0x3e]         ;3192
0001fa  6c20              LDR      r0,[r4,#0x40]         ;3195
0001fc  f0400040          ORR      r0,r0,#0x40           ;3195
000200  6420              STR      r0,[r4,#0x40]         ;3195
000202  bf00              NOP                            ;3198
000204  2000              MOVS     r0,#0                 ;3198
000206  f884003c          STRB     r0,[r4,#0x3c]         ;3198
00020a  bf00              NOP                            ;3198
00020c  2001              MOVS     r0,#1                 ;3200
00020e  e72e              B        |L34.110|
                  |L34.528|
000210  2002              MOVS     r0,#2                 ;3205
000212  e72c              B        |L34.110|
;;;3208   
                          ENDP

                  |L34.532|
                          DCD      SystemCoreClock
                  |L34.536|
                          DCD      0xffff0000
                  |L34.540|
                          DCD      I2C_DMAXferCplt
                  |L34.544|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Write_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_IT PROC
;;;2853     */
;;;2854   HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2855   {
000002  4604              MOV      r4,r0
000004  e9dd5606          LDRD     r5,r6,[sp,#0x18]
;;;2856     __IO uint32_t count = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2857   
;;;2858     /* Check the parameters */
;;;2859     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2860   
;;;2861     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2820              CMP      r0,#0x20
000012  d16f              BNE      |L35.244|
;;;2862     {
;;;2863       /* Wait until BUSY flag is reset */
;;;2864       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000014  4838              LDR      r0,|L35.248|
000016  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000018  2719              MOVS     r7,#0x19
00001a  fbb0f0f7          UDIV     r0,r0,r7
00001e  f44f777a          MOV      r7,#0x3e8
000022  fbb0f0f7          UDIV     r0,r0,r7
000026  eb0007c0          ADD      r7,r0,r0,LSL #3
00002a  eb071000          ADD      r0,r7,r0,LSL #4
00002e  9000              STR      r0,[sp,#0]
;;;2865       do
000030  bf00              NOP      
                  |L35.50|
;;;2866       {
;;;2867         count--;
000032  9800              LDR      r0,[sp,#0]
000034  1e40              SUBS     r0,r0,#1
000036  9000              STR      r0,[sp,#0]
;;;2868         if (count == 0U)
000038  9800              LDR      r0,[sp,#0]
00003a  b990              CBNZ     r0,|L35.98|
;;;2869         {
;;;2870           hi2c->PreviousState       = I2C_STATE_NONE;
00003c  2000              MOVS     r0,#0
00003e  6320              STR      r0,[r4,#0x30]
;;;2871           hi2c->State               = HAL_I2C_STATE_READY;
000040  2020              MOVS     r0,#0x20
000042  f884003d          STRB     r0,[r4,#0x3d]
;;;2872           hi2c->Mode                = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;2873           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00004c  6c20              LDR      r0,[r4,#0x40]
00004e  f0400020          ORR      r0,r0,#0x20
000052  6420              STR      r0,[r4,#0x40]
;;;2874   
;;;2875           /* Process Unlocked */
;;;2876           __HAL_UNLOCK(hi2c);
000054  bf00              NOP      
000056  2000              MOVS     r0,#0
000058  f884003c          STRB     r0,[r4,#0x3c]
00005c  bf00              NOP      
;;;2877   
;;;2878           return HAL_ERROR;
00005e  2001              MOVS     r0,#1
                  |L35.96|
;;;2879         }
;;;2880       }
;;;2881       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2882   
;;;2883       /* Process Locked */
;;;2884       __HAL_LOCK(hi2c);
;;;2885   
;;;2886       /* Check if the I2C is already enabled */
;;;2887       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2888       {
;;;2889         /* Enable I2C peripheral */
;;;2890         __HAL_I2C_ENABLE(hi2c);
;;;2891       }
;;;2892   
;;;2893       /* Disable Pos */
;;;2894       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2895   
;;;2896       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2897       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2898       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2899   
;;;2900       /* Prepare transfer parameters */
;;;2901       hi2c->pBuffPtr    = pData;
;;;2902       hi2c->XferCount   = Size;
;;;2903       hi2c->XferSize    = hi2c->XferCount;
;;;2904       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2905       hi2c->Devaddress  = DevAddress;
;;;2906       hi2c->Memaddress  = MemAddress;
;;;2907       hi2c->MemaddSize  = MemAddSize;
;;;2908       hi2c->EventCount  = 0U;
;;;2909   
;;;2910       /* Generate Start */
;;;2911       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2912   
;;;2913       /* Process Unlocked */
;;;2914       __HAL_UNLOCK(hi2c);
;;;2915   
;;;2916       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2917       to avoid the risk of I2C interrupt handle execution before current
;;;2918       process unlock */
;;;2919   
;;;2920       /* Enable EVT, BUF and ERR interrupt */
;;;2921       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2922   
;;;2923       return HAL_OK;
;;;2924     }
;;;2925     else
;;;2926     {
;;;2927       return HAL_BUSY;
;;;2928     }
;;;2929   }
000060  bdf8              POP      {r3-r7,pc}
                  |L35.98|
000062  6820              LDR      r0,[r4,#0]            ;2881
000064  6980              LDR      r0,[r0,#0x18]         ;2881
000066  f3c00040          UBFX     r0,r0,#1,#1           ;2881
00006a  2800              CMP      r0,#0                 ;2881
00006c  d1e1              BNE      |L35.50|
00006e  bf00              NOP                            ;2884
000070  f894003c          LDRB     r0,[r4,#0x3c]         ;2884
000074  2801              CMP      r0,#1                 ;2884
000076  d101              BNE      |L35.124|
000078  2002              MOVS     r0,#2                 ;2884
00007a  e7f1              B        |L35.96|
                  |L35.124|
00007c  2001              MOVS     r0,#1                 ;2884
00007e  f884003c          STRB     r0,[r4,#0x3c]         ;2884
000082  bf00              NOP                            ;2884
000084  6820              LDR      r0,[r4,#0]            ;2887
000086  6800              LDR      r0,[r0,#0]            ;2887
000088  f0000001          AND      r0,r0,#1              ;2887
00008c  b928              CBNZ     r0,|L35.154|
00008e  6820              LDR      r0,[r4,#0]            ;2890
000090  6800              LDR      r0,[r0,#0]            ;2890
000092  f0400001          ORR      r0,r0,#1              ;2890
000096  6827              LDR      r7,[r4,#0]            ;2890
000098  6038              STR      r0,[r7,#0]            ;2890
                  |L35.154|
00009a  6820              LDR      r0,[r4,#0]            ;2894
00009c  6800              LDR      r0,[r0,#0]            ;2894
00009e  f4206000          BIC      r0,r0,#0x800          ;2894
0000a2  6827              LDR      r7,[r4,#0]            ;2894
0000a4  6038              STR      r0,[r7,#0]            ;2894
0000a6  2021              MOVS     r0,#0x21              ;2896
0000a8  f884003d          STRB     r0,[r4,#0x3d]         ;2896
0000ac  2040              MOVS     r0,#0x40              ;2897
0000ae  f884003e          STRB     r0,[r4,#0x3e]         ;2897
0000b2  2000              MOVS     r0,#0                 ;2898
0000b4  6420              STR      r0,[r4,#0x40]         ;2898
0000b6  6265              STR      r5,[r4,#0x24]         ;2901
0000b8  8566              STRH     r6,[r4,#0x2a]         ;2902
0000ba  8d60              LDRH     r0,[r4,#0x2a]         ;2903
0000bc  8520              STRH     r0,[r4,#0x28]         ;2903
0000be  480f              LDR      r0,|L35.252|
0000c0  62e0              STR      r0,[r4,#0x2c]         ;2904
0000c2  6461              STR      r1,[r4,#0x44]         ;2905
0000c4  64a2              STR      r2,[r4,#0x48]         ;2906
0000c6  64e3              STR      r3,[r4,#0x4c]         ;2907
0000c8  2000              MOVS     r0,#0                 ;2908
0000ca  6520              STR      r0,[r4,#0x50]         ;2908
0000cc  6820              LDR      r0,[r4,#0]            ;2911
0000ce  6800              LDR      r0,[r0,#0]            ;2911
0000d0  f4407080          ORR      r0,r0,#0x100          ;2911
0000d4  6827              LDR      r7,[r4,#0]            ;2911
0000d6  6038              STR      r0,[r7,#0]            ;2911
0000d8  bf00              NOP                            ;2914
0000da  2000              MOVS     r0,#0                 ;2914
0000dc  f884003c          STRB     r0,[r4,#0x3c]         ;2914
0000e0  bf00              NOP                            ;2914
0000e2  6820              LDR      r0,[r4,#0]            ;2921
0000e4  6840              LDR      r0,[r0,#4]            ;2921
0000e6  f44060e0          ORR      r0,r0,#0x700          ;2921
0000ea  6827              LDR      r7,[r4,#0]            ;2921
0000ec  6078              STR      r0,[r7,#4]            ;2921
0000ee  2000              MOVS     r0,#0                 ;2923
0000f0  e7b6              B        |L35.96|
0000f2  e7ff              B        |L35.244|
                  |L35.244|
0000f4  2002              MOVS     r0,#2                 ;2927
0000f6  e7b3              B        |L35.96|
;;;2930   
                          ENDP

                  |L35.248|
                          DCD      SystemCoreClock
                  |L35.252|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspDeInit PROC
;;;611      */
;;;612    __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;613    {
;;;614      /* Prevent unused argument(s) compilation warning */
;;;615      UNUSED(hi2c);
;;;616    
;;;617      /* NOTE : This function should not be modified, when the callback is needed,
;;;618                the HAL_I2C_MspDeInit could be implemented in the user file
;;;619       */
;;;620    }
;;;621    
                          ENDP


                          AREA ||i.HAL_I2C_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspInit PROC
;;;595      */
;;;596    __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;597    {
;;;598      /* Prevent unused argument(s) compilation warning */
;;;599      UNUSED(hi2c);
;;;600    
;;;601      /* NOTE : This function should not be modified, when the callback is needed,
;;;602                the HAL_I2C_MspInit could be implemented in the user file
;;;603       */
;;;604    }
;;;605    
                          ENDP


                          AREA ||i.HAL_I2C_SlaveRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveRxCpltCallback PROC
;;;5077     */
;;;5078   __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5079   {
;;;5080     /* Prevent unused argument(s) compilation warning */
;;;5081     UNUSED(hi2c);
;;;5082   
;;;5083     /* NOTE : This function should not be modified, when the callback is needed,
;;;5084               the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
;;;5085      */
;;;5086   }
;;;5087   
                          ENDP


                          AREA ||i.HAL_I2C_SlaveTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveTxCpltCallback PROC
;;;5061     */
;;;5062   __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;5063   {
;;;5064     /* Prevent unused argument(s) compilation warning */
;;;5065     UNUSED(hi2c);
;;;5066   
;;;5067     /* NOTE : This function should not be modified, when the callback is needed,
;;;5068               the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
;;;5069      */
;;;5070   }
;;;5071   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive PROC
;;;1526     */
;;;1527   HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1528   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1529     /* Init tickstart for timeout management*/
;;;1530     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;1531   
;;;1532     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2820              CMP      r0,#0x20
000018  d17e              BNE      |L40.280|
;;;1533     {
;;;1534       if ((pData == NULL) || (Size == (uint16_t)0))
00001a  b105              CBZ      r5,|L40.30|
00001c  b916              CBNZ     r6,|L40.36|
                  |L40.30|
;;;1535       {
;;;1536         return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L40.32|
;;;1537       }
;;;1538   
;;;1539       /* Process Locked */
;;;1540       __HAL_LOCK(hi2c);
;;;1541   
;;;1542       /* Check if the I2C is already enabled */
;;;1543       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1544       {
;;;1545         /* Enable I2C peripheral */
;;;1546         __HAL_I2C_ENABLE(hi2c);
;;;1547       }
;;;1548   
;;;1549       /* Disable Pos */
;;;1550       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1551   
;;;1552       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1553       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1554       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1555   
;;;1556       /* Prepare transfer parameters */
;;;1557       hi2c->pBuffPtr    = pData;
;;;1558       hi2c->XferCount   = Size;
;;;1559       hi2c->XferSize    = hi2c->XferCount;
;;;1560       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1561   
;;;1562       /* Enable Address Acknowledge */
;;;1563       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1564   
;;;1565       /* Wait until ADDR flag is set */
;;;1566       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1567       {
;;;1568         return HAL_ERROR;
;;;1569       }
;;;1570   
;;;1571       /* Clear ADDR flag */
;;;1572       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1573   
;;;1574       while (hi2c->XferSize > 0U)
;;;1575       {
;;;1576         /* Wait until RXNE flag is set */
;;;1577         if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1578         {
;;;1579           /* Disable Address Acknowledge */
;;;1580           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1581   
;;;1582           return HAL_ERROR;
;;;1583         }
;;;1584   
;;;1585         /* Read data from DR */
;;;1586         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1587   
;;;1588         /* Increment Buffer pointer */
;;;1589         hi2c->pBuffPtr++;
;;;1590   
;;;1591         /* Update counter */
;;;1592         hi2c->XferSize--;
;;;1593         hi2c->XferCount--;
;;;1594   
;;;1595         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1596         {
;;;1597           /* Read data from DR */
;;;1598           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1599   
;;;1600           /* Increment Buffer pointer */
;;;1601           hi2c->pBuffPtr++;
;;;1602   
;;;1603           /* Update counter */
;;;1604           hi2c->XferSize--;
;;;1605           hi2c->XferCount--;
;;;1606         }
;;;1607       }
;;;1608   
;;;1609       /* Wait until STOP flag is set */
;;;1610       if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1611       {
;;;1612         /* Disable Address Acknowledge */
;;;1613         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1614   
;;;1615         return HAL_ERROR;
;;;1616       }
;;;1617   
;;;1618       /* Clear STOP flag */
;;;1619       __HAL_I2C_CLEAR_STOPFLAG(hi2c);
;;;1620   
;;;1621       /* Disable Address Acknowledge */
;;;1622       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1623   
;;;1624       hi2c->State = HAL_I2C_STATE_READY;
;;;1625       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1626   
;;;1627       /* Process Unlocked */
;;;1628       __HAL_UNLOCK(hi2c);
;;;1629   
;;;1630       return HAL_OK;
;;;1631     }
;;;1632     else
;;;1633     {
;;;1634       return HAL_BUSY;
;;;1635     }
;;;1636   }
000020  e8bd83f8          POP      {r3-r9,pc}
                  |L40.36|
000024  bf00              NOP                            ;1540
000026  f894003c          LDRB     r0,[r4,#0x3c]         ;1540
00002a  2801              CMP      r0,#1                 ;1540
00002c  d101              BNE      |L40.50|
00002e  2002              MOVS     r0,#2                 ;1540
000030  e7f6              B        |L40.32|
                  |L40.50|
000032  2001              MOVS     r0,#1                 ;1540
000034  f884003c          STRB     r0,[r4,#0x3c]         ;1540
000038  bf00              NOP                            ;1540
00003a  6820              LDR      r0,[r4,#0]            ;1543
00003c  6800              LDR      r0,[r0,#0]            ;1543
00003e  f0000001          AND      r0,r0,#1              ;1543
000042  b928              CBNZ     r0,|L40.80|
000044  6820              LDR      r0,[r4,#0]            ;1546
000046  6800              LDR      r0,[r0,#0]            ;1546
000048  f0400001          ORR      r0,r0,#1              ;1546
00004c  6821              LDR      r1,[r4,#0]            ;1546
00004e  6008              STR      r0,[r1,#0]            ;1546
                  |L40.80|
000050  6820              LDR      r0,[r4,#0]            ;1550
000052  6800              LDR      r0,[r0,#0]            ;1550
000054  f4206000          BIC      r0,r0,#0x800          ;1550
000058  6821              LDR      r1,[r4,#0]            ;1550
00005a  6008              STR      r0,[r1,#0]            ;1550
00005c  2022              MOVS     r0,#0x22              ;1552
00005e  f884003d          STRB     r0,[r4,#0x3d]         ;1552
000062  2020              MOVS     r0,#0x20              ;1553
000064  f884003e          STRB     r0,[r4,#0x3e]         ;1553
000068  2000              MOVS     r0,#0                 ;1554
00006a  6420              STR      r0,[r4,#0x40]         ;1554
00006c  6265              STR      r5,[r4,#0x24]         ;1557
00006e  8566              STRH     r6,[r4,#0x2a]         ;1558
000070  8d60              LDRH     r0,[r4,#0x2a]         ;1559
000072  8520              STRH     r0,[r4,#0x28]         ;1559
000074  4840              LDR      r0,|L40.376|
000076  62e0              STR      r0,[r4,#0x2c]         ;1560
000078  6820              LDR      r0,[r4,#0]            ;1563
00007a  6800              LDR      r0,[r0,#0]            ;1563
00007c  f4406080          ORR      r0,r0,#0x400          ;1563
000080  6821              LDR      r1,[r4,#0]            ;1563
000082  6008              STR      r0,[r1,#0]            ;1563
000084  463b              MOV      r3,r7                 ;1566
000086  2200              MOVS     r2,#0                 ;1566
000088  493c              LDR      r1,|L40.380|
00008a  4620              MOV      r0,r4                 ;1566
00008c  f8cd8000          STR      r8,[sp,#0]            ;1566
000090  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000094  b108              CBZ      r0,|L40.154|
000096  2001              MOVS     r0,#1                 ;1568
000098  e7c2              B        |L40.32|
                  |L40.154|
00009a  bf00              NOP                            ;1572
00009c  2000              MOVS     r0,#0                 ;1572
00009e  9000              STR      r0,[sp,#0]            ;1572
0000a0  6820              LDR      r0,[r4,#0]            ;1572
0000a2  6940              LDR      r0,[r0,#0x14]         ;1572
0000a4  9000              STR      r0,[sp,#0]            ;1572
0000a6  6820              LDR      r0,[r4,#0]            ;1572
0000a8  6980              LDR      r0,[r0,#0x18]         ;1572
0000aa  9000              STR      r0,[sp,#0]            ;1572
0000ac  bf00              NOP                            ;1572
0000ae  bf00              NOP                            ;1572
0000b0  e02e              B        |L40.272|
                  |L40.178|
0000b2  4642              MOV      r2,r8                 ;1577
0000b4  4639              MOV      r1,r7                 ;1577
0000b6  4620              MOV      r0,r4                 ;1577
0000b8  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000bc  b138              CBZ      r0,|L40.206|
0000be  6820              LDR      r0,[r4,#0]            ;1580
0000c0  6800              LDR      r0,[r0,#0]            ;1580
0000c2  f4206080          BIC      r0,r0,#0x400          ;1580
0000c6  6821              LDR      r1,[r4,#0]            ;1580
0000c8  6008              STR      r0,[r1,#0]            ;1580
0000ca  2001              MOVS     r0,#1                 ;1582
0000cc  e7a8              B        |L40.32|
                  |L40.206|
0000ce  6820              LDR      r0,[r4,#0]            ;1586
0000d0  6900              LDR      r0,[r0,#0x10]         ;1586
0000d2  6a61              LDR      r1,[r4,#0x24]         ;1586
0000d4  7008              STRB     r0,[r1,#0]            ;1586
0000d6  6a60              LDR      r0,[r4,#0x24]         ;1589
0000d8  1c40              ADDS     r0,r0,#1              ;1589
0000da  6260              STR      r0,[r4,#0x24]         ;1589
0000dc  8d20              LDRH     r0,[r4,#0x28]         ;1592
0000de  1e40              SUBS     r0,r0,#1              ;1592
0000e0  8520              STRH     r0,[r4,#0x28]         ;1592
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;1593
0000e4  1e40              SUBS     r0,r0,#1              ;1593
0000e6  8560              STRH     r0,[r4,#0x2a]         ;1593
0000e8  6820              LDR      r0,[r4,#0]            ;1595
0000ea  6940              LDR      r0,[r0,#0x14]         ;1595
0000ec  f3c00080          UBFX     r0,r0,#2,#1           ;1595
0000f0  b170              CBZ      r0,|L40.272|
0000f2  8d20              LDRH     r0,[r4,#0x28]         ;1595
0000f4  b160              CBZ      r0,|L40.272|
0000f6  6820              LDR      r0,[r4,#0]            ;1598
0000f8  6900              LDR      r0,[r0,#0x10]         ;1598
0000fa  6a61              LDR      r1,[r4,#0x24]         ;1598
0000fc  7008              STRB     r0,[r1,#0]            ;1598
0000fe  6a60              LDR      r0,[r4,#0x24]         ;1601
000100  1c40              ADDS     r0,r0,#1              ;1601
000102  6260              STR      r0,[r4,#0x24]         ;1601
000104  8d20              LDRH     r0,[r4,#0x28]         ;1604
000106  1e40              SUBS     r0,r0,#1              ;1604
000108  8520              STRH     r0,[r4,#0x28]         ;1604
00010a  8d60              LDRH     r0,[r4,#0x2a]         ;1605
00010c  1e40              SUBS     r0,r0,#1              ;1605
00010e  8560              STRH     r0,[r4,#0x2a]         ;1605
                  |L40.272|
000110  8d20              LDRH     r0,[r4,#0x28]         ;1574
000112  2800              CMP      r0,#0                 ;1574
000114  d1cd              BNE      |L40.178|
000116  e000              B        |L40.282|
                  |L40.280|
000118  e02c              B        |L40.372|
                  |L40.282|
00011a  4642              MOV      r2,r8                 ;1610
00011c  4639              MOV      r1,r7                 ;1610
00011e  4620              MOV      r0,r4                 ;1610
000120  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
000124  b138              CBZ      r0,|L40.310|
000126  6820              LDR      r0,[r4,#0]            ;1613
000128  6800              LDR      r0,[r0,#0]            ;1613
00012a  f4206080          BIC      r0,r0,#0x400          ;1613
00012e  6821              LDR      r1,[r4,#0]            ;1613
000130  6008              STR      r0,[r1,#0]            ;1613
000132  2001              MOVS     r0,#1                 ;1615
000134  e774              B        |L40.32|
                  |L40.310|
000136  bf00              NOP                            ;1619
000138  2000              MOVS     r0,#0                 ;1619
00013a  9000              STR      r0,[sp,#0]            ;1619
00013c  6820              LDR      r0,[r4,#0]            ;1619
00013e  6940              LDR      r0,[r0,#0x14]         ;1619
000140  9000              STR      r0,[sp,#0]            ;1619
000142  6820              LDR      r0,[r4,#0]            ;1619
000144  6800              LDR      r0,[r0,#0]            ;1619
000146  f0400001          ORR      r0,r0,#1              ;1619
00014a  6821              LDR      r1,[r4,#0]            ;1619
00014c  6008              STR      r0,[r1,#0]            ;1619
00014e  bf00              NOP                            ;1619
000150  bf00              NOP                            ;1619
000152  6820              LDR      r0,[r4,#0]            ;1622
000154  6800              LDR      r0,[r0,#0]            ;1622
000156  f4206080          BIC      r0,r0,#0x400          ;1622
00015a  6821              LDR      r1,[r4,#0]            ;1622
00015c  6008              STR      r0,[r1,#0]            ;1622
00015e  2020              MOVS     r0,#0x20              ;1624
000160  f884003d          STRB     r0,[r4,#0x3d]         ;1624
000164  2000              MOVS     r0,#0                 ;1625
000166  f884003e          STRB     r0,[r4,#0x3e]         ;1625
00016a  bf00              NOP                            ;1628
00016c  f884003c          STRB     r0,[r4,#0x3c]         ;1628
000170  bf00              NOP                            ;1628
000172  e755              B        |L40.32|
                  |L40.372|
000174  2002              MOVS     r0,#2                 ;1634
000176  e753              B        |L40.32|
;;;1637   
                          ENDP

                  |L40.376|
                          DCD      0xffff0000
                  |L40.380|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_DMA PROC
;;;2364     */
;;;2365   HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2366   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2367     HAL_StatusTypeDef dmaxferstatus;
;;;2368   
;;;2369     if (hi2c->State == HAL_I2C_STATE_READY)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2820              CMP      r0,#0x20
000010  d175              BNE      |L41.254|
;;;2370     {
;;;2371       if ((pData == NULL) || (Size == 0U))
000012  b105              CBZ      r5,|L41.22|
000014  b916              CBNZ     r6,|L41.28|
                  |L41.22|
;;;2372       {
;;;2373         return  HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L41.24|
;;;2374       }
;;;2375   
;;;2376       /* Process Locked */
;;;2377       __HAL_LOCK(hi2c);
;;;2378   
;;;2379       /* Check if the I2C is already enabled */
;;;2380       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2381       {
;;;2382         /* Enable I2C peripheral */
;;;2383         __HAL_I2C_ENABLE(hi2c);
;;;2384       }
;;;2385   
;;;2386       /* Disable Pos */
;;;2387       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2388   
;;;2389       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2390       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2391       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2392   
;;;2393       /* Prepare transfer parameters */
;;;2394       hi2c->pBuffPtr    = pData;
;;;2395       hi2c->XferCount   = Size;
;;;2396       hi2c->XferSize    = hi2c->XferCount;
;;;2397       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2398   
;;;2399       if (hi2c->hdmarx != NULL)
;;;2400       {
;;;2401         /* Set the I2C DMA transfer complete callback */
;;;2402         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;2403   
;;;2404         /* Set the DMA error callback */
;;;2405         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2406   
;;;2407         /* Set the unused DMA callbacks to NULL */
;;;2408         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2409         hi2c->hdmarx->XferM1CpltCallback = NULL;
;;;2410         hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
;;;2411         hi2c->hdmarx->XferAbortCallback = NULL;
;;;2412   
;;;2413         /* Enable the DMA stream */
;;;2414         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;2415       }
;;;2416       else
;;;2417       {
;;;2418         /* Update I2C state */
;;;2419         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;2420         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2421   
;;;2422         /* Update I2C error code */
;;;2423         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;2424   
;;;2425         /* Process Unlocked */
;;;2426         __HAL_UNLOCK(hi2c);
;;;2427   
;;;2428         return HAL_ERROR;
;;;2429       }
;;;2430   
;;;2431       if (dmaxferstatus == HAL_OK)
;;;2432       {
;;;2433         /* Enable Address Acknowledge */
;;;2434         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2435   
;;;2436         /* Process Unlocked */
;;;2437         __HAL_UNLOCK(hi2c);
;;;2438   
;;;2439         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2440         to avoid the risk of I2C interrupt handle execution before current
;;;2441         process unlock */
;;;2442         /* Enable EVT and ERR interrupt */
;;;2443         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2444   
;;;2445         /* Enable DMA Request */
;;;2446         SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2447   
;;;2448         return HAL_OK;
;;;2449       }
;;;2450       else
;;;2451       {
;;;2452         /* Update I2C state */
;;;2453         hi2c->State     = HAL_I2C_STATE_READY;
;;;2454         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2455   
;;;2456         /* Update I2C error code */
;;;2457         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2458   
;;;2459         /* Process Unlocked */
;;;2460         __HAL_UNLOCK(hi2c);
;;;2461   
;;;2462         return HAL_ERROR;
;;;2463       }
;;;2464     }
;;;2465     else
;;;2466     {
;;;2467       return HAL_BUSY;
;;;2468     }
;;;2469   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L41.28|
00001c  bf00              NOP                            ;2377
00001e  f894003c          LDRB     r0,[r4,#0x3c]         ;2377
000022  2801              CMP      r0,#1                 ;2377
000024  d101              BNE      |L41.42|
000026  2002              MOVS     r0,#2                 ;2377
000028  e7f6              B        |L41.24|
                  |L41.42|
00002a  2001              MOVS     r0,#1                 ;2377
00002c  f884003c          STRB     r0,[r4,#0x3c]         ;2377
000030  bf00              NOP                            ;2377
000032  6820              LDR      r0,[r4,#0]            ;2380
000034  6800              LDR      r0,[r0,#0]            ;2380
000036  f0000001          AND      r0,r0,#1              ;2380
00003a  b928              CBNZ     r0,|L41.72|
00003c  6820              LDR      r0,[r4,#0]            ;2383
00003e  6800              LDR      r0,[r0,#0]            ;2383
000040  f0400001          ORR      r0,r0,#1              ;2383
000044  6821              LDR      r1,[r4,#0]            ;2383
000046  6008              STR      r0,[r1,#0]            ;2383
                  |L41.72|
000048  6820              LDR      r0,[r4,#0]            ;2387
00004a  6800              LDR      r0,[r0,#0]            ;2387
00004c  f4206000          BIC      r0,r0,#0x800          ;2387
000050  6821              LDR      r1,[r4,#0]            ;2387
000052  6008              STR      r0,[r1,#0]            ;2387
000054  2022              MOVS     r0,#0x22              ;2389
000056  f884003d          STRB     r0,[r4,#0x3d]         ;2389
00005a  2020              MOVS     r0,#0x20              ;2390
00005c  f884003e          STRB     r0,[r4,#0x3e]         ;2390
000060  2000              MOVS     r0,#0                 ;2391
000062  6420              STR      r0,[r4,#0x40]         ;2391
000064  6265              STR      r5,[r4,#0x24]         ;2394
000066  8566              STRH     r6,[r4,#0x2a]         ;2395
000068  8d60              LDRH     r0,[r4,#0x2a]         ;2396
00006a  8520              STRH     r0,[r4,#0x28]         ;2396
00006c  482e              LDR      r0,|L41.296|
00006e  62e0              STR      r0,[r4,#0x2c]         ;2397
000070  6ba0              LDR      r0,[r4,#0x38]         ;2399
000072  b1c8              CBZ      r0,|L41.168|
000074  482d              LDR      r0,|L41.300|
000076  6ba1              LDR      r1,[r4,#0x38]         ;2402
000078  63c8              STR      r0,[r1,#0x3c]         ;2402
00007a  482d              LDR      r0,|L41.304|
00007c  6ba1              LDR      r1,[r4,#0x38]         ;2405
00007e  64c8              STR      r0,[r1,#0x4c]         ;2405
000080  2000              MOVS     r0,#0                 ;2408
000082  6ba1              LDR      r1,[r4,#0x38]         ;2408
000084  6408              STR      r0,[r1,#0x40]         ;2408
000086  6ba1              LDR      r1,[r4,#0x38]         ;2409
000088  6448              STR      r0,[r1,#0x44]         ;2409
00008a  6ba1              LDR      r1,[r4,#0x38]         ;2410
00008c  6488              STR      r0,[r1,#0x48]         ;2410
00008e  6ba1              LDR      r1,[r4,#0x38]         ;2411
000090  6508              STR      r0,[r1,#0x50]         ;2411
000092  8d23              LDRH     r3,[r4,#0x28]         ;2414
000094  f8d4c000          LDR      r12,[r4,#0]           ;2414
000098  f10c0110          ADD      r1,r12,#0x10          ;2414
00009c  6a62              LDR      r2,[r4,#0x24]         ;2414
00009e  6ba0              LDR      r0,[r4,#0x38]         ;2414
0000a0  f7fffffe          BL       HAL_DMA_Start_IT
0000a4  4607              MOV      r7,r0                 ;2414
0000a6  e010              B        |L41.202|
                  |L41.168|
0000a8  2028              MOVS     r0,#0x28              ;2419
0000aa  f884003d          STRB     r0,[r4,#0x3d]         ;2419
0000ae  2000              MOVS     r0,#0                 ;2420
0000b0  f884003e          STRB     r0,[r4,#0x3e]         ;2420
0000b4  6c20              LDR      r0,[r4,#0x40]         ;2423
0000b6  f0400080          ORR      r0,r0,#0x80           ;2423
0000ba  6420              STR      r0,[r4,#0x40]         ;2423
0000bc  bf00              NOP                            ;2426
0000be  2000              MOVS     r0,#0                 ;2426
0000c0  f884003c          STRB     r0,[r4,#0x3c]         ;2426
0000c4  bf00              NOP                            ;2426
0000c6  2001              MOVS     r0,#1                 ;2428
0000c8  e7a6              B        |L41.24|
                  |L41.202|
0000ca  b9cf              CBNZ     r7,|L41.256|
0000cc  6820              LDR      r0,[r4,#0]            ;2434
0000ce  6800              LDR      r0,[r0,#0]            ;2434
0000d0  f4406080          ORR      r0,r0,#0x400          ;2434
0000d4  6821              LDR      r1,[r4,#0]            ;2434
0000d6  6008              STR      r0,[r1,#0]            ;2434
0000d8  bf00              NOP                            ;2437
0000da  2000              MOVS     r0,#0                 ;2437
0000dc  f884003c          STRB     r0,[r4,#0x3c]         ;2437
0000e0  bf00              NOP                            ;2437
0000e2  6820              LDR      r0,[r4,#0]            ;2443
0000e4  6840              LDR      r0,[r0,#4]            ;2443
0000e6  f4407040          ORR      r0,r0,#0x300          ;2443
0000ea  6821              LDR      r1,[r4,#0]            ;2443
0000ec  6048              STR      r0,[r1,#4]            ;2443
0000ee  6820              LDR      r0,[r4,#0]            ;2446
0000f0  6840              LDR      r0,[r0,#4]            ;2446
0000f2  f4406000          ORR      r0,r0,#0x800          ;2446
0000f6  6821              LDR      r1,[r4,#0]            ;2446
0000f8  6048              STR      r0,[r1,#4]            ;2446
0000fa  2000              MOVS     r0,#0                 ;2448
0000fc  e78c              B        |L41.24|
                  |L41.254|
0000fe  e010              B        |L41.290|
                  |L41.256|
000100  2020              MOVS     r0,#0x20              ;2453
000102  f884003d          STRB     r0,[r4,#0x3d]         ;2453
000106  2000              MOVS     r0,#0                 ;2454
000108  f884003e          STRB     r0,[r4,#0x3e]         ;2454
00010c  6c20              LDR      r0,[r4,#0x40]         ;2457
00010e  f0400010          ORR      r0,r0,#0x10           ;2457
000112  6420              STR      r0,[r4,#0x40]         ;2457
000114  bf00              NOP                            ;2460
000116  2000              MOVS     r0,#0                 ;2460
000118  f884003c          STRB     r0,[r4,#0x3c]         ;2460
00011c  bf00              NOP                            ;2460
00011e  2001              MOVS     r0,#1                 ;2462
000120  e77a              B        |L41.24|
                  |L41.290|
000122  2002              MOVS     r0,#2                 ;2467
000124  e778              B        |L41.24|
;;;2470   
                          ENDP

000126  0000              DCW      0x0000
                  |L41.296|
                          DCD      0xffff0000
                  |L41.300|
                          DCD      I2C_DMAXferCplt
                  |L41.304|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_IT PROC
;;;1872     */
;;;1873   HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1874   {
000002  4603              MOV      r3,r0
;;;1875   
;;;1876     if (hi2c->State == HAL_I2C_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2820              CMP      r0,#0x20
00000a  d140              BNE      |L42.142|
;;;1877     {
;;;1878       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L42.16|
00000e  b90a              CBNZ     r2,|L42.20|
                  |L42.16|
;;;1879       {
;;;1880         return  HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L42.18|
;;;1881       }
;;;1882   
;;;1883       /* Process Locked */
;;;1884       __HAL_LOCK(hi2c);
;;;1885   
;;;1886       /* Check if the I2C is already enabled */
;;;1887       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1888       {
;;;1889         /* Enable I2C peripheral */
;;;1890         __HAL_I2C_ENABLE(hi2c);
;;;1891       }
;;;1892   
;;;1893       /* Disable Pos */
;;;1894       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1895   
;;;1896       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1897       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1898       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1899   
;;;1900       /* Prepare transfer parameters */
;;;1901       hi2c->pBuffPtr    = pData;
;;;1902       hi2c->XferCount   = Size;
;;;1903       hi2c->XferSize    = hi2c->XferCount;
;;;1904       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1905   
;;;1906       /* Enable Address Acknowledge */
;;;1907       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1908   
;;;1909       /* Process Unlocked */
;;;1910       __HAL_UNLOCK(hi2c);
;;;1911   
;;;1912       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1913                 to avoid the risk of I2C interrupt handle execution before current
;;;1914                 process unlock */
;;;1915   
;;;1916       /* Enable EVT, BUF and ERR interrupt */
;;;1917       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1918   
;;;1919       return HAL_OK;
;;;1920     }
;;;1921     else
;;;1922     {
;;;1923       return HAL_BUSY;
;;;1924     }
;;;1925   }
000012  bd10              POP      {r4,pc}
                  |L42.20|
000014  bf00              NOP                            ;1884
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;1884
00001a  2801              CMP      r0,#1                 ;1884
00001c  d101              BNE      |L42.34|
00001e  2002              MOVS     r0,#2                 ;1884
000020  e7f7              B        |L42.18|
                  |L42.34|
000022  2001              MOVS     r0,#1                 ;1884
000024  f883003c          STRB     r0,[r3,#0x3c]         ;1884
000028  bf00              NOP                            ;1884
00002a  6818              LDR      r0,[r3,#0]            ;1887
00002c  6800              LDR      r0,[r0,#0]            ;1887
00002e  f0000001          AND      r0,r0,#1              ;1887
000032  b928              CBNZ     r0,|L42.64|
000034  6818              LDR      r0,[r3,#0]            ;1890
000036  6800              LDR      r0,[r0,#0]            ;1890
000038  f0400001          ORR      r0,r0,#1              ;1890
00003c  681c              LDR      r4,[r3,#0]            ;1890
00003e  6020              STR      r0,[r4,#0]            ;1890
                  |L42.64|
000040  6818              LDR      r0,[r3,#0]            ;1894
000042  6800              LDR      r0,[r0,#0]            ;1894
000044  f4206000          BIC      r0,r0,#0x800          ;1894
000048  681c              LDR      r4,[r3,#0]            ;1894
00004a  6020              STR      r0,[r4,#0]            ;1894
00004c  2022              MOVS     r0,#0x22              ;1896
00004e  f883003d          STRB     r0,[r3,#0x3d]         ;1896
000052  2020              MOVS     r0,#0x20              ;1897
000054  f883003e          STRB     r0,[r3,#0x3e]         ;1897
000058  2000              MOVS     r0,#0                 ;1898
00005a  6418              STR      r0,[r3,#0x40]         ;1898
00005c  6259              STR      r1,[r3,#0x24]         ;1901
00005e  855a              STRH     r2,[r3,#0x2a]         ;1902
000060  8d58              LDRH     r0,[r3,#0x2a]         ;1903
000062  8518              STRH     r0,[r3,#0x28]         ;1903
000064  480b              LDR      r0,|L42.148|
000066  62d8              STR      r0,[r3,#0x2c]         ;1904
000068  6818              LDR      r0,[r3,#0]            ;1907
00006a  6800              LDR      r0,[r0,#0]            ;1907
00006c  f4406080          ORR      r0,r0,#0x400          ;1907
000070  681c              LDR      r4,[r3,#0]            ;1907
000072  6020              STR      r0,[r4,#0]            ;1907
000074  bf00              NOP                            ;1910
000076  2000              MOVS     r0,#0                 ;1910
000078  f883003c          STRB     r0,[r3,#0x3c]         ;1910
00007c  bf00              NOP                            ;1910
00007e  6818              LDR      r0,[r3,#0]            ;1917
000080  6840              LDR      r0,[r0,#4]            ;1917
000082  f44060e0          ORR      r0,r0,#0x700          ;1917
000086  681c              LDR      r4,[r3,#0]            ;1917
000088  6060              STR      r0,[r4,#4]            ;1917
00008a  2000              MOVS     r0,#0                 ;1919
00008c  e7c1              B        |L42.18|
                  |L42.142|
00008e  2002              MOVS     r0,#2                 ;1923
000090  e7bf              B        |L42.18|
;;;1926   
                          ENDP

000092  0000              DCW      0x0000
                  |L42.148|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Slave_Seq_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Receive_DMA PROC
;;;4484     */
;;;4485   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;4486   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;4487     HAL_StatusTypeDef dmaxferstatus;
;;;4488   
;;;4489     /* Check the parameters */
;;;4490     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4491   
;;;4492     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  f0000028          AND      r0,r0,#0x28
000014  2828              CMP      r0,#0x28
000016  d17d              BNE      |L43.276|
;;;4493     {
;;;4494       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L43.28|
00001a  b916              CBNZ     r6,|L43.34|
                  |L43.28|
;;;4495       {
;;;4496         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L43.30|
;;;4497       }
;;;4498   
;;;4499       /* Process Locked */
;;;4500       __HAL_LOCK(hi2c);
;;;4501   
;;;4502       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;4503       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4504   
;;;4505       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;4506       /* and then toggle the HAL slave RX state to TX state */
;;;4507       if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;4508       {
;;;4509         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4510         {
;;;4511           /* Abort DMA Xfer if any */
;;;4512           if (hi2c->hdmarx != NULL)
;;;4513           {
;;;4514             CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4515   
;;;4516             /* Set the I2C DMA Abort callback :
;;;4517              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4518             hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;4519   
;;;4520             /* Abort DMA RX */
;;;4521             if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;4522             {
;;;4523               /* Call Directly XferAbortCallback function in case of error */
;;;4524               hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;4525             }
;;;4526           }
;;;4527         }
;;;4528       }
;;;4529       else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;4530       {
;;;4531         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4532         {
;;;4533           CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4534   
;;;4535           /* Abort DMA Xfer if any */
;;;4536           if (hi2c->hdmatx != NULL)
;;;4537           {
;;;4538             /* Set the I2C DMA Abort callback :
;;;4539              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4540             hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
;;;4541   
;;;4542             /* Abort DMA TX */
;;;4543             if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;4544             {
;;;4545               /* Call Directly XferAbortCallback function in case of error */
;;;4546               hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;4547             }
;;;4548           }
;;;4549         }
;;;4550       }
;;;4551       else
;;;4552       {
;;;4553         /* Nothing to do */
;;;4554       }
;;;4555   
;;;4556       /* Check if the I2C is already enabled */
;;;4557       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4558       {
;;;4559         /* Enable I2C peripheral */
;;;4560         __HAL_I2C_ENABLE(hi2c);
;;;4561       }
;;;4562   
;;;4563       /* Disable Pos */
;;;4564       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4565   
;;;4566       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;4567       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4568       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4569   
;;;4570       /* Prepare transfer parameters */
;;;4571       hi2c->pBuffPtr    = pData;
;;;4572       hi2c->XferCount   = Size;
;;;4573       hi2c->XferSize    = hi2c->XferCount;
;;;4574       hi2c->XferOptions = XferOptions;
;;;4575   
;;;4576       if (hi2c->hdmarx != NULL)
;;;4577       {
;;;4578         /* Set the I2C DMA transfer complete callback */
;;;4579         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;4580   
;;;4581         /* Set the DMA error callback */
;;;4582         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;4583   
;;;4584         /* Set the unused DMA callbacks to NULL */
;;;4585         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;4586         hi2c->hdmarx->XferAbortCallback = NULL;
;;;4587   
;;;4588         /* Enable the DMA stream */
;;;4589         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;4590       }
;;;4591       else
;;;4592       {
;;;4593         /* Update I2C state */
;;;4594         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;4595         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4596   
;;;4597         /* Update I2C error code */
;;;4598         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;4599   
;;;4600         /* Process Unlocked */
;;;4601         __HAL_UNLOCK(hi2c);
;;;4602   
;;;4603         return HAL_ERROR;
;;;4604       }
;;;4605   
;;;4606       if (dmaxferstatus == HAL_OK)
;;;4607       {
;;;4608         /* Enable Address Acknowledge */
;;;4609         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4610   
;;;4611         /* Clear ADDR flag */
;;;4612         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4613   
;;;4614         /* Process Unlocked */
;;;4615         __HAL_UNLOCK(hi2c);
;;;4616   
;;;4617         /* Enable DMA Request */
;;;4618         SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4619   
;;;4620         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4621         to avoid the risk of I2C interrupt handle execution before current
;;;4622         process unlock */
;;;4623         /* Enable EVT and ERR interrupt */
;;;4624         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4625   
;;;4626         return HAL_OK;
;;;4627       }
;;;4628       else
;;;4629       {
;;;4630         /* Update I2C state */
;;;4631         hi2c->State     = HAL_I2C_STATE_READY;
;;;4632         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4633   
;;;4634         /* Update I2C error code */
;;;4635         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;4636   
;;;4637         /* Process Unlocked */
;;;4638         __HAL_UNLOCK(hi2c);
;;;4639   
;;;4640         return HAL_ERROR;
;;;4641       }
;;;4642     }
;;;4643     else
;;;4644     {
;;;4645       return HAL_BUSY;
;;;4646     }
;;;4647   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L43.34|
000022  bf00              NOP                            ;4500
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;4500
000028  2801              CMP      r0,#1                 ;4500
00002a  d101              BNE      |L43.48|
00002c  2002              MOVS     r0,#2                 ;4500
00002e  e7f6              B        |L43.30|
                  |L43.48|
000030  2001              MOVS     r0,#1                 ;4500
000032  f884003c          STRB     r0,[r4,#0x3c]         ;4500
000036  bf00              NOP                            ;4500
000038  6820              LDR      r0,[r4,#0]            ;4503
00003a  6840              LDR      r0,[r0,#4]            ;4503
00003c  f4207040          BIC      r0,r0,#0x300          ;4503
000040  6821              LDR      r1,[r4,#0]            ;4503
000042  6048              STR      r0,[r1,#4]            ;4503
000044  f894003d          LDRB     r0,[r4,#0x3d]         ;4507
000048  282a              CMP      r0,#0x2a              ;4507
00004a  d119              BNE      |L43.128|
00004c  6820              LDR      r0,[r4,#0]            ;4509
00004e  6840              LDR      r0,[r0,#4]            ;4509
000050  f4006000          AND      r0,r0,#0x800          ;4509
000054  f5b06f00          CMP      r0,#0x800             ;4509
000058  d12f              BNE      |L43.186|
00005a  6ba0              LDR      r0,[r4,#0x38]         ;4512
00005c  b368              CBZ      r0,|L43.186|
00005e  6820              LDR      r0,[r4,#0]            ;4514
000060  6840              LDR      r0,[r0,#4]            ;4514
000062  f4206000          BIC      r0,r0,#0x800          ;4514
000066  6821              LDR      r1,[r4,#0]            ;4514
000068  6048              STR      r0,[r1,#4]            ;4514
00006a  4855              LDR      r0,|L43.448|
00006c  6ba1              LDR      r1,[r4,#0x38]         ;4518
00006e  6508              STR      r0,[r1,#0x50]         ;4518
000070  6ba0              LDR      r0,[r4,#0x38]         ;4521
000072  f7fffffe          BL       HAL_DMA_Abort_IT
000076  b300              CBZ      r0,|L43.186|
000078  6ba0              LDR      r0,[r4,#0x38]         ;4524
00007a  6d01              LDR      r1,[r0,#0x50]         ;4524
00007c  4788              BLX      r1                    ;4524
00007e  e01c              B        |L43.186|
                  |L43.128|
000080  f894003d          LDRB     r0,[r4,#0x3d]         ;4529
000084  2829              CMP      r0,#0x29              ;4529
000086  d118              BNE      |L43.186|
000088  6820              LDR      r0,[r4,#0]            ;4531
00008a  6840              LDR      r0,[r0,#4]            ;4531
00008c  f4006000          AND      r0,r0,#0x800          ;4531
000090  f5b06f00          CMP      r0,#0x800             ;4531
000094  d111              BNE      |L43.186|
000096  6820              LDR      r0,[r4,#0]            ;4533
000098  6840              LDR      r0,[r0,#4]            ;4533
00009a  f4206000          BIC      r0,r0,#0x800          ;4533
00009e  6821              LDR      r1,[r4,#0]            ;4533
0000a0  6048              STR      r0,[r1,#4]            ;4533
0000a2  6b60              LDR      r0,[r4,#0x34]         ;4536
0000a4  b148              CBZ      r0,|L43.186|
0000a6  4846              LDR      r0,|L43.448|
0000a8  6b61              LDR      r1,[r4,#0x34]         ;4540
0000aa  6508              STR      r0,[r1,#0x50]         ;4540
0000ac  6b60              LDR      r0,[r4,#0x34]         ;4543
0000ae  f7fffffe          BL       HAL_DMA_Abort_IT
0000b2  b110              CBZ      r0,|L43.186|
0000b4  6b60              LDR      r0,[r4,#0x34]         ;4546
0000b6  6d01              LDR      r1,[r0,#0x50]         ;4546
0000b8  4788              BLX      r1                    ;4546
                  |L43.186|
0000ba  6820              LDR      r0,[r4,#0]            ;4557
0000bc  6800              LDR      r0,[r0,#0]            ;4557
0000be  f0000001          AND      r0,r0,#1              ;4557
0000c2  b928              CBNZ     r0,|L43.208|
0000c4  6820              LDR      r0,[r4,#0]            ;4560
0000c6  6800              LDR      r0,[r0,#0]            ;4560
0000c8  f0400001          ORR      r0,r0,#1              ;4560
0000cc  6821              LDR      r1,[r4,#0]            ;4560
0000ce  6008              STR      r0,[r1,#0]            ;4560
                  |L43.208|
0000d0  6820              LDR      r0,[r4,#0]            ;4564
0000d2  6800              LDR      r0,[r0,#0]            ;4564
0000d4  f4206000          BIC      r0,r0,#0x800          ;4564
0000d8  6821              LDR      r1,[r4,#0]            ;4564
0000da  6008              STR      r0,[r1,#0]            ;4564
0000dc  202a              MOVS     r0,#0x2a              ;4566
0000de  f884003d          STRB     r0,[r4,#0x3d]         ;4566
0000e2  2020              MOVS     r0,#0x20              ;4567
0000e4  f884003e          STRB     r0,[r4,#0x3e]         ;4567
0000e8  2000              MOVS     r0,#0                 ;4568
0000ea  6420              STR      r0,[r4,#0x40]         ;4568
0000ec  6265              STR      r5,[r4,#0x24]         ;4571
0000ee  8566              STRH     r6,[r4,#0x2a]         ;4572
0000f0  8d60              LDRH     r0,[r4,#0x2a]         ;4573
0000f2  8520              STRH     r0,[r4,#0x28]         ;4573
0000f4  f8c4802c          STR      r8,[r4,#0x2c]         ;4574
0000f8  6ba0              LDR      r0,[r4,#0x38]         ;4576
0000fa  b1b8              CBZ      r0,|L43.300|
0000fc  4831              LDR      r0,|L43.452|
0000fe  6ba1              LDR      r1,[r4,#0x38]         ;4579
000100  63c8              STR      r0,[r1,#0x3c]         ;4579
000102  4831              LDR      r0,|L43.456|
000104  6ba1              LDR      r1,[r4,#0x38]         ;4582
000106  64c8              STR      r0,[r1,#0x4c]         ;4582
000108  2000              MOVS     r0,#0                 ;4585
00010a  6ba1              LDR      r1,[r4,#0x38]         ;4585
00010c  6408              STR      r0,[r1,#0x40]         ;4585
00010e  6ba1              LDR      r1,[r4,#0x38]         ;4586
000110  6508              STR      r0,[r1,#0x50]         ;4586
000112  e000              B        |L43.278|
                  |L43.276|
000114  e051              B        |L43.442|
                  |L43.278|
000116  8d23              LDRH     r3,[r4,#0x28]         ;4589
000118  f8d4c000          LDR      r12,[r4,#0]           ;4589
00011c  f10c0110          ADD      r1,r12,#0x10          ;4589
000120  6a62              LDR      r2,[r4,#0x24]         ;4589
000122  6ba0              LDR      r0,[r4,#0x38]         ;4589
000124  f7fffffe          BL       HAL_DMA_Start_IT
000128  4607              MOV      r7,r0                 ;4589
00012a  e010              B        |L43.334|
                  |L43.300|
00012c  2028              MOVS     r0,#0x28              ;4594
00012e  f884003d          STRB     r0,[r4,#0x3d]         ;4594
000132  2000              MOVS     r0,#0                 ;4595
000134  f884003e          STRB     r0,[r4,#0x3e]         ;4595
000138  6c20              LDR      r0,[r4,#0x40]         ;4598
00013a  f0400080          ORR      r0,r0,#0x80           ;4598
00013e  6420              STR      r0,[r4,#0x40]         ;4598
000140  bf00              NOP                            ;4601
000142  2000              MOVS     r0,#0                 ;4601
000144  f884003c          STRB     r0,[r4,#0x3c]         ;4601
000148  bf00              NOP                            ;4601
00014a  2001              MOVS     r0,#1                 ;4603
00014c  e767              B        |L43.30|
                  |L43.334|
00014e  bb1f              CBNZ     r7,|L43.408|
000150  6820              LDR      r0,[r4,#0]            ;4609
000152  6800              LDR      r0,[r0,#0]            ;4609
000154  f4406080          ORR      r0,r0,#0x400          ;4609
000158  6821              LDR      r1,[r4,#0]            ;4609
00015a  6008              STR      r0,[r1,#0]            ;4609
00015c  bf00              NOP                            ;4612
00015e  2000              MOVS     r0,#0                 ;4612
000160  9000              STR      r0,[sp,#0]            ;4612
000162  6820              LDR      r0,[r4,#0]            ;4612
000164  6940              LDR      r0,[r0,#0x14]         ;4612
000166  9000              STR      r0,[sp,#0]            ;4612
000168  6820              LDR      r0,[r4,#0]            ;4612
00016a  6980              LDR      r0,[r0,#0x18]         ;4612
00016c  9000              STR      r0,[sp,#0]            ;4612
00016e  bf00              NOP                            ;4612
000170  bf00              NOP                            ;4612
000172  bf00              NOP                            ;4615
000174  2000              MOVS     r0,#0                 ;4615
000176  f884003c          STRB     r0,[r4,#0x3c]         ;4615
00017a  bf00              NOP                            ;4615
00017c  6820              LDR      r0,[r4,#0]            ;4618
00017e  6840              LDR      r0,[r0,#4]            ;4618
000180  f4406000          ORR      r0,r0,#0x800          ;4618
000184  6821              LDR      r1,[r4,#0]            ;4618
000186  6048              STR      r0,[r1,#4]            ;4618
000188  6820              LDR      r0,[r4,#0]            ;4624
00018a  6840              LDR      r0,[r0,#4]            ;4624
00018c  f4407040          ORR      r0,r0,#0x300          ;4624
000190  6821              LDR      r1,[r4,#0]            ;4624
000192  6048              STR      r0,[r1,#4]            ;4624
000194  2000              MOVS     r0,#0                 ;4626
000196  e742              B        |L43.30|
                  |L43.408|
000198  2020              MOVS     r0,#0x20              ;4631
00019a  f884003d          STRB     r0,[r4,#0x3d]         ;4631
00019e  2000              MOVS     r0,#0                 ;4632
0001a0  f884003e          STRB     r0,[r4,#0x3e]         ;4632
0001a4  6c20              LDR      r0,[r4,#0x40]         ;4635
0001a6  f0400010          ORR      r0,r0,#0x10           ;4635
0001aa  6420              STR      r0,[r4,#0x40]         ;4635
0001ac  bf00              NOP                            ;4638
0001ae  2000              MOVS     r0,#0                 ;4638
0001b0  f884003c          STRB     r0,[r4,#0x3c]         ;4638
0001b4  bf00              NOP                            ;4638
0001b6  2001              MOVS     r0,#1                 ;4640
0001b8  e731              B        |L43.30|
                  |L43.442|
0001ba  2002              MOVS     r0,#2                 ;4645
0001bc  e72f              B        |L43.30|
;;;4648   
                          ENDP

0001be  0000              DCW      0x0000
                  |L43.448|
                          DCD      I2C_DMAAbort
                  |L43.452|
                          DCD      I2C_DMAXferCplt
                  |L43.456|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Seq_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Seq_Receive_IT PROC
;;;4418     */
;;;4419   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b538              PUSH     {r3-r5,lr}
;;;4420   {
000002  4604              MOV      r4,r0
;;;4421     /* Check the parameters */
;;;4422     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4423   
;;;4424     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  f0000028          AND      r0,r0,#0x28
00000c  2828              CMP      r0,#0x28
00000e  d144              BNE      |L44.154|
;;;4425     {
;;;4426       if ((pData == NULL) || (Size == 0U))
000010  b101              CBZ      r1,|L44.20|
000012  b90a              CBNZ     r2,|L44.24|
                  |L44.20|
;;;4427       {
;;;4428         return  HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L44.22|
;;;4429       }
;;;4430   
;;;4431       /* Process Locked */
;;;4432       __HAL_LOCK(hi2c);
;;;4433   
;;;4434       /* Check if the I2C is already enabled */
;;;4435       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4436       {
;;;4437         /* Enable I2C peripheral */
;;;4438         __HAL_I2C_ENABLE(hi2c);
;;;4439       }
;;;4440   
;;;4441       /* Disable Pos */
;;;4442       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4443   
;;;4444       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;4445       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4446       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4447   
;;;4448       /* Prepare transfer parameters */
;;;4449       hi2c->pBuffPtr    = pData;
;;;4450       hi2c->XferCount   = Size;
;;;4451       hi2c->XferSize    = hi2c->XferCount;
;;;4452       hi2c->XferOptions = XferOptions;
;;;4453   
;;;4454       /* Clear ADDR flag */
;;;4455       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4456   
;;;4457       /* Process Unlocked */
;;;4458       __HAL_UNLOCK(hi2c);
;;;4459   
;;;4460       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4461                 to avoid the risk of I2C interrupt handle execution before current
;;;4462                 process unlock */
;;;4463   
;;;4464       /* Enable EVT, BUF and ERR interrupt */
;;;4465       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4466   
;;;4467       return HAL_OK;
;;;4468     }
;;;4469     else
;;;4470     {
;;;4471       return HAL_BUSY;
;;;4472     }
;;;4473   }
000016  bd38              POP      {r3-r5,pc}
                  |L44.24|
000018  bf00              NOP                            ;4432
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;4432
00001e  2801              CMP      r0,#1                 ;4432
000020  d101              BNE      |L44.38|
000022  2002              MOVS     r0,#2                 ;4432
000024  e7f7              B        |L44.22|
                  |L44.38|
000026  2001              MOVS     r0,#1                 ;4432
000028  f884003c          STRB     r0,[r4,#0x3c]         ;4432
00002c  bf00              NOP                            ;4432
00002e  6820              LDR      r0,[r4,#0]            ;4435
000030  6800              LDR      r0,[r0,#0]            ;4435
000032  f0000001          AND      r0,r0,#1              ;4435
000036  b928              CBNZ     r0,|L44.68|
000038  6820              LDR      r0,[r4,#0]            ;4438
00003a  6800              LDR      r0,[r0,#0]            ;4438
00003c  f0400001          ORR      r0,r0,#1              ;4438
000040  6825              LDR      r5,[r4,#0]            ;4438
000042  6028              STR      r0,[r5,#0]            ;4438
                  |L44.68|
000044  6820              LDR      r0,[r4,#0]            ;4442
000046  6800              LDR      r0,[r0,#0]            ;4442
000048  f4206000          BIC      r0,r0,#0x800          ;4442
00004c  6825              LDR      r5,[r4,#0]            ;4442
00004e  6028              STR      r0,[r5,#0]            ;4442
000050  202a              MOVS     r0,#0x2a              ;4444
000052  f884003d          STRB     r0,[r4,#0x3d]         ;4444
000056  2020              MOVS     r0,#0x20              ;4445
000058  f884003e          STRB     r0,[r4,#0x3e]         ;4445
00005c  2000              MOVS     r0,#0                 ;4446
00005e  6420              STR      r0,[r4,#0x40]         ;4446
000060  6261              STR      r1,[r4,#0x24]         ;4449
000062  8562              STRH     r2,[r4,#0x2a]         ;4450
000064  8d60              LDRH     r0,[r4,#0x2a]         ;4451
000066  8520              STRH     r0,[r4,#0x28]         ;4451
000068  62e3              STR      r3,[r4,#0x2c]         ;4452
00006a  bf00              NOP                            ;4455
00006c  2000              MOVS     r0,#0                 ;4455
00006e  9000              STR      r0,[sp,#0]            ;4455
000070  6820              LDR      r0,[r4,#0]            ;4455
000072  6940              LDR      r0,[r0,#0x14]         ;4455
000074  9000              STR      r0,[sp,#0]            ;4455
000076  6820              LDR      r0,[r4,#0]            ;4455
000078  6980              LDR      r0,[r0,#0x18]         ;4455
00007a  9000              STR      r0,[sp,#0]            ;4455
00007c  bf00              NOP                            ;4455
00007e  bf00              NOP                            ;4455
000080  bf00              NOP                            ;4458
000082  2000              MOVS     r0,#0                 ;4458
000084  f884003c          STRB     r0,[r4,#0x3c]         ;4458
000088  bf00              NOP                            ;4458
00008a  6820              LDR      r0,[r4,#0]            ;4465
00008c  6840              LDR      r0,[r0,#4]            ;4465
00008e  f44060e0          ORR      r0,r0,#0x700          ;4465
000092  6825              LDR      r5,[r4,#0]            ;4465
000094  6068              STR      r0,[r5,#4]            ;4465
000096  2000              MOVS     r0,#0                 ;4467
000098  e7bd              B        |L44.22|
                  |L44.154|
00009a  2002              MOVS     r0,#2                 ;4471
00009c  e7bb              B        |L44.22|
;;;4474   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Seq_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Transmit_DMA PROC
;;;4244     */
;;;4245   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;4246   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;4247     HAL_StatusTypeDef dmaxferstatus;
;;;4248   
;;;4249     /* Check the parameters */
;;;4250     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4251   
;;;4252     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  f0000028          AND      r0,r0,#0x28
000014  2828              CMP      r0,#0x28
000016  d17d              BNE      |L45.276|
;;;4253     {
;;;4254       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L45.28|
00001a  b916              CBNZ     r6,|L45.34|
                  |L45.28|
;;;4255       {
;;;4256         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L45.30|
;;;4257       }
;;;4258   
;;;4259       /* Process Locked */
;;;4260       __HAL_LOCK(hi2c);
;;;4261   
;;;4262       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;4263       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4264   
;;;4265       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;4266       /* and then toggle the HAL slave RX state to TX state */
;;;4267       if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;4268       {
;;;4269         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4270         {
;;;4271           /* Abort DMA Xfer if any */
;;;4272           if (hi2c->hdmarx != NULL)
;;;4273           {
;;;4274             CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4275   
;;;4276             /* Set the I2C DMA Abort callback :
;;;4277              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4278             hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;4279   
;;;4280             /* Abort DMA RX */
;;;4281             if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;4282             {
;;;4283               /* Call Directly XferAbortCallback function in case of error */
;;;4284               hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;4285             }
;;;4286           }
;;;4287         }
;;;4288       }
;;;4289       else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;4290       {
;;;4291         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4292         {
;;;4293           CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4294   
;;;4295           /* Abort DMA Xfer if any */
;;;4296           if (hi2c->hdmatx != NULL)
;;;4297           {
;;;4298             /* Set the I2C DMA Abort callback :
;;;4299              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4300             hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
;;;4301   
;;;4302             /* Abort DMA TX */
;;;4303             if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;4304             {
;;;4305               /* Call Directly XferAbortCallback function in case of error */
;;;4306               hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;4307             }
;;;4308           }
;;;4309         }
;;;4310       }
;;;4311       else
;;;4312       {
;;;4313         /* Nothing to do */
;;;4314       }
;;;4315   
;;;4316       /* Check if the I2C is already enabled */
;;;4317       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4318       {
;;;4319         /* Enable I2C peripheral */
;;;4320         __HAL_I2C_ENABLE(hi2c);
;;;4321       }
;;;4322   
;;;4323       /* Disable Pos */
;;;4324       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4325   
;;;4326       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;4327       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4328       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4329   
;;;4330       /* Prepare transfer parameters */
;;;4331       hi2c->pBuffPtr    = pData;
;;;4332       hi2c->XferCount   = Size;
;;;4333       hi2c->XferSize    = hi2c->XferCount;
;;;4334       hi2c->XferOptions = XferOptions;
;;;4335   
;;;4336       if (hi2c->hdmatx != NULL)
;;;4337       {
;;;4338         /* Set the I2C DMA transfer complete callback */
;;;4339         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;4340   
;;;4341         /* Set the DMA error callback */
;;;4342         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;4343   
;;;4344         /* Set the unused DMA callbacks to NULL */
;;;4345         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;4346         hi2c->hdmatx->XferAbortCallback = NULL;
;;;4347   
;;;4348         /* Enable the DMA stream */
;;;4349         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;4350       }
;;;4351       else
;;;4352       {
;;;4353         /* Update I2C state */
;;;4354         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;4355         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4356   
;;;4357         /* Update I2C error code */
;;;4358         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;4359   
;;;4360         /* Process Unlocked */
;;;4361         __HAL_UNLOCK(hi2c);
;;;4362   
;;;4363         return HAL_ERROR;
;;;4364       }
;;;4365   
;;;4366       if (dmaxferstatus == HAL_OK)
;;;4367       {
;;;4368         /* Enable Address Acknowledge */
;;;4369         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4370   
;;;4371         /* Clear ADDR flag */
;;;4372         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4373   
;;;4374         /* Process Unlocked */
;;;4375         __HAL_UNLOCK(hi2c);
;;;4376   
;;;4377         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4378         to avoid the risk of I2C interrupt handle execution before current
;;;4379         process unlock */
;;;4380         /* Enable EVT and ERR interrupt */
;;;4381         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4382   
;;;4383         /* Enable DMA Request */
;;;4384         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;4385   
;;;4386         return HAL_OK;
;;;4387       }
;;;4388       else
;;;4389       {
;;;4390         /* Update I2C state */
;;;4391         hi2c->State     = HAL_I2C_STATE_READY;
;;;4392         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4393   
;;;4394         /* Update I2C error code */
;;;4395         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;4396   
;;;4397         /* Process Unlocked */
;;;4398         __HAL_UNLOCK(hi2c);
;;;4399   
;;;4400         return HAL_ERROR;
;;;4401       }
;;;4402     }
;;;4403     else
;;;4404     {
;;;4405       return HAL_BUSY;
;;;4406     }
;;;4407   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L45.34|
000022  bf00              NOP                            ;4260
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;4260
000028  2801              CMP      r0,#1                 ;4260
00002a  d101              BNE      |L45.48|
00002c  2002              MOVS     r0,#2                 ;4260
00002e  e7f6              B        |L45.30|
                  |L45.48|
000030  2001              MOVS     r0,#1                 ;4260
000032  f884003c          STRB     r0,[r4,#0x3c]         ;4260
000036  bf00              NOP                            ;4260
000038  6820              LDR      r0,[r4,#0]            ;4263
00003a  6840              LDR      r0,[r0,#4]            ;4263
00003c  f4207040          BIC      r0,r0,#0x300          ;4263
000040  6821              LDR      r1,[r4,#0]            ;4263
000042  6048              STR      r0,[r1,#4]            ;4263
000044  f894003d          LDRB     r0,[r4,#0x3d]         ;4267
000048  282a              CMP      r0,#0x2a              ;4267
00004a  d119              BNE      |L45.128|
00004c  6820              LDR      r0,[r4,#0]            ;4269
00004e  6840              LDR      r0,[r0,#4]            ;4269
000050  f4006000          AND      r0,r0,#0x800          ;4269
000054  f5b06f00          CMP      r0,#0x800             ;4269
000058  d12f              BNE      |L45.186|
00005a  6ba0              LDR      r0,[r4,#0x38]         ;4272
00005c  b368              CBZ      r0,|L45.186|
00005e  6820              LDR      r0,[r4,#0]            ;4274
000060  6840              LDR      r0,[r0,#4]            ;4274
000062  f4206000          BIC      r0,r0,#0x800          ;4274
000066  6821              LDR      r1,[r4,#0]            ;4274
000068  6048              STR      r0,[r1,#4]            ;4274
00006a  4855              LDR      r0,|L45.448|
00006c  6ba1              LDR      r1,[r4,#0x38]         ;4278
00006e  6508              STR      r0,[r1,#0x50]         ;4278
000070  6ba0              LDR      r0,[r4,#0x38]         ;4281
000072  f7fffffe          BL       HAL_DMA_Abort_IT
000076  b300              CBZ      r0,|L45.186|
000078  6ba0              LDR      r0,[r4,#0x38]         ;4284
00007a  6d01              LDR      r1,[r0,#0x50]         ;4284
00007c  4788              BLX      r1                    ;4284
00007e  e01c              B        |L45.186|
                  |L45.128|
000080  f894003d          LDRB     r0,[r4,#0x3d]         ;4289
000084  2829              CMP      r0,#0x29              ;4289
000086  d118              BNE      |L45.186|
000088  6820              LDR      r0,[r4,#0]            ;4291
00008a  6840              LDR      r0,[r0,#4]            ;4291
00008c  f4006000          AND      r0,r0,#0x800          ;4291
000090  f5b06f00          CMP      r0,#0x800             ;4291
000094  d111              BNE      |L45.186|
000096  6820              LDR      r0,[r4,#0]            ;4293
000098  6840              LDR      r0,[r0,#4]            ;4293
00009a  f4206000          BIC      r0,r0,#0x800          ;4293
00009e  6821              LDR      r1,[r4,#0]            ;4293
0000a0  6048              STR      r0,[r1,#4]            ;4293
0000a2  6b60              LDR      r0,[r4,#0x34]         ;4296
0000a4  b148              CBZ      r0,|L45.186|
0000a6  4846              LDR      r0,|L45.448|
0000a8  6b61              LDR      r1,[r4,#0x34]         ;4300
0000aa  6508              STR      r0,[r1,#0x50]         ;4300
0000ac  6b60              LDR      r0,[r4,#0x34]         ;4303
0000ae  f7fffffe          BL       HAL_DMA_Abort_IT
0000b2  b110              CBZ      r0,|L45.186|
0000b4  6b60              LDR      r0,[r4,#0x34]         ;4306
0000b6  6d01              LDR      r1,[r0,#0x50]         ;4306
0000b8  4788              BLX      r1                    ;4306
                  |L45.186|
0000ba  6820              LDR      r0,[r4,#0]            ;4317
0000bc  6800              LDR      r0,[r0,#0]            ;4317
0000be  f0000001          AND      r0,r0,#1              ;4317
0000c2  b928              CBNZ     r0,|L45.208|
0000c4  6820              LDR      r0,[r4,#0]            ;4320
0000c6  6800              LDR      r0,[r0,#0]            ;4320
0000c8  f0400001          ORR      r0,r0,#1              ;4320
0000cc  6821              LDR      r1,[r4,#0]            ;4320
0000ce  6008              STR      r0,[r1,#0]            ;4320
                  |L45.208|
0000d0  6820              LDR      r0,[r4,#0]            ;4324
0000d2  6800              LDR      r0,[r0,#0]            ;4324
0000d4  f4206000          BIC      r0,r0,#0x800          ;4324
0000d8  6821              LDR      r1,[r4,#0]            ;4324
0000da  6008              STR      r0,[r1,#0]            ;4324
0000dc  2029              MOVS     r0,#0x29              ;4326
0000de  f884003d          STRB     r0,[r4,#0x3d]         ;4326
0000e2  2020              MOVS     r0,#0x20              ;4327
0000e4  f884003e          STRB     r0,[r4,#0x3e]         ;4327
0000e8  2000              MOVS     r0,#0                 ;4328
0000ea  6420              STR      r0,[r4,#0x40]         ;4328
0000ec  6265              STR      r5,[r4,#0x24]         ;4331
0000ee  8566              STRH     r6,[r4,#0x2a]         ;4332
0000f0  8d60              LDRH     r0,[r4,#0x2a]         ;4333
0000f2  8520              STRH     r0,[r4,#0x28]         ;4333
0000f4  f8c4802c          STR      r8,[r4,#0x2c]         ;4334
0000f8  6b60              LDR      r0,[r4,#0x34]         ;4336
0000fa  b1b8              CBZ      r0,|L45.300|
0000fc  4831              LDR      r0,|L45.452|
0000fe  6b61              LDR      r1,[r4,#0x34]         ;4339
000100  63c8              STR      r0,[r1,#0x3c]         ;4339
000102  4831              LDR      r0,|L45.456|
000104  6b61              LDR      r1,[r4,#0x34]         ;4342
000106  64c8              STR      r0,[r1,#0x4c]         ;4342
000108  2000              MOVS     r0,#0                 ;4345
00010a  6b61              LDR      r1,[r4,#0x34]         ;4345
00010c  6408              STR      r0,[r1,#0x40]         ;4345
00010e  6b61              LDR      r1,[r4,#0x34]         ;4346
000110  6508              STR      r0,[r1,#0x50]         ;4346
000112  e000              B        |L45.278|
                  |L45.276|
000114  e051              B        |L45.442|
                  |L45.278|
000116  8d23              LDRH     r3,[r4,#0x28]         ;4349
000118  f8d4c000          LDR      r12,[r4,#0]           ;4349
00011c  f10c0210          ADD      r2,r12,#0x10          ;4349
000120  6a61              LDR      r1,[r4,#0x24]         ;4349
000122  6b60              LDR      r0,[r4,#0x34]         ;4349
000124  f7fffffe          BL       HAL_DMA_Start_IT
000128  4607              MOV      r7,r0                 ;4349
00012a  e010              B        |L45.334|
                  |L45.300|
00012c  2028              MOVS     r0,#0x28              ;4354
00012e  f884003d          STRB     r0,[r4,#0x3d]         ;4354
000132  2000              MOVS     r0,#0                 ;4355
000134  f884003e          STRB     r0,[r4,#0x3e]         ;4355
000138  6c20              LDR      r0,[r4,#0x40]         ;4358
00013a  f0400080          ORR      r0,r0,#0x80           ;4358
00013e  6420              STR      r0,[r4,#0x40]         ;4358
000140  bf00              NOP                            ;4361
000142  2000              MOVS     r0,#0                 ;4361
000144  f884003c          STRB     r0,[r4,#0x3c]         ;4361
000148  bf00              NOP                            ;4361
00014a  2001              MOVS     r0,#1                 ;4363
00014c  e767              B        |L45.30|
                  |L45.334|
00014e  bb1f              CBNZ     r7,|L45.408|
000150  6820              LDR      r0,[r4,#0]            ;4369
000152  6800              LDR      r0,[r0,#0]            ;4369
000154  f4406080          ORR      r0,r0,#0x400          ;4369
000158  6821              LDR      r1,[r4,#0]            ;4369
00015a  6008              STR      r0,[r1,#0]            ;4369
00015c  bf00              NOP                            ;4372
00015e  2000              MOVS     r0,#0                 ;4372
000160  9000              STR      r0,[sp,#0]            ;4372
000162  6820              LDR      r0,[r4,#0]            ;4372
000164  6940              LDR      r0,[r0,#0x14]         ;4372
000166  9000              STR      r0,[sp,#0]            ;4372
000168  6820              LDR      r0,[r4,#0]            ;4372
00016a  6980              LDR      r0,[r0,#0x18]         ;4372
00016c  9000              STR      r0,[sp,#0]            ;4372
00016e  bf00              NOP                            ;4372
000170  bf00              NOP                            ;4372
000172  bf00              NOP                            ;4375
000174  2000              MOVS     r0,#0                 ;4375
000176  f884003c          STRB     r0,[r4,#0x3c]         ;4375
00017a  bf00              NOP                            ;4375
00017c  6820              LDR      r0,[r4,#0]            ;4381
00017e  6840              LDR      r0,[r0,#4]            ;4381
000180  f4407040          ORR      r0,r0,#0x300          ;4381
000184  6821              LDR      r1,[r4,#0]            ;4381
000186  6048              STR      r0,[r1,#4]            ;4381
000188  6820              LDR      r0,[r4,#0]            ;4384
00018a  6840              LDR      r0,[r0,#4]            ;4384
00018c  f4406000          ORR      r0,r0,#0x800          ;4384
000190  6821              LDR      r1,[r4,#0]            ;4384
000192  6048              STR      r0,[r1,#4]            ;4384
000194  2000              MOVS     r0,#0                 ;4386
000196  e742              B        |L45.30|
                  |L45.408|
000198  2020              MOVS     r0,#0x20              ;4391
00019a  f884003d          STRB     r0,[r4,#0x3d]         ;4391
00019e  2000              MOVS     r0,#0                 ;4392
0001a0  f884003e          STRB     r0,[r4,#0x3e]         ;4392
0001a4  6c20              LDR      r0,[r4,#0x40]         ;4395
0001a6  f0400010          ORR      r0,r0,#0x10           ;4395
0001aa  6420              STR      r0,[r4,#0x40]         ;4395
0001ac  bf00              NOP                            ;4398
0001ae  2000              MOVS     r0,#0                 ;4398
0001b0  f884003c          STRB     r0,[r4,#0x3c]         ;4398
0001b4  bf00              NOP                            ;4398
0001b6  2001              MOVS     r0,#1                 ;4400
0001b8  e731              B        |L45.30|
                  |L45.442|
0001ba  2002              MOVS     r0,#2                 ;4405
0001bc  e72f              B        |L45.30|
;;;4408   
                          ENDP

0001be  0000              DCW      0x0000
                  |L45.448|
                          DCD      I2C_DMAAbort
                  |L45.452|
                          DCD      I2C_DMAXferCplt
                  |L45.456|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Seq_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Seq_Transmit_IT PROC
;;;4178     */
;;;4179   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b538              PUSH     {r3-r5,lr}
;;;4180   {
000002  4604              MOV      r4,r0
;;;4181     /* Check the parameters */
;;;4182     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4183   
;;;4184     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  f0000028          AND      r0,r0,#0x28
00000c  2828              CMP      r0,#0x28
00000e  d144              BNE      |L46.154|
;;;4185     {
;;;4186       if ((pData == NULL) || (Size == 0U))
000010  b101              CBZ      r1,|L46.20|
000012  b90a              CBNZ     r2,|L46.24|
                  |L46.20|
;;;4187       {
;;;4188         return  HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L46.22|
;;;4189       }
;;;4190   
;;;4191       /* Process Locked */
;;;4192       __HAL_LOCK(hi2c);
;;;4193   
;;;4194       /* Check if the I2C is already enabled */
;;;4195       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4196       {
;;;4197         /* Enable I2C peripheral */
;;;4198         __HAL_I2C_ENABLE(hi2c);
;;;4199       }
;;;4200   
;;;4201       /* Disable Pos */
;;;4202       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4203   
;;;4204       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;4205       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4206       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4207   
;;;4208       /* Prepare transfer parameters */
;;;4209       hi2c->pBuffPtr    = pData;
;;;4210       hi2c->XferCount   = Size;
;;;4211       hi2c->XferSize    = hi2c->XferCount;
;;;4212       hi2c->XferOptions = XferOptions;
;;;4213   
;;;4214       /* Clear ADDR flag */
;;;4215       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4216   
;;;4217       /* Process Unlocked */
;;;4218       __HAL_UNLOCK(hi2c);
;;;4219   
;;;4220       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4221                 to avoid the risk of I2C interrupt handle execution before current
;;;4222                 process unlock */
;;;4223   
;;;4224       /* Enable EVT, BUF and ERR interrupt */
;;;4225       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4226   
;;;4227       return HAL_OK;
;;;4228     }
;;;4229     else
;;;4230     {
;;;4231       return HAL_BUSY;
;;;4232     }
;;;4233   }
000016  bd38              POP      {r3-r5,pc}
                  |L46.24|
000018  bf00              NOP                            ;4192
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;4192
00001e  2801              CMP      r0,#1                 ;4192
000020  d101              BNE      |L46.38|
000022  2002              MOVS     r0,#2                 ;4192
000024  e7f7              B        |L46.22|
                  |L46.38|
000026  2001              MOVS     r0,#1                 ;4192
000028  f884003c          STRB     r0,[r4,#0x3c]         ;4192
00002c  bf00              NOP                            ;4192
00002e  6820              LDR      r0,[r4,#0]            ;4195
000030  6800              LDR      r0,[r0,#0]            ;4195
000032  f0000001          AND      r0,r0,#1              ;4195
000036  b928              CBNZ     r0,|L46.68|
000038  6820              LDR      r0,[r4,#0]            ;4198
00003a  6800              LDR      r0,[r0,#0]            ;4198
00003c  f0400001          ORR      r0,r0,#1              ;4198
000040  6825              LDR      r5,[r4,#0]            ;4198
000042  6028              STR      r0,[r5,#0]            ;4198
                  |L46.68|
000044  6820              LDR      r0,[r4,#0]            ;4202
000046  6800              LDR      r0,[r0,#0]            ;4202
000048  f4206000          BIC      r0,r0,#0x800          ;4202
00004c  6825              LDR      r5,[r4,#0]            ;4202
00004e  6028              STR      r0,[r5,#0]            ;4202
000050  2029              MOVS     r0,#0x29              ;4204
000052  f884003d          STRB     r0,[r4,#0x3d]         ;4204
000056  2020              MOVS     r0,#0x20              ;4205
000058  f884003e          STRB     r0,[r4,#0x3e]         ;4205
00005c  2000              MOVS     r0,#0                 ;4206
00005e  6420              STR      r0,[r4,#0x40]         ;4206
000060  6261              STR      r1,[r4,#0x24]         ;4209
000062  8562              STRH     r2,[r4,#0x2a]         ;4210
000064  8d60              LDRH     r0,[r4,#0x2a]         ;4211
000066  8520              STRH     r0,[r4,#0x28]         ;4211
000068  62e3              STR      r3,[r4,#0x2c]         ;4212
00006a  bf00              NOP                            ;4215
00006c  2000              MOVS     r0,#0                 ;4215
00006e  9000              STR      r0,[sp,#0]            ;4215
000070  6820              LDR      r0,[r4,#0]            ;4215
000072  6940              LDR      r0,[r0,#0x14]         ;4215
000074  9000              STR      r0,[sp,#0]            ;4215
000076  6820              LDR      r0,[r4,#0]            ;4215
000078  6980              LDR      r0,[r0,#0x18]         ;4215
00007a  9000              STR      r0,[sp,#0]            ;4215
00007c  bf00              NOP                            ;4215
00007e  bf00              NOP                            ;4215
000080  bf00              NOP                            ;4218
000082  2000              MOVS     r0,#0                 ;4218
000084  f884003c          STRB     r0,[r4,#0x3c]         ;4218
000088  bf00              NOP                            ;4218
00008a  6820              LDR      r0,[r4,#0]            ;4225
00008c  6840              LDR      r0,[r0,#4]            ;4225
00008e  f44060e0          ORR      r0,r0,#0x700          ;4225
000092  6825              LDR      r5,[r4,#0]            ;4225
000094  6068              STR      r0,[r5,#4]            ;4225
000096  2000              MOVS     r0,#0                 ;4227
000098  e7bd              B        |L46.22|
                  |L46.154|
00009a  2002              MOVS     r0,#2                 ;4231
00009c  e7bb              B        |L46.22|
;;;4234   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit PROC
;;;1396     */
;;;1397   HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1398   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1399     /* Init tickstart for timeout management*/
;;;1400     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;1401   
;;;1402     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2820              CMP      r0,#0x20
000018  d171              BNE      |L47.254|
;;;1403     {
;;;1404       if ((pData == NULL) || (Size == 0U))
00001a  b106              CBZ      r6,|L47.30|
00001c  b917              CBNZ     r7,|L47.36|
                  |L47.30|
;;;1405       {
;;;1406         return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L47.32|
;;;1407       }
;;;1408   
;;;1409       /* Process Locked */
;;;1410       __HAL_LOCK(hi2c);
;;;1411   
;;;1412       /* Check if the I2C is already enabled */
;;;1413       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1414       {
;;;1415         /* Enable I2C peripheral */
;;;1416         __HAL_I2C_ENABLE(hi2c);
;;;1417       }
;;;1418   
;;;1419       /* Disable Pos */
;;;1420       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1421   
;;;1422       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1423       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1424       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1425   
;;;1426       /* Prepare transfer parameters */
;;;1427       hi2c->pBuffPtr    = pData;
;;;1428       hi2c->XferCount   = Size;
;;;1429       hi2c->XferSize    = hi2c->XferCount;
;;;1430       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1431   
;;;1432       /* Enable Address Acknowledge */
;;;1433       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1434   
;;;1435       /* Wait until ADDR flag is set */
;;;1436       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1437       {
;;;1438         return HAL_ERROR;
;;;1439       }
;;;1440   
;;;1441       /* Clear ADDR flag */
;;;1442       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1443   
;;;1444       /* If 10bit addressing mode is selected */
;;;1445       if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
;;;1446       {
;;;1447         /* Wait until ADDR flag is set */
;;;1448         if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1449         {
;;;1450           return HAL_ERROR;
;;;1451         }
;;;1452   
;;;1453         /* Clear ADDR flag */
;;;1454         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1455       }
;;;1456   
;;;1457       while (hi2c->XferSize > 0U)
;;;1458       {
;;;1459         /* Wait until TXE flag is set */
;;;1460         if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1461         {
;;;1462           /* Disable Address Acknowledge */
;;;1463           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1464   
;;;1465           return HAL_ERROR;
;;;1466         }
;;;1467   
;;;1468         /* Write data to DR */
;;;1469         hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1470   
;;;1471         /* Increment Buffer pointer */
;;;1472         hi2c->pBuffPtr++;
;;;1473   
;;;1474         /* Update counter */
;;;1475         hi2c->XferCount--;
;;;1476         hi2c->XferSize--;
;;;1477   
;;;1478         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1479         {
;;;1480           /* Write data to DR */
;;;1481           hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1482   
;;;1483           /* Increment Buffer pointer */
;;;1484           hi2c->pBuffPtr++;
;;;1485   
;;;1486           /* Update counter */
;;;1487           hi2c->XferCount--;
;;;1488           hi2c->XferSize--;
;;;1489         }
;;;1490       }
;;;1491   
;;;1492       /* Wait until AF flag is set */
;;;1493       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)
;;;1494       {
;;;1495         return HAL_ERROR;
;;;1496       }
;;;1497   
;;;1498       /* Clear AF flag */
;;;1499       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;1500   
;;;1501       /* Disable Address Acknowledge */
;;;1502       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1503   
;;;1504       hi2c->State = HAL_I2C_STATE_READY;
;;;1505       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1506   
;;;1507       /* Process Unlocked */
;;;1508       __HAL_UNLOCK(hi2c);
;;;1509   
;;;1510       return HAL_OK;
;;;1511     }
;;;1512     else
;;;1513     {
;;;1514       return HAL_BUSY;
;;;1515     }
;;;1516   }
000020  e8bd83f8          POP      {r3-r9,pc}
                  |L47.36|
000024  bf00              NOP                            ;1410
000026  f894003c          LDRB     r0,[r4,#0x3c]         ;1410
00002a  2801              CMP      r0,#1                 ;1410
00002c  d101              BNE      |L47.50|
00002e  2002              MOVS     r0,#2                 ;1410
000030  e7f6              B        |L47.32|
                  |L47.50|
000032  2001              MOVS     r0,#1                 ;1410
000034  f884003c          STRB     r0,[r4,#0x3c]         ;1410
000038  bf00              NOP                            ;1410
00003a  6820              LDR      r0,[r4,#0]            ;1413
00003c  6800              LDR      r0,[r0,#0]            ;1413
00003e  f0000001          AND      r0,r0,#1              ;1413
000042  b928              CBNZ     r0,|L47.80|
000044  6820              LDR      r0,[r4,#0]            ;1416
000046  6800              LDR      r0,[r0,#0]            ;1416
000048  f0400001          ORR      r0,r0,#1              ;1416
00004c  6821              LDR      r1,[r4,#0]            ;1416
00004e  6008              STR      r0,[r1,#0]            ;1416
                  |L47.80|
000050  6820              LDR      r0,[r4,#0]            ;1420
000052  6800              LDR      r0,[r0,#0]            ;1420
000054  f4206000          BIC      r0,r0,#0x800          ;1420
000058  6821              LDR      r1,[r4,#0]            ;1420
00005a  6008              STR      r0,[r1,#0]            ;1420
00005c  2021              MOVS     r0,#0x21              ;1422
00005e  f884003d          STRB     r0,[r4,#0x3d]         ;1422
000062  2020              MOVS     r0,#0x20              ;1423
000064  f884003e          STRB     r0,[r4,#0x3e]         ;1423
000068  2000              MOVS     r0,#0                 ;1424
00006a  6420              STR      r0,[r4,#0x40]         ;1424
00006c  6266              STR      r6,[r4,#0x24]         ;1427
00006e  8567              STRH     r7,[r4,#0x2a]         ;1428
000070  8d60              LDRH     r0,[r4,#0x2a]         ;1429
000072  8520              STRH     r0,[r4,#0x28]         ;1429
000074  4845              LDR      r0,|L47.396|
000076  62e0              STR      r0,[r4,#0x2c]         ;1430
000078  6820              LDR      r0,[r4,#0]            ;1433
00007a  6800              LDR      r0,[r0,#0]            ;1433
00007c  f4406080          ORR      r0,r0,#0x400          ;1433
000080  6821              LDR      r1,[r4,#0]            ;1433
000082  6008              STR      r0,[r1,#0]            ;1433
000084  4643              MOV      r3,r8                 ;1436
000086  2200              MOVS     r2,#0                 ;1436
000088  4941              LDR      r1,|L47.400|
00008a  4620              MOV      r0,r4                 ;1436
00008c  9500              STR      r5,[sp,#0]            ;1436
00008e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000092  b108              CBZ      r0,|L47.152|
000094  2001              MOVS     r0,#1                 ;1438
000096  e7c3              B        |L47.32|
                  |L47.152|
000098  bf00              NOP                            ;1442
00009a  2000              MOVS     r0,#0                 ;1442
00009c  9000              STR      r0,[sp,#0]            ;1442
00009e  6820              LDR      r0,[r4,#0]            ;1442
0000a0  6940              LDR      r0,[r0,#0x14]         ;1442
0000a2  9000              STR      r0,[sp,#0]            ;1442
0000a4  6820              LDR      r0,[r4,#0]            ;1442
0000a6  6980              LDR      r0,[r0,#0x18]         ;1442
0000a8  9000              STR      r0,[sp,#0]            ;1442
0000aa  bf00              NOP                            ;1442
0000ac  bf00              NOP                            ;1442
0000ae  6920              LDR      r0,[r4,#0x10]         ;1445
0000b0  f5b04f40          CMP      r0,#0xc000            ;1445
0000b4  d114              BNE      |L47.224|
0000b6  4643              MOV      r3,r8                 ;1448
0000b8  2200              MOVS     r2,#0                 ;1448
0000ba  4935              LDR      r1,|L47.400|
0000bc  4620              MOV      r0,r4                 ;1448
0000be  9500              STR      r5,[sp,#0]            ;1448
0000c0  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000c4  b108              CBZ      r0,|L47.202|
0000c6  2001              MOVS     r0,#1                 ;1450
0000c8  e7aa              B        |L47.32|
                  |L47.202|
0000ca  bf00              NOP                            ;1454
0000cc  2000              MOVS     r0,#0                 ;1454
0000ce  9000              STR      r0,[sp,#0]            ;1454
0000d0  6820              LDR      r0,[r4,#0]            ;1454
0000d2  6940              LDR      r0,[r0,#0x14]         ;1454
0000d4  9000              STR      r0,[sp,#0]            ;1454
0000d6  6820              LDR      r0,[r4,#0]            ;1454
0000d8  6980              LDR      r0,[r0,#0x18]         ;1454
0000da  9000              STR      r0,[sp,#0]            ;1454
0000dc  bf00              NOP                            ;1454
0000de  bf00              NOP                            ;1454
                  |L47.224|
0000e0  e02f              B        |L47.322|
                  |L47.226|
0000e2  462a              MOV      r2,r5                 ;1460
0000e4  4641              MOV      r1,r8                 ;1460
0000e6  4620              MOV      r0,r4                 ;1460
0000e8  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000ec  b140              CBZ      r0,|L47.256|
0000ee  6820              LDR      r0,[r4,#0]            ;1463
0000f0  6800              LDR      r0,[r0,#0]            ;1463
0000f2  f4206080          BIC      r0,r0,#0x400          ;1463
0000f6  6821              LDR      r1,[r4,#0]            ;1463
0000f8  6008              STR      r0,[r1,#0]            ;1463
0000fa  2001              MOVS     r0,#1                 ;1465
0000fc  e790              B        |L47.32|
                  |L47.254|
0000fe  e043              B        |L47.392|
                  |L47.256|
000100  6a60              LDR      r0,[r4,#0x24]         ;1469
000102  7800              LDRB     r0,[r0,#0]            ;1469
000104  6821              LDR      r1,[r4,#0]            ;1469
000106  6108              STR      r0,[r1,#0x10]         ;1469
000108  6a60              LDR      r0,[r4,#0x24]         ;1472
00010a  1c40              ADDS     r0,r0,#1              ;1472
00010c  6260              STR      r0,[r4,#0x24]         ;1472
00010e  8d60              LDRH     r0,[r4,#0x2a]         ;1475
000110  1e40              SUBS     r0,r0,#1              ;1475
000112  8560              STRH     r0,[r4,#0x2a]         ;1475
000114  8d20              LDRH     r0,[r4,#0x28]         ;1476
000116  1e40              SUBS     r0,r0,#1              ;1476
000118  8520              STRH     r0,[r4,#0x28]         ;1476
00011a  6820              LDR      r0,[r4,#0]            ;1478
00011c  6940              LDR      r0,[r0,#0x14]         ;1478
00011e  f3c00080          UBFX     r0,r0,#2,#1           ;1478
000122  b170              CBZ      r0,|L47.322|
000124  8d20              LDRH     r0,[r4,#0x28]         ;1478
000126  b160              CBZ      r0,|L47.322|
000128  6a60              LDR      r0,[r4,#0x24]         ;1481
00012a  7800              LDRB     r0,[r0,#0]            ;1481
00012c  6821              LDR      r1,[r4,#0]            ;1481
00012e  6108              STR      r0,[r1,#0x10]         ;1481
000130  6a60              LDR      r0,[r4,#0x24]         ;1484
000132  1c40              ADDS     r0,r0,#1              ;1484
000134  6260              STR      r0,[r4,#0x24]         ;1484
000136  8d60              LDRH     r0,[r4,#0x2a]         ;1487
000138  1e40              SUBS     r0,r0,#1              ;1487
00013a  8560              STRH     r0,[r4,#0x2a]         ;1487
00013c  8d20              LDRH     r0,[r4,#0x28]         ;1488
00013e  1e40              SUBS     r0,r0,#1              ;1488
000140  8520              STRH     r0,[r4,#0x28]         ;1488
                  |L47.322|
000142  8d20              LDRH     r0,[r4,#0x28]         ;1457
000144  2800              CMP      r0,#0                 ;1457
000146  d1cc              BNE      |L47.226|
000148  4643              MOV      r3,r8                 ;1493
00014a  2200              MOVS     r2,#0                 ;1493
00014c  f44f3182          MOV      r1,#0x10400           ;1493
000150  4620              MOV      r0,r4                 ;1493
000152  9500              STR      r5,[sp,#0]            ;1493
000154  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000158  b108              CBZ      r0,|L47.350|
00015a  2001              MOVS     r0,#1                 ;1495
00015c  e760              B        |L47.32|
                  |L47.350|
00015e  f46f6080          MVN      r0,#0x400             ;1499
000162  6821              LDR      r1,[r4,#0]            ;1499
000164  6148              STR      r0,[r1,#0x14]         ;1499
000166  6820              LDR      r0,[r4,#0]            ;1502
000168  6800              LDR      r0,[r0,#0]            ;1502
00016a  f4206080          BIC      r0,r0,#0x400          ;1502
00016e  6821              LDR      r1,[r4,#0]            ;1502
000170  6008              STR      r0,[r1,#0]            ;1502
000172  2020              MOVS     r0,#0x20              ;1504
000174  f884003d          STRB     r0,[r4,#0x3d]         ;1504
000178  2000              MOVS     r0,#0                 ;1505
00017a  f884003e          STRB     r0,[r4,#0x3e]         ;1505
00017e  bf00              NOP                            ;1508
000180  f884003c          STRB     r0,[r4,#0x3c]         ;1508
000184  bf00              NOP                            ;1508
000186  e74b              B        |L47.32|
                  |L47.392|
000188  2002              MOVS     r0,#2                 ;1514
00018a  e749              B        |L47.32|
;;;1517   
                          ENDP

                  |L47.396|
                          DCD      0xffff0000
                  |L47.400|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_DMA PROC
;;;2250     */
;;;2251   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2252   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2253     HAL_StatusTypeDef dmaxferstatus;
;;;2254   
;;;2255     if (hi2c->State == HAL_I2C_STATE_READY)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2820              CMP      r0,#0x20
000010  d175              BNE      |L48.254|
;;;2256     {
;;;2257       if ((pData == NULL) || (Size == 0U))
000012  b105              CBZ      r5,|L48.22|
000014  b916              CBNZ     r6,|L48.28|
                  |L48.22|
;;;2258       {
;;;2259         return  HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L48.24|
;;;2260       }
;;;2261   
;;;2262       /* Process Locked */
;;;2263       __HAL_LOCK(hi2c);
;;;2264   
;;;2265       /* Check if the I2C is already enabled */
;;;2266       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2267       {
;;;2268         /* Enable I2C peripheral */
;;;2269         __HAL_I2C_ENABLE(hi2c);
;;;2270       }
;;;2271   
;;;2272       /* Disable Pos */
;;;2273       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2274   
;;;2275       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2276       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2277       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2278   
;;;2279       /* Prepare transfer parameters */
;;;2280       hi2c->pBuffPtr    = pData;
;;;2281       hi2c->XferCount   = Size;
;;;2282       hi2c->XferSize    = hi2c->XferCount;
;;;2283       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2284   
;;;2285       if (hi2c->hdmatx != NULL)
;;;2286       {
;;;2287         /* Set the I2C DMA transfer complete callback */
;;;2288         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;2289   
;;;2290         /* Set the DMA error callback */
;;;2291         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;2292   
;;;2293         /* Set the unused DMA callbacks to NULL */
;;;2294         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;2295         hi2c->hdmatx->XferM1CpltCallback = NULL;
;;;2296         hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
;;;2297         hi2c->hdmatx->XferAbortCallback = NULL;
;;;2298   
;;;2299         /* Enable the DMA stream */
;;;2300         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;2301       }
;;;2302       else
;;;2303       {
;;;2304         /* Update I2C state */
;;;2305         hi2c->State     = HAL_I2C_STATE_LISTEN;
;;;2306         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2307   
;;;2308         /* Update I2C error code */
;;;2309         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
;;;2310   
;;;2311         /* Process Unlocked */
;;;2312         __HAL_UNLOCK(hi2c);
;;;2313   
;;;2314         return HAL_ERROR;
;;;2315       }
;;;2316   
;;;2317       if (dmaxferstatus == HAL_OK)
;;;2318       {
;;;2319         /* Enable Address Acknowledge */
;;;2320         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2321   
;;;2322         /* Process Unlocked */
;;;2323         __HAL_UNLOCK(hi2c);
;;;2324   
;;;2325         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2326         to avoid the risk of I2C interrupt handle execution before current
;;;2327         process unlock */
;;;2328         /* Enable EVT and ERR interrupt */
;;;2329         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2330   
;;;2331         /* Enable DMA Request */
;;;2332         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;2333   
;;;2334         return HAL_OK;
;;;2335       }
;;;2336       else
;;;2337       {
;;;2338         /* Update I2C state */
;;;2339         hi2c->State     = HAL_I2C_STATE_READY;
;;;2340         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2341   
;;;2342         /* Update I2C error code */
;;;2343         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2344   
;;;2345         /* Process Unlocked */
;;;2346         __HAL_UNLOCK(hi2c);
;;;2347   
;;;2348         return HAL_ERROR;
;;;2349       }
;;;2350     }
;;;2351     else
;;;2352     {
;;;2353       return HAL_BUSY;
;;;2354     }
;;;2355   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L48.28|
00001c  bf00              NOP                            ;2263
00001e  f894003c          LDRB     r0,[r4,#0x3c]         ;2263
000022  2801              CMP      r0,#1                 ;2263
000024  d101              BNE      |L48.42|
000026  2002              MOVS     r0,#2                 ;2263
000028  e7f6              B        |L48.24|
                  |L48.42|
00002a  2001              MOVS     r0,#1                 ;2263
00002c  f884003c          STRB     r0,[r4,#0x3c]         ;2263
000030  bf00              NOP                            ;2263
000032  6820              LDR      r0,[r4,#0]            ;2266
000034  6800              LDR      r0,[r0,#0]            ;2266
000036  f0000001          AND      r0,r0,#1              ;2266
00003a  b928              CBNZ     r0,|L48.72|
00003c  6820              LDR      r0,[r4,#0]            ;2269
00003e  6800              LDR      r0,[r0,#0]            ;2269
000040  f0400001          ORR      r0,r0,#1              ;2269
000044  6821              LDR      r1,[r4,#0]            ;2269
000046  6008              STR      r0,[r1,#0]            ;2269
                  |L48.72|
000048  6820              LDR      r0,[r4,#0]            ;2273
00004a  6800              LDR      r0,[r0,#0]            ;2273
00004c  f4206000          BIC      r0,r0,#0x800          ;2273
000050  6821              LDR      r1,[r4,#0]            ;2273
000052  6008              STR      r0,[r1,#0]            ;2273
000054  2021              MOVS     r0,#0x21              ;2275
000056  f884003d          STRB     r0,[r4,#0x3d]         ;2275
00005a  2020              MOVS     r0,#0x20              ;2276
00005c  f884003e          STRB     r0,[r4,#0x3e]         ;2276
000060  2000              MOVS     r0,#0                 ;2277
000062  6420              STR      r0,[r4,#0x40]         ;2277
000064  6265              STR      r5,[r4,#0x24]         ;2280
000066  8566              STRH     r6,[r4,#0x2a]         ;2281
000068  8d60              LDRH     r0,[r4,#0x2a]         ;2282
00006a  8520              STRH     r0,[r4,#0x28]         ;2282
00006c  482e              LDR      r0,|L48.296|
00006e  62e0              STR      r0,[r4,#0x2c]         ;2283
000070  6b60              LDR      r0,[r4,#0x34]         ;2285
000072  b1c8              CBZ      r0,|L48.168|
000074  482d              LDR      r0,|L48.300|
000076  6b61              LDR      r1,[r4,#0x34]         ;2288
000078  63c8              STR      r0,[r1,#0x3c]         ;2288
00007a  482d              LDR      r0,|L48.304|
00007c  6b61              LDR      r1,[r4,#0x34]         ;2291
00007e  64c8              STR      r0,[r1,#0x4c]         ;2291
000080  2000              MOVS     r0,#0                 ;2294
000082  6b61              LDR      r1,[r4,#0x34]         ;2294
000084  6408              STR      r0,[r1,#0x40]         ;2294
000086  6b61              LDR      r1,[r4,#0x34]         ;2295
000088  6448              STR      r0,[r1,#0x44]         ;2295
00008a  6b61              LDR      r1,[r4,#0x34]         ;2296
00008c  6488              STR      r0,[r1,#0x48]         ;2296
00008e  6b61              LDR      r1,[r4,#0x34]         ;2297
000090  6508              STR      r0,[r1,#0x50]         ;2297
000092  8d23              LDRH     r3,[r4,#0x28]         ;2300
000094  f8d4c000          LDR      r12,[r4,#0]           ;2300
000098  f10c0210          ADD      r2,r12,#0x10          ;2300
00009c  6a61              LDR      r1,[r4,#0x24]         ;2300
00009e  6b60              LDR      r0,[r4,#0x34]         ;2300
0000a0  f7fffffe          BL       HAL_DMA_Start_IT
0000a4  4607              MOV      r7,r0                 ;2300
0000a6  e010              B        |L48.202|
                  |L48.168|
0000a8  2028              MOVS     r0,#0x28              ;2305
0000aa  f884003d          STRB     r0,[r4,#0x3d]         ;2305
0000ae  2000              MOVS     r0,#0                 ;2306
0000b0  f884003e          STRB     r0,[r4,#0x3e]         ;2306
0000b4  6c20              LDR      r0,[r4,#0x40]         ;2309
0000b6  f0400080          ORR      r0,r0,#0x80           ;2309
0000ba  6420              STR      r0,[r4,#0x40]         ;2309
0000bc  bf00              NOP                            ;2312
0000be  2000              MOVS     r0,#0                 ;2312
0000c0  f884003c          STRB     r0,[r4,#0x3c]         ;2312
0000c4  bf00              NOP                            ;2312
0000c6  2001              MOVS     r0,#1                 ;2314
0000c8  e7a6              B        |L48.24|
                  |L48.202|
0000ca  b9cf              CBNZ     r7,|L48.256|
0000cc  6820              LDR      r0,[r4,#0]            ;2320
0000ce  6800              LDR      r0,[r0,#0]            ;2320
0000d0  f4406080          ORR      r0,r0,#0x400          ;2320
0000d4  6821              LDR      r1,[r4,#0]            ;2320
0000d6  6008              STR      r0,[r1,#0]            ;2320
0000d8  bf00              NOP                            ;2323
0000da  2000              MOVS     r0,#0                 ;2323
0000dc  f884003c          STRB     r0,[r4,#0x3c]         ;2323
0000e0  bf00              NOP                            ;2323
0000e2  6820              LDR      r0,[r4,#0]            ;2329
0000e4  6840              LDR      r0,[r0,#4]            ;2329
0000e6  f4407040          ORR      r0,r0,#0x300          ;2329
0000ea  6821              LDR      r1,[r4,#0]            ;2329
0000ec  6048              STR      r0,[r1,#4]            ;2329
0000ee  6820              LDR      r0,[r4,#0]            ;2332
0000f0  6840              LDR      r0,[r0,#4]            ;2332
0000f2  f4406000          ORR      r0,r0,#0x800          ;2332
0000f6  6821              LDR      r1,[r4,#0]            ;2332
0000f8  6048              STR      r0,[r1,#4]            ;2332
0000fa  2000              MOVS     r0,#0                 ;2334
0000fc  e78c              B        |L48.24|
                  |L48.254|
0000fe  e010              B        |L48.290|
                  |L48.256|
000100  2020              MOVS     r0,#0x20              ;2339
000102  f884003d          STRB     r0,[r4,#0x3d]         ;2339
000106  2000              MOVS     r0,#0                 ;2340
000108  f884003e          STRB     r0,[r4,#0x3e]         ;2340
00010c  6c20              LDR      r0,[r4,#0x40]         ;2343
00010e  f0400010          ORR      r0,r0,#0x10           ;2343
000112  6420              STR      r0,[r4,#0x40]         ;2343
000114  bf00              NOP                            ;2346
000116  2000              MOVS     r0,#0                 ;2346
000118  f884003c          STRB     r0,[r4,#0x3c]         ;2346
00011c  bf00              NOP                            ;2346
00011e  2001              MOVS     r0,#1                 ;2348
000120  e77a              B        |L48.24|
                  |L48.290|
000122  2002              MOVS     r0,#2                 ;2353
000124  e778              B        |L48.24|
;;;2356   
                          ENDP

000126  0000              DCW      0x0000
                  |L48.296|
                          DCD      0xffff0000
                  |L48.300|
                          DCD      I2C_DMAXferCplt
                  |L48.304|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_IT PROC
;;;1810     */
;;;1811   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1812   {
000002  4603              MOV      r3,r0
;;;1813   
;;;1814     if (hi2c->State == HAL_I2C_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2820              CMP      r0,#0x20
00000a  d140              BNE      |L49.142|
;;;1815     {
;;;1816       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L49.16|
00000e  b90a              CBNZ     r2,|L49.20|
                  |L49.16|
;;;1817       {
;;;1818         return  HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L49.18|
;;;1819       }
;;;1820   
;;;1821       /* Process Locked */
;;;1822       __HAL_LOCK(hi2c);
;;;1823   
;;;1824       /* Check if the I2C is already enabled */
;;;1825       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1826       {
;;;1827         /* Enable I2C peripheral */
;;;1828         __HAL_I2C_ENABLE(hi2c);
;;;1829       }
;;;1830   
;;;1831       /* Disable Pos */
;;;1832       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1833   
;;;1834       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1835       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1836       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1837   
;;;1838       /* Prepare transfer parameters */
;;;1839       hi2c->pBuffPtr    = pData;
;;;1840       hi2c->XferCount   = Size;
;;;1841       hi2c->XferSize    = hi2c->XferCount;
;;;1842       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1843   
;;;1844       /* Enable Address Acknowledge */
;;;1845       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1846   
;;;1847       /* Process Unlocked */
;;;1848       __HAL_UNLOCK(hi2c);
;;;1849   
;;;1850       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1851                 to avoid the risk of I2C interrupt handle execution before current
;;;1852                 process unlock */
;;;1853   
;;;1854       /* Enable EVT, BUF and ERR interrupt */
;;;1855       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1856   
;;;1857       return HAL_OK;
;;;1858     }
;;;1859     else
;;;1860     {
;;;1861       return HAL_BUSY;
;;;1862     }
;;;1863   }
000012  bd10              POP      {r4,pc}
                  |L49.20|
000014  bf00              NOP                            ;1822
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;1822
00001a  2801              CMP      r0,#1                 ;1822
00001c  d101              BNE      |L49.34|
00001e  2002              MOVS     r0,#2                 ;1822
000020  e7f7              B        |L49.18|
                  |L49.34|
000022  2001              MOVS     r0,#1                 ;1822
000024  f883003c          STRB     r0,[r3,#0x3c]         ;1822
000028  bf00              NOP                            ;1822
00002a  6818              LDR      r0,[r3,#0]            ;1825
00002c  6800              LDR      r0,[r0,#0]            ;1825
00002e  f0000001          AND      r0,r0,#1              ;1825
000032  b928              CBNZ     r0,|L49.64|
000034  6818              LDR      r0,[r3,#0]            ;1828
000036  6800              LDR      r0,[r0,#0]            ;1828
000038  f0400001          ORR      r0,r0,#1              ;1828
00003c  681c              LDR      r4,[r3,#0]            ;1828
00003e  6020              STR      r0,[r4,#0]            ;1828
                  |L49.64|
000040  6818              LDR      r0,[r3,#0]            ;1832
000042  6800              LDR      r0,[r0,#0]            ;1832
000044  f4206000          BIC      r0,r0,#0x800          ;1832
000048  681c              LDR      r4,[r3,#0]            ;1832
00004a  6020              STR      r0,[r4,#0]            ;1832
00004c  2021              MOVS     r0,#0x21              ;1834
00004e  f883003d          STRB     r0,[r3,#0x3d]         ;1834
000052  2020              MOVS     r0,#0x20              ;1835
000054  f883003e          STRB     r0,[r3,#0x3e]         ;1835
000058  2000              MOVS     r0,#0                 ;1836
00005a  6418              STR      r0,[r3,#0x40]         ;1836
00005c  6259              STR      r1,[r3,#0x24]         ;1839
00005e  855a              STRH     r2,[r3,#0x2a]         ;1840
000060  8d58              LDRH     r0,[r3,#0x2a]         ;1841
000062  8518              STRH     r0,[r3,#0x28]         ;1841
000064  480b              LDR      r0,|L49.148|
000066  62d8              STR      r0,[r3,#0x2c]         ;1842
000068  6818              LDR      r0,[r3,#0]            ;1845
00006a  6800              LDR      r0,[r0,#0]            ;1845
00006c  f4406080          ORR      r0,r0,#0x400          ;1845
000070  681c              LDR      r4,[r3,#0]            ;1845
000072  6020              STR      r0,[r4,#0]            ;1845
000074  bf00              NOP                            ;1848
000076  2000              MOVS     r0,#0                 ;1848
000078  f883003c          STRB     r0,[r3,#0x3c]         ;1848
00007c  bf00              NOP                            ;1848
00007e  6818              LDR      r0,[r3,#0]            ;1855
000080  6840              LDR      r0,[r0,#4]            ;1855
000082  f44060e0          ORR      r0,r0,#0x700          ;1855
000086  681c              LDR      r4,[r3,#0]            ;1855
000088  6060              STR      r0,[r4,#4]            ;1855
00008a  2000              MOVS     r0,#0                 ;1857
00008c  e7c1              B        |L49.18|
                  |L49.142|
00008e  2002              MOVS     r0,#2                 ;1861
000090  e7bf              B        |L49.18|
;;;1864   
                          ENDP

000092  0000              DCW      0x0000
                  |L49.148|
                          DCD      0xffff0000

                          AREA ||i.I2C_ConvertOtherXferOptions||, CODE, READONLY, ALIGN=1

                  I2C_ConvertOtherXferOptions PROC
;;;7487     */
;;;7488   static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
000000  6ac1              LDR      r1,[r0,#0x2c]
;;;7489   {
;;;7490     /* if user set XferOptions to I2C_OTHER_FRAME            */
;;;7491     /* it request implicitly to generate a restart condition */
;;;7492     /* set XferOptions to I2C_FIRST_FRAME                    */
;;;7493     if (hi2c->XferOptions == I2C_OTHER_FRAME)
000002  f5b10f2a          CMP      r1,#0xaa0000
000006  d102              BNE      |L50.14|
;;;7494     {
;;;7495       hi2c->XferOptions = I2C_FIRST_FRAME;
000008  2101              MOVS     r1,#1
00000a  62c1              STR      r1,[r0,#0x2c]
00000c  e005              B        |L50.26|
                  |L50.14|
;;;7496     }
;;;7497     /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
;;;7498     /* it request implicitly to generate a restart condition    */
;;;7499     /* then generate a stop condition at the end of transfer    */
;;;7500     /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
;;;7501     else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
00000e  6ac1              LDR      r1,[r0,#0x2c]
000010  f1b14f2a          CMP      r1,#0xaa000000
000014  d101              BNE      |L50.26|
;;;7502     {
;;;7503       hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
000016  2108              MOVS     r1,#8
000018  62c1              STR      r1,[r0,#0x2c]
                  |L50.26|
;;;7504     }
;;;7505     else
;;;7506     {
;;;7507       /* Nothing to do */
;;;7508     }
;;;7509   }
00001a  4770              BX       lr
;;;7510   
                          ENDP


                          AREA ||i.I2C_DMAAbort||, CODE, READONLY, ALIGN=2

                  I2C_DMAAbort PROC
;;;7091     */
;;;7092   static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;7093   {
000002  4605              MOV      r5,r0
;;;7094     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;7095     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
000008  6bac              LDR      r4,[r5,#0x38]
;;;7096   
;;;7097     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;7098     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
00000a  f894603d          LDRB     r6,[r4,#0x3d]
;;;7099   
;;;7100     /* During abort treatment, check that there is no pending STOP request */
;;;7101     /* Wait until STOP flag is reset */
;;;7102     count = I2C_TIMEOUT_FLAG * (SystemCoreClock / 25U / 1000U);
00000e  4839              LDR      r0,|L51.244|
000010  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000012  2119              MOVS     r1,#0x19
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  f44f717a          MOV      r1,#0x3e8
00001c  fbb0f0f1          UDIV     r0,r0,r1
000020  ebc000c0          RSB      r0,r0,r0,LSL #3
000024  eb000080          ADD      r0,r0,r0,LSL #2
000028  9000              STR      r0,[sp,#0]
;;;7103     do
00002a  bf00              NOP      
                  |L51.44|
;;;7104     {
;;;7105       if (count == 0U)
00002c  9800              LDR      r0,[sp,#0]
00002e  b920              CBNZ     r0,|L51.58|
;;;7106       {
;;;7107         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
000030  6c20              LDR      r0,[r4,#0x40]
000032  f0400020          ORR      r0,r0,#0x20
000036  6420              STR      r0,[r4,#0x40]
;;;7108         break;
000038  e009              B        |L51.78|
                  |L51.58|
;;;7109       }
;;;7110       count--;
00003a  9800              LDR      r0,[sp,#0]
00003c  1e40              SUBS     r0,r0,#1
00003e  9000              STR      r0,[sp,#0]
;;;7111     }
;;;7112     while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
000040  6820              LDR      r0,[r4,#0]
000042  6800              LDR      r0,[r0,#0]
000044  f4007000          AND      r0,r0,#0x200
000048  f5b07f00          CMP      r0,#0x200
00004c  d0ee              BEQ      |L51.44|
                  |L51.78|
00004e  bf00              NOP                            ;7108
;;;7113   
;;;7114     /* Clear Complete callback */
;;;7115     if (hi2c->hdmatx != NULL)
000050  6b60              LDR      r0,[r4,#0x34]
000052  b110              CBZ      r0,|L51.90|
;;;7116     {
;;;7117       hi2c->hdmatx->XferCpltCallback = NULL;
000054  2000              MOVS     r0,#0
000056  6b61              LDR      r1,[r4,#0x34]
000058  63c8              STR      r0,[r1,#0x3c]
                  |L51.90|
;;;7118     }
;;;7119     if (hi2c->hdmarx != NULL)
00005a  6ba0              LDR      r0,[r4,#0x38]
00005c  b110              CBZ      r0,|L51.100|
;;;7120     {
;;;7121       hi2c->hdmarx->XferCpltCallback = NULL;
00005e  2000              MOVS     r0,#0
000060  6ba1              LDR      r1,[r4,#0x38]
000062  63c8              STR      r0,[r1,#0x3c]
                  |L51.100|
;;;7122     }
;;;7123   
;;;7124     /* Disable Acknowledge */
;;;7125     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000064  6820              LDR      r0,[r4,#0]
000066  6800              LDR      r0,[r0,#0]
000068  f4206080          BIC      r0,r0,#0x400
00006c  6821              LDR      r1,[r4,#0]
00006e  6008              STR      r0,[r1,#0]
;;;7126   
;;;7127     hi2c->XferCount = 0U;
000070  2000              MOVS     r0,#0
000072  8560              STRH     r0,[r4,#0x2a]
;;;7128   
;;;7129     /* Reset XferAbortCallback */
;;;7130     if (hi2c->hdmatx != NULL)
000074  6b60              LDR      r0,[r4,#0x34]
000076  b110              CBZ      r0,|L51.126|
;;;7131     {
;;;7132       hi2c->hdmatx->XferAbortCallback = NULL;
000078  2000              MOVS     r0,#0
00007a  6b61              LDR      r1,[r4,#0x34]
00007c  6508              STR      r0,[r1,#0x50]
                  |L51.126|
;;;7133     }
;;;7134     if (hi2c->hdmarx != NULL)
00007e  6ba0              LDR      r0,[r4,#0x38]
000080  b110              CBZ      r0,|L51.136|
;;;7135     {
;;;7136       hi2c->hdmarx->XferAbortCallback = NULL;
000082  2000              MOVS     r0,#0
000084  6ba1              LDR      r1,[r4,#0x38]
000086  6508              STR      r0,[r1,#0x50]
                  |L51.136|
;;;7137     }
;;;7138   
;;;7139     /* Disable I2C peripheral to prevent dummy data in buffer */
;;;7140     __HAL_I2C_DISABLE(hi2c);
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  f0200001          BIC      r0,r0,#1
000090  6821              LDR      r1,[r4,#0]
000092  6008              STR      r0,[r1,#0]
;;;7141   
;;;7142     /* Check if come from abort from user */
;;;7143     if (hi2c->State == HAL_I2C_STATE_ABORT)
000094  f894003d          LDRB     r0,[r4,#0x3d]
000098  2860              CMP      r0,#0x60
00009a  d10a              BNE      |L51.178|
;;;7144     {
;;;7145       hi2c->State         = HAL_I2C_STATE_READY;
00009c  2020              MOVS     r0,#0x20
00009e  f884003d          STRB     r0,[r4,#0x3d]
;;;7146       hi2c->Mode          = HAL_I2C_MODE_NONE;
0000a2  2000              MOVS     r0,#0
0000a4  f884003e          STRB     r0,[r4,#0x3e]
;;;7147       hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
0000a8  6420              STR      r0,[r4,#0x40]
;;;7148   
;;;7149       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;7150   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;7151       hi2c->AbortCpltCallback(hi2c);
;;;7152   #else
;;;7153       HAL_I2C_AbortCpltCallback(hi2c);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       HAL_I2C_AbortCpltCallback
0000b0  e01e              B        |L51.240|
                  |L51.178|
;;;7154   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;7155     }
;;;7156     else
;;;7157     {
;;;7158       if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
0000b2  f0060028          AND      r0,r6,#0x28
0000b6  2828              CMP      r0,#0x28
0000b8  d111              BNE      |L51.222|
;;;7159       {
;;;7160         /* Renable I2C peripheral */
;;;7161         __HAL_I2C_ENABLE(hi2c);
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6800              LDR      r0,[r0,#0]
0000be  f0400001          ORR      r0,r0,#1
0000c2  6821              LDR      r1,[r4,#0]
0000c4  6008              STR      r0,[r1,#0]
;;;7162   
;;;7163         /* Enable Acknowledge */
;;;7164         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0000c6  6820              LDR      r0,[r4,#0]
0000c8  6800              LDR      r0,[r0,#0]
0000ca  f4406080          ORR      r0,r0,#0x400
0000ce  6821              LDR      r1,[r4,#0]
0000d0  6008              STR      r0,[r1,#0]
;;;7165   
;;;7166         /* keep HAL_I2C_STATE_LISTEN */
;;;7167         hi2c->PreviousState = I2C_STATE_NONE;
0000d2  2000              MOVS     r0,#0
0000d4  6320              STR      r0,[r4,#0x30]
;;;7168         hi2c->State = HAL_I2C_STATE_LISTEN;
0000d6  2028              MOVS     r0,#0x28
0000d8  f884003d          STRB     r0,[r4,#0x3d]
0000dc  e005              B        |L51.234|
                  |L51.222|
;;;7169       }
;;;7170       else
;;;7171       {
;;;7172         hi2c->State = HAL_I2C_STATE_READY;
0000de  2020              MOVS     r0,#0x20
0000e0  f884003d          STRB     r0,[r4,#0x3d]
;;;7173         hi2c->Mode = HAL_I2C_MODE_NONE;
0000e4  2000              MOVS     r0,#0
0000e6  f884003e          STRB     r0,[r4,#0x3e]
                  |L51.234|
;;;7174       }
;;;7175   
;;;7176       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;7177   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;7178       hi2c->ErrorCallback(hi2c);
;;;7179   #else
;;;7180       HAL_I2C_ErrorCallback(hi2c);
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L51.240|
;;;7181   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;7182     }
;;;7183   }
0000f0  bdf8              POP      {r3-r7,pc}
;;;7184   
                          ENDP

0000f2  0000              DCW      0x0000
                  |L51.244|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_DMAError||, CODE, READONLY, ALIGN=1

                  I2C_DMAError PROC
;;;7050     */
;;;7051   static void I2C_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;7052   {
000002  4605              MOV      r5,r0
;;;7053     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;7054   
;;;7055     /* Clear Complete callback */
;;;7056     if (hi2c->hdmatx != NULL)
000006  6b60              LDR      r0,[r4,#0x34]
000008  b110              CBZ      r0,|L52.16|
;;;7057     {
;;;7058       hi2c->hdmatx->XferCpltCallback = NULL;
00000a  2000              MOVS     r0,#0
00000c  6b61              LDR      r1,[r4,#0x34]
00000e  63c8              STR      r0,[r1,#0x3c]
                  |L52.16|
;;;7059     }
;;;7060     if (hi2c->hdmarx != NULL)
000010  6ba0              LDR      r0,[r4,#0x38]
000012  b110              CBZ      r0,|L52.26|
;;;7061     {
;;;7062       hi2c->hdmarx->XferCpltCallback = NULL;
000014  2000              MOVS     r0,#0
000016  6ba1              LDR      r1,[r4,#0x38]
000018  63c8              STR      r0,[r1,#0x3c]
                  |L52.26|
;;;7063     }
;;;7064   
;;;7065     /* Ignore DMA FIFO error */
;;;7066     if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       HAL_DMA_GetError
000020  2802              CMP      r0,#2
000022  d014              BEQ      |L52.78|
;;;7067     {
;;;7068       /* Disable Acknowledge */
;;;7069       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
;;;7070   
;;;7071       hi2c->XferCount = 0U;
000030  2000              MOVS     r0,#0
000032  8560              STRH     r0,[r4,#0x2a]
;;;7072   
;;;7073       hi2c->State = HAL_I2C_STATE_READY;
000034  2020              MOVS     r0,#0x20
000036  f884003d          STRB     r0,[r4,#0x3d]
;;;7074       hi2c->Mode = HAL_I2C_MODE_NONE;
00003a  2000              MOVS     r0,#0
00003c  f884003e          STRB     r0,[r4,#0x3e]
;;;7075   
;;;7076       hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
000040  6c20              LDR      r0,[r4,#0x40]
000042  f0400010          ORR      r0,r0,#0x10
000046  6420              STR      r0,[r4,#0x40]
;;;7077   
;;;7078   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;7079       hi2c->ErrorCallback(hi2c);
;;;7080   #else
;;;7081       HAL_I2C_ErrorCallback(hi2c);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L52.78|
;;;7082   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;7083     }
;;;7084   }
00004e  bd70              POP      {r4-r6,pc}
;;;7085   
                          ENDP


                          AREA ||i.I2C_DMAXferCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAXferCplt PROC
;;;6912     */
;;;6913   static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6914   {
000004  4607              MOV      r7,r0
;;;6915     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
000006  6bbc              LDR      r4,[r7,#0x38]
;;;6916   
;;;6917     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6918     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000008  f894503d          LDRB     r5,[r4,#0x3d]
;;;6919     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
00000c  f894803e          LDRB     r8,[r4,#0x3e]
;;;6920     uint32_t CurrentXferOptions       = hi2c->XferOptions;
000010  6ae6              LDR      r6,[r4,#0x2c]
;;;6921   
;;;6922     /* Disable EVT and ERR interrupt */
;;;6923     __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000012  6820              LDR      r0,[r4,#0]
000014  6840              LDR      r0,[r0,#4]
000016  f4207040          BIC      r0,r0,#0x300
00001a  6821              LDR      r1,[r4,#0]
00001c  6048              STR      r0,[r1,#4]
;;;6924   
;;;6925     /* Clear Complete callback */
;;;6926     if (hi2c->hdmatx != NULL)
00001e  6b60              LDR      r0,[r4,#0x34]
000020  b110              CBZ      r0,|L53.40|
;;;6927     {
;;;6928       hi2c->hdmatx->XferCpltCallback = NULL;
000022  2000              MOVS     r0,#0
000024  6b61              LDR      r1,[r4,#0x34]
000026  63c8              STR      r0,[r1,#0x3c]
                  |L53.40|
;;;6929     }
;;;6930     if (hi2c->hdmarx != NULL)
000028  6ba0              LDR      r0,[r4,#0x38]
00002a  b110              CBZ      r0,|L53.50|
;;;6931     {
;;;6932       hi2c->hdmarx->XferCpltCallback = NULL;
00002c  2000              MOVS     r0,#0
00002e  6ba1              LDR      r1,[r4,#0x38]
000030  63c8              STR      r0,[r1,#0x3c]
                  |L53.50|
;;;6933     }
;;;6934   
;;;6935     if ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_TX) == (uint32_t)HAL_I2C_STATE_BUSY_TX) || ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_RX) == (uint32_t)HAL_I2C_STATE_BUSY_RX) && (CurrentMode == HAL_I2C_MODE_SLAVE)))
000032  f0050021          AND      r0,r5,#0x21
000036  2821              CMP      r0,#0x21
000038  d006              BEQ      |L53.72|
00003a  f0050022          AND      r0,r5,#0x22
00003e  2822              CMP      r0,#0x22
000040  d126              BNE      |L53.144|
000042  f1b80f20          CMP      r8,#0x20
000046  d123              BNE      |L53.144|
                  |L53.72|
;;;6936     {
;;;6937       /* Disable DMA Request */
;;;6938       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000048  6820              LDR      r0,[r4,#0]
00004a  6840              LDR      r0,[r0,#4]
00004c  f4206000          BIC      r0,r0,#0x800
000050  6821              LDR      r1,[r4,#0]
000052  6048              STR      r0,[r1,#4]
;;;6939   
;;;6940       hi2c->XferCount = 0U;
000054  2000              MOVS     r0,#0
000056  8560              STRH     r0,[r4,#0x2a]
;;;6941   
;;;6942       if (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN)
000058  2d29              CMP      r5,#0x29
00005a  d108              BNE      |L53.110|
;;;6943       {
;;;6944         /* Set state at HAL_I2C_STATE_LISTEN */
;;;6945         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
00005c  2021              MOVS     r0,#0x21
00005e  6320              STR      r0,[r4,#0x30]
;;;6946         hi2c->State = HAL_I2C_STATE_LISTEN;
000060  2028              MOVS     r0,#0x28
000062  f884003d          STRB     r0,[r4,#0x3d]
;;;6947   
;;;6948         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6949   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6950         hi2c->SlaveTxCpltCallback(hi2c);
;;;6951   #else
;;;6952         HAL_I2C_SlaveTxCpltCallback(hi2c);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
00006c  e009              B        |L53.130|
                  |L53.110|
;;;6953   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6954       }
;;;6955       else if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
00006e  2d2a              CMP      r5,#0x2a
000070  d107              BNE      |L53.130|
;;;6956       {
;;;6957         /* Set state at HAL_I2C_STATE_LISTEN */
;;;6958         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000072  2022              MOVS     r0,#0x22
000074  6320              STR      r0,[r4,#0x30]
;;;6959         hi2c->State = HAL_I2C_STATE_LISTEN;
000076  2028              MOVS     r0,#0x28
000078  f884003d          STRB     r0,[r4,#0x3d]
;;;6960   
;;;6961         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6962   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6963         hi2c->SlaveRxCpltCallback(hi2c);
;;;6964   #else
;;;6965         HAL_I2C_SlaveRxCpltCallback(hi2c);
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L53.130|
;;;6966   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6967       }
;;;6968       else
;;;6969       {
;;;6970         /* Do nothing */
;;;6971       }
;;;6972   
;;;6973       /* Enable EVT and ERR interrupt to treat end of transfer in IRQ handler */
;;;6974       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000082  6820              LDR      r0,[r4,#0]
000084  6840              LDR      r0,[r0,#4]
000086  f4407040          ORR      r0,r0,#0x300
00008a  6821              LDR      r1,[r4,#0]
00008c  6048              STR      r0,[r1,#4]
00008e  e04d              B        |L53.300|
                  |L53.144|
;;;6975     }
;;;6976     /* Check current Mode, in case of treatment DMA handler have been preempted by a prior interrupt */
;;;6977     else if (hi2c->Mode != HAL_I2C_MODE_NONE)
000090  f894003e          LDRB     r0,[r4,#0x3e]
000094  2800              CMP      r0,#0
000096  d049              BEQ      |L53.300|
;;;6978     {
;;;6979       if (hi2c->XferCount == (uint16_t)1)
000098  8d60              LDRH     r0,[r4,#0x2a]
00009a  2801              CMP      r0,#1
00009c  d105              BNE      |L53.170|
;;;6980       {
;;;6981         /* Disable Acknowledge */
;;;6982         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00009e  6820              LDR      r0,[r4,#0]
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f4206080          BIC      r0,r0,#0x400
0000a6  6821              LDR      r1,[r4,#0]
0000a8  6008              STR      r0,[r1,#0]
                  |L53.170|
;;;6983       }
;;;6984   
;;;6985       /* Disable EVT and ERR interrupt */
;;;6986       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
0000aa  6820              LDR      r0,[r4,#0]
0000ac  6840              LDR      r0,[r0,#4]
0000ae  f4207040          BIC      r0,r0,#0x300
0000b2  6821              LDR      r1,[r4,#0]
0000b4  6048              STR      r0,[r1,#4]
;;;6987   
;;;6988       /* Prepare next transfer or stop current transfer */
;;;6989       if ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_OTHER_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME))
0000b6  f5163f80          CMN      r6,#0x10000
0000ba  d006              BEQ      |L53.202|
0000bc  2e08              CMP      r6,#8
0000be  d004              BEQ      |L53.202|
0000c0  f1b64f2a          CMP      r6,#0xaa000000
0000c4  d001              BEQ      |L53.202|
0000c6  2e20              CMP      r6,#0x20
0000c8  d105              BNE      |L53.214|
                  |L53.202|
;;;6990       {
;;;6991         /* Generate Stop */
;;;6992         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6800              LDR      r0,[r0,#0]
0000ce  f4407000          ORR      r0,r0,#0x200
0000d2  6821              LDR      r1,[r4,#0]
0000d4  6008              STR      r0,[r1,#0]
                  |L53.214|
;;;6993       }
;;;6994   
;;;6995       /* Disable Last DMA */
;;;6996       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
0000d6  6820              LDR      r0,[r4,#0]
0000d8  6840              LDR      r0,[r0,#4]
0000da  f4205080          BIC      r0,r0,#0x1000
0000de  6821              LDR      r1,[r4,#0]
0000e0  6048              STR      r0,[r1,#4]
;;;6997   
;;;6998       /* Disable DMA Request */
;;;6999       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
0000e2  6820              LDR      r0,[r4,#0]
0000e4  6840              LDR      r0,[r0,#4]
0000e6  f4206000          BIC      r0,r0,#0x800
0000ea  6821              LDR      r1,[r4,#0]
0000ec  6048              STR      r0,[r1,#4]
;;;7000   
;;;7001       hi2c->XferCount = 0U;
0000ee  2000              MOVS     r0,#0
0000f0  8560              STRH     r0,[r4,#0x2a]
;;;7002   
;;;7003       /* Check if Errors has been detected during transfer */
;;;7004       if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
0000f2  6c20              LDR      r0,[r4,#0x40]
0000f4  b118              CBZ      r0,|L53.254|
;;;7005       {
;;;7006   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;7007         hi2c->ErrorCallback(hi2c);
;;;7008   #else
;;;7009         HAL_I2C_ErrorCallback(hi2c);
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       HAL_I2C_ErrorCallback
0000fc  e016              B        |L53.300|
                  |L53.254|
;;;7010   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;7011       }
;;;7012       else
;;;7013       {
;;;7014         hi2c->State = HAL_I2C_STATE_READY;
0000fe  2020              MOVS     r0,#0x20
000100  f884003d          STRB     r0,[r4,#0x3d]
;;;7015   
;;;7016         if (hi2c->Mode == HAL_I2C_MODE_MEM)
000104  f894003e          LDRB     r0,[r4,#0x3e]
000108  2840              CMP      r0,#0x40
00010a  d107              BNE      |L53.284|
;;;7017         {
;;;7018           hi2c->Mode = HAL_I2C_MODE_NONE;
00010c  2000              MOVS     r0,#0
00010e  f884003e          STRB     r0,[r4,#0x3e]
;;;7019           hi2c->PreviousState = I2C_STATE_NONE;
000112  6320              STR      r0,[r4,#0x30]
;;;7020   
;;;7021   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;7022           hi2c->MemRxCpltCallback(hi2c);
;;;7023   #else
;;;7024           HAL_I2C_MemRxCpltCallback(hi2c);
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
00011a  e007              B        |L53.300|
                  |L53.284|
;;;7025   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;7026         }
;;;7027         else
;;;7028         {
;;;7029           hi2c->Mode = HAL_I2C_MODE_NONE;
00011c  2000              MOVS     r0,#0
00011e  f884003e          STRB     r0,[r4,#0x3e]
;;;7030           hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000122  2012              MOVS     r0,#0x12
000124  6320              STR      r0,[r4,#0x30]
;;;7031   
;;;7032   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;7033           hi2c->MasterRxCpltCallback(hi2c);
;;;7034   #else
;;;7035           HAL_I2C_MasterRxCpltCallback(hi2c);
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
                  |L53.300|
;;;7036   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;7037         }
;;;7038       }
;;;7039     }
;;;7040     else
;;;7041     {
;;;7042       /* Do nothing */
;;;7043     }
;;;7044   }
00012c  e8bd81f0          POP      {r4-r8,pc}
;;;7045   
                          ENDP


                          AREA ||i.I2C_ITError||, CODE, READONLY, ALIGN=2

                  I2C_ITError PROC
;;;6387     */
;;;6388   static void I2C_ITError(I2C_HandleTypeDef *hi2c)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6389   {
000004  4604              MOV      r4,r0
;;;6390     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6391     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000006  f894603d          LDRB     r6,[r4,#0x3d]
;;;6392     HAL_I2C_ModeTypeDef CurrentMode = hi2c->Mode;
00000a  f894703e          LDRB     r7,[r4,#0x3e]
;;;6393     uint32_t CurrentError;
;;;6394   
;;;6395     if (((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM)) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
00000e  2f10              CMP      r7,#0x10
000010  d001              BEQ      |L54.22|
000012  2f40              CMP      r7,#0x40
000014  d107              BNE      |L54.38|
                  |L54.22|
000016  2e22              CMP      r6,#0x22
000018  d105              BNE      |L54.38|
;;;6396     {
;;;6397       /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
;;;6398       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
00001a  6820              LDR      r0,[r4,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f4206000          BIC      r0,r0,#0x800
000022  6821              LDR      r1,[r4,#0]
000024  6008              STR      r0,[r1,#0]
                  |L54.38|
;;;6399     }
;;;6400   
;;;6401     if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000026  f0060028          AND      r0,r6,#0x28
00002a  2828              CMP      r0,#0x28
00002c  d105              BNE      |L54.58|
;;;6402     {
;;;6403       /* keep HAL_I2C_STATE_LISTEN */
;;;6404       hi2c->PreviousState = I2C_STATE_NONE;
00002e  2000              MOVS     r0,#0
000030  6320              STR      r0,[r4,#0x30]
;;;6405       hi2c->State = HAL_I2C_STATE_LISTEN;
000032  2028              MOVS     r0,#0x28
000034  f884003d          STRB     r0,[r4,#0x3d]
000038  e010              B        |L54.92|
                  |L54.58|
;;;6406     }
;;;6407     else
;;;6408     {
;;;6409       /* If state is an abort treatment on going, don't change state */
;;;6410       /* This change will be do later */
;;;6411       if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
00003a  6820              LDR      r0,[r4,#0]
00003c  6840              LDR      r0,[r0,#4]
00003e  f4006000          AND      r0,r0,#0x800
000042  f5b06f00          CMP      r0,#0x800
000046  d007              BEQ      |L54.88|
000048  2e60              CMP      r6,#0x60
00004a  d005              BEQ      |L54.88|
;;;6412       {
;;;6413         hi2c->State = HAL_I2C_STATE_READY;
00004c  2020              MOVS     r0,#0x20
00004e  f884003d          STRB     r0,[r4,#0x3d]
;;;6414         hi2c->Mode = HAL_I2C_MODE_NONE;
000052  2000              MOVS     r0,#0
000054  f884003e          STRB     r0,[r4,#0x3e]
                  |L54.88|
;;;6415       }
;;;6416       hi2c->PreviousState = I2C_STATE_NONE;
000058  2000              MOVS     r0,#0
00005a  6320              STR      r0,[r4,#0x30]
                  |L54.92|
;;;6417     }
;;;6418   
;;;6419     /* Abort DMA transfer */
;;;6420     if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
00005c  6820              LDR      r0,[r4,#0]
00005e  6840              LDR      r0,[r0,#4]
000060  f4006000          AND      r0,r0,#0x800
000064  f5b06f00          CMP      r0,#0x800
000068  d140              BNE      |L54.236|
;;;6421     {
;;;6422       hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
00006a  6820              LDR      r0,[r4,#0]
00006c  6840              LDR      r0,[r0,#4]
00006e  f4206000          BIC      r0,r0,#0x800
000072  6821              LDR      r1,[r4,#0]
000074  6048              STR      r0,[r1,#4]
;;;6423   
;;;6424       if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
000076  6b60              LDR      r0,[r4,#0x34]
000078  f8900035          LDRB     r0,[r0,#0x35]
00007c  2801              CMP      r0,#1
00007e  d014              BEQ      |L54.170|
;;;6425       {
;;;6426         /* Set the DMA Abort callback :
;;;6427         will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6428         hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
000080  4848              LDR      r0,|L54.420|
000082  6b61              LDR      r1,[r4,#0x34]
000084  6508              STR      r0,[r1,#0x50]
;;;6429   
;;;6430         if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
000086  6b60              LDR      r0,[r4,#0x34]
000088  f7fffffe          BL       HAL_DMA_Abort_IT
00008c  2800              CMP      r0,#0
00008e  d05b              BEQ      |L54.328|
;;;6431         {
;;;6432           /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6433           __HAL_I2C_DISABLE(hi2c);
000090  6820              LDR      r0,[r4,#0]
000092  6800              LDR      r0,[r0,#0]
000094  f0200001          BIC      r0,r0,#1
000098  6821              LDR      r1,[r4,#0]
00009a  6008              STR      r0,[r1,#0]
;;;6434   
;;;6435           hi2c->State = HAL_I2C_STATE_READY;
00009c  2020              MOVS     r0,#0x20
00009e  f884003d          STRB     r0,[r4,#0x3d]
;;;6436   
;;;6437           /* Call Directly XferAbortCallback function in case of error */
;;;6438           hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
0000a2  6b60              LDR      r0,[r4,#0x34]
0000a4  6d01              LDR      r1,[r0,#0x50]
0000a6  4788              BLX      r1
0000a8  e04e              B        |L54.328|
                  |L54.170|
;;;6439         }
;;;6440       }
;;;6441       else
;;;6442       {
;;;6443         /* Set the DMA Abort callback :
;;;6444         will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6445         hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
0000aa  483e              LDR      r0,|L54.420|
0000ac  6ba1              LDR      r1,[r4,#0x38]
0000ae  6508              STR      r0,[r1,#0x50]
;;;6446   
;;;6447         if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
0000b0  6ba0              LDR      r0,[r4,#0x38]
0000b2  f7fffffe          BL       HAL_DMA_Abort_IT
0000b6  2800              CMP      r0,#0
0000b8  d046              BEQ      |L54.328|
;;;6448         {
;;;6449           /* Store Last receive data if any */
;;;6450           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6940              LDR      r0,[r0,#0x14]
0000be  f3c01080          UBFX     r0,r0,#6,#1
0000c2  b130              CBZ      r0,|L54.210|
;;;6451           {
;;;6452             /* Read data from DR */
;;;6453             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000c4  6820              LDR      r0,[r4,#0]
0000c6  6900              LDR      r0,[r0,#0x10]
0000c8  6a61              LDR      r1,[r4,#0x24]
0000ca  7008              STRB     r0,[r1,#0]
;;;6454   
;;;6455             /* Increment Buffer pointer */
;;;6456             hi2c->pBuffPtr++;
0000cc  6a60              LDR      r0,[r4,#0x24]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  6260              STR      r0,[r4,#0x24]
                  |L54.210|
;;;6457           }
;;;6458   
;;;6459           /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6460           __HAL_I2C_DISABLE(hi2c);
0000d2  6820              LDR      r0,[r4,#0]
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f0200001          BIC      r0,r0,#1
0000da  6821              LDR      r1,[r4,#0]
0000dc  6008              STR      r0,[r1,#0]
;;;6461   
;;;6462           hi2c->State = HAL_I2C_STATE_READY;
0000de  2020              MOVS     r0,#0x20
0000e0  f884003d          STRB     r0,[r4,#0x3d]
;;;6463   
;;;6464           /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
;;;6465           hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
0000e4  6ba0              LDR      r0,[r4,#0x38]
0000e6  6d01              LDR      r1,[r0,#0x50]
0000e8  4788              BLX      r1
0000ea  e02d              B        |L54.328|
                  |L54.236|
;;;6466         }
;;;6467       }
;;;6468     }
;;;6469     else if (hi2c->State == HAL_I2C_STATE_ABORT)
0000ec  f894003d          LDRB     r0,[r4,#0x3d]
0000f0  2860              CMP      r0,#0x60
0000f2  d11a              BNE      |L54.298|
;;;6470     {
;;;6471       hi2c->State = HAL_I2C_STATE_READY;
0000f4  2020              MOVS     r0,#0x20
0000f6  f884003d          STRB     r0,[r4,#0x3d]
;;;6472       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
0000fa  2000              MOVS     r0,#0
0000fc  6420              STR      r0,[r4,#0x40]
;;;6473   
;;;6474       /* Store Last receive data if any */
;;;6475       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000fe  6820              LDR      r0,[r4,#0]
000100  6940              LDR      r0,[r0,#0x14]
000102  f3c01080          UBFX     r0,r0,#6,#1
000106  b130              CBZ      r0,|L54.278|
;;;6476       {
;;;6477         /* Read data from DR */
;;;6478         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000108  6820              LDR      r0,[r4,#0]
00010a  6900              LDR      r0,[r0,#0x10]
00010c  6a61              LDR      r1,[r4,#0x24]
00010e  7008              STRB     r0,[r1,#0]
;;;6479   
;;;6480         /* Increment Buffer pointer */
;;;6481         hi2c->pBuffPtr++;
000110  6a60              LDR      r0,[r4,#0x24]
000112  1c40              ADDS     r0,r0,#1
000114  6260              STR      r0,[r4,#0x24]
                  |L54.278|
;;;6482       }
;;;6483   
;;;6484       /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6485       __HAL_I2C_DISABLE(hi2c);
000116  6820              LDR      r0,[r4,#0]
000118  6800              LDR      r0,[r0,#0]
00011a  f0200001          BIC      r0,r0,#1
00011e  6821              LDR      r1,[r4,#0]
000120  6008              STR      r0,[r1,#0]
;;;6486   
;;;6487       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6488   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6489       hi2c->AbortCpltCallback(hi2c);
;;;6490   #else
;;;6491       HAL_I2C_AbortCpltCallback(hi2c);
000122  4620              MOV      r0,r4
000124  f7fffffe          BL       HAL_I2C_AbortCpltCallback
000128  e00e              B        |L54.328|
                  |L54.298|
;;;6492   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6493     }
;;;6494     else
;;;6495     {
;;;6496       /* Store Last receive data if any */
;;;6497       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
00012a  6820              LDR      r0,[r4,#0]
00012c  6940              LDR      r0,[r0,#0x14]
00012e  f3c01080          UBFX     r0,r0,#6,#1
000132  b130              CBZ      r0,|L54.322|
;;;6498       {
;;;6499         /* Read data from DR */
;;;6500         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000134  6820              LDR      r0,[r4,#0]
000136  6900              LDR      r0,[r0,#0x10]
000138  6a61              LDR      r1,[r4,#0x24]
00013a  7008              STRB     r0,[r1,#0]
;;;6501   
;;;6502         /* Increment Buffer pointer */
;;;6503         hi2c->pBuffPtr++;
00013c  6a60              LDR      r0,[r4,#0x24]
00013e  1c40              ADDS     r0,r0,#1
000140  6260              STR      r0,[r4,#0x24]
                  |L54.322|
;;;6504       }
;;;6505   
;;;6506       /* Call user error callback */
;;;6507   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6508       hi2c->ErrorCallback(hi2c);
;;;6509   #else
;;;6510       HAL_I2C_ErrorCallback(hi2c);
000142  4620              MOV      r0,r4
000144  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L54.328|
;;;6511   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6512     }
;;;6513   
;;;6514     /* STOP Flag is not set after a NACK reception, BusError, ArbitrationLost, OverRun */
;;;6515     CurrentError = hi2c->ErrorCode;
000148  6c25              LDR      r5,[r4,#0x40]
;;;6516   
;;;6517     if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
00014a  f0050001          AND      r0,r5,#1
00014e  b958              CBNZ     r0,|L54.360|
;;;6518         ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
000150  f0050002          AND      r0,r5,#2
000154  2802              CMP      r0,#2
000156  d007              BEQ      |L54.360|
;;;6519         ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
000158  f0050004          AND      r0,r5,#4
00015c  2804              CMP      r0,#4
00015e  d003              BEQ      |L54.360|
;;;6520         ((CurrentError & HAL_I2C_ERROR_OVR) == HAL_I2C_ERROR_OVR))
000160  f0050008          AND      r0,r5,#8
000164  2808              CMP      r0,#8
000166  d105              BNE      |L54.372|
                  |L54.360|
;;;6521     {
;;;6522       /* Disable EVT, BUF and ERR interrupt */
;;;6523       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000168  6820              LDR      r0,[r4,#0]
00016a  6840              LDR      r0,[r0,#4]
00016c  f42060e0          BIC      r0,r0,#0x700
000170  6821              LDR      r1,[r4,#0]
000172  6048              STR      r0,[r1,#4]
                  |L54.372|
;;;6524     }
;;;6525   
;;;6526     /* So may inform upper layer that listen phase is stopped */
;;;6527     /* during NACK error treatment */
;;;6528     CurrentState = hi2c->State;
000174  f894603d          LDRB     r6,[r4,#0x3d]
;;;6529     if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
000178  6c20              LDR      r0,[r4,#0x40]
00017a  f0000004          AND      r0,r0,#4
00017e  2804              CMP      r0,#4
000180  d10e              BNE      |L54.416|
000182  2e28              CMP      r6,#0x28
000184  d10c              BNE      |L54.416|
;;;6530     {
;;;6531       hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
000186  4808              LDR      r0,|L54.424|
000188  62e0              STR      r0,[r4,#0x2c]
;;;6532       hi2c->PreviousState = I2C_STATE_NONE;
00018a  2000              MOVS     r0,#0
00018c  6320              STR      r0,[r4,#0x30]
;;;6533       hi2c->State         = HAL_I2C_STATE_READY;
00018e  2020              MOVS     r0,#0x20
000190  f884003d          STRB     r0,[r4,#0x3d]
;;;6534       hi2c->Mode          = HAL_I2C_MODE_NONE;
000194  2000              MOVS     r0,#0
000196  f884003e          STRB     r0,[r4,#0x3e]
;;;6535   
;;;6536       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;6537   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6538       hi2c->ListenCpltCallback(hi2c);
;;;6539   #else
;;;6540       HAL_I2C_ListenCpltCallback(hi2c);
00019a  4620              MOV      r0,r4
00019c  f7fffffe          BL       HAL_I2C_ListenCpltCallback
                  |L54.416|
;;;6541   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6542     }
;;;6543   }
0001a0  e8bd81f0          POP      {r4-r8,pc}
;;;6544   
                          ENDP

                  |L54.420|
                          DCD      I2C_DMAAbort
                  |L54.424|
                          DCD      0xffff0000

                          AREA ||i.I2C_IsAcknowledgeFailed||, CODE, READONLY, ALIGN=1

                  I2C_IsAcknowledgeFailed PROC
;;;7462     */
;;;7463   static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;7464   {
;;;7465     if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
000002  6808              LDR      r0,[r1,#0]
000004  6940              LDR      r0,[r0,#0x14]
000006  f3c02080          UBFX     r0,r0,#10,#1
00000a  b1b0              CBZ      r0,|L55.58|
;;;7466     {
;;;7467       /* Clear NACKF Flag */
;;;7468       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
00000c  f46f6080          MVN      r0,#0x400
000010  680a              LDR      r2,[r1,#0]
000012  6150              STR      r0,[r2,#0x14]
;;;7469   
;;;7470       hi2c->PreviousState       = I2C_STATE_NONE;
000014  2000              MOVS     r0,#0
000016  6308              STR      r0,[r1,#0x30]
;;;7471       hi2c->State               = HAL_I2C_STATE_READY;
000018  2020              MOVS     r0,#0x20
00001a  f881003d          STRB     r0,[r1,#0x3d]
;;;7472       hi2c->Mode                = HAL_I2C_MODE_NONE;
00001e  2000              MOVS     r0,#0
000020  f881003e          STRB     r0,[r1,#0x3e]
;;;7473       hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
000024  6c08              LDR      r0,[r1,#0x40]
000026  f0400004          ORR      r0,r0,#4
00002a  6408              STR      r0,[r1,#0x40]
;;;7474   
;;;7475       /* Process Unlocked */
;;;7476       __HAL_UNLOCK(hi2c);
00002c  bf00              NOP      
00002e  2000              MOVS     r0,#0
000030  f881003c          STRB     r0,[r1,#0x3c]
000034  bf00              NOP      
;;;7477   
;;;7478       return HAL_ERROR;
000036  2001              MOVS     r0,#1
                  |L55.56|
;;;7479     }
;;;7480     return HAL_OK;
;;;7481   }
000038  4770              BX       lr
                  |L55.58|
00003a  2000              MOVS     r0,#0                 ;7480
00003c  e7fc              B        |L55.56|
;;;7482   
                          ENDP


                          AREA ||i.I2C_MasterReceive_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MasterReceive_BTF PROC
;;;5625     */
;;;5626   static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5627   {
000002  4604              MOV      r4,r0
;;;5628     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5629     uint32_t CurrentXferOptions = hi2c->XferOptions;
000004  6ae5              LDR      r5,[r4,#0x2c]
;;;5630   
;;;5631     if (hi2c->XferCount == 4U)
000006  8d60              LDRH     r0,[r4,#0x2a]
000008  2804              CMP      r0,#4
00000a  d110              BNE      |L56.46|
;;;5632     {
;;;5633       /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
;;;5634          on BTF subroutine if there is a reception delay between N-1 and N byte */
;;;5635       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
00000c  6820              LDR      r0,[r4,#0]
00000e  6840              LDR      r0,[r0,#4]
000010  f4206080          BIC      r0,r0,#0x400
000014  6821              LDR      r1,[r4,#0]
000016  6048              STR      r0,[r1,#4]
;;;5636   
;;;5637       /* Read data from DR */
;;;5638       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000018  6820              LDR      r0,[r4,#0]
00001a  6900              LDR      r0,[r0,#0x10]
00001c  6a61              LDR      r1,[r4,#0x24]
00001e  7008              STRB     r0,[r1,#0]
;;;5639   
;;;5640       /* Increment Buffer pointer */
;;;5641       hi2c->pBuffPtr++;
000020  6a60              LDR      r0,[r4,#0x24]
000022  1c40              ADDS     r0,r0,#1
000024  6260              STR      r0,[r4,#0x24]
;;;5642   
;;;5643       /* Update counter */
;;;5644       hi2c->XferCount--;
000026  8d60              LDRH     r0,[r4,#0x2a]
000028  1e40              SUBS     r0,r0,#1
00002a  8560              STRH     r0,[r4,#0x2a]
00002c  e07a              B        |L56.292|
                  |L56.46|
;;;5645     }
;;;5646     else if (hi2c->XferCount == 3U)
00002e  8d60              LDRH     r0,[r4,#0x2a]
000030  2803              CMP      r0,#3
000032  d11a              BNE      |L56.106|
;;;5647     {
;;;5648       /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
;;;5649          on BTF subroutine if there is a reception delay between N-1 and N byte */
;;;5650       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000034  6820              LDR      r0,[r4,#0]
000036  6840              LDR      r0,[r0,#4]
000038  f4206080          BIC      r0,r0,#0x400
00003c  6821              LDR      r1,[r4,#0]
00003e  6048              STR      r0,[r1,#4]
;;;5651   
;;;5652       if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
000040  2d04              CMP      r5,#4
000042  d007              BEQ      |L56.84|
000044  2d02              CMP      r5,#2
000046  d005              BEQ      |L56.84|
;;;5653       {
;;;5654         /* Disable Acknowledge */
;;;5655         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000048  6820              LDR      r0,[r4,#0]
00004a  6800              LDR      r0,[r0,#0]
00004c  f4206080          BIC      r0,r0,#0x400
000050  6821              LDR      r1,[r4,#0]
000052  6008              STR      r0,[r1,#0]
                  |L56.84|
;;;5656       }
;;;5657   
;;;5658       /* Read data from DR */
;;;5659       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000054  6820              LDR      r0,[r4,#0]
000056  6900              LDR      r0,[r0,#0x10]
000058  6a61              LDR      r1,[r4,#0x24]
00005a  7008              STRB     r0,[r1,#0]
;;;5660   
;;;5661       /* Increment Buffer pointer */
;;;5662       hi2c->pBuffPtr++;
00005c  6a60              LDR      r0,[r4,#0x24]
00005e  1c40              ADDS     r0,r0,#1
000060  6260              STR      r0,[r4,#0x24]
;;;5663   
;;;5664       /* Update counter */
;;;5665       hi2c->XferCount--;
000062  8d60              LDRH     r0,[r4,#0x2a]
000064  1e40              SUBS     r0,r0,#1
000066  8560              STRH     r0,[r4,#0x2a]
000068  e05c              B        |L56.292|
                  |L56.106|
;;;5666     }
;;;5667     else if (hi2c->XferCount == 2U)
00006a  8d60              LDRH     r0,[r4,#0x2a]
00006c  2802              CMP      r0,#2
00006e  d14f              BNE      |L56.272|
;;;5668     {
;;;5669       /* Prepare next transfer or stop current transfer */
;;;5670       if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
000070  2d01              CMP      r5,#1
000072  d001              BEQ      |L56.120|
000074  2d10              CMP      r5,#0x10
000076  d106              BNE      |L56.134|
                  |L56.120|
;;;5671       {
;;;5672         /* Disable Acknowledge */
;;;5673         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000078  6820              LDR      r0,[r4,#0]
00007a  6800              LDR      r0,[r0,#0]
00007c  f4206080          BIC      r0,r0,#0x400
000080  6821              LDR      r1,[r4,#0]
000082  6008              STR      r0,[r1,#0]
000084  e012              B        |L56.172|
                  |L56.134|
;;;5674       }
;;;5675       else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
000086  2d04              CMP      r5,#4
000088  d001              BEQ      |L56.142|
00008a  2d02              CMP      r5,#2
00008c  d106              BNE      |L56.156|
                  |L56.142|
;;;5676       {
;;;5677         /* Enable Acknowledge */
;;;5678         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00008e  6820              LDR      r0,[r4,#0]
000090  6800              LDR      r0,[r0,#0]
000092  f4406080          ORR      r0,r0,#0x400
000096  6821              LDR      r1,[r4,#0]
000098  6008              STR      r0,[r1,#0]
00009a  e007              B        |L56.172|
                  |L56.156|
;;;5679       }
;;;5680       else if (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP)
00009c  2d10              CMP      r5,#0x10
00009e  d005              BEQ      |L56.172|
;;;5681       {
;;;5682         /* Generate Stop */
;;;5683         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6800              LDR      r0,[r0,#0]
0000a4  f4407000          ORR      r0,r0,#0x200
0000a8  6821              LDR      r1,[r4,#0]
0000aa  6008              STR      r0,[r1,#0]
                  |L56.172|
;;;5684       }
;;;5685       else
;;;5686       {
;;;5687         /* Do nothing */
;;;5688       }
;;;5689   
;;;5690       /* Read data from DR */
;;;5691       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000ac  6820              LDR      r0,[r4,#0]
0000ae  6900              LDR      r0,[r0,#0x10]
0000b0  6a61              LDR      r1,[r4,#0x24]
0000b2  7008              STRB     r0,[r1,#0]
;;;5692   
;;;5693       /* Increment Buffer pointer */
;;;5694       hi2c->pBuffPtr++;
0000b4  6a60              LDR      r0,[r4,#0x24]
0000b6  1c40              ADDS     r0,r0,#1
0000b8  6260              STR      r0,[r4,#0x24]
;;;5695   
;;;5696       /* Update counter */
;;;5697       hi2c->XferCount--;
0000ba  8d60              LDRH     r0,[r4,#0x2a]
0000bc  1e40              SUBS     r0,r0,#1
0000be  8560              STRH     r0,[r4,#0x2a]
;;;5698   
;;;5699       /* Read data from DR */
;;;5700       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6900              LDR      r0,[r0,#0x10]
0000c4  6a61              LDR      r1,[r4,#0x24]
0000c6  7008              STRB     r0,[r1,#0]
;;;5701   
;;;5702       /* Increment Buffer pointer */
;;;5703       hi2c->pBuffPtr++;
0000c8  6a60              LDR      r0,[r4,#0x24]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  6260              STR      r0,[r4,#0x24]
;;;5704   
;;;5705       /* Update counter */
;;;5706       hi2c->XferCount--;
0000ce  8d60              LDRH     r0,[r4,#0x2a]
0000d0  1e40              SUBS     r0,r0,#1
0000d2  8560              STRH     r0,[r4,#0x2a]
;;;5707   
;;;5708       /* Disable EVT and ERR interrupt */
;;;5709       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6840              LDR      r0,[r0,#4]
0000d8  f4207040          BIC      r0,r0,#0x300
0000dc  6821              LDR      r1,[r4,#0]
0000de  6048              STR      r0,[r1,#4]
;;;5710   
;;;5711       hi2c->State = HAL_I2C_STATE_READY;
0000e0  2020              MOVS     r0,#0x20
0000e2  f884003d          STRB     r0,[r4,#0x3d]
;;;5712       if (hi2c->Mode == HAL_I2C_MODE_MEM)
0000e6  f894003e          LDRB     r0,[r4,#0x3e]
0000ea  2840              CMP      r0,#0x40
0000ec  d107              BNE      |L56.254|
;;;5713       {
;;;5714         hi2c->Mode = HAL_I2C_MODE_NONE;
0000ee  2000              MOVS     r0,#0
0000f0  f884003e          STRB     r0,[r4,#0x3e]
;;;5715         hi2c->PreviousState = I2C_STATE_NONE;
0000f4  6320              STR      r0,[r4,#0x30]
;;;5716   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5717         hi2c->MemRxCpltCallback(hi2c);
;;;5718   #else
;;;5719         HAL_I2C_MemRxCpltCallback(hi2c);
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
0000fc  e012              B        |L56.292|
                  |L56.254|
;;;5720   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5721       }
;;;5722       else
;;;5723       {
;;;5724         hi2c->Mode = HAL_I2C_MODE_NONE;
0000fe  2000              MOVS     r0,#0
000100  f884003e          STRB     r0,[r4,#0x3e]
;;;5725         hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000104  2012              MOVS     r0,#0x12
000106  6320              STR      r0,[r4,#0x30]
;;;5726   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5727         hi2c->MasterRxCpltCallback(hi2c);
;;;5728   #else
;;;5729         HAL_I2C_MasterRxCpltCallback(hi2c);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
00010e  e009              B        |L56.292|
                  |L56.272|
;;;5730   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5731       }
;;;5732     }
;;;5733     else
;;;5734     {
;;;5735       /* Read data from DR */
;;;5736       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000110  6820              LDR      r0,[r4,#0]
000112  6900              LDR      r0,[r0,#0x10]
000114  6a61              LDR      r1,[r4,#0x24]
000116  7008              STRB     r0,[r1,#0]
;;;5737   
;;;5738       /* Increment Buffer pointer */
;;;5739       hi2c->pBuffPtr++;
000118  6a60              LDR      r0,[r4,#0x24]
00011a  1c40              ADDS     r0,r0,#1
00011c  6260              STR      r0,[r4,#0x24]
;;;5740   
;;;5741       /* Update counter */
;;;5742       hi2c->XferCount--;
00011e  8d60              LDRH     r0,[r4,#0x2a]
000120  1e40              SUBS     r0,r0,#1
000122  8560              STRH     r0,[r4,#0x2a]
                  |L56.292|
;;;5743     }
;;;5744   }
000124  bd70              POP      {r4-r6,pc}
;;;5745   
                          ENDP


                          AREA ||i.I2C_MasterReceive_RXNE||, CODE, READONLY, ALIGN=1

                  I2C_MasterReceive_RXNE PROC
;;;5517     */
;;;5518   static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5519   {
000002  4604              MOV      r4,r0
;;;5520     if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  2822              CMP      r0,#0x22
00000a  d169              BNE      |L57.224|
;;;5521     {
;;;5522       uint32_t tmp;
;;;5523   
;;;5524       tmp = hi2c->XferCount;
00000c  8d65              LDRH     r5,[r4,#0x2a]
;;;5525       if (tmp > 3U)
00000e  2d03              CMP      r5,#3
000010  d913              BLS      |L57.58|
;;;5526       {
;;;5527         /* Read data from DR */
;;;5528         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000012  6820              LDR      r0,[r4,#0]
000014  6900              LDR      r0,[r0,#0x10]
000016  6a61              LDR      r1,[r4,#0x24]
000018  7008              STRB     r0,[r1,#0]
;;;5529   
;;;5530         /* Increment Buffer pointer */
;;;5531         hi2c->pBuffPtr++;
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  1c40              ADDS     r0,r0,#1
00001e  6260              STR      r0,[r4,#0x24]
;;;5532   
;;;5533         /* Update counter */
;;;5534         hi2c->XferCount--;
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  1e40              SUBS     r0,r0,#1
000024  8560              STRH     r0,[r4,#0x2a]
;;;5535   
;;;5536         if (hi2c->XferCount == (uint16_t)3)
000026  8d60              LDRH     r0,[r4,#0x2a]
000028  2803              CMP      r0,#3
00002a  d158              BNE      |L57.222|
;;;5537         {
;;;5538           /* Disable BUF interrupt, this help to treat correctly the last 4 bytes
;;;5539           on BTF subroutine */
;;;5540           /* Disable BUF interrupt */
;;;5541           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
00002c  6820              LDR      r0,[r4,#0]
00002e  6840              LDR      r0,[r0,#4]
000030  f4206080          BIC      r0,r0,#0x400
000034  6821              LDR      r1,[r4,#0]
000036  6048              STR      r0,[r1,#4]
000038  e051              B        |L57.222|
                  |L57.58|
;;;5542         }
;;;5543       }
;;;5544       else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
00003a  6ae0              LDR      r0,[r4,#0x2c]
00003c  2802              CMP      r0,#2
00003e  d04e              BEQ      |L57.222|
000040  2d01              CMP      r5,#1
000042  d001              BEQ      |L57.72|
000044  2d00              CMP      r5,#0
000046  d14a              BNE      |L57.222|
                  |L57.72|
;;;5545       {
;;;5546         if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       I2C_WaitOnSTOPRequestThroughIT
00004e  bb68              CBNZ     r0,|L57.172|
;;;5547         {
;;;5548           /* Disable Acknowledge */
;;;5549           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000050  6820              LDR      r0,[r4,#0]
000052  6800              LDR      r0,[r0,#0]
000054  f4206080          BIC      r0,r0,#0x400
000058  6821              LDR      r1,[r4,#0]
00005a  6008              STR      r0,[r1,#0]
;;;5550   
;;;5551           /* Disable EVT, BUF and ERR interrupt */
;;;5552           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00005c  6820              LDR      r0,[r4,#0]
00005e  6840              LDR      r0,[r0,#4]
000060  f42060e0          BIC      r0,r0,#0x700
000064  6821              LDR      r1,[r4,#0]
000066  6048              STR      r0,[r1,#4]
;;;5553   
;;;5554           /* Read data from DR */
;;;5555           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000068  6820              LDR      r0,[r4,#0]
00006a  6900              LDR      r0,[r0,#0x10]
00006c  6a61              LDR      r1,[r4,#0x24]
00006e  7008              STRB     r0,[r1,#0]
;;;5556   
;;;5557           /* Increment Buffer pointer */
;;;5558           hi2c->pBuffPtr++;
000070  6a60              LDR      r0,[r4,#0x24]
000072  1c40              ADDS     r0,r0,#1
000074  6260              STR      r0,[r4,#0x24]
;;;5559   
;;;5560           /* Update counter */
;;;5561           hi2c->XferCount--;
000076  8d60              LDRH     r0,[r4,#0x2a]
000078  1e40              SUBS     r0,r0,#1
00007a  8560              STRH     r0,[r4,#0x2a]
;;;5562   
;;;5563           hi2c->State = HAL_I2C_STATE_READY;
00007c  2020              MOVS     r0,#0x20
00007e  f884003d          STRB     r0,[r4,#0x3d]
;;;5564   
;;;5565           if (hi2c->Mode == HAL_I2C_MODE_MEM)
000082  f894003e          LDRB     r0,[r4,#0x3e]
000086  2840              CMP      r0,#0x40
000088  d107              BNE      |L57.154|
;;;5566           {
;;;5567             hi2c->Mode = HAL_I2C_MODE_NONE;
00008a  2000              MOVS     r0,#0
00008c  f884003e          STRB     r0,[r4,#0x3e]
;;;5568             hi2c->PreviousState = I2C_STATE_NONE;
000090  6320              STR      r0,[r4,#0x30]
;;;5569   
;;;5570   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5571             hi2c->MemRxCpltCallback(hi2c);
;;;5572   #else
;;;5573             HAL_I2C_MemRxCpltCallback(hi2c);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
000098  e021              B        |L57.222|
                  |L57.154|
;;;5574   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5575           }
;;;5576           else
;;;5577           {
;;;5578             hi2c->Mode = HAL_I2C_MODE_NONE;
00009a  2000              MOVS     r0,#0
00009c  f884003e          STRB     r0,[r4,#0x3e]
;;;5579             hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
0000a0  2012              MOVS     r0,#0x12
0000a2  6320              STR      r0,[r4,#0x30]
;;;5580   
;;;5581   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5582             hi2c->MasterRxCpltCallback(hi2c);
;;;5583   #else
;;;5584             HAL_I2C_MasterRxCpltCallback(hi2c);
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
0000aa  e018              B        |L57.222|
                  |L57.172|
;;;5585   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5586           }
;;;5587         }
;;;5588         else
;;;5589         {
;;;5590           /* Disable EVT, BUF and ERR interrupt */
;;;5591           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
0000ac  6820              LDR      r0,[r4,#0]
0000ae  6840              LDR      r0,[r0,#4]
0000b0  f42060e0          BIC      r0,r0,#0x700
0000b4  6821              LDR      r1,[r4,#0]
0000b6  6048              STR      r0,[r1,#4]
;;;5592   
;;;5593           /* Read data from DR */
;;;5594           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6900              LDR      r0,[r0,#0x10]
0000bc  6a61              LDR      r1,[r4,#0x24]
0000be  7008              STRB     r0,[r1,#0]
;;;5595   
;;;5596           /* Increment Buffer pointer */
;;;5597           hi2c->pBuffPtr++;
0000c0  6a60              LDR      r0,[r4,#0x24]
0000c2  1c40              ADDS     r0,r0,#1
0000c4  6260              STR      r0,[r4,#0x24]
;;;5598   
;;;5599           /* Update counter */
;;;5600           hi2c->XferCount--;
0000c6  8d60              LDRH     r0,[r4,#0x2a]
0000c8  1e40              SUBS     r0,r0,#1
0000ca  8560              STRH     r0,[r4,#0x2a]
;;;5601   
;;;5602           hi2c->State = HAL_I2C_STATE_READY;
0000cc  2020              MOVS     r0,#0x20
0000ce  f884003d          STRB     r0,[r4,#0x3d]
;;;5603           hi2c->Mode = HAL_I2C_MODE_NONE;
0000d2  2000              MOVS     r0,#0
0000d4  f884003e          STRB     r0,[r4,#0x3e]
;;;5604   
;;;5605           /* Call user error callback */
;;;5606   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5607           hi2c->ErrorCallback(hi2c);
;;;5608   #else
;;;5609           HAL_I2C_ErrorCallback(hi2c);
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L57.222|
;;;5610   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5611         }
;;;5612       }
;;;5613       else
;;;5614       {
;;;5615         /* Do nothing */
;;;5616       }
;;;5617     }
0000de  bf00              NOP      
                  |L57.224|
;;;5618   }
0000e0  bd70              POP      {r4-r6,pc}
;;;5619   
                          ENDP


                          AREA ||i.I2C_MasterRequestRead||, CODE, READONLY, ALIGN=2

                  I2C_MasterRequestRead PROC
;;;6623     */
;;;6624   static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6625   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;6626     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6627     uint32_t CurrentXferOptions = hi2c->XferOptions;
00000c  6ae7              LDR      r7,[r4,#0x2c]
;;;6628   
;;;6629     /* Enable Acknowledge */
;;;6630     SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f4406080          ORR      r0,r0,#0x400
000016  6821              LDR      r1,[r4,#0]
000018  6008              STR      r0,[r1,#0]
;;;6631   
;;;6632     /* Generate Start condition if first transfer */
;;;6633     if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME)  || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
00001a  2f08              CMP      r7,#8
00001c  d004              BEQ      |L58.40|
00001e  2f01              CMP      r7,#1
000020  d002              BEQ      |L58.40|
000022  f5173f80          CMN      r7,#0x10000
000026  d106              BNE      |L58.54|
                  |L58.40|
;;;6634     {
;;;6635       /* Generate Start */
;;;6636       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f4407080          ORR      r0,r0,#0x100
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
000034  e008              B        |L58.72|
                  |L58.54|
;;;6637     }
;;;6638     else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
000036  6b20              LDR      r0,[r4,#0x30]
000038  2811              CMP      r0,#0x11
00003a  d105              BNE      |L58.72|
;;;6639     {
;;;6640       /* Generate ReStart */
;;;6641       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00003c  6820              LDR      r0,[r4,#0]
00003e  6800              LDR      r0,[r0,#0]
000040  f4407080          ORR      r0,r0,#0x100
000044  6821              LDR      r1,[r4,#0]
000046  6008              STR      r0,[r1,#0]
                  |L58.72|
;;;6642     }
;;;6643     else
;;;6644     {
;;;6645       /* Do nothing */
;;;6646     }
;;;6647   
;;;6648     /* Wait until SB flag is set */
;;;6649     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
000048  4643              MOV      r3,r8
00004a  2200              MOVS     r2,#0
00004c  f04f1101          MOV      r1,#0x10001
000050  4620              MOV      r0,r4
000052  9600              STR      r6,[sp,#0]
000054  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000058  b160              CBZ      r0,|L58.116|
;;;6650     {
;;;6651       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
00005a  6820              LDR      r0,[r4,#0]
00005c  6800              LDR      r0,[r0,#0]
00005e  f4007080          AND      r0,r0,#0x100
000062  f5b07f80          CMP      r0,#0x100
000066  d102              BNE      |L58.110|
;;;6652       {
;;;6653         hi2c->ErrorCode = HAL_I2C_WRONG_START;
000068  f44f7000          MOV      r0,#0x200
00006c  6420              STR      r0,[r4,#0x40]
                  |L58.110|
;;;6654       }
;;;6655       return HAL_TIMEOUT;
00006e  2003              MOVS     r0,#3
                  |L58.112|
;;;6656     }
;;;6657   
;;;6658     if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;6659     {
;;;6660       /* Send slave address */
;;;6661       hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;6662     }
;;;6663     else
;;;6664     {
;;;6665       /* Send header of slave address */
;;;6666       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
;;;6667   
;;;6668       /* Wait until ADD10 flag is set */
;;;6669       if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
;;;6670       {
;;;6671         return HAL_ERROR;
;;;6672       }
;;;6673   
;;;6674       /* Send slave address */
;;;6675       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;6676   
;;;6677       /* Wait until ADDR flag is set */
;;;6678       if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6679       {
;;;6680         return HAL_ERROR;
;;;6681       }
;;;6682   
;;;6683       /* Clear ADDR flag */
;;;6684       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;6685   
;;;6686       /* Generate Restart */
;;;6687       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;6688   
;;;6689       /* Wait until SB flag is set */
;;;6690       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
;;;6691       {
;;;6692         if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
;;;6693         {
;;;6694           hi2c->ErrorCode = HAL_I2C_WRONG_START;
;;;6695         }
;;;6696         return HAL_TIMEOUT;
;;;6697       }
;;;6698   
;;;6699       /* Send header of slave address */
;;;6700       hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
;;;6701     }
;;;6702   
;;;6703     /* Wait until ADDR flag is set */
;;;6704     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6705     {
;;;6706       return HAL_ERROR;
;;;6707     }
;;;6708   
;;;6709     return HAL_OK;
;;;6710   }
000070  e8bd83f8          POP      {r3-r9,pc}
                  |L58.116|
000074  6920              LDR      r0,[r4,#0x10]         ;6658
000076  f5b04f80          CMP      r0,#0x4000            ;6658
00007a  d105              BNE      |L58.136|
00007c  b2e8              UXTB     r0,r5                 ;6661
00007e  f0400001          ORR      r0,r0,#1              ;6661
000082  6821              LDR      r1,[r4,#0]            ;6661
000084  6108              STR      r0,[r1,#0x10]         ;6661
000086  e049              B        |L58.284|
                  |L58.136|
000088  f4057040          AND      r0,r5,#0x300          ;6666
00008c  21f0              MOVS     r1,#0xf0              ;6666
00008e  ea4110e0          ORR      r0,r1,r0,ASR #7       ;6666
000092  6821              LDR      r1,[r4,#0]            ;6666
000094  6108              STR      r0,[r1,#0x10]         ;6666
000096  4633              MOV      r3,r6                 ;6669
000098  4642              MOV      r2,r8                 ;6669
00009a  4926              LDR      r1,|L58.308|
00009c  4620              MOV      r0,r4                 ;6669
00009e  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000a2  b108              CBZ      r0,|L58.168|
0000a4  2001              MOVS     r0,#1                 ;6671
0000a6  e7e3              B        |L58.112|
                  |L58.168|
0000a8  b2e8              UXTB     r0,r5                 ;6675
0000aa  6821              LDR      r1,[r4,#0]            ;6675
0000ac  6108              STR      r0,[r1,#0x10]         ;6675
0000ae  4633              MOV      r3,r6                 ;6678
0000b0  4642              MOV      r2,r8                 ;6678
0000b2  4920              LDR      r1,|L58.308|
0000b4  1f89              SUBS     r1,r1,#6              ;6678
0000b6  4620              MOV      r0,r4                 ;6678
0000b8  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000bc  b108              CBZ      r0,|L58.194|
0000be  2001              MOVS     r0,#1                 ;6680
0000c0  e7d6              B        |L58.112|
                  |L58.194|
0000c2  bf00              NOP                            ;6684
0000c4  2000              MOVS     r0,#0                 ;6684
0000c6  9000              STR      r0,[sp,#0]            ;6684
0000c8  6820              LDR      r0,[r4,#0]            ;6684
0000ca  6940              LDR      r0,[r0,#0x14]         ;6684
0000cc  9000              STR      r0,[sp,#0]            ;6684
0000ce  6820              LDR      r0,[r4,#0]            ;6684
0000d0  6980              LDR      r0,[r0,#0x18]         ;6684
0000d2  9000              STR      r0,[sp,#0]            ;6684
0000d4  bf00              NOP                            ;6684
0000d6  bf00              NOP                            ;6684
0000d8  6820              LDR      r0,[r4,#0]            ;6687
0000da  6800              LDR      r0,[r0,#0]            ;6687
0000dc  f4407080          ORR      r0,r0,#0x100          ;6687
0000e0  6821              LDR      r1,[r4,#0]            ;6687
0000e2  6008              STR      r0,[r1,#0]            ;6687
0000e4  4643              MOV      r3,r8                 ;6690
0000e6  2200              MOVS     r2,#0                 ;6690
0000e8  f04f1101          MOV      r1,#0x10001           ;6690
0000ec  4620              MOV      r0,r4                 ;6690
0000ee  9600              STR      r6,[sp,#0]            ;6690
0000f0  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000f4  b158              CBZ      r0,|L58.270|
0000f6  6820              LDR      r0,[r4,#0]            ;6692
0000f8  6800              LDR      r0,[r0,#0]            ;6692
0000fa  f4007080          AND      r0,r0,#0x100          ;6692
0000fe  f5b07f80          CMP      r0,#0x100             ;6692
000102  d102              BNE      |L58.266|
000104  f44f7000          MOV      r0,#0x200             ;6694
000108  6420              STR      r0,[r4,#0x40]         ;6694
                  |L58.266|
00010a  2003              MOVS     r0,#3                 ;6696
00010c  e7b0              B        |L58.112|
                  |L58.270|
00010e  f4057040          AND      r0,r5,#0x300          ;6700
000112  21f1              MOVS     r1,#0xf1              ;6700
000114  ea4110e0          ORR      r0,r1,r0,ASR #7       ;6700
000118  6821              LDR      r1,[r4,#0]            ;6700
00011a  6108              STR      r0,[r1,#0x10]         ;6700
                  |L58.284|
00011c  4633              MOV      r3,r6                 ;6704
00011e  4642              MOV      r2,r8                 ;6704
000120  4904              LDR      r1,|L58.308|
000122  1f89              SUBS     r1,r1,#6              ;6704
000124  4620              MOV      r0,r4                 ;6704
000126  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00012a  b108              CBZ      r0,|L58.304|
00012c  2001              MOVS     r0,#1                 ;6706
00012e  e79f              B        |L58.112|
                  |L58.304|
000130  2000              MOVS     r0,#0                 ;6709
000132  e79d              B        |L58.112|
;;;6711   
                          ENDP

                  |L58.308|
                          DCD      0x00010008

                          AREA ||i.I2C_MasterRequestWrite||, CODE, READONLY, ALIGN=2

                  I2C_MasterRequestWrite PROC
;;;6553     */
;;;6554   static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6555   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;6556     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6557     uint32_t CurrentXferOptions = hi2c->XferOptions;
00000c  6ae6              LDR      r6,[r4,#0x2c]
;;;6558   
;;;6559     /* Generate Start condition if first transfer */
;;;6560     if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
00000e  2e08              CMP      r6,#8
000010  d004              BEQ      |L59.28|
000012  2e01              CMP      r6,#1
000014  d002              BEQ      |L59.28|
000016  f5163f80          CMN      r6,#0x10000
00001a  d106              BNE      |L59.42|
                  |L59.28|
;;;6561     {
;;;6562       /* Generate Start */
;;;6563       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00001c  6820              LDR      r0,[r4,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  f4407080          ORR      r0,r0,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  6008              STR      r0,[r1,#0]
000028  e008              B        |L59.60|
                  |L59.42|
;;;6564     }
;;;6565     else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
00002a  6b20              LDR      r0,[r4,#0x30]
00002c  2812              CMP      r0,#0x12
00002e  d105              BNE      |L59.60|
;;;6566     {
;;;6567       /* Generate ReStart */
;;;6568       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000030  6820              LDR      r0,[r4,#0]
000032  6800              LDR      r0,[r0,#0]
000034  f4407080          ORR      r0,r0,#0x100
000038  6821              LDR      r1,[r4,#0]
00003a  6008              STR      r0,[r1,#0]
                  |L59.60|
;;;6569     }
;;;6570     else
;;;6571     {
;;;6572       /* Do nothing */
;;;6573     }
;;;6574   
;;;6575     /* Wait until SB flag is set */
;;;6576     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
00003c  463b              MOV      r3,r7
00003e  2200              MOVS     r2,#0
000040  f04f1101          MOV      r1,#0x10001
000044  4620              MOV      r0,r4
000046  f8cd8000          STR      r8,[sp,#0]
00004a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00004e  b160              CBZ      r0,|L59.106|
;;;6577     {
;;;6578       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
000050  6820              LDR      r0,[r4,#0]
000052  6800              LDR      r0,[r0,#0]
000054  f4007080          AND      r0,r0,#0x100
000058  f5b07f80          CMP      r0,#0x100
00005c  d102              BNE      |L59.100|
;;;6579       {
;;;6580         hi2c->ErrorCode = HAL_I2C_WRONG_START;
00005e  f44f7000          MOV      r0,#0x200
000062  6420              STR      r0,[r4,#0x40]
                  |L59.100|
;;;6581       }
;;;6582       return HAL_TIMEOUT;
000064  2003              MOVS     r0,#3
                  |L59.102|
;;;6583     }
;;;6584   
;;;6585     if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;6586     {
;;;6587       /* Send slave address */
;;;6588       hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;6589     }
;;;6590     else
;;;6591     {
;;;6592       /* Send header of slave address */
;;;6593       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
;;;6594   
;;;6595       /* Wait until ADD10 flag is set */
;;;6596       if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
;;;6597       {
;;;6598         return HAL_ERROR;
;;;6599       }
;;;6600   
;;;6601       /* Send slave address */
;;;6602       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;6603     }
;;;6604   
;;;6605     /* Wait until ADDR flag is set */
;;;6606     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6607     {
;;;6608       return HAL_ERROR;
;;;6609     }
;;;6610   
;;;6611     return HAL_OK;
;;;6612   }
000066  e8bd83f8          POP      {r3-r9,pc}
                  |L59.106|
00006a  6920              LDR      r0,[r4,#0x10]         ;6585
00006c  f5b04f80          CMP      r0,#0x4000            ;6585
000070  d104              BNE      |L59.124|
000072  f00500fe          AND      r0,r5,#0xfe           ;6588
000076  6821              LDR      r1,[r4,#0]            ;6588
000078  6108              STR      r0,[r1,#0x10]         ;6588
00007a  e012              B        |L59.162|
                  |L59.124|
00007c  f4057040          AND      r0,r5,#0x300          ;6593
000080  21f0              MOVS     r1,#0xf0              ;6593
000082  ea4110e0          ORR      r0,r1,r0,ASR #7       ;6593
000086  6821              LDR      r1,[r4,#0]            ;6593
000088  6108              STR      r0,[r1,#0x10]         ;6593
00008a  4643              MOV      r3,r8                 ;6596
00008c  463a              MOV      r2,r7                 ;6596
00008e  490b              LDR      r1,|L59.188|
000090  4620              MOV      r0,r4                 ;6596
000092  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000096  b108              CBZ      r0,|L59.156|
000098  2001              MOVS     r0,#1                 ;6598
00009a  e7e4              B        |L59.102|
                  |L59.156|
00009c  b2e8              UXTB     r0,r5                 ;6602
00009e  6821              LDR      r1,[r4,#0]            ;6602
0000a0  6108              STR      r0,[r1,#0x10]         ;6602
                  |L59.162|
0000a2  4643              MOV      r3,r8                 ;6606
0000a4  463a              MOV      r2,r7                 ;6606
0000a6  4905              LDR      r1,|L59.188|
0000a8  1f89              SUBS     r1,r1,#6              ;6606
0000aa  4620              MOV      r0,r4                 ;6606
0000ac  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000b0  b108              CBZ      r0,|L59.182|
0000b2  2001              MOVS     r0,#1                 ;6608
0000b4  e7d7              B        |L59.102|
                  |L59.182|
0000b6  2000              MOVS     r0,#0                 ;6611
0000b8  e7d5              B        |L59.102|
;;;6613   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L59.188|
                          DCD      0x00010008

                          AREA ||i.I2C_MasterTransmit_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransmit_BTF PROC
;;;5352     */
;;;5353   static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5354   {
000002  4604              MOV      r4,r0
;;;5355     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5356     uint32_t CurrentXferOptions = hi2c->XferOptions;
000004  6ae5              LDR      r5,[r4,#0x2c]
;;;5357   
;;;5358     if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2821              CMP      r0,#0x21
00000c  d147              BNE      |L60.158|
;;;5359     {
;;;5360       if (hi2c->XferCount != 0U)
00000e  8d60              LDRH     r0,[r4,#0x2a]
000010  b150              CBZ      r0,|L60.40|
;;;5361       {
;;;5362         /* Write data to DR */
;;;5363         hi2c->Instance->DR = *hi2c->pBuffPtr;
000012  6a60              LDR      r0,[r4,#0x24]
000014  7800              LDRB     r0,[r0,#0]
000016  6821              LDR      r1,[r4,#0]
000018  6108              STR      r0,[r1,#0x10]
;;;5364   
;;;5365         /* Increment Buffer pointer */
;;;5366         hi2c->pBuffPtr++;
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  1c40              ADDS     r0,r0,#1
00001e  6260              STR      r0,[r4,#0x24]
;;;5367   
;;;5368         /* Update counter */
;;;5369         hi2c->XferCount--;
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  1e40              SUBS     r0,r0,#1
000024  8560              STRH     r0,[r4,#0x2a]
000026  e03a              B        |L60.158|
                  |L60.40|
;;;5370       }
;;;5371       else
;;;5372       {
;;;5373         /* Call TxCpltCallback() directly if no stop mode is set */
;;;5374         if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
000028  2d08              CMP      r5,#8
00002a  d016              BEQ      |L60.90|
00002c  2d20              CMP      r5,#0x20
00002e  d014              BEQ      |L60.90|
000030  f5153f80          CMN      r5,#0x10000
000034  d011              BEQ      |L60.90|
;;;5375         {
;;;5376           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000036  6820              LDR      r0,[r4,#0]
000038  6840              LDR      r0,[r0,#4]
00003a  f42060e0          BIC      r0,r0,#0x700
00003e  6821              LDR      r1,[r4,#0]
000040  6048              STR      r0,[r1,#4]
;;;5377   
;;;5378           hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
000042  2011              MOVS     r0,#0x11
000044  6320              STR      r0,[r4,#0x30]
;;;5379           hi2c->Mode = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;5380           hi2c->State = HAL_I2C_STATE_READY;
00004c  2020              MOVS     r0,#0x20
00004e  f884003d          STRB     r0,[r4,#0x3d]
;;;5381   
;;;5382   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5383           hi2c->MasterTxCpltCallback(hi2c);
;;;5384   #else
;;;5385           HAL_I2C_MasterTxCpltCallback(hi2c);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000058  e021              B        |L60.158|
                  |L60.90|
;;;5386   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5387         }
;;;5388         else /* Generate Stop condition then Call TxCpltCallback() */
;;;5389         {
;;;5390           /* Disable EVT, BUF and ERR interrupt */
;;;5391           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00005a  6820              LDR      r0,[r4,#0]
00005c  6840              LDR      r0,[r0,#4]
00005e  f42060e0          BIC      r0,r0,#0x700
000062  6821              LDR      r1,[r4,#0]
000064  6048              STR      r0,[r1,#4]
;;;5392   
;;;5393           /* Generate Stop */
;;;5394           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f4407000          ORR      r0,r0,#0x200
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
;;;5395   
;;;5396           hi2c->PreviousState = I2C_STATE_NONE;
000072  2000              MOVS     r0,#0
000074  6320              STR      r0,[r4,#0x30]
;;;5397           hi2c->State = HAL_I2C_STATE_READY;
000076  2020              MOVS     r0,#0x20
000078  f884003d          STRB     r0,[r4,#0x3d]
;;;5398           if (hi2c->Mode == HAL_I2C_MODE_MEM)
00007c  f894003e          LDRB     r0,[r4,#0x3e]
000080  2840              CMP      r0,#0x40
000082  d106              BNE      |L60.146|
;;;5399           {
;;;5400             hi2c->Mode = HAL_I2C_MODE_NONE;
000084  2000              MOVS     r0,#0
000086  f884003e          STRB     r0,[r4,#0x3e]
;;;5401   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5402             hi2c->MemTxCpltCallback(hi2c);
;;;5403   #else
;;;5404             HAL_I2C_MemTxCpltCallback(hi2c);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
000090  e005              B        |L60.158|
                  |L60.146|
;;;5405   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5406           }
;;;5407           else
;;;5408           {
;;;5409             hi2c->Mode = HAL_I2C_MODE_NONE;
000092  2000              MOVS     r0,#0
000094  f884003e          STRB     r0,[r4,#0x3e]
;;;5410   
;;;5411   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5412             hi2c->MasterTxCpltCallback(hi2c);
;;;5413   #else
;;;5414             HAL_I2C_MasterTxCpltCallback(hi2c);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
                  |L60.158|
;;;5415   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5416           }
;;;5417         }
;;;5418       }
;;;5419     }
;;;5420     else
;;;5421     {
;;;5422       /* Do nothing */
;;;5423     }
;;;5424   }
00009e  bd70              POP      {r4-r6,pc}
;;;5425   
                          ENDP


                          AREA ||i.I2C_MasterTransmit_TXE||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransmit_TXE PROC
;;;5258     */
;;;5259   static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5260   {
000004  4604              MOV      r4,r0
;;;5261     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5262     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000006  f894503d          LDRB     r5,[r4,#0x3d]
;;;5263     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
00000a  f894703e          LDRB     r7,[r4,#0x3e]
;;;5264     uint32_t CurrentXferOptions       = hi2c->XferOptions;
00000e  6ae6              LDR      r6,[r4,#0x2c]
;;;5265   
;;;5266     if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
000010  8d20              LDRH     r0,[r4,#0x28]
000012  bbb0              CBNZ     r0,|L61.130|
000014  2d21              CMP      r5,#0x21
000016  d13c              BNE      |L61.146|
;;;5267     {
;;;5268       /* Call TxCpltCallback() directly if no stop mode is set */
;;;5269       if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
000018  2e08              CMP      r6,#8
00001a  d016              BEQ      |L61.74|
00001c  2e20              CMP      r6,#0x20
00001e  d014              BEQ      |L61.74|
000020  f5163f80          CMN      r6,#0x10000
000024  d011              BEQ      |L61.74|
;;;5270       {
;;;5271         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000026  6820              LDR      r0,[r4,#0]
000028  6840              LDR      r0,[r0,#4]
00002a  f42060e0          BIC      r0,r0,#0x700
00002e  6821              LDR      r1,[r4,#0]
000030  6048              STR      r0,[r1,#4]
;;;5272   
;;;5273         hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
000032  2011              MOVS     r0,#0x11
000034  6320              STR      r0,[r4,#0x30]
;;;5274         hi2c->Mode = HAL_I2C_MODE_NONE;
000036  2000              MOVS     r0,#0
000038  f884003e          STRB     r0,[r4,#0x3e]
;;;5275         hi2c->State = HAL_I2C_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;5276   
;;;5277   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5278         hi2c->MasterTxCpltCallback(hi2c);
;;;5279   #else
;;;5280         HAL_I2C_MasterTxCpltCallback(hi2c);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000048  e044              B        |L61.212|
                  |L61.74|
;;;5281   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5282       }
;;;5283       else /* Generate Stop condition then Call TxCpltCallback() */
;;;5284       {
;;;5285         /* Disable EVT, BUF and ERR interrupt */
;;;5286         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00004a  6820              LDR      r0,[r4,#0]
00004c  6840              LDR      r0,[r0,#4]
00004e  f42060e0          BIC      r0,r0,#0x700
000052  6821              LDR      r1,[r4,#0]
000054  6048              STR      r0,[r1,#4]
;;;5287   
;;;5288         /* Generate Stop */
;;;5289         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  f4407000          ORR      r0,r0,#0x200
00005e  6821              LDR      r1,[r4,#0]
000060  6008              STR      r0,[r1,#0]
;;;5290   
;;;5291         hi2c->PreviousState = I2C_STATE_NONE;
000062  2000              MOVS     r0,#0
000064  6320              STR      r0,[r4,#0x30]
;;;5292         hi2c->State = HAL_I2C_STATE_READY;
000066  2020              MOVS     r0,#0x20
000068  f884003d          STRB     r0,[r4,#0x3d]
;;;5293   
;;;5294         if (hi2c->Mode == HAL_I2C_MODE_MEM)
00006c  f894003e          LDRB     r0,[r4,#0x3e]
000070  2840              CMP      r0,#0x40
000072  d107              BNE      |L61.132|
;;;5295         {
;;;5296           hi2c->Mode = HAL_I2C_MODE_NONE;
000074  2000              MOVS     r0,#0
000076  f884003e          STRB     r0,[r4,#0x3e]
;;;5297   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5298           hi2c->MemTxCpltCallback(hi2c);
;;;5299   #else
;;;5300           HAL_I2C_MemTxCpltCallback(hi2c);
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
000080  e028              B        |L61.212|
                  |L61.130|
000082  e006              B        |L61.146|
                  |L61.132|
;;;5301   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5302         }
;;;5303         else
;;;5304         {
;;;5305           hi2c->Mode = HAL_I2C_MODE_NONE;
000084  2000              MOVS     r0,#0
000086  f884003e          STRB     r0,[r4,#0x3e]
;;;5306   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5307           hi2c->MasterTxCpltCallback(hi2c);
;;;5308   #else
;;;5309           HAL_I2C_MasterTxCpltCallback(hi2c);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000090  e020              B        |L61.212|
                  |L61.146|
;;;5310   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5311         }
;;;5312       }
;;;5313     }
;;;5314     else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
000092  2d21              CMP      r5,#0x21
000094  d003              BEQ      |L61.158|
;;;5315              ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
000096  2f40              CMP      r7,#0x40
000098  d11c              BNE      |L61.212|
00009a  2d22              CMP      r5,#0x22
00009c  d11a              BNE      |L61.212|
                  |L61.158|
;;;5316     {
;;;5317       if (hi2c->XferCount == 0U)
00009e  8d60              LDRH     r0,[r4,#0x2a]
0000a0  b930              CBNZ     r0,|L61.176|
;;;5318       {
;;;5319         /* Disable BUF interrupt */
;;;5320         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6840              LDR      r0,[r0,#4]
0000a6  f4206080          BIC      r0,r0,#0x400
0000aa  6821              LDR      r1,[r4,#0]
0000ac  6048              STR      r0,[r1,#4]
0000ae  e011              B        |L61.212|
                  |L61.176|
;;;5321       }
;;;5322       else
;;;5323       {
;;;5324         if (hi2c->Mode == HAL_I2C_MODE_MEM)
0000b0  f894003e          LDRB     r0,[r4,#0x3e]
0000b4  2840              CMP      r0,#0x40
0000b6  d103              BNE      |L61.192|
;;;5325         {
;;;5326           I2C_MemoryTransmit_TXE_BTF(hi2c);
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       I2C_MemoryTransmit_TXE_BTF
0000be  e009              B        |L61.212|
                  |L61.192|
;;;5327         }
;;;5328         else
;;;5329         {
;;;5330           /* Write data to DR */
;;;5331           hi2c->Instance->DR = *hi2c->pBuffPtr;
0000c0  6a60              LDR      r0,[r4,#0x24]
0000c2  7800              LDRB     r0,[r0,#0]
0000c4  6821              LDR      r1,[r4,#0]
0000c6  6108              STR      r0,[r1,#0x10]
;;;5332   
;;;5333           /* Increment Buffer pointer */
;;;5334           hi2c->pBuffPtr++;
0000c8  6a60              LDR      r0,[r4,#0x24]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  6260              STR      r0,[r4,#0x24]
;;;5335   
;;;5336           /* Update counter */
;;;5337           hi2c->XferCount--;
0000ce  8d60              LDRH     r0,[r4,#0x2a]
0000d0  1e40              SUBS     r0,r0,#1
0000d2  8560              STRH     r0,[r4,#0x2a]
                  |L61.212|
;;;5338         }
;;;5339       }
;;;5340     }
;;;5341     else
;;;5342     {
;;;5343       /* Do nothing */
;;;5344     }
;;;5345   }
0000d4  e8bd81f0          POP      {r4-r8,pc}
;;;5346   
                          ENDP


                          AREA ||i.I2C_Master_ADD10||, CODE, READONLY, ALIGN=1

                  I2C_Master_ADD10 PROC
;;;5812     */
;;;5813   static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
000000  6c41              LDR      r1,[r0,#0x44]
;;;5814   {
;;;5815     /* Send slave address */
;;;5816     hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
000002  b2c9              UXTB     r1,r1
000004  6802              LDR      r2,[r0,#0]
000006  6111              STR      r1,[r2,#0x10]
;;;5817   
;;;5818     if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
000008  6b41              LDR      r1,[r0,#0x34]
00000a  b111              CBZ      r1,|L62.18|
00000c  6b41              LDR      r1,[r0,#0x34]
00000e  6bc9              LDR      r1,[r1,#0x3c]
000010  b921              CBNZ     r1,|L62.28|
                  |L62.18|
;;;5819         || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
000012  6b81              LDR      r1,[r0,#0x38]
000014  b141              CBZ      r1,|L62.40|
000016  6b81              LDR      r1,[r0,#0x38]
000018  6bc9              LDR      r1,[r1,#0x3c]
00001a  b129              CBZ      r1,|L62.40|
                  |L62.28|
;;;5820     {
;;;5821       /* Enable DMA Request */
;;;5822       SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
00001c  6801              LDR      r1,[r0,#0]
00001e  6849              LDR      r1,[r1,#4]
000020  f4416100          ORR      r1,r1,#0x800
000024  6802              LDR      r2,[r0,#0]
000026  6051              STR      r1,[r2,#4]
                  |L62.40|
;;;5823     }
;;;5824   }
000028  4770              BX       lr
;;;5825   
                          ENDP


                          AREA ||i.I2C_Master_ADDR||, CODE, READONLY, ALIGN=1

                  I2C_Master_ADDR PROC
;;;5831     */
;;;5832   static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
000000  b538              PUSH     {r3-r5,lr}
;;;5833   {
;;;5834     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;5835     HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
000002  f890203e          LDRB     r2,[r0,#0x3e]
;;;5836     uint32_t CurrentXferOptions           = hi2c->XferOptions;
000006  6ac1              LDR      r1,[r0,#0x2c]
;;;5837     uint32_t Prev_State                   = hi2c->PreviousState;
000008  6b03              LDR      r3,[r0,#0x30]
;;;5838   
;;;5839     if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
00000a  f890403d          LDRB     r4,[r0,#0x3d]
00000e  2c22              CMP      r4,#0x22
000010  d173              BNE      |L63.250|
;;;5840     {
;;;5841       if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
000012  6d04              LDR      r4,[r0,#0x50]
000014  b964              CBNZ     r4,|L63.48|
000016  2a40              CMP      r2,#0x40
000018  d10a              BNE      |L63.48|
;;;5842       {
;;;5843         /* Clear ADDR flag */
;;;5844         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00001a  bf00              NOP      
00001c  2400              MOVS     r4,#0
00001e  9400              STR      r4,[sp,#0]
000020  6804              LDR      r4,[r0,#0]
000022  6964              LDR      r4,[r4,#0x14]
000024  9400              STR      r4,[sp,#0]
000026  6804              LDR      r4,[r0,#0]
000028  69a4              LDR      r4,[r4,#0x18]
00002a  9400              STR      r4,[sp,#0]
00002c  bf00              NOP      
00002e  e11a              B        |L63.614|
                  |L63.48|
;;;5845       }
;;;5846       else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
000030  6d04              LDR      r4,[r0,#0x50]
000032  b9c4              CBNZ     r4,|L63.102|
000034  6904              LDR      r4,[r0,#0x10]
000036  f5b44f40          CMP      r4,#0xc000
00003a  d114              BNE      |L63.102|
;;;5847       {
;;;5848         /* Clear ADDR flag */
;;;5849         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00003c  bf00              NOP      
00003e  2400              MOVS     r4,#0
000040  9400              STR      r4,[sp,#0]
000042  6804              LDR      r4,[r0,#0]
000044  6964              LDR      r4,[r4,#0x14]
000046  9400              STR      r4,[sp,#0]
000048  6804              LDR      r4,[r0,#0]
00004a  69a4              LDR      r4,[r4,#0x18]
00004c  9400              STR      r4,[sp,#0]
00004e  bf00              NOP      
000050  bf00              NOP      
;;;5850   
;;;5851         /* Generate Restart */
;;;5852         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000052  6804              LDR      r4,[r0,#0]
000054  6824              LDR      r4,[r4,#0]
000056  f4447480          ORR      r4,r4,#0x100
00005a  6805              LDR      r5,[r0,#0]
00005c  602c              STR      r4,[r5,#0]
;;;5853   
;;;5854         hi2c->EventCount++;
00005e  6d04              LDR      r4,[r0,#0x50]
000060  1c64              ADDS     r4,r4,#1
000062  6504              STR      r4,[r0,#0x50]
000064  e0ff              B        |L63.614|
                  |L63.102|
;;;5855       }
;;;5856       else
;;;5857       {
;;;5858         if (hi2c->XferCount == 0U)
000066  8d44              LDRH     r4,[r0,#0x2a]
000068  b98c              CBNZ     r4,|L63.142|
;;;5859         {
;;;5860           /* Clear ADDR flag */
;;;5861           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00006a  bf00              NOP      
00006c  2400              MOVS     r4,#0
00006e  9400              STR      r4,[sp,#0]
000070  6804              LDR      r4,[r0,#0]
000072  6964              LDR      r4,[r4,#0x14]
000074  9400              STR      r4,[sp,#0]
000076  6804              LDR      r4,[r0,#0]
000078  69a4              LDR      r4,[r4,#0x18]
00007a  9400              STR      r4,[sp,#0]
00007c  bf00              NOP      
00007e  bf00              NOP      
;;;5862   
;;;5863           /* Generate Stop */
;;;5864           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000080  6804              LDR      r4,[r0,#0]
000082  6824              LDR      r4,[r4,#0]
000084  f4447400          ORR      r4,r4,#0x200
000088  6805              LDR      r5,[r0,#0]
00008a  602c              STR      r4,[r5,#0]
00008c  e0dd              B        |L63.586|
                  |L63.142|
;;;5865         }
;;;5866         else if (hi2c->XferCount == 1U)
00008e  8d44              LDRH     r4,[r0,#0x2a]
000090  2c01              CMP      r4,#1
000092  d172              BNE      |L63.378|
;;;5867         {
;;;5868           if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
000094  f5113f80          CMN      r1,#0x10000
000098  d130              BNE      |L63.252|
;;;5869           {
;;;5870             /* Disable Acknowledge */
;;;5871             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00009a  6804              LDR      r4,[r0,#0]
00009c  6824              LDR      r4,[r4,#0]
00009e  f4246480          BIC      r4,r4,#0x400
0000a2  6805              LDR      r5,[r0,#0]
0000a4  602c              STR      r4,[r5,#0]
;;;5872   
;;;5873             if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
0000a6  6804              LDR      r4,[r0,#0]
0000a8  6864              LDR      r4,[r4,#4]
0000aa  f4046400          AND      r4,r4,#0x800
0000ae  f5b46f00          CMP      r4,#0x800
0000b2  d110              BNE      |L63.214|
;;;5874             {
;;;5875               /* Disable Acknowledge */
;;;5876               CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0000b4  6804              LDR      r4,[r0,#0]
0000b6  6824              LDR      r4,[r4,#0]
0000b8  f4246480          BIC      r4,r4,#0x400
0000bc  6805              LDR      r5,[r0,#0]
0000be  602c              STR      r4,[r5,#0]
;;;5877   
;;;5878               /* Clear ADDR flag */
;;;5879               __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0000c0  bf00              NOP      
0000c2  2400              MOVS     r4,#0
0000c4  9400              STR      r4,[sp,#0]
0000c6  6804              LDR      r4,[r0,#0]
0000c8  6964              LDR      r4,[r4,#0x14]
0000ca  9400              STR      r4,[sp,#0]
0000cc  6804              LDR      r4,[r0,#0]
0000ce  69a4              LDR      r4,[r4,#0x18]
0000d0  9400              STR      r4,[sp,#0]
0000d2  bf00              NOP      
0000d4  e0b9              B        |L63.586|
                  |L63.214|
;;;5880             }
;;;5881             else
;;;5882             {
;;;5883               /* Clear ADDR flag */
;;;5884               __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0000d6  bf00              NOP      
0000d8  2400              MOVS     r4,#0
0000da  9400              STR      r4,[sp,#0]
0000dc  6804              LDR      r4,[r0,#0]
0000de  6964              LDR      r4,[r4,#0x14]
0000e0  9400              STR      r4,[sp,#0]
0000e2  6804              LDR      r4,[r0,#0]
0000e4  69a4              LDR      r4,[r4,#0x18]
0000e6  9400              STR      r4,[sp,#0]
0000e8  bf00              NOP      
0000ea  bf00              NOP      
;;;5885   
;;;5886               /* Generate Stop */
;;;5887               SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000ec  6804              LDR      r4,[r0,#0]
0000ee  6824              LDR      r4,[r4,#0]
0000f0  f4447400          ORR      r4,r4,#0x200
0000f4  6805              LDR      r5,[r0,#0]
0000f6  602c              STR      r4,[r5,#0]
0000f8  e0a7              B        |L63.586|
                  |L63.250|
0000fa  e0a9              B        |L63.592|
                  |L63.252|
;;;5888             }
;;;5889           }
;;;5890           /* Prepare next transfer or stop current transfer */
;;;5891           else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
0000fc  2908              CMP      r1,#8
0000fe  d023              BEQ      |L63.328|
000100  2920              CMP      r1,#0x20
000102  d021              BEQ      |L63.328|
;;;5892                    && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
000104  2b12              CMP      r3,#0x12
000106  d101              BNE      |L63.268|
000108  2901              CMP      r1,#1
00010a  d11d              BNE      |L63.328|
                  |L63.268|
;;;5893           {
;;;5894             if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
00010c  2904              CMP      r1,#4
00010e  d00a              BEQ      |L63.294|
000110  2902              CMP      r1,#2
000112  d008              BEQ      |L63.294|
000114  2910              CMP      r1,#0x10
000116  d006              BEQ      |L63.294|
;;;5895             {
;;;5896               /* Disable Acknowledge */
;;;5897               CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000118  6804              LDR      r4,[r0,#0]
00011a  6824              LDR      r4,[r4,#0]
00011c  f4246480          BIC      r4,r4,#0x400
000120  6805              LDR      r5,[r0,#0]
000122  602c              STR      r4,[r5,#0]
000124  e005              B        |L63.306|
                  |L63.294|
;;;5898             }
;;;5899             else
;;;5900             {
;;;5901               /* Enable Acknowledge */
;;;5902               SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000126  6804              LDR      r4,[r0,#0]
000128  6824              LDR      r4,[r4,#0]
00012a  f4446480          ORR      r4,r4,#0x400
00012e  6805              LDR      r5,[r0,#0]
000130  602c              STR      r4,[r5,#0]
                  |L63.306|
;;;5903             }
;;;5904   
;;;5905             /* Clear ADDR flag */
;;;5906             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000132  bf00              NOP      
000134  2400              MOVS     r4,#0
000136  9400              STR      r4,[sp,#0]
000138  6804              LDR      r4,[r0,#0]
00013a  6964              LDR      r4,[r4,#0x14]
00013c  9400              STR      r4,[sp,#0]
00013e  6804              LDR      r4,[r0,#0]
000140  69a4              LDR      r4,[r4,#0x18]
000142  9400              STR      r4,[sp,#0]
000144  bf00              NOP      
000146  e080              B        |L63.586|
                  |L63.328|
;;;5907           }
;;;5908           else
;;;5909           {
;;;5910             /* Disable Acknowledge */
;;;5911             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000148  6804              LDR      r4,[r0,#0]
00014a  6824              LDR      r4,[r4,#0]
00014c  f4246480          BIC      r4,r4,#0x400
000150  6805              LDR      r5,[r0,#0]
000152  602c              STR      r4,[r5,#0]
;;;5912   
;;;5913             /* Clear ADDR flag */
;;;5914             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000154  bf00              NOP      
000156  2400              MOVS     r4,#0
000158  9400              STR      r4,[sp,#0]
00015a  6804              LDR      r4,[r0,#0]
00015c  6964              LDR      r4,[r4,#0x14]
00015e  9400              STR      r4,[sp,#0]
000160  6804              LDR      r4,[r0,#0]
000162  69a4              LDR      r4,[r4,#0x18]
000164  9400              STR      r4,[sp,#0]
000166  bf00              NOP      
000168  bf00              NOP      
;;;5915   
;;;5916             /* Generate Stop */
;;;5917             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00016a  6804              LDR      r4,[r0,#0]
00016c  6824              LDR      r4,[r4,#0]
00016e  f4447400          ORR      r4,r4,#0x200
000172  6805              LDR      r5,[r0,#0]
000174  602c              STR      r4,[r5,#0]
000176  e068              B        |L63.586|
000178  e7ff              B        |L63.378|
                  |L63.378|
;;;5918           }
;;;5919         }
;;;5920         else if (hi2c->XferCount == 2U)
00017a  8d44              LDRH     r4,[r0,#0x2a]
00017c  2c02              CMP      r4,#2
00017e  d13b              BNE      |L63.504|
;;;5921         {
;;;5922           if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
000180  2904              CMP      r1,#4
000182  d010              BEQ      |L63.422|
000184  2902              CMP      r1,#2
000186  d00e              BEQ      |L63.422|
000188  2910              CMP      r1,#0x10
00018a  d00c              BEQ      |L63.422|
;;;5923           {
;;;5924             /* Disable Acknowledge */
;;;5925             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00018c  6804              LDR      r4,[r0,#0]
00018e  6824              LDR      r4,[r4,#0]
000190  f4246480          BIC      r4,r4,#0x400
000194  6805              LDR      r5,[r0,#0]
000196  602c              STR      r4,[r5,#0]
;;;5926   
;;;5927             /* Enable Pos */
;;;5928             SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
000198  6804              LDR      r4,[r0,#0]
00019a  6824              LDR      r4,[r4,#0]
00019c  f4446400          ORR      r4,r4,#0x800
0001a0  6805              LDR      r5,[r0,#0]
0001a2  602c              STR      r4,[r5,#0]
0001a4  e005              B        |L63.434|
                  |L63.422|
;;;5929           }
;;;5930           else
;;;5931           {
;;;5932             /* Enable Acknowledge */
;;;5933             SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0001a6  6804              LDR      r4,[r0,#0]
0001a8  6824              LDR      r4,[r4,#0]
0001aa  f4446480          ORR      r4,r4,#0x400
0001ae  6805              LDR      r5,[r0,#0]
0001b0  602c              STR      r4,[r5,#0]
                  |L63.434|
;;;5934           }
;;;5935   
;;;5936           if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
0001b2  6804              LDR      r4,[r0,#0]
0001b4  6864              LDR      r4,[r4,#4]
0001b6  f4046400          AND      r4,r4,#0x800
0001ba  f5b46f00          CMP      r4,#0x800
0001be  d110              BNE      |L63.482|
0001c0  f5113f80          CMN      r1,#0x10000
0001c4  d007              BEQ      |L63.470|
0001c6  2901              CMP      r1,#1
0001c8  d005              BEQ      |L63.470|
0001ca  2908              CMP      r1,#8
0001cc  d003              BEQ      |L63.470|
0001ce  2910              CMP      r1,#0x10
0001d0  d001              BEQ      |L63.470|
0001d2  2920              CMP      r1,#0x20
0001d4  d105              BNE      |L63.482|
                  |L63.470|
;;;5937           {
;;;5938             /* Enable Last DMA bit */
;;;5939             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
0001d6  6804              LDR      r4,[r0,#0]
0001d8  6864              LDR      r4,[r4,#4]
0001da  f4445480          ORR      r4,r4,#0x1000
0001de  6805              LDR      r5,[r0,#0]
0001e0  606c              STR      r4,[r5,#4]
                  |L63.482|
;;;5940           }
;;;5941   
;;;5942           /* Clear ADDR flag */
;;;5943           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0001e2  bf00              NOP      
0001e4  2400              MOVS     r4,#0
0001e6  9400              STR      r4,[sp,#0]
0001e8  6804              LDR      r4,[r0,#0]
0001ea  6964              LDR      r4,[r4,#0x14]
0001ec  9400              STR      r4,[sp,#0]
0001ee  6804              LDR      r4,[r0,#0]
0001f0  69a4              LDR      r4,[r4,#0x18]
0001f2  9400              STR      r4,[sp,#0]
0001f4  bf00              NOP      
0001f6  e028              B        |L63.586|
                  |L63.504|
;;;5944         }
;;;5945         else
;;;5946         {
;;;5947           /* Enable Acknowledge */
;;;5948           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0001f8  6804              LDR      r4,[r0,#0]
0001fa  6824              LDR      r4,[r4,#0]
0001fc  f4446480          ORR      r4,r4,#0x400
000200  6805              LDR      r5,[r0,#0]
000202  602c              STR      r4,[r5,#0]
;;;5949   
;;;5950           if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
000204  6804              LDR      r4,[r0,#0]
000206  6864              LDR      r4,[r4,#4]
000208  f4046400          AND      r4,r4,#0x800
00020c  f5b46f00          CMP      r4,#0x800
000210  d110              BNE      |L63.564|
000212  f5113f80          CMN      r1,#0x10000
000216  d007              BEQ      |L63.552|
000218  2901              CMP      r1,#1
00021a  d005              BEQ      |L63.552|
00021c  2908              CMP      r1,#8
00021e  d003              BEQ      |L63.552|
000220  2910              CMP      r1,#0x10
000222  d001              BEQ      |L63.552|
000224  2920              CMP      r1,#0x20
000226  d105              BNE      |L63.564|
                  |L63.552|
;;;5951           {
;;;5952             /* Enable Last DMA bit */
;;;5953             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
000228  6804              LDR      r4,[r0,#0]
00022a  6864              LDR      r4,[r4,#4]
00022c  f4445480          ORR      r4,r4,#0x1000
000230  6805              LDR      r5,[r0,#0]
000232  606c              STR      r4,[r5,#4]
                  |L63.564|
;;;5954           }
;;;5955   
;;;5956           /* Clear ADDR flag */
;;;5957           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000234  bf00              NOP      
000236  2400              MOVS     r4,#0
000238  9400              STR      r4,[sp,#0]
00023a  6804              LDR      r4,[r0,#0]
00023c  6964              LDR      r4,[r4,#0x14]
00023e  9400              STR      r4,[sp,#0]
000240  6804              LDR      r4,[r0,#0]
000242  69a4              LDR      r4,[r4,#0x18]
000244  9400              STR      r4,[sp,#0]
000246  bf00              NOP      
000248  bf00              NOP      
                  |L63.586|
;;;5958         }
;;;5959   
;;;5960         /* Reset Event counter  */
;;;5961         hi2c->EventCount = 0U;
00024a  2400              MOVS     r4,#0
00024c  6504              STR      r4,[r0,#0x50]
00024e  e00a              B        |L63.614|
                  |L63.592|
;;;5962       }
;;;5963     }
;;;5964     else
;;;5965     {
;;;5966       /* Clear ADDR flag */
;;;5967       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000250  bf00              NOP      
000252  2400              MOVS     r4,#0
000254  9400              STR      r4,[sp,#0]
000256  6804              LDR      r4,[r0,#0]
000258  6964              LDR      r4,[r4,#0x14]
00025a  9400              STR      r4,[sp,#0]
00025c  6804              LDR      r4,[r0,#0]
00025e  69a4              LDR      r4,[r4,#0x18]
000260  9400              STR      r4,[sp,#0]
000262  bf00              NOP      
000264  bf00              NOP      
                  |L63.614|
;;;5968     }
;;;5969   }
000266  bd38              POP      {r3-r5,pc}
;;;5970   
                          ENDP


                          AREA ||i.I2C_Master_SB||, CODE, READONLY, ALIGN=1

                  I2C_Master_SB PROC
;;;5751     */
;;;5752   static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
000000  f890103e          LDRB     r1,[r0,#0x3e]
;;;5753   {
;;;5754     if (hi2c->Mode == HAL_I2C_MODE_MEM)
000004  2940              CMP      r1,#0x40
000006  d10e              BNE      |L64.38|
;;;5755     {
;;;5756       if (hi2c->EventCount == 0U)
000008  6d01              LDR      r1,[r0,#0x50]
00000a  b929              CBNZ     r1,|L64.24|
;;;5757       {
;;;5758         /* Send slave address */
;;;5759         hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
00000c  6c41              LDR      r1,[r0,#0x44]
00000e  f00101fe          AND      r1,r1,#0xfe
000012  6802              LDR      r2,[r0,#0]
000014  6111              STR      r1,[r2,#0x10]
000016  e041              B        |L64.156|
                  |L64.24|
;;;5760       }
;;;5761       else
;;;5762       {
;;;5763         hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
000018  6c41              LDR      r1,[r0,#0x44]
00001a  b2c9              UXTB     r1,r1
00001c  f0410101          ORR      r1,r1,#1
000020  6802              LDR      r2,[r0,#0]
000022  6111              STR      r1,[r2,#0x10]
000024  e03a              B        |L64.156|
                  |L64.38|
;;;5764       }
;;;5765     }
;;;5766     else
;;;5767     {
;;;5768       if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
000026  6901              LDR      r1,[r0,#0x10]
000028  f5b14f80          CMP      r1,#0x4000
00002c  d120              BNE      |L64.112|
;;;5769       {
;;;5770         /* Send slave 7 Bits address */
;;;5771         if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
00002e  f890103d          LDRB     r1,[r0,#0x3d]
000032  2921              CMP      r1,#0x21
000034  d105              BNE      |L64.66|
;;;5772         {
;;;5773           hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
000036  6c41              LDR      r1,[r0,#0x44]
000038  f00101fe          AND      r1,r1,#0xfe
00003c  6802              LDR      r2,[r0,#0]
00003e  6111              STR      r1,[r2,#0x10]
000040  e005              B        |L64.78|
                  |L64.66|
;;;5774         }
;;;5775         else
;;;5776         {
;;;5777           hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
000042  6c41              LDR      r1,[r0,#0x44]
000044  b2c9              UXTB     r1,r1
000046  f0410101          ORR      r1,r1,#1
00004a  6802              LDR      r2,[r0,#0]
00004c  6111              STR      r1,[r2,#0x10]
                  |L64.78|
;;;5778         }
;;;5779   
;;;5780         if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
00004e  6b41              LDR      r1,[r0,#0x34]
000050  b111              CBZ      r1,|L64.88|
000052  6b41              LDR      r1,[r0,#0x34]
000054  6bc9              LDR      r1,[r1,#0x3c]
000056  b921              CBNZ     r1,|L64.98|
                  |L64.88|
;;;5781             || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
000058  6b81              LDR      r1,[r0,#0x38]
00005a  b1f9              CBZ      r1,|L64.156|
00005c  6b81              LDR      r1,[r0,#0x38]
00005e  6bc9              LDR      r1,[r1,#0x3c]
000060  b1e1              CBZ      r1,|L64.156|
                  |L64.98|
;;;5782         {
;;;5783           /* Enable DMA Request */
;;;5784           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000062  6801              LDR      r1,[r0,#0]
000064  6849              LDR      r1,[r1,#4]
000066  f4416100          ORR      r1,r1,#0x800
00006a  6802              LDR      r2,[r0,#0]
00006c  6051              STR      r1,[r2,#4]
00006e  e015              B        |L64.156|
                  |L64.112|
;;;5785         }
;;;5786       }
;;;5787       else
;;;5788       {
;;;5789         if (hi2c->EventCount == 0U)
000070  6d01              LDR      r1,[r0,#0x50]
000072  b941              CBNZ     r1,|L64.134|
;;;5790         {
;;;5791           /* Send header of slave address */
;;;5792           hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
000074  6c41              LDR      r1,[r0,#0x44]
000076  f4017140          AND      r1,r1,#0x300
00007a  22f0              MOVS     r2,#0xf0
00007c  ea4211e1          ORR      r1,r2,r1,ASR #7
000080  6802              LDR      r2,[r0,#0]
000082  6111              STR      r1,[r2,#0x10]
000084  e00a              B        |L64.156|
                  |L64.134|
;;;5793         }
;;;5794         else if (hi2c->EventCount == 1U)
000086  6d01              LDR      r1,[r0,#0x50]
000088  2901              CMP      r1,#1
00008a  d107              BNE      |L64.156|
;;;5795         {
;;;5796           /* Send header of slave address */
;;;5797           hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
00008c  6c41              LDR      r1,[r0,#0x44]
00008e  f4017140          AND      r1,r1,#0x300
000092  22f1              MOVS     r2,#0xf1
000094  ea4211e1          ORR      r1,r2,r1,ASR #7
000098  6802              LDR      r2,[r0,#0]
00009a  6111              STR      r1,[r2,#0x10]
                  |L64.156|
;;;5798         }
;;;5799         else
;;;5800         {
;;;5801           /* Do nothing */
;;;5802         }
;;;5803       }
;;;5804     }
;;;5805   }
00009c  4770              BX       lr
;;;5806   
                          ENDP


                          AREA ||i.I2C_MemoryTransmit_TXE_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MemoryTransmit_TXE_BTF PROC
;;;5431     */
;;;5432   static void I2C_MemoryTransmit_TXE_BTF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5433   {
000002  4604              MOV      r4,r0
;;;5434     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5435     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;5436   
;;;5437     if (hi2c->EventCount == 0U)
000008  6d20              LDR      r0,[r4,#0x50]
00000a  b998              CBNZ     r0,|L65.52|
;;;5438     {
;;;5439       /* If Memory address size is 8Bit */
;;;5440       if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
00000c  6ce0              LDR      r0,[r4,#0x4c]
00000e  2801              CMP      r0,#1
000010  d107              BNE      |L65.34|
;;;5441       {
;;;5442         /* Send Memory Address */
;;;5443         hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
000012  6ca0              LDR      r0,[r4,#0x48]
000014  b2c0              UXTB     r0,r0
000016  6821              LDR      r1,[r4,#0]
000018  6108              STR      r0,[r1,#0x10]
;;;5444   
;;;5445         hi2c->EventCount += 2U;
00001a  6d20              LDR      r0,[r4,#0x50]
00001c  1c80              ADDS     r0,r0,#2
00001e  6520              STR      r0,[r4,#0x50]
000020  e04c              B        |L65.188|
                  |L65.34|
;;;5446       }
;;;5447       /* If Memory address size is 16Bit */
;;;5448       else
;;;5449       {
;;;5450         /* Send MSB of Memory Address */
;;;5451         hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
000022  6ca0              LDR      r0,[r4,#0x48]
000024  f3c02007          UBFX     r0,r0,#8,#8
000028  6821              LDR      r1,[r4,#0]
00002a  6108              STR      r0,[r1,#0x10]
;;;5452   
;;;5453         hi2c->EventCount++;
00002c  6d20              LDR      r0,[r4,#0x50]
00002e  1c40              ADDS     r0,r0,#1
000030  6520              STR      r0,[r4,#0x50]
000032  e043              B        |L65.188|
                  |L65.52|
;;;5454       }
;;;5455     }
;;;5456     else if (hi2c->EventCount == 1U)
000034  6d20              LDR      r0,[r4,#0x50]
000036  2801              CMP      r0,#1
000038  d107              BNE      |L65.74|
;;;5457     {
;;;5458       /* Send LSB of Memory Address */
;;;5459       hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
00003a  6ca0              LDR      r0,[r4,#0x48]
00003c  b2c0              UXTB     r0,r0
00003e  6821              LDR      r1,[r4,#0]
000040  6108              STR      r0,[r1,#0x10]
;;;5460   
;;;5461       hi2c->EventCount++;
000042  6d20              LDR      r0,[r4,#0x50]
000044  1c40              ADDS     r0,r0,#1
000046  6520              STR      r0,[r4,#0x50]
000048  e038              B        |L65.188|
                  |L65.74|
;;;5462     }
;;;5463     else if (hi2c->EventCount == 2U)
00004a  6d20              LDR      r0,[r4,#0x50]
00004c  2802              CMP      r0,#2
00004e  d135              BNE      |L65.188|
;;;5464     {
;;;5465       if (CurrentState == HAL_I2C_STATE_BUSY_RX)
000050  2d22              CMP      r5,#0x22
000052  d109              BNE      |L65.104|
;;;5466       {
;;;5467         /* Generate Restart */
;;;5468         hi2c->Instance->CR1 |= I2C_CR1_START;
000054  6820              LDR      r0,[r4,#0]
000056  6800              LDR      r0,[r0,#0]
000058  f4407080          ORR      r0,r0,#0x100
00005c  6821              LDR      r1,[r4,#0]
00005e  6008              STR      r0,[r1,#0]
;;;5469   
;;;5470         hi2c->EventCount++;
000060  6d20              LDR      r0,[r4,#0x50]
000062  1c40              ADDS     r0,r0,#1
000064  6520              STR      r0,[r4,#0x50]
000066  e029              B        |L65.188|
                  |L65.104|
;;;5471       }
;;;5472       else if ((hi2c->XferCount > 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
000068  8d60              LDRH     r0,[r4,#0x2a]
00006a  b160              CBZ      r0,|L65.134|
00006c  2d21              CMP      r5,#0x21
00006e  d10a              BNE      |L65.134|
;;;5473       {
;;;5474         /* Write data to DR */
;;;5475         hi2c->Instance->DR = *hi2c->pBuffPtr;
000070  6a60              LDR      r0,[r4,#0x24]
000072  7800              LDRB     r0,[r0,#0]
000074  6821              LDR      r1,[r4,#0]
000076  6108              STR      r0,[r1,#0x10]
;;;5476   
;;;5477         /* Increment Buffer pointer */
;;;5478         hi2c->pBuffPtr++;
000078  6a60              LDR      r0,[r4,#0x24]
00007a  1c40              ADDS     r0,r0,#1
00007c  6260              STR      r0,[r4,#0x24]
;;;5479   
;;;5480         /* Update counter */
;;;5481         hi2c->XferCount--;
00007e  8d60              LDRH     r0,[r4,#0x2a]
000080  1e40              SUBS     r0,r0,#1
000082  8560              STRH     r0,[r4,#0x2a]
000084  e01a              B        |L65.188|
                  |L65.134|
;;;5482       }
;;;5483       else if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
000086  8d60              LDRH     r0,[r4,#0x2a]
000088  b9c0              CBNZ     r0,|L65.188|
00008a  2d21              CMP      r5,#0x21
00008c  d116              BNE      |L65.188|
;;;5484       {
;;;5485         /* Generate Stop condition then Call TxCpltCallback() */
;;;5486         /* Disable EVT, BUF and ERR interrupt */
;;;5487         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00008e  6820              LDR      r0,[r4,#0]
000090  6840              LDR      r0,[r0,#4]
000092  f42060e0          BIC      r0,r0,#0x700
000096  6821              LDR      r1,[r4,#0]
000098  6048              STR      r0,[r1,#4]
;;;5488   
;;;5489         /* Generate Stop */
;;;5490         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00009a  6820              LDR      r0,[r4,#0]
00009c  6800              LDR      r0,[r0,#0]
00009e  f4407000          ORR      r0,r0,#0x200
0000a2  6821              LDR      r1,[r4,#0]
0000a4  6008              STR      r0,[r1,#0]
;;;5491   
;;;5492         hi2c->PreviousState = I2C_STATE_NONE;
0000a6  2000              MOVS     r0,#0
0000a8  6320              STR      r0,[r4,#0x30]
;;;5493         hi2c->State = HAL_I2C_STATE_READY;
0000aa  2020              MOVS     r0,#0x20
0000ac  f884003d          STRB     r0,[r4,#0x3d]
;;;5494         hi2c->Mode = HAL_I2C_MODE_NONE;
0000b0  2000              MOVS     r0,#0
0000b2  f884003e          STRB     r0,[r4,#0x3e]
;;;5495   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5496         hi2c->MemTxCpltCallback(hi2c);
;;;5497   #else
;;;5498         HAL_I2C_MemTxCpltCallback(hi2c);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
                  |L65.188|
;;;5499   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5500       }
;;;5501       else
;;;5502       {
;;;5503         /* Do nothing */
;;;5504       }
;;;5505     }
;;;5506     else
;;;5507     {
;;;5508       /* Do nothing */
;;;5509     }
;;;5510   }
0000bc  bd70              POP      {r4-r6,pc}
;;;5511   
                          ENDP


                          AREA ||i.I2C_RequestMemoryRead||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryRead PROC
;;;6803     */
;;;6804   static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6805   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
00000c  e9dd8608          LDRD     r8,r6,[sp,#0x20]
;;;6806     /* Enable Acknowledge */
;;;6807     SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f4406080          ORR      r0,r0,#0x400
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;6808   
;;;6809     /* Generate Start */
;;;6810     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00001c  6820              LDR      r0,[r4,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  f4407080          ORR      r0,r0,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  6008              STR      r0,[r1,#0]
;;;6811   
;;;6812     /* Wait until SB flag is set */
;;;6813     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
000028  4643              MOV      r3,r8
00002a  2200              MOVS     r2,#0
00002c  f04f1101          MOV      r1,#0x10001
000030  4620              MOV      r0,r4
000032  9600              STR      r6,[sp,#0]
000034  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000038  b160              CBZ      r0,|L66.84|
;;;6814     {
;;;6815       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
00003a  6820              LDR      r0,[r4,#0]
00003c  6800              LDR      r0,[r0,#0]
00003e  f4007080          AND      r0,r0,#0x100
000042  f5b07f80          CMP      r0,#0x100
000046  d102              BNE      |L66.78|
;;;6816       {
;;;6817         hi2c->ErrorCode = HAL_I2C_WRONG_START;
000048  f44f7000          MOV      r0,#0x200
00004c  6420              STR      r0,[r4,#0x40]
                  |L66.78|
;;;6818       }
;;;6819       return HAL_TIMEOUT;
00004e  2003              MOVS     r0,#3
                  |L66.80|
;;;6820     }
;;;6821   
;;;6822     /* Send slave address */
;;;6823     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;6824   
;;;6825     /* Wait until ADDR flag is set */
;;;6826     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6827     {
;;;6828       return HAL_ERROR;
;;;6829     }
;;;6830   
;;;6831     /* Clear ADDR flag */
;;;6832     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;6833   
;;;6834     /* Wait until TXE flag is set */
;;;6835     if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6836     {
;;;6837       if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6838       {
;;;6839         /* Generate Stop */
;;;6840         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6841       }
;;;6842       return HAL_ERROR;
;;;6843     }
;;;6844   
;;;6845     /* If Memory address size is 8Bit */
;;;6846     if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;6847     {
;;;6848       /* Send Memory Address */
;;;6849       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6850     }
;;;6851     /* If Memory address size is 16Bit */
;;;6852     else
;;;6853     {
;;;6854       /* Send MSB of Memory Address */
;;;6855       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;6856   
;;;6857       /* Wait until TXE flag is set */
;;;6858       if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6859       {
;;;6860         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6861         {
;;;6862           /* Generate Stop */
;;;6863           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6864         }
;;;6865         return HAL_ERROR;
;;;6866       }
;;;6867   
;;;6868       /* Send LSB of Memory Address */
;;;6869       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6870     }
;;;6871   
;;;6872     /* Wait until TXE flag is set */
;;;6873     if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6874     {
;;;6875       if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6876       {
;;;6877         /* Generate Stop */
;;;6878         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6879       }
;;;6880       return HAL_ERROR;
;;;6881     }
;;;6882   
;;;6883     /* Generate Restart */
;;;6884     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;6885   
;;;6886     /* Wait until SB flag is set */
;;;6887     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
;;;6888     {
;;;6889       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
;;;6890       {
;;;6891         hi2c->ErrorCode = HAL_I2C_WRONG_START;
;;;6892       }
;;;6893       return HAL_TIMEOUT;
;;;6894     }
;;;6895   
;;;6896     /* Send slave address */
;;;6897     hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;6898   
;;;6899     /* Wait until ADDR flag is set */
;;;6900     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6901     {
;;;6902       return HAL_ERROR;
;;;6903     }
;;;6904   
;;;6905     return HAL_OK;
;;;6906   }
000050  e8bd83f8          POP      {r3-r9,pc}
                  |L66.84|
000054  f00700fe          AND      r0,r7,#0xfe           ;6823
000058  6821              LDR      r1,[r4,#0]            ;6823
00005a  6108              STR      r0,[r1,#0x10]         ;6823
00005c  4633              MOV      r3,r6                 ;6826
00005e  4642              MOV      r2,r8                 ;6826
000060  493e              LDR      r1,|L66.348|
000062  4620              MOV      r0,r4                 ;6826
000064  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000068  b108              CBZ      r0,|L66.110|
00006a  2001              MOVS     r0,#1                 ;6828
00006c  e7f0              B        |L66.80|
                  |L66.110|
00006e  bf00              NOP                            ;6832
000070  2000              MOVS     r0,#0                 ;6832
000072  9000              STR      r0,[sp,#0]            ;6832
000074  6820              LDR      r0,[r4,#0]            ;6832
000076  6940              LDR      r0,[r0,#0x14]         ;6832
000078  9000              STR      r0,[sp,#0]            ;6832
00007a  6820              LDR      r0,[r4,#0]            ;6832
00007c  6980              LDR      r0,[r0,#0x18]         ;6832
00007e  9000              STR      r0,[sp,#0]            ;6832
000080  bf00              NOP                            ;6832
000082  bf00              NOP                            ;6832
000084  4632              MOV      r2,r6                 ;6835
000086  4641              MOV      r1,r8                 ;6835
000088  4620              MOV      r0,r4                 ;6835
00008a  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
00008e  b150              CBZ      r0,|L66.166|
000090  6c20              LDR      r0,[r4,#0x40]         ;6837
000092  2804              CMP      r0,#4                 ;6837
000094  d105              BNE      |L66.162|
000096  6820              LDR      r0,[r4,#0]            ;6840
000098  6800              LDR      r0,[r0,#0]            ;6840
00009a  f4407000          ORR      r0,r0,#0x200          ;6840
00009e  6821              LDR      r1,[r4,#0]            ;6840
0000a0  6008              STR      r0,[r1,#0]            ;6840
                  |L66.162|
0000a2  2001              MOVS     r0,#1                 ;6842
0000a4  e7d4              B        |L66.80|
                  |L66.166|
0000a6  f1b90f01          CMP      r9,#1                 ;6846
0000aa  d103              BNE      |L66.180|
0000ac  b2e8              UXTB     r0,r5                 ;6849
0000ae  6821              LDR      r1,[r4,#0]            ;6849
0000b0  6108              STR      r0,[r1,#0x10]         ;6849
0000b2  e017              B        |L66.228|
                  |L66.180|
0000b4  f3c52007          UBFX     r0,r5,#8,#8           ;6855
0000b8  6821              LDR      r1,[r4,#0]            ;6855
0000ba  6108              STR      r0,[r1,#0x10]         ;6855
0000bc  4632              MOV      r2,r6                 ;6858
0000be  4641              MOV      r1,r8                 ;6858
0000c0  4620              MOV      r0,r4                 ;6858
0000c2  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000c6  b150              CBZ      r0,|L66.222|
0000c8  6c20              LDR      r0,[r4,#0x40]         ;6860
0000ca  2804              CMP      r0,#4                 ;6860
0000cc  d105              BNE      |L66.218|
0000ce  6820              LDR      r0,[r4,#0]            ;6863
0000d0  6800              LDR      r0,[r0,#0]            ;6863
0000d2  f4407000          ORR      r0,r0,#0x200          ;6863
0000d6  6821              LDR      r1,[r4,#0]            ;6863
0000d8  6008              STR      r0,[r1,#0]            ;6863
                  |L66.218|
0000da  2001              MOVS     r0,#1                 ;6865
0000dc  e7b8              B        |L66.80|
                  |L66.222|
0000de  b2e8              UXTB     r0,r5                 ;6869
0000e0  6821              LDR      r1,[r4,#0]            ;6869
0000e2  6108              STR      r0,[r1,#0x10]         ;6869
                  |L66.228|
0000e4  4632              MOV      r2,r6                 ;6873
0000e6  4641              MOV      r1,r8                 ;6873
0000e8  4620              MOV      r0,r4                 ;6873
0000ea  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000ee  b150              CBZ      r0,|L66.262|
0000f0  6c20              LDR      r0,[r4,#0x40]         ;6875
0000f2  2804              CMP      r0,#4                 ;6875
0000f4  d105              BNE      |L66.258|
0000f6  6820              LDR      r0,[r4,#0]            ;6878
0000f8  6800              LDR      r0,[r0,#0]            ;6878
0000fa  f4407000          ORR      r0,r0,#0x200          ;6878
0000fe  6821              LDR      r1,[r4,#0]            ;6878
000100  6008              STR      r0,[r1,#0]            ;6878
                  |L66.258|
000102  2001              MOVS     r0,#1                 ;6880
000104  e7a4              B        |L66.80|
                  |L66.262|
000106  6820              LDR      r0,[r4,#0]            ;6884
000108  6800              LDR      r0,[r0,#0]            ;6884
00010a  f4407080          ORR      r0,r0,#0x100          ;6884
00010e  6821              LDR      r1,[r4,#0]            ;6884
000110  6008              STR      r0,[r1,#0]            ;6884
000112  4643              MOV      r3,r8                 ;6887
000114  2200              MOVS     r2,#0                 ;6887
000116  f04f1101          MOV      r1,#0x10001           ;6887
00011a  4620              MOV      r0,r4                 ;6887
00011c  9600              STR      r6,[sp,#0]            ;6887
00011e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000122  b158              CBZ      r0,|L66.316|
000124  6820              LDR      r0,[r4,#0]            ;6889
000126  6800              LDR      r0,[r0,#0]            ;6889
000128  f4007080          AND      r0,r0,#0x100          ;6889
00012c  f5b07f80          CMP      r0,#0x100             ;6889
000130  d102              BNE      |L66.312|
000132  f44f7000          MOV      r0,#0x200             ;6891
000136  6420              STR      r0,[r4,#0x40]         ;6891
                  |L66.312|
000138  2003              MOVS     r0,#3                 ;6893
00013a  e789              B        |L66.80|
                  |L66.316|
00013c  b2f8              UXTB     r0,r7                 ;6897
00013e  f0400001          ORR      r0,r0,#1              ;6897
000142  6821              LDR      r1,[r4,#0]            ;6897
000144  6108              STR      r0,[r1,#0x10]         ;6897
000146  4633              MOV      r3,r6                 ;6900
000148  4642              MOV      r2,r8                 ;6900
00014a  4904              LDR      r1,|L66.348|
00014c  4620              MOV      r0,r4                 ;6900
00014e  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000152  b108              CBZ      r0,|L66.344|
000154  2001              MOVS     r0,#1                 ;6902
000156  e77b              B        |L66.80|
                  |L66.344|
000158  2000              MOVS     r0,#0                 ;6905
00015a  e779              B        |L66.80|
;;;6907   
                          ENDP

                  |L66.348|
                          DCD      0x00010002

                          AREA ||i.I2C_RequestMemoryWrite||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryWrite PROC
;;;6723     */
;;;6724   static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6725   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
00000c  e9dd6708          LDRD     r6,r7,[sp,#0x20]
;;;6726     /* Generate Start */
;;;6727     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f4407080          ORR      r0,r0,#0x100
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;6728   
;;;6729     /* Wait until SB flag is set */
;;;6730     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
00001c  4633              MOV      r3,r6
00001e  2200              MOVS     r2,#0
000020  f04f1101          MOV      r1,#0x10001
000024  4620              MOV      r0,r4
000026  9700              STR      r7,[sp,#0]
000028  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002c  b160              CBZ      r0,|L67.72|
;;;6731     {
;;;6732       if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f4007080          AND      r0,r0,#0x100
000036  f5b07f80          CMP      r0,#0x100
00003a  d102              BNE      |L67.66|
;;;6733       {
;;;6734         hi2c->ErrorCode = HAL_I2C_WRONG_START;
00003c  f44f7000          MOV      r0,#0x200
000040  6420              STR      r0,[r4,#0x40]
                  |L67.66|
;;;6735       }
;;;6736       return HAL_TIMEOUT;
000042  2003              MOVS     r0,#3
                  |L67.68|
;;;6737     }
;;;6738   
;;;6739     /* Send slave address */
;;;6740     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;6741   
;;;6742     /* Wait until ADDR flag is set */
;;;6743     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6744     {
;;;6745       return HAL_ERROR;
;;;6746     }
;;;6747   
;;;6748     /* Clear ADDR flag */
;;;6749     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;6750   
;;;6751     /* Wait until TXE flag is set */
;;;6752     if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6753     {
;;;6754       if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6755       {
;;;6756         /* Generate Stop */
;;;6757         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6758       }
;;;6759       return HAL_ERROR;
;;;6760     }
;;;6761   
;;;6762     /* If Memory address size is 8Bit */
;;;6763     if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;6764     {
;;;6765       /* Send Memory Address */
;;;6766       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6767     }
;;;6768     /* If Memory address size is 16Bit */
;;;6769     else
;;;6770     {
;;;6771       /* Send MSB of Memory Address */
;;;6772       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;6773   
;;;6774       /* Wait until TXE flag is set */
;;;6775       if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6776       {
;;;6777         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6778         {
;;;6779           /* Generate Stop */
;;;6780           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6781         }
;;;6782         return HAL_ERROR;
;;;6783       }
;;;6784   
;;;6785       /* Send LSB of Memory Address */
;;;6786       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6787     }
;;;6788   
;;;6789     return HAL_OK;
;;;6790   }
000044  e8bd83f8          POP      {r3-r9,pc}
                  |L67.72|
000048  f00800fe          AND      r0,r8,#0xfe           ;6740
00004c  6821              LDR      r1,[r4,#0]            ;6740
00004e  6108              STR      r0,[r1,#0x10]         ;6740
000050  463b              MOV      r3,r7                 ;6743
000052  4632              MOV      r2,r6                 ;6743
000054  4921              LDR      r1,|L67.220|
000056  4620              MOV      r0,r4                 ;6743
000058  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00005c  b108              CBZ      r0,|L67.98|
00005e  2001              MOVS     r0,#1                 ;6745
000060  e7f0              B        |L67.68|
                  |L67.98|
000062  bf00              NOP                            ;6749
000064  2000              MOVS     r0,#0                 ;6749
000066  9000              STR      r0,[sp,#0]            ;6749
000068  6820              LDR      r0,[r4,#0]            ;6749
00006a  6940              LDR      r0,[r0,#0x14]         ;6749
00006c  9000              STR      r0,[sp,#0]            ;6749
00006e  6820              LDR      r0,[r4,#0]            ;6749
000070  6980              LDR      r0,[r0,#0x18]         ;6749
000072  9000              STR      r0,[sp,#0]            ;6749
000074  bf00              NOP                            ;6749
000076  bf00              NOP                            ;6749
000078  463a              MOV      r2,r7                 ;6752
00007a  4631              MOV      r1,r6                 ;6752
00007c  4620              MOV      r0,r4                 ;6752
00007e  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
000082  b150              CBZ      r0,|L67.154|
000084  6c20              LDR      r0,[r4,#0x40]         ;6754
000086  2804              CMP      r0,#4                 ;6754
000088  d105              BNE      |L67.150|
00008a  6820              LDR      r0,[r4,#0]            ;6757
00008c  6800              LDR      r0,[r0,#0]            ;6757
00008e  f4407000          ORR      r0,r0,#0x200          ;6757
000092  6821              LDR      r1,[r4,#0]            ;6757
000094  6008              STR      r0,[r1,#0]            ;6757
                  |L67.150|
000096  2001              MOVS     r0,#1                 ;6759
000098  e7d4              B        |L67.68|
                  |L67.154|
00009a  f1b90f01          CMP      r9,#1                 ;6763
00009e  d103              BNE      |L67.168|
0000a0  b2e8              UXTB     r0,r5                 ;6766
0000a2  6821              LDR      r1,[r4,#0]            ;6766
0000a4  6108              STR      r0,[r1,#0x10]         ;6766
0000a6  e017              B        |L67.216|
                  |L67.168|
0000a8  f3c52007          UBFX     r0,r5,#8,#8           ;6772
0000ac  6821              LDR      r1,[r4,#0]            ;6772
0000ae  6108              STR      r0,[r1,#0x10]         ;6772
0000b0  463a              MOV      r2,r7                 ;6775
0000b2  4631              MOV      r1,r6                 ;6775
0000b4  4620              MOV      r0,r4                 ;6775
0000b6  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000ba  b150              CBZ      r0,|L67.210|
0000bc  6c20              LDR      r0,[r4,#0x40]         ;6777
0000be  2804              CMP      r0,#4                 ;6777
0000c0  d105              BNE      |L67.206|
0000c2  6820              LDR      r0,[r4,#0]            ;6780
0000c4  6800              LDR      r0,[r0,#0]            ;6780
0000c6  f4407000          ORR      r0,r0,#0x200          ;6780
0000ca  6821              LDR      r1,[r4,#0]            ;6780
0000cc  6008              STR      r0,[r1,#0]            ;6780
                  |L67.206|
0000ce  2001              MOVS     r0,#1                 ;6782
0000d0  e7b8              B        |L67.68|
                  |L67.210|
0000d2  b2e8              UXTB     r0,r5                 ;6786
0000d4  6821              LDR      r1,[r4,#0]            ;6786
0000d6  6108              STR      r0,[r1,#0x10]         ;6786
                  |L67.216|
0000d8  2000              MOVS     r0,#0                 ;6789
0000da  e7b3              B        |L67.68|
;;;6791   
                          ENDP

                  |L67.220|
                          DCD      0x00010002

                          AREA ||i.I2C_SlaveReceive_BTF||, CODE, READONLY, ALIGN=1

                  I2C_SlaveReceive_BTF PROC
;;;6079     */
;;;6080   static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
000000  8d41              LDRH     r1,[r0,#0x2a]
;;;6081   {
;;;6082     if (hi2c->XferCount != 0U)
000002  b149              CBZ      r1,|L68.24|
;;;6083     {
;;;6084       /* Read data from DR */
;;;6085       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000004  6801              LDR      r1,[r0,#0]
000006  6909              LDR      r1,[r1,#0x10]
000008  6a42              LDR      r2,[r0,#0x24]
00000a  7011              STRB     r1,[r2,#0]
;;;6086   
;;;6087       /* Increment Buffer pointer */
;;;6088       hi2c->pBuffPtr++;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  1c49              ADDS     r1,r1,#1
000010  6241              STR      r1,[r0,#0x24]
;;;6089   
;;;6090       /* Update counter */
;;;6091       hi2c->XferCount--;
000012  8d41              LDRH     r1,[r0,#0x2a]
000014  1e49              SUBS     r1,r1,#1
000016  8541              STRH     r1,[r0,#0x2a]
                  |L68.24|
;;;6092     }
;;;6093   }
000018  4770              BX       lr
;;;6094   
                          ENDP


                          AREA ||i.I2C_SlaveReceive_RXNE||, CODE, READONLY, ALIGN=1

                  I2C_SlaveReceive_RXNE PROC
;;;6038     */
;;;6039   static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;6040   {
000002  4604              MOV      r4,r0
;;;6041     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;6042     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;6043   
;;;6044     if (hi2c->XferCount != 0U)
000008  8d60              LDRH     r0,[r4,#0x2a]
00000a  b1d8              CBZ      r0,|L69.68|
;;;6045     {
;;;6046       /* Read data from DR */
;;;6047       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
00000c  6820              LDR      r0,[r4,#0]
00000e  6900              LDR      r0,[r0,#0x10]
000010  6a61              LDR      r1,[r4,#0x24]
000012  7008              STRB     r0,[r1,#0]
;;;6048   
;;;6049       /* Increment Buffer pointer */
;;;6050       hi2c->pBuffPtr++;
000014  6a60              LDR      r0,[r4,#0x24]
000016  1c40              ADDS     r0,r0,#1
000018  6260              STR      r0,[r4,#0x24]
;;;6051   
;;;6052       /* Update counter */
;;;6053       hi2c->XferCount--;
00001a  8d60              LDRH     r0,[r4,#0x2a]
00001c  1e40              SUBS     r0,r0,#1
00001e  8560              STRH     r0,[r4,#0x2a]
;;;6054   
;;;6055       if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  b978              CBNZ     r0,|L69.68|
000024  2d2a              CMP      r5,#0x2a
000026  d10d              BNE      |L69.68|
;;;6056       {
;;;6057         /* Last Byte is received, disable Interrupt */
;;;6058         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  f4206080          BIC      r0,r0,#0x400
000030  6821              LDR      r1,[r4,#0]
000032  6048              STR      r0,[r1,#4]
;;;6059   
;;;6060         /* Set state at HAL_I2C_STATE_LISTEN */
;;;6061         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000034  2022              MOVS     r0,#0x22
000036  6320              STR      r0,[r4,#0x30]
;;;6062         hi2c->State = HAL_I2C_STATE_LISTEN;
000038  2028              MOVS     r0,#0x28
00003a  f884003d          STRB     r0,[r4,#0x3d]
;;;6063   
;;;6064         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6065   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6066         hi2c->SlaveRxCpltCallback(hi2c);
;;;6067   #else
;;;6068         HAL_I2C_SlaveRxCpltCallback(hi2c);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L69.68|
;;;6069   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6070       }
;;;6071     }
;;;6072   }
000044  bd70              POP      {r4-r6,pc}
;;;6073   
                          ENDP


                          AREA ||i.I2C_SlaveTransmit_BTF||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransmit_BTF PROC
;;;6017     */
;;;6018   static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
000000  8d41              LDRH     r1,[r0,#0x2a]
;;;6019   {
;;;6020     if (hi2c->XferCount != 0U)
000002  b149              CBZ      r1,|L70.24|
;;;6021     {
;;;6022       /* Write data to DR */
;;;6023       hi2c->Instance->DR = *hi2c->pBuffPtr;
000004  6a41              LDR      r1,[r0,#0x24]
000006  7809              LDRB     r1,[r1,#0]
000008  6802              LDR      r2,[r0,#0]
00000a  6111              STR      r1,[r2,#0x10]
;;;6024   
;;;6025       /* Increment Buffer pointer */
;;;6026       hi2c->pBuffPtr++;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  1c49              ADDS     r1,r1,#1
000010  6241              STR      r1,[r0,#0x24]
;;;6027   
;;;6028       /* Update counter */
;;;6029       hi2c->XferCount--;
000012  8d41              LDRH     r1,[r0,#0x2a]
000014  1e49              SUBS     r1,r1,#1
000016  8541              STRH     r1,[r0,#0x2a]
                  |L70.24|
;;;6030     }
;;;6031   }
000018  4770              BX       lr
;;;6032   
                          ENDP


                          AREA ||i.I2C_SlaveTransmit_TXE||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransmit_TXE PROC
;;;5976     */
;;;5977   static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5978   {
000002  4604              MOV      r4,r0
;;;5979     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5980     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;5981   
;;;5982     if (hi2c->XferCount != 0U)
000008  8d60              LDRH     r0,[r4,#0x2a]
00000a  b1d8              CBZ      r0,|L71.68|
;;;5983     {
;;;5984       /* Write data to DR */
;;;5985       hi2c->Instance->DR = *hi2c->pBuffPtr;
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  7800              LDRB     r0,[r0,#0]
000010  6821              LDR      r1,[r4,#0]
000012  6108              STR      r0,[r1,#0x10]
;;;5986   
;;;5987       /* Increment Buffer pointer */
;;;5988       hi2c->pBuffPtr++;
000014  6a60              LDR      r0,[r4,#0x24]
000016  1c40              ADDS     r0,r0,#1
000018  6260              STR      r0,[r4,#0x24]
;;;5989   
;;;5990       /* Update counter */
;;;5991       hi2c->XferCount--;
00001a  8d60              LDRH     r0,[r4,#0x2a]
00001c  1e40              SUBS     r0,r0,#1
00001e  8560              STRH     r0,[r4,#0x2a]
;;;5992   
;;;5993       if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  b978              CBNZ     r0,|L71.68|
000024  2d29              CMP      r5,#0x29
000026  d10d              BNE      |L71.68|
;;;5994       {
;;;5995         /* Last Byte is received, disable Interrupt */
;;;5996         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  f4206080          BIC      r0,r0,#0x400
000030  6821              LDR      r1,[r4,#0]
000032  6048              STR      r0,[r1,#4]
;;;5997   
;;;5998         /* Set state at HAL_I2C_STATE_LISTEN */
;;;5999         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
000034  2021              MOVS     r0,#0x21
000036  6320              STR      r0,[r4,#0x30]
;;;6000         hi2c->State = HAL_I2C_STATE_LISTEN;
000038  2028              MOVS     r0,#0x28
00003a  f884003d          STRB     r0,[r4,#0x3d]
;;;6001   
;;;6002         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6003   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6004         hi2c->SlaveTxCpltCallback(hi2c);
;;;6005   #else
;;;6006         HAL_I2C_SlaveTxCpltCallback(hi2c);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
                  |L71.68|
;;;6007   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6008       }
;;;6009     }
;;;6010   }
000044  bd70              POP      {r4-r6,pc}
;;;6011   
                          ENDP


                          AREA ||i.I2C_Slave_ADDR||, CODE, READONLY, ALIGN=1

                  I2C_Slave_ADDR PROC
;;;6101     */
;;;6102   static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags)
000000  b5f8              PUSH     {r3-r7,lr}
;;;6103   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;6104     uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
000006  2700              MOVS     r7,#0
;;;6105     uint16_t SlaveAddrCode;
;;;6106   
;;;6107     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  f0000028          AND      r0,r0,#0x28
000010  2828              CMP      r0,#0x28
000012  d11c              BNE      |L72.78|
;;;6108     {
;;;6109       /* Disable BUF interrupt, BUF enabling is manage through slave specific interface */
;;;6110       __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
000014  6820              LDR      r0,[r4,#0]
000016  6840              LDR      r0,[r0,#4]
000018  f4206080          BIC      r0,r0,#0x400
00001c  6821              LDR      r1,[r4,#0]
00001e  6048              STR      r0,[r1,#4]
;;;6111   
;;;6112       /* Transfer Direction requested by Master */
;;;6113       if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
000020  f3c50080          UBFX     r0,r5,#2,#1
000024  b900              CBNZ     r0,|L72.40|
;;;6114       {
;;;6115         TransferDirection = I2C_DIRECTION_TRANSMIT;
000026  2701              MOVS     r7,#1
                  |L72.40|
;;;6116       }
;;;6117   
;;;6118       if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
000028  f3c510c0          UBFX     r0,r5,#7,#1
00002c  b910              CBNZ     r0,|L72.52|
;;;6119       {
;;;6120         SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
00002e  89a0              LDRH     r0,[r4,#0xc]
000030  b286              UXTH     r6,r0
000032  e001              B        |L72.56|
                  |L72.52|
;;;6121       }
;;;6122       else
;;;6123       {
;;;6124         SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
000034  8b20              LDRH     r0,[r4,#0x18]
000036  b286              UXTH     r6,r0
                  |L72.56|
;;;6125       }
;;;6126   
;;;6127       /* Process Unlocked */
;;;6128       __HAL_UNLOCK(hi2c);
000038  bf00              NOP      
00003a  2000              MOVS     r0,#0
00003c  f884003c          STRB     r0,[r4,#0x3c]
000040  bf00              NOP      
;;;6129   
;;;6130       /* Call Slave Addr callback */
;;;6131   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6132       hi2c->AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
;;;6133   #else
;;;6134       HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
000042  4632              MOV      r2,r6
000044  4639              MOV      r1,r7
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       HAL_I2C_AddrCallback
00004c  e00f              B        |L72.110|
                  |L72.78|
;;;6135   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6136     }
;;;6137     else
;;;6138     {
;;;6139       /* Clear ADDR flag */
;;;6140       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00004e  bf00              NOP      
000050  2000              MOVS     r0,#0
000052  9000              STR      r0,[sp,#0]
000054  6820              LDR      r0,[r4,#0]
000056  6940              LDR      r0,[r0,#0x14]
000058  9000              STR      r0,[sp,#0]
00005a  6820              LDR      r0,[r4,#0]
00005c  6980              LDR      r0,[r0,#0x18]
00005e  9000              STR      r0,[sp,#0]
000060  bf00              NOP      
000062  bf00              NOP      
;;;6141   
;;;6142       /* Process Unlocked */
;;;6143       __HAL_UNLOCK(hi2c);
000064  bf00              NOP      
000066  2000              MOVS     r0,#0
000068  f884003c          STRB     r0,[r4,#0x3c]
00006c  bf00              NOP      
                  |L72.110|
;;;6144     }
;;;6145   }
00006e  bdf8              POP      {r3-r7,pc}
;;;6146   
                          ENDP


                          AREA ||i.I2C_Slave_AF||, CODE, READONLY, ALIGN=2

                  I2C_Slave_AF PROC
;;;6321     */
;;;6322   static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;6323   {
000002  4604              MOV      r4,r0
;;;6324     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;6325     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;6326     uint32_t CurrentXferOptions       = hi2c->XferOptions;
000008  6ae6              LDR      r6,[r4,#0x2c]
;;;6327   
;;;6328     if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
00000a  2e08              CMP      r6,#8
00000c  d001              BEQ      |L73.18|
00000e  2e20              CMP      r6,#0x20
000010  d11f              BNE      |L73.82|
                  |L73.18|
;;;6329         (CurrentState == HAL_I2C_STATE_LISTEN))
000012  2d28              CMP      r5,#0x28
000014  d11d              BNE      |L73.82|
;;;6330     {
;;;6331       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
000016  4821              LDR      r0,|L73.156|
000018  62e0              STR      r0,[r4,#0x2c]
;;;6332   
;;;6333       /* Disable EVT, BUF and ERR interrupt */
;;;6334       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f42060e0          BIC      r0,r0,#0x700
000022  6821              LDR      r1,[r4,#0]
000024  6048              STR      r0,[r1,#4]
;;;6335   
;;;6336       /* Clear AF flag */
;;;6337       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000026  f46f6080          MVN      r0,#0x400
00002a  6821              LDR      r1,[r4,#0]
00002c  6148              STR      r0,[r1,#0x14]
;;;6338   
;;;6339       /* Disable Acknowledge */
;;;6340       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f4206080          BIC      r0,r0,#0x400
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;6341   
;;;6342       hi2c->PreviousState = I2C_STATE_NONE;
00003a  2000              MOVS     r0,#0
00003c  6320              STR      r0,[r4,#0x30]
;;;6343       hi2c->State         = HAL_I2C_STATE_READY;
00003e  2020              MOVS     r0,#0x20
000040  f884003d          STRB     r0,[r4,#0x3d]
;;;6344       hi2c->Mode          = HAL_I2C_MODE_NONE;
000044  2000              MOVS     r0,#0
000046  f884003e          STRB     r0,[r4,#0x3e]
;;;6345   
;;;6346       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;6347   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6348       hi2c->ListenCpltCallback(hi2c);
;;;6349   #else
;;;6350       HAL_I2C_ListenCpltCallback(hi2c);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       HAL_I2C_ListenCpltCallback
000050  e023              B        |L73.154|
                  |L73.82|
;;;6351   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6352     }
;;;6353     else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
000052  2d21              CMP      r5,#0x21
000054  d11d              BNE      |L73.146|
;;;6354     {
;;;6355       hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
000056  4811              LDR      r0,|L73.156|
000058  62e0              STR      r0,[r4,#0x2c]
;;;6356       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
00005a  2021              MOVS     r0,#0x21
00005c  6320              STR      r0,[r4,#0x30]
;;;6357       hi2c->State         = HAL_I2C_STATE_READY;
00005e  2020              MOVS     r0,#0x20
000060  f884003d          STRB     r0,[r4,#0x3d]
;;;6358       hi2c->Mode          = HAL_I2C_MODE_NONE;
000064  2000              MOVS     r0,#0
000066  f884003e          STRB     r0,[r4,#0x3e]
;;;6359   
;;;6360       /* Disable EVT, BUF and ERR interrupt */
;;;6361       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00006a  6820              LDR      r0,[r4,#0]
00006c  6840              LDR      r0,[r0,#4]
00006e  f42060e0          BIC      r0,r0,#0x700
000072  6821              LDR      r1,[r4,#0]
000074  6048              STR      r0,[r1,#4]
;;;6362   
;;;6363       /* Clear AF flag */
;;;6364       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000076  f46f6080          MVN      r0,#0x400
00007a  6821              LDR      r1,[r4,#0]
00007c  6148              STR      r0,[r1,#0x14]
;;;6365   
;;;6366       /* Disable Acknowledge */
;;;6367       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00007e  6820              LDR      r0,[r4,#0]
000080  6800              LDR      r0,[r0,#0]
000082  f4206080          BIC      r0,r0,#0x400
000086  6821              LDR      r1,[r4,#0]
000088  6008              STR      r0,[r1,#0]
;;;6368   
;;;6369   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6370       hi2c->SlaveTxCpltCallback(hi2c);
;;;6371   #else
;;;6372       HAL_I2C_SlaveTxCpltCallback(hi2c);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
000090  e003              B        |L73.154|
                  |L73.146|
;;;6373   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6374     }
;;;6375     else
;;;6376     {
;;;6377       /* Clear AF flag only */
;;;6378       /* State Listen, but XferOptions == FIRST or NEXT */
;;;6379       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000092  f46f6080          MVN      r0,#0x400
000096  6821              LDR      r1,[r4,#0]
000098  6148              STR      r0,[r1,#0x14]
                  |L73.154|
;;;6380     }
;;;6381   }
00009a  bd70              POP      {r4-r6,pc}
;;;6382   
                          ENDP

                  |L73.156|
                          DCD      0xffff0000

                          AREA ||i.I2C_Slave_STOPF||, CODE, READONLY, ALIGN=2

                  I2C_Slave_STOPF PROC
;;;6152     */
;;;6153   static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
000000  b538              PUSH     {r3-r5,lr}
;;;6154   {
000002  4604              MOV      r4,r0
;;;6155     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6156     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;6157   
;;;6158     /* Disable EVT, BUF and ERR interrupt */
;;;6159     __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000008  6820              LDR      r0,[r4,#0]
00000a  6840              LDR      r0,[r0,#4]
00000c  f42060e0          BIC      r0,r0,#0x700
000010  6821              LDR      r1,[r4,#0]
000012  6048              STR      r0,[r1,#4]
;;;6160   
;;;6161     /* Clear STOPF flag */
;;;6162     __HAL_I2C_CLEAR_STOPFLAG(hi2c);
000014  bf00              NOP      
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
00001a  6820              LDR      r0,[r4,#0]
00001c  6940              LDR      r0,[r0,#0x14]
00001e  9000              STR      r0,[sp,#0]
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0400001          ORR      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;6163   
;;;6164     /* Disable Acknowledge */
;;;6165     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000030  6820              LDR      r0,[r4,#0]
000032  6800              LDR      r0,[r0,#0]
000034  f4206080          BIC      r0,r0,#0x400
000038  6821              LDR      r1,[r4,#0]
00003a  6008              STR      r0,[r1,#0]
;;;6166   
;;;6167     /* If a DMA is ongoing, Update handle size context */
;;;6168     if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
00003c  6820              LDR      r0,[r4,#0]
00003e  6840              LDR      r0,[r0,#4]
000040  f4006000          AND      r0,r0,#0x800
000044  f5b06f00          CMP      r0,#0x800
000048  d142              BNE      |L74.208|
;;;6169     {
;;;6170       if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
00004a  2d22              CMP      r5,#0x22
00004c  d001              BEQ      |L74.82|
00004e  2d2a              CMP      r5,#0x2a
000050  d11f              BNE      |L74.146|
                  |L74.82|
;;;6171       {
;;;6172         hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmarx));
000052  6ba0              LDR      r0,[r4,#0x38]
000054  6800              LDR      r0,[r0,#0]
000056  6840              LDR      r0,[r0,#4]
000058  8560              STRH     r0,[r4,#0x2a]
;;;6173   
;;;6174         if (hi2c->XferCount != 0U)
00005a  8d60              LDRH     r0,[r4,#0x2a]
00005c  b118              CBZ      r0,|L74.102|
;;;6175         {
;;;6176           /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;6177           hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00005e  6c20              LDR      r0,[r4,#0x40]
000060  f0400004          ORR      r0,r0,#4
000064  6420              STR      r0,[r4,#0x40]
                  |L74.102|
;;;6178         }
;;;6179   
;;;6180         /* Disable, stop the current DMA */
;;;6181         CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000066  6820              LDR      r0,[r4,#0]
000068  6840              LDR      r0,[r0,#4]
00006a  f4206000          BIC      r0,r0,#0x800
00006e  6821              LDR      r1,[r4,#0]
000070  6048              STR      r0,[r1,#4]
;;;6182   
;;;6183         /* Abort DMA Xfer if any */
;;;6184         if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
000072  6ba0              LDR      r0,[r4,#0x38]
000074  f7fffffe          BL       HAL_DMA_GetState
000078  2801              CMP      r0,#1
00007a  d029              BEQ      |L74.208|
;;;6185         {
;;;6186           /* Set the I2C DMA Abort callback :
;;;6187           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6188           hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
00007c  4841              LDR      r0,|L74.388|
00007e  6ba1              LDR      r1,[r4,#0x38]
000080  6508              STR      r0,[r1,#0x50]
;;;6189   
;;;6190           /* Abort DMA RX */
;;;6191           if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
000082  6ba0              LDR      r0,[r4,#0x38]
000084  f7fffffe          BL       HAL_DMA_Abort_IT
000088  b310              CBZ      r0,|L74.208|
;;;6192           {
;;;6193             /* Call Directly XferAbortCallback function in case of error */
;;;6194             hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
00008a  6ba0              LDR      r0,[r4,#0x38]
00008c  6d01              LDR      r1,[r0,#0x50]
00008e  4788              BLX      r1
000090  e01e              B        |L74.208|
                  |L74.146|
;;;6195           }
;;;6196         }
;;;6197       }
;;;6198       else
;;;6199       {
;;;6200         hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmatx));
000092  6b60              LDR      r0,[r4,#0x34]
000094  6800              LDR      r0,[r0,#0]
000096  6840              LDR      r0,[r0,#4]
000098  8560              STRH     r0,[r4,#0x2a]
;;;6201   
;;;6202         if (hi2c->XferCount != 0U)
00009a  8d60              LDRH     r0,[r4,#0x2a]
00009c  b118              CBZ      r0,|L74.166|
;;;6203         {
;;;6204           /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;6205           hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00009e  6c20              LDR      r0,[r4,#0x40]
0000a0  f0400004          ORR      r0,r0,#4
0000a4  6420              STR      r0,[r4,#0x40]
                  |L74.166|
;;;6206         }
;;;6207   
;;;6208         /* Disable, stop the current DMA */
;;;6209         CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
0000a6  6820              LDR      r0,[r4,#0]
0000a8  6840              LDR      r0,[r0,#4]
0000aa  f4206000          BIC      r0,r0,#0x800
0000ae  6821              LDR      r1,[r4,#0]
0000b0  6048              STR      r0,[r1,#4]
;;;6210   
;;;6211         /* Abort DMA Xfer if any */
;;;6212         if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
0000b2  6b60              LDR      r0,[r4,#0x34]
0000b4  f7fffffe          BL       HAL_DMA_GetState
0000b8  2801              CMP      r0,#1
0000ba  d009              BEQ      |L74.208|
;;;6213         {
;;;6214           /* Set the I2C DMA Abort callback :
;;;6215           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6216           hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
0000bc  4831              LDR      r0,|L74.388|
0000be  6b61              LDR      r1,[r4,#0x34]
0000c0  6508              STR      r0,[r1,#0x50]
;;;6217   
;;;6218           /* Abort DMA TX */
;;;6219           if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
0000c2  6b60              LDR      r0,[r4,#0x34]
0000c4  f7fffffe          BL       HAL_DMA_Abort_IT
0000c8  b110              CBZ      r0,|L74.208|
;;;6220           {
;;;6221             /* Call Directly XferAbortCallback function in case of error */
;;;6222             hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
0000ca  6b60              LDR      r0,[r4,#0x34]
0000cc  6d01              LDR      r1,[r0,#0x50]
0000ce  4788              BLX      r1
                  |L74.208|
;;;6223           }
;;;6224         }
;;;6225       }
;;;6226     }
;;;6227   
;;;6228     /* All data are not transferred, so set error code accordingly */
;;;6229     if (hi2c->XferCount != 0U)
0000d0  8d60              LDRH     r0,[r4,#0x2a]
0000d2  b318              CBZ      r0,|L74.284|
;;;6230     {
;;;6231       /* Store Last receive data if any */
;;;6232       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6940              LDR      r0,[r0,#0x14]
0000d8  f3c00080          UBFX     r0,r0,#2,#1
0000dc  b148              CBZ      r0,|L74.242|
;;;6233       {
;;;6234         /* Read data from DR */
;;;6235         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000de  6820              LDR      r0,[r4,#0]
0000e0  6900              LDR      r0,[r0,#0x10]
0000e2  6a61              LDR      r1,[r4,#0x24]
0000e4  7008              STRB     r0,[r1,#0]
;;;6236   
;;;6237         /* Increment Buffer pointer */
;;;6238         hi2c->pBuffPtr++;
0000e6  6a60              LDR      r0,[r4,#0x24]
0000e8  1c40              ADDS     r0,r0,#1
0000ea  6260              STR      r0,[r4,#0x24]
;;;6239   
;;;6240         /* Update counter */
;;;6241         hi2c->XferCount--;
0000ec  8d60              LDRH     r0,[r4,#0x2a]
0000ee  1e40              SUBS     r0,r0,#1
0000f0  8560              STRH     r0,[r4,#0x2a]
                  |L74.242|
;;;6242       }
;;;6243   
;;;6244       /* Store Last receive data if any */
;;;6245       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000f2  6820              LDR      r0,[r4,#0]
0000f4  6940              LDR      r0,[r0,#0x14]
0000f6  f3c01080          UBFX     r0,r0,#6,#1
0000fa  b148              CBZ      r0,|L74.272|
;;;6246       {
;;;6247         /* Read data from DR */
;;;6248         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000fc  6820              LDR      r0,[r4,#0]
0000fe  6900              LDR      r0,[r0,#0x10]
000100  6a61              LDR      r1,[r4,#0x24]
000102  7008              STRB     r0,[r1,#0]
;;;6249   
;;;6250         /* Increment Buffer pointer */
;;;6251         hi2c->pBuffPtr++;
000104  6a60              LDR      r0,[r4,#0x24]
000106  1c40              ADDS     r0,r0,#1
000108  6260              STR      r0,[r4,#0x24]
;;;6252   
;;;6253         /* Update counter */
;;;6254         hi2c->XferCount--;
00010a  8d60              LDRH     r0,[r4,#0x2a]
00010c  1e40              SUBS     r0,r0,#1
00010e  8560              STRH     r0,[r4,#0x2a]
                  |L74.272|
;;;6255       }
;;;6256   
;;;6257       if (hi2c->XferCount != 0U)
000110  8d60              LDRH     r0,[r4,#0x2a]
000112  b118              CBZ      r0,|L74.284|
;;;6258       {
;;;6259         /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;6260         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000114  6c20              LDR      r0,[r4,#0x40]
000116  f0400004          ORR      r0,r0,#4
00011a  6420              STR      r0,[r4,#0x40]
                  |L74.284|
;;;6261       }
;;;6262     }
;;;6263   
;;;6264     if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
00011c  6c20              LDR      r0,[r4,#0x40]
00011e  b118              CBZ      r0,|L74.296|
;;;6265     {
;;;6266       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6267       I2C_ITError(hi2c);
000120  4620              MOV      r0,r4
000122  f7fffffe          BL       I2C_ITError
000126  e02b              B        |L74.384|
                  |L74.296|
;;;6268     }
;;;6269     else
;;;6270     {
;;;6271       if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
000128  2d2a              CMP      r5,#0x2a
00012a  d107              BNE      |L74.316|
;;;6272       {
;;;6273         /* Set state at HAL_I2C_STATE_LISTEN */
;;;6274         hi2c->PreviousState = I2C_STATE_NONE;
00012c  2000              MOVS     r0,#0
00012e  6320              STR      r0,[r4,#0x30]
;;;6275         hi2c->State = HAL_I2C_STATE_LISTEN;
000130  2028              MOVS     r0,#0x28
000132  f884003d          STRB     r0,[r4,#0x3d]
;;;6276   
;;;6277         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6278   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6279         hi2c->SlaveRxCpltCallback(hi2c);
;;;6280   #else
;;;6281         HAL_I2C_SlaveRxCpltCallback(hi2c);
000136  4620              MOV      r0,r4
000138  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L74.316|
;;;6282   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6283       }
;;;6284   
;;;6285       if (hi2c->State == HAL_I2C_STATE_LISTEN)
00013c  f894003d          LDRB     r0,[r4,#0x3d]
000140  2828              CMP      r0,#0x28
000142  d10d              BNE      |L74.352|
;;;6286       {
;;;6287         hi2c->XferOptions = I2C_NO_OPTION_FRAME;
000144  4810              LDR      r0,|L74.392|
000146  62e0              STR      r0,[r4,#0x2c]
;;;6288         hi2c->PreviousState = I2C_STATE_NONE;
000148  2000              MOVS     r0,#0
00014a  6320              STR      r0,[r4,#0x30]
;;;6289         hi2c->State = HAL_I2C_STATE_READY;
00014c  2020              MOVS     r0,#0x20
00014e  f884003d          STRB     r0,[r4,#0x3d]
;;;6290         hi2c->Mode = HAL_I2C_MODE_NONE;
000152  2000              MOVS     r0,#0
000154  f884003e          STRB     r0,[r4,#0x3e]
;;;6291   
;;;6292         /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;6293   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6294         hi2c->ListenCpltCallback(hi2c);
;;;6295   #else
;;;6296         HAL_I2C_ListenCpltCallback(hi2c);
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       HAL_I2C_ListenCpltCallback
00015e  e00f              B        |L74.384|
                  |L74.352|
;;;6297   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6298       }
;;;6299       else
;;;6300       {
;;;6301         if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
000160  6b20              LDR      r0,[r4,#0x30]
000162  2822              CMP      r0,#0x22
000164  d001              BEQ      |L74.362|
000166  2d22              CMP      r5,#0x22
000168  d10a              BNE      |L74.384|
                  |L74.362|
;;;6302         {
;;;6303           hi2c->PreviousState = I2C_STATE_NONE;
00016a  2000              MOVS     r0,#0
00016c  6320              STR      r0,[r4,#0x30]
;;;6304           hi2c->State = HAL_I2C_STATE_READY;
00016e  2020              MOVS     r0,#0x20
000170  f884003d          STRB     r0,[r4,#0x3d]
;;;6305           hi2c->Mode = HAL_I2C_MODE_NONE;
000174  2000              MOVS     r0,#0
000176  f884003e          STRB     r0,[r4,#0x3e]
;;;6306   
;;;6307   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6308           hi2c->SlaveRxCpltCallback(hi2c);
;;;6309   #else
;;;6310           HAL_I2C_SlaveRxCpltCallback(hi2c);
00017a  4620              MOV      r0,r4
00017c  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L74.384|
;;;6311   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6312         }
;;;6313       }
;;;6314     }
;;;6315   }
000180  bd38              POP      {r3-r5,pc}
;;;6316   
                          ENDP

000182  0000              DCW      0x0000
                  |L74.388|
                          DCD      I2C_DMAAbort
                  |L74.392|
                          DCD      0xffff0000

                          AREA ||i.I2C_WaitOnBTFFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnBTFFlagUntilTimeout PROC
;;;7317     */
;;;7318   static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;7319   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;7320     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
000008  e020              B        |L75.76|
                  |L75.10|
;;;7321     {
;;;7322       /* Check if a NACK is detected */
;;;7323       if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L75.22|
;;;7324       {
;;;7325         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L75.20|
;;;7326       }
;;;7327   
;;;7328       /* Check for the Timeout */
;;;7329       if (Timeout != HAL_MAX_DELAY)
;;;7330       {
;;;7331         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7332         {
;;;7333           hi2c->PreviousState       = I2C_STATE_NONE;
;;;7334           hi2c->State               = HAL_I2C_STATE_READY;
;;;7335           hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7336           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7337   
;;;7338           /* Process Unlocked */
;;;7339           __HAL_UNLOCK(hi2c);
;;;7340   
;;;7341           return HAL_ERROR;
;;;7342         }
;;;7343       }
;;;7344     }
;;;7345     return HAL_OK;
;;;7346   }
000014  bd70              POP      {r4-r6,pc}
                  |L75.22|
000016  1c68              ADDS     r0,r5,#1              ;7329
000018  b1c0              CBZ      r0,|L75.76|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b80              SUBS     r0,r0,r6              ;7331
000020  42a8              CMP      r0,r5                 ;7331
000022  d800              BHI      |L75.38|
000024  b995              CBNZ     r5,|L75.76|
                  |L75.38|
000026  2000              MOVS     r0,#0                 ;7333
000028  6320              STR      r0,[r4,#0x30]         ;7333
00002a  2020              MOVS     r0,#0x20              ;7334
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;7334
000030  2000              MOVS     r0,#0                 ;7335
000032  f884003e          STRB     r0,[r4,#0x3e]         ;7335
000036  6c20              LDR      r0,[r4,#0x40]         ;7336
000038  f0400020          ORR      r0,r0,#0x20           ;7336
00003c  6420              STR      r0,[r4,#0x40]         ;7336
00003e  bf00              NOP                            ;7339
000040  2000              MOVS     r0,#0                 ;7339
000042  f884003c          STRB     r0,[r4,#0x3c]         ;7339
000046  bf00              NOP                            ;7339
000048  2001              MOVS     r0,#1                 ;7341
00004a  e7e3              B        |L75.20|
                  |L75.76|
00004c  6820              LDR      r0,[r4,#0]            ;7320
00004e  6940              LDR      r0,[r0,#0x14]         ;7320
000050  f3c00080          UBFX     r0,r0,#2,#1           ;7320
000054  2800              CMP      r0,#0                 ;7320
000056  d0d8              BEQ      |L75.10|
000058  2000              MOVS     r0,#0                 ;7345
00005a  e7db              B        |L75.20|
;;;7347   
                          ENDP


                          AREA ||i.I2C_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnFlagUntilTimeout PROC
;;;7194     */
;;;7195   static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;7196   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;7197     /* Wait until flag is set */
;;;7198     while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
000010  e01c              B        |L76.76|
                  |L76.18|
;;;7199     {
;;;7200       /* Check for the Timeout */
;;;7201       if (Timeout != HAL_MAX_DELAY)
000012  1c70              ADDS     r0,r6,#1
000014  b1d0              CBZ      r0,|L76.76|
;;;7202       {
;;;7203         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d800              BHI      |L76.36|
000022  b99e              CBNZ     r6,|L76.76|
                  |L76.36|
;;;7204         {
;;;7205           hi2c->PreviousState     = I2C_STATE_NONE;
000024  2000              MOVS     r0,#0
000026  6320              STR      r0,[r4,#0x30]
;;;7206           hi2c->State             = HAL_I2C_STATE_READY;
000028  2020              MOVS     r0,#0x20
00002a  f884003d          STRB     r0,[r4,#0x3d]
;;;7207           hi2c->Mode              = HAL_I2C_MODE_NONE;
00002e  2000              MOVS     r0,#0
000030  f884003e          STRB     r0,[r4,#0x3e]
;;;7208           hi2c->ErrorCode         |= HAL_I2C_ERROR_TIMEOUT;
000034  6c20              LDR      r0,[r4,#0x40]
000036  f0400020          ORR      r0,r0,#0x20
00003a  6420              STR      r0,[r4,#0x40]
;;;7209   
;;;7210           /* Process Unlocked */
;;;7211           __HAL_UNLOCK(hi2c);
00003c  bf00              NOP      
00003e  2000              MOVS     r0,#0
000040  f884003c          STRB     r0,[r4,#0x3c]
000044  bf00              NOP      
;;;7212   
;;;7213           return HAL_ERROR;
000046  2001              MOVS     r0,#1
                  |L76.72|
;;;7214         }
;;;7215       }
;;;7216     }
;;;7217     return HAL_OK;
;;;7218   }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L76.76|
00004c  f3c54007          UBFX     r0,r5,#16,#8          ;7198
000050  2801              CMP      r0,#1                 ;7198
000052  d10a              BNE      |L76.106|
000054  6820              LDR      r0,[r4,#0]            ;7198
000056  6940              LDR      r0,[r0,#0x14]         ;7198
000058  b2a9              UXTH     r1,r5                 ;7198
00005a  4008              ANDS     r0,r0,r1              ;7198
00005c  b2a9              UXTH     r1,r5                 ;7198
00005e  4288              CMP      r0,r1                 ;7198
000060  d101              BNE      |L76.102|
000062  2001              MOVS     r0,#1                 ;7198
000064  e00b              B        |L76.126|
                  |L76.102|
000066  2000              MOVS     r0,#0                 ;7198
000068  e009              B        |L76.126|
                  |L76.106|
00006a  6820              LDR      r0,[r4,#0]            ;7198
00006c  6980              LDR      r0,[r0,#0x18]         ;7198
00006e  b2a9              UXTH     r1,r5                 ;7198
000070  4008              ANDS     r0,r0,r1              ;7198
000072  b2a9              UXTH     r1,r5                 ;7198
000074  4288              CMP      r0,r1                 ;7198
000076  d101              BNE      |L76.124|
000078  2001              MOVS     r0,#1                 ;7198
00007a  e000              B        |L76.126|
                  |L76.124|
00007c  2000              MOVS     r0,#0                 ;7198
                  |L76.126|
00007e  42b8              CMP      r0,r7                 ;7198
000080  d0c7              BEQ      |L76.18|
000082  2000              MOVS     r0,#0                 ;7217
000084  e7e0              B        |L76.72|
;;;7219   
                          ENDP


                          AREA ||i.I2C_WaitOnMasterAddressFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnMasterAddressFlagUntilTimeout PROC
;;;7228     */
;;;7229   static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;7230   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;7231     while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
00000c  e03d              B        |L77.138|
                  |L77.14|
;;;7232     {
;;;7233       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
00000e  6820              LDR      r0,[r4,#0]
000010  6940              LDR      r0,[r0,#0x14]
000012  f3c02080          UBFX     r0,r0,#10,#1
000016  b1e8              CBZ      r0,|L77.84|
;;;7234       {
;;;7235         /* Generate Stop */
;;;7236         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000018  6820              LDR      r0,[r4,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  f4407000          ORR      r0,r0,#0x200
000020  6821              LDR      r1,[r4,#0]
000022  6008              STR      r0,[r1,#0]
;;;7237   
;;;7238         /* Clear AF Flag */
;;;7239         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000024  f46f6080          MVN      r0,#0x400
000028  6821              LDR      r1,[r4,#0]
00002a  6148              STR      r0,[r1,#0x14]
;;;7240   
;;;7241         hi2c->PreviousState       = I2C_STATE_NONE;
00002c  2000              MOVS     r0,#0
00002e  6320              STR      r0,[r4,#0x30]
;;;7242         hi2c->State               = HAL_I2C_STATE_READY;
000030  2020              MOVS     r0,#0x20
000032  f884003d          STRB     r0,[r4,#0x3d]
;;;7243         hi2c->Mode                = HAL_I2C_MODE_NONE;
000036  2000              MOVS     r0,#0
000038  f884003e          STRB     r0,[r4,#0x3e]
;;;7244         hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
00003c  6c20              LDR      r0,[r4,#0x40]
00003e  f0400004          ORR      r0,r0,#4
000042  6420              STR      r0,[r4,#0x40]
;;;7245   
;;;7246         /* Process Unlocked */
;;;7247         __HAL_UNLOCK(hi2c);
000044  bf00              NOP      
000046  2000              MOVS     r0,#0
000048  f884003c          STRB     r0,[r4,#0x3c]
00004c  bf00              NOP      
;;;7248   
;;;7249         return HAL_ERROR;
00004e  2001              MOVS     r0,#1
                  |L77.80|
;;;7250       }
;;;7251   
;;;7252       /* Check for the Timeout */
;;;7253       if (Timeout != HAL_MAX_DELAY)
;;;7254       {
;;;7255         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7256         {
;;;7257           hi2c->PreviousState       = I2C_STATE_NONE;
;;;7258           hi2c->State               = HAL_I2C_STATE_READY;
;;;7259           hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7260           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7261   
;;;7262           /* Process Unlocked */
;;;7263           __HAL_UNLOCK(hi2c);
;;;7264   
;;;7265           return HAL_ERROR;
;;;7266         }
;;;7267       }
;;;7268     }
;;;7269     return HAL_OK;
;;;7270   }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L77.84|
000054  1c70              ADDS     r0,r6,#1              ;7253
000056  b1c0              CBZ      r0,|L77.138|
000058  f7fffffe          BL       HAL_GetTick
00005c  1bc0              SUBS     r0,r0,r7              ;7255
00005e  42b0              CMP      r0,r6                 ;7255
000060  d800              BHI      |L77.100|
000062  b996              CBNZ     r6,|L77.138|
                  |L77.100|
000064  2000              MOVS     r0,#0                 ;7257
000066  6320              STR      r0,[r4,#0x30]         ;7257
000068  2020              MOVS     r0,#0x20              ;7258
00006a  f884003d          STRB     r0,[r4,#0x3d]         ;7258
00006e  2000              MOVS     r0,#0                 ;7259
000070  f884003e          STRB     r0,[r4,#0x3e]         ;7259
000074  6c20              LDR      r0,[r4,#0x40]         ;7260
000076  f0400020          ORR      r0,r0,#0x20           ;7260
00007a  6420              STR      r0,[r4,#0x40]         ;7260
00007c  bf00              NOP                            ;7263
00007e  2000              MOVS     r0,#0                 ;7263
000080  f884003c          STRB     r0,[r4,#0x3c]         ;7263
000084  bf00              NOP                            ;7263
000086  2001              MOVS     r0,#1                 ;7265
000088  e7e2              B        |L77.80|
                  |L77.138|
00008a  f3c54007          UBFX     r0,r5,#16,#8          ;7231
00008e  2801              CMP      r0,#1                 ;7231
000090  d10a              BNE      |L77.168|
000092  6820              LDR      r0,[r4,#0]            ;7231
000094  6940              LDR      r0,[r0,#0x14]         ;7231
000096  b2a9              UXTH     r1,r5                 ;7231
000098  4008              ANDS     r0,r0,r1              ;7231
00009a  b2a9              UXTH     r1,r5                 ;7231
00009c  4288              CMP      r0,r1                 ;7231
00009e  d101              BNE      |L77.164|
0000a0  2001              MOVS     r0,#1                 ;7231
0000a2  e00b              B        |L77.188|
                  |L77.164|
0000a4  2000              MOVS     r0,#0                 ;7231
0000a6  e009              B        |L77.188|
                  |L77.168|
0000a8  6820              LDR      r0,[r4,#0]            ;7231
0000aa  6980              LDR      r0,[r0,#0x18]         ;7231
0000ac  b2a9              UXTH     r1,r5                 ;7231
0000ae  4008              ANDS     r0,r0,r1              ;7231
0000b0  b2a9              UXTH     r1,r5                 ;7231
0000b2  4288              CMP      r0,r1                 ;7231
0000b4  d101              BNE      |L77.186|
0000b6  2001              MOVS     r0,#1                 ;7231
0000b8  e000              B        |L77.188|
                  |L77.186|
0000ba  2000              MOVS     r0,#0                 ;7231
                  |L77.188|
0000bc  2800              CMP      r0,#0                 ;7231
0000be  d0a6              BEQ      |L77.14|
0000c0  2000              MOVS     r0,#0                 ;7269
0000c2  e7c5              B        |L77.80|
;;;7271   
                          ENDP


                          AREA ||i.I2C_WaitOnRXNEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnRXNEFlagUntilTimeout PROC
;;;7417     */
;;;7418   static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;7419   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;7420   
;;;7421     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
000008  e032              B        |L78.112|
                  |L78.10|
;;;7422     {
;;;7423       /* Check if a STOPF is detected */
;;;7424       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
00000a  6820              LDR      r0,[r4,#0]
00000c  6940              LDR      r0,[r0,#0x14]
00000e  f3c01000          UBFX     r0,r0,#4,#1
000012  b1a0              CBZ      r0,|L78.62|
;;;7425       {
;;;7426         /* Clear STOP Flag */
;;;7427         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
000014  f06f0010          MVN      r0,#0x10
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;7428   
;;;7429         hi2c->PreviousState       = I2C_STATE_NONE;
00001c  2000              MOVS     r0,#0
00001e  6320              STR      r0,[r4,#0x30]
;;;7430         hi2c->State               = HAL_I2C_STATE_READY;
000020  2020              MOVS     r0,#0x20
000022  f884003d          STRB     r0,[r4,#0x3d]
;;;7431         hi2c->Mode                = HAL_I2C_MODE_NONE;
000026  2000              MOVS     r0,#0
000028  f884003e          STRB     r0,[r4,#0x3e]
;;;7432         hi2c->ErrorCode           |= HAL_I2C_ERROR_NONE;
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  6420              STR      r0,[r4,#0x40]
;;;7433   
;;;7434         /* Process Unlocked */
;;;7435         __HAL_UNLOCK(hi2c);
000030  bf00              NOP      
000032  2000              MOVS     r0,#0
000034  f884003c          STRB     r0,[r4,#0x3c]
000038  bf00              NOP      
;;;7436   
;;;7437         return HAL_ERROR;
00003a  2001              MOVS     r0,#1
                  |L78.60|
;;;7438       }
;;;7439   
;;;7440       /* Check for the Timeout */
;;;7441       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7442       {
;;;7443         hi2c->PreviousState       = I2C_STATE_NONE;
;;;7444         hi2c->State               = HAL_I2C_STATE_READY;
;;;7445         hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7446         hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7447   
;;;7448         /* Process Unlocked */
;;;7449         __HAL_UNLOCK(hi2c);
;;;7450   
;;;7451         return HAL_ERROR;
;;;7452       }
;;;7453     }
;;;7454     return HAL_OK;
;;;7455   }
00003c  bd70              POP      {r4-r6,pc}
                  |L78.62|
00003e  f7fffffe          BL       HAL_GetTick
000042  1b80              SUBS     r0,r0,r6              ;7441
000044  42a8              CMP      r0,r5                 ;7441
000046  d800              BHI      |L78.74|
000048  b995              CBNZ     r5,|L78.112|
                  |L78.74|
00004a  2000              MOVS     r0,#0                 ;7443
00004c  6320              STR      r0,[r4,#0x30]         ;7443
00004e  2020              MOVS     r0,#0x20              ;7444
000050  f884003d          STRB     r0,[r4,#0x3d]         ;7444
000054  2000              MOVS     r0,#0                 ;7445
000056  f884003e          STRB     r0,[r4,#0x3e]         ;7445
00005a  6c20              LDR      r0,[r4,#0x40]         ;7446
00005c  f0400020          ORR      r0,r0,#0x20           ;7446
000060  6420              STR      r0,[r4,#0x40]         ;7446
000062  bf00              NOP                            ;7449
000064  2000              MOVS     r0,#0                 ;7449
000066  f884003c          STRB     r0,[r4,#0x3c]         ;7449
00006a  bf00              NOP                            ;7449
00006c  2001              MOVS     r0,#1                 ;7451
00006e  e7e5              B        |L78.60|
                  |L78.112|
000070  6820              LDR      r0,[r4,#0]            ;7421
000072  6940              LDR      r0,[r0,#0x14]         ;7421
000074  f3c01080          UBFX     r0,r0,#6,#1           ;7421
000078  2800              CMP      r0,#0                 ;7421
00007a  d0c6              BEQ      |L78.10|
00007c  2000              MOVS     r0,#0                 ;7454
00007e  e7dd              B        |L78.60|
;;;7456   
                          ENDP


                          AREA ||i.I2C_WaitOnSTOPFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnSTOPFlagUntilTimeout PROC
;;;7355     */
;;;7356   static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;7357   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;7358     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
000008  e01e              B        |L79.72|
                  |L79.10|
;;;7359     {
;;;7360       /* Check if a NACK is detected */
;;;7361       if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L79.22|
;;;7362       {
;;;7363         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L79.20|
;;;7364       }
;;;7365   
;;;7366       /* Check for the Timeout */
;;;7367       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7368       {
;;;7369         hi2c->PreviousState       = I2C_STATE_NONE;
;;;7370         hi2c->State               = HAL_I2C_STATE_READY;
;;;7371         hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7372         hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7373   
;;;7374         /* Process Unlocked */
;;;7375         __HAL_UNLOCK(hi2c);
;;;7376   
;;;7377         return HAL_ERROR;
;;;7378       }
;;;7379     }
;;;7380     return HAL_OK;
;;;7381   }
000014  bd70              POP      {r4-r6,pc}
                  |L79.22|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6              ;7367
00001c  42a8              CMP      r0,r5                 ;7367
00001e  d800              BHI      |L79.34|
000020  b995              CBNZ     r5,|L79.72|
                  |L79.34|
000022  2000              MOVS     r0,#0                 ;7369
000024  6320              STR      r0,[r4,#0x30]         ;7369
000026  2020              MOVS     r0,#0x20              ;7370
000028  f884003d          STRB     r0,[r4,#0x3d]         ;7370
00002c  2000              MOVS     r0,#0                 ;7371
00002e  f884003e          STRB     r0,[r4,#0x3e]         ;7371
000032  6c20              LDR      r0,[r4,#0x40]         ;7372
000034  f0400020          ORR      r0,r0,#0x20           ;7372
000038  6420              STR      r0,[r4,#0x40]         ;7372
00003a  bf00              NOP                            ;7375
00003c  2000              MOVS     r0,#0                 ;7375
00003e  f884003c          STRB     r0,[r4,#0x3c]         ;7375
000042  bf00              NOP                            ;7375
000044  2001              MOVS     r0,#1                 ;7377
000046  e7e5              B        |L79.20|
                  |L79.72|
000048  6820              LDR      r0,[r4,#0]            ;7358
00004a  6940              LDR      r0,[r0,#0x14]         ;7358
00004c  f3c01000          UBFX     r0,r0,#4,#1           ;7358
000050  2800              CMP      r0,#0                 ;7358
000052  d0da              BEQ      |L79.10|
000054  2000              MOVS     r0,#0                 ;7380
000056  e7dd              B        |L79.20|
;;;7382   
                          ENDP


                          AREA ||i.I2C_WaitOnSTOPRequestThroughIT||, CODE, READONLY, ALIGN=2

                  I2C_WaitOnSTOPRequestThroughIT PROC
;;;7388     */
;;;7389   static HAL_StatusTypeDef I2C_WaitOnSTOPRequestThroughIT(I2C_HandleTypeDef *hi2c)
000000  b508              PUSH     {r3,lr}
;;;7390   {
000002  4601              MOV      r1,r0
;;;7391     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;7392   
;;;7393     /* Wait until STOP flag is reset */
;;;7394     count = I2C_TIMEOUT_STOP_FLAG * (SystemCoreClock / 25U / 1000U);
000008  4810              LDR      r0,|L80.76|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  2219              MOVS     r2,#0x19
00000e  fbb0f0f2          UDIV     r0,r0,r2
000012  f44f727a          MOV      r2,#0x3e8
000016  fbb0f0f2          UDIV     r0,r0,r2
00001a  eb000080          ADD      r0,r0,r0,LSL #2
00001e  9000              STR      r0,[sp,#0]
;;;7395     do
000020  bf00              NOP      
                  |L80.34|
;;;7396     {
;;;7397       count--;
000022  9800              LDR      r0,[sp,#0]
000024  1e40              SUBS     r0,r0,#1
000026  9000              STR      r0,[sp,#0]
;;;7398       if (count == 0U)
000028  9800              LDR      r0,[sp,#0]
00002a  b928              CBNZ     r0,|L80.56|
;;;7399       {
;;;7400         hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00002c  6c08              LDR      r0,[r1,#0x40]
00002e  f0400020          ORR      r0,r0,#0x20
000032  6408              STR      r0,[r1,#0x40]
;;;7401   
;;;7402         return HAL_ERROR;
000034  2001              MOVS     r0,#1
                  |L80.54|
;;;7403       }
;;;7404     }
;;;7405     while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
;;;7406   
;;;7407     return HAL_OK;
;;;7408   }
000036  bd08              POP      {r3,pc}
                  |L80.56|
000038  6808              LDR      r0,[r1,#0]            ;7405
00003a  6800              LDR      r0,[r0,#0]            ;7405
00003c  f4007000          AND      r0,r0,#0x200          ;7405
000040  f5b07f00          CMP      r0,#0x200             ;7405
000044  d0ed              BEQ      |L80.34|
000046  2000              MOVS     r0,#0                 ;7407
000048  e7f5              B        |L80.54|
;;;7409   
                          ENDP

00004a  0000              DCW      0x0000
                  |L80.76|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_WaitOnTXEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnTXEFlagUntilTimeout PROC
;;;7279     */
;;;7280   static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;7281   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;7282     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
000008  e020              B        |L81.76|
                  |L81.10|
;;;7283     {
;;;7284       /* Check if a NACK is detected */
;;;7285       if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L81.22|
;;;7286       {
;;;7287         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L81.20|
;;;7288       }
;;;7289   
;;;7290       /* Check for the Timeout */
;;;7291       if (Timeout != HAL_MAX_DELAY)
;;;7292       {
;;;7293         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7294         {
;;;7295           hi2c->PreviousState       = I2C_STATE_NONE;
;;;7296           hi2c->State               = HAL_I2C_STATE_READY;
;;;7297           hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7298           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7299   
;;;7300           /* Process Unlocked */
;;;7301           __HAL_UNLOCK(hi2c);
;;;7302   
;;;7303           return HAL_ERROR;
;;;7304         }
;;;7305       }
;;;7306     }
;;;7307     return HAL_OK;
;;;7308   }
000014  bd70              POP      {r4-r6,pc}
                  |L81.22|
000016  1c68              ADDS     r0,r5,#1              ;7291
000018  b1c0              CBZ      r0,|L81.76|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b80              SUBS     r0,r0,r6              ;7293
000020  42a8              CMP      r0,r5                 ;7293
000022  d800              BHI      |L81.38|
000024  b995              CBNZ     r5,|L81.76|
                  |L81.38|
000026  2000              MOVS     r0,#0                 ;7295
000028  6320              STR      r0,[r4,#0x30]         ;7295
00002a  2020              MOVS     r0,#0x20              ;7296
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;7296
000030  2000              MOVS     r0,#0                 ;7297
000032  f884003e          STRB     r0,[r4,#0x3e]         ;7297
000036  6c20              LDR      r0,[r4,#0x40]         ;7298
000038  f0400020          ORR      r0,r0,#0x20           ;7298
00003c  6420              STR      r0,[r4,#0x40]         ;7298
00003e  bf00              NOP                            ;7301
000040  2000              MOVS     r0,#0                 ;7301
000042  f884003c          STRB     r0,[r4,#0x3c]         ;7301
000046  bf00              NOP                            ;7301
000048  2001              MOVS     r0,#1                 ;7303
00004a  e7e3              B        |L81.20|
                  |L81.76|
00004c  6820              LDR      r0,[r4,#0]            ;7282
00004e  6940              LDR      r0,[r0,#0x14]         ;7282
000050  f3c010c0          UBFX     r0,r0,#7,#1           ;7282
000054  2800              CMP      r0,#0                 ;7282
000056  d0d8              BEQ      |L81.10|
000058  2000              MOVS     r0,#0                 ;7307
00005a  e7db              B        |L81.20|
;;;7309   
                          ENDP


;*** Start embedded assembler ***

#line 1 "D:\\Keil_v5\\ARM\\PACK\\Keil\\STM32F4xx_DFP\\2.16.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____RRX|
#line 587
|__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
