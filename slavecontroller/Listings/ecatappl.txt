; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\ecatappl.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ecatappl.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\ecatappl.crf etherCAT\ecatappl.c]
                          THUMB

                          AREA ||i.ECAT_Application||, CODE, READONLY, ALIGN=2

                  ECAT_Application PROC
;;;956    /*ET9300 Project Handler :(#if _PIC18 && AL_EVENT_ENABLED) lines 1546 to 1550 deleted*/
;;;957    void ECAT_Application(void)
000000  b510              PUSH     {r4,lr}
;;;958    {
;;;959    #if (MIN_PD_CYCLE_TIME == 0)
;;;960        UINT32 u32TimeValue = 0;
000002  2400              MOVS     r4,#0
;;;961    
;;;962    
;;;963        if (MEASUREMENT_ACTIVE)
000004  482d              LDR      r0,|L1.188|
000006  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManOutPar
000008  f0000001          AND      r0,r0,#1
00000c  b920              CBNZ     r0,|L1.24|
00000e  482c              LDR      r0,|L1.192|
000010  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManInPar
000012  f0000001          AND      r0,r0,#1
000016  b170              CBZ      r0,|L1.54|
                  |L1.24|
;;;964        {
;;;965            u32TimeValue = GetSystemTimeDelay(0);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       GetSystemTimeDelay
00001e  4604              MOV      r4,r0
;;;966    
;;;967            if (nPdOutputSize == 0)
000020  4828              LDR      r0,|L1.196|
000022  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
000024  b938              CBNZ     r0,|L1.54|
;;;968            {
;;;969                /* in case of an input only device the cycle starts with an ECAT_Application call*/
;;;970    
;;;971                u32MinCycleTimeStartValue = u32TimeValue;
000026  4828              LDR      r0,|L1.200|
000028  6004              STR      r4,[r0,#0]  ; u32MinCycleTimeStartValue
;;;972                bMinCycleTimeMeasurementStarted = TRUE;
00002a  2001              MOVS     r0,#1
00002c  4927              LDR      r1,|L1.204|
00002e  7008              STRB     r0,[r1,#0]
;;;973                u32MinCycleTimeValue = 0;
000030  2000              MOVS     r0,#0
000032  4927              LDR      r1,|L1.208|
000034  6008              STR      r0,[r1,#0]  ; u32MinCycleTimeValue
                  |L1.54|
;;;974            }
;;;975        } /* measurement started*/
;;;976    #endif /* (MIN_PD_CYCLE_TIME == 0)*/
;;;977    
;;;978        if (MEASUREMENT_ACTIVE)
000036  4821              LDR      r0,|L1.188|
000038  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManOutPar
00003a  f0000001          AND      r0,r0,#1
00003e  b920              CBNZ     r0,|L1.74|
000040  481f              LDR      r0,|L1.192|
000042  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManInPar
000044  f0000001          AND      r0,r0,#1
000048  b120              CBZ      r0,|L1.84|
                  |L1.74|
;;;979        {
;;;980            if (nPdOutputSize == 0)
00004a  481e              LDR      r0,|L1.196|
00004c  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
00004e  b908              CBNZ     r0,|L1.84|
;;;981            {
;;;982                /* in case of an input only device the cycle starts with an ECAT_Application call*/
;;;983                HandleCycleTimeMeasurement();
000050  f7fffffe          BL       HandleCycleTimeMeasurement
                  |L1.84|
;;;984            }
;;;985        }
;;;986    
;;;987    
;;;988        /*ECATCHANGE_START(V5.13) CIA402 4*/
;;;989        /*decouple CIA402 application from ESM*/
;;;990        /*ECATCHANGE_END(V5.13) CIA402 4*/
;;;991        APPL_Application();
000054  f7fffffe          BL       APPL_Application
;;;992    
;;;993    /* PDO Input mapping is called from the specific trigger ISR */
;;;994    
;;;995    #if (MIN_PD_CYCLE_TIME == 0)
;;;996    
;;;997        if (MEASUREMENT_ACTIVE)
000058  4818              LDR      r0,|L1.188|
00005a  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManOutPar
00005c  f0000001          AND      r0,r0,#1
000060  b920              CBNZ     r0,|L1.108|
000062  4817              LDR      r0,|L1.192|
000064  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManInPar
000066  f0000001          AND      r0,r0,#1
00006a  b328              CBZ      r0,|L1.184|
                  |L1.108|
;;;998        {
;;;999            u32TimeValue = GetSystemTimeDelay(u32TimeValue);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       GetSystemTimeDelay
000072  4604              MOV      r4,r0
;;;1000   
;;;1001   
;;;1002           /* handle the min cycle time measurement only if a new cycle was started (prevent measurement failures if the get cycle time bit is set within a process data cycle)*/
;;;1003           if (bMinCycleTimeMeasurementStarted == TRUE)
000074  4815              LDR      r0,|L1.204|
000076  7800              LDRB     r0,[r0,#0]  ; bMinCycleTimeMeasurementStarted
000078  2801              CMP      r0,#1
00007a  d11d              BNE      |L1.184|
;;;1004           {
;;;1005   
;;;1006               /* add application execution time to the min cycle time*/
;;;1007               u32MinCycleTimeValue = u32MinCycleTimeValue + u32TimeValue;
00007c  4814              LDR      r0,|L1.208|
00007e  6800              LDR      r0,[r0,#0]  ; u32MinCycleTimeValue
000080  4420              ADD      r0,r0,r4
000082  4913              LDR      r1,|L1.208|
000084  6008              STR      r0,[r1,#0]  ; u32MinCycleTimeValue
;;;1008   
;;;1009               if (nPdInputSize == 0)
000086  4813              LDR      r0,|L1.212|
000088  8800              LDRH     r0,[r0,#0]  ; nPdInputSize
00008a  b9a8              CBNZ     r0,|L1.184|
;;;1010               {
;;;1011                   /* In case of an output only device the cycle ends with an ECAT_Application call*/
;;;1012   
;;;1013   
;;;1014                   if (sSyncManOutPar.u32MinCycleTime < u32MinCycleTimeValue)
00008c  480b              LDR      r0,|L1.188|
00008e  6900              LDR      r0,[r0,#0x10]  ; sSyncManOutPar
000090  6809              LDR      r1,[r1,#0]  ; u32MinCycleTimeValue
000092  4288              CMP      r0,r1
000094  d203              BCS      |L1.158|
;;;1015                   {
;;;1016                           sSyncManOutPar.u32MinCycleTime = u32MinCycleTimeValue;
000096  480e              LDR      r0,|L1.208|
000098  6800              LDR      r0,[r0,#0]  ; u32MinCycleTimeValue
00009a  4908              LDR      r1,|L1.188|
00009c  6108              STR      r0,[r1,#0x10]  ; sSyncManOutPar
                  |L1.158|
;;;1017                   }
;;;1018   
;;;1019                   if (sSyncManInPar.u32MinCycleTime < u32MinCycleTimeValue)
00009e  4808              LDR      r0,|L1.192|
0000a0  6900              LDR      r0,[r0,#0x10]  ; sSyncManInPar
0000a2  490b              LDR      r1,|L1.208|
0000a4  6809              LDR      r1,[r1,#0]  ; u32MinCycleTimeValue
0000a6  4288              CMP      r0,r1
0000a8  d203              BCS      |L1.178|
;;;1020                   {
;;;1021                           sSyncManInPar.u32MinCycleTime = u32MinCycleTimeValue;
0000aa  4809              LDR      r0,|L1.208|
0000ac  6800              LDR      r0,[r0,#0]  ; u32MinCycleTimeValue
0000ae  4904              LDR      r1,|L1.192|
0000b0  6108              STR      r0,[r1,#0x10]  ; sSyncManInPar
                  |L1.178|
;;;1022                   }
;;;1023   
;;;1024                   bMinCycleTimeMeasurementStarted = FALSE;
0000b2  2000              MOVS     r0,#0
0000b4  4905              LDR      r1,|L1.204|
0000b6  7008              STRB     r0,[r1,#0]
                  |L1.184|
;;;1025               }
;;;1026           }
;;;1027   
;;;1028       }/* measurement started*/
;;;1029   #endif /* #if MIN_PD_CYCLE_TIME == 0 */
;;;1030   }
0000b8  bd10              POP      {r4,pc}
;;;1031   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L1.188|
                          DCD      sSyncManOutPar
                  |L1.192|
                          DCD      sSyncManInPar
                  |L1.196|
                          DCD      nPdOutputSize
                  |L1.200|
                          DCD      u32MinCycleTimeStartValue
                  |L1.204|
                          DCD      bMinCycleTimeMeasurementStarted
                  |L1.208|
                          DCD      u32MinCycleTimeValue
                  |L1.212|
                          DCD      nPdInputSize

                          AREA ||i.ECAT_CheckTimer||, CODE, READONLY, ALIGN=2

                  ECAT_CheckTimer PROC
;;;349    
;;;350    void ECAT_CheckTimer(void)
000000  b510              PUSH     {r4,lr}
;;;351    {
;;;352    
;;;353        /*decrement the state transition timeout counter*/
;;;354        if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
000002  4819              LDR      r0,|L2.104|
000004  7800              LDRB     r0,[r0,#0]  ; bEcatWaitForAlControlRes
000006  b150              CBZ      r0,|L2.30|
000008  4818              LDR      r0,|L2.108|
00000a  f9b00000          LDRSH    r0,[r0,#0]  ; EsmTimeoutCounter
00000e  2800              CMP      r0,#0
000010  dd05              BLE      |L2.30|
;;;355        {
;;;356            EsmTimeoutCounter--;
000012  4816              LDR      r0,|L2.108|
000014  8800              LDRH     r0,[r0,#0]  ; EsmTimeoutCounter
000016  1e40              SUBS     r0,r0,#1
000018  b200              SXTH     r0,r0
00001a  4914              LDR      r1,|L2.108|
00001c  8008              STRH     r0,[r1,#0]
                  |L2.30|
;;;357        }
;;;358    
;;;359    /*ET9300 Project Handler :(#if !ESC_SM_WD_SUPPORTED) lines 444 to 449 deleted*/
;;;360    
;;;361    /*ET9300 Project Handler :(#if UC_SET_ECAT_LED) lines 451 to 453 deleted*/
;;;362    
;;;363        DC_CheckWatchdog();
00001e  f7fffffe          BL       DC_CheckWatchdog
;;;364    
;;;365    /*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 459 to 478 deleted*/
;;;366    
;;;367    
;;;368    /*ECATCHANGE_START(V5.13) */
;;;369        /* Increment the counter every ms between two updates based on the system time (32Bit overrun is handled in COE_SyncTimeStamp) */
;;;370        if (!b32BitDc || ((u64Timestamp & 0xFFFFFFFF) <= 4293000000UL))
000022  4813              LDR      r0,|L2.112|
000024  7800              LDRB     r0,[r0,#0]  ; b32BitDc
000026  b138              CBZ      r0,|L2.56|
000028  4912              LDR      r1,|L2.116|
00002a  c903              LDM      r1,{r0,r1}
00002c  2100              MOVS     r1,#0
00002e  4b12              LDR      r3,|L2.120|
000030  1a18              SUBS     r0,r3,r0
000032  eb710201          SBCS     r2,r1,r1
000036  d30a              BCC      |L2.78|
                  |L2.56|
;;;371    /*ECATCHANGE_END(V5.13) */
;;;372        {
;;;373    
;;;374            /* the timestamp is stored in ns */
;;;375            u64Timestamp = u64Timestamp + 1000000;
000038  480e              LDR      r0,|L2.116|
00003a  e9d01000          LDRD     r1,r0,[r0,#0]
00003e  4b0f              LDR      r3,|L2.124|
000040  18c9              ADDS     r1,r1,r3
000042  f1400000          ADC      r0,r0,#0
000046  4a0b              LDR      r2,|L2.116|
000048  e9c21000          STRD     r1,r0,[r2,#0]
00004c  e006              B        |L2.92|
                  |L2.78|
;;;376    
;;;377        }
;;;378        else if(b32BitDc)
00004e  4808              LDR      r0,|L2.112|
000050  7800              LDRB     r0,[r0,#0]  ; b32BitDc
000052  b118              CBZ      r0,|L2.92|
;;;379        {
;;;380            /* in case of a 32Bit DC and almost expired time stamp check for a DC overrun*/
;;;381            u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
000054  f44f607a          MOV      r0,#0xfa0
000058  4909              LDR      r1,|L2.128|
00005a  6008              STR      r0,[r1,#0]  ; u32CheckForDcOverrunCnt
                  |L2.92|
;;;382        }
;;;383    
;;;384        u32CheckForDcOverrunCnt++;
00005c  4808              LDR      r0,|L2.128|
00005e  6800              LDR      r0,[r0,#0]  ; u32CheckForDcOverrunCnt
000060  1c40              ADDS     r0,r0,#1
000062  4907              LDR      r1,|L2.128|
000064  6008              STR      r0,[r1,#0]  ; u32CheckForDcOverrunCnt
;;;385    
;;;386    
;;;387    /*ET9300 Project Handler :(#if TEST_APPLICATION && COE_SUPPORTED) lines 508 to 512 deleted*/
;;;388    }
000066  bd10              POP      {r4,pc}
;;;389    
                          ENDP

                  |L2.104|
                          DCD      bEcatWaitForAlControlRes
                  |L2.108|
                          DCD      EsmTimeoutCounter
                  |L2.112|
                          DCD      b32BitDc
                  |L2.116|
                          DCD      u64Timestamp
                  |L2.120|
                          DCD      0xffe1fb40
                  |L2.124|
                          DCD      0x000f4240
                  |L2.128|
                          DCD      u32CheckForDcOverrunCnt

                          AREA ||i.ESC_EepromAccess||, CODE, READONLY, ALIGN=1

                  ESC_EepromAccess PROC
;;;1045   
;;;1046   UINT16 ESC_EepromAccess(UINT32 wordaddress, UINT16 wordsize, UINT16 MBXMEM *pData, UINT8 access)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1047   {
000004  b087              SUB      sp,sp,#0x1c
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
00000a  461f              MOV      r7,r3
;;;1048       UINT16 i;
;;;1049       UINT8 u8TimeOut;
;;;1050       UINT16 u16RetErr = 0;
00000c  2000              MOVS     r0,#0
00000e  9005              STR      r0,[sp,#0x14]
;;;1051       UINT16 u16WordOffset = 0;
000010  4682              MOV      r10,r0
;;;1052       UINT8 RetryCnt = MAX_CMD_RETIRES; //Maximum number of retries (evaluated in case of an Acknowledge Error)
000012  200a              MOVS     r0,#0xa
000014  9004              STR      r0,[sp,#0x10]
;;;1053   
;;;1054   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1667 to 1675 deleted*/
;;;1055       UINT16 nConfig;
;;;1056       VARVOLATILE UINT16 nControl;
;;;1057   
;;;1058       HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
000016  2202              MOVS     r2,#2
000018  01c1              LSLS     r1,r0,#7
00001a  a803              ADD      r0,sp,#0xc
00001c  f7fffffe          BL       HW_EscRead
;;;1059       HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
000020  2202              MOVS     r2,#2
000022  f2405102          MOV      r1,#0x502
000026  a802              ADD      r0,sp,#8
000028  f7fffffe          BL       HW_EscRead
;;;1060   
;;;1061   /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 1682 to 1685 deleted*/
;;;1062   
;;;1063   
;;;1064   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1689 to 1691 deleted*/
;;;1065       if ( nConfig & ESC_EEPROM_ASSIGN_TO_PDI_MASK )
00002c  f8bd000c          LDRH     r0,[sp,#0xc]
000030  f0000001          AND      r0,r0,#1
000034  2800              CMP      r0,#0
000036  d07d              BEQ      |L3.308|
;;;1066       {
;;;1067           /* register 0x500.0 is set (should be written by the master before sending
;;;1068           the state transition request to PREOP),we have access to the EEPROM */
;;;1069           UINT16 step = 1; /* we write always only 1 word with one write access */
000038  2501              MOVS     r5,#1
;;;1070   
;;;1071           if ( access == ESC_RD )
00003a  b93f              CBNZ     r7,|L3.76|
;;;1072           {
;;;1073               /* read access requested, we have to check if we read 2 (register 0x502.6=0)
;;;1074               or 4 words (register 0x502.6=1) with one access */
;;;1075   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1703 to 1705 deleted*/
;;;1076               if ( nControl & ESC_EEPROM_SUPPORTED_READBYTES_MASK )
00003c  f8bd0008          LDRH     r0,[sp,#8]
000040  f0000040          AND      r0,r0,#0x40
000044  b108              CBZ      r0,|L3.74|
;;;1077               {
;;;1078                   step = 4; /* we get 4 words with one read access */
000046  2504              MOVS     r5,#4
000048  e000              B        |L3.76|
                  |L3.74|
;;;1079               }
;;;1080               else
;;;1081               {
;;;1082                   step = 2; /* we get 2 words with one read access */
00004a  2502              MOVS     r5,#2
                  |L3.76|
;;;1083               }
;;;1084           }
;;;1085   
;;;1086           /* first we have to lock the EEPROM access that we will not be interrupted by the master
;;;1087           by setting register 0x501.0 */
;;;1088   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1719 to 1733 deleted*/
;;;1089           nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
00004c  f44f7080          MOV      r0,#0x100
000050  9003              STR      r0,[sp,#0xc]
;;;1090   /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 1735 to 1737 deleted*/
;;;1091           HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
000052  2202              MOVS     r2,#2
000054  f44f61a0          MOV      r1,#0x500
000058  a803              ADD      r0,sp,#0xc
00005a  f7fffffe          BL       HW_EscWrite
;;;1092           for (i = 0; i < wordsize;)
00005e  2400              MOVS     r4,#0
000060  e0a0              B        |L3.420|
                  |L3.98|
;;;1093           {
;;;1094               /* we have to set the start address in register 0x504-0x507 */
;;;1095   /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 1743 to 1746 deleted*/
;;;1096   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1747 to 1749 deleted*/
;;;1097               HW_EscWrite((MEM_ADDR *) &wordaddress, ESC_EEPROM_ADDRESS_OFFSET, 4);
000062  2204              MOVS     r2,#4
000064  f2405104          MOV      r1,#0x504
000068  a807              ADD      r0,sp,#0x1c
00006a  f7fffffe          BL       HW_EscWrite
;;;1098   
;;;1099               if ( access == ESC_RD )
00006e  b94f              CBNZ     r7,|L3.132|
;;;1100               {
;;;1101                   /* read access, we start the reading by setting 0x502.8
;;;1102                   (will be reset automatically when reading is finished) */
;;;1103   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1758 to 1766 deleted*/
;;;1104                   nControl = ESC_EEPROM_CMD_READ_MASK;
000070  f44f7080          MOV      r0,#0x100
000074  9002              STR      r0,[sp,#8]
;;;1105   /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 1768 to 1770 deleted*/
;;;1106                   HW_EscWriteWord(nControl,ESC_EEPROM_CONTROL_OFFSET);
000076  2202              MOVS     r2,#2
000078  f2405102          MOV      r1,#0x502
00007c  a802              ADD      r0,sp,#8
00007e  f7fffffe          BL       HW_EscWrite
000082  e00f              B        |L3.164|
                  |L3.132|
;;;1107               }
;;;1108               else
;;;1109               {
;;;1110                   /* write access, we write the data in register 0x508-0x509 */
;;;1111   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1777 to 1789 deleted*/
;;;1112                   HW_EscWriteWord(pData[i],ESC_EEPROM_DATA_OFFSET);
000084  eb090044          ADD      r0,r9,r4,LSL #1
000088  2202              MOVS     r2,#2
00008a  f44f61a1          MOV      r1,#0x508
00008e  f7fffffe          BL       HW_EscWrite
;;;1113   
;;;1114                   /* we start the writing by setting 0x502.9
;;;1115                   (will be reset automatically when writing is finished) */
;;;1116   
;;;1117                   nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
000092  f44f7000          MOV      r0,#0x200
000096  9002              STR      r0,[sp,#8]
;;;1118   
;;;1119                   HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
000098  2202              MOVS     r2,#2
00009a  f2405102          MOV      r1,#0x502
00009e  a802              ADD      r0,sp,#8
0000a0  f7fffffe          BL       HW_EscWrite
                  |L3.164|
;;;1120               }
;;;1121   
;;;1122               do
0000a4  bf00              NOP      
                  |L3.166|
;;;1123               {
;;;1124   
;;;1125                   /*Wait 100 cycles before reading EEPROM status*/
;;;1126                   u8TimeOut = 100;
0000a6  2064              MOVS     r0,#0x64
0000a8  9006              STR      r0,[sp,#0x18]
;;;1127                   while (u8TimeOut > 0)
0000aa  e003              B        |L3.180|
                  |L3.172|
;;;1128                   {
;;;1129                       u8TimeOut--;
0000ac  9806              LDR      r0,[sp,#0x18]
0000ae  1e40              SUBS     r0,r0,#1
0000b0  b2c0              UXTB     r0,r0
0000b2  9006              STR      r0,[sp,#0x18]
                  |L3.180|
0000b4  9806              LDR      r0,[sp,#0x18]         ;1127
0000b6  2800              CMP      r0,#0                 ;1127
0000b8  dcf8              BGT      |L3.172|
;;;1130                   }
;;;1131   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1810 to 1818 deleted*/
;;;1132                   HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
0000ba  2202              MOVS     r2,#2
0000bc  f2405102          MOV      r1,#0x502
0000c0  a802              ADD      r0,sp,#8
0000c2  f7fffffe          BL       HW_EscRead
;;;1133   
;;;1134   /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 1821 to 1823 deleted*/
;;;1135               }
;;;1136               while ( nControl & (ESC_EEPROM_BUSY_MASK));
0000c6  f8bd0008          LDRH     r0,[sp,#8]
0000ca  f4004000          AND      r0,r0,#0x8000
0000ce  2800              CMP      r0,#0
0000d0  d1e9              BNE      |L3.166|
;;;1137   
;;;1138               /* we have to check if the access was without errors */
;;;1139   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1829 to 1845 deleted*/
;;;1140               HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
0000d2  2202              MOVS     r2,#2
0000d4  f2405102          MOV      r1,#0x502
0000d8  a802              ADD      r0,sp,#8
0000da  f7fffffe          BL       HW_EscRead
;;;1141   
;;;1142   /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 1848 to 1850 deleted*/
;;;1143               if ( nControl & ESC_EEPROM_ERROR_MASK )
0000de  f8bd0008          LDRH     r0,[sp,#8]
0000e2  f40040f0          AND      r0,r0,#0x7800
0000e6  b148              CBZ      r0,|L3.252|
;;;1144               {
;;;1145                   if(!(nControl & ESC_EEPROM_ERROR_CMD_ACK) && (RetryCnt != 0))
0000e8  f8bd0008          LDRH     r0,[sp,#8]
0000ec  f4005000          AND      r0,r0,#0x2000
0000f0  b9d8              CBNZ     r0,|L3.298|
0000f2  9804              LDR      r0,[sp,#0x10]
0000f4  b1c8              CBZ      r0,|L3.298|
;;;1146                   {
;;;1147                       /* Only abort if non Acknowledge Error occurs
;;;1148                          In case of an Acknowledge Error the operation should be repeated*/
;;;1149                       u16RetErr =  ALSTATUSCODE_EE_ERROR;
0000f6  2051              MOVS     r0,#0x51
0000f8  9005              STR      r0,[sp,#0x14]
;;;1150                       break;
0000fa  e056              B        |L3.426|
                  |L3.252|
;;;1151                   }
;;;1152               }
;;;1153               else
;;;1154               {
;;;1155                   if ( access == ESC_RD )
0000fc  b9af              CBNZ     r7,|L3.298|
;;;1156                   {
;;;1157                       UINT16 u16BytesToCopy = (step << 1);
0000fe  f64f70ff          MOV      r0,#0xffff
000102  ea000845          AND      r8,r0,r5,LSL #1
;;;1158   
;;;1159                       /* read access, get the data from register 0x508-0x50B(0x50F)*/
;;;1160                       if((u16WordOffset + step) > wordsize)
000106  eb0a0005          ADD      r0,r10,r5
00010a  42b0              CMP      r0,r6
00010c  dd05              BLE      |L3.282|
;;;1161                       {
;;;1162                           /*less than "step" words are left => copy only last required Bytes*/
;;;1163                           u16BytesToCopy = (wordsize - u16WordOffset) << 1;
00010e  eba6000a          SUB      r0,r6,r10
000112  f64f71ff          MOV      r1,#0xffff
000116  ea010840          AND      r8,r1,r0,LSL #1
                  |L3.282|
;;;1164                       }
;;;1165   
;;;1166                       HW_EscRead((MEM_ADDR *) &pData[i], ESC_EEPROM_DATA_OFFSET, u16BytesToCopy);
00011a  eb090044          ADD      r0,r9,r4,LSL #1
00011e  4642              MOV      r2,r8
000120  f44f61a1          MOV      r1,#0x508
000124  f7fffffe          BL       HW_EscRead
;;;1167                   }
000128  bf00              NOP      
                  |L3.298|
;;;1168               }
;;;1169   
;;;1170   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1879 to 1881 deleted*/
;;;1171               if(!(nControl & ESC_EEPROM_ERROR_MASK))
00012a  f8bd0008          LDRH     r0,[sp,#8]
00012e  f40040f0          AND      r0,r0,#0x7800
000132  e000              B        |L3.310|
                  |L3.308|
000134  e03b              B        |L3.430|
                  |L3.310|
000136  b958              CBNZ     r0,|L3.336|
;;;1172               {
;;;1173                   /* In case of Acknowledge Error repeat same operation, otherwise increment the address and proceed*/
;;;1174                   wordaddress += step;
000138  9807              LDR      r0,[sp,#0x1c]
00013a  4428              ADD      r0,r0,r5
00013c  9007              STR      r0,[sp,#0x1c]
;;;1175                   u16WordOffset +=step;
00013e  eb0a0005          ADD      r0,r10,r5
000142  fa1ffa80          UXTH     r10,r0
;;;1176                   RetryCnt = MAX_CMD_RETIRES;
000146  200a              MOVS     r0,#0xa
000148  9004              STR      r0,[sp,#0x10]
;;;1177   
;;;1178                   i += step;
00014a  1960              ADDS     r0,r4,r5
00014c  b284              UXTH     r4,r0
00014e  e029              B        |L3.420|
                  |L3.336|
;;;1179               }
;;;1180               else
;;;1181               {
;;;1182                   RetryCnt --;
000150  9804              LDR      r0,[sp,#0x10]
000152  1e40              SUBS     r0,r0,#1
000154  b2c0              UXTB     r0,r0
000156  9004              STR      r0,[sp,#0x10]
;;;1183                   if(RetryCnt > 0)
000158  9804              LDR      r0,[sp,#0x10]
00015a  2800              CMP      r0,#0
00015c  dd1f              BLE      |L3.414|
;;;1184                   {
;;;1185   /*ECATCHANGE_START(V5.13) ECAT4*/
;;;1186                       /* Wait for 10ms until repeat EEPROM access */
;;;1187                       INT32 i32TimeoutTicks = (INT32)(ECAT_TIMER_INC_P_MS * 10);
00015e  200a              MOVS     r0,#0xa
000160  9001              STR      r0,[sp,#4]
;;;1188   /*ECATCHANGE_END(V5.13) ECAT4*/
;;;1189                       UINT32 u16CurTimer = 0;
000162  f04f0800          MOV      r8,#0
;;;1190                       UINT32 u16LastTimer = HAL_GetTick();
000166  f7fffffe          BL       HAL_GetTick
00016a  4683              MOV      r11,r0
;;;1191                       UINT32 Delta = 0;
00016c  2000              MOVS     r0,#0
00016e  9000              STR      r0,[sp,#0]
;;;1192   
;;;1193                       /* Start wait loop */
;;;1194                       while(i32TimeoutTicks > 0)
000170  e011              B        |L3.406|
                  |L3.370|
;;;1195                       {
;;;1196                           u16CurTimer = HAL_GetTick();
000172  f7fffffe          BL       HAL_GetTick
000176  4680              MOV      r8,r0
;;;1197   
;;;1198                           if(u16LastTimer <= u16CurTimer)
000178  45c3              CMP      r11,r8
00017a  d803              BHI      |L3.388|
;;;1199                           {
;;;1200                               Delta = (u16CurTimer - u16LastTimer);
00017c  eba8000b          SUB      r0,r8,r11
000180  9000              STR      r0,[sp,#0]
000182  e003              B        |L3.396|
                  |L3.388|
;;;1201                           }
;;;1202                           else
;;;1203                           {
;;;1204                               /* 16bit overrun*/
;;;1205                               Delta = (0xFFFFFFFFU - u16LastTimer) + u16CurTimer;
000184  f1cb30ff          RSB      r0,r11,#0xffffffff
000188  4440              ADD      r0,r0,r8
00018a  9000              STR      r0,[sp,#0]
                  |L3.396|
;;;1206                           }
;;;1207                           i32TimeoutTicks = i32TimeoutTicks - Delta;
00018c  e9dd1000          LDRD     r1,r0,[sp,#0]
000190  1a40              SUBS     r0,r0,r1
000192  9001              STR      r0,[sp,#4]
;;;1208   
;;;1209                           u16LastTimer = u16CurTimer;
000194  46c3              MOV      r11,r8
                  |L3.406|
000196  9801              LDR      r0,[sp,#4]            ;1194
000198  2800              CMP      r0,#0                 ;1194
00019a  dcea              BGT      |L3.370|
;;;1210                       }
;;;1211                   }
00019c  e002              B        |L3.420|
                  |L3.414|
;;;1212                   else
;;;1213                   {
;;;1214                       /* Abort EEPROM access if max retires are reached*/
;;;1215                       u16RetErr =  ALSTATUSCODE_EE_ERROR;
00019e  2051              MOVS     r0,#0x51
0001a0  9005              STR      r0,[sp,#0x14]
;;;1216                       break;
0001a2  e002              B        |L3.426|
                  |L3.420|
0001a4  42b4              CMP      r4,r6                 ;1092
0001a6  f6ffaf5c          BLT      |L3.98|
                  |L3.426|
0001aa  bf00              NOP                            ;1150
;;;1217                   }
;;;1218               }
;;;1219           } //for-loop over all data
;;;1220       } // if EEPROM access is assigned to PDI
0001ac  e001              B        |L3.434|
                  |L3.430|
;;;1221       else
;;;1222       {
;;;1223           u16RetErr = ALSTATUSCODE_EE_NOACCESS;
0001ae  2050              MOVS     r0,#0x50
0001b0  9005              STR      r0,[sp,#0x14]
                  |L3.434|
;;;1224       }
;;;1225   
;;;1226       /* clear EEPROM control register 0x500 */
;;;1227   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1939 to 1943 deleted*/
;;;1228       nConfig = 0;
0001b2  2000              MOVS     r0,#0
0001b4  9003              STR      r0,[sp,#0xc]
;;;1229   
;;;1230       HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
0001b6  2202              MOVS     r2,#2
0001b8  f44f61a0          MOV      r1,#0x500
0001bc  a803              ADD      r0,sp,#0xc
0001be  f7fffffe          BL       HW_EscWrite
;;;1231       return u16RetErr;
0001c2  9805              LDR      r0,[sp,#0x14]
;;;1232   }
0001c4  b00b              ADD      sp,sp,#0x2c
0001c6  e8bd8ff0          POP      {r4-r11,pc}
;;;1233   
                          ENDP


                          AREA ||i.ESC_EepromWriteCRC||, CODE, READONLY, ALIGN=1

                  ESC_EepromWriteCRC PROC
;;;1241    *////////////////////////////////////////////////////////////////////////////////////////
;;;1242   UINT16 ESC_EepromWriteCRC(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1243   {
000002  b085              SUB      sp,sp,#0x14
;;;1244       UINT16 u16Return = ALSTATUSCODE_UNSPECIFIEDERROR;
000004  2501              MOVS     r5,#1
;;;1245       UINT16 EscCfgData[8];
;;;1246       UINT16 u16Crc = 0x00FF;
000006  20ff              MOVS     r0,#0xff
000008  9000              STR      r0,[sp,#0]
;;;1247       UINT16 i,j;
;;;1248   
;;;1249       
;;;1250       u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
00000a  2300              MOVS     r3,#0
00000c  aa01              ADD      r2,sp,#4
00000e  2107              MOVS     r1,#7
000010  4618              MOV      r0,r3
000012  f7fffffe          BL       ESC_EepromAccess
000016  4605              MOV      r5,r0
;;;1251       if(u16Return == 0)
000018  2d00              CMP      r5,#0
00001a  d133              BNE      |L4.132|
;;;1252       {
;;;1253           UINT8 *pData = (UINT8 *)EscCfgData;
00001c  af01              ADD      r7,sp,#4
;;;1254   
;;;1255           for(i = 0; i < 14; i++ )
00001e  2400              MOVS     r4,#0
000020  e020              B        |L4.100|
                  |L4.34|
;;;1256           {
;;;1257               u16Crc ^= pData[i];
000022  5d38              LDRB     r0,[r7,r4]
000024  f8bd1000          LDRH     r1,[sp,#0]
000028  4048              EORS     r0,r0,r1
00002a  9000              STR      r0,[sp,#0]
;;;1258   
;;;1259               for(j=0; j<8; j++ )
00002c  2600              MOVS     r6,#0
00002e  e015              B        |L4.92|
                  |L4.48|
;;;1260               {
;;;1261                   if( u16Crc & 0x80 )
000030  f8bd0000          LDRH     r0,[sp,#0]
000034  f0000080          AND      r0,r0,#0x80
000038  b138              CBZ      r0,|L4.74|
;;;1262                   {
;;;1263                       u16Crc = (u16Crc<<1) ^ 0x07;
00003a  f8bd0000          LDRH     r0,[sp,#0]
00003e  2107              MOVS     r1,#7
000040  ea810040          EOR      r0,r1,r0,LSL #1
000044  b280              UXTH     r0,r0
000046  9000              STR      r0,[sp,#0]
000048  e006              B        |L4.88|
                  |L4.74|
;;;1264                   }
;;;1265                   else
;;;1266                   {
;;;1267                       u16Crc <<= 1;
00004a  f8bd0000          LDRH     r0,[sp,#0]
00004e  f64f71ff          MOV      r1,#0xffff
000052  ea010040          AND      r0,r1,r0,LSL #1
000056  9000              STR      r0,[sp,#0]
                  |L4.88|
000058  1c70              ADDS     r0,r6,#1              ;1259
00005a  b286              UXTH     r6,r0                 ;1259
                  |L4.92|
00005c  2e08              CMP      r6,#8                 ;1259
00005e  dbe7              BLT      |L4.48|
000060  1c60              ADDS     r0,r4,#1              ;1255
000062  b284              UXTH     r4,r0                 ;1255
                  |L4.100|
000064  2c0e              CMP      r4,#0xe               ;1255
000066  dbdc              BLT      |L4.34|
;;;1268                   }
;;;1269               }
;;;1270           }
;;;1271   
;;;1272           /*only low Byte shall be written*/
;;;1273           u16Crc &= 0x00FF;
000068  f8bd0000          LDRH     r0,[sp,#0]
00006c  b2c0              UXTB     r0,r0
00006e  9000              STR      r0,[sp,#0]
;;;1274   
;;;1275           /*write new calculated Crc to Esc Config area*/
;;;1276           u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
000070  2301              MOVS     r3,#1
000072  466a              MOV      r2,sp
000074  4619              MOV      r1,r3
000076  2007              MOVS     r0,#7
000078  f7fffffe          BL       ESC_EepromAccess
00007c  4605              MOV      r5,r0
;;;1277           if(u16Return == 0)
00007e  b905              CBNZ     r5,|L4.130|
;;;1278           {
;;;1279               u16Return =  ALSTATUSCODE_WAITFORCOLDSTART;
000080  2520              MOVS     r5,#0x20
                  |L4.130|
;;;1280           }
;;;1281       }
000082  bf00              NOP      
                  |L4.132|
;;;1282   
;;;1283       return u16Return;
000084  4628              MOV      r0,r5
;;;1284   }
000086  b005              ADD      sp,sp,#0x14
000088  bdf0              POP      {r4-r7,pc}
;;;1285   
                          ENDP


                          AREA ||i.GetSystemTimeDelay||, CODE, READONLY, ALIGN=2

                  GetSystemTimeDelay PROC
;;;428    
;;;429    UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
000000  b538              PUSH     {r3-r5,lr}
;;;430    {
000002  4604              MOV      r4,r0
;;;431       UINT32 u32CurValue = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;432       UINT32 u32Delta = 0;
000008  2500              MOVS     r5,#0
;;;433    
;;;434       
;;;435       HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
00000a  2204              MOVS     r2,#4
00000c  f44f6111          MOV      r1,#0x910
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       HW_EscReadIsr
;;;436    
;;;437       if (u32CurValue > 0)
000016  9800              LDR      r0,[sp,#0]
000018  b148              CBZ      r0,|L5.46|
;;;438       {
;;;439          if (u32StartTime <= u32CurValue)
00001a  9800              LDR      r0,[sp,#0]
00001c  4284              CMP      r4,r0
00001e  d802              BHI      |L5.38|
;;;440          {
;;;441             u32Delta = u32CurValue - u32StartTime;
000020  9800              LDR      r0,[sp,#0]
000022  1b05              SUBS     r5,r0,r4
000024  e003              B        |L5.46|
                  |L5.38|
;;;442          }
;;;443          else
;;;444          {
;;;445             //The 32Bit timer is wrapped around
;;;446             u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
000026  f1c430ff          RSB      r0,r4,#0xffffffff
00002a  9900              LDR      r1,[sp,#0]
00002c  1845              ADDS     r5,r0,r1
                  |L5.46|
;;;447          }
;;;448       }// current value successfully read out
;;;449    
;;;450       if (u32StartTime > 0)
00002e  b144              CBZ      r4,|L5.66|
;;;451       {
;;;452    
;;;453           /*the difference between two timestamps are calculated => subtract measurement failure*/
;;;454           if (u32SystemTimeReadFailure < u32Delta)
000030  4805              LDR      r0,|L5.72|
000032  6800              LDR      r0,[r0,#0]  ; u32SystemTimeReadFailure
000034  42a8              CMP      r0,r5
000036  d203              BCS      |L5.64|
;;;455           {
;;;456               u32Delta = u32Delta - u32SystemTimeReadFailure;
000038  4803              LDR      r0,|L5.72|
00003a  6800              LDR      r0,[r0,#0]  ; u32SystemTimeReadFailure
00003c  1a2d              SUBS     r5,r5,r0
00003e  e000              B        |L5.66|
                  |L5.64|
;;;457           }
;;;458           else
;;;459           {
;;;460               /*set the delta to 0 if the measurement failure is greater than the calculated difference*/
;;;461               u32Delta = 0;
000040  2500              MOVS     r5,#0
                  |L5.66|
;;;462           }
;;;463       }
;;;464       return u32Delta;
000042  4628              MOV      r0,r5
;;;465    }
000044  bd38              POP      {r3-r5,pc}
;;;466    
                          ENDP

000046  0000              DCW      0x0000
                  |L5.72|
                          DCD      u32SystemTimeReadFailure

                          AREA ||i.HandleCycleTimeMeasurement||, CODE, READONLY, ALIGN=2

                  HandleCycleTimeMeasurement PROC
;;;393    *////////////////////////////////////////////////////////////////////////////////////////
;;;394    void HandleCycleTimeMeasurement(void)
000000  b510              PUSH     {r4,lr}
;;;395    {
;;;396        if (!bDcSyncActive) //no DC sync configured (cycle time measurement 0x1C3x.2 is only available in no DC sync modes)
000002  4815              LDR      r0,|L6.88|
000004  7800              LDRB     r0,[r0,#0]  ; bDcSyncActive
000006  bb30              CBNZ     r0,|L6.86|
;;;397        {
;;;398            if (u32CycleTimeStartValue > 0)
000008  4814              LDR      r0,|L6.92|
00000a  6800              LDR      r0,[r0,#0]  ; u32CycleTimeStartValue
00000c  b1f0              CBZ      r0,|L6.76|
;;;399            {
;;;400                /* bus cycle completed*/
;;;401                u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
00000e  4813              LDR      r0,|L6.92|
000010  6800              LDR      r0,[r0,#0]  ; u32CycleTimeStartValue
000012  f7fffffe          BL       GetSystemTimeDelay
000016  4911              LDR      r1,|L6.92|
000018  6008              STR      r0,[r1,#0]  ; u32CycleTimeStartValue
;;;402    
;;;403                if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
00001a  4811              LDR      r0,|L6.96|
00001c  6840              LDR      r0,[r0,#4]  ; sSyncManOutPar
00001e  b120              CBZ      r0,|L6.42|
000020  480f              LDR      r0,|L6.96|
000022  6840              LDR      r0,[r0,#4]  ; sSyncManOutPar
000024  6809              LDR      r1,[r1,#0]  ; u32CycleTimeStartValue
000026  4288              CMP      r0,r1
000028  d903              BLS      |L6.50|
                  |L6.42|
;;;404                {
;;;405                        sSyncManOutPar.u32CycleTime = u32CycleTimeStartValue;
00002a  480c              LDR      r0,|L6.92|
00002c  6800              LDR      r0,[r0,#0]  ; u32CycleTimeStartValue
00002e  490c              LDR      r1,|L6.96|
000030  6048              STR      r0,[r1,#4]  ; sSyncManOutPar
                  |L6.50|
;;;406                }
;;;407    
;;;408                if ((sSyncManInPar.u32CycleTime == 0) || (sSyncManInPar.u32CycleTime > u32CycleTimeStartValue))
000032  480c              LDR      r0,|L6.100|
000034  6840              LDR      r0,[r0,#4]  ; sSyncManInPar
000036  b128              CBZ      r0,|L6.68|
000038  480a              LDR      r0,|L6.100|
00003a  6840              LDR      r0,[r0,#4]  ; sSyncManInPar
00003c  4907              LDR      r1,|L6.92|
00003e  6809              LDR      r1,[r1,#0]  ; u32CycleTimeStartValue
000040  4288              CMP      r0,r1
000042  d903              BLS      |L6.76|
                  |L6.68|
;;;409                {
;;;410                        sSyncManInPar.u32CycleTime = u32CycleTimeStartValue;
000044  4805              LDR      r0,|L6.92|
000046  6800              LDR      r0,[r0,#0]  ; u32CycleTimeStartValue
000048  4906              LDR      r1,|L6.100|
00004a  6048              STR      r0,[r1,#4]  ; sSyncManInPar
                  |L6.76|
;;;411                }
;;;412            }
;;;413            /* get next start value */
;;;414            u32CycleTimeStartValue = GetSystemTimeDelay(0);
00004c  2000              MOVS     r0,#0
00004e  f7fffffe          BL       GetSystemTimeDelay
000052  4902              LDR      r1,|L6.92|
000054  6008              STR      r0,[r1,#0]  ; u32CycleTimeStartValue
                  |L6.86|
;;;415            
;;;416        }/* No DC sync configured */
;;;417    }
000056  bd10              POP      {r4,pc}
;;;418    
                          ENDP

                  |L6.88|
                          DCD      bDcSyncActive
                  |L6.92|
                          DCD      u32CycleTimeStartValue
                  |L6.96|
                          DCD      sSyncManOutPar
                  |L6.100|
                          DCD      sSyncManInPar

                          AREA ||i.MainInit||, CODE, READONLY, ALIGN=2

                  MainInit PROC
;;;733    
;;;734    UINT16 MainInit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;735    {
;;;736        UINT16 Error = 0;
000002  2500              MOVS     r5,#0
;;;737    /*Hardware init function need to be called from the application layer*/
;;;738    
;;;739    #ifdef SET_EEPROM_PTR
;;;740        SET_EEPROM_PTR
;;;741    #endif
;;;742    
;;;743    
;;;744    /* Reset application function pointer*/
;;;745    /*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 1240 to 1245 deleted*/
;;;746    
;;;747    
;;;748    /*ET9300 Project Handler :(#if EOE_SUPPORTED) lines 1248 to 1251 deleted*/
;;;749    
;;;750        pAPPL_FoeRead = NULL;
000004  2000              MOVS     r0,#0
000006  4939              LDR      r1,|L7.236|
000008  6008              STR      r0,[r1,#0]  ; pAPPL_FoeRead
;;;751        pAPPL_FoeReadData = NULL;
00000a  4939              LDR      r1,|L7.240|
00000c  6008              STR      r0,[r1,#0]  ; pAPPL_FoeReadData
;;;752        pAPPL_FoeError = NULL;
00000e  4939              LDR      r1,|L7.244|
000010  6008              STR      r0,[r1,#0]  ; pAPPL_FoeError
;;;753        pAPPL_FoeWrite = NULL;
000012  4939              LDR      r1,|L7.248|
000014  6008              STR      r0,[r1,#0]  ; pAPPL_FoeWrite
;;;754        pAPPL_FoeWriteData = NULL;
000016  4939              LDR      r1,|L7.252|
000018  6008              STR      r0,[r1,#0]  ; pAPPL_FoeWriteData
;;;755    
;;;756        /* ECATCHANGE_START(V5.13) COE4*/
;;;757        pAPPL_CoeReadInd = NULL;
00001a  4939              LDR      r1,|L7.256|
00001c  6008              STR      r0,[r1,#0]  ; pAPPL_CoeReadInd
;;;758        pAPPL_CoeWriteInd = NULL;
00001e  4939              LDR      r1,|L7.260|
000020  6008              STR      r0,[r1,#0]  ; pAPPL_CoeWriteInd
;;;759        /* ECATCHANGE_END(V5.13) COE4*/
;;;760    
;;;761        pAPPL_MainLoop = NULL;
000022  4939              LDR      r1,|L7.264|
000024  6008              STR      r0,[r1,#0]  ; pAPPL_MainLoop
;;;762    
;;;763        /* initialize the EtherCAT Slave Interface */
;;;764        ECAT_Init();
000026  f7fffffe          BL       ECAT_Init
;;;765        /* initialize the objects */
;;;766        COE_ObjInit();
00002a  f7fffffe          BL       COE_ObjInit
;;;767    
;;;768    /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1277 to 1280 deleted*/
;;;769    
;;;770        /*Reset PDI Access*/
;;;771        {
;;;772    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1285 to 1299 deleted*/
;;;773        UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values
00002e  2000              MOVS     r0,#0
000030  9001              STR      r0,[sp,#4]
;;;774    
;;;775        HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
000032  2202              MOVS     r2,#2
000034  f44f61a0          MOV      r1,#0x500
000038  a801              ADD      r0,sp,#4
00003a  f7fffffe          BL       HW_EscRead
;;;776        eepromConfigControl = SWAPWORD(eepromConfigControl);
00003e  f8bd0004          LDRH     r0,[sp,#4]
000042  9001              STR      r0,[sp,#4]
;;;777    
;;;778        if((eepromConfigControl & ESC_EEPROM_ASSIGN_TO_PDI_MASK) > 0)
000044  f8bd0004          LDRH     r0,[sp,#4]
000048  f0000001          AND      r0,r0,#1
00004c  2800              CMP      r0,#0
00004e  dd0d              BLE      |L7.108|
;;;779        {
;;;780            /*Clear access register(0x0501.1)*/
;;;781            eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
000050  f8bd0004          LDRH     r0,[sp,#4]
000054  f4207080          BIC      r0,r0,#0x100
000058  9001              STR      r0,[sp,#4]
;;;782    
;;;783            eepromConfigControl = SWAPWORD(eepromConfigControl);
00005a  f8bd0004          LDRH     r0,[sp,#4]
00005e  9001              STR      r0,[sp,#4]
;;;784            HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
000060  2202              MOVS     r2,#2
000062  f44f61a0          MOV      r1,#0x500
000066  a801              ADD      r0,sp,#4
000068  f7fffffe          BL       HW_EscWrite
                  |L7.108|
;;;785        }
;;;786        }
;;;787        /*indicate that the slave stack initialization finished*/
;;;788        bInitFinished = TRUE;
00006c  2001              MOVS     r0,#1
00006e  4927              LDR      r1,|L7.268|
000070  7008              STRB     r0,[r1,#0]
;;;789    
;;;790    
;;;791        bMinCycleTimeMeasurementStarted = FALSE;
000072  2000              MOVS     r0,#0
000074  4926              LDR      r1,|L7.272|
000076  7008              STRB     r0,[r1,#0]
;;;792        u32CycleTimeStartValue = 0;
000078  4926              LDR      r1,|L7.276|
00007a  6008              STR      r0,[r1,#0]  ; u32CycleTimeStartValue
;;;793        u32MinCycleTimeStartValue = 0;
00007c  4926              LDR      r1,|L7.280|
00007e  6008              STR      r0,[r1,#0]  ; u32MinCycleTimeStartValue
;;;794    
;;;795        u32SystemTimeReadFailure = 0;
000080  4926              LDR      r1,|L7.284|
000082  6008              STR      r0,[r1,#0]  ; u32SystemTimeReadFailure
;;;796    
;;;797        /* Get the System Time read failure */
;;;798        {
;;;799           UINT32 u32TimeValue = 0;
000084  9001              STR      r0,[sp,#4]
;;;800           UINT32 u32Cnt = 0;
000086  2400              MOVS     r4,#0
;;;801           UINT32 u32Delta = 0;
000088  9000              STR      r0,[sp,#0]
;;;802    
;;;803           while (u32Cnt < 1000)
00008a  e02a              B        |L7.226|
                  |L7.140|
;;;804           {
;;;805               HW_EscReadDWordIsr(u32TimeValue, ESC_SYSTEMTIME_OFFSET);
00008c  2204              MOVS     r2,#4
00008e  f44f6111          MOV      r1,#0x910
000092  a801              ADD      r0,sp,#4
000094  f7fffffe          BL       HW_EscReadIsr
;;;806               HW_EscReadDWordIsr(u32Delta, ESC_SYSTEMTIME_OFFSET);
000098  2204              MOVS     r2,#4
00009a  f44f6111          MOV      r1,#0x910
00009e  4668              MOV      r0,sp
0000a0  f7fffffe          BL       HW_EscReadIsr
;;;807    
;;;808                if (u32TimeValue <= u32Delta)
0000a4  e9dd1000          LDRD     r1,r0,[sp,#0]
0000a8  4288              CMP      r0,r1
0000aa  d804              BHI      |L7.182|
;;;809                {
;;;810                        u32Delta = u32Delta - u32TimeValue;
0000ac  e9dd0100          LDRD     r0,r1,[sp,#0]
0000b0  1a40              SUBS     r0,r0,r1
0000b2  9000              STR      r0,[sp,#0]
0000b4  e005              B        |L7.194|
                  |L7.182|
;;;811                }
;;;812                else
;;;813                {
;;;814                    //The 32Bit timer is wrapped around
;;;815                    u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
0000b6  9801              LDR      r0,[sp,#4]
0000b8  f1c030ff          RSB      r0,r0,#0xffffffff
0000bc  9900              LDR      r1,[sp,#0]
0000be  4408              ADD      r0,r0,r1
0000c0  9000              STR      r0,[sp,#0]
                  |L7.194|
;;;816                }
;;;817    
;;;818    
;;;819                if (u32SystemTimeReadFailure == 0)
0000c2  4816              LDR      r0,|L7.284|
0000c4  6800              LDR      r0,[r0,#0]  ; u32SystemTimeReadFailure
0000c6  b918              CBNZ     r0,|L7.208|
;;;820                {
;;;821                    u32SystemTimeReadFailure = u32Delta;
0000c8  4914              LDR      r1,|L7.284|
0000ca  9800              LDR      r0,[sp,#0]
0000cc  6008              STR      r0,[r1,#0]  ; u32SystemTimeReadFailure
0000ce  e007              B        |L7.224|
                  |L7.208|
;;;822                }
;;;823                else if (u32SystemTimeReadFailure > u32Delta)
0000d0  4812              LDR      r0,|L7.284|
0000d2  6800              LDR      r0,[r0,#0]  ; u32SystemTimeReadFailure
0000d4  9900              LDR      r1,[sp,#0]
0000d6  4288              CMP      r0,r1
0000d8  d902              BLS      |L7.224|
;;;824                {
;;;825                    u32SystemTimeReadFailure = u32Delta;
0000da  4910              LDR      r1,|L7.284|
0000dc  9800              LDR      r0,[sp,#0]
0000de  6008              STR      r0,[r1,#0]  ; u32SystemTimeReadFailure
                  |L7.224|
;;;826                }
;;;827    
;;;828              u32Cnt++;
0000e0  1c64              ADDS     r4,r4,#1
                  |L7.226|
0000e2  f5b47f7a          CMP      r4,#0x3e8             ;803
0000e6  d3d1              BCC      |L7.140|
;;;829           }
;;;830        
;;;831        }
;;;832    
;;;833    
;;;834    
;;;835    /*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 1368 to 1391 deleted*/
;;;836    
;;;837    /*Application Init need to be called from the application layer*/
;;;838         return Error;
0000e8  4628              MOV      r0,r5
;;;839    }
0000ea  bd7c              POP      {r2-r6,pc}
;;;840    
                          ENDP

                  |L7.236|
                          DCD      pAPPL_FoeRead
                  |L7.240|
                          DCD      pAPPL_FoeReadData
                  |L7.244|
                          DCD      pAPPL_FoeError
                  |L7.248|
                          DCD      pAPPL_FoeWrite
                  |L7.252|
                          DCD      pAPPL_FoeWriteData
                  |L7.256|
                          DCD      pAPPL_CoeReadInd
                  |L7.260|
                          DCD      pAPPL_CoeWriteInd
                  |L7.264|
                          DCD      pAPPL_MainLoop
                  |L7.268|
                          DCD      bInitFinished
                  |L7.272|
                          DCD      bMinCycleTimeMeasurementStarted
                  |L7.276|
                          DCD      u32CycleTimeStartValue
                  |L7.280|
                          DCD      u32MinCycleTimeStartValue
                  |L7.284|
                          DCD      u32SystemTimeReadFailure

                          AREA ||i.MainLoop||, CODE, READONLY, ALIGN=2

                  MainLoop PROC
;;;848    
;;;849    void MainLoop(void)
000000  b510              PUSH     {r4,lr}
;;;850    {
;;;851        
;;;852        /*return if initialization not finished */
;;;853        if(bInitFinished == FALSE)
000002  482e              LDR      r0,|L8.188|
000004  7800              LDRB     r0,[r0,#0]  ; bInitFinished
000006  b900              CBNZ     r0,|L8.10|
                  |L8.8|
;;;854        {
;;;855            return;
;;;856        }
;;;857    
;;;858    
;;;859    
;;;860            /* FreeRun-Mode:  bEscIntEnabled = FALSE, bDcSyncActive = FALSE
;;;861               Synchron-Mode: bEscIntEnabled = TRUE, bDcSyncActive = FALSE
;;;862               DC-Mode:       bEscIntEnabled = TRUE, bDcSyncActive = TRUE */
;;;863            if (
;;;864                (!bEscIntEnabled || !bEcatFirstOutputsReceived)     /* SM-Synchronous, but not SM-event received */
;;;865    /*ET9300 Project Handler :(#if MAX_PD_OUTPUT_SIZE > 0 #else) lines 1422 to 1424 deleted*/
;;;866              && !bDcSyncActive                                               /* DC-Synchronous */
;;;867                )
;;;868            {
;;;869                /* if the application is running in ECAT Synchron Mode the function ECAT_Application is called
;;;870                   from the ESC interrupt routine,
;;;871                   in ECAT Synchron Mode it should be additionally checked, if the SM-event is received
;;;872                   at least once (bEcatFirstOutputsReceived = 1), otherwise no interrupt is generated
;;;873                   and the function ECAT_Application has to be called here (with interrupts disabled,
;;;874                   because the SM-event could be generated while executing ECAT_Application) */
;;;875                if ( !bEscIntEnabled )
;;;876                {
;;;877                    /* application is running in ECAT FreeRun Mode,
;;;878                       first we have to check, if outputs were received */
;;;879                    UINT16 ALEvent = HW_GetALEventRegister();
;;;880                    ALEvent = SWAPWORD(ALEvent);
;;;881    
;;;882                    if ( ALEvent & PROCESS_OUTPUT_EVENT )
;;;883                    {
;;;884                        /* set the flag for the state machine behavior */
;;;885                        bEcatFirstOutputsReceived = TRUE;
;;;886    /*ET9300 Project Handler :(#if !ESC_SM_WD_SUPPORTED) lines 1448 to 1451 deleted*/
;;;887                        if ( bEcatOutputUpdateRunning )
;;;888                        {
;;;889                            /* update the outputs */
;;;890                            PDO_OutputMapping();
;;;891                        }
;;;892                    }
;;;893                    else if ( nPdOutputSize == 0 )
;;;894                    {
;;;895                        /* if no outputs are transmitted, the watchdog must be reset, when the inputs were read */
;;;896                        if ( ALEvent & PROCESS_INPUT_EVENT )
;;;897                        {
;;;898                            /* Outputs were updated, set flag for watchdog monitoring */
;;;899                            bEcatFirstOutputsReceived = TRUE;
;;;900    /*ET9300 Project Handler :(#if !ESC_SM_WD_SUPPORTED) lines 1466 to 1469 deleted*/
;;;901                        }
;;;902                    }
;;;903                }
;;;904    
;;;905                DISABLE_ESC_INT();
;;;906                 ECAT_Application();
;;;907    
;;;908    /*ECATCHANGE_START(V5.13) ECAT 5*/
;;;909                 if ( (bEcatInputUpdateRunning  == TRUE) && (nPdInputSize > 0))
;;;910    /*ECATCHANGE_END(V5.13) ECAT 5*/
;;;911                 {
;;;912                    /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
;;;913                    PDO_InputMapping();
;;;914                }
;;;915                ENABLE_ESC_INT();
;;;916            }
;;;917    
;;;918            /* there is no interrupt routine for the hardware timer so check the timer register if the desired cycle elapsed*/
;;;919            {
;;;920                UINT32 CurTimer = (UINT32)HW_GetTimer();
;;;921    
;;;922                if(CurTimer>= ECAT_TIMER_INC_P_MS)
;;;923                {
;;;924                    ECAT_CheckTimer();
;;;925    
;;;926                    HW_ClearTimer();
;;;927                }
;;;928            }
;;;929    
;;;930            if (u32CheckForDcOverrunCnt >= CHECK_DC_OVERRUN_IN_MS)
;;;931            {
;;;932                COE_SyncTimeStamp();
;;;933            }
;;;934    
;;;935            /* call EtherCAT functions */
;;;936            ECAT_Main();
;;;937    
;;;938            /* call lower prior application part */
;;;939           COE_Main();
;;;940           CheckIfEcatError();
;;;941    
;;;942    /*ET9300 Project Handler :(#if CiA402_SAMPLE_APPLICATION) lines 1527 to 1532 deleted*/
;;;943    
;;;944        if (pAPPL_MainLoop != NULL)
;;;945        {
;;;946            pAPPL_MainLoop();
;;;947        }
;;;948    }
000008  bd10              POP      {r4,pc}
                  |L8.10|
00000a  482d              LDR      r0,|L8.192|
00000c  7800              LDRB     r0,[r0,#0]            ;863  ; bEscIntEnabled
00000e  b118              CBZ      r0,|L8.24|
000010  482c              LDR      r0,|L8.196|
000012  7800              LDRB     r0,[r0,#0]            ;864  ; bEcatFirstOutputsReceived
000014  2800              CMP      r0,#0                 ;864
000016  d133              BNE      |L8.128|
                  |L8.24|
000018  482b              LDR      r0,|L8.200|
00001a  7800              LDRB     r0,[r0,#0]            ;866  ; bDcSyncActive
00001c  bb80              CBNZ     r0,|L8.128|
00001e  4828              LDR      r0,|L8.192|
000020  7800              LDRB     r0,[r0,#0]            ;875  ; bEscIntEnabled
000022  b9c8              CBNZ     r0,|L8.88|
000024  f7fffffe          BL       HW_GetALEventRegister
000028  4604              MOV      r4,r0                 ;879
00002a  bf00              NOP                            ;880
00002c  f4046080          AND      r0,r4,#0x400          ;882
000030  b140              CBZ      r0,|L8.68|
000032  2001              MOVS     r0,#1                 ;885
000034  4923              LDR      r1,|L8.196|
000036  7008              STRB     r0,[r1,#0]            ;885
000038  4824              LDR      r0,|L8.204|
00003a  7800              LDRB     r0,[r0,#0]            ;887  ; bEcatOutputUpdateRunning
00003c  b158              CBZ      r0,|L8.86|
00003e  f7fffffe          BL       PDO_OutputMapping
000042  e008              B        |L8.86|
                  |L8.68|
000044  4822              LDR      r0,|L8.208|
000046  8800              LDRH     r0,[r0,#0]            ;893  ; nPdOutputSize
000048  b928              CBNZ     r0,|L8.86|
00004a  f4046000          AND      r0,r4,#0x800          ;896
00004e  b110              CBZ      r0,|L8.86|
000050  2001              MOVS     r0,#1                 ;899
000052  491c              LDR      r1,|L8.196|
000054  7008              STRB     r0,[r1,#0]            ;899
                  |L8.86|
000056  bf00              NOP                            ;903
                  |L8.88|
000058  f7fffffe          BL       PDI_Disable_Global_Interrupt
00005c  491d              LDR      r1,|L8.212|
00005e  6008              STR      r0,[r1,#0]            ;905  ; restore_intsts
000060  f7fffffe          BL       ECAT_Application
000064  481c              LDR      r0,|L8.216|
000066  7800              LDRB     r0,[r0,#0]            ;909  ; bEcatInputUpdateRunning
000068  2801              CMP      r0,#1                 ;909
00006a  d105              BNE      |L8.120|
00006c  481b              LDR      r0,|L8.220|
00006e  8800              LDRH     r0,[r0,#0]            ;909  ; nPdInputSize
000070  2800              CMP      r0,#0                 ;909
000072  dd01              BLE      |L8.120|
000074  f7fffffe          BL       PDO_InputMapping
                  |L8.120|
000078  4816              LDR      r0,|L8.212|
00007a  6800              LDR      r0,[r0,#0]            ;915  ; restore_intsts
00007c  f7fffffe          BL       PDI_Restore_Global_Interrupt
                  |L8.128|
000080  f7fffffe          BL       PDI_GetTimer
000084  4604              MOV      r4,r0                 ;920
000086  b11c              CBZ      r4,|L8.144|
000088  f7fffffe          BL       ECAT_CheckTimer
00008c  f7fffffe          BL       PDI_ClearTimer
                  |L8.144|
000090  4813              LDR      r0,|L8.224|
000092  6800              LDR      r0,[r0,#0]            ;930  ; u32CheckForDcOverrunCnt
000094  f5b06f7a          CMP      r0,#0xfa0             ;930
000098  d301              BCC      |L8.158|
00009a  f7fffffe          BL       COE_SyncTimeStamp
                  |L8.158|
00009e  f7fffffe          BL       ECAT_Main
0000a2  f7fffffe          BL       COE_Main
0000a6  f7fffffe          BL       CheckIfEcatError
0000aa  480e              LDR      r0,|L8.228|
0000ac  6800              LDR      r0,[r0,#0]            ;944  ; pAPPL_MainLoop
0000ae  b110              CBZ      r0,|L8.182|
0000b0  480c              LDR      r0,|L8.228|
0000b2  6800              LDR      r0,[r0,#0]            ;946  ; pAPPL_MainLoop
0000b4  4780              BLX      r0                    ;946
                  |L8.182|
0000b6  bf00              NOP      
0000b8  e7a6              B        |L8.8|
;;;949    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L8.188|
                          DCD      bInitFinished
                  |L8.192|
                          DCD      bEscIntEnabled
                  |L8.196|
                          DCD      bEcatFirstOutputsReceived
                  |L8.200|
                          DCD      bDcSyncActive
                  |L8.204|
                          DCD      bEcatOutputUpdateRunning
                  |L8.208|
                          DCD      nPdOutputSize
                  |L8.212|
                          DCD      restore_intsts
                  |L8.216|
                          DCD      bEcatInputUpdateRunning
                  |L8.220|
                          DCD      nPdInputSize
                  |L8.224|
                          DCD      u32CheckForDcOverrunCnt
                  |L8.228|
                          DCD      pAPPL_MainLoop

                          AREA ||i.PDI_Isr||, CODE, READONLY, ALIGN=2

                  PDI_Isr PROC
;;;469    /*ET9300 Project Handler :(#if _PIC18) lines 603 to 607 deleted*/
;;;470    void PDI_Isr(void)
000000  b538              PUSH     {r3-r5,lr}
;;;471    {
;;;472        /*ECATCHANGE_START(V5.13) ECAT1*/
;;;473        BOOL SyncAcknowledgePending = FALSE;
000002  2500              MOVS     r5,#0
;;;474    
;;;475        /* get the AL event register */
;;;476        UINT16  ALEvent = HW_GetALEventRegister_Isr();
000004  f7fffffe          BL       HW_GetALEventRegister_Isr
000008  4604              MOV      r4,r0
;;;477        ALEvent = SWAPWORD(ALEvent);
00000a  bf00              NOP      
;;;478    
;;;479    
;;;480        /* Check if Sync1 Isr has to be called */
;;;481    
;;;482        if (ALEvent & SYNC1_EVENT)
00000c  f0040008          AND      r0,r4,#8
000010  b110              CBZ      r0,|L9.24|
;;;483        {
;;;484            Sync1_Isr();
000012  f7fffffe          BL       Sync1_Isr
;;;485    
;;;486            SyncAcknowledgePending = TRUE;
000016  2501              MOVS     r5,#1
                  |L9.24|
;;;487        }
;;;488        /*ECATCHANGE_END(V5.13) ECAT1*/
;;;489        
;;;490    
;;;491        if(bEscIntEnabled)
000018  4841              LDR      r0,|L9.288|
00001a  7800              LDRB     r0,[r0,#0]  ; bEscIntEnabled
00001c  2800              CMP      r0,#0
00001e  d06b              BEQ      |L9.248|
;;;492        {
;;;493            if ( ALEvent & PROCESS_OUTPUT_EVENT )
000020  f4046080          AND      r0,r4,#0x400
000024  b378              CBZ      r0,|L9.134|
;;;494            {
;;;495                if(bDcRunning && bDcSyncActive)
000026  483f              LDR      r0,|L9.292|
000028  7800              LDRB     r0,[r0,#0]  ; bDcRunning
00002a  b128              CBZ      r0,|L9.56|
00002c  483e              LDR      r0,|L9.296|
00002e  7800              LDRB     r0,[r0,#0]  ; bDcSyncActive
000030  b110              CBZ      r0,|L9.56|
;;;496                {
;;;497                    /* Reset SM/Sync0 counter. Will be incremented on every Sync0 event*/
;;;498                    u16SmSync0Counter = 0;
000032  2000              MOVS     r0,#0
000034  493d              LDR      r1,|L9.300|
000036  8008              STRH     r0,[r1,#0]
                  |L9.56|
;;;499                }
;;;500                if(sSyncManOutPar.u16SmEventMissedCounter > 0)
000038  483d              LDR      r0,|L9.304|
00003a  8d00              LDRH     r0,[r0,#0x28]  ; sSyncManOutPar
00003c  2800              CMP      r0,#0
00003e  dd04              BLE      |L9.74|
;;;501                {
;;;502                    sSyncManOutPar.u16SmEventMissedCounter--;
000040  483b              LDR      r0,|L9.304|
000042  8d00              LDRH     r0,[r0,#0x28]  ; sSyncManOutPar
000044  1e40              SUBS     r0,r0,#1
000046  493a              LDR      r1,|L9.304|
000048  8508              STRH     r0,[r1,#0x28]
                  |L9.74|
;;;503                }
;;;504    
;;;505                sSyncManInPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter;
00004a  4839              LDR      r0,|L9.304|
00004c  8d00              LDRH     r0,[r0,#0x28]  ; sSyncManOutPar
00004e  4939              LDR      r1,|L9.308|
000050  8508              STRH     r0,[r1,#0x28]
;;;506    
;;;507    /*ET9300 Project Handler :(#if COE_SUPPORTED #else) lines 654 to 659 deleted*/
;;;508    
;;;509    
;;;510            /* Outputs were updated, set flag for watchdog monitoring */
;;;511            bEcatFirstOutputsReceived = TRUE;
000052  2001              MOVS     r0,#1
000054  4938              LDR      r1,|L9.312|
000056  7008              STRB     r0,[r1,#0]
;;;512    
;;;513    /*ET9300 Project Handler :(#if !ESC_SM_WD_SUPPORTED) lines 666 to 669 deleted*/
;;;514    
;;;515            /*
;;;516                handle output process data event
;;;517            */
;;;518            if ( bEcatOutputUpdateRunning )
000058  4838              LDR      r0,|L9.316|
00005a  7800              LDRB     r0,[r0,#0]  ; bEcatOutputUpdateRunning
00005c  b110              CBZ      r0,|L9.100|
;;;519            {
;;;520                /* slave is in OP, update the outputs */
;;;521                PDO_OutputMapping();
00005e  f7fffffe          BL       PDO_OutputMapping
000062  e010              B        |L9.134|
                  |L9.100|
;;;522            }
;;;523            else
;;;524            {
;;;525                /* Just acknowledge the process data event in the INIT,PreOP and SafeOP state */
;;;526    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 682 to 685 deleted*/
;;;527                HW_EscReadWordIsr(u16dummy,nEscAddrOutputData);
000064  2202              MOVS     r2,#2
000066  4836              LDR      r0,|L9.320|
000068  8801              LDRH     r1,[r0,#0]  ; nEscAddrOutputData
00006a  4836              LDR      r0,|L9.324|
00006c  f7fffffe          BL       HW_EscReadIsr
;;;528                HW_EscReadWordIsr(u16dummy,(nEscAddrOutputData+nPdOutputSize-2));
000070  4833              LDR      r0,|L9.320|
000072  8800              LDRH     r0,[r0,#0]  ; nEscAddrOutputData
000074  4a34              LDR      r2,|L9.328|
000076  8812              LDRH     r2,[r2,#0]  ; nPdOutputSize
000078  4410              ADD      r0,r0,r2
00007a  1e80              SUBS     r0,r0,#2
00007c  b281              UXTH     r1,r0
00007e  2202              MOVS     r2,#2
000080  4830              LDR      r0,|L9.324|
000082  f7fffffe          BL       HW_EscReadIsr
                  |L9.134|
;;;529    /*ET9300 Project Handler :( #else) lines 688 to 691 deleted*/
;;;530            }
;;;531            }
;;;532    /*ET9300 Project Handler :(#elif MAX_PD_INPUT_SIZE > 0) lines 694 to 718 deleted*/
;;;533    
;;;534            /*
;;;535                Call ECAT_Application() in SM Sync mode
;;;536            */
;;;537            if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
000086  482a              LDR      r0,|L9.304|
000088  8840              LDRH     r0,[r0,#2]  ; sSyncManOutPar
00008a  2801              CMP      r0,#1
00008c  d101              BNE      |L9.146|
;;;538            {
;;;539                /* The Application is synchronized to process data Sync Manager event*/
;;;540                ECAT_Application();
00008e  f7fffffe          BL       ECAT_Application
                  |L9.146|
;;;541            }
;;;542    /*ET9300 Project Handler :(#elif MAX_PD_INPUT_SIZE > 0) lines 730 to 736 deleted*/
;;;543    /*ET9300 Project Handler :(#if COE_SUPPORTED #else) lines 737 to 744 deleted*/
;;;544    
;;;545    /*ECATCHANGE_START(V5.13) ECAT 5*/
;;;546        if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
000092  482e              LDR      r0,|L9.332|
000094  7800              LDRB     r0,[r0,#0]  ; bEcatInputUpdateRunning
000096  2801              CMP      r0,#1
000098  d10d              BNE      |L9.182|
00009a  482d              LDR      r0,|L9.336|
00009c  8800              LDRH     r0,[r0,#0]  ; nPdInputSize
00009e  2800              CMP      r0,#0
0000a0  dd09              BLE      |L9.182|
;;;547    /*ECATCHANGE_END(V5.13) ECAT 5*/
;;;548           && ((sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) || (sSyncManInPar.u16SyncType == SYNCTYPE_SM2_SYNCHRON))
0000a2  4824              LDR      r0,|L9.308|
0000a4  8840              LDRH     r0,[r0,#2]  ; sSyncManInPar
0000a6  2801              CMP      r0,#1
0000a8  d003              BEQ      |L9.178|
0000aa  4822              LDR      r0,|L9.308|
0000ac  8840              LDRH     r0,[r0,#2]  ; sSyncManInPar
0000ae  2822              CMP      r0,#0x22
0000b0  d101              BNE      |L9.182|
                  |L9.178|
;;;549    /*ET9300 Project Handler :(#if COE_SUPPORTED #else) lines 752 to 754 deleted*/
;;;550            )
;;;551        {
;;;552            /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
;;;553            PDO_InputMapping();
0000b2  f7fffffe          BL       PDO_InputMapping
                  |L9.182|
;;;554        }
;;;555    
;;;556        /*
;;;557          Check if cycle exceed
;;;558        */
;;;559        /*if next SM event was triggered during runtime increment cycle exceed counter*/
;;;560        ALEvent = HW_GetALEventRegister_Isr();
0000b6  f7fffffe          BL       HW_GetALEventRegister_Isr
0000ba  4604              MOV      r4,r0
;;;561        ALEvent = SWAPWORD(ALEvent);
0000bc  bf00              NOP      
;;;562    
;;;563        if ( ALEvent & PROCESS_OUTPUT_EVENT )
0000be  f4046080          AND      r0,r4,#0x400
0000c2  b1c8              CBZ      r0,|L9.248|
;;;564        {
;;;565            sSyncManOutPar.u16CycleExceededCounter++;
0000c4  481a              LDR      r0,|L9.304|
0000c6  8d40              LDRH     r0,[r0,#0x2a]  ; sSyncManOutPar
0000c8  1c40              ADDS     r0,r0,#1
0000ca  4919              LDR      r1,|L9.304|
0000cc  8548              STRH     r0,[r1,#0x2a]
;;;566            sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
0000ce  4608              MOV      r0,r1
0000d0  8d40              LDRH     r0,[r0,#0x2a]  ; sSyncManOutPar
0000d2  4918              LDR      r1,|L9.308|
0000d4  8548              STRH     r0,[r1,#0x2a]
;;;567    
;;;568          /* Acknowledge the process data event*/
;;;569    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 780 to 783 deleted*/
;;;570                HW_EscReadWordIsr(u16dummy,nEscAddrOutputData);
0000d6  2202              MOVS     r2,#2
0000d8  4819              LDR      r0,|L9.320|
0000da  8801              LDRH     r1,[r0,#0]  ; nEscAddrOutputData
0000dc  4819              LDR      r0,|L9.324|
0000de  f7fffffe          BL       HW_EscReadIsr
;;;571                HW_EscReadWordIsr(u16dummy,(nEscAddrOutputData+nPdOutputSize-2));
0000e2  4817              LDR      r0,|L9.320|
0000e4  8800              LDRH     r0,[r0,#0]  ; nEscAddrOutputData
0000e6  4a18              LDR      r2,|L9.328|
0000e8  8812              LDRH     r2,[r2,#0]  ; nPdOutputSize
0000ea  4410              ADD      r0,r0,r2
0000ec  1e80              SUBS     r0,r0,#2
0000ee  b281              UXTH     r1,r0
0000f0  2202              MOVS     r2,#2
0000f2  4814              LDR      r0,|L9.324|
0000f4  f7fffffe          BL       HW_EscReadIsr
                  |L9.248|
;;;572    /*ET9300 Project Handler :( #else) lines 786 to 789 deleted*/
;;;573        }
;;;574    /*ET9300 Project Handler :(#elif MAX_PD_INPUT_SIZE > 0) lines 791 to 811 deleted*/
;;;575        } //if(bEscIntEnabled)
;;;576    
;;;577          /*ECATCHANGE_START(V5.13) ECAT1*/
;;;578        if (ALEvent & SYNC0_EVENT)
0000f8  f0040004          AND      r0,r4,#4
0000fc  b110              CBZ      r0,|L9.260|
;;;579        {
;;;580            Sync0_Isr();
0000fe  f7fffffe          BL       Sync0_Isr
;;;581    
;;;582            SyncAcknowledgePending = TRUE;
000102  2501              MOVS     r5,#1
                  |L9.260|
;;;583        }
;;;584    
;;;585        /* Read Sync0/1 Status Register to acknowledge the event bit in the AL Event register */
;;;586        if (SyncAcknowledgePending)
000104  b145              CBZ      r5,|L9.280|
;;;587        {
;;;588            volatile UINT32 SyncState = 0;
000106  2000              MOVS     r0,#0
000108  9000              STR      r0,[sp,#0]
;;;589            HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
00010a  2204              MOVS     r2,#4
00010c  f640118c          MOV      r1,#0x98c
000110  4668              MOV      r0,sp
000112  f7fffffe          BL       HW_EscRead
;;;590    
;;;591        }
000116  bf00              NOP      
                  |L9.280|
;;;592        /*ECATCHANGE_END(V5.13) ECAT1*/
;;;593    
;;;594        COE_UpdateSyncErrorStatus();
000118  f7fffffe          BL       COE_UpdateSyncErrorStatus
;;;595    
;;;596    }
00011c  bd38              POP      {r3-r5,pc}
;;;597    
                          ENDP

00011e  0000              DCW      0x0000
                  |L9.288|
                          DCD      bEscIntEnabled
                  |L9.292|
                          DCD      bDcRunning
                  |L9.296|
                          DCD      bDcSyncActive
                  |L9.300|
                          DCD      u16SmSync0Counter
                  |L9.304|
                          DCD      sSyncManOutPar
                  |L9.308|
                          DCD      sSyncManInPar
                  |L9.312|
                          DCD      bEcatFirstOutputsReceived
                  |L9.316|
                          DCD      bEcatOutputUpdateRunning
                  |L9.320|
                          DCD      nEscAddrOutputData
                  |L9.324|
                          DCD      u16dummy
                  |L9.328|
                          DCD      nPdOutputSize
                  |L9.332|
                          DCD      bEcatInputUpdateRunning
                  |L9.336|
                          DCD      nPdInputSize

                          AREA ||i.PDO_InputMapping||, CODE, READONLY, ALIGN=2

                  PDO_InputMapping PROC
;;;228    /*ET9300 Project Handler :(#if _PIC18 && AL_EVENT_ENABLED) lines 284 to 288 deleted*/
;;;229    void PDO_InputMapping(void)
000000  b570              PUSH     {r4-r6,lr}
;;;230    {
;;;231    
;;;232    #if ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0))
;;;233        UINT32 u32TimeValue = 0;
000002  2400              MOVS     r4,#0
;;;234        UINT16 ALEvent = HW_GetALEventRegister_Isr();
000004  f7fffffe          BL       HW_GetALEventRegister_Isr
000008  4605              MOV      r5,r0
;;;235        ALEvent = SWAPWORD(ALEvent);
00000a  bf00              NOP      
;;;236    
;;;237        if (MEASUREMENT_ACTIVE)
00000c  4825              LDR      r0,|L10.164|
00000e  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManOutPar
000010  f0000001          AND      r0,r0,#1
000014  b920              CBNZ     r0,|L10.32|
000016  4824              LDR      r0,|L10.168|
000018  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManInPar
00001a  f0000001          AND      r0,r0,#1
00001e  b118              CBZ      r0,|L10.40|
                  |L10.32|
;;;238        {
;;;239            u32TimeValue = GetSystemTimeDelay(0);
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       GetSystemTimeDelay
000026  4604              MOV      r4,r0
                  |L10.40|
;;;240        }
;;;241    #endif /* ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0)) */
;;;242    
;;;243    
;;;244    
;;;245    
;;;246    
;;;247    
;;;248      
;;;249        APPL_InputMapping((UINT16*)aPdInputData);
000028  4820              LDR      r0,|L10.172|
00002a  f7fffffe          BL       APPL_InputMapping
;;;250        HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );
00002e  4820              LDR      r0,|L10.176|
000030  8802              LDRH     r2,[r0,#0]  ; nPdInputSize
000032  4820              LDR      r0,|L10.180|
000034  8801              LDRH     r1,[r0,#0]  ; nEscAddrInputData
000036  481d              LDR      r0,|L10.172|
000038  f7fffffe          BL       HW_EscWriteIsr
;;;251    
;;;252        
;;;253    
;;;254    #if ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0))
;;;255    
;;;256        if (MEASUREMENT_ACTIVE)
00003c  4819              LDR      r0,|L10.164|
00003e  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManOutPar
000040  f0000001          AND      r0,r0,#1
000044  b920              CBNZ     r0,|L10.80|
000046  4818              LDR      r0,|L10.168|
000048  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManInPar
00004a  f0000001          AND      r0,r0,#1
00004e  b340              CBZ      r0,|L10.162|
                  |L10.80|
;;;257        {
;;;258            u32TimeValue = GetSystemTimeDelay(u32TimeValue);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       GetSystemTimeDelay
000056  4604              MOV      r4,r0
;;;259    
;;;260    #if (PD_INPUT_CALC_AND_COPY_TIME == 0)
;;;261            if (sSyncManInPar.u32CalcAndCopyTime < u32TimeValue)
000058  4813              LDR      r0,|L10.168|
00005a  6940              LDR      r0,[r0,#0x14]  ; sSyncManInPar
00005c  42a0              CMP      r0,r4
00005e  d201              BCS      |L10.100|
;;;262            {
;;;263                sSyncManInPar.u32CalcAndCopyTime = u32TimeValue;
000060  4811              LDR      r0,|L10.168|
000062  6144              STR      r4,[r0,#0x14]  ; sSyncManInPar
                  |L10.100|
;;;264            }
;;;265    #endif
;;;266    
;;;267    #if (MIN_PD_CYCLE_TIME == 0)
;;;268            /* handle the min cycle time measurement only if a new cycle was started (prevent measurement failures if the get cycle time bit is set within a process data cycle)*/
;;;269            if (bMinCycleTimeMeasurementStarted == TRUE)
000064  4814              LDR      r0,|L10.184|
000066  7800              LDRB     r0,[r0,#0]  ; bMinCycleTimeMeasurementStarted
000068  2801              CMP      r0,#1
00006a  d11a              BNE      |L10.162|
;;;270            {
;;;271    
;;;272                /* add input mapping time to the min cycle time*/
;;;273                u32MinCycleTimeValue = u32MinCycleTimeValue + u32TimeValue;
00006c  4813              LDR      r0,|L10.188|
00006e  6800              LDR      r0,[r0,#0]  ; u32MinCycleTimeValue
000070  4420              ADD      r0,r0,r4
000072  4912              LDR      r1,|L10.188|
000074  6008              STR      r0,[r1,#0]  ; u32MinCycleTimeValue
;;;274    
;;;275    
;;;276                if (sSyncManOutPar.u32MinCycleTime < u32MinCycleTimeValue)
000076  480b              LDR      r0,|L10.164|
000078  6900              LDR      r0,[r0,#0x10]  ; sSyncManOutPar
00007a  6809              LDR      r1,[r1,#0]  ; u32MinCycleTimeValue
00007c  4288              CMP      r0,r1
00007e  d203              BCS      |L10.136|
;;;277                {
;;;278                        sSyncManOutPar.u32MinCycleTime = u32MinCycleTimeValue;
000080  480e              LDR      r0,|L10.188|
000082  6800              LDR      r0,[r0,#0]  ; u32MinCycleTimeValue
000084  4907              LDR      r1,|L10.164|
000086  6108              STR      r0,[r1,#0x10]  ; sSyncManOutPar
                  |L10.136|
;;;279                }
;;;280    
;;;281                if (sSyncManInPar.u32MinCycleTime < u32MinCycleTimeValue)
000088  4807              LDR      r0,|L10.168|
00008a  6900              LDR      r0,[r0,#0x10]  ; sSyncManInPar
00008c  490b              LDR      r1,|L10.188|
00008e  6809              LDR      r1,[r1,#0]  ; u32MinCycleTimeValue
000090  4288              CMP      r0,r1
000092  d203              BCS      |L10.156|
;;;282                {
;;;283                        sSyncManInPar.u32MinCycleTime = u32MinCycleTimeValue;
000094  4809              LDR      r0,|L10.188|
000096  6800              LDR      r0,[r0,#0]  ; u32MinCycleTimeValue
000098  4903              LDR      r1,|L10.168|
00009a  6108              STR      r0,[r1,#0x10]  ; sSyncManInPar
                  |L10.156|
;;;284                }
;;;285    
;;;286                bMinCycleTimeMeasurementStarted = FALSE;
00009c  2000              MOVS     r0,#0
00009e  4906              LDR      r1,|L10.184|
0000a0  7008              STRB     r0,[r1,#0]
                  |L10.162|
;;;287            }
;;;288    #endif /* (MIN_PD_CYCLE_TIME == 0) */
;;;289        }
;;;290    
;;;291    #endif /* ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0)) */
;;;292    
;;;293    }
0000a2  bd70              POP      {r4-r6,pc}
;;;294    /////////////////////////////////////////////////////////////////////////////////////////
                          ENDP

                  |L10.164|
                          DCD      sSyncManOutPar
                  |L10.168|
                          DCD      sSyncManInPar
                  |L10.172|
                          DCD      aPdInputData
                  |L10.176|
                          DCD      nPdInputSize
                  |L10.180|
                          DCD      nEscAddrInputData
                  |L10.184|
                          DCD      bMinCycleTimeMeasurementStarted
                  |L10.188|
                          DCD      u32MinCycleTimeValue

                          AREA ||i.PDO_OutputMapping||, CODE, READONLY, ALIGN=2

                  PDO_OutputMapping PROC
;;;299    /*ET9300 Project Handler :(#if _PIC18 && AL_EVENT_ENABLED) lines 371 to 375 deleted*/
;;;300    void PDO_OutputMapping(void)
000000  b510              PUSH     {r4,lr}
;;;301    {
;;;302       UINT32 u32TimeValue = 0;
000002  2400              MOVS     r4,#0
;;;303       if (MEASUREMENT_ACTIVE)
000004  481c              LDR      r0,|L11.120|
000006  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManOutPar
000008  f0000001          AND      r0,r0,#1
00000c  b920              CBNZ     r0,|L11.24|
00000e  481b              LDR      r0,|L11.124|
000010  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManInPar
000012  f0000001          AND      r0,r0,#1
000016  b168              CBZ      r0,|L11.52|
                  |L11.24|
;;;304       {
;;;305    #if ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0))
;;;306          u32TimeValue = GetSystemTimeDelay(0);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       GetSystemTimeDelay
00001e  4604              MOV      r4,r0
;;;307          u32MinCycleTimeStartValue = u32TimeValue;
000020  4817              LDR      r0,|L11.128|
000022  6004              STR      r4,[r0,#0]  ; u32MinCycleTimeStartValue
;;;308    
;;;309          bMinCycleTimeMeasurementStarted = TRUE;
000024  2001              MOVS     r0,#1
000026  4917              LDR      r1,|L11.132|
000028  7008              STRB     r0,[r1,#0]
;;;310          u32MinCycleTimeValue = 0;
00002a  2000              MOVS     r0,#0
00002c  4916              LDR      r1,|L11.136|
00002e  6008              STR      r0,[r1,#0]  ; u32MinCycleTimeValue
;;;311    
;;;312    #endif /* ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0)) */
;;;313    
;;;314          HandleCycleTimeMeasurement();
000030  f7fffffe          BL       HandleCycleTimeMeasurement
                  |L11.52|
;;;315    
;;;316       }
;;;317    
;;;318        HW_EscReadIsr(((MEM_ADDR *)aPdOutputData), nEscAddrOutputData, nPdOutputSize );
000034  4815              LDR      r0,|L11.140|
000036  8802              LDRH     r2,[r0,#0]  ; nPdOutputSize
000038  4815              LDR      r0,|L11.144|
00003a  8801              LDRH     r1,[r0,#0]  ; nEscAddrOutputData
00003c  4815              LDR      r0,|L11.148|
00003e  f7fffffe          BL       HW_EscReadIsr
;;;319        APPL_OutputMapping((UINT16*) aPdOutputData);
000042  4814              LDR      r0,|L11.148|
000044  f7fffffe          BL       APPL_OutputMapping
;;;320    
;;;321    
;;;322    #if ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0))
;;;323        if (MEASUREMENT_ACTIVE)
000048  480b              LDR      r0,|L11.120|
00004a  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManOutPar
00004c  f0000001          AND      r0,r0,#1
000050  b920              CBNZ     r0,|L11.92|
000052  480a              LDR      r0,|L11.124|
000054  7f00              LDRB     r0,[r0,#0x1c]  ; sSyncManInPar
000056  f0000001          AND      r0,r0,#1
00005a  b158              CBZ      r0,|L11.116|
                  |L11.92|
;;;324        {
;;;325           u32TimeValue = GetSystemTimeDelay(u32TimeValue);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       GetSystemTimeDelay
000062  4604              MOV      r4,r0
;;;326    
;;;327    #if (PD_OUTPUT_CALC_AND_COPY_TIME == 0)
;;;328           if (sSyncManOutPar.u32CalcAndCopyTime < u32TimeValue)
000064  4804              LDR      r0,|L11.120|
000066  6940              LDR      r0,[r0,#0x14]  ; sSyncManOutPar
000068  42a0              CMP      r0,r4
00006a  d201              BCS      |L11.112|
;;;329           {
;;;330              sSyncManOutPar.u32CalcAndCopyTime = u32TimeValue;
00006c  4802              LDR      r0,|L11.120|
00006e  6144              STR      r4,[r0,#0x14]  ; sSyncManOutPar
                  |L11.112|
;;;331           }
;;;332    #endif
;;;333    
;;;334    #if (MIN_PD_CYCLE_TIME == 0)
;;;335           /* add the first part of the min cycle time */
;;;336           u32MinCycleTimeValue = u32TimeValue;
000070  4805              LDR      r0,|L11.136|
000072  6004              STR      r4,[r0,#0]  ; u32MinCycleTimeValue
                  |L11.116|
;;;337    #endif
;;;338        }
;;;339    #endif /* #if ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0)) */
;;;340    }
000074  bd10              POP      {r4,pc}
;;;341    
                          ENDP

000076  0000              DCW      0x0000
                  |L11.120|
                          DCD      sSyncManOutPar
                  |L11.124|
                          DCD      sSyncManInPar
                  |L11.128|
                          DCD      u32MinCycleTimeStartValue
                  |L11.132|
                          DCD      bMinCycleTimeMeasurementStarted
                  |L11.136|
                          DCD      u32MinCycleTimeValue
                  |L11.140|
                          DCD      nPdOutputSize
                  |L11.144|
                          DCD      nEscAddrOutputData
                  |L11.148|
                          DCD      aPdOutputData

                          AREA ||i.Sync0_Isr||, CODE, READONLY, ALIGN=2

                  Sync0_Isr PROC
;;;597    
;;;598    void Sync0_Isr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;599    {
;;;600         Sync0WdCounter = 0;
000002  2000              MOVS     r0,#0
000004  4946              LDR      r1,|L12.288|
000006  8008              STRH     r0,[r1,#0]
;;;601    
;;;602        if(bDcSyncActive)
000008  4846              LDR      r0,|L12.292|
00000a  7800              LDRB     r0,[r0,#0]  ; bDcSyncActive
00000c  2800              CMP      r0,#0
00000e  d07d              BEQ      |L12.268|
;;;603        {
;;;604    /*ECATCHANGE_START(V5.13) ECAT 6*/
;;;605            BOOL bCallInputMapping = FALSE;
000010  2500              MOVS     r5,#0
;;;606    /*ECATCHANGE_END(V5.13) ECAT 6*/
;;;607    /*ET9300 Project Handler :(#if !AL_EVENT_ENABLED) lines 853 to 896 deleted*/
;;;608    
;;;609    /*ECATCHANGE_START(V5.13) ECAT 6*/
;;;610            if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
000012  4845              LDR      r0,|L12.296|
000014  7800              LDRB     r0,[r0,#0]  ; bEcatInputUpdateRunning
000016  2801              CMP      r0,#1
000018  d119              BNE      |L12.78|
00001a  4844              LDR      r0,|L12.300|
00001c  8800              LDRH     r0,[r0,#0]  ; LatchInputSync0Value
00001e  2800              CMP      r0,#0
000020  dd15              BLE      |L12.78|
000022  4843              LDR      r0,|L12.304|
000024  8800              LDRH     r0,[r0,#0]  ; nPdInputSize
000026  2800              CMP      r0,#0
000028  dd11              BLE      |L12.78|
;;;611            {
;;;612                if(LatchInputSync0Value > LatchInputSync0Counter) /* Inputs shall be latched on a specific Sync0 event */
00002a  4840              LDR      r0,|L12.300|
00002c  8800              LDRH     r0,[r0,#0]  ; LatchInputSync0Value
00002e  4941              LDR      r1,|L12.308|
000030  8809              LDRH     r1,[r1,#0]  ; LatchInputSync0Counter
000032  4288              CMP      r0,r1
000034  dd04              BLE      |L12.64|
;;;613                {
;;;614                    LatchInputSync0Counter++;
000036  483f              LDR      r0,|L12.308|
000038  8800              LDRH     r0,[r0,#0]  ; LatchInputSync0Counter
00003a  1c40              ADDS     r0,r0,#1
00003c  493d              LDR      r1,|L12.308|
00003e  8008              STRH     r0,[r1,#0]
                  |L12.64|
;;;615                }
;;;616    
;;;617                if (LatchInputSync0Value == LatchInputSync0Counter)
000040  483a              LDR      r0,|L12.300|
000042  8800              LDRH     r0,[r0,#0]  ; LatchInputSync0Value
000044  493b              LDR      r1,|L12.308|
000046  8809              LDRH     r1,[r1,#0]  ; LatchInputSync0Counter
000048  4288              CMP      r0,r1
00004a  d100              BNE      |L12.78|
;;;618                {
;;;619                    bCallInputMapping = TRUE;
00004c  2501              MOVS     r5,#1
                  |L12.78|
;;;620                }
;;;621            }
;;;622    /*ECATCHANGE_END(V5.13) ECAT 6*/
;;;623    
;;;624            if(u16SmSync0Value > 0)
00004e  483a              LDR      r0,|L12.312|
000050  8800              LDRH     r0,[r0,#0]  ; u16SmSync0Value
000052  2800              CMP      r0,#0
000054  dd51              BLE      |L12.250|
;;;625            {
;;;626               /* Check if Sm-Sync sequence is invalid */
;;;627               if (u16SmSync0Counter > u16SmSync0Value)
000056  4839              LDR      r0,|L12.316|
000058  8800              LDRH     r0,[r0,#0]  ; u16SmSync0Counter
00005a  4937              LDR      r1,|L12.312|
00005c  8809              LDRH     r1,[r1,#0]  ; u16SmSync0Value
00005e  4288              CMP      r0,r1
000060  dd20              BLE      |L12.164|
;;;628               {
;;;629                  if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
000062  4837              LDR      r0,|L12.320|
000064  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
000066  2800              CMP      r0,#0
000068  dd0a              BLE      |L12.128|
00006a  4836              LDR      r0,|L12.324|
00006c  8d00              LDRH     r0,[r0,#0x28]  ; sSyncManOutPar
00006e  4936              LDR      r1,|L12.328|
000070  8909              LDRH     r1,[r1,#8]  ; sErrorSettings
000072  4288              CMP      r0,r1
000074  dc04              BGT      |L12.128|
;;;630                  {
;;;631                     sSyncManOutPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter + 3;
000076  4833              LDR      r0,|L12.324|
000078  8d00              LDRH     r0,[r0,#0x28]  ; sSyncManOutPar
00007a  1cc0              ADDS     r0,r0,#3
00007c  4931              LDR      r1,|L12.324|
00007e  8508              STRH     r0,[r1,#0x28]
                  |L12.128|
;;;632                  }
;;;633    
;;;634                   if ((nPdInputSize > 0) && (nPdOutputSize == 0) && (sSyncManInPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
000080  482b              LDR      r0,|L12.304|
000082  8800              LDRH     r0,[r0,#0]  ; nPdInputSize
000084  2800              CMP      r0,#0
000086  dd0d              BLE      |L12.164|
000088  482d              LDR      r0,|L12.320|
00008a  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
00008c  b950              CBNZ     r0,|L12.164|
00008e  482f              LDR      r0,|L12.332|
000090  8d00              LDRH     r0,[r0,#0x28]  ; sSyncManInPar
000092  492d              LDR      r1,|L12.328|
000094  8909              LDRH     r1,[r1,#8]  ; sErrorSettings
000096  4288              CMP      r0,r1
000098  dc04              BGT      |L12.164|
;;;635                   {
;;;636                       sSyncManInPar.u16SmEventMissedCounter = sSyncManInPar.u16SmEventMissedCounter + 3;
00009a  482c              LDR      r0,|L12.332|
00009c  8d00              LDRH     r0,[r0,#0x28]  ; sSyncManInPar
00009e  1cc0              ADDS     r0,r0,#3
0000a0  492a              LDR      r1,|L12.332|
0000a2  8508              STRH     r0,[r1,#0x28]
                  |L12.164|
;;;637                   }
;;;638    
;;;639    /*ET9300 Project Handler :(#if COE_SUPPORTED #else) lines 937 to 942 deleted*/
;;;640               } // if (u16SmSync0Counter > u16SmSync0Value)
;;;641    
;;;642               
;;;643               if ((nPdOutputSize == 0) && (nPdInputSize > 0))
0000a4  4826              LDR      r0,|L12.320|
0000a6  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
0000a8  b9e0              CBNZ     r0,|L12.228|
0000aa  4821              LDR      r0,|L12.304|
0000ac  8800              LDRH     r0,[r0,#0]  ; nPdInputSize
0000ae  2800              CMP      r0,#0
0000b0  dd18              BLE      |L12.228|
;;;644               {
;;;645                  /* Input only with DC, check if the last input data was read*/
;;;646                  UINT16  ALEvent = HW_GetALEventRegister_Isr();
0000b2  f7fffffe          BL       HW_GetALEventRegister_Isr
0000b6  4604              MOV      r4,r0
;;;647                  ALEvent = SWAPWORD(ALEvent);
0000b8  bf00              NOP      
;;;648    
;;;649                  if ((ALEvent & PROCESS_INPUT_EVENT) == 0)
0000ba  f4046000          AND      r0,r4,#0x800
0000be  b958              CBNZ     r0,|L12.216|
;;;650                  {
;;;651    
;;;652                     /* no input data was read by the master, increment the sm missed counter*/
;;;653                    if (u16SmSync0Counter <= u16SmSync0Value)
0000c0  481e              LDR      r0,|L12.316|
0000c2  8800              LDRH     r0,[r0,#0]  ; u16SmSync0Counter
0000c4  491c              LDR      r1,|L12.312|
0000c6  8809              LDRH     r1,[r1,#0]  ; u16SmSync0Value
0000c8  4288              CMP      r0,r1
0000ca  dc0a              BGT      |L12.226|
;;;654                    {
;;;655                        u16SmSync0Counter++;
0000cc  481b              LDR      r0,|L12.316|
0000ce  8800              LDRH     r0,[r0,#0]  ; u16SmSync0Counter
0000d0  1c40              ADDS     r0,r0,#1
0000d2  491a              LDR      r1,|L12.316|
0000d4  8008              STRH     r0,[r1,#0]
0000d6  e004              B        |L12.226|
                  |L12.216|
;;;656                    }
;;;657                  }
;;;658                  else
;;;659                  {
;;;660                     /* Reset SM/Sync0 counter*/
;;;661                     u16SmSync0Counter = 0;
0000d8  2000              MOVS     r0,#0
0000da  4918              LDR      r1,|L12.316|
0000dc  8008              STRH     r0,[r1,#0]
;;;662    
;;;663                     sSyncManInPar.u16SmEventMissedCounter = 0;
0000de  491b              LDR      r1,|L12.332|
0000e0  8508              STRH     r0,[r1,#0x28]
                  |L12.226|
;;;664    /*ET9300 Project Handler :(#if COE_SUPPORTED #else) lines 970 to 972 deleted*/
;;;665    
;;;666                  }
;;;667               }
0000e2  e00a              B        |L12.250|
                  |L12.228|
;;;668               else if (u16SmSync0Counter <= u16SmSync0Value)
0000e4  4815              LDR      r0,|L12.316|
0000e6  8800              LDRH     r0,[r0,#0]  ; u16SmSync0Counter
0000e8  4913              LDR      r1,|L12.312|
0000ea  8809              LDRH     r1,[r1,#0]  ; u16SmSync0Value
0000ec  4288              CMP      r0,r1
0000ee  dc04              BGT      |L12.250|
;;;669               {
;;;670    
;;;671                   u16SmSync0Counter++;
0000f0  4812              LDR      r0,|L12.316|
0000f2  8800              LDRH     r0,[r0,#0]  ; u16SmSync0Counter
0000f4  1c40              ADDS     r0,r0,#1
0000f6  4911              LDR      r1,|L12.316|
0000f8  8008              STRH     r0,[r1,#0]
                  |L12.250|
;;;672               }
;;;673            }//SM -Sync monitoring enabled
;;;674    
;;;675    
;;;676            /* Application is synchronized to SYNC0 event*/
;;;677            ECAT_Application();
0000fa  f7fffffe          BL       ECAT_Application
;;;678    
;;;679    /*ECATCHANGE_START(V5.13) ECAT 6*/
;;;680            if (bCallInputMapping == TRUE)
0000fe  2d01              CMP      r5,#1
000100  d10a              BNE      |L12.280|
;;;681            {
;;;682                /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
;;;683                PDO_InputMapping();
000102  f7fffffe          BL       PDO_InputMapping
;;;684    
;;;685                if(LatchInputSync0Value == 1)
000106  4809              LDR      r0,|L12.300|
000108  8800              LDRH     r0,[r0,#0]  ; LatchInputSync0Value
00010a  e000              B        |L12.270|
                  |L12.268|
00010c  e005              B        |L12.282|
                  |L12.270|
00010e  2801              CMP      r0,#1
000110  d102              BNE      |L12.280|
;;;686                {
;;;687                    /* if inputs are latched on every Sync0 event (otherwise the counter is reset on the next Sync1 event) */
;;;688                    LatchInputSync0Counter = 0;
000112  2000              MOVS     r0,#0
000114  4907              LDR      r1,|L12.308|
000116  8008              STRH     r0,[r1,#0]
                  |L12.280|
;;;689                }
;;;690            }
;;;691    /*ECATCHANGE_END(V5.13) ECAT 6*/
;;;692    
;;;693        }
000118  bf00              NOP      
                  |L12.282|
;;;694    
;;;695        COE_UpdateSyncErrorStatus();
00011a  f7fffffe          BL       COE_UpdateSyncErrorStatus
;;;696    
;;;697    }
00011e  bd70              POP      {r4-r6,pc}
;;;698    
                          ENDP

                  |L12.288|
                          DCD      Sync0WdCounter
                  |L12.292|
                          DCD      bDcSyncActive
                  |L12.296|
                          DCD      bEcatInputUpdateRunning
                  |L12.300|
                          DCD      LatchInputSync0Value
                  |L12.304|
                          DCD      nPdInputSize
                  |L12.308|
                          DCD      LatchInputSync0Counter
                  |L12.312|
                          DCD      u16SmSync0Value
                  |L12.316|
                          DCD      u16SmSync0Counter
                  |L12.320|
                          DCD      nPdOutputSize
                  |L12.324|
                          DCD      sSyncManOutPar
                  |L12.328|
                          DCD      sErrorSettings
                  |L12.332|
                          DCD      sSyncManInPar

                          AREA ||i.Sync1_Isr||, CODE, READONLY, ALIGN=2

                  Sync1_Isr PROC
;;;698    
;;;699    void Sync1_Isr(void)
000000  b510              PUSH     {r4,lr}
;;;700    {
;;;701        Sync1WdCounter = 0;
000002  2000              MOVS     r0,#0
000004  490b              LDR      r1,|L13.52|
000006  8008              STRH     r0,[r1,#0]
;;;702    
;;;703        /*ECATCHANGE_START(V5.13) ECAT 5*/
;;;704        if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
000008  480b              LDR      r0,|L13.56|
00000a  7800              LDRB     r0,[r0,#0]  ; bEcatInputUpdateRunning
00000c  2801              CMP      r0,#1
00000e  d10c              BNE      |L13.42|
000010  480a              LDR      r0,|L13.60|
000012  8800              LDRH     r0,[r0,#0]  ; nPdInputSize
000014  2800              CMP      r0,#0
000016  dd08              BLE      |L13.42|
;;;705    /*ECATCHANGE_END(V5.13) ECAT 5*/
;;;706                && (sSyncManInPar.u16SyncType == SYNCTYPE_DCSYNC1)
000018  4809              LDR      r0,|L13.64|
00001a  8840              LDRH     r0,[r0,#2]  ; sSyncManInPar
00001c  2803              CMP      r0,#3
00001e  d104              BNE      |L13.42|
;;;707                && (LatchInputSync0Value == 0)) /* Inputs are latched on Sync1 (LatchInputSync0Value == 0), if LatchInputSync0Value > 0 inputs are latched with Sync0 */
000020  4808              LDR      r0,|L13.68|
000022  8800              LDRH     r0,[r0,#0]  ; LatchInputSync0Value
000024  b908              CBNZ     r0,|L13.42|
;;;708            {
;;;709                /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
;;;710                PDO_InputMapping();
000026  f7fffffe          BL       PDO_InputMapping
                  |L13.42|
;;;711            }
;;;712    
;;;713            /* Reset Sync0 latch counter (to start next Sync0 latch cycle) */
;;;714            LatchInputSync0Counter = 0;
00002a  2000              MOVS     r0,#0
00002c  4906              LDR      r1,|L13.72|
00002e  8008              STRH     r0,[r1,#0]
;;;715    }
000030  bd10              POP      {r4,pc}
;;;716    /////////////////////////////////////////////////////////////////////////////////////////
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      Sync1WdCounter
                  |L13.56|
                          DCD      bEcatInputUpdateRunning
                  |L13.60|
                          DCD      nPdInputSize
                  |L13.64|
                          DCD      sSyncManInPar
                  |L13.68|
                          DCD      LatchInputSync0Value
                  |L13.72|
                          DCD      LatchInputSync0Counter

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  aPdOutputData
                          %        256
                  aPdInputData
                          %        256

                          AREA ||.data||, DATA, ALIGN=2

                  bEcatWaitForInputUpdate
000000  00                DCB      0x00
                  bEtherCATRunLed
000001  00                DCB      0x00
                  bEtherCATErrorLed
000002  00                DCB      0x00
                  bRunApplication
000003  00                DCB      0x00
                  pAPPL_FoeRead
                          DCD      0x00000000
                  pAPPL_FoeReadData
                          DCD      0x00000000
                  pAPPL_FoeError
                          DCD      0x00000000
                  pAPPL_FoeWrite
                          DCD      0x00000000
                  pAPPL_FoeWriteData
                          DCD      0x00000000
                  pAPPL_CoeReadInd
                          DCD      0x00000000
                  pAPPL_CoeWriteInd
                          DCD      0x00000000
                  pAPPL_MainLoop
                          DCD      0x00000000
                  u32CycleTimeStartValue
                          DCD      0x00000000
                  u32MinCycleTimeStartValue
                          DCD      0x00000000
                  u32SystemTimeReadFailure
                          DCD      0x00000000
                  bMinCycleTimeMeasurementStarted
000030  00000000          DCB      0x00,0x00,0x00,0x00
                  u32MinCycleTimeValue
                          DCD      0x00000000
                  bInitFinished
000038  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "etherCAT\\ecatappl.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_ecatappl_c_7415b2a8____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_ecatappl_c_7415b2a8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_ecatappl_c_7415b2a8____REVSH|
#line 402
|__asm___10_ecatappl_c_7415b2a8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_ecatappl_c_7415b2a8____RRX|
#line 587
|__asm___10_ecatappl_c_7415b2a8____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
