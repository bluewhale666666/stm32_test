; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_hal_uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hal_uart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\stm32f4xx_hal_uart.crf D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2864     */
;;;2865   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2866   {
;;;2867     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2868   
;;;2869     /* Process Locked */
;;;2870     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f891003c          LDRB     r0,[r1,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L1.18|
00000e  2002              MOVS     r0,#2
                  |L1.16|
;;;2871   
;;;2872     huart->gState = HAL_UART_STATE_BUSY;
;;;2873   
;;;2874     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2875     tmpreg = huart->Instance->CR1;
;;;2876   
;;;2877     /* Clear TE and RE bits */
;;;2878     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2879   
;;;2880     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2881     tmpreg |= (uint32_t)USART_CR1_RE;
;;;2882   
;;;2883     /* Write to USART CR1 */
;;;2884     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2885   
;;;2886     huart->gState = HAL_UART_STATE_READY;
;;;2887   
;;;2888     /* Process Unlocked */
;;;2889     __HAL_UNLOCK(huart);
;;;2890   
;;;2891     return HAL_OK;
;;;2892   }
000010  4770              BX       lr
                  |L1.18|
000012  2001              MOVS     r0,#1                 ;2870
000014  f881003c          STRB     r0,[r1,#0x3c]         ;2870
000018  bf00              NOP                            ;2870
00001a  2024              MOVS     r0,#0x24              ;2872
00001c  f881003d          STRB     r0,[r1,#0x3d]         ;2872
000020  6808              LDR      r0,[r1,#0]            ;2875
000022  68c2              LDR      r2,[r0,#0xc]          ;2875
000024  f022020c          BIC      r2,r2,#0xc            ;2878
000028  f0420204          ORR      r2,r2,#4              ;2881
00002c  6808              LDR      r0,[r1,#0]            ;2884
00002e  60c2              STR      r2,[r0,#0xc]          ;2884
000030  2020              MOVS     r0,#0x20              ;2886
000032  f881003d          STRB     r0,[r1,#0x3d]         ;2886
000036  bf00              NOP                            ;2889
000038  2000              MOVS     r0,#0                 ;2889
00003a  f881003c          STRB     r0,[r1,#0x3c]         ;2889
00003e  bf00              NOP                            ;2889
000040  bf00              NOP                            ;2891
000042  e7e5              B        |L1.16|
;;;2893   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2829     */
;;;2830   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2831   {
;;;2832     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2833   
;;;2834     /* Process Locked */
;;;2835     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f891003c          LDRB     r0,[r1,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L2.18|
00000e  2002              MOVS     r0,#2
                  |L2.16|
;;;2836   
;;;2837     huart->gState = HAL_UART_STATE_BUSY;
;;;2838   
;;;2839     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2840     tmpreg = huart->Instance->CR1;
;;;2841   
;;;2842     /* Clear TE and RE bits */
;;;2843     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2844   
;;;2845     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2846     tmpreg |= (uint32_t)USART_CR1_TE;
;;;2847   
;;;2848     /* Write to USART CR1 */
;;;2849     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2850   
;;;2851     huart->gState = HAL_UART_STATE_READY;
;;;2852   
;;;2853     /* Process Unlocked */
;;;2854     __HAL_UNLOCK(huart);
;;;2855   
;;;2856     return HAL_OK;
;;;2857   }
000010  4770              BX       lr
                  |L2.18|
000012  2001              MOVS     r0,#1                 ;2835
000014  f881003c          STRB     r0,[r1,#0x3c]         ;2835
000018  bf00              NOP                            ;2835
00001a  2024              MOVS     r0,#0x24              ;2837
00001c  f881003d          STRB     r0,[r1,#0x3d]         ;2837
000020  6808              LDR      r0,[r1,#0]            ;2840
000022  68c2              LDR      r2,[r0,#0xc]          ;2840
000024  f022020c          BIC      r2,r2,#0xc            ;2843
000028  f0420208          ORR      r2,r2,#8              ;2846
00002c  6808              LDR      r0,[r1,#0]            ;2849
00002e  60c2              STR      r2,[r0,#0xc]          ;2849
000030  2020              MOVS     r0,#0x20              ;2851
000032  f881003d          STRB     r0,[r1,#0x3d]         ;2851
000036  bf00              NOP                            ;2854
000038  2000              MOVS     r0,#0                 ;2854
00003a  f881003c          STRB     r0,[r1,#0x3c]         ;2854
00003e  bf00              NOP                            ;2854
000040  bf00              NOP                            ;2856
000042  e7e5              B        |L2.16|
;;;2858   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=2

                  HAL_HalfDuplex_Init PROC
;;;432      */
;;;433    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;434    {
000002  4604              MOV      r4,r0
;;;435      /* Check the UART handle allocation */
;;;436      if (huart == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;437      {
;;;438        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;439      }
;;;440    
;;;441      /* Check the parameters */
;;;442      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;443      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;444      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;445    
;;;446      if (huart->gState == HAL_UART_STATE_RESET)
;;;447      {
;;;448        /* Allocate lock resource and initialize it */
;;;449        huart->Lock = HAL_UNLOCKED;
;;;450    
;;;451    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;452        UART_InitCallbacksToDefault(huart);
;;;453    
;;;454        if (huart->MspInitCallback == NULL)
;;;455        {
;;;456          huart->MspInitCallback = HAL_UART_MspInit;
;;;457        }
;;;458    
;;;459        /* Init the low level hardware */
;;;460        huart->MspInitCallback(huart);
;;;461    #else
;;;462        /* Init the low level hardware : GPIO, CLOCK */
;;;463        HAL_UART_MspInit(huart);
;;;464    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;465      }
;;;466    
;;;467      huart->gState = HAL_UART_STATE_BUSY;
;;;468    
;;;469      /* Disable the peripheral */
;;;470      __HAL_UART_DISABLE(huart);
;;;471    
;;;472      /* Set the UART Communication parameters */
;;;473      UART_SetConfig(huart);
;;;474    
;;;475      /* In half-duplex mode, the following bits must be kept cleared:
;;;476         - LINEN and CLKEN bits in the USART_CR2 register,
;;;477         - SCEN and IREN bits in the USART_CR3 register.*/
;;;478      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;479      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;480    
;;;481      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;482      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;483    
;;;484      /* Enable the peripheral */
;;;485      __HAL_UART_ENABLE(huart);
;;;486    
;;;487      /* Initialize the UART state*/
;;;488      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;489      huart->gState = HAL_UART_STATE_READY;
;;;490      huart->RxState = HAL_UART_STATE_READY;
;;;491    
;;;492      return HAL_OK;
;;;493    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;446
00000e  b960              CBNZ     r0,|L3.42|
000010  2000              MOVS     r0,#0                 ;449
000012  f884003c          STRB     r0,[r4,#0x3c]         ;449
000016  4620              MOV      r0,r4                 ;452
000018  f7fffffe          BL       UART_InitCallbacksToDefault
00001c  6ee0              LDR      r0,[r4,#0x6c]         ;454
00001e  b908              CBNZ     r0,|L3.36|
000020  4818              LDR      r0,|L3.132|
000022  66e0              STR      r0,[r4,#0x6c]         ;456
                  |L3.36|
000024  4620              MOV      r0,r4                 ;460
000026  6ee1              LDR      r1,[r4,#0x6c]         ;460
000028  4788              BLX      r1                    ;460
                  |L3.42|
00002a  2024              MOVS     r0,#0x24              ;467
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;467
000030  6820              LDR      r0,[r4,#0]            ;470
000032  68c0              LDR      r0,[r0,#0xc]          ;470
000034  f4205000          BIC      r0,r0,#0x2000         ;470
000038  6821              LDR      r1,[r4,#0]            ;470
00003a  60c8              STR      r0,[r1,#0xc]          ;470
00003c  4620              MOV      r0,r4                 ;473
00003e  f7fffffe          BL       UART_SetConfig
000042  6820              LDR      r0,[r4,#0]            ;478
000044  6900              LDR      r0,[r0,#0x10]         ;478
000046  f4204090          BIC      r0,r0,#0x4800         ;478
00004a  6821              LDR      r1,[r4,#0]            ;478
00004c  6108              STR      r0,[r1,#0x10]         ;478
00004e  6820              LDR      r0,[r4,#0]            ;479
000050  6940              LDR      r0,[r0,#0x14]         ;479
000052  f0200022          BIC      r0,r0,#0x22           ;479
000056  6821              LDR      r1,[r4,#0]            ;479
000058  6148              STR      r0,[r1,#0x14]         ;479
00005a  6820              LDR      r0,[r4,#0]            ;482
00005c  6940              LDR      r0,[r0,#0x14]         ;482
00005e  f0400008          ORR      r0,r0,#8              ;482
000062  6821              LDR      r1,[r4,#0]            ;482
000064  6148              STR      r0,[r1,#0x14]         ;482
000066  6820              LDR      r0,[r4,#0]            ;485
000068  68c0              LDR      r0,[r0,#0xc]          ;485
00006a  f4405000          ORR      r0,r0,#0x2000         ;485
00006e  6821              LDR      r1,[r4,#0]            ;485
000070  60c8              STR      r0,[r1,#0xc]          ;485
000072  2000              MOVS     r0,#0                 ;488
000074  6420              STR      r0,[r4,#0x40]         ;488
000076  2020              MOVS     r0,#0x20              ;489
000078  f884003d          STRB     r0,[r4,#0x3d]         ;489
00007c  f884003e          STRB     r0,[r4,#0x3e]         ;490
000080  2000              MOVS     r0,#0                 ;492
000082  e7c1              B        |L3.8|
;;;494    
                          ENDP

                  |L3.132|
                          DCD      HAL_UART_MspInit

                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=2

                  HAL_LIN_Init PROC
;;;505      */
;;;506    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;507    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;508      /* Check the UART handle allocation */
;;;509      if (huart == NULL)
000006  b90c              CBNZ     r4,|L4.12|
;;;510      {
;;;511        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L4.10|
;;;512      }
;;;513    
;;;514      /* Check the LIN UART instance */
;;;515      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;516    
;;;517      /* Check the Break detection length parameter */
;;;518      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;519      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;520      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;521    
;;;522      if (huart->gState == HAL_UART_STATE_RESET)
;;;523      {
;;;524        /* Allocate lock resource and initialize it */
;;;525        huart->Lock = HAL_UNLOCKED;
;;;526    
;;;527    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;528        UART_InitCallbacksToDefault(huart);
;;;529    
;;;530        if (huart->MspInitCallback == NULL)
;;;531        {
;;;532          huart->MspInitCallback = HAL_UART_MspInit;
;;;533        }
;;;534    
;;;535        /* Init the low level hardware */
;;;536        huart->MspInitCallback(huart);
;;;537    #else
;;;538        /* Init the low level hardware : GPIO, CLOCK */
;;;539        HAL_UART_MspInit(huart);
;;;540    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;541      }
;;;542    
;;;543      huart->gState = HAL_UART_STATE_BUSY;
;;;544    
;;;545      /* Disable the peripheral */
;;;546      __HAL_UART_DISABLE(huart);
;;;547    
;;;548      /* Set the UART Communication parameters */
;;;549      UART_SetConfig(huart);
;;;550    
;;;551      /* In LIN mode, the following bits must be kept cleared:
;;;552         - CLKEN bits in the USART_CR2 register,
;;;553         - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/
;;;554      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_CLKEN));
;;;555      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;556    
;;;557      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;558      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;559    
;;;560      /* Set the USART LIN Break detection length. */
;;;561      CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
;;;562      SET_BIT(huart->Instance->CR2, BreakDetectLength);
;;;563    
;;;564      /* Enable the peripheral */
;;;565      __HAL_UART_ENABLE(huart);
;;;566    
;;;567      /* Initialize the UART state*/
;;;568      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;569      huart->gState = HAL_UART_STATE_READY;
;;;570      huart->RxState = HAL_UART_STATE_READY;
;;;571    
;;;572      return HAL_OK;
;;;573    }
00000a  bd70              POP      {r4-r6,pc}
                  |L4.12|
00000c  f894003d          LDRB     r0,[r4,#0x3d]         ;522
000010  b960              CBNZ     r0,|L4.44|
000012  2000              MOVS     r0,#0                 ;525
000014  f884003c          STRB     r0,[r4,#0x3c]         ;525
000018  4620              MOV      r0,r4                 ;528
00001a  f7fffffe          BL       UART_InitCallbacksToDefault
00001e  6ee0              LDR      r0,[r4,#0x6c]         ;530
000020  b908              CBNZ     r0,|L4.38|
000022  481e              LDR      r0,|L4.156|
000024  66e0              STR      r0,[r4,#0x6c]         ;532
                  |L4.38|
000026  4620              MOV      r0,r4                 ;536
000028  6ee1              LDR      r1,[r4,#0x6c]         ;536
00002a  4788              BLX      r1                    ;536
                  |L4.44|
00002c  2024              MOVS     r0,#0x24              ;543
00002e  f884003d          STRB     r0,[r4,#0x3d]         ;543
000032  6820              LDR      r0,[r4,#0]            ;546
000034  68c0              LDR      r0,[r0,#0xc]          ;546
000036  f4205000          BIC      r0,r0,#0x2000         ;546
00003a  6821              LDR      r1,[r4,#0]            ;546
00003c  60c8              STR      r0,[r1,#0xc]          ;546
00003e  4620              MOV      r0,r4                 ;549
000040  f7fffffe          BL       UART_SetConfig
000044  6820              LDR      r0,[r4,#0]            ;554
000046  6900              LDR      r0,[r0,#0x10]         ;554
000048  f4206000          BIC      r0,r0,#0x800          ;554
00004c  6821              LDR      r1,[r4,#0]            ;554
00004e  6108              STR      r0,[r1,#0x10]         ;554
000050  6820              LDR      r0,[r4,#0]            ;555
000052  6940              LDR      r0,[r0,#0x14]         ;555
000054  f020002a          BIC      r0,r0,#0x2a           ;555
000058  6821              LDR      r1,[r4,#0]            ;555
00005a  6148              STR      r0,[r1,#0x14]         ;555
00005c  6820              LDR      r0,[r4,#0]            ;558
00005e  6900              LDR      r0,[r0,#0x10]         ;558
000060  f4404080          ORR      r0,r0,#0x4000         ;558
000064  6821              LDR      r1,[r4,#0]            ;558
000066  6108              STR      r0,[r1,#0x10]         ;558
000068  6820              LDR      r0,[r4,#0]            ;561
00006a  6900              LDR      r0,[r0,#0x10]         ;561
00006c  f0200020          BIC      r0,r0,#0x20           ;561
000070  6821              LDR      r1,[r4,#0]            ;561
000072  6108              STR      r0,[r1,#0x10]         ;561
000074  6820              LDR      r0,[r4,#0]            ;562
000076  6900              LDR      r0,[r0,#0x10]         ;562
000078  4328              ORRS     r0,r0,r5              ;562
00007a  6821              LDR      r1,[r4,#0]            ;562
00007c  6108              STR      r0,[r1,#0x10]         ;562
00007e  6820              LDR      r0,[r4,#0]            ;565
000080  68c0              LDR      r0,[r0,#0xc]          ;565
000082  f4405000          ORR      r0,r0,#0x2000         ;565
000086  6821              LDR      r1,[r4,#0]            ;565
000088  60c8              STR      r0,[r1,#0xc]          ;565
00008a  2000              MOVS     r0,#0                 ;568
00008c  6420              STR      r0,[r4,#0x40]         ;568
00008e  2020              MOVS     r0,#0x20              ;569
000090  f884003d          STRB     r0,[r4,#0x3d]         ;569
000094  f884003e          STRB     r0,[r4,#0x3e]         ;570
000098  2000              MOVS     r0,#0                 ;572
00009a  e7b6              B        |L4.10|
;;;574    
                          ENDP

                  |L4.156|
                          DCD      HAL_UART_MspInit

                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2748     */
;;;2749   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2750   {
;;;2751     /* Check the parameters */
;;;2752     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2753   
;;;2754     /* Process Locked */
;;;2755     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;2756   
;;;2757     huart->gState = HAL_UART_STATE_BUSY;
;;;2758   
;;;2759     /* Send break characters */
;;;2760     ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
;;;2761   
;;;2762     huart->gState = HAL_UART_STATE_READY;
;;;2763   
;;;2764     /* Process Unlocked */
;;;2765     __HAL_UNLOCK(huart);
;;;2766   
;;;2767     return HAL_OK;
;;;2768   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;2755
000012  f881003c          STRB     r0,[r1,#0x3c]         ;2755
000016  bf00              NOP                            ;2755
000018  2024              MOVS     r0,#0x24              ;2757
00001a  f881003d          STRB     r0,[r1,#0x3d]         ;2757
00001e  bf00              NOP                            ;2760
000020  bf00              NOP                            ;2760
                  |L5.34|
000022  680a              LDR      r2,[r1,#0]            ;2760
000024  320c              ADDS     r2,r2,#0xc            ;2760
000026  e8522f00          LDREX    r2,[r2,#0]            ;2760
00002a  f0420001          ORR      r0,r2,#1              ;2760
00002e  680a              LDR      r2,[r1,#0]            ;2760
000030  320c              ADDS     r2,r2,#0xc            ;2760
000032  e8420300          STREX    r3,r0,[r2,#0]         ;2760
000036  2b00              CMP      r3,#0                 ;2760
000038  d1f3              BNE      |L5.34|
00003a  bf00              NOP                            ;2760
00003c  2020              MOVS     r0,#0x20              ;2762
00003e  f881003d          STRB     r0,[r1,#0x3d]         ;2762
000042  bf00              NOP                            ;2765
000044  2000              MOVS     r0,#0                 ;2765
000046  f881003c          STRB     r0,[r1,#0x3c]         ;2765
00004a  bf00              NOP                            ;2765
00004c  bf00              NOP                            ;2767
00004e  e7de              B        |L5.14|
;;;2769   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;2775     */
;;;2776   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2777   {
;;;2778     /* Check the parameters */
;;;2779     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2780   
;;;2781     /* Process Locked */
;;;2782     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L6.16|
00000c  2002              MOVS     r0,#2
                  |L6.14|
;;;2783   
;;;2784     huart->gState = HAL_UART_STATE_BUSY;
;;;2785   
;;;2786     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;2787     ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2788   
;;;2789     huart->gState = HAL_UART_STATE_READY;
;;;2790   
;;;2791     /* Process Unlocked */
;;;2792     __HAL_UNLOCK(huart);
;;;2793   
;;;2794     return HAL_OK;
;;;2795   }
00000e  4770              BX       lr
                  |L6.16|
000010  2001              MOVS     r0,#1                 ;2782
000012  f881003c          STRB     r0,[r1,#0x3c]         ;2782
000016  bf00              NOP                            ;2782
000018  2024              MOVS     r0,#0x24              ;2784
00001a  f881003d          STRB     r0,[r1,#0x3d]         ;2784
00001e  bf00              NOP                            ;2787
000020  bf00              NOP                            ;2787
                  |L6.34|
000022  680a              LDR      r2,[r1,#0]            ;2787
000024  320c              ADDS     r2,r2,#0xc            ;2787
000026  e8522f00          LDREX    r2,[r2,#0]            ;2787
00002a  f0420002          ORR      r0,r2,#2              ;2787
00002e  680a              LDR      r2,[r1,#0]            ;2787
000030  320c              ADDS     r2,r2,#0xc            ;2787
000032  e8420300          STREX    r3,r0,[r2,#0]         ;2787
000036  2b00              CMP      r3,#0                 ;2787
000038  d1f3              BNE      |L6.34|
00003a  bf00              NOP                            ;2787
00003c  2020              MOVS     r0,#0x20              ;2789
00003e  f881003d          STRB     r0,[r1,#0x3d]         ;2789
000042  bf00              NOP                            ;2792
000044  2000              MOVS     r0,#0                 ;2792
000046  f881003c          STRB     r0,[r1,#0x3c]         ;2792
00004a  bf00              NOP                            ;2792
00004c  bf00              NOP                            ;2794
00004e  e7de              B        |L6.14|
;;;2796   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;2802     */
;;;2803   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2804   {
;;;2805     /* Check the parameters */
;;;2806     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2807   
;;;2808     /* Process Locked */
;;;2809     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;2810   
;;;2811     huart->gState = HAL_UART_STATE_BUSY;
;;;2812   
;;;2813     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;2814     ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2815   
;;;2816     huart->gState = HAL_UART_STATE_READY;
;;;2817   
;;;2818     /* Process Unlocked */
;;;2819     __HAL_UNLOCK(huart);
;;;2820   
;;;2821     return HAL_OK;
;;;2822   }
00000e  4770              BX       lr
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;2809
000012  f881003c          STRB     r0,[r1,#0x3c]         ;2809
000016  bf00              NOP                            ;2809
000018  2024              MOVS     r0,#0x24              ;2811
00001a  f881003d          STRB     r0,[r1,#0x3d]         ;2811
00001e  bf00              NOP                            ;2814
000020  bf00              NOP                            ;2814
                  |L7.34|
000022  680a              LDR      r2,[r1,#0]            ;2814
000024  320c              ADDS     r2,r2,#0xc            ;2814
000026  e8522f00          LDREX    r2,[r2,#0]            ;2814
00002a  f0220002          BIC      r0,r2,#2              ;2814
00002e  680a              LDR      r2,[r1,#0]            ;2814
000030  320c              ADDS     r2,r2,#0xc            ;2814
000032  e8420300          STREX    r3,r0,[r2,#0]         ;2814
000036  2b00              CMP      r3,#0                 ;2814
000038  d1f3              BNE      |L7.34|
00003a  bf00              NOP                            ;2814
00003c  2020              MOVS     r0,#0x20              ;2816
00003e  f881003d          STRB     r0,[r1,#0x3d]         ;2816
000042  bf00              NOP                            ;2819
000044  2000              MOVS     r0,#0                 ;2819
000046  f881003c          STRB     r0,[r1,#0x3c]         ;2819
00004a  bf00              NOP                            ;2819
00004c  bf00              NOP                            ;2821
00004e  e7de              B        |L7.14|
;;;2823   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=2

                  HAL_MultiProcessor_Init PROC
;;;586      */
;;;587    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;588    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;589      /* Check the UART handle allocation */
;;;590      if (huart == NULL)
000008  b90c              CBNZ     r4,|L8.14|
;;;591      {
;;;592        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;593      }
;;;594    
;;;595      /* Check the parameters */
;;;596      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;597    
;;;598      /* Check the Address & wake up method parameters */
;;;599      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;600      assert_param(IS_UART_ADDRESS(Address));
;;;601      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;602      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;603    
;;;604      if (huart->gState == HAL_UART_STATE_RESET)
;;;605      {
;;;606        /* Allocate lock resource and initialize it */
;;;607        huart->Lock = HAL_UNLOCKED;
;;;608    
;;;609    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;610        UART_InitCallbacksToDefault(huart);
;;;611    
;;;612        if (huart->MspInitCallback == NULL)
;;;613        {
;;;614          huart->MspInitCallback = HAL_UART_MspInit;
;;;615        }
;;;616    
;;;617        /* Init the low level hardware */
;;;618        huart->MspInitCallback(huart);
;;;619    #else
;;;620        /* Init the low level hardware : GPIO, CLOCK */
;;;621        HAL_UART_MspInit(huart);
;;;622    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;623      }
;;;624    
;;;625      huart->gState = HAL_UART_STATE_BUSY;
;;;626    
;;;627      /* Disable the peripheral */
;;;628      __HAL_UART_DISABLE(huart);
;;;629    
;;;630      /* Set the UART Communication parameters */
;;;631      UART_SetConfig(huart);
;;;632    
;;;633      /* In Multi-Processor mode, the following bits must be kept cleared:
;;;634         - LINEN and CLKEN bits in the USART_CR2 register,
;;;635         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;636      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;637      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;638    
;;;639      /* Set the USART address node */
;;;640      CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
;;;641      SET_BIT(huart->Instance->CR2, Address);
;;;642    
;;;643      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;644      CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
;;;645      SET_BIT(huart->Instance->CR1, WakeUpMethod);
;;;646    
;;;647      /* Enable the peripheral */
;;;648      __HAL_UART_ENABLE(huart);
;;;649    
;;;650      /* Initialize the UART state */
;;;651      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;652      huart->gState = HAL_UART_STATE_READY;
;;;653      huart->RxState = HAL_UART_STATE_READY;
;;;654    
;;;655      return HAL_OK;
;;;656    }
00000c  bd70              POP      {r4-r6,pc}
                  |L8.14|
00000e  f894003d          LDRB     r0,[r4,#0x3d]         ;604
000012  b960              CBNZ     r0,|L8.46|
000014  2000              MOVS     r0,#0                 ;607
000016  f884003c          STRB     r0,[r4,#0x3c]         ;607
00001a  4620              MOV      r0,r4                 ;610
00001c  f7fffffe          BL       UART_InitCallbacksToDefault
000020  6ee0              LDR      r0,[r4,#0x6c]         ;612
000022  b908              CBNZ     r0,|L8.40|
000024  4820              LDR      r0,|L8.168|
000026  66e0              STR      r0,[r4,#0x6c]         ;614
                  |L8.40|
000028  4620              MOV      r0,r4                 ;618
00002a  6ee1              LDR      r1,[r4,#0x6c]         ;618
00002c  4788              BLX      r1                    ;618
                  |L8.46|
00002e  2024              MOVS     r0,#0x24              ;625
000030  f884003d          STRB     r0,[r4,#0x3d]         ;625
000034  6820              LDR      r0,[r4,#0]            ;628
000036  68c0              LDR      r0,[r0,#0xc]          ;628
000038  f4205000          BIC      r0,r0,#0x2000         ;628
00003c  6821              LDR      r1,[r4,#0]            ;628
00003e  60c8              STR      r0,[r1,#0xc]          ;628
000040  4620              MOV      r0,r4                 ;631
000042  f7fffffe          BL       UART_SetConfig
000046  6820              LDR      r0,[r4,#0]            ;636
000048  6900              LDR      r0,[r0,#0x10]         ;636
00004a  f4204090          BIC      r0,r0,#0x4800         ;636
00004e  6821              LDR      r1,[r4,#0]            ;636
000050  6108              STR      r0,[r1,#0x10]         ;636
000052  6820              LDR      r0,[r4,#0]            ;637
000054  6940              LDR      r0,[r0,#0x14]         ;637
000056  f020002a          BIC      r0,r0,#0x2a           ;637
00005a  6821              LDR      r1,[r4,#0]            ;637
00005c  6148              STR      r0,[r1,#0x14]         ;637
00005e  6820              LDR      r0,[r4,#0]            ;640
000060  6900              LDR      r0,[r0,#0x10]         ;640
000062  f020000f          BIC      r0,r0,#0xf            ;640
000066  6821              LDR      r1,[r4,#0]            ;640
000068  6108              STR      r0,[r1,#0x10]         ;640
00006a  6820              LDR      r0,[r4,#0]            ;641
00006c  6900              LDR      r0,[r0,#0x10]         ;641
00006e  4328              ORRS     r0,r0,r5              ;641
000070  6821              LDR      r1,[r4,#0]            ;641
000072  6108              STR      r0,[r1,#0x10]         ;641
000074  6820              LDR      r0,[r4,#0]            ;644
000076  68c0              LDR      r0,[r0,#0xc]          ;644
000078  f4206000          BIC      r0,r0,#0x800          ;644
00007c  6821              LDR      r1,[r4,#0]            ;644
00007e  60c8              STR      r0,[r1,#0xc]          ;644
000080  6820              LDR      r0,[r4,#0]            ;645
000082  68c0              LDR      r0,[r0,#0xc]          ;645
000084  4330              ORRS     r0,r0,r6              ;645
000086  6821              LDR      r1,[r4,#0]            ;645
000088  60c8              STR      r0,[r1,#0xc]          ;645
00008a  6820              LDR      r0,[r4,#0]            ;648
00008c  68c0              LDR      r0,[r0,#0xc]          ;648
00008e  f4405000          ORR      r0,r0,#0x2000         ;648
000092  6821              LDR      r1,[r4,#0]            ;648
000094  60c8              STR      r0,[r1,#0xc]          ;648
000096  2000              MOVS     r0,#0                 ;651
000098  6420              STR      r0,[r4,#0x40]         ;651
00009a  2020              MOVS     r0,#0x20              ;652
00009c  f884003d          STRB     r0,[r4,#0x3d]         ;652
0000a0  f884003e          STRB     r0,[r4,#0x3e]         ;653
0000a4  2000              MOVS     r0,#0                 ;655
0000a6  e7b1              B        |L8.12|
;;;657    
                          ENDP

                  |L8.168|
                          DCD      HAL_UART_MspInit

                          AREA ||i.HAL_UARTEx_ReceiveToIdle||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle PROC
;;;1619     */
;;;1620   HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1621                                              uint32_t Timeout)
;;;1622   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
00000c  f8dda028          LDR      r10,[sp,#0x28]
;;;1623     uint8_t  *pdata8bits;
;;;1624     uint16_t *pdata16bits;
;;;1625     uint32_t tickstart;
;;;1626   
;;;1627     /* Check that a Rx process is not already ongoing */
;;;1628     if (huart->RxState == HAL_UART_STATE_READY)
000010  f894003e          LDRB     r0,[r4,#0x3e]
000014  2820              CMP      r0,#0x20
000016  d17c              BNE      |L9.274|
;;;1629     {
;;;1630       if ((pData == NULL) || (Size == 0U))
000018  b117              CBZ      r7,|L9.32|
00001a  f1b80f00          CMP      r8,#0
00001e  d102              BNE      |L9.38|
                  |L9.32|
;;;1631       {
;;;1632         return  HAL_ERROR;
000020  2001              MOVS     r0,#1
                  |L9.34|
;;;1633       }
;;;1634   
;;;1635       __HAL_LOCK(huart);
;;;1636   
;;;1637       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1638       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1639       huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;1640   
;;;1641       /* Init tickstart for timeout management */
;;;1642       tickstart = HAL_GetTick();
;;;1643   
;;;1644       huart->RxXferSize  = Size;
;;;1645       huart->RxXferCount = Size;
;;;1646   
;;;1647       /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;1648       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1649       {
;;;1650         pdata8bits  = NULL;
;;;1651         pdata16bits = (uint16_t *) pData;
;;;1652       }
;;;1653       else
;;;1654       {
;;;1655         pdata8bits  = pData;
;;;1656         pdata16bits = NULL;
;;;1657       }
;;;1658   
;;;1659       __HAL_UNLOCK(huart);
;;;1660   
;;;1661       /* Initialize output number of received elements */
;;;1662       *RxLen = 0U;
;;;1663   
;;;1664       /* as long as data have to be received */
;;;1665       while (huart->RxXferCount > 0U)
;;;1666       {
;;;1667         /* Check if IDLE flag is set */
;;;1668         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
;;;1669         {
;;;1670           /* Clear IDLE flag in ISR */
;;;1671           __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;1672   
;;;1673           /* If Set, but no data ever received, clear flag without exiting loop */
;;;1674           /* If Set, and data has already been received, this means Idle Event is valid : End reception */
;;;1675           if (*RxLen > 0U)
;;;1676           {
;;;1677             huart->RxState = HAL_UART_STATE_READY;
;;;1678   
;;;1679             return HAL_OK;
;;;1680           }
;;;1681         }
;;;1682   
;;;1683         /* Check if RXNE flag is set */
;;;1684         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE))
;;;1685         {
;;;1686           if (pdata8bits == NULL)
;;;1687           {
;;;1688             *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;1689             pdata16bits++;
;;;1690           }
;;;1691           else
;;;1692           {
;;;1693             if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
;;;1694             {
;;;1695               *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1696             }
;;;1697             else
;;;1698             {
;;;1699               *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1700             }
;;;1701   
;;;1702             pdata8bits++;
;;;1703           }
;;;1704           /* Increment number of received elements */
;;;1705           *RxLen += 1U;
;;;1706           huart->RxXferCount--;
;;;1707         }
;;;1708   
;;;1709         /* Check for the Timeout */
;;;1710         if (Timeout != HAL_MAX_DELAY)
;;;1711         {
;;;1712           if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;1713           {
;;;1714             huart->RxState = HAL_UART_STATE_READY;
;;;1715   
;;;1716             return HAL_TIMEOUT;
;;;1717           }
;;;1718         }
;;;1719       }
;;;1720   
;;;1721       /* Set number of received elements in output parameter : RxLen */
;;;1722       *RxLen = huart->RxXferSize - huart->RxXferCount;
;;;1723       /* At end of Rx process, restore huart->RxState to Ready */
;;;1724       huart->RxState = HAL_UART_STATE_READY;
;;;1725   
;;;1726       return HAL_OK;
;;;1727     }
;;;1728     else
;;;1729     {
;;;1730       return HAL_BUSY;
;;;1731     }
;;;1732   }
000022  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.38|
000026  bf00              NOP                            ;1635
000028  f894003c          LDRB     r0,[r4,#0x3c]         ;1635
00002c  2801              CMP      r0,#1                 ;1635
00002e  d101              BNE      |L9.52|
000030  2002              MOVS     r0,#2                 ;1635
000032  e7f6              B        |L9.34|
                  |L9.52|
000034  2001              MOVS     r0,#1                 ;1635
000036  f884003c          STRB     r0,[r4,#0x3c]         ;1635
00003a  bf00              NOP                            ;1635
00003c  2000              MOVS     r0,#0                 ;1637
00003e  6420              STR      r0,[r4,#0x40]         ;1637
000040  2022              MOVS     r0,#0x22              ;1638
000042  f884003e          STRB     r0,[r4,#0x3e]         ;1638
000046  2001              MOVS     r0,#1                 ;1639
000048  6320              STR      r0,[r4,#0x30]         ;1639
00004a  f7fffffe          BL       HAL_GetTick
00004e  4683              MOV      r11,r0                ;1642
000050  f8a4802c          STRH     r8,[r4,#0x2c]         ;1644
000054  f8a4802e          STRH     r8,[r4,#0x2e]         ;1645
000058  68a0              LDR      r0,[r4,#8]            ;1648
00005a  f5b05f80          CMP      r0,#0x1000            ;1648
00005e  d104              BNE      |L9.106|
000060  6920              LDR      r0,[r4,#0x10]         ;1648
000062  b910              CBNZ     r0,|L9.106|
000064  2600              MOVS     r6,#0                 ;1650
000066  46b9              MOV      r9,r7                 ;1651
000068  e002              B        |L9.112|
                  |L9.106|
00006a  463e              MOV      r6,r7                 ;1655
00006c  f04f0900          MOV      r9,#0                 ;1656
                  |L9.112|
000070  bf00              NOP                            ;1659
000072  2000              MOVS     r0,#0                 ;1659
000074  f884003c          STRB     r0,[r4,#0x3c]         ;1659
000078  bf00              NOP                            ;1659
00007a  8028              STRH     r0,[r5,#0]            ;1662
00007c  e052              B        |L9.292|
                  |L9.126|
00007e  6820              LDR      r0,[r4,#0]            ;1668
000080  6800              LDR      r0,[r0,#0]            ;1668
000082  f0000010          AND      r0,r0,#0x10           ;1668
000086  2810              CMP      r0,#0x10              ;1668
000088  d111              BNE      |L9.174|
00008a  bf00              NOP                            ;1671
00008c  2000              MOVS     r0,#0                 ;1671
00008e  9000              STR      r0,[sp,#0]            ;1671
000090  6820              LDR      r0,[r4,#0]            ;1671
000092  6800              LDR      r0,[r0,#0]            ;1671
000094  9000              STR      r0,[sp,#0]            ;1671
000096  6820              LDR      r0,[r4,#0]            ;1671
000098  6840              LDR      r0,[r0,#4]            ;1671
00009a  9000              STR      r0,[sp,#0]            ;1671
00009c  bf00              NOP                            ;1671
00009e  bf00              NOP                            ;1671
0000a0  8828              LDRH     r0,[r5,#0]            ;1675
0000a2  b120              CBZ      r0,|L9.174|
0000a4  2020              MOVS     r0,#0x20              ;1677
0000a6  f884003e          STRB     r0,[r4,#0x3e]         ;1677
0000aa  2000              MOVS     r0,#0                 ;1679
0000ac  e7b9              B        |L9.34|
                  |L9.174|
0000ae  6820              LDR      r0,[r4,#0]            ;1684
0000b0  6800              LDR      r0,[r0,#0]            ;1684
0000b2  f0000020          AND      r0,r0,#0x20           ;1684
0000b6  2820              CMP      r0,#0x20              ;1684
0000b8  d121              BNE      |L9.254|
0000ba  b946              CBNZ     r6,|L9.206|
0000bc  6820              LDR      r0,[r4,#0]            ;1688
0000be  6840              LDR      r0,[r0,#4]            ;1688
0000c0  f3c00008          UBFX     r0,r0,#0,#9           ;1688
0000c4  f8a90000          STRH     r0,[r9,#0]            ;1688
0000c8  f1090902          ADD      r9,r9,#2              ;1689
0000cc  e011              B        |L9.242|
                  |L9.206|
0000ce  68a0              LDR      r0,[r4,#8]            ;1693
0000d0  f5b05f80          CMP      r0,#0x1000            ;1693
0000d4  d003              BEQ      |L9.222|
0000d6  68a0              LDR      r0,[r4,#8]            ;1693
0000d8  b928              CBNZ     r0,|L9.230|
0000da  6920              LDR      r0,[r4,#0x10]         ;1693
0000dc  b918              CBNZ     r0,|L9.230|
                  |L9.222|
0000de  6820              LDR      r0,[r4,#0]            ;1695
0000e0  6840              LDR      r0,[r0,#4]            ;1695
0000e2  7030              STRB     r0,[r6,#0]            ;1695
0000e4  e004              B        |L9.240|
                  |L9.230|
0000e6  6820              LDR      r0,[r4,#0]            ;1699
0000e8  6840              LDR      r0,[r0,#4]            ;1699
0000ea  f000007f          AND      r0,r0,#0x7f           ;1699
0000ee  7030              STRB     r0,[r6,#0]            ;1699
                  |L9.240|
0000f0  1c76              ADDS     r6,r6,#1              ;1702
                  |L9.242|
0000f2  8828              LDRH     r0,[r5,#0]            ;1705
0000f4  1c40              ADDS     r0,r0,#1              ;1705
0000f6  8028              STRH     r0,[r5,#0]            ;1705
0000f8  8de0              LDRH     r0,[r4,#0x2e]         ;1706
0000fa  1e40              SUBS     r0,r0,#1              ;1706
0000fc  85e0              STRH     r0,[r4,#0x2e]         ;1706
                  |L9.254|
0000fe  f10a0001          ADD      r0,r10,#1             ;1710
000102  b178              CBZ      r0,|L9.292|
000104  f7fffffe          BL       HAL_GetTick
000108  eba0000b          SUB      r0,r0,r11             ;1712
00010c  4550              CMP      r0,r10                ;1712
00010e  d804              BHI      |L9.282|
000110  e000              B        |L9.276|
                  |L9.274|
000112  e013              B        |L9.316|
                  |L9.276|
000114  f1ba0f00          CMP      r10,#0                ;1712
000118  d104              BNE      |L9.292|
                  |L9.282|
00011a  2020              MOVS     r0,#0x20              ;1714
00011c  f884003e          STRB     r0,[r4,#0x3e]         ;1714
000120  2003              MOVS     r0,#3                 ;1716
000122  e77e              B        |L9.34|
                  |L9.292|
000124  8de0              LDRH     r0,[r4,#0x2e]         ;1665
000126  2800              CMP      r0,#0                 ;1665
000128  d1a9              BNE      |L9.126|
00012a  8da0              LDRH     r0,[r4,#0x2c]         ;1722
00012c  8de1              LDRH     r1,[r4,#0x2e]         ;1722
00012e  1a40              SUBS     r0,r0,r1              ;1722
000130  8028              STRH     r0,[r5,#0]            ;1722
000132  2020              MOVS     r0,#0x20              ;1724
000134  f884003e          STRB     r0,[r4,#0x3e]         ;1724
000138  2000              MOVS     r0,#0                 ;1726
00013a  e772              B        |L9.34|
                  |L9.316|
00013c  2002              MOVS     r0,#2                 ;1730
00013e  e770              B        |L9.34|
;;;1733   
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle_DMA||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle_DMA PROC
;;;1807     */
;;;1808   HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1809   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1810     HAL_StatusTypeDef status;
;;;1811   
;;;1812     /* Check that a Rx process is not already ongoing */
;;;1813     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003e          LDRB     r0,[r4,#0x3e]
00000c  2820              CMP      r0,#0x20
00000e  d136              BNE      |L10.126|
;;;1814     {
;;;1815       if ((pData == NULL) || (Size == 0U))
000010  b106              CBZ      r6,|L10.20|
000012  b90f              CBNZ     r7,|L10.24|
                  |L10.20|
;;;1816       {
;;;1817         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L10.22|
;;;1818       }
;;;1819   
;;;1820       __HAL_LOCK(huart);
;;;1821   
;;;1822       /* Set Reception type to reception till IDLE Event*/
;;;1823       huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;1824   
;;;1825       status =  UART_Start_Receive_DMA(huart, pData, Size);
;;;1826   
;;;1827       /* Check Rx process has been successfully started */
;;;1828       if (status == HAL_OK)
;;;1829       {
;;;1830         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;1831         {
;;;1832           __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;1833           ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;1834         }
;;;1835         else
;;;1836         {
;;;1837           /* In case of errors already pending when reception is started,
;;;1838              Interrupts may have already been raised and lead to reception abortion.
;;;1839              (Overrun error for instance).
;;;1840              In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
;;;1841           status = HAL_ERROR;
;;;1842         }
;;;1843       }
;;;1844   
;;;1845       return status;
;;;1846     }
;;;1847     else
;;;1848     {
;;;1849       return HAL_BUSY;
;;;1850     }
;;;1851   }
000016  bdf8              POP      {r3-r7,pc}
                  |L10.24|
000018  bf00              NOP                            ;1820
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1820
00001e  2801              CMP      r0,#1                 ;1820
000020  d101              BNE      |L10.38|
000022  2002              MOVS     r0,#2                 ;1820
000024  e7f7              B        |L10.22|
                  |L10.38|
000026  2001              MOVS     r0,#1                 ;1820
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1820
00002c  bf00              NOP                            ;1820
00002e  6320              STR      r0,[r4,#0x30]         ;1823
000030  463a              MOV      r2,r7                 ;1825
000032  4631              MOV      r1,r6                 ;1825
000034  4620              MOV      r0,r4                 ;1825
000036  f7fffffe          BL       UART_Start_Receive_DMA
00003a  4605              MOV      r5,r0                 ;1825
00003c  b9ed              CBNZ     r5,|L10.122|
00003e  6b20              LDR      r0,[r4,#0x30]         ;1830
000040  2801              CMP      r0,#1                 ;1830
000042  d119              BNE      |L10.120|
000044  bf00              NOP                            ;1832
000046  2000              MOVS     r0,#0                 ;1832
000048  9000              STR      r0,[sp,#0]            ;1832
00004a  6820              LDR      r0,[r4,#0]            ;1832
00004c  6800              LDR      r0,[r0,#0]            ;1832
00004e  9000              STR      r0,[sp,#0]            ;1832
000050  6820              LDR      r0,[r4,#0]            ;1832
000052  6840              LDR      r0,[r0,#4]            ;1832
000054  9000              STR      r0,[sp,#0]            ;1832
000056  bf00              NOP                            ;1832
000058  bf00              NOP                            ;1832
00005a  bf00              NOP                            ;1833
00005c  bf00              NOP                            ;1833
                  |L10.94|
00005e  6821              LDR      r1,[r4,#0]            ;1833
000060  310c              ADDS     r1,r1,#0xc            ;1833
000062  e8511f00          LDREX    r1,[r1,#0]            ;1833
000066  f0410010          ORR      r0,r1,#0x10           ;1833
00006a  6821              LDR      r1,[r4,#0]            ;1833
00006c  310c              ADDS     r1,r1,#0xc            ;1833
00006e  e8410200          STREX    r2,r0,[r1,#0]         ;1833
000072  2a00              CMP      r2,#0                 ;1833
000074  d1f3              BNE      |L10.94|
000076  e000              B        |L10.122|
                  |L10.120|
000078  2501              MOVS     r5,#1                 ;1841
                  |L10.122|
00007a  4628              MOV      r0,r5                 ;1845
00007c  e7cb              B        |L10.22|
                  |L10.126|
00007e  2002              MOVS     r0,#2                 ;1849
000080  e7c9              B        |L10.22|
;;;1852   
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle_IT||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle_IT PROC
;;;1746     */
;;;1747   HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1748   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1749     HAL_StatusTypeDef status;
;;;1750   
;;;1751     /* Check that a Rx process is not already ongoing */
;;;1752     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003e          LDRB     r0,[r4,#0x3e]
00000c  2820              CMP      r0,#0x20
00000e  d136              BNE      |L11.126|
;;;1753     {
;;;1754       if ((pData == NULL) || (Size == 0U))
000010  b106              CBZ      r6,|L11.20|
000012  b90f              CBNZ     r7,|L11.24|
                  |L11.20|
;;;1755       {
;;;1756         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L11.22|
;;;1757       }
;;;1758   
;;;1759       __HAL_LOCK(huart);
;;;1760   
;;;1761       /* Set Reception type to reception till IDLE Event*/
;;;1762       huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;1763   
;;;1764       status =  UART_Start_Receive_IT(huart, pData, Size);
;;;1765   
;;;1766       /* Check Rx process has been successfully started */
;;;1767       if (status == HAL_OK)
;;;1768       {
;;;1769         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;1770         {
;;;1771           __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;1772           ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;1773         }
;;;1774         else
;;;1775         {
;;;1776           /* In case of errors already pending when reception is started,
;;;1777              Interrupts may have already been raised and lead to reception abortion.
;;;1778              (Overrun error for instance).
;;;1779              In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
;;;1780           status = HAL_ERROR;
;;;1781         }
;;;1782       }
;;;1783   
;;;1784       return status;
;;;1785     }
;;;1786     else
;;;1787     {
;;;1788       return HAL_BUSY;
;;;1789     }
;;;1790   }
000016  bdf8              POP      {r3-r7,pc}
                  |L11.24|
000018  bf00              NOP                            ;1759
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1759
00001e  2801              CMP      r0,#1                 ;1759
000020  d101              BNE      |L11.38|
000022  2002              MOVS     r0,#2                 ;1759
000024  e7f7              B        |L11.22|
                  |L11.38|
000026  2001              MOVS     r0,#1                 ;1759
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1759
00002c  bf00              NOP                            ;1759
00002e  6320              STR      r0,[r4,#0x30]         ;1762
000030  463a              MOV      r2,r7                 ;1764
000032  4631              MOV      r1,r6                 ;1764
000034  4620              MOV      r0,r4                 ;1764
000036  f7fffffe          BL       UART_Start_Receive_IT
00003a  4605              MOV      r5,r0                 ;1764
00003c  b9ed              CBNZ     r5,|L11.122|
00003e  6b20              LDR      r0,[r4,#0x30]         ;1769
000040  2801              CMP      r0,#1                 ;1769
000042  d119              BNE      |L11.120|
000044  bf00              NOP                            ;1771
000046  2000              MOVS     r0,#0                 ;1771
000048  9000              STR      r0,[sp,#0]            ;1771
00004a  6820              LDR      r0,[r4,#0]            ;1771
00004c  6800              LDR      r0,[r0,#0]            ;1771
00004e  9000              STR      r0,[sp,#0]            ;1771
000050  6820              LDR      r0,[r4,#0]            ;1771
000052  6840              LDR      r0,[r0,#4]            ;1771
000054  9000              STR      r0,[sp,#0]            ;1771
000056  bf00              NOP                            ;1771
000058  bf00              NOP                            ;1771
00005a  bf00              NOP                            ;1772
00005c  bf00              NOP                            ;1772
                  |L11.94|
00005e  6821              LDR      r1,[r4,#0]            ;1772
000060  310c              ADDS     r1,r1,#0xc            ;1772
000062  e8511f00          LDREX    r1,[r1,#0]            ;1772
000066  f0410010          ORR      r0,r1,#0x10           ;1772
00006a  6821              LDR      r1,[r4,#0]            ;1772
00006c  310c              ADDS     r1,r1,#0xc            ;1772
00006e  e8410200          STREX    r2,r0,[r1,#0]         ;1772
000072  2a00              CMP      r2,#0                 ;1772
000074  d1f3              BNE      |L11.94|
000076  e000              B        |L11.122|
                  |L11.120|
000078  2501              MOVS     r5,#1                 ;1780
                  |L11.122|
00007a  4628              MOV      r0,r5                 ;1784
00007c  e7cb              B        |L11.22|
                  |L11.126|
00007e  2002              MOVS     r0,#2                 ;1788
000080  e7c9              B        |L11.22|
;;;1791   
                          ENDP


                          AREA ||i.HAL_UARTEx_RxEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_RxEventCallback PROC
;;;2708     */
;;;2709   __weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
000000  4770              BX       lr
;;;2710   {
;;;2711     /* Prevent unused argument(s) compilation warning */
;;;2712     UNUSED(huart);
;;;2713     UNUSED(Size);
;;;2714   
;;;2715     /* NOTE : This function should not be modified, when the callback is needed,
;;;2716               the HAL_UARTEx_RxEventCallback can be implemented in the user file.
;;;2717      */
;;;2718   }
;;;2719   
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1864     */
;;;1865   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1866   {
000002  4604              MOV      r4,r0
;;;1867     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1868     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L13.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f42170f0          BIC      r0,r1,#0x1e0
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L13.8|
000020  bf00              NOP      
;;;1869     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  bf00              NOP      
000024  bf00              NOP      
                  |L13.38|
000026  6821              LDR      r1,[r4,#0]
000028  3114              ADDS     r1,r1,#0x14
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f0210001          BIC      r0,r1,#1
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L13.38|
00003e  bf00              NOP      
;;;1870   
;;;1871     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;1872     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000040  6b20              LDR      r0,[r4,#0x30]
000042  2801              CMP      r0,#1
000044  d10e              BNE      |L13.100|
;;;1873     {
;;;1874       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000046  bf00              NOP      
000048  bf00              NOP      
                  |L13.74|
00004a  6821              LDR      r1,[r4,#0]
00004c  310c              ADDS     r1,r1,#0xc
00004e  e8511f00          LDREX    r1,[r1,#0]
000052  f0210010          BIC      r0,r1,#0x10
000056  6821              LDR      r1,[r4,#0]
000058  310c              ADDS     r1,r1,#0xc
00005a  e8410200          STREX    r2,r0,[r1,#0]
00005e  2a00              CMP      r2,#0
000060  d1f3              BNE      |L13.74|
000062  bf00              NOP      
                  |L13.100|
;;;1875     }
;;;1876   
;;;1877     /* Disable the UART DMA Tx request if enabled */
;;;1878     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000080          AND      r0,r0,#0x80
00006c  2880              CMP      r0,#0x80
00006e  d120              BNE      |L13.178|
;;;1879     {
;;;1880       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000070  bf00              NOP      
000072  bf00              NOP      
                  |L13.116|
000074  6821              LDR      r1,[r4,#0]
000076  3114              ADDS     r1,r1,#0x14
000078  e8511f00          LDREX    r1,[r1,#0]
00007c  f0210080          BIC      r0,r1,#0x80
000080  6821              LDR      r1,[r4,#0]
000082  3114              ADDS     r1,r1,#0x14
000084  e8410200          STREX    r2,r0,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f3              BNE      |L13.116|
00008c  bf00              NOP      
;;;1881   
;;;1882       /* Abort the UART DMA Tx stream: use blocking DMA Abort API (no callback) */
;;;1883       if (huart->hdmatx != NULL)
00008e  6b60              LDR      r0,[r4,#0x34]
000090  b178              CBZ      r0,|L13.178|
;;;1884       {
;;;1885         /* Set the UART DMA Abort callback to Null.
;;;1886            No call back execution at end of DMA abort procedure */
;;;1887         huart->hdmatx->XferAbortCallback = NULL;
000092  2000              MOVS     r0,#0
000094  6b61              LDR      r1,[r4,#0x34]
000096  6508              STR      r0,[r1,#0x50]
;;;1888   
;;;1889         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000098  6b60              LDR      r0,[r4,#0x34]
00009a  f7fffffe          BL       HAL_DMA_Abort
00009e  b140              CBZ      r0,|L13.178|
;;;1890         {
;;;1891           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
0000a0  6b60              LDR      r0,[r4,#0x34]
0000a2  f7fffffe          BL       HAL_DMA_GetError
0000a6  2820              CMP      r0,#0x20
0000a8  d103              BNE      |L13.178|
;;;1892           {
;;;1893             /* Set error code to DMA */
;;;1894             huart->ErrorCode = HAL_UART_ERROR_DMA;
0000aa  2010              MOVS     r0,#0x10
0000ac  6420              STR      r0,[r4,#0x40]
;;;1895   
;;;1896             return HAL_TIMEOUT;
0000ae  2003              MOVS     r0,#3
                  |L13.176|
;;;1897           }
;;;1898         }
;;;1899       }
;;;1900     }
;;;1901   
;;;1902     /* Disable the UART DMA Rx request if enabled */
;;;1903     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1904     {
;;;1905       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1906   
;;;1907       /* Abort the UART DMA Rx stream: use blocking DMA Abort API (no callback) */
;;;1908       if (huart->hdmarx != NULL)
;;;1909       {
;;;1910         /* Set the UART DMA Abort callback to Null.
;;;1911            No call back execution at end of DMA abort procedure */
;;;1912         huart->hdmarx->XferAbortCallback = NULL;
;;;1913   
;;;1914         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
;;;1915         {
;;;1916           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
;;;1917           {
;;;1918             /* Set error code to DMA */
;;;1919             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1920   
;;;1921             return HAL_TIMEOUT;
;;;1922           }
;;;1923         }
;;;1924       }
;;;1925     }
;;;1926   
;;;1927     /* Reset Tx and Rx transfer counters */
;;;1928     huart->TxXferCount = 0x00U;
;;;1929     huart->RxXferCount = 0x00U;
;;;1930   
;;;1931     /* Reset ErrorCode */
;;;1932     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1933   
;;;1934     /* Restore huart->RxState and huart->gState to Ready */
;;;1935     huart->RxState = HAL_UART_STATE_READY;
;;;1936     huart->gState = HAL_UART_STATE_READY;
;;;1937     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1938   
;;;1939     return HAL_OK;
;;;1940   }
0000b0  bd10              POP      {r4,pc}
                  |L13.178|
0000b2  6820              LDR      r0,[r4,#0]            ;1903
0000b4  6940              LDR      r0,[r0,#0x14]         ;1903
0000b6  f0000040          AND      r0,r0,#0x40           ;1903
0000ba  2840              CMP      r0,#0x40              ;1903
0000bc  d120              BNE      |L13.256|
0000be  bf00              NOP                            ;1905
0000c0  bf00              NOP                            ;1905
                  |L13.194|
0000c2  6821              LDR      r1,[r4,#0]            ;1905
0000c4  3114              ADDS     r1,r1,#0x14           ;1905
0000c6  e8511f00          LDREX    r1,[r1,#0]            ;1905
0000ca  f0210040          BIC      r0,r1,#0x40           ;1905
0000ce  6821              LDR      r1,[r4,#0]            ;1905
0000d0  3114              ADDS     r1,r1,#0x14           ;1905
0000d2  e8410200          STREX    r2,r0,[r1,#0]         ;1905
0000d6  2a00              CMP      r2,#0                 ;1905
0000d8  d1f3              BNE      |L13.194|
0000da  bf00              NOP                            ;1905
0000dc  6ba0              LDR      r0,[r4,#0x38]         ;1908
0000de  b178              CBZ      r0,|L13.256|
0000e0  2000              MOVS     r0,#0                 ;1912
0000e2  6ba1              LDR      r1,[r4,#0x38]         ;1912
0000e4  6508              STR      r0,[r1,#0x50]         ;1912
0000e6  6ba0              LDR      r0,[r4,#0x38]         ;1914
0000e8  f7fffffe          BL       HAL_DMA_Abort
0000ec  b140              CBZ      r0,|L13.256|
0000ee  6ba0              LDR      r0,[r4,#0x38]         ;1916
0000f0  f7fffffe          BL       HAL_DMA_GetError
0000f4  2820              CMP      r0,#0x20              ;1916
0000f6  d103              BNE      |L13.256|
0000f8  2010              MOVS     r0,#0x10              ;1919
0000fa  6420              STR      r0,[r4,#0x40]         ;1919
0000fc  2003              MOVS     r0,#3                 ;1921
0000fe  e7d7              B        |L13.176|
                  |L13.256|
000100  2000              MOVS     r0,#0                 ;1928
000102  84e0              STRH     r0,[r4,#0x26]         ;1928
000104  85e0              STRH     r0,[r4,#0x2e]         ;1929
000106  6420              STR      r0,[r4,#0x40]         ;1932
000108  2020              MOVS     r0,#0x20              ;1935
00010a  f884003e          STRB     r0,[r4,#0x3e]         ;1935
00010e  f884003d          STRB     r0,[r4,#0x3d]         ;1936
000112  2000              MOVS     r0,#0                 ;1937
000114  6320              STR      r0,[r4,#0x30]         ;1937
000116  bf00              NOP                            ;1939
000118  e7ca              B        |L13.176|
;;;1941   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;2661     */
;;;2662   __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2663   {
;;;2664     /* Prevent unused argument(s) compilation warning */
;;;2665     UNUSED(huart);
;;;2666   
;;;2667     /* NOTE : This function should not be modified, when the callback is needed,
;;;2668               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;2669      */
;;;2670   }
;;;2671   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;2004     */
;;;2005   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2006   {
000002  4604              MOV      r4,r0
;;;2007     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2008     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L15.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f4217090          BIC      r0,r1,#0x120
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L15.8|
000020  bf00              NOP      
;;;2009     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  bf00              NOP      
000024  bf00              NOP      
                  |L15.38|
000026  6821              LDR      r1,[r4,#0]
000028  3114              ADDS     r1,r1,#0x14
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f0210001          BIC      r0,r1,#1
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L15.38|
00003e  bf00              NOP      
;;;2010   
;;;2011     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2012     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000040  6b20              LDR      r0,[r4,#0x30]
000042  2801              CMP      r0,#1
000044  d10e              BNE      |L15.100|
;;;2013     {
;;;2014       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000046  bf00              NOP      
000048  bf00              NOP      
                  |L15.74|
00004a  6821              LDR      r1,[r4,#0]
00004c  310c              ADDS     r1,r1,#0xc
00004e  e8511f00          LDREX    r1,[r1,#0]
000052  f0210010          BIC      r0,r1,#0x10
000056  6821              LDR      r1,[r4,#0]
000058  310c              ADDS     r1,r1,#0xc
00005a  e8410200          STREX    r2,r0,[r1,#0]
00005e  2a00              CMP      r2,#0
000060  d1f3              BNE      |L15.74|
000062  bf00              NOP      
                  |L15.100|
;;;2015     }
;;;2016   
;;;2017     /* Disable the UART DMA Rx request if enabled */
;;;2018     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000040          AND      r0,r0,#0x40
00006c  2840              CMP      r0,#0x40
00006e  d120              BNE      |L15.178|
;;;2019     {
;;;2020       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  bf00              NOP      
000072  bf00              NOP      
                  |L15.116|
000074  6821              LDR      r1,[r4,#0]
000076  3114              ADDS     r1,r1,#0x14
000078  e8511f00          LDREX    r1,[r1,#0]
00007c  f0210040          BIC      r0,r1,#0x40
000080  6821              LDR      r1,[r4,#0]
000082  3114              ADDS     r1,r1,#0x14
000084  e8410200          STREX    r2,r0,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f3              BNE      |L15.116|
00008c  bf00              NOP      
;;;2021   
;;;2022       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;2023       if (huart->hdmarx != NULL)
00008e  6ba0              LDR      r0,[r4,#0x38]
000090  b178              CBZ      r0,|L15.178|
;;;2024       {
;;;2025         /* Set the UART DMA Abort callback to Null.
;;;2026            No call back execution at end of DMA abort procedure */
;;;2027         huart->hdmarx->XferAbortCallback = NULL;
000092  2000              MOVS     r0,#0
000094  6ba1              LDR      r1,[r4,#0x38]
000096  6508              STR      r0,[r1,#0x50]
;;;2028   
;;;2029         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
000098  6ba0              LDR      r0,[r4,#0x38]
00009a  f7fffffe          BL       HAL_DMA_Abort
00009e  b140              CBZ      r0,|L15.178|
;;;2030         {
;;;2031           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
0000a0  6ba0              LDR      r0,[r4,#0x38]
0000a2  f7fffffe          BL       HAL_DMA_GetError
0000a6  2820              CMP      r0,#0x20
0000a8  d103              BNE      |L15.178|
;;;2032           {
;;;2033             /* Set error code to DMA */
;;;2034             huart->ErrorCode = HAL_UART_ERROR_DMA;
0000aa  2010              MOVS     r0,#0x10
0000ac  6420              STR      r0,[r4,#0x40]
;;;2035   
;;;2036             return HAL_TIMEOUT;
0000ae  2003              MOVS     r0,#3
                  |L15.176|
;;;2037           }
;;;2038         }
;;;2039       }
;;;2040     }
;;;2041   
;;;2042     /* Reset Rx transfer counter */
;;;2043     huart->RxXferCount = 0x00U;
;;;2044   
;;;2045     /* Restore huart->RxState to Ready */
;;;2046     huart->RxState = HAL_UART_STATE_READY;
;;;2047     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2048   
;;;2049     return HAL_OK;
;;;2050   }
0000b0  bd10              POP      {r4,pc}
                  |L15.178|
0000b2  2000              MOVS     r0,#0                 ;2043
0000b4  85e0              STRH     r0,[r4,#0x2e]         ;2043
0000b6  2020              MOVS     r0,#0x20              ;2046
0000b8  f884003e          STRB     r0,[r4,#0x3e]         ;2046
0000bc  2000              MOVS     r0,#0                 ;2047
0000be  6320              STR      r0,[r4,#0x30]         ;2047
0000c0  bf00              NOP                            ;2049
0000c2  e7f5              B        |L15.176|
;;;2051   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;2691     */
;;;2692   __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2693   {
;;;2694     /* Prevent unused argument(s) compilation warning */
;;;2695     UNUSED(huart);
;;;2696   
;;;2697     /* NOTE : This function should not be modified, when the callback is needed,
;;;2698               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;2699      */
;;;2700   }
;;;2701   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;2277     */
;;;2278   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2279   {
000002  4604              MOV      r4,r0
;;;2280     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2281     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L17.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f4217090          BIC      r0,r1,#0x120
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L17.8|
000020  bf00              NOP      
;;;2282     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  bf00              NOP      
000024  bf00              NOP      
                  |L17.38|
000026  6821              LDR      r1,[r4,#0]
000028  3114              ADDS     r1,r1,#0x14
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f0210001          BIC      r0,r1,#1
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L17.38|
00003e  bf00              NOP      
;;;2283   
;;;2284     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2285     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000040  6b20              LDR      r0,[r4,#0x30]
000042  2801              CMP      r0,#1
000044  d10e              BNE      |L17.100|
;;;2286     {
;;;2287       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000046  bf00              NOP      
000048  bf00              NOP      
                  |L17.74|
00004a  6821              LDR      r1,[r4,#0]
00004c  310c              ADDS     r1,r1,#0xc
00004e  e8511f00          LDREX    r1,[r1,#0]
000052  f0210010          BIC      r0,r1,#0x10
000056  6821              LDR      r1,[r4,#0]
000058  310c              ADDS     r1,r1,#0xc
00005a  e8410200          STREX    r2,r0,[r1,#0]
00005e  2a00              CMP      r2,#0
000060  d1f3              BNE      |L17.74|
000062  bf00              NOP      
                  |L17.100|
;;;2288     }
;;;2289   
;;;2290     /* Disable the UART DMA Rx request if enabled */
;;;2291     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000040          AND      r0,r0,#0x40
00006c  2840              CMP      r0,#0x40
00006e  d126              BNE      |L17.190|
;;;2292     {
;;;2293       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  bf00              NOP      
000072  bf00              NOP      
                  |L17.116|
000074  6821              LDR      r1,[r4,#0]
000076  3114              ADDS     r1,r1,#0x14
000078  e8511f00          LDREX    r1,[r1,#0]
00007c  f0210040          BIC      r0,r1,#0x40
000080  6821              LDR      r1,[r4,#0]
000082  3114              ADDS     r1,r1,#0x14
000084  e8410200          STREX    r2,r0,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f3              BNE      |L17.116|
00008c  bf00              NOP      
;;;2294   
;;;2295       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;2296       if (huart->hdmarx != NULL)
00008e  6ba0              LDR      r0,[r4,#0x38]
000090  b150              CBZ      r0,|L17.168|
;;;2297       {
;;;2298         /* Set the UART DMA Abort callback :
;;;2299            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2300         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
000092  4811              LDR      r0,|L17.216|
000094  6ba1              LDR      r1,[r4,#0x38]
000096  6508              STR      r0,[r1,#0x50]
;;;2301   
;;;2302         /* Abort DMA RX */
;;;2303         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000098  6ba0              LDR      r0,[r4,#0x38]
00009a  f7fffffe          BL       HAL_DMA_Abort_IT
00009e  b1c0              CBZ      r0,|L17.210|
;;;2304         {
;;;2305           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;2306           huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000a0  6ba0              LDR      r0,[r4,#0x38]
0000a2  6d01              LDR      r1,[r0,#0x50]
0000a4  4788              BLX      r1
0000a6  e014              B        |L17.210|
                  |L17.168|
;;;2307         }
;;;2308       }
;;;2309       else
;;;2310       {
;;;2311         /* Reset Rx transfer counter */
;;;2312         huart->RxXferCount = 0x00U;
0000a8  2000              MOVS     r0,#0
0000aa  85e0              STRH     r0,[r4,#0x2e]
;;;2313   
;;;2314         /* Restore huart->RxState to Ready */
;;;2315         huart->RxState = HAL_UART_STATE_READY;
0000ac  2020              MOVS     r0,#0x20
0000ae  f884003e          STRB     r0,[r4,#0x3e]
;;;2316         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
0000b2  2000              MOVS     r0,#0
0000b4  6320              STR      r0,[r4,#0x30]
;;;2317   
;;;2318         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2319   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2320         /* Call registered Abort Receive Complete Callback */
;;;2321         huart->AbortReceiveCpltCallback(huart);
0000b6  4620              MOV      r0,r4
0000b8  6e21              LDR      r1,[r4,#0x60]
0000ba  4788              BLX      r1
0000bc  e009              B        |L17.210|
                  |L17.190|
;;;2322   #else
;;;2323         /* Call legacy weak Abort Receive Complete Callback */
;;;2324         HAL_UART_AbortReceiveCpltCallback(huart);
;;;2325   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2326       }
;;;2327     }
;;;2328     else
;;;2329     {
;;;2330       /* Reset Rx transfer counter */
;;;2331       huart->RxXferCount = 0x00U;
0000be  2000              MOVS     r0,#0
0000c0  85e0              STRH     r0,[r4,#0x2e]
;;;2332   
;;;2333       /* Restore huart->RxState to Ready */
;;;2334       huart->RxState = HAL_UART_STATE_READY;
0000c2  2020              MOVS     r0,#0x20
0000c4  f884003e          STRB     r0,[r4,#0x3e]
;;;2335       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
0000c8  2000              MOVS     r0,#0
0000ca  6320              STR      r0,[r4,#0x30]
;;;2336   
;;;2337       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2338   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2339       /* Call registered Abort Receive Complete Callback */
;;;2340       huart->AbortReceiveCpltCallback(huart);
0000cc  4620              MOV      r0,r4
0000ce  6e21              LDR      r1,[r4,#0x60]
0000d0  4788              BLX      r1
                  |L17.210|
;;;2341   #else
;;;2342       /* Call legacy weak Abort Receive Complete Callback */
;;;2343       HAL_UART_AbortReceiveCpltCallback(huart);
;;;2344   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2345     }
;;;2346   
;;;2347     return HAL_OK;
0000d2  2000              MOVS     r0,#0
;;;2348   }
0000d4  bd10              POP      {r4,pc}
;;;2349   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L17.216|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1953     */
;;;1954   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1955   {
000002  4604              MOV      r4,r0
;;;1956     /* Disable TXEIE and TCIE interrupts */
;;;1957     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L18.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f02100c0          BIC      r0,r1,#0xc0
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L18.8|
000020  bf00              NOP      
;;;1958   
;;;1959     /* Disable the UART DMA Tx request if enabled */
;;;1960     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6820              LDR      r0,[r4,#0]
000024  6940              LDR      r0,[r0,#0x14]
000026  f0000080          AND      r0,r0,#0x80
00002a  2880              CMP      r0,#0x80
00002c  d120              BNE      |L18.112|
;;;1961     {
;;;1962       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L18.50|
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8511f00          LDREX    r1,[r1,#0]
00003a  f0210080          BIC      r0,r1,#0x80
00003e  6821              LDR      r1,[r4,#0]
000040  3114              ADDS     r1,r1,#0x14
000042  e8410200          STREX    r2,r0,[r1,#0]
000046  2a00              CMP      r2,#0
000048  d1f3              BNE      |L18.50|
00004a  bf00              NOP      
;;;1963   
;;;1964       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;1965       if (huart->hdmatx != NULL)
00004c  6b60              LDR      r0,[r4,#0x34]
00004e  b178              CBZ      r0,|L18.112|
;;;1966       {
;;;1967         /* Set the UART DMA Abort callback to Null.
;;;1968            No call back execution at end of DMA abort procedure */
;;;1969         huart->hdmatx->XferAbortCallback = NULL;
000050  2000              MOVS     r0,#0
000052  6b61              LDR      r1,[r4,#0x34]
000054  6508              STR      r0,[r1,#0x50]
;;;1970   
;;;1971         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000056  6b60              LDR      r0,[r4,#0x34]
000058  f7fffffe          BL       HAL_DMA_Abort
00005c  b140              CBZ      r0,|L18.112|
;;;1972         {
;;;1973           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_GetError
000064  2820              CMP      r0,#0x20
000066  d103              BNE      |L18.112|
;;;1974           {
;;;1975             /* Set error code to DMA */
;;;1976             huart->ErrorCode = HAL_UART_ERROR_DMA;
000068  2010              MOVS     r0,#0x10
00006a  6420              STR      r0,[r4,#0x40]
;;;1977   
;;;1978             return HAL_TIMEOUT;
00006c  2003              MOVS     r0,#3
                  |L18.110|
;;;1979           }
;;;1980         }
;;;1981       }
;;;1982     }
;;;1983   
;;;1984     /* Reset Tx transfer counter */
;;;1985     huart->TxXferCount = 0x00U;
;;;1986   
;;;1987     /* Restore huart->gState to Ready */
;;;1988     huart->gState = HAL_UART_STATE_READY;
;;;1989   
;;;1990     return HAL_OK;
;;;1991   }
00006e  bd10              POP      {r4,pc}
                  |L18.112|
000070  2000              MOVS     r0,#0                 ;1985
000072  84e0              STRH     r0,[r4,#0x26]         ;1985
000074  2020              MOVS     r0,#0x20              ;1988
000076  f884003d          STRB     r0,[r4,#0x3d]         ;1988
00007a  2000              MOVS     r0,#0                 ;1990
00007c  e7f7              B        |L18.110|
;;;1992   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;2676     */
;;;2677   __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2678   {
;;;2679     /* Prevent unused argument(s) compilation warning */
;;;2680     UNUSED(huart);
;;;2681   
;;;2682     /* NOTE : This function should not be modified, when the callback is needed,
;;;2683               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;2684      */
;;;2685   }
;;;2686   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;2200     */
;;;2201   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2202   {
000002  4604              MOV      r4,r0
;;;2203     /* Disable TXEIE and TCIE interrupts */
;;;2204     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L20.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f02100c0          BIC      r0,r1,#0xc0
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L20.8|
000020  bf00              NOP      
;;;2205   
;;;2206     /* Disable the UART DMA Tx request if enabled */
;;;2207     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6820              LDR      r0,[r4,#0]
000024  6940              LDR      r0,[r0,#0x14]
000026  f0000080          AND      r0,r0,#0x80
00002a  2880              CMP      r0,#0x80
00002c  d124              BNE      |L20.120|
;;;2208     {
;;;2209       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L20.50|
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8511f00          LDREX    r1,[r1,#0]
00003a  f0210080          BIC      r0,r1,#0x80
00003e  6821              LDR      r1,[r4,#0]
000040  3114              ADDS     r1,r1,#0x14
000042  e8410200          STREX    r2,r0,[r1,#0]
000046  2a00              CMP      r2,#0
000048  d1f3              BNE      |L20.50|
00004a  bf00              NOP      
;;;2210   
;;;2211       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;2212       if (huart->hdmatx != NULL)
00004c  6b60              LDR      r0,[r4,#0x34]
00004e  b150              CBZ      r0,|L20.102|
;;;2213       {
;;;2214         /* Set the UART DMA Abort callback :
;;;2215            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2216         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
000050  480e              LDR      r0,|L20.140|
000052  6b61              LDR      r1,[r4,#0x34]
000054  6508              STR      r0,[r1,#0x50]
;;;2217   
;;;2218         /* Abort DMA TX */
;;;2219         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000056  6b60              LDR      r0,[r4,#0x34]
000058  f7fffffe          BL       HAL_DMA_Abort_IT
00005c  b1a0              CBZ      r0,|L20.136|
;;;2220         {
;;;2221           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;2222           huart->hdmatx->XferAbortCallback(huart->hdmatx);
00005e  6b60              LDR      r0,[r4,#0x34]
000060  6d01              LDR      r1,[r0,#0x50]
000062  4788              BLX      r1
000064  e010              B        |L20.136|
                  |L20.102|
;;;2223         }
;;;2224       }
;;;2225       else
;;;2226       {
;;;2227         /* Reset Tx transfer counter */
;;;2228         huart->TxXferCount = 0x00U;
000066  2000              MOVS     r0,#0
000068  84e0              STRH     r0,[r4,#0x26]
;;;2229   
;;;2230         /* Restore huart->gState to Ready */
;;;2231         huart->gState = HAL_UART_STATE_READY;
00006a  2020              MOVS     r0,#0x20
00006c  f884003d          STRB     r0,[r4,#0x3d]
;;;2232   
;;;2233         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2234   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2235         /* Call registered Abort Transmit Complete Callback */
;;;2236         huart->AbortTransmitCpltCallback(huart);
000070  4620              MOV      r0,r4
000072  6de1              LDR      r1,[r4,#0x5c]
000074  4788              BLX      r1
000076  e007              B        |L20.136|
                  |L20.120|
;;;2237   #else
;;;2238         /* Call legacy weak Abort Transmit Complete Callback */
;;;2239         HAL_UART_AbortTransmitCpltCallback(huart);
;;;2240   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2241       }
;;;2242     }
;;;2243     else
;;;2244     {
;;;2245       /* Reset Tx transfer counter */
;;;2246       huart->TxXferCount = 0x00U;
000078  2000              MOVS     r0,#0
00007a  84e0              STRH     r0,[r4,#0x26]
;;;2247   
;;;2248       /* Restore huart->gState to Ready */
;;;2249       huart->gState = HAL_UART_STATE_READY;
00007c  2020              MOVS     r0,#0x20
00007e  f884003d          STRB     r0,[r4,#0x3d]
;;;2250   
;;;2251       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2252   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2253       /* Call registered Abort Transmit Complete Callback */
;;;2254       huart->AbortTransmitCpltCallback(huart);
000082  4620              MOV      r0,r4
000084  6de1              LDR      r1,[r4,#0x5c]
000086  4788              BLX      r1
                  |L20.136|
;;;2255   #else
;;;2256       /* Call legacy weak Abort Transmit Complete Callback */
;;;2257       HAL_UART_AbortTransmitCpltCallback(huart);
;;;2258   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2259     }
;;;2260   
;;;2261     return HAL_OK;
000088  2000              MOVS     r0,#0
;;;2262   }
00008a  bd10              POP      {r4,pc}
;;;2263   
                          ENDP

                  |L20.140|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;2065     */
;;;2066   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2067   {
000002  4604              MOV      r4,r0
;;;2068     uint32_t AbortCplt = 0x01U;
000004  2501              MOVS     r5,#1
;;;2069   
;;;2070     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2071     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  bf00              NOP      
000008  bf00              NOP      
                  |L21.10|
00000a  6821              LDR      r1,[r4,#0]
00000c  310c              ADDS     r1,r1,#0xc
00000e  e8511f00          LDREX    r1,[r1,#0]
000012  f42170f0          BIC      r0,r1,#0x1e0
000016  6821              LDR      r1,[r4,#0]
000018  310c              ADDS     r1,r1,#0xc
00001a  e8410200          STREX    r2,r0,[r1,#0]
00001e  2a00              CMP      r2,#0
000020  d1f3              BNE      |L21.10|
000022  bf00              NOP      
;;;2072     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000024  bf00              NOP      
000026  bf00              NOP      
                  |L21.40|
000028  6821              LDR      r1,[r4,#0]
00002a  3114              ADDS     r1,r1,#0x14
00002c  e8511f00          LDREX    r1,[r1,#0]
000030  f0210001          BIC      r0,r1,#1
000034  6821              LDR      r1,[r4,#0]
000036  3114              ADDS     r1,r1,#0x14
000038  e8410200          STREX    r2,r0,[r1,#0]
00003c  2a00              CMP      r2,#0
00003e  d1f3              BNE      |L21.40|
000040  bf00              NOP      
;;;2073   
;;;2074     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2075     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000042  6b20              LDR      r0,[r4,#0x30]
000044  2801              CMP      r0,#1
000046  d10e              BNE      |L21.102|
;;;2076     {
;;;2077       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L21.76|
00004c  6821              LDR      r1,[r4,#0]
00004e  310c              ADDS     r1,r1,#0xc
000050  e8511f00          LDREX    r1,[r1,#0]
000054  f0210010          BIC      r0,r1,#0x10
000058  6821              LDR      r1,[r4,#0]
00005a  310c              ADDS     r1,r1,#0xc
00005c  e8410200          STREX    r2,r0,[r1,#0]
000060  2a00              CMP      r2,#0
000062  d1f3              BNE      |L21.76|
000064  bf00              NOP      
                  |L21.102|
;;;2078     }
;;;2079   
;;;2080     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;2081        before any call to DMA Abort functions */
;;;2082     /* DMA Tx Handle is valid */
;;;2083     if (huart->hdmatx != NULL)
000066  6b60              LDR      r0,[r4,#0x34]
000068  b160              CBZ      r0,|L21.132|
;;;2084     {
;;;2085       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;2086          Otherwise, set it to NULL */
;;;2087       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00006a  6820              LDR      r0,[r4,#0]
00006c  6940              LDR      r0,[r0,#0x14]
00006e  f0000080          AND      r0,r0,#0x80
000072  2880              CMP      r0,#0x80
000074  d103              BNE      |L21.126|
;;;2088       {
;;;2089         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
000076  4834              LDR      r0,|L21.328|
000078  6b61              LDR      r1,[r4,#0x34]
00007a  6508              STR      r0,[r1,#0x50]
00007c  e002              B        |L21.132|
                  |L21.126|
;;;2090       }
;;;2091       else
;;;2092       {
;;;2093         huart->hdmatx->XferAbortCallback = NULL;
00007e  2000              MOVS     r0,#0
000080  6b61              LDR      r1,[r4,#0x34]
000082  6508              STR      r0,[r1,#0x50]
                  |L21.132|
;;;2094       }
;;;2095     }
;;;2096     /* DMA Rx Handle is valid */
;;;2097     if (huart->hdmarx != NULL)
000084  6ba0              LDR      r0,[r4,#0x38]
000086  b160              CBZ      r0,|L21.162|
;;;2098     {
;;;2099       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;2100          Otherwise, set it to NULL */
;;;2101       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000088  6820              LDR      r0,[r4,#0]
00008a  6940              LDR      r0,[r0,#0x14]
00008c  f0000040          AND      r0,r0,#0x40
000090  2840              CMP      r0,#0x40
000092  d103              BNE      |L21.156|
;;;2102       {
;;;2103         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
000094  482d              LDR      r0,|L21.332|
000096  6ba1              LDR      r1,[r4,#0x38]
000098  6508              STR      r0,[r1,#0x50]
00009a  e002              B        |L21.162|
                  |L21.156|
;;;2104       }
;;;2105       else
;;;2106       {
;;;2107         huart->hdmarx->XferAbortCallback = NULL;
00009c  2000              MOVS     r0,#0
00009e  6ba1              LDR      r1,[r4,#0x38]
0000a0  6508              STR      r0,[r1,#0x50]
                  |L21.162|
;;;2108       }
;;;2109     }
;;;2110   
;;;2111     /* Disable the UART DMA Tx request if enabled */
;;;2112     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6940              LDR      r0,[r0,#0x14]
0000a6  f0000080          AND      r0,r0,#0x80
0000aa  2880              CMP      r0,#0x80
0000ac  d119              BNE      |L21.226|
;;;2113     {
;;;2114       /* Disable DMA Tx at UART level */
;;;2115       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
0000ae  bf00              NOP      
0000b0  bf00              NOP      
                  |L21.178|
0000b2  6821              LDR      r1,[r4,#0]
0000b4  3114              ADDS     r1,r1,#0x14
0000b6  e8511f00          LDREX    r1,[r1,#0]
0000ba  f0210080          BIC      r0,r1,#0x80
0000be  6821              LDR      r1,[r4,#0]
0000c0  3114              ADDS     r1,r1,#0x14
0000c2  e8410200          STREX    r2,r0,[r1,#0]
0000c6  2a00              CMP      r2,#0
0000c8  d1f3              BNE      |L21.178|
0000ca  bf00              NOP      
;;;2116   
;;;2117       /* Abort the UART DMA Tx stream : use non blocking DMA Abort API (callback) */
;;;2118       if (huart->hdmatx != NULL)
0000cc  6b60              LDR      r0,[r4,#0x34]
0000ce  b140              CBZ      r0,|L21.226|
;;;2119       {
;;;2120         /* UART Tx DMA Abort callback has already been initialised :
;;;2121            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2122   
;;;2123         /* Abort DMA TX */
;;;2124         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
0000d0  6b60              LDR      r0,[r4,#0x34]
0000d2  f7fffffe          BL       HAL_DMA_Abort_IT
0000d6  b118              CBZ      r0,|L21.224|
;;;2125         {
;;;2126           huart->hdmatx->XferAbortCallback = NULL;
0000d8  2000              MOVS     r0,#0
0000da  6b61              LDR      r1,[r4,#0x34]
0000dc  6508              STR      r0,[r1,#0x50]
0000de  e000              B        |L21.226|
                  |L21.224|
;;;2127         }
;;;2128         else
;;;2129         {
;;;2130           AbortCplt = 0x00U;
0000e0  2500              MOVS     r5,#0
                  |L21.226|
;;;2131         }
;;;2132       }
;;;2133     }
;;;2134   
;;;2135     /* Disable the UART DMA Rx request if enabled */
;;;2136     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000e2  6820              LDR      r0,[r4,#0]
0000e4  6940              LDR      r0,[r0,#0x14]
0000e6  f0000040          AND      r0,r0,#0x40
0000ea  2840              CMP      r0,#0x40
0000ec  d11a              BNE      |L21.292|
;;;2137     {
;;;2138       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000ee  bf00              NOP      
0000f0  bf00              NOP      
                  |L21.242|
0000f2  6821              LDR      r1,[r4,#0]
0000f4  3114              ADDS     r1,r1,#0x14
0000f6  e8511f00          LDREX    r1,[r1,#0]
0000fa  f0210040          BIC      r0,r1,#0x40
0000fe  6821              LDR      r1,[r4,#0]
000100  3114              ADDS     r1,r1,#0x14
000102  e8410200          STREX    r2,r0,[r1,#0]
000106  2a00              CMP      r2,#0
000108  d1f3              BNE      |L21.242|
00010a  bf00              NOP      
;;;2139   
;;;2140       /* Abort the UART DMA Rx stream : use non blocking DMA Abort API (callback) */
;;;2141       if (huart->hdmarx != NULL)
00010c  6ba0              LDR      r0,[r4,#0x38]
00010e  b148              CBZ      r0,|L21.292|
;;;2142       {
;;;2143         /* UART Rx DMA Abort callback has already been initialised :
;;;2144            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2145   
;;;2146         /* Abort DMA RX */
;;;2147         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000110  6ba0              LDR      r0,[r4,#0x38]
000112  f7fffffe          BL       HAL_DMA_Abort_IT
000116  b120              CBZ      r0,|L21.290|
;;;2148         {
;;;2149           huart->hdmarx->XferAbortCallback = NULL;
000118  2000              MOVS     r0,#0
00011a  6ba1              LDR      r1,[r4,#0x38]
00011c  6508              STR      r0,[r1,#0x50]
;;;2150           AbortCplt = 0x01U;
00011e  2501              MOVS     r5,#1
000120  e000              B        |L21.292|
                  |L21.290|
;;;2151         }
;;;2152         else
;;;2153         {
;;;2154           AbortCplt = 0x00U;
000122  2500              MOVS     r5,#0
                  |L21.292|
;;;2155         }
;;;2156       }
;;;2157     }
;;;2158   
;;;2159     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;2160     if (AbortCplt == 0x01U)
000124  2d01              CMP      r5,#1
000126  d10d              BNE      |L21.324|
;;;2161     {
;;;2162       /* Reset Tx and Rx transfer counters */
;;;2163       huart->TxXferCount = 0x00U;
000128  2000              MOVS     r0,#0
00012a  84e0              STRH     r0,[r4,#0x26]
;;;2164       huart->RxXferCount = 0x00U;
00012c  85e0              STRH     r0,[r4,#0x2e]
;;;2165   
;;;2166       /* Reset ErrorCode */
;;;2167       huart->ErrorCode = HAL_UART_ERROR_NONE;
00012e  6420              STR      r0,[r4,#0x40]
;;;2168   
;;;2169       /* Restore huart->gState and huart->RxState to Ready */
;;;2170       huart->gState  = HAL_UART_STATE_READY;
000130  2020              MOVS     r0,#0x20
000132  f884003d          STRB     r0,[r4,#0x3d]
;;;2171       huart->RxState = HAL_UART_STATE_READY;
000136  f884003e          STRB     r0,[r4,#0x3e]
;;;2172       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
00013a  2000              MOVS     r0,#0
00013c  6320              STR      r0,[r4,#0x30]
;;;2173   
;;;2174       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2175   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2176       /* Call registered Abort complete callback */
;;;2177       huart->AbortCpltCallback(huart);
00013e  4620              MOV      r0,r4
000140  6da1              LDR      r1,[r4,#0x58]
000142  4788              BLX      r1
                  |L21.324|
;;;2178   #else
;;;2179       /* Call legacy weak Abort complete callback */
;;;2180       HAL_UART_AbortCpltCallback(huart);
;;;2181   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2182     }
;;;2183   
;;;2184     return HAL_OK;
000144  2000              MOVS     r0,#0
;;;2185   }
000146  bd70              POP      {r4-r6,pc}
;;;2186   
                          ENDP

                  |L21.328|
                          DCD      UART_DMATxAbortCallback
                  |L21.332|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1491     */
;;;1492   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1493   {
000002  4601              MOV      r1,r0
;;;1494     uint32_t dmarequest = 0x00U;
000004  2200              MOVS     r2,#0
;;;1495   
;;;1496     /* Process Locked */
;;;1497     __HAL_LOCK(huart);
000006  bf00              NOP      
000008  f891003c          LDRB     r0,[r1,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L22.20|
000010  2002              MOVS     r0,#2
                  |L22.18|
;;;1498   
;;;1499     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
;;;1500     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
;;;1501     {
;;;1502       /* Disable the UART DMA Tx request */
;;;1503       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1504     }
;;;1505   
;;;1506     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1507     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1508     {
;;;1509       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1510       ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1511       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1512   
;;;1513       /* Disable the UART DMA Rx request */
;;;1514       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1515     }
;;;1516   
;;;1517     /* Process Unlocked */
;;;1518     __HAL_UNLOCK(huart);
;;;1519   
;;;1520     return HAL_OK;
;;;1521   }
000012  bd10              POP      {r4,pc}
                  |L22.20|
000014  2001              MOVS     r0,#1                 ;1497
000016  f881003c          STRB     r0,[r1,#0x3c]         ;1497
00001a  bf00              NOP                            ;1497
00001c  6808              LDR      r0,[r1,#0]            ;1499
00001e  6940              LDR      r0,[r0,#0x14]         ;1499
000020  f3c012c0          UBFX     r2,r0,#7,#1           ;1499
000024  f891003d          LDRB     r0,[r1,#0x3d]         ;1500
000028  2821              CMP      r0,#0x21              ;1500
00002a  d10f              BNE      |L22.76|
00002c  b172              CBZ      r2,|L22.76|
00002e  bf00              NOP                            ;1503
000030  bf00              NOP                            ;1503
                  |L22.50|
000032  680b              LDR      r3,[r1,#0]            ;1503
000034  3314              ADDS     r3,r3,#0x14           ;1503
000036  e8533f00          LDREX    r3,[r3,#0]            ;1503
00003a  f0230080          BIC      r0,r3,#0x80           ;1503
00003e  680b              LDR      r3,[r1,#0]            ;1503
000040  3314              ADDS     r3,r3,#0x14           ;1503
000042  e8430400          STREX    r4,r0,[r3,#0]         ;1503
000046  2c00              CMP      r4,#0                 ;1503
000048  d1f3              BNE      |L22.50|
00004a  bf00              NOP                            ;1503
                  |L22.76|
00004c  6808              LDR      r0,[r1,#0]            ;1506
00004e  6940              LDR      r0,[r0,#0x14]         ;1506
000050  f3c01280          UBFX     r2,r0,#6,#1           ;1506
000054  f891003e          LDRB     r0,[r1,#0x3e]         ;1507
000058  2822              CMP      r0,#0x22              ;1507
00005a  d12d              BNE      |L22.184|
00005c  b362              CBZ      r2,|L22.184|
00005e  bf00              NOP                            ;1510
000060  bf00              NOP                            ;1510
                  |L22.98|
000062  680b              LDR      r3,[r1,#0]            ;1510
000064  330c              ADDS     r3,r3,#0xc            ;1510
000066  e8533f00          LDREX    r3,[r3,#0]            ;1510
00006a  f4237080          BIC      r0,r3,#0x100          ;1510
00006e  680b              LDR      r3,[r1,#0]            ;1510
000070  330c              ADDS     r3,r3,#0xc            ;1510
000072  e8430400          STREX    r4,r0,[r3,#0]         ;1510
000076  2c00              CMP      r4,#0                 ;1510
000078  d1f3              BNE      |L22.98|
00007a  bf00              NOP                            ;1510
00007c  bf00              NOP                            ;1511
00007e  bf00              NOP                            ;1511
                  |L22.128|
000080  680b              LDR      r3,[r1,#0]            ;1511
000082  3314              ADDS     r3,r3,#0x14           ;1511
000084  e8533f00          LDREX    r3,[r3,#0]            ;1511
000088  f0230001          BIC      r0,r3,#1              ;1511
00008c  680b              LDR      r3,[r1,#0]            ;1511
00008e  3314              ADDS     r3,r3,#0x14           ;1511
000090  e8430400          STREX    r4,r0,[r3,#0]         ;1511
000094  2c00              CMP      r4,#0                 ;1511
000096  d1f3              BNE      |L22.128|
000098  bf00              NOP                            ;1511
00009a  bf00              NOP                            ;1514
00009c  bf00              NOP                            ;1514
                  |L22.158|
00009e  680b              LDR      r3,[r1,#0]            ;1514
0000a0  3314              ADDS     r3,r3,#0x14           ;1514
0000a2  e8533f00          LDREX    r3,[r3,#0]            ;1514
0000a6  f0230040          BIC      r0,r3,#0x40           ;1514
0000aa  680b              LDR      r3,[r1,#0]            ;1514
0000ac  3314              ADDS     r3,r3,#0x14           ;1514
0000ae  e8430400          STREX    r4,r0,[r3,#0]         ;1514
0000b2  2c00              CMP      r4,#0                 ;1514
0000b4  d1f3              BNE      |L22.158|
0000b6  bf00              NOP                            ;1514
                  |L22.184|
0000b8  bf00              NOP                            ;1518
0000ba  2000              MOVS     r0,#0                 ;1518
0000bc  f881003c          STRB     r0,[r1,#0x3c]         ;1518
0000c0  bf00              NOP                            ;1518
0000c2  bf00              NOP                            ;1520
0000c4  e7a5              B        |L22.18|
;;;1522   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1528     */
;;;1529   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1530   {
000002  4601              MOV      r1,r0
;;;1531     /* Process Locked */
;;;1532     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f891003c          LDRB     r0,[r1,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L23.18|
00000e  2002              MOVS     r0,#2
                  |L23.16|
;;;1533   
;;;1534     if (huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1535     {
;;;1536       /* Enable the UART DMA Tx request */
;;;1537       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1538     }
;;;1539   
;;;1540     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1541     {
;;;1542       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1543       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1544   
;;;1545       /* Re-enable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1546       ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1547       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1548   
;;;1549       /* Enable the UART DMA Rx request */
;;;1550       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1551     }
;;;1552   
;;;1553     /* Process Unlocked */
;;;1554     __HAL_UNLOCK(huart);
;;;1555   
;;;1556     return HAL_OK;
;;;1557   }
000010  bd08              POP      {r3,pc}
                  |L23.18|
000012  2001              MOVS     r0,#1                 ;1532
000014  f881003c          STRB     r0,[r1,#0x3c]         ;1532
000018  bf00              NOP                            ;1532
00001a  f891003d          LDRB     r0,[r1,#0x3d]         ;1534
00001e  2821              CMP      r0,#0x21              ;1534
000020  d10e              BNE      |L23.64|
000022  bf00              NOP                            ;1537
000024  bf00              NOP                            ;1537
                  |L23.38|
000026  680a              LDR      r2,[r1,#0]            ;1537
000028  3214              ADDS     r2,r2,#0x14           ;1537
00002a  e8522f00          LDREX    r2,[r2,#0]            ;1537
00002e  f0420080          ORR      r0,r2,#0x80           ;1537
000032  680a              LDR      r2,[r1,#0]            ;1537
000034  3214              ADDS     r2,r2,#0x14           ;1537
000036  e8420300          STREX    r3,r0,[r2,#0]         ;1537
00003a  2b00              CMP      r3,#0                 ;1537
00003c  d1f3              BNE      |L23.38|
00003e  bf00              NOP                            ;1537
                  |L23.64|
000040  f891003e          LDRB     r0,[r1,#0x3e]         ;1540
000044  2822              CMP      r0,#0x22              ;1540
000046  d137              BNE      |L23.184|
000048  bf00              NOP                            ;1543
00004a  2000              MOVS     r0,#0                 ;1543
00004c  9000              STR      r0,[sp,#0]            ;1543
00004e  6808              LDR      r0,[r1,#0]            ;1543
000050  6800              LDR      r0,[r0,#0]            ;1543
000052  9000              STR      r0,[sp,#0]            ;1543
000054  6808              LDR      r0,[r1,#0]            ;1543
000056  6840              LDR      r0,[r0,#4]            ;1543
000058  9000              STR      r0,[sp,#0]            ;1543
00005a  bf00              NOP                            ;1543
00005c  bf00              NOP                            ;1543
00005e  bf00              NOP                            ;1546
000060  bf00              NOP                            ;1546
                  |L23.98|
000062  680a              LDR      r2,[r1,#0]            ;1546
000064  320c              ADDS     r2,r2,#0xc            ;1546
000066  e8522f00          LDREX    r2,[r2,#0]            ;1546
00006a  f4427080          ORR      r0,r2,#0x100          ;1546
00006e  680a              LDR      r2,[r1,#0]            ;1546
000070  320c              ADDS     r2,r2,#0xc            ;1546
000072  e8420300          STREX    r3,r0,[r2,#0]         ;1546
000076  2b00              CMP      r3,#0                 ;1546
000078  d1f3              BNE      |L23.98|
00007a  bf00              NOP                            ;1546
00007c  bf00              NOP                            ;1547
00007e  bf00              NOP                            ;1547
                  |L23.128|
000080  680a              LDR      r2,[r1,#0]            ;1547
000082  3214              ADDS     r2,r2,#0x14           ;1547
000084  e8522f00          LDREX    r2,[r2,#0]            ;1547
000088  f0420001          ORR      r0,r2,#1              ;1547
00008c  680a              LDR      r2,[r1,#0]            ;1547
00008e  3214              ADDS     r2,r2,#0x14           ;1547
000090  e8420300          STREX    r3,r0,[r2,#0]         ;1547
000094  2b00              CMP      r3,#0                 ;1547
000096  d1f3              BNE      |L23.128|
000098  bf00              NOP                            ;1547
00009a  bf00              NOP                            ;1550
00009c  bf00              NOP                            ;1550
                  |L23.158|
00009e  680a              LDR      r2,[r1,#0]            ;1550
0000a0  3214              ADDS     r2,r2,#0x14           ;1550
0000a2  e8522f00          LDREX    r2,[r2,#0]            ;1550
0000a6  f0420040          ORR      r0,r2,#0x40           ;1550
0000aa  680a              LDR      r2,[r1,#0]            ;1550
0000ac  3214              ADDS     r2,r2,#0x14           ;1550
0000ae  e8420300          STREX    r3,r0,[r2,#0]         ;1550
0000b2  2b00              CMP      r3,#0                 ;1550
0000b4  d1f3              BNE      |L23.158|
0000b6  bf00              NOP                            ;1550
                  |L23.184|
0000b8  bf00              NOP                            ;1554
0000ba  2000              MOVS     r0,#0                 ;1554
0000bc  f881003c          STRB     r0,[r1,#0x3c]         ;1554
0000c0  bf00              NOP                            ;1554
0000c2  bf00              NOP                            ;1556
0000c4  e7a4              B        |L23.16|
;;;1558   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1564     */
;;;1565   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1566   {
000002  4604              MOV      r4,r0
;;;1567     uint32_t dmarequest = 0x00U;
000004  2500              MOVS     r5,#0
;;;1568     /* The Lock is not implemented on this API to allow the user application
;;;1569        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1570        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1571        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1572        */
;;;1573   
;;;1574     /* Stop UART DMA Tx request if ongoing */
;;;1575     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000006  6820              LDR      r0,[r4,#0]
000008  6940              LDR      r0,[r0,#0x14]
00000a  f3c015c0          UBFX     r5,r0,#7,#1
;;;1576     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2821              CMP      r0,#0x21
000014  d117              BNE      |L24.70|
000016  b1b5              CBZ      r5,|L24.70|
;;;1577     {
;;;1578       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L24.28|
00001c  6821              LDR      r1,[r4,#0]
00001e  3114              ADDS     r1,r1,#0x14
000020  e8511f00          LDREX    r1,[r1,#0]
000024  f0210080          BIC      r0,r1,#0x80
000028  6821              LDR      r1,[r4,#0]
00002a  3114              ADDS     r1,r1,#0x14
00002c  e8410200          STREX    r2,r0,[r1,#0]
000030  2a00              CMP      r2,#0
000032  d1f3              BNE      |L24.28|
000034  bf00              NOP      
;;;1579   
;;;1580       /* Abort the UART DMA Tx stream */
;;;1581       if (huart->hdmatx != NULL)
000036  6b60              LDR      r0,[r4,#0x34]
000038  b110              CBZ      r0,|L24.64|
;;;1582       {
;;;1583         HAL_DMA_Abort(huart->hdmatx);
00003a  6b60              LDR      r0,[r4,#0x34]
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L24.64|
;;;1584       }
;;;1585       UART_EndTxTransfer(huart);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       UART_EndTxTransfer
                  |L24.70|
;;;1586     }
;;;1587   
;;;1588     /* Stop UART DMA Rx request if ongoing */
;;;1589     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000046  6820              LDR      r0,[r4,#0]
000048  6940              LDR      r0,[r0,#0x14]
00004a  f3c01580          UBFX     r5,r0,#6,#1
;;;1590     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00004e  f894003e          LDRB     r0,[r4,#0x3e]
000052  2822              CMP      r0,#0x22
000054  d117              BNE      |L24.134|
000056  b1b5              CBZ      r5,|L24.134|
;;;1591     {
;;;1592       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000058  bf00              NOP      
00005a  bf00              NOP      
                  |L24.92|
00005c  6821              LDR      r1,[r4,#0]
00005e  3114              ADDS     r1,r1,#0x14
000060  e8511f00          LDREX    r1,[r1,#0]
000064  f0210040          BIC      r0,r1,#0x40
000068  6821              LDR      r1,[r4,#0]
00006a  3114              ADDS     r1,r1,#0x14
00006c  e8410200          STREX    r2,r0,[r1,#0]
000070  2a00              CMP      r2,#0
000072  d1f3              BNE      |L24.92|
000074  bf00              NOP      
;;;1593   
;;;1594       /* Abort the UART DMA Rx stream */
;;;1595       if (huart->hdmarx != NULL)
000076  6ba0              LDR      r0,[r4,#0x38]
000078  b110              CBZ      r0,|L24.128|
;;;1596       {
;;;1597         HAL_DMA_Abort(huart->hdmarx);
00007a  6ba0              LDR      r0,[r4,#0x38]
00007c  f7fffffe          BL       HAL_DMA_Abort
                  |L24.128|
;;;1598       }
;;;1599       UART_EndRxTransfer(huart);
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       UART_EndRxTransfer
                  |L24.134|
;;;1600     }
;;;1601   
;;;1602     return HAL_OK;
000086  2000              MOVS     r0,#0
;;;1603   }
000088  bd70              POP      {r4-r6,pc}
;;;1604   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_UART_DeInit PROC
;;;663      */
;;;664    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;665    {
000002  4604              MOV      r4,r0
;;;666      /* Check the UART handle allocation */
;;;667      if (huart == NULL)
000004  b90c              CBNZ     r4,|L25.10|
;;;668      {
;;;669        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L25.8|
;;;670      }
;;;671    
;;;672      /* Check the parameters */
;;;673      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;674    
;;;675      huart->gState = HAL_UART_STATE_BUSY;
;;;676    
;;;677      /* Disable the Peripheral */
;;;678      __HAL_UART_DISABLE(huart);
;;;679    
;;;680    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;681      if (huart->MspDeInitCallback == NULL)
;;;682      {
;;;683        huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;684      }
;;;685      /* DeInit the low level hardware */
;;;686      huart->MspDeInitCallback(huart);
;;;687    #else
;;;688      /* DeInit the low level hardware */
;;;689      HAL_UART_MspDeInit(huart);
;;;690    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;691    
;;;692      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;693      huart->gState = HAL_UART_STATE_RESET;
;;;694      huart->RxState = HAL_UART_STATE_RESET;
;;;695      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;696    
;;;697      /* Process Unlock */
;;;698      __HAL_UNLOCK(huart);
;;;699    
;;;700      return HAL_OK;
;;;701    }
000008  bd10              POP      {r4,pc}
                  |L25.10|
00000a  2024              MOVS     r0,#0x24              ;675
00000c  f884003d          STRB     r0,[r4,#0x3d]         ;675
000010  6820              LDR      r0,[r4,#0]            ;678
000012  68c0              LDR      r0,[r0,#0xc]          ;678
000014  f4205000          BIC      r0,r0,#0x2000         ;678
000018  6821              LDR      r1,[r4,#0]            ;678
00001a  60c8              STR      r0,[r1,#0xc]          ;678
00001c  6f20              LDR      r0,[r4,#0x70]         ;681
00001e  b908              CBNZ     r0,|L25.36|
000020  4808              LDR      r0,|L25.68|
000022  6720              STR      r0,[r4,#0x70]         ;683
                  |L25.36|
000024  4620              MOV      r0,r4                 ;686
000026  6f21              LDR      r1,[r4,#0x70]         ;686
000028  4788              BLX      r1                    ;686
00002a  2000              MOVS     r0,#0                 ;692
00002c  6420              STR      r0,[r4,#0x40]         ;692
00002e  f884003d          STRB     r0,[r4,#0x3d]         ;693
000032  f884003e          STRB     r0,[r4,#0x3e]         ;694
000036  6320              STR      r0,[r4,#0x30]         ;695
000038  bf00              NOP                            ;698
00003a  f884003c          STRB     r0,[r4,#0x3c]         ;698
00003e  bf00              NOP                            ;698
000040  bf00              NOP                            ;700
000042  e7e1              B        |L25.8|
;;;702    
                          ENDP

                  |L25.68|
                          DCD      HAL_UART_MspDeInit

                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;2647     */
;;;2648   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2649   {
;;;2650     /* Prevent unused argument(s) compilation warning */
;;;2651     UNUSED(huart);
;;;2652     /* NOTE: This function should not be modified, when the callback is needed,
;;;2653              the HAL_UART_ErrorCallback could be implemented in the user file
;;;2654      */
;;;2655   }
;;;2656   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2936     */
;;;2937   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2938   {
;;;2939     return huart->ErrorCode;
000002  6c08              LDR      r0,[r1,#0x40]
;;;2940   }
000004  4770              BX       lr
;;;2941   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2921     */
;;;2922   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2923   {
;;;2924     uint32_t temp1 = 0x00U, temp2 = 0x00U;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;2925     temp1 = huart->gState;
000006  f891203d          LDRB     r2,[r1,#0x3d]
;;;2926     temp2 = huart->RxState;
00000a  f891303e          LDRB     r3,[r1,#0x3e]
;;;2927   
;;;2928     return (HAL_UART_StateTypeDef)(temp1 | temp2);
00000e  ea420003          ORR      r0,r2,r3
;;;2929   }
000012  4770              BX       lr
;;;2930   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;2355     */
;;;2356   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2357   {
000004  4604              MOV      r4,r0
;;;2358     uint32_t isrflags   = READ_REG(huart->Instance->SR);
000006  6820              LDR      r0,[r4,#0]
000008  6805              LDR      r5,[r0,#0]
;;;2359     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  6820              LDR      r0,[r4,#0]
00000c  68c6              LDR      r6,[r0,#0xc]
;;;2360     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000e  6820              LDR      r0,[r4,#0]
000010  6947              LDR      r7,[r0,#0x14]
;;;2361     uint32_t errorflags = 0x00U;
000012  f04f0900          MOV      r9,#0
;;;2362     uint32_t dmarequest = 0x00U;
000016  46ca              MOV      r10,r9
;;;2363   
;;;2364     /* If no error occurs */
;;;2365     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
000018  f005090f          AND      r9,r5,#0xf
;;;2366     if (errorflags == RESET)
00001c  f1b90f00          CMP      r9,#0
000020  d10a              BNE      |L29.56|
;;;2367     {
;;;2368       /* UART in mode Receiver -------------------------------------------------*/
;;;2369       if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000022  f0050020          AND      r0,r5,#0x20
000026  b138              CBZ      r0,|L29.56|
000028  f0060020          AND      r0,r6,#0x20
00002c  b120              CBZ      r0,|L29.56|
;;;2370       {
;;;2371         UART_Receive_IT(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       UART_Receive_IT
                  |L29.52|
;;;2372         return;
;;;2373       }
;;;2374     }
;;;2375   
;;;2376     /* If some errors occur */
;;;2377     if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET)
;;;2378                                   || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
;;;2379     {
;;;2380       /* UART parity error interrupt occurred ----------------------------------*/
;;;2381       if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;2382       {
;;;2383         huart->ErrorCode |= HAL_UART_ERROR_PE;
;;;2384       }
;;;2385   
;;;2386       /* UART noise error interrupt occurred -----------------------------------*/
;;;2387       if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2388       {
;;;2389         huart->ErrorCode |= HAL_UART_ERROR_NE;
;;;2390       }
;;;2391   
;;;2392       /* UART frame error interrupt occurred -----------------------------------*/
;;;2393       if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2394       {
;;;2395         huart->ErrorCode |= HAL_UART_ERROR_FE;
;;;2396       }
;;;2397   
;;;2398       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;2399       if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET)
;;;2400                                                    || ((cr3its & USART_CR3_EIE) != RESET)))
;;;2401       {
;;;2402         huart->ErrorCode |= HAL_UART_ERROR_ORE;
;;;2403       }
;;;2404   
;;;2405       /* Call UART Error Call back function if need be --------------------------*/
;;;2406       if (huart->ErrorCode != HAL_UART_ERROR_NONE)
;;;2407       {
;;;2408         /* UART in mode Receiver -----------------------------------------------*/
;;;2409         if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;2410         {
;;;2411           UART_Receive_IT(huart);
;;;2412         }
;;;2413   
;;;2414         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;2415            consider error as blocking */
;;;2416         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;2417         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
;;;2418         {
;;;2419           /* Blocking error : transfer is aborted
;;;2420              Set the UART state ready to be able to start again the process,
;;;2421              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;2422           UART_EndRxTransfer(huart);
;;;2423   
;;;2424           /* Disable the UART DMA Rx request if enabled */
;;;2425           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;2426           {
;;;2427             ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2428   
;;;2429             /* Abort the UART DMA Rx stream */
;;;2430             if (huart->hdmarx != NULL)
;;;2431             {
;;;2432               /* Set the UART DMA Abort callback :
;;;2433                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;2434               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;2435               if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;2436               {
;;;2437                 /* Call Directly XferAbortCallback function in case of error */
;;;2438                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;2439               }
;;;2440             }
;;;2441             else
;;;2442             {
;;;2443               /* Call user error callback */
;;;2444   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2445               /*Call registered error callback*/
;;;2446               huart->ErrorCallback(huart);
;;;2447   #else
;;;2448               /*Call legacy weak error callback*/
;;;2449               HAL_UART_ErrorCallback(huart);
;;;2450   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2451             }
;;;2452           }
;;;2453           else
;;;2454           {
;;;2455             /* Call user error callback */
;;;2456   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2457             /*Call registered error callback*/
;;;2458             huart->ErrorCallback(huart);
;;;2459   #else
;;;2460             /*Call legacy weak error callback*/
;;;2461             HAL_UART_ErrorCallback(huart);
;;;2462   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2463           }
;;;2464         }
;;;2465         else
;;;2466         {
;;;2467           /* Non Blocking error : transfer could go on.
;;;2468              Error is notified to user through user error callback */
;;;2469   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2470           /*Call registered error callback*/
;;;2471           huart->ErrorCallback(huart);
;;;2472   #else
;;;2473           /*Call legacy weak error callback*/
;;;2474           HAL_UART_ErrorCallback(huart);
;;;2475   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2476   
;;;2477           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2478         }
;;;2479       }
;;;2480       return;
;;;2481     } /* End if some error occurs */
;;;2482   
;;;2483     /* Check current reception Mode :
;;;2484        If Reception till IDLE event has been selected : */
;;;2485     if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;2486         && ((isrflags & USART_SR_IDLE) != 0U)
;;;2487         && ((cr1its & USART_SR_IDLE) != 0U))
;;;2488     {
;;;2489       __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;2490   
;;;2491       /* Check if DMA mode is enabled in UART */
;;;2492       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;2493       {
;;;2494         /* DMA mode enabled */
;;;2495         /* Check received length : If all expected data are received, do nothing,
;;;2496            (DMA cplt callback will be called).
;;;2497            Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
;;;2498         uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
;;;2499         if ((nb_remaining_rx_data > 0U)
;;;2500             && (nb_remaining_rx_data < huart->RxXferSize))
;;;2501         {
;;;2502           /* Reception is not complete */
;;;2503           huart->RxXferCount = nb_remaining_rx_data;
;;;2504   
;;;2505           /* In Normal mode, end DMA xfer and HAL UART Rx process*/
;;;2506           if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
;;;2507           {
;;;2508             /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2509             ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;2510             ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2511   
;;;2512             /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
;;;2513                in the UART CR3 register */
;;;2514             ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2515   
;;;2516             /* At end of Rx process, restore huart->RxState to Ready */
;;;2517             huart->RxState = HAL_UART_STATE_READY;
;;;2518             huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2519   
;;;2520             ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;2521   
;;;2522             /* Last bytes received, so no need as the abort is immediate */
;;;2523             (void)HAL_DMA_Abort(huart->hdmarx);
;;;2524           }
;;;2525   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2526           /*Call registered Rx Event callback*/
;;;2527           huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
;;;2528   #else
;;;2529           /*Call legacy weak Rx Event callback*/
;;;2530           HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
;;;2531   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2532         }
;;;2533         return;
;;;2534       }
;;;2535       else
;;;2536       {
;;;2537         /* DMA mode not enabled */
;;;2538         /* Check received length : If all expected data are received, do nothing.
;;;2539            Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
;;;2540         uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
;;;2541         if ((huart->RxXferCount > 0U)
;;;2542             && (nb_rx_data > 0U))
;;;2543         {
;;;2544           /* Disable the UART Parity Error Interrupt and RXNE interrupts */
;;;2545           ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;2546   
;;;2547           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2548           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2549   
;;;2550           /* Rx process is completed, restore huart->RxState to Ready */
;;;2551           huart->RxState = HAL_UART_STATE_READY;
;;;2552           huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2553   
;;;2554           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;2555   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2556           /*Call registered Rx complete callback*/
;;;2557           huart->RxEventCallback(huart, nb_rx_data);
;;;2558   #else
;;;2559           /*Call legacy weak Rx Event callback*/
;;;2560           HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
;;;2561   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2562         }
;;;2563         return;
;;;2564       }
;;;2565     }
;;;2566   
;;;2567     /* UART in mode Transmitter ------------------------------------------------*/
;;;2568     if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;2569     {
;;;2570       UART_Transmit_IT(huart);
;;;2571       return;
;;;2572     }
;;;2573   
;;;2574     /* UART in mode Transmitter end --------------------------------------------*/
;;;2575     if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;2576     {
;;;2577       UART_EndTransmit_IT(huart);
;;;2578       return;
;;;2579     }
;;;2580   }
000034  e8bd8ff8          POP      {r3-r11,pc}
                  |L29.56|
000038  f1b90f00          CMP      r9,#0                 ;2377
00003c  d07c              BEQ      |L29.312|
00003e  f0070001          AND      r0,r7,#1              ;2377
000042  b918              CBNZ     r0,|L29.76|
000044  f4067090          AND      r0,r6,#0x120          ;2378
000048  2800              CMP      r0,#0                 ;2378
00004a  d075              BEQ      |L29.312|
                  |L29.76|
00004c  f0050001          AND      r0,r5,#1              ;2381
000050  b130              CBZ      r0,|L29.96|
000052  f4067080          AND      r0,r6,#0x100          ;2381
000056  b118              CBZ      r0,|L29.96|
000058  6c20              LDR      r0,[r4,#0x40]         ;2383
00005a  f0400001          ORR      r0,r0,#1              ;2383
00005e  6420              STR      r0,[r4,#0x40]         ;2383
                  |L29.96|
000060  f0050004          AND      r0,r5,#4              ;2387
000064  b130              CBZ      r0,|L29.116|
000066  f0070001          AND      r0,r7,#1              ;2387
00006a  b118              CBZ      r0,|L29.116|
00006c  6c20              LDR      r0,[r4,#0x40]         ;2389
00006e  f0400002          ORR      r0,r0,#2              ;2389
000072  6420              STR      r0,[r4,#0x40]         ;2389
                  |L29.116|
000074  f0050002          AND      r0,r5,#2              ;2393
000078  b130              CBZ      r0,|L29.136|
00007a  f0070001          AND      r0,r7,#1              ;2393
00007e  b118              CBZ      r0,|L29.136|
000080  6c20              LDR      r0,[r4,#0x40]         ;2395
000082  f0400004          ORR      r0,r0,#4              ;2395
000086  6420              STR      r0,[r4,#0x40]         ;2395
                  |L29.136|
000088  f0050008          AND      r0,r5,#8              ;2399
00008c  b148              CBZ      r0,|L29.162|
00008e  f0060020          AND      r0,r6,#0x20           ;2399
000092  b910              CBNZ     r0,|L29.154|
000094  f0070001          AND      r0,r7,#1              ;2400
000098  b118              CBZ      r0,|L29.162|
                  |L29.154|
00009a  6c20              LDR      r0,[r4,#0x40]         ;2402
00009c  f0400008          ORR      r0,r0,#8              ;2402
0000a0  6420              STR      r0,[r4,#0x40]         ;2402
                  |L29.162|
0000a2  6c20              LDR      r0,[r4,#0x40]         ;2406
0000a4  2800              CMP      r0,#0                 ;2406
0000a6  d046              BEQ      |L29.310|
0000a8  f0050020          AND      r0,r5,#0x20           ;2409
0000ac  b128              CBZ      r0,|L29.186|
0000ae  f0060020          AND      r0,r6,#0x20           ;2409
0000b2  b110              CBZ      r0,|L29.186|
0000b4  4620              MOV      r0,r4                 ;2411
0000b6  f7fffffe          BL       UART_Receive_IT
                  |L29.186|
0000ba  6820              LDR      r0,[r4,#0]            ;2416
0000bc  6940              LDR      r0,[r0,#0x14]         ;2416
0000be  f3c01a80          UBFX     r10,r0,#6,#1          ;2416
0000c2  6c20              LDR      r0,[r4,#0x40]         ;2417
0000c4  f0000008          AND      r0,r0,#8              ;2417
0000c8  b910              CBNZ     r0,|L29.208|
0000ca  f1ba0f00          CMP      r10,#0                ;2417
0000ce  d02d              BEQ      |L29.300|
                  |L29.208|
0000d0  4620              MOV      r0,r4                 ;2422
0000d2  f7fffffe          BL       UART_EndRxTransfer
0000d6  6820              LDR      r0,[r4,#0]            ;2425
0000d8  6940              LDR      r0,[r0,#0x14]         ;2425
0000da  f0000040          AND      r0,r0,#0x40           ;2425
0000de  2840              CMP      r0,#0x40              ;2425
0000e0  d120              BNE      |L29.292|
0000e2  bf00              NOP                            ;2427
0000e4  bf00              NOP                            ;2427
                  |L29.230|
0000e6  6821              LDR      r1,[r4,#0]            ;2427
0000e8  3114              ADDS     r1,r1,#0x14           ;2427
0000ea  e8511f00          LDREX    r1,[r1,#0]            ;2427
0000ee  f0210040          BIC      r0,r1,#0x40           ;2427
0000f2  6821              LDR      r1,[r4,#0]            ;2427
0000f4  3114              ADDS     r1,r1,#0x14           ;2427
0000f6  e8410200          STREX    r2,r0,[r1,#0]         ;2427
0000fa  2a00              CMP      r2,#0                 ;2427
0000fc  d1f3              BNE      |L29.230|
0000fe  bf00              NOP                            ;2427
000100  6ba0              LDR      r0,[r4,#0x38]         ;2430
000102  b150              CBZ      r0,|L29.282|
000104  4875              LDR      r0,|L29.732|
000106  6ba1              LDR      r1,[r4,#0x38]         ;2434
000108  6508              STR      r0,[r1,#0x50]         ;2434
00010a  6ba0              LDR      r0,[r4,#0x38]         ;2435
00010c  f7fffffe          BL       HAL_DMA_Abort_IT
000110  b188              CBZ      r0,|L29.310|
000112  6ba0              LDR      r0,[r4,#0x38]         ;2438
000114  6d01              LDR      r1,[r0,#0x50]         ;2438
000116  4788              BLX      r1                    ;2438
000118  e00d              B        |L29.310|
                  |L29.282|
00011a  4620              MOV      r0,r4                 ;2446
00011c  6d61              LDR      r1,[r4,#0x54]         ;2446
00011e  4788              BLX      r1                    ;2446
000120  e009              B        |L29.310|
000122  e009              B        |L29.312|
                  |L29.292|
000124  4620              MOV      r0,r4                 ;2458
000126  6d61              LDR      r1,[r4,#0x54]         ;2458
000128  4788              BLX      r1                    ;2458
00012a  e004              B        |L29.310|
                  |L29.300|
00012c  4620              MOV      r0,r4                 ;2471
00012e  6d61              LDR      r1,[r4,#0x54]         ;2471
000130  4788              BLX      r1                    ;2471
000132  2000              MOVS     r0,#0                 ;2477
000134  6420              STR      r0,[r4,#0x40]         ;2477
                  |L29.310|
000136  e77d              B        |L29.52|
                  |L29.312|
000138  6b20              LDR      r0,[r4,#0x30]         ;2485
00013a  2801              CMP      r0,#1                 ;2485
00013c  d176              BNE      |L29.556|
00013e  f0050010          AND      r0,r5,#0x10           ;2486
000142  2800              CMP      r0,#0                 ;2486
                  |L29.324|
000144  d072              BEQ      |L29.556|
000146  f0060010          AND      r0,r6,#0x10           ;2487
00014a  2800              CMP      r0,#0                 ;2487
00014c  d0fa              BEQ      |L29.324|
00014e  bf00              NOP                            ;2489
000150  2000              MOVS     r0,#0                 ;2489
000152  9000              STR      r0,[sp,#0]            ;2489
000154  6820              LDR      r0,[r4,#0]            ;2489
000156  6800              LDR      r0,[r0,#0]            ;2489
000158  9000              STR      r0,[sp,#0]            ;2489
00015a  6820              LDR      r0,[r4,#0]            ;2489
00015c  6840              LDR      r0,[r0,#4]            ;2489
00015e  9000              STR      r0,[sp,#0]            ;2489
000160  bf00              NOP                            ;2489
000162  bf00              NOP                            ;2489
000164  6820              LDR      r0,[r4,#0]            ;2492
000166  6940              LDR      r0,[r0,#0x14]         ;2492
000168  f0000040          AND      r0,r0,#0x40           ;2492
00016c  2840              CMP      r0,#0x40              ;2492
00016e  d15e              BNE      |L29.558|
000170  6ba0              LDR      r0,[r4,#0x38]         ;2498
000172  6800              LDR      r0,[r0,#0]            ;2498
000174  6840              LDR      r0,[r0,#4]            ;2498
000176  fa1ff880          UXTH     r8,r0                 ;2498
00017a  f1b80f00          CMP      r8,#0                 ;2499
00017e  d054              BEQ      |L29.554|
000180  8da0              LDRH     r0,[r4,#0x2c]         ;2500
000182  4540              CMP      r0,r8                 ;2500
000184  dd51              BLE      |L29.554|
000186  f8a4802e          STRH     r8,[r4,#0x2e]         ;2503
00018a  6ba0              LDR      r0,[r4,#0x38]         ;2506
00018c  69c0              LDR      r0,[r0,#0x1c]         ;2506
00018e  f5b07f80          CMP      r0,#0x100             ;2506
000192  d043              BEQ      |L29.540|
000194  bf00              NOP                            ;2509
000196  bf00              NOP                            ;2509
                  |L29.408|
000198  6821              LDR      r1,[r4,#0]            ;2509
00019a  310c              ADDS     r1,r1,#0xc            ;2509
00019c  e8511f00          LDREX    r1,[r1,#0]            ;2509
0001a0  f4217080          BIC      r0,r1,#0x100          ;2509
0001a4  6821              LDR      r1,[r4,#0]            ;2509
0001a6  310c              ADDS     r1,r1,#0xc            ;2509
0001a8  e8410200          STREX    r2,r0,[r1,#0]         ;2509
0001ac  2a00              CMP      r2,#0                 ;2509
0001ae  d1f3              BNE      |L29.408|
0001b0  bf00              NOP                            ;2509
0001b2  bf00              NOP                            ;2510
0001b4  bf00              NOP                            ;2510
                  |L29.438|
0001b6  6821              LDR      r1,[r4,#0]            ;2510
0001b8  3114              ADDS     r1,r1,#0x14           ;2510
0001ba  e8511f00          LDREX    r1,[r1,#0]            ;2510
0001be  f0210001          BIC      r0,r1,#1              ;2510
0001c2  6821              LDR      r1,[r4,#0]            ;2510
0001c4  3114              ADDS     r1,r1,#0x14           ;2510
0001c6  e8410200          STREX    r2,r0,[r1,#0]         ;2510
0001ca  2a00              CMP      r2,#0                 ;2510
0001cc  d1f3              BNE      |L29.438|
0001ce  bf00              NOP                            ;2510
0001d0  bf00              NOP                            ;2514
0001d2  bf00              NOP                            ;2514
                  |L29.468|
0001d4  6821              LDR      r1,[r4,#0]            ;2514
0001d6  3114              ADDS     r1,r1,#0x14           ;2514
0001d8  e8511f00          LDREX    r1,[r1,#0]            ;2514
0001dc  f0210040          BIC      r0,r1,#0x40           ;2514
0001e0  6821              LDR      r1,[r4,#0]            ;2514
0001e2  3114              ADDS     r1,r1,#0x14           ;2514
0001e4  e8410200          STREX    r2,r0,[r1,#0]         ;2514
0001e8  2a00              CMP      r2,#0                 ;2514
0001ea  d1f3              BNE      |L29.468|
0001ec  bf00              NOP                            ;2514
0001ee  2020              MOVS     r0,#0x20              ;2517
0001f0  f884003e          STRB     r0,[r4,#0x3e]         ;2517
0001f4  2000              MOVS     r0,#0                 ;2518
0001f6  6320              STR      r0,[r4,#0x30]         ;2518
0001f8  bf00              NOP                            ;2520
0001fa  bf00              NOP                            ;2520
                  |L29.508|
0001fc  6821              LDR      r1,[r4,#0]            ;2520
0001fe  310c              ADDS     r1,r1,#0xc            ;2520
000200  e8511f00          LDREX    r1,[r1,#0]            ;2520
000204  f0210010          BIC      r0,r1,#0x10           ;2520
000208  6821              LDR      r1,[r4,#0]            ;2520
00020a  310c              ADDS     r1,r1,#0xc            ;2520
00020c  e8410200          STREX    r2,r0,[r1,#0]         ;2520
000210  2a00              CMP      r2,#0                 ;2520
000212  d1f3              BNE      |L29.508|
000214  bf00              NOP                            ;2520
000216  6ba0              LDR      r0,[r4,#0x38]         ;2523
000218  f7fffffe          BL       HAL_DMA_Abort
                  |L29.540|
00021c  8da0              LDRH     r0,[r4,#0x2c]         ;2527
00021e  8de3              LDRH     r3,[r4,#0x2e]         ;2527
000220  1ac0              SUBS     r0,r0,r3              ;2527
000222  b281              UXTH     r1,r0                 ;2527
000224  4620              MOV      r0,r4                 ;2527
000226  6ea2              LDR      r2,[r4,#0x68]         ;2527
000228  4790              BLX      r2                    ;2527
                  |L29.554|
00022a  e703              B        |L29.52|
                  |L29.556|
00022c  e040              B        |L29.688|
                  |L29.558|
00022e  8da0              LDRH     r0,[r4,#0x2c]         ;2540
000230  8de1              LDRH     r1,[r4,#0x2e]         ;2540
000232  1a40              SUBS     r0,r0,r1              ;2540
000234  fa1ff880          UXTH     r8,r0                 ;2540
000238  8de0              LDRH     r0,[r4,#0x2e]         ;2541
00023a  b3c0              CBZ      r0,|L29.686|
00023c  f1b80f00          CMP      r8,#0                 ;2542
000240  d035              BEQ      |L29.686|
000242  bf00              NOP                            ;2545
000244  bf00              NOP                            ;2545
                  |L29.582|
000246  6821              LDR      r1,[r4,#0]            ;2545
000248  310c              ADDS     r1,r1,#0xc            ;2545
00024a  e8511f00          LDREX    r1,[r1,#0]            ;2545
00024e  f4217090          BIC      r0,r1,#0x120          ;2545
000252  6821              LDR      r1,[r4,#0]            ;2545
000254  310c              ADDS     r1,r1,#0xc            ;2545
000256  e8410200          STREX    r2,r0,[r1,#0]         ;2545
00025a  2a00              CMP      r2,#0                 ;2545
00025c  d1f3              BNE      |L29.582|
00025e  bf00              NOP                            ;2545
000260  bf00              NOP                            ;2548
000262  bf00              NOP                            ;2548
                  |L29.612|
000264  6821              LDR      r1,[r4,#0]            ;2548
000266  3114              ADDS     r1,r1,#0x14           ;2548
000268  e8511f00          LDREX    r1,[r1,#0]            ;2548
00026c  f0210001          BIC      r0,r1,#1              ;2548
000270  6821              LDR      r1,[r4,#0]            ;2548
000272  3114              ADDS     r1,r1,#0x14           ;2548
000274  e8410200          STREX    r2,r0,[r1,#0]         ;2548
000278  2a00              CMP      r2,#0                 ;2548
00027a  d1f3              BNE      |L29.612|
00027c  bf00              NOP                            ;2548
00027e  2020              MOVS     r0,#0x20              ;2551
000280  f884003e          STRB     r0,[r4,#0x3e]         ;2551
000284  2000              MOVS     r0,#0                 ;2552
000286  6320              STR      r0,[r4,#0x30]         ;2552
000288  bf00              NOP                            ;2554
00028a  bf00              NOP                            ;2554
                  |L29.652|
00028c  6821              LDR      r1,[r4,#0]            ;2554
00028e  310c              ADDS     r1,r1,#0xc            ;2554
000290  e8511f00          LDREX    r1,[r1,#0]            ;2554
000294  f0210010          BIC      r0,r1,#0x10           ;2554
000298  6821              LDR      r1,[r4,#0]            ;2554
00029a  310c              ADDS     r1,r1,#0xc            ;2554
00029c  e8410200          STREX    r2,r0,[r1,#0]         ;2554
0002a0  2a00              CMP      r2,#0                 ;2554
0002a2  d1f3              BNE      |L29.652|
0002a4  bf00              NOP                            ;2554
0002a6  4641              MOV      r1,r8                 ;2557
0002a8  4620              MOV      r0,r4                 ;2557
0002aa  6ea2              LDR      r2,[r4,#0x68]         ;2557
0002ac  4790              BLX      r2                    ;2557
                  |L29.686|
0002ae  e6c1              B        |L29.52|
                  |L29.688|
0002b0  f0050080          AND      r0,r5,#0x80           ;2568
0002b4  b130              CBZ      r0,|L29.708|
0002b6  f0060080          AND      r0,r6,#0x80           ;2568
0002ba  b118              CBZ      r0,|L29.708|
0002bc  4620              MOV      r0,r4                 ;2570
0002be  f7fffffe          BL       UART_Transmit_IT
0002c2  e6b7              B        |L29.52|
                  |L29.708|
0002c4  f0050040          AND      r0,r5,#0x40           ;2575
0002c8  b130              CBZ      r0,|L29.728|
0002ca  f0060040          AND      r0,r6,#0x40           ;2575
0002ce  b118              CBZ      r0,|L29.728|
0002d0  4620              MOV      r0,r4                 ;2577
0002d2  f7fffffe          BL       UART_EndTransmit_IT
0002d6  e6ad              B        |L29.52|
                  |L29.728|
0002d8  bf00              NOP      
0002da  e6ab              B        |L29.52|
;;;2581   
                          ENDP

                  |L29.732|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=2

                  HAL_UART_Init PROC
;;;355      */
;;;356    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;357    {
000002  4604              MOV      r4,r0
;;;358      /* Check the UART handle allocation */
;;;359      if (huart == NULL)
000004  b90c              CBNZ     r4,|L30.10|
;;;360      {
;;;361        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L30.8|
;;;362      }
;;;363    
;;;364      /* Check the parameters */
;;;365      if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;366      {
;;;367        /* The hardware flow control is available only for USART1, USART2, USART3 and USART6.
;;;368           Except for STM32F446xx devices, that is available for USART1, USART2, USART3, USART6, UART4 and UART5.
;;;369        */
;;;370        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;371        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;372      }
;;;373      else
;;;374      {
;;;375        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;376      }
;;;377      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;378      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;379    
;;;380      if (huart->gState == HAL_UART_STATE_RESET)
;;;381      {
;;;382        /* Allocate lock resource and initialize it */
;;;383        huart->Lock = HAL_UNLOCKED;
;;;384    
;;;385    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;386        UART_InitCallbacksToDefault(huart);
;;;387    
;;;388        if (huart->MspInitCallback == NULL)
;;;389        {
;;;390          huart->MspInitCallback = HAL_UART_MspInit;
;;;391        }
;;;392    
;;;393        /* Init the low level hardware */
;;;394        huart->MspInitCallback(huart);
;;;395    #else
;;;396        /* Init the low level hardware : GPIO, CLOCK */
;;;397        HAL_UART_MspInit(huart);
;;;398    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;399      }
;;;400    
;;;401      huart->gState = HAL_UART_STATE_BUSY;
;;;402    
;;;403      /* Disable the peripheral */
;;;404      __HAL_UART_DISABLE(huart);
;;;405    
;;;406      /* Set the UART Communication parameters */
;;;407      UART_SetConfig(huart);
;;;408    
;;;409      /* In asynchronous mode, the following bits must be kept cleared:
;;;410         - LINEN and CLKEN bits in the USART_CR2 register,
;;;411         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;412      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;413      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;414    
;;;415      /* Enable the peripheral */
;;;416      __HAL_UART_ENABLE(huart);
;;;417    
;;;418      /* Initialize the UART state */
;;;419      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;420      huart->gState = HAL_UART_STATE_READY;
;;;421      huart->RxState = HAL_UART_STATE_READY;
;;;422    
;;;423      return HAL_OK;
;;;424    }
000008  bd10              POP      {r4,pc}
                  |L30.10|
00000a  69a0              LDR      r0,[r4,#0x18]         ;365
00000c  b100              CBZ      r0,|L30.16|
00000e  e000              B        |L30.18|
                  |L30.16|
000010  bf00              NOP                            ;375
                  |L30.18|
000012  f894003d          LDRB     r0,[r4,#0x3d]         ;380
000016  b960              CBNZ     r0,|L30.50|
000018  2000              MOVS     r0,#0                 ;383
00001a  f884003c          STRB     r0,[r4,#0x3c]         ;383
00001e  4620              MOV      r0,r4                 ;386
000020  f7fffffe          BL       UART_InitCallbacksToDefault
000024  6ee0              LDR      r0,[r4,#0x6c]         ;388
000026  b908              CBNZ     r0,|L30.44|
000028  4815              LDR      r0,|L30.128|
00002a  66e0              STR      r0,[r4,#0x6c]         ;390
                  |L30.44|
00002c  4620              MOV      r0,r4                 ;394
00002e  6ee1              LDR      r1,[r4,#0x6c]         ;394
000030  4788              BLX      r1                    ;394
                  |L30.50|
000032  2024              MOVS     r0,#0x24              ;401
000034  f884003d          STRB     r0,[r4,#0x3d]         ;401
000038  6820              LDR      r0,[r4,#0]            ;404
00003a  68c0              LDR      r0,[r0,#0xc]          ;404
00003c  f4205000          BIC      r0,r0,#0x2000         ;404
000040  6821              LDR      r1,[r4,#0]            ;404
000042  60c8              STR      r0,[r1,#0xc]          ;404
000044  4620              MOV      r0,r4                 ;407
000046  f7fffffe          BL       UART_SetConfig
00004a  6820              LDR      r0,[r4,#0]            ;412
00004c  6900              LDR      r0,[r0,#0x10]         ;412
00004e  f4204090          BIC      r0,r0,#0x4800         ;412
000052  6821              LDR      r1,[r4,#0]            ;412
000054  6108              STR      r0,[r1,#0x10]         ;412
000056  6820              LDR      r0,[r4,#0]            ;413
000058  6940              LDR      r0,[r0,#0x14]         ;413
00005a  f020002a          BIC      r0,r0,#0x2a           ;413
00005e  6821              LDR      r1,[r4,#0]            ;413
000060  6148              STR      r0,[r1,#0x14]         ;413
000062  6820              LDR      r0,[r4,#0]            ;416
000064  68c0              LDR      r0,[r0,#0xc]          ;416
000066  f4405000          ORR      r0,r0,#0x2000         ;416
00006a  6821              LDR      r1,[r4,#0]            ;416
00006c  60c8              STR      r0,[r1,#0xc]          ;416
00006e  2000              MOVS     r0,#0                 ;419
000070  6420              STR      r0,[r4,#0x40]         ;419
000072  2020              MOVS     r0,#0x20              ;420
000074  f884003d          STRB     r0,[r4,#0x3d]         ;420
000078  f884003e          STRB     r0,[r4,#0x3e]         ;421
00007c  2000              MOVS     r0,#0                 ;423
00007e  e7c3              B        |L30.8|
;;;425    
                          ENDP

                  |L30.128|
                          DCD      HAL_UART_MspInit

                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;723      */
;;;724    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;725    {
;;;726      /* Prevent unused argument(s) compilation warning */
;;;727      UNUSED(huart);
;;;728      /* NOTE: This function should not be modified, when the callback is needed,
;;;729               the HAL_UART_MspDeInit could be implemented in the user file
;;;730       */
;;;731    }
;;;732    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;708      */
;;;709    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;710    {
;;;711      /* Prevent unused argument(s) compilation warning */
;;;712      UNUSED(huart);
;;;713      /* NOTE: This function should not be modified, when the callback is needed,
;;;714               the HAL_UART_MspInit could be implemented in the user file
;;;715       */
;;;716    }
;;;717    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;1222     */
;;;1223   HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1224   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;1225     uint8_t  *pdata8bits;
;;;1226     uint16_t *pdata16bits;
;;;1227     uint32_t tickstart = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;1228   
;;;1229     /* Check that a Rx process is not already ongoing */
;;;1230     if (huart->RxState == HAL_UART_STATE_READY)
000010  f894003e          LDRB     r0,[r4,#0x3e]
000014  2820              CMP      r0,#0x20
000016  d15f              BNE      |L33.216|
;;;1231     {
;;;1232       if ((pData == NULL) || (Size == 0U))
000018  b106              CBZ      r6,|L33.28|
00001a  b917              CBNZ     r7,|L33.34|
                  |L33.28|
;;;1233       {
;;;1234         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L33.30|
;;;1235       }
;;;1236   
;;;1237       /* Process Locked */
;;;1238       __HAL_LOCK(huart);
;;;1239   
;;;1240       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1241       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1242       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1243   
;;;1244       /* Init tickstart for timeout management */
;;;1245       tickstart = HAL_GetTick();
;;;1246   
;;;1247       huart->RxXferSize = Size;
;;;1248       huart->RxXferCount = Size;
;;;1249   
;;;1250       /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;1251       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1252       {
;;;1253         pdata8bits  = NULL;
;;;1254         pdata16bits = (uint16_t *) pData;
;;;1255       }
;;;1256       else
;;;1257       {
;;;1258         pdata8bits  = pData;
;;;1259         pdata16bits = NULL;
;;;1260       }
;;;1261   
;;;1262       /* Process Unlocked */
;;;1263       __HAL_UNLOCK(huart);
;;;1264   
;;;1265       /* Check the remain data to be received */
;;;1266       while (huart->RxXferCount > 0U)
;;;1267       {
;;;1268         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1269         {
;;;1270           return HAL_TIMEOUT;
;;;1271         }
;;;1272         if (pdata8bits == NULL)
;;;1273         {
;;;1274           *pdata16bits = (uint16_t)(huart->Instance->DR & 0x01FF);
;;;1275           pdata16bits++;
;;;1276         }
;;;1277         else
;;;1278         {
;;;1279           if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
;;;1280           {
;;;1281             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1282           }
;;;1283           else
;;;1284           {
;;;1285             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1286           }
;;;1287           pdata8bits++;
;;;1288         }
;;;1289         huart->RxXferCount--;
;;;1290       }
;;;1291   
;;;1292       /* At end of Rx process, restore huart->RxState to Ready */
;;;1293       huart->RxState = HAL_UART_STATE_READY;
;;;1294   
;;;1295       return HAL_OK;
;;;1296     }
;;;1297     else
;;;1298     {
;;;1299       return HAL_BUSY;
;;;1300     }
;;;1301   }
00001e  e8bd8ff8          POP      {r3-r11,pc}
                  |L33.34|
000022  bf00              NOP                            ;1238
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;1238
000028  2801              CMP      r0,#1                 ;1238
00002a  d101              BNE      |L33.48|
00002c  2002              MOVS     r0,#2                 ;1238
00002e  e7f6              B        |L33.30|
                  |L33.48|
000030  2001              MOVS     r0,#1                 ;1238
000032  f884003c          STRB     r0,[r4,#0x3c]         ;1238
000036  bf00              NOP                            ;1238
000038  2000              MOVS     r0,#0                 ;1240
00003a  6420              STR      r0,[r4,#0x40]         ;1240
00003c  2022              MOVS     r0,#0x22              ;1241
00003e  f884003e          STRB     r0,[r4,#0x3e]         ;1241
000042  2000              MOVS     r0,#0                 ;1242
000044  6320              STR      r0,[r4,#0x30]         ;1242
000046  f7fffffe          BL       HAL_GetTick
00004a  4682              MOV      r10,r0                ;1245
00004c  85a7              STRH     r7,[r4,#0x2c]         ;1247
00004e  85e7              STRH     r7,[r4,#0x2e]         ;1248
000050  68a0              LDR      r0,[r4,#8]            ;1251
000052  f5b05f80          CMP      r0,#0x1000            ;1251
000056  d104              BNE      |L33.98|
000058  6920              LDR      r0,[r4,#0x10]         ;1251
00005a  b910              CBNZ     r0,|L33.98|
00005c  2500              MOVS     r5,#0                 ;1253
00005e  46b0              MOV      r8,r6                 ;1254
000060  e002              B        |L33.104|
                  |L33.98|
000062  4635              MOV      r5,r6                 ;1258
000064  f04f0800          MOV      r8,#0                 ;1259
                  |L33.104|
000068  bf00              NOP                            ;1263
00006a  2000              MOVS     r0,#0                 ;1263
00006c  f884003c          STRB     r0,[r4,#0x3c]         ;1263
000070  bf00              NOP                            ;1263
000072  e029              B        |L33.200|
                  |L33.116|
000074  4653              MOV      r3,r10                ;1268
000076  2200              MOVS     r2,#0                 ;1268
000078  2120              MOVS     r1,#0x20              ;1268
00007a  4620              MOV      r0,r4                 ;1268
00007c  f8cd9000          STR      r9,[sp,#0]            ;1268
000080  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000084  b108              CBZ      r0,|L33.138|
000086  2003              MOVS     r0,#3                 ;1270
000088  e7c9              B        |L33.30|
                  |L33.138|
00008a  b945              CBNZ     r5,|L33.158|
00008c  6820              LDR      r0,[r4,#0]            ;1274
00008e  6840              LDR      r0,[r0,#4]            ;1274
000090  f3c00008          UBFX     r0,r0,#0,#9           ;1274
000094  f8a80000          STRH     r0,[r8,#0]            ;1274
000098  f1080802          ADD      r8,r8,#2              ;1275
00009c  e011              B        |L33.194|
                  |L33.158|
00009e  68a0              LDR      r0,[r4,#8]            ;1279
0000a0  f5b05f80          CMP      r0,#0x1000            ;1279
0000a4  d003              BEQ      |L33.174|
0000a6  68a0              LDR      r0,[r4,#8]            ;1279
0000a8  b928              CBNZ     r0,|L33.182|
0000aa  6920              LDR      r0,[r4,#0x10]         ;1279
0000ac  b918              CBNZ     r0,|L33.182|
                  |L33.174|
0000ae  6820              LDR      r0,[r4,#0]            ;1281
0000b0  6840              LDR      r0,[r0,#4]            ;1281
0000b2  7028              STRB     r0,[r5,#0]            ;1281
0000b4  e004              B        |L33.192|
                  |L33.182|
0000b6  6820              LDR      r0,[r4,#0]            ;1285
0000b8  6840              LDR      r0,[r0,#4]            ;1285
0000ba  f000007f          AND      r0,r0,#0x7f           ;1285
0000be  7028              STRB     r0,[r5,#0]            ;1285
                  |L33.192|
0000c0  1c6d              ADDS     r5,r5,#1              ;1287
                  |L33.194|
0000c2  8de0              LDRH     r0,[r4,#0x2e]         ;1289
0000c4  1e40              SUBS     r0,r0,#1              ;1289
0000c6  85e0              STRH     r0,[r4,#0x2e]         ;1289
                  |L33.200|
0000c8  8de0              LDRH     r0,[r4,#0x2e]         ;1266
0000ca  2800              CMP      r0,#0                 ;1266
0000cc  d1d2              BNE      |L33.116|
0000ce  2020              MOVS     r0,#0x20              ;1293
0000d0  f884003e          STRB     r0,[r4,#0x3e]         ;1293
0000d4  2000              MOVS     r0,#0                 ;1295
0000d6  e7a2              B        |L33.30|
                  |L33.216|
0000d8  2002              MOVS     r0,#2                 ;1299
0000da  e7a0              B        |L33.30|
;;;1302   
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_DMA PROC
;;;1461     */
;;;1462   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1463   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1464     /* Check that a Rx process is not already ongoing */
;;;1465     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003e          LDRB     r0,[r4,#0x3e]
00000c  2820              CMP      r0,#0x20
00000e  d116              BNE      |L34.62|
;;;1466     {
;;;1467       if ((pData == NULL) || (Size == 0U))
000010  b105              CBZ      r5,|L34.20|
000012  b90e              CBNZ     r6,|L34.24|
                  |L34.20|
;;;1468       {
;;;1469         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L34.22|
;;;1470       }
;;;1471   
;;;1472       /* Process Locked */
;;;1473       __HAL_LOCK(huart);
;;;1474   
;;;1475       /* Set Reception type to Standard reception */
;;;1476       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1477   
;;;1478       return (UART_Start_Receive_DMA(huart, pData, Size));
;;;1479     }
;;;1480     else
;;;1481     {
;;;1482       return HAL_BUSY;
;;;1483     }
;;;1484   }
000016  bd70              POP      {r4-r6,pc}
                  |L34.24|
000018  bf00              NOP                            ;1473
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1473
00001e  2801              CMP      r0,#1                 ;1473
000020  d101              BNE      |L34.38|
000022  2002              MOVS     r0,#2                 ;1473
000024  e7f7              B        |L34.22|
                  |L34.38|
000026  2001              MOVS     r0,#1                 ;1473
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1473
00002c  bf00              NOP                            ;1473
00002e  2000              MOVS     r0,#0                 ;1476
000030  6320              STR      r0,[r4,#0x30]         ;1476
000032  4632              MOV      r2,r6                 ;1478
000034  4629              MOV      r1,r5                 ;1478
000036  4620              MOV      r0,r4                 ;1478
000038  f7fffffe          BL       UART_Start_Receive_DMA
00003c  e7eb              B        |L34.22|
                  |L34.62|
00003e  2002              MOVS     r0,#2                 ;1482
000040  e7e9              B        |L34.22|
;;;1485   
                          ENDP


                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;1358     */
;;;1359   HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1360   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1361     /* Check that a Rx process is not already ongoing */
;;;1362     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003e          LDRB     r0,[r4,#0x3e]
00000c  2820              CMP      r0,#0x20
00000e  d116              BNE      |L35.62|
;;;1363     {
;;;1364       if ((pData == NULL) || (Size == 0U))
000010  b105              CBZ      r5,|L35.20|
000012  b90e              CBNZ     r6,|L35.24|
                  |L35.20|
;;;1365       {
;;;1366         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L35.22|
;;;1367       }
;;;1368   
;;;1369       /* Process Locked */
;;;1370       __HAL_LOCK(huart);
;;;1371   
;;;1372       /* Set Reception type to Standard reception */
;;;1373       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1374   
;;;1375       return (UART_Start_Receive_IT(huart, pData, Size));
;;;1376     }
;;;1377     else
;;;1378     {
;;;1379       return HAL_BUSY;
;;;1380     }
;;;1381   }
000016  bd70              POP      {r4-r6,pc}
                  |L35.24|
000018  bf00              NOP                            ;1370
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1370
00001e  2801              CMP      r0,#1                 ;1370
000020  d101              BNE      |L35.38|
000022  2002              MOVS     r0,#2                 ;1370
000024  e7f7              B        |L35.22|
                  |L35.38|
000026  2001              MOVS     r0,#1                 ;1370
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1370
00002c  bf00              NOP                            ;1370
00002e  2000              MOVS     r0,#0                 ;1373
000030  6320              STR      r0,[r4,#0x30]         ;1373
000032  4632              MOV      r2,r6                 ;1375
000034  4629              MOV      r1,r5                 ;1375
000036  4620              MOV      r0,r4                 ;1375
000038  f7fffffe          BL       UART_Start_Receive_IT
00003c  e7eb              B        |L35.22|
                  |L35.62|
00003e  2002              MOVS     r0,#2                 ;1379
000040  e7e9              B        |L35.22|
;;;1382   
                          ENDP


                          AREA ||i.HAL_UART_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RegisterCallback PROC
;;;752      */
;;;753    HAL_StatusTypeDef HAL_UART_RegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID,
000000  b510              PUSH     {r4,lr}
;;;754                                                pUART_CallbackTypeDef pCallback)
;;;755    {
000002  4603              MOV      r3,r0
;;;756      HAL_StatusTypeDef status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;757    
;;;758      if (pCallback == NULL)
000006  b92a              CBNZ     r2,|L36.20|
;;;759      {
;;;760        /* Update the error code */
;;;761        huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
000008  6c18              LDR      r0,[r3,#0x40]
00000a  f0400020          ORR      r0,r0,#0x20
00000e  6418              STR      r0,[r3,#0x40]
;;;762    
;;;763        return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L36.18|
;;;764      }
;;;765      /* Process locked */
;;;766      __HAL_LOCK(huart);
;;;767    
;;;768      if (huart->gState == HAL_UART_STATE_READY)
;;;769      {
;;;770        switch (CallbackID)
;;;771        {
;;;772          case HAL_UART_TX_HALFCOMPLETE_CB_ID :
;;;773            huart->TxHalfCpltCallback = pCallback;
;;;774            break;
;;;775    
;;;776          case HAL_UART_TX_COMPLETE_CB_ID :
;;;777            huart->TxCpltCallback = pCallback;
;;;778            break;
;;;779    
;;;780          case HAL_UART_RX_HALFCOMPLETE_CB_ID :
;;;781            huart->RxHalfCpltCallback = pCallback;
;;;782            break;
;;;783    
;;;784          case HAL_UART_RX_COMPLETE_CB_ID :
;;;785            huart->RxCpltCallback = pCallback;
;;;786            break;
;;;787    
;;;788          case HAL_UART_ERROR_CB_ID :
;;;789            huart->ErrorCallback = pCallback;
;;;790            break;
;;;791    
;;;792          case HAL_UART_ABORT_COMPLETE_CB_ID :
;;;793            huart->AbortCpltCallback = pCallback;
;;;794            break;
;;;795    
;;;796          case HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID :
;;;797            huart->AbortTransmitCpltCallback = pCallback;
;;;798            break;
;;;799    
;;;800          case HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID :
;;;801            huart->AbortReceiveCpltCallback = pCallback;
;;;802            break;
;;;803    
;;;804          case HAL_UART_MSPINIT_CB_ID :
;;;805            huart->MspInitCallback = pCallback;
;;;806            break;
;;;807    
;;;808          case HAL_UART_MSPDEINIT_CB_ID :
;;;809            huart->MspDeInitCallback = pCallback;
;;;810            break;
;;;811    
;;;812          default :
;;;813            /* Update the error code */
;;;814            huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
;;;815    
;;;816            /* Return error status */
;;;817            status =  HAL_ERROR;
;;;818            break;
;;;819        }
;;;820      }
;;;821      else if (huart->gState == HAL_UART_STATE_RESET)
;;;822      {
;;;823        switch (CallbackID)
;;;824        {
;;;825          case HAL_UART_MSPINIT_CB_ID :
;;;826            huart->MspInitCallback = pCallback;
;;;827            break;
;;;828    
;;;829          case HAL_UART_MSPDEINIT_CB_ID :
;;;830            huart->MspDeInitCallback = pCallback;
;;;831            break;
;;;832    
;;;833          default :
;;;834            /* Update the error code */
;;;835            huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
;;;836    
;;;837            /* Return error status */
;;;838            status =  HAL_ERROR;
;;;839            break;
;;;840        }
;;;841      }
;;;842      else
;;;843      {
;;;844        /* Update the error code */
;;;845        huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
;;;846    
;;;847        /* Return error status */
;;;848        status =  HAL_ERROR;
;;;849      }
;;;850    
;;;851      /* Release Lock */
;;;852      __HAL_UNLOCK(huart);
;;;853    
;;;854      return status;
;;;855    }
000012  bd10              POP      {r4,pc}
                  |L36.20|
000014  bf00              NOP                            ;766
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;766
00001a  2801              CMP      r0,#1                 ;766
00001c  d101              BNE      |L36.34|
00001e  2002              MOVS     r0,#2                 ;766
000020  e7f7              B        |L36.18|
                  |L36.34|
000022  2001              MOVS     r0,#1                 ;766
000024  f883003c          STRB     r0,[r3,#0x3c]         ;766
000028  bf00              NOP                            ;766
00002a  f893003d          LDRB     r0,[r3,#0x3d]         ;768
00002e  2820              CMP      r0,#0x20              ;768
000030  d125              BNE      |L36.126|
000032  290d              CMP      r1,#0xd               ;770
000034  d21c              BCS      |L36.112|
000036  e8dff001          TBB      [pc,r1]               ;770
00003a  0709              DCB      0x07,0x09
00003c  0b0d0f11          DCB      0x0b,0x0d,0x0f,0x11
000040  13151b1b          DCB      0x13,0x15,0x1b,0x1b
000044  1b171900          DCB      0x1b,0x17,0x19,0x00
000048  645a              STR      r2,[r3,#0x44]         ;773
00004a  e017              B        |L36.124|
00004c  649a              STR      r2,[r3,#0x48]         ;777
00004e  e015              B        |L36.124|
000050  64da              STR      r2,[r3,#0x4c]         ;781
000052  e013              B        |L36.124|
000054  651a              STR      r2,[r3,#0x50]         ;785
000056  e011              B        |L36.124|
000058  655a              STR      r2,[r3,#0x54]         ;789
00005a  e00f              B        |L36.124|
00005c  659a              STR      r2,[r3,#0x58]         ;793
00005e  e00d              B        |L36.124|
000060  65da              STR      r2,[r3,#0x5c]         ;797
000062  e00b              B        |L36.124|
000064  661a              STR      r2,[r3,#0x60]         ;801
000066  e009              B        |L36.124|
000068  66da              STR      r2,[r3,#0x6c]         ;805
00006a  e007              B        |L36.124|
00006c  671a              STR      r2,[r3,#0x70]         ;809
00006e  e005              B        |L36.124|
                  |L36.112|
000070  6c18              LDR      r0,[r3,#0x40]         ;814
000072  f0400020          ORR      r0,r0,#0x20           ;814
000076  6418              STR      r0,[r3,#0x40]         ;814
000078  2401              MOVS     r4,#1                 ;817
00007a  bf00              NOP                            ;818
                  |L36.124|
00007c  e017              B        |L36.174|
                  |L36.126|
00007e  f893003d          LDRB     r0,[r3,#0x3d]         ;821
000082  b978              CBNZ     r0,|L36.164|
000084  290b              CMP      r1,#0xb               ;823
000086  d002              BEQ      |L36.142|
000088  290c              CMP      r1,#0xc               ;823
00008a  d104              BNE      |L36.150|
00008c  e001              B        |L36.146|
                  |L36.142|
00008e  66da              STR      r2,[r3,#0x6c]         ;826
000090  e007              B        |L36.162|
                  |L36.146|
000092  671a              STR      r2,[r3,#0x70]         ;830
000094  e005              B        |L36.162|
                  |L36.150|
000096  6c18              LDR      r0,[r3,#0x40]         ;835
000098  f0400020          ORR      r0,r0,#0x20           ;835
00009c  6418              STR      r0,[r3,#0x40]         ;835
00009e  2401              MOVS     r4,#1                 ;838
0000a0  bf00              NOP                            ;839
                  |L36.162|
0000a2  e004              B        |L36.174|
                  |L36.164|
0000a4  6c18              LDR      r0,[r3,#0x40]         ;845
0000a6  f0400020          ORR      r0,r0,#0x20           ;845
0000aa  6418              STR      r0,[r3,#0x40]         ;845
0000ac  2401              MOVS     r4,#1                 ;848
                  |L36.174|
0000ae  bf00              NOP                            ;852
0000b0  2000              MOVS     r0,#0                 ;852
0000b2  f883003c          STRB     r0,[r3,#0x3c]         ;852
0000b6  bf00              NOP                            ;852
0000b8  4620              MOV      r0,r4                 ;854
0000ba  e7aa              B        |L36.18|
;;;856    
                          ENDP


                          AREA ||i.HAL_UART_RegisterRxEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RegisterRxEventCallback PROC
;;;977      */
;;;978    HAL_StatusTypeDef HAL_UART_RegisterRxEventCallback(UART_HandleTypeDef *huart, pUART_RxEventCallbackTypeDef pCallback)
000000  4602              MOV      r2,r0
;;;979    {
;;;980      HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;981    
;;;982      if (pCallback == NULL)
000004  b929              CBNZ     r1,|L37.18|
;;;983      {
;;;984        huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
000006  6c10              LDR      r0,[r2,#0x40]
000008  f0400020          ORR      r0,r0,#0x20
00000c  6410              STR      r0,[r2,#0x40]
;;;985    
;;;986        return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L37.16|
;;;987      }
;;;988    
;;;989      /* Process locked */
;;;990      __HAL_LOCK(huart);
;;;991    
;;;992      if (huart->gState == HAL_UART_STATE_READY)
;;;993      {
;;;994        huart->RxEventCallback = pCallback;
;;;995      }
;;;996      else
;;;997      {
;;;998        huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
;;;999    
;;;1000       status =  HAL_ERROR;
;;;1001     }
;;;1002   
;;;1003     /* Release Lock */
;;;1004     __HAL_UNLOCK(huart);
;;;1005   
;;;1006     return status;
;;;1007   }
000010  4770              BX       lr
                  |L37.18|
000012  bf00              NOP                            ;990
000014  f892003c          LDRB     r0,[r2,#0x3c]         ;990
000018  2801              CMP      r0,#1                 ;990
00001a  d101              BNE      |L37.32|
00001c  2002              MOVS     r0,#2                 ;990
00001e  e7f7              B        |L37.16|
                  |L37.32|
000020  2001              MOVS     r0,#1                 ;990
000022  f882003c          STRB     r0,[r2,#0x3c]         ;990
000026  bf00              NOP                            ;990
000028  f892003d          LDRB     r0,[r2,#0x3d]         ;992
00002c  2820              CMP      r0,#0x20              ;992
00002e  d101              BNE      |L37.52|
000030  6691              STR      r1,[r2,#0x68]         ;994
000032  e004              B        |L37.62|
                  |L37.52|
000034  6c10              LDR      r0,[r2,#0x40]         ;998
000036  f0400020          ORR      r0,r0,#0x20           ;998
00003a  6410              STR      r0,[r2,#0x40]         ;998
00003c  2301              MOVS     r3,#1                 ;1000
                  |L37.62|
00003e  bf00              NOP                            ;1004
000040  2000              MOVS     r0,#0                 ;1004
000042  f882003c          STRB     r0,[r2,#0x3c]         ;1004
000046  bf00              NOP                            ;1004
000048  4618              MOV      r0,r3                 ;1006
00004a  e7e1              B        |L37.16|
;;;1008   
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;2617     */
;;;2618   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2619   {
;;;2620     /* Prevent unused argument(s) compilation warning */
;;;2621     UNUSED(huart);
;;;2622     /* NOTE: This function should not be modified, when the callback is needed,
;;;2623              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;2624      */
;;;2625   }
;;;2626   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;2632     */
;;;2633   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2634   {
;;;2635     /* Prevent unused argument(s) compilation warning */
;;;2636     UNUSED(huart);
;;;2637     /* NOTE: This function should not be modified, when the callback is needed,
;;;2638              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;2639      */
;;;2640   }
;;;2641   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;1134     */
;;;1135   HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1136   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;1137     uint8_t  *pdata8bits;
;;;1138     uint16_t *pdata16bits;
;;;1139     uint32_t tickstart = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;1140   
;;;1141     /* Check that a Tx process is not already ongoing */
;;;1142     if (huart->gState == HAL_UART_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d15a              BNE      |L40.206|
;;;1143     {
;;;1144       if ((pData == NULL) || (Size == 0U))
000018  b106              CBZ      r6,|L40.28|
00001a  b917              CBNZ     r7,|L40.34|
                  |L40.28|
;;;1145       {
;;;1146         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L40.30|
;;;1147       }
;;;1148   
;;;1149       /* Process Locked */
;;;1150       __HAL_LOCK(huart);
;;;1151   
;;;1152       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1153       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1154   
;;;1155       /* Init tickstart for timeout management */
;;;1156       tickstart = HAL_GetTick();
;;;1157   
;;;1158       huart->TxXferSize = Size;
;;;1159       huart->TxXferCount = Size;
;;;1160   
;;;1161       /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
;;;1162       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1163       {
;;;1164         pdata8bits  = NULL;
;;;1165         pdata16bits = (uint16_t *) pData;
;;;1166       }
;;;1167       else
;;;1168       {
;;;1169         pdata8bits  = pData;
;;;1170         pdata16bits = NULL;
;;;1171       }
;;;1172   
;;;1173       /* Process Unlocked */
;;;1174       __HAL_UNLOCK(huart);
;;;1175   
;;;1176       while (huart->TxXferCount > 0U)
;;;1177       {
;;;1178         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1179         {
;;;1180           return HAL_TIMEOUT;
;;;1181         }
;;;1182         if (pdata8bits == NULL)
;;;1183         {
;;;1184           huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
;;;1185           pdata16bits++;
;;;1186         }
;;;1187         else
;;;1188         {
;;;1189           huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
;;;1190           pdata8bits++;
;;;1191         }
;;;1192         huart->TxXferCount--;
;;;1193       }
;;;1194   
;;;1195       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;1196       {
;;;1197         return HAL_TIMEOUT;
;;;1198       }
;;;1199   
;;;1200       /* At end of Tx process, restore huart->gState to Ready */
;;;1201       huart->gState = HAL_UART_STATE_READY;
;;;1202   
;;;1203       return HAL_OK;
;;;1204     }
;;;1205     else
;;;1206     {
;;;1207       return HAL_BUSY;
;;;1208     }
;;;1209   }
00001e  e8bd8ff8          POP      {r3-r11,pc}
                  |L40.34|
000022  bf00              NOP                            ;1150
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;1150
000028  2801              CMP      r0,#1                 ;1150
00002a  d101              BNE      |L40.48|
00002c  2002              MOVS     r0,#2                 ;1150
00002e  e7f6              B        |L40.30|
                  |L40.48|
000030  2001              MOVS     r0,#1                 ;1150
000032  f884003c          STRB     r0,[r4,#0x3c]         ;1150
000036  bf00              NOP                            ;1150
000038  2000              MOVS     r0,#0                 ;1152
00003a  6420              STR      r0,[r4,#0x40]         ;1152
00003c  2021              MOVS     r0,#0x21              ;1153
00003e  f884003d          STRB     r0,[r4,#0x3d]         ;1153
000042  f7fffffe          BL       HAL_GetTick
000046  4682              MOV      r10,r0                ;1156
000048  84a7              STRH     r7,[r4,#0x24]         ;1158
00004a  84e7              STRH     r7,[r4,#0x26]         ;1159
00004c  68a0              LDR      r0,[r4,#8]            ;1162
00004e  f5b05f80          CMP      r0,#0x1000            ;1162
000052  d104              BNE      |L40.94|
000054  6920              LDR      r0,[r4,#0x10]         ;1162
000056  b910              CBNZ     r0,|L40.94|
000058  2500              MOVS     r5,#0                 ;1164
00005a  46b0              MOV      r8,r6                 ;1165
00005c  e002              B        |L40.100|
                  |L40.94|
00005e  4635              MOV      r5,r6                 ;1169
000060  f04f0800          MOV      r8,#0                 ;1170
                  |L40.100|
000064  bf00              NOP                            ;1174
000066  2000              MOVS     r0,#0                 ;1174
000068  f884003c          STRB     r0,[r4,#0x3c]         ;1174
00006c  bf00              NOP                            ;1174
00006e  e01b              B        |L40.168|
                  |L40.112|
000070  4653              MOV      r3,r10                ;1178
000072  2200              MOVS     r2,#0                 ;1178
000074  2180              MOVS     r1,#0x80              ;1178
000076  4620              MOV      r0,r4                 ;1178
000078  f8cd9000          STR      r9,[sp,#0]            ;1178
00007c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000080  b108              CBZ      r0,|L40.134|
000082  2003              MOVS     r0,#3                 ;1180
000084  e7cb              B        |L40.30|
                  |L40.134|
000086  b945              CBNZ     r5,|L40.154|
000088  f8b80000          LDRH     r0,[r8,#0]            ;1184
00008c  f3c00008          UBFX     r0,r0,#0,#9           ;1184
000090  6821              LDR      r1,[r4,#0]            ;1184
000092  6048              STR      r0,[r1,#4]            ;1184
000094  f1080802          ADD      r8,r8,#2              ;1185
000098  e003              B        |L40.162|
                  |L40.154|
00009a  7828              LDRB     r0,[r5,#0]            ;1189
00009c  6821              LDR      r1,[r4,#0]            ;1189
00009e  6048              STR      r0,[r1,#4]            ;1189
0000a0  1c6d              ADDS     r5,r5,#1              ;1190
                  |L40.162|
0000a2  8ce0              LDRH     r0,[r4,#0x26]         ;1192
0000a4  1e40              SUBS     r0,r0,#1              ;1192
0000a6  84e0              STRH     r0,[r4,#0x26]         ;1192
                  |L40.168|
0000a8  8ce0              LDRH     r0,[r4,#0x26]         ;1176
0000aa  2800              CMP      r0,#0                 ;1176
0000ac  d1e0              BNE      |L40.112|
0000ae  4653              MOV      r3,r10                ;1195
0000b0  2200              MOVS     r2,#0                 ;1195
0000b2  2140              MOVS     r1,#0x40              ;1195
0000b4  4620              MOV      r0,r4                 ;1195
0000b6  f8cd9000          STR      r9,[sp,#0]            ;1195
0000ba  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000be  b108              CBZ      r0,|L40.196|
0000c0  2003              MOVS     r0,#3                 ;1197
0000c2  e7ac              B        |L40.30|
                  |L40.196|
0000c4  2020              MOVS     r0,#0x20              ;1201
0000c6  f884003d          STRB     r0,[r4,#0x3d]         ;1201
0000ca  2000              MOVS     r0,#0                 ;1203
0000cc  e7a7              B        |L40.30|
                  |L40.206|
0000ce  2002              MOVS     r0,#2                 ;1207
0000d0  e7a5              B        |L40.30|
;;;1210   
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;1393     */
;;;1394   HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1395   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1396     uint32_t *tmp;
;;;1397   
;;;1398     /* Check that a Tx process is not already ongoing */
;;;1399     if (huart->gState == HAL_UART_STATE_READY)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2820              CMP      r0,#0x20
00000c  d146              BNE      |L41.156|
;;;1400     {
;;;1401       if ((pData == NULL) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  b100              CBZ      r0,|L41.20|
000012  b90d              CBNZ     r5,|L41.24|
                  |L41.20|
;;;1402       {
;;;1403         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L41.22|
;;;1404       }
;;;1405   
;;;1406       /* Process Locked */
;;;1407       __HAL_LOCK(huart);
;;;1408   
;;;1409       huart->pTxBuffPtr = pData;
;;;1410       huart->TxXferSize = Size;
;;;1411       huart->TxXferCount = Size;
;;;1412   
;;;1413       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1414       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1415   
;;;1416       /* Set the UART DMA transfer complete callback */
;;;1417       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1418   
;;;1419       /* Set the UART DMA Half transfer complete callback */
;;;1420       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1421   
;;;1422       /* Set the DMA error callback */
;;;1423       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1424   
;;;1425       /* Set the DMA abort callback */
;;;1426       huart->hdmatx->XferAbortCallback = NULL;
;;;1427   
;;;1428       /* Enable the UART transmit DMA stream */
;;;1429       tmp = (uint32_t *)&pData;
;;;1430       HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;1431   
;;;1432       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1433       __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;1434   
;;;1435       /* Process Unlocked */
;;;1436       __HAL_UNLOCK(huart);
;;;1437   
;;;1438       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1439          in the UART CR3 register */
;;;1440       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1441   
;;;1442       return HAL_OK;
;;;1443     }
;;;1444     else
;;;1445     {
;;;1446       return HAL_BUSY;
;;;1447     }
;;;1448   }
000016  bdfe              POP      {r1-r7,pc}
                  |L41.24|
000018  bf00              NOP                            ;1407
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;1407
00001e  2801              CMP      r0,#1                 ;1407
000020  d101              BNE      |L41.38|
000022  2002              MOVS     r0,#2                 ;1407
000024  e7f7              B        |L41.22|
                  |L41.38|
000026  2001              MOVS     r0,#1                 ;1407
000028  f884003c          STRB     r0,[r4,#0x3c]         ;1407
00002c  bf00              NOP                            ;1407
00002e  9801              LDR      r0,[sp,#4]            ;1409
000030  6220              STR      r0,[r4,#0x20]         ;1409
000032  84a5              STRH     r5,[r4,#0x24]         ;1410
000034  84e5              STRH     r5,[r4,#0x26]         ;1411
000036  2000              MOVS     r0,#0                 ;1413
000038  6420              STR      r0,[r4,#0x40]         ;1413
00003a  2021              MOVS     r0,#0x21              ;1414
00003c  f884003d          STRB     r0,[r4,#0x3d]         ;1414
000040  4817              LDR      r0,|L41.160|
000042  6b61              LDR      r1,[r4,#0x34]         ;1417
000044  63c8              STR      r0,[r1,#0x3c]         ;1417
000046  4817              LDR      r0,|L41.164|
000048  6b61              LDR      r1,[r4,#0x34]         ;1420
00004a  6408              STR      r0,[r1,#0x40]         ;1420
00004c  4816              LDR      r0,|L41.168|
00004e  6b61              LDR      r1,[r4,#0x34]         ;1423
000050  64c8              STR      r0,[r1,#0x4c]         ;1423
000052  2000              MOVS     r0,#0                 ;1426
000054  6b61              LDR      r1,[r4,#0x34]         ;1426
000056  6508              STR      r0,[r1,#0x50]         ;1426
000058  ae01              ADD      r6,sp,#4              ;1429
00005a  6823              LDR      r3,[r4,#0]            ;1430
00005c  1d1a              ADDS     r2,r3,#4              ;1430
00005e  6831              LDR      r1,[r6,#0]            ;1430
000060  462b              MOV      r3,r5                 ;1430
000062  6b60              LDR      r0,[r4,#0x34]         ;1430
000064  f7fffffe          BL       HAL_DMA_Start_IT
000068  f06f0040          MVN      r0,#0x40              ;1433
00006c  6821              LDR      r1,[r4,#0]            ;1433
00006e  6008              STR      r0,[r1,#0]            ;1433
000070  bf00              NOP                            ;1436
000072  2000              MOVS     r0,#0                 ;1436
000074  f884003c          STRB     r0,[r4,#0x3c]         ;1436
000078  bf00              NOP                            ;1436
00007a  bf00              NOP                            ;1440
00007c  bf00              NOP                            ;1440
                  |L41.126|
00007e  6821              LDR      r1,[r4,#0]            ;1440
000080  3114              ADDS     r1,r1,#0x14           ;1440
000082  e8511f00          LDREX    r1,[r1,#0]            ;1440
000086  f0410080          ORR      r0,r1,#0x80           ;1440
00008a  6821              LDR      r1,[r4,#0]            ;1440
00008c  3114              ADDS     r1,r1,#0x14           ;1440
00008e  e8410200          STREX    r2,r0,[r1,#0]         ;1440
000092  2a00              CMP      r2,#0                 ;1440
000094  d1f3              BNE      |L41.126|
000096  bf00              NOP                            ;1440
000098  2000              MOVS     r0,#0                 ;1442
00009a  e7bc              B        |L41.22|
                  |L41.156|
00009c  2002              MOVS     r0,#2                 ;1446
00009e  e7ba              B        |L41.22|
;;;1449   
                          ENDP

                  |L41.160|
                          DCD      UART_DMATransmitCplt
                  |L41.164|
                          DCD      UART_DMATxHalfCplt
                  |L41.168|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;1313     */
;;;1314   HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1315   {
000002  4603              MOV      r3,r0
;;;1316     /* Check that a Tx process is not already ongoing */
;;;1317     if (huart->gState == HAL_UART_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2820              CMP      r0,#0x20
00000a  d123              BNE      |L42.84|
;;;1318     {
;;;1319       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L42.16|
00000e  b90a              CBNZ     r2,|L42.20|
                  |L42.16|
;;;1320       {
;;;1321         return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L42.18|
;;;1322       }
;;;1323   
;;;1324       /* Process Locked */
;;;1325       __HAL_LOCK(huart);
;;;1326   
;;;1327       huart->pTxBuffPtr = pData;
;;;1328       huart->TxXferSize = Size;
;;;1329       huart->TxXferCount = Size;
;;;1330   
;;;1331       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1332       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1333   
;;;1334       /* Process Unlocked */
;;;1335       __HAL_UNLOCK(huart);
;;;1336   
;;;1337       /* Enable the UART Transmit data register empty Interrupt */
;;;1338       __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;1339   
;;;1340       return HAL_OK;
;;;1341     }
;;;1342     else
;;;1343     {
;;;1344       return HAL_BUSY;
;;;1345     }
;;;1346   }
000012  bd10              POP      {r4,pc}
                  |L42.20|
000014  bf00              NOP                            ;1325
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;1325
00001a  2801              CMP      r0,#1                 ;1325
00001c  d101              BNE      |L42.34|
00001e  2002              MOVS     r0,#2                 ;1325
000020  e7f7              B        |L42.18|
                  |L42.34|
000022  2001              MOVS     r0,#1                 ;1325
000024  f883003c          STRB     r0,[r3,#0x3c]         ;1325
000028  bf00              NOP                            ;1325
00002a  6219              STR      r1,[r3,#0x20]         ;1327
00002c  849a              STRH     r2,[r3,#0x24]         ;1328
00002e  84da              STRH     r2,[r3,#0x26]         ;1329
000030  2000              MOVS     r0,#0                 ;1331
000032  6418              STR      r0,[r3,#0x40]         ;1331
000034  2021              MOVS     r0,#0x21              ;1332
000036  f883003d          STRB     r0,[r3,#0x3d]         ;1332
00003a  bf00              NOP                            ;1335
00003c  2000              MOVS     r0,#0                 ;1335
00003e  f883003c          STRB     r0,[r3,#0x3c]         ;1335
000042  bf00              NOP                            ;1335
000044  6818              LDR      r0,[r3,#0]            ;1338
000046  68c0              LDR      r0,[r0,#0xc]          ;1338
000048  f0400080          ORR      r0,r0,#0x80           ;1338
00004c  681c              LDR      r4,[r3,#0]            ;1338
00004e  60e0              STR      r0,[r4,#0xc]          ;1338
000050  2000              MOVS     r0,#0                 ;1340
000052  e7de              B        |L42.18|
                  |L42.84|
000054  2002              MOVS     r0,#2                 ;1344
000056  e7dc              B        |L42.18|
;;;1347   
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;2587     */
;;;2588   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2589   {
;;;2590     /* Prevent unused argument(s) compilation warning */
;;;2591     UNUSED(huart);
;;;2592     /* NOTE: This function should not be modified, when the callback is needed,
;;;2593              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;2594      */
;;;2595   }
;;;2596   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;2602     */
;;;2603   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2604   {
;;;2605     /* Prevent unused argument(s) compilation warning */
;;;2606     UNUSED(huart);
;;;2607     /* NOTE: This function should not be modified, when the callback is needed,
;;;2608              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;2609      */
;;;2610   }
;;;2611   
                          ENDP


                          AREA ||i.HAL_UART_UnRegisterCallback||, CODE, READONLY, ALIGN=2

                  HAL_UART_UnRegisterCallback PROC
;;;874      */
;;;875    HAL_StatusTypeDef HAL_UART_UnRegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID)
000000  4602              MOV      r2,r0
;;;876    {
;;;877      HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;878    
;;;879      /* Process locked */
;;;880      __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f892003c          LDRB     r0,[r2,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L45.18|
00000e  2002              MOVS     r0,#2
                  |L45.16|
;;;881    
;;;882      if (HAL_UART_STATE_READY == huart->gState)
;;;883      {
;;;884        switch (CallbackID)
;;;885        {
;;;886          case HAL_UART_TX_HALFCOMPLETE_CB_ID :
;;;887            huart->TxHalfCpltCallback = HAL_UART_TxHalfCpltCallback;               /* Legacy weak  TxHalfCpltCallback       */
;;;888            break;
;;;889    
;;;890          case HAL_UART_TX_COMPLETE_CB_ID :
;;;891            huart->TxCpltCallback = HAL_UART_TxCpltCallback;                       /* Legacy weak TxCpltCallback            */
;;;892            break;
;;;893    
;;;894          case HAL_UART_RX_HALFCOMPLETE_CB_ID :
;;;895            huart->RxHalfCpltCallback = HAL_UART_RxHalfCpltCallback;               /* Legacy weak RxHalfCpltCallback        */
;;;896            break;
;;;897    
;;;898          case HAL_UART_RX_COMPLETE_CB_ID :
;;;899            huart->RxCpltCallback = HAL_UART_RxCpltCallback;                       /* Legacy weak RxCpltCallback            */
;;;900            break;
;;;901    
;;;902          case HAL_UART_ERROR_CB_ID :
;;;903            huart->ErrorCallback = HAL_UART_ErrorCallback;                         /* Legacy weak ErrorCallback             */
;;;904            break;
;;;905    
;;;906          case HAL_UART_ABORT_COMPLETE_CB_ID :
;;;907            huart->AbortCpltCallback = HAL_UART_AbortCpltCallback;                 /* Legacy weak AbortCpltCallback         */
;;;908            break;
;;;909    
;;;910          case HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID :
;;;911            huart->AbortTransmitCpltCallback = HAL_UART_AbortTransmitCpltCallback; /* Legacy weak AbortTransmitCpltCallback */
;;;912            break;
;;;913    
;;;914          case HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID :
;;;915            huart->AbortReceiveCpltCallback = HAL_UART_AbortReceiveCpltCallback;   /* Legacy weak AbortReceiveCpltCallback  */
;;;916            break;
;;;917    
;;;918          case HAL_UART_MSPINIT_CB_ID :
;;;919            huart->MspInitCallback = HAL_UART_MspInit;                             /* Legacy weak MspInitCallback           */
;;;920            break;
;;;921    
;;;922          case HAL_UART_MSPDEINIT_CB_ID :
;;;923            huart->MspDeInitCallback = HAL_UART_MspDeInit;                         /* Legacy weak MspDeInitCallback         */
;;;924            break;
;;;925    
;;;926          default :
;;;927            /* Update the error code */
;;;928            huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
;;;929    
;;;930            /* Return error status */
;;;931            status =  HAL_ERROR;
;;;932            break;
;;;933        }
;;;934      }
;;;935      else if (HAL_UART_STATE_RESET == huart->gState)
;;;936      {
;;;937        switch (CallbackID)
;;;938        {
;;;939          case HAL_UART_MSPINIT_CB_ID :
;;;940            huart->MspInitCallback = HAL_UART_MspInit;
;;;941            break;
;;;942    
;;;943          case HAL_UART_MSPDEINIT_CB_ID :
;;;944            huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;945            break;
;;;946    
;;;947          default :
;;;948            /* Update the error code */
;;;949            huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
;;;950    
;;;951            /* Return error status */
;;;952            status =  HAL_ERROR;
;;;953            break;
;;;954        }
;;;955      }
;;;956      else
;;;957      {
;;;958        /* Update the error code */
;;;959        huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
;;;960    
;;;961        /* Return error status */
;;;962        status =  HAL_ERROR;
;;;963      }
;;;964    
;;;965      /* Release Lock */
;;;966      __HAL_UNLOCK(huart);
;;;967    
;;;968      return status;
;;;969    }
000010  4770              BX       lr
                  |L45.18|
000012  2001              MOVS     r0,#1                 ;880
000014  f882003c          STRB     r0,[r2,#0x3c]         ;880
000018  bf00              NOP                            ;880
00001a  f892003d          LDRB     r0,[r2,#0x3d]         ;882
00001e  2820              CMP      r0,#0x20              ;882
000020  d12f              BNE      |L45.130|
000022  290d              CMP      r1,#0xd               ;884
000024  d226              BCS      |L45.116|
000026  e8dff001          TBB      [pc,r1]               ;884
00002a  070a              DCB      0x07,0x0a
00002c  0d101316          DCB      0x0d,0x10,0x13,0x16
000030  191c2525          DCB      0x19,0x1c,0x25,0x25
000034  251f2200          DCB      0x25,0x1f,0x22,0x00
000038  4822              LDR      r0,|L45.196|
00003a  6450              STR      r0,[r2,#0x44]         ;887
00003c  e020              B        |L45.128|
00003e  4822              LDR      r0,|L45.200|
000040  6490              STR      r0,[r2,#0x48]         ;891
000042  e01d              B        |L45.128|
000044  4821              LDR      r0,|L45.204|
000046  64d0              STR      r0,[r2,#0x4c]         ;895
000048  e01a              B        |L45.128|
00004a  4821              LDR      r0,|L45.208|
00004c  6510              STR      r0,[r2,#0x50]         ;899
00004e  e017              B        |L45.128|
000050  4820              LDR      r0,|L45.212|
000052  6550              STR      r0,[r2,#0x54]         ;903
000054  e014              B        |L45.128|
000056  4820              LDR      r0,|L45.216|
000058  6590              STR      r0,[r2,#0x58]         ;907
00005a  e011              B        |L45.128|
00005c  481f              LDR      r0,|L45.220|
00005e  65d0              STR      r0,[r2,#0x5c]         ;911
000060  e00e              B        |L45.128|
000062  481f              LDR      r0,|L45.224|
000064  6610              STR      r0,[r2,#0x60]         ;915
000066  e00b              B        |L45.128|
000068  481e              LDR      r0,|L45.228|
00006a  66d0              STR      r0,[r2,#0x6c]         ;919
00006c  e008              B        |L45.128|
00006e  481e              LDR      r0,|L45.232|
000070  6710              STR      r0,[r2,#0x70]         ;923
000072  e005              B        |L45.128|
                  |L45.116|
000074  6c10              LDR      r0,[r2,#0x40]         ;928
000076  f0400020          ORR      r0,r0,#0x20           ;928
00007a  6410              STR      r0,[r2,#0x40]         ;928
00007c  2301              MOVS     r3,#1                 ;931
00007e  bf00              NOP                            ;932
                  |L45.128|
000080  e019              B        |L45.182|
                  |L45.130|
000082  f892003d          LDRB     r0,[r2,#0x3d]         ;935
000086  b988              CBNZ     r0,|L45.172|
000088  290b              CMP      r1,#0xb               ;937
00008a  d002              BEQ      |L45.146|
00008c  290c              CMP      r1,#0xc               ;937
00008e  d106              BNE      |L45.158|
000090  e002              B        |L45.152|
                  |L45.146|
000092  4814              LDR      r0,|L45.228|
000094  66d0              STR      r0,[r2,#0x6c]         ;940
000096  e008              B        |L45.170|
                  |L45.152|
000098  4813              LDR      r0,|L45.232|
00009a  6710              STR      r0,[r2,#0x70]         ;944
00009c  e005              B        |L45.170|
                  |L45.158|
00009e  6c10              LDR      r0,[r2,#0x40]         ;949
0000a0  f0400020          ORR      r0,r0,#0x20           ;949
0000a4  6410              STR      r0,[r2,#0x40]         ;949
0000a6  2301              MOVS     r3,#1                 ;952
0000a8  bf00              NOP                            ;953
                  |L45.170|
0000aa  e004              B        |L45.182|
                  |L45.172|
0000ac  6c10              LDR      r0,[r2,#0x40]         ;959
0000ae  f0400020          ORR      r0,r0,#0x20           ;959
0000b2  6410              STR      r0,[r2,#0x40]         ;959
0000b4  2301              MOVS     r3,#1                 ;962
                  |L45.182|
0000b6  bf00              NOP                            ;966
0000b8  2000              MOVS     r0,#0                 ;966
0000ba  f882003c          STRB     r0,[r2,#0x3c]         ;966
0000be  bf00              NOP                            ;966
0000c0  4618              MOV      r0,r3                 ;968
0000c2  e7a5              B        |L45.16|
;;;970    
                          ENDP

                  |L45.196|
                          DCD      HAL_UART_TxHalfCpltCallback
                  |L45.200|
                          DCD      HAL_UART_TxCpltCallback
                  |L45.204|
                          DCD      HAL_UART_RxHalfCpltCallback
                  |L45.208|
                          DCD      HAL_UART_RxCpltCallback
                  |L45.212|
                          DCD      HAL_UART_ErrorCallback
                  |L45.216|
                          DCD      HAL_UART_AbortCpltCallback
                  |L45.220|
                          DCD      HAL_UART_AbortTransmitCpltCallback
                  |L45.224|
                          DCD      HAL_UART_AbortReceiveCpltCallback
                  |L45.228|
                          DCD      HAL_UART_MspInit
                  |L45.232|
                          DCD      HAL_UART_MspDeInit

                          AREA ||i.HAL_UART_UnRegisterRxEventCallback||, CODE, READONLY, ALIGN=2

                  HAL_UART_UnRegisterRxEventCallback PROC
;;;1014     */
;;;1015   HAL_StatusTypeDef HAL_UART_UnRegisterRxEventCallback(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1016   {
;;;1017     HAL_StatusTypeDef status = HAL_OK;
000002  2200              MOVS     r2,#0
;;;1018   
;;;1019     /* Process locked */
;;;1020     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f891003c          LDRB     r0,[r1,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L46.18|
00000e  2002              MOVS     r0,#2
                  |L46.16|
;;;1021   
;;;1022     if (huart->gState == HAL_UART_STATE_READY)
;;;1023     {
;;;1024       huart->RxEventCallback = HAL_UARTEx_RxEventCallback; /* Legacy weak UART Rx Event Callback  */
;;;1025     }
;;;1026     else
;;;1027     {
;;;1028       huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
;;;1029   
;;;1030       status =  HAL_ERROR;
;;;1031     }
;;;1032   
;;;1033     /* Release Lock */
;;;1034     __HAL_UNLOCK(huart);
;;;1035     return status;
;;;1036   }
000010  4770              BX       lr
                  |L46.18|
000012  2001              MOVS     r0,#1                 ;1020
000014  f881003c          STRB     r0,[r1,#0x3c]         ;1020
000018  bf00              NOP                            ;1020
00001a  f891003d          LDRB     r0,[r1,#0x3d]         ;1022
00001e  2820              CMP      r0,#0x20              ;1022
000020  d102              BNE      |L46.40|
000022  4807              LDR      r0,|L46.64|
000024  6688              STR      r0,[r1,#0x68]         ;1024
000026  e004              B        |L46.50|
                  |L46.40|
000028  6c08              LDR      r0,[r1,#0x40]         ;1028
00002a  f0400020          ORR      r0,r0,#0x20           ;1028
00002e  6408              STR      r0,[r1,#0x40]         ;1028
000030  2201              MOVS     r2,#1                 ;1030
                  |L46.50|
000032  bf00              NOP                            ;1034
000034  2000              MOVS     r0,#0                 ;1034
000036  f881003c          STRB     r0,[r1,#0x3c]         ;1034
00003a  bf00              NOP                            ;1034
00003c  4610              MOV      r0,r2                 ;1035
00003e  e7e7              B        |L46.16|
;;;1037   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
                          ENDP

                  |L46.64|
                          DCD      HAL_UARTEx_RxEventCallback

                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;3330     */
;;;3331   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3332   {
000002  4605              MOV      r5,r0
;;;3333     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3334     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;3335     huart->TxXferCount = 0x00U;
00000a  84e0              STRH     r0,[r4,#0x26]
;;;3336   
;;;3337   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3338     /*Call registered error callback*/
;;;3339     huart->ErrorCallback(huart);
00000c  4620              MOV      r0,r4
00000e  6d61              LDR      r1,[r4,#0x54]
000010  4788              BLX      r1
;;;3340   #else
;;;3341     /*Call legacy weak error callback*/
;;;3342     HAL_UART_ErrorCallback(huart);
;;;3343   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3344   }
000012  bd70              POP      {r4-r6,pc}
;;;3345   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;3127     */
;;;3128   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3129   {
000002  4605              MOV      r5,r0
;;;3130     uint32_t dmarequest = 0x00U;
000004  2600              MOVS     r6,#0
;;;3131     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000006  6bac              LDR      r4,[r5,#0x38]
;;;3132   
;;;3133     /* Stop UART DMA Tx request if ongoing */
;;;3134     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000008  6820              LDR      r0,[r4,#0]
00000a  6940              LDR      r0,[r0,#0x14]
00000c  f3c016c0          UBFX     r6,r0,#7,#1
;;;3135     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2821              CMP      r0,#0x21
000016  d105              BNE      |L48.36|
000018  b126              CBZ      r6,|L48.36|
;;;3136     {
;;;3137       huart->TxXferCount = 0x00U;
00001a  2000              MOVS     r0,#0
00001c  84e0              STRH     r0,[r4,#0x26]
;;;3138       UART_EndTxTransfer(huart);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       UART_EndTxTransfer
                  |L48.36|
;;;3139     }
;;;3140   
;;;3141     /* Stop UART DMA Rx request if ongoing */
;;;3142     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000024  6820              LDR      r0,[r4,#0]
000026  6940              LDR      r0,[r0,#0x14]
000028  f3c01680          UBFX     r6,r0,#6,#1
;;;3143     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00002c  f894003e          LDRB     r0,[r4,#0x3e]
000030  2822              CMP      r0,#0x22
000032  d105              BNE      |L48.64|
000034  b126              CBZ      r6,|L48.64|
;;;3144     {
;;;3145       huart->RxXferCount = 0x00U;
000036  2000              MOVS     r0,#0
000038  85e0              STRH     r0,[r4,#0x2e]
;;;3146       UART_EndRxTransfer(huart);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       UART_EndRxTransfer
                  |L48.64|
;;;3147     }
;;;3148   
;;;3149     huart->ErrorCode |= HAL_UART_ERROR_DMA;
000040  6c20              LDR      r0,[r4,#0x40]
000042  f0400010          ORR      r0,r0,#0x10
000046  6420              STR      r0,[r4,#0x40]
;;;3150   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3151     /*Call registered error callback*/
;;;3152     huart->ErrorCallback(huart);
000048  4620              MOV      r0,r4
00004a  6d61              LDR      r1,[r4,#0x54]
00004c  4788              BLX      r1
;;;3153   #else
;;;3154     /*Call legacy weak error callback*/
;;;3155     HAL_UART_ErrorCallback(huart);
;;;3156   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3157   }
00004e  bd70              POP      {r4-r6,pc}
;;;3158   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;3035     */
;;;3036   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3037   {
000002  4605              MOV      r5,r0
;;;3038     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3039     /* DMA Normal mode*/
;;;3040     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  2800              CMP      r0,#0
000010  d142              BNE      |L49.152|
;;;3041     {
;;;3042       huart->RxXferCount = 0U;
000012  85e0              STRH     r0,[r4,#0x2e]
;;;3043   
;;;3044       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3045       ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  bf00              NOP      
000016  bf00              NOP      
                  |L49.24|
000018  6821              LDR      r1,[r4,#0]
00001a  310c              ADDS     r1,r1,#0xc
00001c  e8511f00          LDREX    r1,[r1,#0]
000020  f4217080          BIC      r0,r1,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  310c              ADDS     r1,r1,#0xc
000028  e8410200          STREX    r2,r0,[r1,#0]
00002c  2a00              CMP      r2,#0
00002e  d1f3              BNE      |L49.24|
000030  bf00              NOP      
;;;3046       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000032  bf00              NOP      
000034  bf00              NOP      
                  |L49.54|
000036  6821              LDR      r1,[r4,#0]
000038  3114              ADDS     r1,r1,#0x14
00003a  e8511f00          LDREX    r1,[r1,#0]
00003e  f0210001          BIC      r0,r1,#1
000042  6821              LDR      r1,[r4,#0]
000044  3114              ADDS     r1,r1,#0x14
000046  e8410200          STREX    r2,r0,[r1,#0]
00004a  2a00              CMP      r2,#0
00004c  d1f3              BNE      |L49.54|
00004e  bf00              NOP      
;;;3047   
;;;3048       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;3049          in the UART CR3 register */
;;;3050       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000050  bf00              NOP      
000052  bf00              NOP      
                  |L49.84|
000054  6821              LDR      r1,[r4,#0]
000056  3114              ADDS     r1,r1,#0x14
000058  e8511f00          LDREX    r1,[r1,#0]
00005c  f0210040          BIC      r0,r1,#0x40
000060  6821              LDR      r1,[r4,#0]
000062  3114              ADDS     r1,r1,#0x14
000064  e8410200          STREX    r2,r0,[r1,#0]
000068  2a00              CMP      r2,#0
00006a  d1f3              BNE      |L49.84|
00006c  bf00              NOP      
;;;3051   
;;;3052       /* At end of Rx process, restore huart->RxState to Ready */
;;;3053       huart->RxState = HAL_UART_STATE_READY;
00006e  2020              MOVS     r0,#0x20
000070  f884003e          STRB     r0,[r4,#0x3e]
;;;3054   
;;;3055       /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */
;;;3056       if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000074  6b20              LDR      r0,[r4,#0x30]
000076  2801              CMP      r0,#1
000078  d10e              BNE      |L49.152|
;;;3057       {
;;;3058         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
00007a  bf00              NOP      
00007c  bf00              NOP      
                  |L49.126|
00007e  6821              LDR      r1,[r4,#0]
000080  310c              ADDS     r1,r1,#0xc
000082  e8511f00          LDREX    r1,[r1,#0]
000086  f0210010          BIC      r0,r1,#0x10
00008a  6821              LDR      r1,[r4,#0]
00008c  310c              ADDS     r1,r1,#0xc
00008e  e8410200          STREX    r2,r0,[r1,#0]
000092  2a00              CMP      r2,#0
000094  d1f3              BNE      |L49.126|
000096  bf00              NOP      
                  |L49.152|
;;;3059       }
;;;3060     }
;;;3061   
;;;3062     /* Check current reception Mode :
;;;3063        If Reception till IDLE event has been selected : use Rx Event callback */
;;;3064     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000098  6b20              LDR      r0,[r4,#0x30]
00009a  2801              CMP      r0,#1
00009c  d104              BNE      |L49.168|
;;;3065     {
;;;3066   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3067       /*Call registered Rx Event callback*/
;;;3068       huart->RxEventCallback(huart, huart->RxXferSize);
00009e  8da1              LDRH     r1,[r4,#0x2c]
0000a0  4620              MOV      r0,r4
0000a2  6ea2              LDR      r2,[r4,#0x68]
0000a4  4790              BLX      r2
0000a6  e002              B        |L49.174|
                  |L49.168|
;;;3069   #else
;;;3070       /*Call legacy weak Rx Event callback*/
;;;3071       HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
;;;3072   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3073     }
;;;3074     else
;;;3075     {
;;;3076       /* In other cases : use Rx Complete callback */
;;;3077   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3078       /*Call registered Rx complete callback*/
;;;3079       huart->RxCpltCallback(huart);
0000a8  4620              MOV      r0,r4
0000aa  6d21              LDR      r1,[r4,#0x50]
0000ac  4788              BLX      r1
                  |L49.174|
;;;3080   #else
;;;3081       /*Call legacy weak Rx complete callback*/
;;;3082       HAL_UART_RxCpltCallback(huart);
;;;3083   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3084     }
;;;3085   }
0000ae  bd70              POP      {r4-r6,pc}
;;;3086   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;3400     */
;;;3401   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3402   {
000002  4605              MOV      r5,r0
;;;3403     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3404   
;;;3405     huart->hdmarx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  6508              STR      r0,[r1,#0x50]
;;;3406   
;;;3407     /* Check if an Abort process is still ongoing */
;;;3408     if (huart->hdmatx != NULL)
00000c  6b60              LDR      r0,[r4,#0x34]
00000e  b118              CBZ      r0,|L50.24|
;;;3409     {
;;;3410       if (huart->hdmatx->XferAbortCallback != NULL)
000010  6b60              LDR      r0,[r4,#0x34]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L50.24|
                  |L50.22|
;;;3411       {
;;;3412         return;
;;;3413       }
;;;3414     }
;;;3415   
;;;3416     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;3417     huart->TxXferCount = 0x00U;
;;;3418     huart->RxXferCount = 0x00U;
;;;3419   
;;;3420     /* Reset ErrorCode */
;;;3421     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;3422   
;;;3423     /* Restore huart->gState and huart->RxState to Ready */
;;;3424     huart->gState  = HAL_UART_STATE_READY;
;;;3425     huart->RxState = HAL_UART_STATE_READY;
;;;3426     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;3427   
;;;3428     /* Call user Abort complete callback */
;;;3429   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3430     /* Call registered Abort complete callback */
;;;3431     huart->AbortCpltCallback(huart);
;;;3432   #else
;;;3433     /* Call legacy weak Abort complete callback */
;;;3434     HAL_UART_AbortCpltCallback(huart);
;;;3435   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3436   }
000016  bd70              POP      {r4-r6,pc}
                  |L50.24|
000018  2000              MOVS     r0,#0                 ;3417
00001a  84e0              STRH     r0,[r4,#0x26]         ;3417
00001c  85e0              STRH     r0,[r4,#0x2e]         ;3418
00001e  6420              STR      r0,[r4,#0x40]         ;3421
000020  2020              MOVS     r0,#0x20              ;3424
000022  f884003d          STRB     r0,[r4,#0x3d]         ;3424
000026  f884003e          STRB     r0,[r4,#0x3e]         ;3425
00002a  2000              MOVS     r0,#0                 ;3426
00002c  6320              STR      r0,[r4,#0x30]         ;3426
00002e  4620              MOV      r0,r4                 ;3431
000030  6da1              LDR      r1,[r4,#0x58]         ;3431
000032  4788              BLX      r1                    ;3431
000034  bf00              NOP      
000036  e7ee              B        |L50.22|
;;;3437   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;3092     */
;;;3093   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3094   {
000002  4605              MOV      r5,r0
;;;3095     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3096   
;;;3097     /* Check current reception Mode :
;;;3098        If Reception till IDLE event has been selected : use Rx Event callback */
;;;3099     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000006  6b20              LDR      r0,[r4,#0x30]
000008  2801              CMP      r0,#1
00000a  d105              BNE      |L51.24|
;;;3100     {
;;;3101   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3102       /*Call registered Rx Event callback*/
;;;3103       huart->RxEventCallback(huart, huart->RxXferSize / 2U);
00000c  8da0              LDRH     r0,[r4,#0x2c]
00000e  0841              LSRS     r1,r0,#1
000010  4620              MOV      r0,r4
000012  6ea2              LDR      r2,[r4,#0x68]
000014  4790              BLX      r2
000016  e002              B        |L51.30|
                  |L51.24|
;;;3104   #else
;;;3105       /*Call legacy weak Rx Event callback*/
;;;3106       HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
;;;3107   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3108     }
;;;3109     else
;;;3110     {
;;;3111       /* In other cases : use Rx Half Complete callback */
;;;3112   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3113       /*Call registered Rx Half complete callback*/
;;;3114       huart->RxHalfCpltCallback(huart);
000018  4620              MOV      r0,r4
00001a  6ce1              LDR      r1,[r4,#0x4c]
00001c  4788              BLX      r1
                  |L51.30|
;;;3115   #else
;;;3116       /*Call legacy weak Rx Half complete callback*/
;;;3117       HAL_UART_RxHalfCpltCallback(huart);
;;;3118   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3119     }
;;;3120   }
00001e  bd70              POP      {r4-r6,pc}
;;;3121   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;3474     */
;;;3475   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3476   {
000002  4605              MOV      r5,r0
;;;3477     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3478   
;;;3479     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;3480   
;;;3481     /* Restore huart->RxState to Ready */
;;;3482     huart->RxState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f884003e          STRB     r0,[r4,#0x3e]
;;;3483     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000010  2000              MOVS     r0,#0
000012  6320              STR      r0,[r4,#0x30]
;;;3484   
;;;3485     /* Call user Abort complete callback */
;;;3486   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3487     /* Call registered Abort Receive Complete Callback */
;;;3488     huart->AbortReceiveCpltCallback(huart);
000014  4620              MOV      r0,r4
000016  6e21              LDR      r1,[r4,#0x60]
000018  4788              BLX      r1
;;;3489   #else
;;;3490     /* Call legacy weak Abort Receive Complete Callback */
;;;3491     HAL_UART_AbortReceiveCpltCallback(huart);
;;;3492   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3493   }
00001a  bd70              POP      {r4-r6,pc}
;;;3494   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2981     */
;;;2982   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2983   {
000002  4605              MOV      r5,r0
;;;2984     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2985     /* DMA Normal mode*/
;;;2986     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b9f8              CBNZ     r0,|L53.80|
;;;2987     {
;;;2988       huart->TxXferCount = 0x00U;
000010  2000              MOVS     r0,#0
000012  84e0              STRH     r0,[r4,#0x26]
;;;2989   
;;;2990       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2991          in the UART CR3 register */
;;;2992       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  bf00              NOP      
000016  bf00              NOP      
                  |L53.24|
000018  6821              LDR      r1,[r4,#0]
00001a  3114              ADDS     r1,r1,#0x14
00001c  e8511f00          LDREX    r1,[r1,#0]
000020  f0210080          BIC      r0,r1,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  3114              ADDS     r1,r1,#0x14
000028  e8410200          STREX    r2,r0,[r1,#0]
00002c  2a00              CMP      r2,#0
00002e  d1f3              BNE      |L53.24|
000030  bf00              NOP      
;;;2993   
;;;2994       /* Enable the UART Transmit Complete Interrupt */
;;;2995       ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000032  bf00              NOP      
000034  bf00              NOP      
                  |L53.54|
000036  6821              LDR      r1,[r4,#0]
000038  310c              ADDS     r1,r1,#0xc
00003a  e8511f00          LDREX    r1,[r1,#0]
00003e  f0410040          ORR      r0,r1,#0x40
000042  6821              LDR      r1,[r4,#0]
000044  310c              ADDS     r1,r1,#0xc
000046  e8410200          STREX    r2,r0,[r1,#0]
00004a  2a00              CMP      r2,#0
00004c  d1f3              BNE      |L53.54|
00004e  e002              B        |L53.86|
                  |L53.80|
;;;2996   
;;;2997     }
;;;2998     /* DMA Circular mode */
;;;2999     else
;;;3000     {
;;;3001   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3002       /*Call registered Tx complete callback*/
;;;3003       huart->TxCpltCallback(huart);
000050  4620              MOV      r0,r4
000052  6ca1              LDR      r1,[r4,#0x48]
000054  4788              BLX      r1
                  |L53.86|
;;;3004   #else
;;;3005       /*Call legacy weak Tx complete callback*/
;;;3006       HAL_UART_TxCpltCallback(huart);
;;;3007   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3008     }
;;;3009   }
000056  bd70              POP      {r4-r6,pc}
;;;3010   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;3354     */
;;;3355   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3356   {
000002  4605              MOV      r5,r0
;;;3357     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3358   
;;;3359     huart->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6b61              LDR      r1,[r4,#0x34]
00000a  6508              STR      r0,[r1,#0x50]
;;;3360   
;;;3361     /* Check if an Abort process is still ongoing */
;;;3362     if (huart->hdmarx != NULL)
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  b118              CBZ      r0,|L54.24|
;;;3363     {
;;;3364       if (huart->hdmarx->XferAbortCallback != NULL)
000010  6ba0              LDR      r0,[r4,#0x38]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L54.24|
                  |L54.22|
;;;3365       {
;;;3366         return;
;;;3367       }
;;;3368     }
;;;3369   
;;;3370     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;3371     huart->TxXferCount = 0x00U;
;;;3372     huart->RxXferCount = 0x00U;
;;;3373   
;;;3374     /* Reset ErrorCode */
;;;3375     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;3376   
;;;3377     /* Restore huart->gState and huart->RxState to Ready */
;;;3378     huart->gState  = HAL_UART_STATE_READY;
;;;3379     huart->RxState = HAL_UART_STATE_READY;
;;;3380     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;3381   
;;;3382     /* Call user Abort complete callback */
;;;3383   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3384     /* Call registered Abort complete callback */
;;;3385     huart->AbortCpltCallback(huart);
;;;3386   #else
;;;3387     /* Call legacy weak Abort complete callback */
;;;3388     HAL_UART_AbortCpltCallback(huart);
;;;3389   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3390   }
000016  bd70              POP      {r4-r6,pc}
                  |L54.24|
000018  2000              MOVS     r0,#0                 ;3371
00001a  84e0              STRH     r0,[r4,#0x26]         ;3371
00001c  85e0              STRH     r0,[r4,#0x2e]         ;3372
00001e  6420              STR      r0,[r4,#0x40]         ;3375
000020  2020              MOVS     r0,#0x20              ;3378
000022  f884003d          STRB     r0,[r4,#0x3d]         ;3378
000026  f884003e          STRB     r0,[r4,#0x3e]         ;3379
00002a  2000              MOVS     r0,#0                 ;3380
00002c  6320              STR      r0,[r4,#0x30]         ;3380
00002e  4620              MOV      r0,r4                 ;3385
000030  6da1              LDR      r1,[r4,#0x58]         ;3385
000032  4788              BLX      r1                    ;3385
000034  bf00              NOP      
000036  e7ee              B        |L54.22|
;;;3391   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;3016     */
;;;3017   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3018   {
000002  4604              MOV      r4,r0
;;;3019     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;3020   
;;;3021   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3022     /*Call registered Tx complete callback*/
;;;3023     huart->TxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  6c69              LDR      r1,[r5,#0x44]
00000a  4788              BLX      r1
;;;3024   #else
;;;3025     /*Call legacy weak Tx complete callback*/
;;;3026     HAL_UART_TxHalfCpltCallback(huart);
;;;3027   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3028   }
00000c  bd70              POP      {r4-r6,pc}
;;;3029   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;3446     */
;;;3447   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3448   {
000002  4605              MOV      r5,r0
;;;3449     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3450   
;;;3451     huart->TxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  84e0              STRH     r0,[r4,#0x26]
;;;3452   
;;;3453     /* Restore huart->gState to Ready */
;;;3454     huart->gState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f884003d          STRB     r0,[r4,#0x3d]
;;;3455   
;;;3456     /* Call user Abort complete callback */
;;;3457   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3458     /* Call registered Abort Transmit Complete Callback */
;;;3459     huart->AbortTransmitCpltCallback(huart);
000010  4620              MOV      r0,r4
000012  6de1              LDR      r1,[r4,#0x5c]
000014  4788              BLX      r1
;;;3460   #else
;;;3461     /* Call legacy weak Abort Transmit Complete Callback */
;;;3462     HAL_UART_AbortTransmitCpltCallback(huart);
;;;3463   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3464   }
000016  bd70              POP      {r4-r6,pc}
;;;3465   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;3306     */
;;;3307   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  bf00              NOP      
;;;3308   {
;;;3309     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3310     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  bf00              NOP      
                  |L57.4|
000004  6802              LDR      r2,[r0,#0]
000006  320c              ADDS     r2,r2,#0xc
000008  e8522f00          LDREX    r2,[r2,#0]
00000c  f4227190          BIC      r1,r2,#0x120
000010  6802              LDR      r2,[r0,#0]
000012  320c              ADDS     r2,r2,#0xc
000014  e8421300          STREX    r3,r1,[r2,#0]
000018  2b00              CMP      r3,#0
00001a  d1f3              BNE      |L57.4|
00001c  bf00              NOP      
;;;3311     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L57.34|
000022  6802              LDR      r2,[r0,#0]
000024  3214              ADDS     r2,r2,#0x14
000026  e8522f00          LDREX    r2,[r2,#0]
00002a  f0220101          BIC      r1,r2,#1
00002e  6802              LDR      r2,[r0,#0]
000030  3214              ADDS     r2,r2,#0x14
000032  e8421300          STREX    r3,r1,[r2,#0]
000036  2b00              CMP      r3,#0
000038  d1f3              BNE      |L57.34|
00003a  bf00              NOP      
;;;3312   
;;;3313     /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
;;;3314     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
00003c  6b01              LDR      r1,[r0,#0x30]
00003e  2901              CMP      r1,#1
000040  d10e              BNE      |L57.96|
;;;3315     {
;;;3316       ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
000042  bf00              NOP      
000044  bf00              NOP      
                  |L57.70|
000046  6802              LDR      r2,[r0,#0]
000048  320c              ADDS     r2,r2,#0xc
00004a  e8522f00          LDREX    r2,[r2,#0]
00004e  f0220110          BIC      r1,r2,#0x10
000052  6802              LDR      r2,[r0,#0]
000054  320c              ADDS     r2,r2,#0xc
000056  e8421300          STREX    r3,r1,[r2,#0]
00005a  2b00              CMP      r3,#0
00005c  d1f3              BNE      |L57.70|
00005e  bf00              NOP      
                  |L57.96|
;;;3317     }
;;;3318   
;;;3319     /* At end of Rx process, restore huart->RxState to Ready */
;;;3320     huart->RxState = HAL_UART_STATE_READY;
000060  2120              MOVS     r1,#0x20
000062  f880103e          STRB     r1,[r0,#0x3e]
;;;3321     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000066  2100              MOVS     r1,#0
000068  6301              STR      r1,[r0,#0x30]
;;;3322   }
00006a  4770              BX       lr
;;;3323   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;3540     */
;;;3541   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;3542   {
000002  4604              MOV      r4,r0
;;;3543     /* Disable the UART Transmit Complete Interrupt */
;;;3544     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;3545   
;;;3546     /* Tx process is ended, restore huart->gState to Ready */
;;;3547     huart->gState = HAL_UART_STATE_READY;
000010  2020              MOVS     r0,#0x20
000012  f884003d          STRB     r0,[r4,#0x3d]
;;;3548   
;;;3549   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3550     /*Call registered Tx complete callback*/
;;;3551     huart->TxCpltCallback(huart);
000016  4620              MOV      r0,r4
000018  6ca1              LDR      r1,[r4,#0x48]
00001a  4788              BLX      r1
;;;3552   #else
;;;3553     /*Call legacy weak Tx complete callback*/
;;;3554     HAL_UART_TxCpltCallback(huart);
;;;3555   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3556   
;;;3557     return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;3558   }
00001e  bd10              POP      {r4,pc}
;;;3559   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;3292     */
;;;3293   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  bf00              NOP      
;;;3294   {
;;;3295     /* Disable TXEIE and TCIE interrupts */
;;;3296     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  bf00              NOP      
                  |L59.4|
000004  6802              LDR      r2,[r0,#0]
000006  320c              ADDS     r2,r2,#0xc
000008  e8522f00          LDREX    r2,[r2,#0]
00000c  f02201c0          BIC      r1,r2,#0xc0
000010  6802              LDR      r2,[r0,#0]
000012  320c              ADDS     r2,r2,#0xc
000014  e8421300          STREX    r3,r1,[r2,#0]
000018  2b00              CMP      r3,#0
00001a  d1f3              BNE      |L59.4|
00001c  bf00              NOP      
;;;3297   
;;;3298     /* At end of Tx process, restore huart->gState to Ready */
;;;3299     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  f880103d          STRB     r1,[r0,#0x3d]
;;;3300   }
000024  4770              BX       lr
;;;3301   
                          ENDP


                          AREA ||i.UART_InitCallbacksToDefault||, CODE, READONLY, ALIGN=2

                  UART_InitCallbacksToDefault PROC
;;;2959   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2960   void UART_InitCallbacksToDefault(UART_HandleTypeDef *huart)
000000  4909              LDR      r1,|L60.40|
;;;2961   {
;;;2962     /* Init the UART Callback settings */
;;;2963     huart->TxHalfCpltCallback        = HAL_UART_TxHalfCpltCallback;        /* Legacy weak TxHalfCpltCallback        */
000002  6441              STR      r1,[r0,#0x44]
;;;2964     huart->TxCpltCallback            = HAL_UART_TxCpltCallback;            /* Legacy weak TxCpltCallback            */
000004  4909              LDR      r1,|L60.44|
000006  6481              STR      r1,[r0,#0x48]
;;;2965     huart->RxHalfCpltCallback        = HAL_UART_RxHalfCpltCallback;        /* Legacy weak RxHalfCpltCallback        */
000008  4909              LDR      r1,|L60.48|
00000a  64c1              STR      r1,[r0,#0x4c]
;;;2966     huart->RxCpltCallback            = HAL_UART_RxCpltCallback;            /* Legacy weak RxCpltCallback            */
00000c  4909              LDR      r1,|L60.52|
00000e  6501              STR      r1,[r0,#0x50]
;;;2967     huart->ErrorCallback             = HAL_UART_ErrorCallback;             /* Legacy weak ErrorCallback             */
000010  4909              LDR      r1,|L60.56|
000012  6541              STR      r1,[r0,#0x54]
;;;2968     huart->AbortCpltCallback         = HAL_UART_AbortCpltCallback;         /* Legacy weak AbortCpltCallback         */
000014  4909              LDR      r1,|L60.60|
000016  6581              STR      r1,[r0,#0x58]
;;;2969     huart->AbortTransmitCpltCallback = HAL_UART_AbortTransmitCpltCallback; /* Legacy weak AbortTransmitCpltCallback */
000018  4909              LDR      r1,|L60.64|
00001a  65c1              STR      r1,[r0,#0x5c]
;;;2970     huart->AbortReceiveCpltCallback  = HAL_UART_AbortReceiveCpltCallback;  /* Legacy weak AbortReceiveCpltCallback  */
00001c  4909              LDR      r1,|L60.68|
00001e  6601              STR      r1,[r0,#0x60]
;;;2971     huart->RxEventCallback           = HAL_UARTEx_RxEventCallback;         /* Legacy weak RxEventCallback           */
000020  4909              LDR      r1,|L60.72|
000022  6681              STR      r1,[r0,#0x68]
;;;2972   
;;;2973   }
000024  4770              BX       lr
;;;2974   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
                          ENDP

000026  0000              DCW      0x0000
                  |L60.40|
                          DCD      HAL_UART_TxHalfCpltCallback
                  |L60.44|
                          DCD      HAL_UART_TxCpltCallback
                  |L60.48|
                          DCD      HAL_UART_RxHalfCpltCallback
                  |L60.52|
                          DCD      HAL_UART_RxCpltCallback
                  |L60.56|
                          DCD      HAL_UART_ErrorCallback
                  |L60.60|
                          DCD      HAL_UART_AbortCpltCallback
                  |L60.64|
                          DCD      HAL_UART_AbortTransmitCpltCallback
                  |L60.68|
                          DCD      HAL_UART_AbortReceiveCpltCallback
                  |L60.72|
                          DCD      HAL_UARTEx_RxEventCallback

                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;3565     */
;;;3566   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3567   {
000002  4604              MOV      r4,r0
;;;3568     uint8_t  *pdata8bits;
;;;3569     uint16_t *pdata16bits;
;;;3570   
;;;3571     /* Check that a Rx process is ongoing */
;;;3572     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000004  f894003e          LDRB     r0,[r4,#0x3e]
000008  2822              CMP      r0,#0x22
00000a  d173              BNE      |L61.244|
;;;3573     {
;;;3574       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00000c  68a0              LDR      r0,[r4,#8]
00000e  f5b05f80          CMP      r0,#0x1000
000012  d10c              BNE      |L61.46|
000014  6920              LDR      r0,[r4,#0x10]
000016  b950              CBNZ     r0,|L61.46|
;;;3575       {
;;;3576         pdata8bits  = NULL;
000018  2500              MOVS     r5,#0
;;;3577         pdata16bits = (uint16_t *) huart->pRxBuffPtr;
00001a  6aa6              LDR      r6,[r4,#0x28]
;;;3578         *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f3c00008          UBFX     r0,r0,#0,#9
000024  8030              STRH     r0,[r6,#0]
;;;3579         huart->pRxBuffPtr += 2U;
000026  6aa0              LDR      r0,[r4,#0x28]
000028  1c80              ADDS     r0,r0,#2
00002a  62a0              STR      r0,[r4,#0x28]
00002c  e015              B        |L61.90|
                  |L61.46|
;;;3580       }
;;;3581       else
;;;3582       {
;;;3583         pdata8bits = (uint8_t *) huart->pRxBuffPtr;
00002e  6aa5              LDR      r5,[r4,#0x28]
;;;3584         pdata16bits  = NULL;
000030  2600              MOVS     r6,#0
;;;3585   
;;;3586         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
000032  68a0              LDR      r0,[r4,#8]
000034  f5b05f80          CMP      r0,#0x1000
000038  d003              BEQ      |L61.66|
00003a  68a0              LDR      r0,[r4,#8]
00003c  b928              CBNZ     r0,|L61.74|
00003e  6920              LDR      r0,[r4,#0x10]
000040  b918              CBNZ     r0,|L61.74|
                  |L61.66|
;;;3587         {
;;;3588           *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
000042  6820              LDR      r0,[r4,#0]
000044  6840              LDR      r0,[r0,#4]
000046  7028              STRB     r0,[r5,#0]
000048  e004              B        |L61.84|
                  |L61.74|
;;;3589         }
;;;3590         else
;;;3591         {
;;;3592           *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
00004a  6820              LDR      r0,[r4,#0]
00004c  6840              LDR      r0,[r0,#4]
00004e  f000007f          AND      r0,r0,#0x7f
000052  7028              STRB     r0,[r5,#0]
                  |L61.84|
;;;3593         }
;;;3594         huart->pRxBuffPtr += 1U;
000054  6aa0              LDR      r0,[r4,#0x28]
000056  1c40              ADDS     r0,r0,#1
000058  62a0              STR      r0,[r4,#0x28]
                  |L61.90|
;;;3595       }
;;;3596   
;;;3597       if (--huart->RxXferCount == 0U)
00005a  8de0              LDRH     r0,[r4,#0x2e]
00005c  1e40              SUBS     r0,r0,#1
00005e  b280              UXTH     r0,r0
000060  85e0              STRH     r0,[r4,#0x2e]
000062  2800              CMP      r0,#0
000064  d144              BNE      |L61.240|
;;;3598       {
;;;3599         /* Disable the UART Data Register not empty Interrupt */
;;;3600         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
000066  6820              LDR      r0,[r4,#0]
000068  68c0              LDR      r0,[r0,#0xc]
00006a  f0200020          BIC      r0,r0,#0x20
00006e  6821              LDR      r1,[r4,#0]
000070  60c8              STR      r0,[r1,#0xc]
;;;3601   
;;;3602         /* Disable the UART Parity Error Interrupt */
;;;3603         __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  f4207080          BIC      r0,r0,#0x100
00007a  6821              LDR      r1,[r4,#0]
00007c  60c8              STR      r0,[r1,#0xc]
;;;3604   
;;;3605         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3606         __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
00007e  6820              LDR      r0,[r4,#0]
000080  6940              LDR      r0,[r0,#0x14]
000082  f0200001          BIC      r0,r0,#1
000086  6821              LDR      r1,[r4,#0]
000088  6148              STR      r0,[r1,#0x14]
;;;3607   
;;;3608         /* Rx process is completed, restore huart->RxState to Ready */
;;;3609         huart->RxState = HAL_UART_STATE_READY;
00008a  2020              MOVS     r0,#0x20
00008c  f884003e          STRB     r0,[r4,#0x3e]
;;;3610   
;;;3611         /* Check current reception Mode :
;;;3612            If Reception till IDLE event has been selected : */
;;;3613         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000090  6b20              LDR      r0,[r4,#0x30]
000092  2801              CMP      r0,#1
000094  d126              BNE      |L61.228|
;;;3614         {
;;;3615           /* Set reception type to Standard */
;;;3616           huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000096  2000              MOVS     r0,#0
000098  6320              STR      r0,[r4,#0x30]
;;;3617   
;;;3618           /* Disable IDLE interrupt */
;;;3619           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
00009a  bf00              NOP      
00009c  bf00              NOP      
                  |L61.158|
00009e  6821              LDR      r1,[r4,#0]
0000a0  310c              ADDS     r1,r1,#0xc
0000a2  e8511f00          LDREX    r1,[r1,#0]
0000a6  f0210010          BIC      r0,r1,#0x10
0000aa  6821              LDR      r1,[r4,#0]
0000ac  310c              ADDS     r1,r1,#0xc
0000ae  e8410200          STREX    r2,r0,[r1,#0]
0000b2  2a00              CMP      r2,#0
0000b4  d1f3              BNE      |L61.158|
0000b6  bf00              NOP      
;;;3620   
;;;3621           /* Check if IDLE flag is set */
;;;3622           if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6800              LDR      r0,[r0,#0]
0000bc  f0000010          AND      r0,r0,#0x10
0000c0  2810              CMP      r0,#0x10
0000c2  d10a              BNE      |L61.218|
;;;3623           {
;;;3624             /* Clear IDLE flag in ISR */
;;;3625             __HAL_UART_CLEAR_IDLEFLAG(huart);
0000c4  bf00              NOP      
0000c6  2000              MOVS     r0,#0
0000c8  9000              STR      r0,[sp,#0]
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6800              LDR      r0,[r0,#0]
0000ce  9000              STR      r0,[sp,#0]
0000d0  6820              LDR      r0,[r4,#0]
0000d2  6840              LDR      r0,[r0,#4]
0000d4  9000              STR      r0,[sp,#0]
0000d6  bf00              NOP      
0000d8  bf00              NOP      
                  |L61.218|
;;;3626           }
;;;3627   
;;;3628   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3629           /*Call registered Rx Event callback*/
;;;3630           huart->RxEventCallback(huart, huart->RxXferSize);
0000da  8da1              LDRH     r1,[r4,#0x2c]
0000dc  4620              MOV      r0,r4
0000de  6ea2              LDR      r2,[r4,#0x68]
0000e0  4790              BLX      r2
0000e2  e002              B        |L61.234|
                  |L61.228|
;;;3631   #else
;;;3632           /*Call legacy weak Rx Event callback*/
;;;3633           HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
;;;3634   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3635         }
;;;3636         else
;;;3637         {
;;;3638           /* Standard reception API called */
;;;3639   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3640           /*Call registered Rx complete callback*/
;;;3641           huart->RxCpltCallback(huart);
0000e4  4620              MOV      r0,r4
0000e6  6d21              LDR      r1,[r4,#0x50]
0000e8  4788              BLX      r1
                  |L61.234|
;;;3642   #else
;;;3643           /*Call legacy weak Rx complete callback*/
;;;3644           HAL_UART_RxCpltCallback(huart);
;;;3645   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3646         }
;;;3647   
;;;3648         return HAL_OK;
0000ea  2000              MOVS     r0,#0
                  |L61.236|
;;;3649       }
;;;3650       return HAL_OK;
;;;3651     }
;;;3652     else
;;;3653     {
;;;3654       return HAL_BUSY;
;;;3655     }
;;;3656   }
0000ec  bdf8              POP      {r3-r7,pc}
0000ee  e001              B        |L61.244|
                  |L61.240|
0000f0  2000              MOVS     r0,#0                 ;3650
0000f2  e7fb              B        |L61.236|
                  |L61.244|
0000f4  2002              MOVS     r0,#2                 ;3654
0000f6  e7f9              B        |L61.236|
;;;3657   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;3663     */
;;;3664   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3665   {
000004  4604              MOV      r4,r0
;;;3666     uint32_t tmpreg;
;;;3667     uint32_t pclk;
;;;3668   
;;;3669     /* Check the parameters */
;;;3670     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;3671     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;3672     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;3673     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;3674   
;;;3675     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;3676     /* Configure the UART Stop Bits: Set STOP[13:12] bits
;;;3677        according to huart->Init.StopBits value */
;;;3678     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6820              LDR      r0,[r4,#0]
000008  6900              LDR      r0,[r0,#0x10]
00000a  f4205040          BIC      r0,r0,#0x3000
00000e  68e1              LDR      r1,[r4,#0xc]
000010  4308              ORRS     r0,r0,r1
000012  6821              LDR      r1,[r4,#0]
000014  6108              STR      r0,[r1,#0x10]
;;;3679   
;;;3680     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;3681     /* Configure the UART Word Length, Parity and mode:
;;;3682        Set the M bits according to huart->Init.WordLength value
;;;3683        Set PCE and PS bits according to huart->Init.Parity value
;;;3684        Set TE and RE bits according to huart->Init.Mode value
;;;3685        Set OVER8 bit according to huart->Init.OverSampling value */
;;;3686   
;;;3687     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
000016  6921              LDR      r1,[r4,#0x10]
000018  68a0              LDR      r0,[r4,#8]
00001a  4308              ORRS     r0,r0,r1
00001c  6961              LDR      r1,[r4,#0x14]
00001e  4308              ORRS     r0,r0,r1
000020  69e1              LDR      r1,[r4,#0x1c]
000022  4308              ORRS     r0,r0,r1
000024  9000              STR      r0,[sp,#0]
;;;3688     MODIFY_REG(huart->Instance->CR1,
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  f249610c          MOV      r1,#0x960c
00002e  4388              BICS     r0,r0,r1
000030  9900              LDR      r1,[sp,#0]
000032  4308              ORRS     r0,r0,r1
000034  6821              LDR      r1,[r4,#0]
000036  60c8              STR      r0,[r1,#0xc]
;;;3689                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;3690                tmpreg);
;;;3691   
;;;3692     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;3693     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;3694     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
000038  6820              LDR      r0,[r4,#0]
00003a  6940              LDR      r0,[r0,#0x14]
00003c  f4207040          BIC      r0,r0,#0x300
000040  69a1              LDR      r1,[r4,#0x18]
000042  4308              ORRS     r0,r0,r1
000044  6821              LDR      r1,[r4,#0]
000046  6148              STR      r0,[r1,#0x14]
;;;3695   
;;;3696   
;;;3697   #if defined(USART6) && defined(UART9) && defined(UART10)
;;;3698       if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
;;;3699       {
;;;3700         pclk = HAL_RCC_GetPCLK2Freq();
;;;3701       }
;;;3702   #elif defined(USART6)
;;;3703       if ((huart->Instance == USART1) || (huart->Instance == USART6))
000048  4976              LDR      r1,|L62.548|
00004a  6820              LDR      r0,[r4,#0]
00004c  4288              CMP      r0,r1
00004e  d003              BEQ      |L62.88|
000050  4975              LDR      r1,|L62.552|
000052  6820              LDR      r0,[r4,#0]
000054  4288              CMP      r0,r1
000056  d103              BNE      |L62.96|
                  |L62.88|
;;;3704       {
;;;3705         pclk = HAL_RCC_GetPCLK2Freq();
000058  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00005c  4681              MOV      r9,r0
00005e  e002              B        |L62.102|
                  |L62.96|
;;;3706       }
;;;3707   #else
;;;3708       if (huart->Instance == USART1)
;;;3709       {
;;;3710         pclk = HAL_RCC_GetPCLK2Freq();
;;;3711       }
;;;3712   #endif /* USART6 */
;;;3713       else
;;;3714       {
;;;3715         pclk = HAL_RCC_GetPCLK1Freq();
000060  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000064  4681              MOV      r9,r0
                  |L62.102|
;;;3716       }
;;;3717     /*-------------------------- USART BRR Configuration ---------------------*/
;;;3718     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000066  69e0              LDR      r0,[r4,#0x1c]
000068  f5b04f00          CMP      r0,#0x8000
00006c  d16c              BNE      |L62.328|
;;;3719     {
;;;3720       huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
00006e  2002              MOVS     r0,#2
000070  6861              LDR      r1,[r4,#4]
000072  fba05001          UMULL    r5,r0,r0,r1
000076  4603              MOV      r3,r0
000078  2019              MOVS     r0,#0x19
00007a  fba97000          UMULL    r7,r0,r9,r0
00007e  4601              MOV      r1,r0
000080  462a              MOV      r2,r5
000082  4638              MOV      r0,r7
000084  f7fffffe          BL       __aeabi_uldivmod
000088  2164              MOVS     r1,#0x64
00008a  fbb0f0f1          UDIV     r0,r0,r1
00008e  ea4f1a00          LSL      r10,r0,#4
000092  2002              MOVS     r0,#2
000094  6861              LDR      r1,[r4,#4]
000096  fba05101          UMULL    r5,r1,r0,r1
00009a  460b              MOV      r3,r1
00009c  2019              MOVS     r0,#0x19
00009e  fba97100          UMULL    r7,r1,r9,r0
0000a2  462a              MOV      r2,r5
0000a4  4638              MOV      r0,r7
0000a6  f7fffffe          BL       __aeabi_uldivmod
0000aa  4683              MOV      r11,r0
0000ac  2002              MOVS     r0,#2
0000ae  6861              LDR      r1,[r4,#4]
0000b0  fba05001          UMULL    r5,r0,r0,r1
0000b4  4603              MOV      r3,r0
0000b6  2019              MOVS     r0,#0x19
0000b8  fba97100          UMULL    r7,r1,r9,r0
0000bc  462a              MOV      r2,r5
0000be  4638              MOV      r0,r7
0000c0  f7fffffe          BL       __aeabi_uldivmod
0000c4  2164              MOVS     r1,#0x64
0000c6  fbb0f0f1          UDIV     r0,r0,r1
0000ca  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ce  eb011000          ADD      r0,r1,r0,LSL #4
0000d2  ebab0080          SUB      r0,r11,r0,LSL #2
0000d6  2132              MOVS     r1,#0x32
0000d8  eb0100c0          ADD      r0,r1,r0,LSL #3
0000dc  2164              MOVS     r1,#0x64
0000de  fbb0f0f1          UDIV     r0,r0,r1
0000e2  f00000f8          AND      r0,r0,#0xf8
0000e6  eb0a0a40          ADD      r10,r10,r0,LSL #1
0000ea  2002              MOVS     r0,#2
0000ec  6861              LDR      r1,[r4,#4]
0000ee  fba05001          UMULL    r5,r0,r0,r1
0000f2  4603              MOV      r3,r0
0000f4  2019              MOVS     r0,#0x19
0000f6  fba97000          UMULL    r7,r0,r9,r0
0000fa  4601              MOV      r1,r0
0000fc  462a              MOV      r2,r5
0000fe  4638              MOV      r0,r7
000100  f7fffffe          BL       __aeabi_uldivmod
000104  4683              MOV      r11,r0
000106  2002              MOVS     r0,#2
000108  6861              LDR      r1,[r4,#4]
00010a  fba05001          UMULL    r5,r0,r0,r1
00010e  4603              MOV      r3,r0
000110  2019              MOVS     r0,#0x19
000112  fba97100          UMULL    r7,r1,r9,r0
000116  462a              MOV      r2,r5
000118  4638              MOV      r0,r7
00011a  f7fffffe          BL       __aeabi_uldivmod
00011e  2164              MOVS     r1,#0x64
000120  fbb0f0f1          UDIV     r0,r0,r1
000124  eb0001c0          ADD      r1,r0,r0,LSL #3
000128  eb011000          ADD      r0,r1,r0,LSL #4
00012c  ebab0080          SUB      r0,r11,r0,LSL #2
000130  2132              MOVS     r1,#0x32
000132  eb0100c0          ADD      r0,r1,r0,LSL #3
000136  2164              MOVS     r1,#0x64
000138  fbb0f0f1          UDIV     r0,r0,r1
00013c  f0000007          AND      r0,r0,#7
000140  4450              ADD      r0,r0,r10
000142  6821              LDR      r1,[r4,#0]
000144  6088              STR      r0,[r1,#8]
000146  e06a              B        |L62.542|
                  |L62.328|
;;;3721     }
;;;3722     else
;;;3723     {
;;;3724       huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
000148  2004              MOVS     r0,#4
00014a  6861              LDR      r1,[r4,#4]
00014c  fba05001          UMULL    r5,r0,r0,r1
000150  4603              MOV      r3,r0
000152  2019              MOVS     r0,#0x19
000154  fba97000          UMULL    r7,r0,r9,r0
000158  4601              MOV      r1,r0
00015a  462a              MOV      r2,r5
00015c  4638              MOV      r0,r7
00015e  f7fffffe          BL       __aeabi_uldivmod
000162  4682              MOV      r10,r0
000164  2004              MOVS     r0,#4
000166  6861              LDR      r1,[r4,#4]
000168  fba05001          UMULL    r5,r0,r0,r1
00016c  4603              MOV      r3,r0
00016e  2019              MOVS     r0,#0x19
000170  fba97000          UMULL    r7,r0,r9,r0
000174  4601              MOV      r1,r0
000176  462a              MOV      r2,r5
000178  4638              MOV      r0,r7
00017a  f7fffffe          BL       __aeabi_uldivmod
00017e  2164              MOVS     r1,#0x64
000180  fbb0f0f1          UDIV     r0,r0,r1
000184  eb0001c0          ADD      r1,r0,r0,LSL #3
000188  eb011000          ADD      r0,r1,r0,LSL #4
00018c  ebaa0080          SUB      r0,r10,r0,LSL #2
000190  2132              MOVS     r1,#0x32
000192  eb011000          ADD      r0,r1,r0,LSL #4
000196  2164              MOVS     r1,#0x64
000198  fbb0f0f1          UDIV     r0,r0,r1
00019c  f0000af0          AND      r10,r0,#0xf0
0001a0  2004              MOVS     r0,#4
0001a2  6861              LDR      r1,[r4,#4]
0001a4  fba07001          UMULL    r7,r0,r0,r1
0001a8  4603              MOV      r3,r0
0001aa  2019              MOVS     r0,#0x19
0001ac  fba95100          UMULL    r5,r1,r9,r0
0001b0  463a              MOV      r2,r7
0001b2  4628              MOV      r0,r5
0001b4  f7fffffe          BL       __aeabi_uldivmod
0001b8  2164              MOVS     r1,#0x64
0001ba  fbb0f0f1          UDIV     r0,r0,r1
0001be  eb0a1a00          ADD      r10,r10,r0,LSL #4
0001c2  2004              MOVS     r0,#4
0001c4  6861              LDR      r1,[r4,#4]
0001c6  fba05101          UMULL    r5,r1,r0,r1
0001ca  460b              MOV      r3,r1
0001cc  2019              MOVS     r0,#0x19
0001ce  fba97100          UMULL    r7,r1,r9,r0
0001d2  462a              MOV      r2,r5
0001d4  4638              MOV      r0,r7
0001d6  f7fffffe          BL       __aeabi_uldivmod
0001da  4683              MOV      r11,r0
0001dc  2004              MOVS     r0,#4
0001de  6861              LDR      r1,[r4,#4]
0001e0  fba05001          UMULL    r5,r0,r0,r1
0001e4  4603              MOV      r3,r0
0001e6  2019              MOVS     r0,#0x19
0001e8  fba97000          UMULL    r7,r0,r9,r0
0001ec  4601              MOV      r1,r0
0001ee  462a              MOV      r2,r5
0001f0  4638              MOV      r0,r7
0001f2  f7fffffe          BL       __aeabi_uldivmod
0001f6  2164              MOVS     r1,#0x64
0001f8  fbb0f0f1          UDIV     r0,r0,r1
0001fc  eb0001c0          ADD      r1,r0,r0,LSL #3
000200  eb011000          ADD      r0,r1,r0,LSL #4
000204  ebab0080          SUB      r0,r11,r0,LSL #2
000208  2132              MOVS     r1,#0x32
00020a  eb011000          ADD      r0,r1,r0,LSL #4
00020e  2164              MOVS     r1,#0x64
000210  fbb0f0f1          UDIV     r0,r0,r1
000214  f000000f          AND      r0,r0,#0xf
000218  4450              ADD      r0,r0,r10
00021a  6821              LDR      r1,[r4,#0]
00021c  6088              STR      r0,[r1,#8]
                  |L62.542|
;;;3725     }
;;;3726   }
00021e  e8bd8ff8          POP      {r3-r11,pc}
;;;3727   
                          ENDP

000222  0000              DCW      0x0000
                  |L62.548|
                          DCD      0x40011000
                  |L62.552|
                          DCD      0x40011400

                          AREA ||i.UART_Start_Receive_DMA||, CODE, READONLY, ALIGN=2

                  UART_Start_Receive_DMA PROC
;;;3242     */
;;;3243   HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b577              PUSH     {r0-r2,r4-r6,lr}
;;;3244   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
;;;3245     uint32_t *tmp;
;;;3246   
;;;3247     huart->pRxBuffPtr = pData;
000008  9802              LDR      r0,[sp,#8]
00000a  62a0              STR      r0,[r4,#0x28]
;;;3248     huart->RxXferSize = Size;
00000c  85a5              STRH     r5,[r4,#0x2c]
;;;3249   
;;;3250     huart->ErrorCode = HAL_UART_ERROR_NONE;
00000e  2000              MOVS     r0,#0
000010  6420              STR      r0,[r4,#0x40]
;;;3251     huart->RxState = HAL_UART_STATE_BUSY_RX;
000012  2022              MOVS     r0,#0x22
000014  f884003e          STRB     r0,[r4,#0x3e]
;;;3252   
;;;3253     /* Set the UART DMA transfer complete callback */
;;;3254     huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
000018  4829              LDR      r0,|L63.192|
00001a  6ba1              LDR      r1,[r4,#0x38]
00001c  63c8              STR      r0,[r1,#0x3c]
;;;3255   
;;;3256     /* Set the UART DMA Half transfer complete callback */
;;;3257     huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
00001e  4829              LDR      r0,|L63.196|
000020  6ba1              LDR      r1,[r4,#0x38]
000022  6408              STR      r0,[r1,#0x40]
;;;3258   
;;;3259     /* Set the DMA error callback */
;;;3260     huart->hdmarx->XferErrorCallback = UART_DMAError;
000024  4828              LDR      r0,|L63.200|
000026  6ba1              LDR      r1,[r4,#0x38]
000028  64c8              STR      r0,[r1,#0x4c]
;;;3261   
;;;3262     /* Set the DMA abort callback */
;;;3263     huart->hdmarx->XferAbortCallback = NULL;
00002a  2000              MOVS     r0,#0
00002c  6ba1              LDR      r1,[r4,#0x38]
00002e  6508              STR      r0,[r1,#0x50]
;;;3264   
;;;3265     /* Enable the DMA stream */
;;;3266     tmp = (uint32_t *)&pData;
000030  ae02              ADD      r6,sp,#8
;;;3267     HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
000032  6832              LDR      r2,[r6,#0]
000034  6823              LDR      r3,[r4,#0]
000036  1d19              ADDS     r1,r3,#4
000038  462b              MOV      r3,r5
00003a  6ba0              LDR      r0,[r4,#0x38]
00003c  f7fffffe          BL       HAL_DMA_Start_IT
;;;3268   
;;;3269     /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;3270     __HAL_UART_CLEAR_OREFLAG(huart);
000040  bf00              NOP      
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
000046  6820              LDR      r0,[r4,#0]
000048  6800              LDR      r0,[r0,#0]
00004a  9000              STR      r0,[sp,#0]
00004c  6820              LDR      r0,[r4,#0]
00004e  6840              LDR      r0,[r0,#4]
000050  9000              STR      r0,[sp,#0]
000052  bf00              NOP      
000054  bf00              NOP      
;;;3271   
;;;3272     /* Process Unlocked */
;;;3273     __HAL_UNLOCK(huart);
000056  bf00              NOP      
000058  2000              MOVS     r0,#0
00005a  f884003c          STRB     r0,[r4,#0x3c]
00005e  bf00              NOP      
;;;3274   
;;;3275     /* Enable the UART Parity Error Interrupt */
;;;3276     ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000060  bf00              NOP      
000062  bf00              NOP      
                  |L63.100|
000064  6821              LDR      r1,[r4,#0]
000066  310c              ADDS     r1,r1,#0xc
000068  e8511f00          LDREX    r1,[r1,#0]
00006c  f4417080          ORR      r0,r1,#0x100
000070  6821              LDR      r1,[r4,#0]
000072  310c              ADDS     r1,r1,#0xc
000074  e8410200          STREX    r2,r0,[r1,#0]
000078  2a00              CMP      r2,#0
00007a  d1f3              BNE      |L63.100|
00007c  bf00              NOP      
;;;3277   
;;;3278     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3279     ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
00007e  bf00              NOP      
000080  bf00              NOP      
                  |L63.130|
000082  6821              LDR      r1,[r4,#0]
000084  3114              ADDS     r1,r1,#0x14
000086  e8511f00          LDREX    r1,[r1,#0]
00008a  f0410001          ORR      r0,r1,#1
00008e  6821              LDR      r1,[r4,#0]
000090  3114              ADDS     r1,r1,#0x14
000092  e8410200          STREX    r2,r0,[r1,#0]
000096  2a00              CMP      r2,#0
000098  d1f3              BNE      |L63.130|
00009a  bf00              NOP      
;;;3280   
;;;3281     /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;3282     in the UART CR3 register */
;;;3283     ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00009c  bf00              NOP      
00009e  bf00              NOP      
                  |L63.160|
0000a0  6821              LDR      r1,[r4,#0]
0000a2  3114              ADDS     r1,r1,#0x14
0000a4  e8511f00          LDREX    r1,[r1,#0]
0000a8  f0410040          ORR      r0,r1,#0x40
0000ac  6821              LDR      r1,[r4,#0]
0000ae  3114              ADDS     r1,r1,#0x14
0000b0  e8410200          STREX    r2,r0,[r1,#0]
0000b4  2a00              CMP      r2,#0
0000b6  d1f3              BNE      |L63.160|
0000b8  bf00              NOP      
;;;3284   
;;;3285     return HAL_OK;
0000ba  2000              MOVS     r0,#0
;;;3286   }
0000bc  b004              ADD      sp,sp,#0x10
0000be  bd70              POP      {r4-r6,pc}
;;;3287   
                          ENDP

                  |L63.192|
                          DCD      UART_DMAReceiveCplt
                  |L63.196|
                          DCD      UART_DMARxHalfCplt
                  |L63.200|
                          DCD      UART_DMAError

                          AREA ||i.UART_Start_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Start_Receive_IT PROC
;;;3207     */
;;;3208   HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;3209   {
000002  4603              MOV      r3,r0
;;;3210     huart->pRxBuffPtr = pData;
000004  6299              STR      r1,[r3,#0x28]
;;;3211     huart->RxXferSize = Size;
000006  859a              STRH     r2,[r3,#0x2c]
;;;3212     huart->RxXferCount = Size;
000008  85da              STRH     r2,[r3,#0x2e]
;;;3213   
;;;3214     huart->ErrorCode = HAL_UART_ERROR_NONE;
00000a  2000              MOVS     r0,#0
00000c  6418              STR      r0,[r3,#0x40]
;;;3215     huart->RxState = HAL_UART_STATE_BUSY_RX;
00000e  2022              MOVS     r0,#0x22
000010  f883003e          STRB     r0,[r3,#0x3e]
;;;3216   
;;;3217     /* Process Unlocked */
;;;3218     __HAL_UNLOCK(huart);
000014  bf00              NOP      
000016  2000              MOVS     r0,#0
000018  f883003c          STRB     r0,[r3,#0x3c]
00001c  bf00              NOP      
;;;3219   
;;;3220     /* Enable the UART Parity Error Interrupt */
;;;3221     __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
00001e  6818              LDR      r0,[r3,#0]
000020  68c0              LDR      r0,[r0,#0xc]
000022  f4407080          ORR      r0,r0,#0x100
000026  681c              LDR      r4,[r3,#0]
000028  60e0              STR      r0,[r4,#0xc]
;;;3222   
;;;3223     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3224     __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
00002a  6818              LDR      r0,[r3,#0]
00002c  6940              LDR      r0,[r0,#0x14]
00002e  f0400001          ORR      r0,r0,#1
000032  681c              LDR      r4,[r3,#0]
000034  6160              STR      r0,[r4,#0x14]
;;;3225   
;;;3226     /* Enable the UART Data Register not empty Interrupt */
;;;3227     __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
000036  6818              LDR      r0,[r3,#0]
000038  68c0              LDR      r0,[r0,#0xc]
00003a  f0400020          ORR      r0,r0,#0x20
00003e  681c              LDR      r4,[r3,#0]
000040  60e0              STR      r0,[r4,#0xc]
;;;3228   
;;;3229     return HAL_OK;
000042  2000              MOVS     r0,#0
;;;3230   }
000044  bd10              POP      {r4,pc}
;;;3231   
                          ENDP


                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;3500     */
;;;3501   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;3502   {
;;;3503     uint16_t *tmp;
;;;3504   
;;;3505     /* Check that a Tx process is ongoing */
;;;3506     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  f891003d          LDRB     r0,[r1,#0x3d]
000006  2821              CMP      r0,#0x21
000008  d128              BNE      |L65.92|
;;;3507     {
;;;3508       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00000a  6888              LDR      r0,[r1,#8]
00000c  f5b05f80          CMP      r0,#0x1000
000010  d10b              BNE      |L65.42|
000012  6908              LDR      r0,[r1,#0x10]
000014  b948              CBNZ     r0,|L65.42|
;;;3509       {
;;;3510         tmp = (uint16_t *) huart->pTxBuffPtr;
000016  6a0a              LDR      r2,[r1,#0x20]
;;;3511         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
000018  8810              LDRH     r0,[r2,#0]
00001a  f3c00008          UBFX     r0,r0,#0,#9
00001e  680b              LDR      r3,[r1,#0]
000020  6058              STR      r0,[r3,#4]
;;;3512         huart->pTxBuffPtr += 2U;
000022  6a08              LDR      r0,[r1,#0x20]
000024  1c80              ADDS     r0,r0,#2
000026  6208              STR      r0,[r1,#0x20]
000028  e005              B        |L65.54|
                  |L65.42|
;;;3513       }
;;;3514       else
;;;3515       {
;;;3516         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
00002a  6a0b              LDR      r3,[r1,#0x20]
00002c  1c58              ADDS     r0,r3,#1
00002e  6208              STR      r0,[r1,#0x20]
000030  7818              LDRB     r0,[r3,#0]
000032  680b              LDR      r3,[r1,#0]
000034  6058              STR      r0,[r3,#4]
                  |L65.54|
;;;3517       }
;;;3518   
;;;3519       if (--huart->TxXferCount == 0U)
000036  8cc8              LDRH     r0,[r1,#0x26]
000038  1e40              SUBS     r0,r0,#1
00003a  b280              UXTH     r0,r0
00003c  84c8              STRH     r0,[r1,#0x26]
00003e  b958              CBNZ     r0,|L65.88|
;;;3520       {
;;;3521         /* Disable the UART Transmit Complete Interrupt */
;;;3522         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
000040  6808              LDR      r0,[r1,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200080          BIC      r0,r0,#0x80
000048  680b              LDR      r3,[r1,#0]
00004a  60d8              STR      r0,[r3,#0xc]
;;;3523   
;;;3524         /* Enable the UART Transmit Complete Interrupt */
;;;3525         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
00004c  6808              LDR      r0,[r1,#0]
00004e  68c0              LDR      r0,[r0,#0xc]
000050  f0400040          ORR      r0,r0,#0x40
000054  680b              LDR      r3,[r1,#0]
000056  60d8              STR      r0,[r3,#0xc]
                  |L65.88|
;;;3526       }
;;;3527       return HAL_OK;
000058  2000              MOVS     r0,#0
                  |L65.90|
;;;3528     }
;;;3529     else
;;;3530     {
;;;3531       return HAL_BUSY;
;;;3532     }
;;;3533   }
00005a  4770              BX       lr
                  |L65.92|
00005c  2002              MOVS     r0,#2                 ;3531
00005e  e7fc              B        |L65.90|
;;;3534   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;3168     */
;;;3169   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3170                                                        uint32_t Tickstart, uint32_t Timeout)
;;;3171   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e06              LDR      r6,[sp,#0x18]
;;;3172     /* Wait until flag is set */
;;;3173     while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
00000e  e034              B        |L66.122|
                  |L66.16|
;;;3174     {
;;;3175       /* Check for the Timeout */
;;;3176       if (Timeout != HAL_MAX_DELAY)
000010  1c70              ADDS     r0,r6,#1
000012  b388              CBZ      r0,|L66.120|
;;;3177       {
;;;3178         if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
000014  b12e              CBZ      r6,|L66.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d92b              BLS      |L66.122|
                  |L66.34|
;;;3179         {
;;;3180           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;3181           ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000022  bf00              NOP      
000024  bf00              NOP      
                  |L66.38|
000026  6821              LDR      r1,[r4,#0]
000028  310c              ADDS     r1,r1,#0xc
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f42170d0          BIC      r0,r1,#0x1a0
000032  6821              LDR      r1,[r4,#0]
000034  310c              ADDS     r1,r1,#0xc
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L66.38|
00003e  bf00              NOP      
;;;3182           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000040  bf00              NOP      
000042  bf00              NOP      
                  |L66.68|
000044  6821              LDR      r1,[r4,#0]
000046  3114              ADDS     r1,r1,#0x14
000048  e8511f00          LDREX    r1,[r1,#0]
00004c  f0210001          BIC      r0,r1,#1
000050  6821              LDR      r1,[r4,#0]
000052  3114              ADDS     r1,r1,#0x14
000054  e8410200          STREX    r2,r0,[r1,#0]
000058  2a00              CMP      r2,#0
00005a  d1f3              BNE      |L66.68|
00005c  bf00              NOP      
;;;3183   
;;;3184           huart->gState  = HAL_UART_STATE_READY;
00005e  2020              MOVS     r0,#0x20
000060  f884003d          STRB     r0,[r4,#0x3d]
;;;3185           huart->RxState = HAL_UART_STATE_READY;
000064  f884003e          STRB     r0,[r4,#0x3e]
;;;3186   
;;;3187           /* Process Unlocked */
;;;3188           __HAL_UNLOCK(huart);
000068  bf00              NOP      
00006a  2000              MOVS     r0,#0
00006c  f884003c          STRB     r0,[r4,#0x3c]
000070  bf00              NOP      
;;;3189   
;;;3190           return HAL_TIMEOUT;
000072  2003              MOVS     r0,#3
                  |L66.116|
;;;3191         }
;;;3192       }
;;;3193     }
;;;3194     return HAL_OK;
;;;3195   }
000074  e8bd81f0          POP      {r4-r8,pc}
                  |L66.120|
000078  e7ff              B        |L66.122|
                  |L66.122|
00007a  6820              LDR      r0,[r4,#0]            ;3173
00007c  6800              LDR      r0,[r0,#0]            ;3173
00007e  4028              ANDS     r0,r0,r5              ;3173
000080  42a8              CMP      r0,r5                 ;3173
000082  d101              BNE      |L66.136|
000084  2001              MOVS     r0,#1                 ;3173
000086  e000              B        |L66.138|
                  |L66.136|
000088  2000              MOVS     r0,#0                 ;3173
                  |L66.138|
00008a  42b8              CMP      r0,r7                 ;3173
00008c  d0c0              BEQ      |L66.16|
00008e  2000              MOVS     r0,#0                 ;3194
000090  e7f0              B        |L66.116|
;;;3196   
                          ENDP


;*** Start embedded assembler ***

#line 1 "D:\\Keil_v5\\ARM\\PACK\\Keil\\STM32F4xx_DFP\\2.16.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
