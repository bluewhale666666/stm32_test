L 1 "Power\PowerMenu.c"
N/**
N  ******************************************************************************
N  * @file    PowerMenu.h
N  * @author  Xi Liang/Liu Gui Qing
N  * @brief   Power Menu Driver.
N  *         
N  @verbatim
N  ******************************************************************************
N  */
N	
N#include "PowerMenu.h"
L 1 "Power\PowerMenu.h" 1
N/**
N  ******************************************************************************
N  * @file    PowerMenu.h
N  * @author  Xi Liang/Liu Gui Qing
N  * @brief   Power Menu Driver.
N  *         
N  @verbatim
N  ******************************************************************************
N  */
N	
N#ifndef __POWERMENU_H
N#define __POWERMENU_H
N
N
N#include "data_def.h"
L 1 "Power\data_def.h" 1
N/**
N  ******************************************************************************
N  * @file    data_def.h
N  * @author  Xi Liang/Liu Gui Qing
N  * @brief   Data define.
N  *         
N  @verbatim
N  ******************************************************************************
N  */
N	
N#ifndef __DATA_DEF_H
N#define __DATA_DEF_H
N
N#include <stdint.h>
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060009
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 15 "Power\data_def.h" 2
N
N
N
Ntypedef union 
N{
N  struct
N	{
N		uint8_t SYSTEM_RUN        :1;		//系统运行
N		uint8_t DC48_OC           :1;		//48V过流防护
N		uint8_t DC24V1_FK_OUT     :1;   //24V反馈输出
N		uint8_t MCON_FK_IN        :1;   //主控反馈信号输入
N		uint8_t BIT4B             :4;
N	}STATE_DEFINE_H;
N	uint8_t VAL;
N}STATE_INFORMATION_H;
N
Ntypedef union 
N{
N  struct
N	{
N		uint8_t DC48V_REM 	      :1;   //48v remote
N		uint8_t DC24V1A  		      :1; 	//24v1a输出，主控
N		uint8_t DC24V1B  		      :1; 	//24v1b输出，从站MCU
N		uint8_t DC24V1C  		      :1; 	//24v1c输出，安全MCU
N		uint8_t DC24V2A  		      :1; 	//24v2a输出，从站IO
N		uint8_t DC24V2B  		      :1; 	//24v2b输出，安全IO
N		uint8_t FAN_RUN  	        :1; 	//风扇启动
N		uint8_t DC48V_ES_SHUTDOWN :1;   //48V异常MOS
N	}STATE_DEFINE_L;
N	uint8_t VAL;
N}STATE_INFORMATION_L;
N
Ntypedef union			
N{
N	struct 
N	{
N		uint8_t DC24V2_OV		      :1; 	//24v2过压
N		uint8_t DC24V2A_OC	      :1; 	//24v2A过流
N		uint8_t DC24V2B_OC	      :1; 	//24v2B过流
N		uint8_t MCON_FKIN		      :1; 	//主控反馈故障
N		uint8_t RES_OVERHAET	 		:1; 	//预充电电阻过热
N		uint8_t BIT3B				      :3; 	
N	}FAULT_DEFINE_H;
N	uint8_t VAL;
N}FAULT_INFORMATION_H;
N
Ntypedef union			
N{
N	struct 
N	{
N		uint8_t TEMP_H	 		      :1; 	//温度过高
N		uint8_t DC48V_UV		      :1; 	//48v欠压
N		uint8_t DC48V_OV	       	:1; 	//48v过压
N		uint8_t DC48V_OC		      :1; 	//48v过流
N		uint8_t DC24V1_UV	      	:1; 	//24v1欠压
N		uint8_t DC24V1_OV		      :1; 	//24v1过压
N		uint8_t DC24V1_OC		      :1; 	//24v1过流
N		uint8_t DC24V2_UV		      :1; 	//24v2欠压
N	}FAULT_DEFINE_L;
N	uint8_t VAL;
N}FAULT_INFORMATION_L;
N
Ntypedef struct 
N{
N	uint16_t upload_time;  
N	uint8_t  work_mode;
N	
N	uint8_t temperature;
N	uint16_t dc48v_u;
N	uint16_t dc48v_i;
N	uint16_t dc24v_u;
N	uint16_t dc24v_i;
N	
N	uint16_t ai1_u;
N	uint16_t ai1_i;
N	uint16_t ai2_u;
N	uint16_t ai2_i;
N	
N	uint8_t AI_SW1;
N	uint8_t AI_SW2;
N	
N	STATE_INFORMATION_H p_state_h;
N	STATE_INFORMATION_L p_state_l;
N	FAULT_INFORMATION_H p_breakdown_h;
N	FAULT_INFORMATION_L p_breakdown_l;
N}POWER_MANAGE_PACKED;
Nextern POWER_MANAGE_PACKED power_manage;
N
Ntypedef enum
N{
N	POWER_STATUS_IDLE = 0x00u,
N	POWER_STATUS_POWERON,
N	POWER_STATUS_48VNOSTART,
N	POWER_STATUS_48VSTART,
N	POWER_STATUS_SHUTDWON,
N	POWER_STATUS_SOFTWAREPOWEROFF,
N	POWER_STATUS_FAULT,
N}POWER_STATUS_TYPE;
N
N#endif
N
L 16 "Power\PowerMenu.h" 2
N#include "main.h"
L 1 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\main.h" 1
N/* USER CODE BEGIN Header */
N/**
N  ******************************************************************************
N  * @file           : main.h
N  * @brief          : Header for main.c file.
N  *                   This file contains the common defines of the application.
N  ******************************************************************************
N  * @attention
N  *
N  * Copyright (c) 2022 STMicroelectronics.
N  * All rights reserved.
N  *
N  * This software is licensed under terms that can be found in the LICENSE file
N  * in the root directory of this software component.
N  * If no LICENSE file comes with this software, it is provided AS-IS.
N  *
N  ******************************************************************************
N  */
N/* USER CODE END Header */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MAIN_H
N#define __MAIN_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal.h
N  * @author  MCD Application Team
N  * @brief   This file contains all the functions prototypes for the HAL 
N  *          module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_H
N#define __STM32F4xx_HAL_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_conf.h"
L 1 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 1
N/* USER CODE BEGIN Header */
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_conf_template.h
N  * @author  MCD Application Team
N  * @brief   HAL configuration template file.
N  *          This file should be copied to the application folder and renamed
N  *          to stm32f4xx_hal_conf.h.
N  ******************************************************************************
N  * @attention
N  *
N  * Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.
N  *
N  * This software is licensed under terms that can be found in the LICENSE file
N  * in the root directory of this software component.
N  * If no LICENSE file comes with this software, it is provided AS-IS.
N  *
N  ******************************************************************************
N  */
N/* USER CODE END Header */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_CONF_H
N#define __STM32F4xx_HAL_CONF_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/* ########################## Module Selection ############################## */
N/**
N  * @brief This is the list of modules to be used in the HAL driver
N  */
N#define HAL_MODULE_ENABLED
N
N  /* #define HAL_ADC_MODULE_ENABLED   */
N/* #define HAL_CRYP_MODULE_ENABLED   */
N#define HAL_CAN_MODULE_ENABLED
N/* #define HAL_CRC_MODULE_ENABLED   */
N/* #define HAL_CAN_LEGACY_MODULE_ENABLED   */
N/* #define HAL_CRYP_MODULE_ENABLED   */
N/* #define HAL_DAC_MODULE_ENABLED   */
N/* #define HAL_DCMI_MODULE_ENABLED   */
N/* #define HAL_DMA2D_MODULE_ENABLED   */
N/* #define HAL_ETH_MODULE_ENABLED   */
N/* #define HAL_NAND_MODULE_ENABLED   */
N/* #define HAL_NOR_MODULE_ENABLED   */
N/* #define HAL_PCCARD_MODULE_ENABLED   */
N/* #define HAL_SRAM_MODULE_ENABLED   */
N/* #define HAL_SDRAM_MODULE_ENABLED   */
N/* #define HAL_HASH_MODULE_ENABLED   */
N#define HAL_I2C_MODULE_ENABLED
N/* #define HAL_I2S_MODULE_ENABLED   */
N/* #define HAL_IWDG_MODULE_ENABLED   */
N/* #define HAL_LTDC_MODULE_ENABLED   */
N/* #define HAL_RNG_MODULE_ENABLED   */
N/* #define HAL_RTC_MODULE_ENABLED   */
N/* #define HAL_SAI_MODULE_ENABLED   */
N/* #define HAL_SD_MODULE_ENABLED   */
N/* #define HAL_MMC_MODULE_ENABLED   */
N#define HAL_SPI_MODULE_ENABLED
N/* #define HAL_TIM_MODULE_ENABLED   */
N#define HAL_UART_MODULE_ENABLED
N/* #define HAL_USART_MODULE_ENABLED   */
N/* #define HAL_IRDA_MODULE_ENABLED   */
N/* #define HAL_SMARTCARD_MODULE_ENABLED   */
N/* #define HAL_SMBUS_MODULE_ENABLED   */
N/* #define HAL_WWDG_MODULE_ENABLED   */
N/* #define HAL_PCD_MODULE_ENABLED   */
N/* #define HAL_HCD_MODULE_ENABLED   */
N/* #define HAL_DSI_MODULE_ENABLED   */
N/* #define HAL_QSPI_MODULE_ENABLED   */
N/* #define HAL_QSPI_MODULE_ENABLED   */
N/* #define HAL_CEC_MODULE_ENABLED   */
N/* #define HAL_FMPI2C_MODULE_ENABLED   */
N/* #define HAL_FMPSMBUS_MODULE_ENABLED   */
N/* #define HAL_SPDIFRX_MODULE_ENABLED   */
N/* #define HAL_DFSDM_MODULE_ENABLED   */
N/* #define HAL_LPTIM_MODULE_ENABLED   */
N#define HAL_GPIO_MODULE_ENABLED
N#define HAL_EXTI_MODULE_ENABLED
N#define HAL_DMA_MODULE_ENABLED
N#define HAL_RCC_MODULE_ENABLED
N#define HAL_FLASH_MODULE_ENABLED
N#define HAL_PWR_MODULE_ENABLED
N#define HAL_CORTEX_MODULE_ENABLED
N
N/* ########################## HSE/HSI Values adaptation ##################### */
N/**
N  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
N  *        This value is used by the RCC HAL module to compute the system frequency
N  *        (when HSE is used as system clock source, directly or through the PLL).
N  */
N#if !defined  (HSE_VALUE)
X#if !0L
N  #define HSE_VALUE    8000000U /*!< Value of the External oscillator in Hz */
N#endif /* HSE_VALUE */
N
N#if !defined  (HSE_STARTUP_TIMEOUT)
X#if !0L
N  #define HSE_STARTUP_TIMEOUT    100U   /*!< Time out for HSE start up, in ms */
N#endif /* HSE_STARTUP_TIMEOUT */
N
N/**
N  * @brief Internal High Speed oscillator (HSI) value.
N  *        This value is used by the RCC HAL module to compute the system frequency
N  *        (when HSI is used as system clock source, directly or through the PLL).
N  */
N#if !defined  (HSI_VALUE)
X#if !0L
N  #define HSI_VALUE    ((uint32_t)16000000U) /*!< Value of the Internal oscillator in Hz*/
N#endif /* HSI_VALUE */
N
N/**
N  * @brief Internal Low Speed oscillator (LSI) value.
N  */
N#if !defined  (LSI_VALUE)
X#if !0L
N #define LSI_VALUE  32000U       /*!< LSI Typical Value in Hz*/
N#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.*/
N/**
N  * @brief External Low Speed oscillator (LSE) value.
N  */
N#if !defined  (LSE_VALUE)
X#if !0L
N #define LSE_VALUE  32768U    /*!< Value of the External Low Speed oscillator in Hz */
N#endif /* LSE_VALUE */
N
N#if !defined  (LSE_STARTUP_TIMEOUT)
X#if !0L
N  #define LSE_STARTUP_TIMEOUT    5000U   /*!< Time out for LSE start up, in ms */
N#endif /* LSE_STARTUP_TIMEOUT */
N
N/**
N  * @brief External clock source for I2S peripheral
N  *        This value is used by the I2S HAL module to compute the I2S clock source
N  *        frequency, this source is inserted directly through I2S_CKIN pad.
N  */
N#if !defined  (EXTERNAL_CLOCK_VALUE)
X#if !0L
N  #define EXTERNAL_CLOCK_VALUE    12288000U /*!< Value of the External audio frequency in Hz*/
N#endif /* EXTERNAL_CLOCK_VALUE */
N
N/* Tip: To avoid modifying this file each time you need to use different HSE,
N   ===  you can define the HSE value in your toolchain compiler preprocessor. */
N
N/* ########################### System Configuration ######################### */
N/**
N  * @brief This is the HAL system configuration section
N  */
N#define  VDD_VALUE		      3300U /*!< Value of VDD in mv */
N#define  TICK_INT_PRIORITY            2U   /*!< tick interrupt priority */
N#define  USE_RTOS                     0U
N#define  PREFETCH_ENABLE              1U
N#define  INSTRUCTION_CACHE_ENABLE     1U
N#define  DATA_CACHE_ENABLE            1U
N
N#define  USE_HAL_ADC_REGISTER_CALLBACKS         0U /* ADC register callback disabled       */
N#define  USE_HAL_CAN_REGISTER_CALLBACKS         0U /* CAN register callback disabled       */
N#define  USE_HAL_CEC_REGISTER_CALLBACKS         0U /* CEC register callback disabled       */
N#define  USE_HAL_CRYP_REGISTER_CALLBACKS        0U /* CRYP register callback disabled      */
N#define  USE_HAL_DAC_REGISTER_CALLBACKS         0U /* DAC register callback disabled       */
N#define  USE_HAL_DCMI_REGISTER_CALLBACKS        0U /* DCMI register callback disabled      */
N#define  USE_HAL_DFSDM_REGISTER_CALLBACKS       0U /* DFSDM register callback disabled     */
N#define  USE_HAL_DMA2D_REGISTER_CALLBACKS       0U /* DMA2D register callback disabled     */
N#define  USE_HAL_DSI_REGISTER_CALLBACKS         0U /* DSI register callback disabled       */
N#define  USE_HAL_ETH_REGISTER_CALLBACKS         0U /* ETH register callback disabled       */
N#define  USE_HAL_HASH_REGISTER_CALLBACKS        0U /* HASH register callback disabled      */
N#define  USE_HAL_HCD_REGISTER_CALLBACKS         0U /* HCD register callback disabled       */
N#define  USE_HAL_I2C_REGISTER_CALLBACKS         0U /* I2C register callback disabled       */
N#define  USE_HAL_FMPI2C_REGISTER_CALLBACKS      0U /* FMPI2C register callback disabled    */
N#define  USE_HAL_FMPSMBUS_REGISTER_CALLBACKS    0U /* FMPSMBUS register callback disabled  */
N#define  USE_HAL_I2S_REGISTER_CALLBACKS         0U /* I2S register callback disabled       */
N#define  USE_HAL_IRDA_REGISTER_CALLBACKS        0U /* IRDA register callback disabled      */
N#define  USE_HAL_LPTIM_REGISTER_CALLBACKS       0U /* LPTIM register callback disabled     */
N#define  USE_HAL_LTDC_REGISTER_CALLBACKS        0U /* LTDC register callback disabled      */
N#define  USE_HAL_MMC_REGISTER_CALLBACKS         0U /* MMC register callback disabled       */
N#define  USE_HAL_NAND_REGISTER_CALLBACKS        0U /* NAND register callback disabled      */
N#define  USE_HAL_NOR_REGISTER_CALLBACKS         0U /* NOR register callback disabled       */
N#define  USE_HAL_PCCARD_REGISTER_CALLBACKS      0U /* PCCARD register callback disabled    */
N#define  USE_HAL_PCD_REGISTER_CALLBACKS         0U /* PCD register callback disabled       */
N#define  USE_HAL_QSPI_REGISTER_CALLBACKS        0U /* QSPI register callback disabled      */
N#define  USE_HAL_RNG_REGISTER_CALLBACKS         0U /* RNG register callback disabled       */
N#define  USE_HAL_RTC_REGISTER_CALLBACKS         0U /* RTC register callback disabled       */
N#define  USE_HAL_SAI_REGISTER_CALLBACKS         0U /* SAI register callback disabled       */
N#define  USE_HAL_SD_REGISTER_CALLBACKS          0U /* SD register callback disabled        */
N#define  USE_HAL_SMARTCARD_REGISTER_CALLBACKS   0U /* SMARTCARD register callback disabled */
N#define  USE_HAL_SDRAM_REGISTER_CALLBACKS       0U /* SDRAM register callback disabled     */
N#define  USE_HAL_SRAM_REGISTER_CALLBACKS        0U /* SRAM register callback disabled      */
N#define  USE_HAL_SPDIFRX_REGISTER_CALLBACKS     0U /* SPDIFRX register callback disabled   */
N#define  USE_HAL_SMBUS_REGISTER_CALLBACKS       0U /* SMBUS register callback disabled     */
N#define  USE_HAL_SPI_REGISTER_CALLBACKS         0U /* SPI register callback disabled       */
N#define  USE_HAL_TIM_REGISTER_CALLBACKS         0U /* TIM register callback disabled       */
N#define  USE_HAL_UART_REGISTER_CALLBACKS        1U /* UART register callback enabled      */
N#define  USE_HAL_USART_REGISTER_CALLBACKS       0U /* USART register callback disabled     */
N#define  USE_HAL_WWDG_REGISTER_CALLBACKS        0U /* WWDG register callback disabled      */
N
N/* ########################## Assert Selection ############################## */
N/**
N  * @brief Uncomment the line below to expanse the "assert_param" macro in the
N  *        HAL drivers code
N  */
N/* #define USE_FULL_ASSERT    1U */
N
N/* ################## Ethernet peripheral configuration ##################### */
N
N/* Section 1 : Ethernet peripheral configuration */
N
N/* MAC ADDRESS: MAC_ADDR0:MAC_ADDR1:MAC_ADDR2:MAC_ADDR3:MAC_ADDR4:MAC_ADDR5 */
N#define MAC_ADDR0   2U
N#define MAC_ADDR1   0U
N#define MAC_ADDR2   0U
N#define MAC_ADDR3   0U
N#define MAC_ADDR4   0U
N#define MAC_ADDR5   0U
N
N/* Definition of the Ethernet driver buffers size and count */
N#define ETH_RX_BUF_SIZE                ETH_MAX_PACKET_SIZE /* buffer size for receive               */
N#define ETH_TX_BUF_SIZE                ETH_MAX_PACKET_SIZE /* buffer size for transmit              */
N#define ETH_RXBUFNB                    4U       /* 4 Rx buffers of size ETH_RX_BUF_SIZE  */
N#define ETH_TXBUFNB                    4U       /* 4 Tx buffers of size ETH_TX_BUF_SIZE  */
N
N/* Section 2: PHY configuration section */
N
N/* DP83848_PHY_ADDRESS Address*/
N#define DP83848_PHY_ADDRESS           0x01U
N/* PHY Reset delay these values are based on a 1 ms Systick interrupt*/
N#define PHY_RESET_DELAY                 0x000000FFU
N/* PHY Configuration delay */
N#define PHY_CONFIG_DELAY                0x00000FFFU
N
N#define PHY_READ_TO                     0x0000FFFFU
N#define PHY_WRITE_TO                    0x0000FFFFU
N
N/* Section 3: Common PHY Registers */
N
N#define PHY_BCR                         ((uint16_t)0x0000U)    /*!< Transceiver Basic Control Register   */
N#define PHY_BSR                         ((uint16_t)0x0001U)    /*!< Transceiver Basic Status Register    */
N
N#define PHY_RESET                       ((uint16_t)0x8000U)  /*!< PHY Reset */
N#define PHY_LOOPBACK                    ((uint16_t)0x4000U)  /*!< Select loop-back mode */
N#define PHY_FULLDUPLEX_100M             ((uint16_t)0x2100U)  /*!< Set the full-duplex mode at 100 Mb/s */
N#define PHY_HALFDUPLEX_100M             ((uint16_t)0x2000U)  /*!< Set the half-duplex mode at 100 Mb/s */
N#define PHY_FULLDUPLEX_10M              ((uint16_t)0x0100U)  /*!< Set the full-duplex mode at 10 Mb/s  */
N#define PHY_HALFDUPLEX_10M              ((uint16_t)0x0000U)  /*!< Set the half-duplex mode at 10 Mb/s  */
N#define PHY_AUTONEGOTIATION             ((uint16_t)0x1000U)  /*!< Enable auto-negotiation function     */
N#define PHY_RESTART_AUTONEGOTIATION     ((uint16_t)0x0200U)  /*!< Restart auto-negotiation function    */
N#define PHY_POWERDOWN                   ((uint16_t)0x0800U)  /*!< Select the power down mode           */
N#define PHY_ISOLATE                     ((uint16_t)0x0400U)  /*!< Isolate PHY from MII                 */
N
N#define PHY_AUTONEGO_COMPLETE           ((uint16_t)0x0020U)  /*!< Auto-Negotiation process completed   */
N#define PHY_LINKED_STATUS               ((uint16_t)0x0004U)  /*!< Valid link established               */
N#define PHY_JABBER_DETECTION            ((uint16_t)0x0002U)  /*!< Jabber condition detected            */
N
N/* Section 4: Extended PHY Registers */
N#define PHY_SR                          ((uint16_t)0x10U)    /*!< PHY status register Offset                      */
N
N#define PHY_SPEED_STATUS                ((uint16_t)0x0002U)  /*!< PHY Speed mask                                  */
N#define PHY_DUPLEX_STATUS               ((uint16_t)0x0004U)  /*!< PHY Duplex mask                                 */
N
N/* ################## SPI peripheral configuration ########################## */
N
N/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver
N* Activated: CRC code is present inside driver
N* Deactivated: CRC code cleaned from driver
N*/
N
N#define USE_SPI_CRC                     0U
N
N/* Includes ------------------------------------------------------------------*/
N/**
N  * @brief Include module's header file
N  */
N
N#ifdef HAL_RCC_MODULE_ENABLED
N  #include "stm32f4xx_hal_rcc.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_rcc.h
N  * @author  MCD Application Team
N  * @brief   Header file of RCC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_RCC_H
N#define __STM32F4xx_HAL_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_def.h
N  * @author  MCD Application Team
N  * @brief   This file contains HAL common defines, enumeration, macros and 
N  *          structures definitions. 
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  *
N  * Modified by Arm
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_DEF
N#define __STM32F4xx_HAL_DEF
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS STM32F4xx Device Peripheral Access Layer Header File.
N  *            
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The STM32F4xx device used in the target application
N  *              - To use or not the peripherals drivers in application code(i.e. 
N  *                code will be based on direct access to peripherals registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_HAL_DRIVER"
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f4xx
N  * @{
N  */
N    
N#ifndef __STM32F4xx_H
N#define __STM32F4xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N   
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N  
N/**
N  * @brief STM32 Family
N  */
N#if !defined  (STM32F4)
X#if !0L
N#define STM32F4
N#endif /* STM32F4 */
N
N/* Uncomment the line below according to the target STM32 device used in your
N   application 
N  */
N#if !defined (STM32F405xx) && !defined (STM32F415xx) && !defined (STM32F407xx) && !defined (STM32F417xx) && \
N    !defined (STM32F427xx) && !defined (STM32F437xx) && !defined (STM32F429xx) && !defined (STM32F439xx) && \
N    !defined (STM32F401xC) && !defined (STM32F401xE) && !defined (STM32F410Tx) && !defined (STM32F410Cx) && \
N    !defined (STM32F410Rx) && !defined (STM32F411xE) && !defined (STM32F446xx) && !defined (STM32F469xx) && \
N    !defined (STM32F479xx) && !defined (STM32F412Cx) && !defined (STM32F412Rx) && !defined (STM32F412Vx) && \
N    !defined (STM32F412Zx) && !defined (STM32F413xx) && !defined (STM32F423xx)
X#if !0L && !0L && !1L && !0L &&     !0L && !0L && !0L && !0L &&     !0L && !0L && !0L && !0L &&     !0L && !0L && !0L && !0L &&     !0L && !0L && !0L && !0L &&     !0L && !0L && !0L
S  /* #define STM32F405xx */   /*!< STM32F405RG, STM32F405VG and STM32F405ZG Devices */
S  /* #define STM32F415xx */   /*!< STM32F415RG, STM32F415VG and STM32F415ZG Devices */
S  /* #define STM32F407xx */   /*!< STM32F407VG, STM32F407VE, STM32F407ZG, STM32F407ZE, STM32F407IG  and STM32F407IE Devices */
S  /* #define STM32F417xx */   /*!< STM32F417VG, STM32F417VE, STM32F417ZG, STM32F417ZE, STM32F417IG and STM32F417IE Devices */
S  /* #define STM32F427xx */   /*!< STM32F427VG, STM32F427VI, STM32F427ZG, STM32F427ZI, STM32F427IG and STM32F427II Devices */
S  /* #define STM32F437xx */   /*!< STM32F437VG, STM32F437VI, STM32F437ZG, STM32F437ZI, STM32F437IG and STM32F437II Devices */
S  /* #define STM32F429xx */   /*!< STM32F429VG, STM32F429VI, STM32F429ZG, STM32F429ZI, STM32F429BG, STM32F429BI, STM32F429NG, 
S                                   STM32F439NI, STM32F429IG  and STM32F429II Devices */
S  /* #define STM32F439xx */   /*!< STM32F439VG, STM32F439VI, STM32F439ZG, STM32F439ZI, STM32F439BG, STM32F439BI, STM32F439NG, 
S                                   STM32F439NI, STM32F439IG and STM32F439II Devices */
S  /* #define STM32F401xC */   /*!< STM32F401CB, STM32F401CC, STM32F401RB, STM32F401RC, STM32F401VB and STM32F401VC Devices */
S  /* #define STM32F401xE */   /*!< STM32F401CD, STM32F401RD, STM32F401VD, STM32F401CE, STM32F401RE and STM32F401VE Devices */
S  /* #define STM32F410Tx */   /*!< STM32F410T8 and STM32F410TB Devices */
S  /* #define STM32F410Cx */   /*!< STM32F410C8 and STM32F410CB Devices */
S  /* #define STM32F410Rx */   /*!< STM32F410R8 and STM32F410RB Devices */
S  /* #define STM32F411xE */   /*!< STM32F411CC, STM32F411RC, STM32F411VC, STM32F411CE, STM32F411RE and STM32F411VE Devices */
S  /* #define STM32F446xx */   /*!< STM32F446MC, STM32F446ME, STM32F446RC, STM32F446RE, STM32F446VC, STM32F446VE, STM32F446ZC, 
S                                   and STM32F446ZE Devices */
S  /* #define STM32F469xx */   /*!< STM32F469AI, STM32F469II, STM32F469BI, STM32F469NI, STM32F469AG, STM32F469IG, STM32F469BG, 
S                                   STM32F469NG, STM32F469AE, STM32F469IE, STM32F469BE and STM32F469NE Devices */
S  /* #define STM32F479xx */   /*!< STM32F479AI, STM32F479II, STM32F479BI, STM32F479NI, STM32F479AG, STM32F479IG, STM32F479BG 
S                                   and STM32F479NG Devices */
S  /* #define STM32F412Cx */   /*!< STM32F412CEU and STM32F412CGU Devices */
S  /* #define STM32F412Zx */   /*!< STM32F412ZET, STM32F412ZGT, STM32F412ZEJ and STM32F412ZGJ Devices */
S  /* #define STM32F412Vx */   /*!< STM32F412VET, STM32F412VGT, STM32F412VEH and STM32F412VGH Devices */
S  /* #define STM32F412Rx */   /*!< STM32F412RET, STM32F412RGT, STM32F412REY and STM32F412RGY Devices */
S  /* #define STM32F413xx */   /*!< STM32F413CH, STM32F413MH, STM32F413RH, STM32F413VH, STM32F413ZH, STM32F413CG, STM32F413MG,
S                                   STM32F413RG, STM32F413VG and STM32F413ZG Devices */
S  /* #define STM32F423xx */   /*!< STM32F423CH, STM32F423RH, STM32F423VH and STM32F423ZH Devices */
N#endif
N   
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N#if !defined  (USE_HAL_DRIVER)
X#if !0L
N/**
N * @brief Comment the line below if you will not use the peripherals drivers.
N   In this case, these drivers will not be included and the application code will 
N   be based on direct access to peripherals registers 
N   */
N  /*#define USE_HAL_DRIVER */
N#endif /* USE_HAL_DRIVER */
N
N/**
N  * @brief CMSIS version number V2.6.7
N  */
N#define __STM32F4xx_CMSIS_VERSION_MAIN   (0x02U) /*!< [31:24] main version */
N#define __STM32F4xx_CMSIS_VERSION_SUB1   (0x06U) /*!< [23:16] sub1 version */
N#define __STM32F4xx_CMSIS_VERSION_SUB2   (0x07U) /*!< [15:8]  sub2 version */
N#define __STM32F4xx_CMSIS_VERSION_RC     (0x00U) /*!< [7:0]  release candidate */
N#define __STM32F4xx_CMSIS_VERSION        ((__STM32F4xx_CMSIS_VERSION_MAIN << 24)\
N                                         |(__STM32F4xx_CMSIS_VERSION_SUB1 << 16)\
N                                         |(__STM32F4xx_CMSIS_VERSION_SUB2 << 8 )\
N                                         |(__STM32F4xx_CMSIS_VERSION_RC))
X#define __STM32F4xx_CMSIS_VERSION        ((__STM32F4xx_CMSIS_VERSION_MAIN << 24)                                         |(__STM32F4xx_CMSIS_VERSION_SUB1 << 16)                                         |(__STM32F4xx_CMSIS_VERSION_SUB2 << 8 )                                         |(__STM32F4xx_CMSIS_VERSION_RC))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Device_Included
N  * @{
N  */
N
N#if defined(STM32F405xx)
X#if 0L
S  #include "stm32f405xx.h"
S#elif defined(STM32F415xx)
X#elif 0L
S  #include "stm32f415xx.h"
N#elif defined(STM32F407xx)
X#elif 1L
N  #include "stm32f407xx.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f407xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f407xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS STM32F407xx Device Peripheral Access Layer Header File.
N  *
N  *          This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - peripherals registers declarations and bits definition
N  *           - Macros to access peripherals registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS_Device
N  * @{
N  */
N
N/** @addtogroup stm32f407xx
N  * @{
N  */
N    
N#ifndef __STM32F407xx_H
N#define __STM32F407xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N  * @brief Configuration of the Cortex-M4 Processor and Core Peripherals 
N  */
N#define __CM4_REV                 0x0001U  /*!< Core revision r0p1                            */
N#define __MPU_PRESENT             1U       /*!< STM32F4XX provides an MPU                     */
N#define __NVIC_PRIO_BITS          4U       /*!< STM32F4XX uses 4 Bits for the Priority Levels */
N#define __Vendor_SysTickConfig    0U       /*!< Set to 1 if different SysTick Config is used  */
N#define __FPU_PRESENT             1U       /*!< FPU present                                   */
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_interrupt_number_definition
N  * @{
N  */
N
N/**
N * @brief STM32F4XX Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
Ntypedef enum
N{
N/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
N  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                           */
N  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                   */
N  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                 */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                    */
N  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                              */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                    */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                */
N/******  STM32 specific Interrupt Numbers **********************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
N  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt                         */
N  TAMP_STAMP_IRQn             = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI line             */
N  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line                        */
N  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                            */
N  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                              */
N  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                              */
N  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                              */
N  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                              */
N  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                              */
N  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                              */
N  DMA1_Stream0_IRQn           = 11,     /*!< DMA1 Stream 0 global Interrupt                                    */
N  DMA1_Stream1_IRQn           = 12,     /*!< DMA1 Stream 1 global Interrupt                                    */
N  DMA1_Stream2_IRQn           = 13,     /*!< DMA1 Stream 2 global Interrupt                                    */
N  DMA1_Stream3_IRQn           = 14,     /*!< DMA1 Stream 3 global Interrupt                                    */
N  DMA1_Stream4_IRQn           = 15,     /*!< DMA1 Stream 4 global Interrupt                                    */
N  DMA1_Stream5_IRQn           = 16,     /*!< DMA1 Stream 5 global Interrupt                                    */
N  DMA1_Stream6_IRQn           = 17,     /*!< DMA1 Stream 6 global Interrupt                                    */
N  ADC_IRQn                    = 18,     /*!< ADC1, ADC2 and ADC3 global Interrupts                             */
N  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
N  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
N  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
N  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
N  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
N  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
N  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
N  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
N  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
N  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
N  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
N  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
N  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
N  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
N  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
N  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
N  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
N  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
N  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
N  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
N  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
N  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
N  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
N  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
N  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
N  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
N  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
N  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare global interrupt                             */
N  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
N  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                             */
N  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
N  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
N  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
N  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
N  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
N  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
N  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
N  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
N  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
N  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
N  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
N  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
N  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
N  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
N  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
N  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
N  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
N  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
N  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
N  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
N  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
N  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
N  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
N  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
N  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
N  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
N  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
N  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
N  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
N  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
N  RNG_IRQn                    = 80,     /*!< RNG global Interrupt                                              */
N  FPU_IRQn                    = 81      /*!< FPU global interrupt                                               */
N} IRQn_Type;
N/* Legacy define */
N#define  HASH_RNG_IRQn      RNG_IRQn
N
N/**
N  * @}
N  */
N
N#include "core_cm4.h"             /* Cortex-M4 processor and core peripherals */
L 1 "D:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM4_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x04U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1U)
X    #if (1U == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "D:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "D:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060183 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x04U) == 0x04U) || ((0x04U) == 0x07U)
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1U == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1U == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060183 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x04U) >= 0x04U)   
N
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
N
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "D:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 211 "D:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cm4.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "D:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 212 "D:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cm4.h" 2
N#include "core_cmSimd.h"                 /* Compiler specific SIMD Intrinsics */
L 1 "D:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cmSimd.h" 1
N/**************************************************************************//**
N * @file     core_cmSimd.h
N * @brief    CMSIS Cortex-M SIMD Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMSIMD_H
N#define __CORE_CMSIMD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CMSIMD_H */
L 213 "D:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include\core_cm4.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1U)
X#if (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#if (__FPU_PRESENT == 1U)
X#if (1U == 1U)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in NVIC and returns the active bit.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 4U)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 4U)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 4U)));
N  }
N  else
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 4U)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4U)) ? (uint32_t)(4U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4U));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4U)) ? (uint32_t)(4U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4U));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0U == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 4U) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != 0x5AA55AA5U)
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5U;        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == 0x5AA55AA5U)
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 168 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f407xx.h" 2
N#include "system_stm32f4xx.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include\system_stm32f4xx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_stm32f4xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS Cortex-M4 Device System Source File for STM32F4xx devices.       
N  ******************************************************************************  
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f4xx_system
N  * @{
N  */  
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_STM32F4XX_H
N#define __SYSTEM_STM32F4XX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/** @addtogroup STM32F4xx_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup STM32F4xx_System_Exported_types
N  * @{
N  */
N  /* This variable is updated in three ways:
N      1) by calling CMSIS function SystemCoreClockUpdate()
N      2) by calling HAL API function HAL_RCC_GetSysClockFreq()
N      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency 
N         Note: If you use this function to configure the system clock; then there
N               is no need to call the 2 first functions listed above, since SystemCoreClock
N               variable is updated automatically.
N  */
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
N
Nextern const uint8_t  AHBPrescTable[16];    /*!< AHB prescalers table values */
Nextern const uint8_t  APBPrescTable[8];     /*!< APB prescalers table values */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F4xx_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F4xx_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F4xx_System_Exported_Functions
N  * @{
N  */
N  
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__SYSTEM_STM32F4XX_H */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 169 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f407xx.h" 2
N#include <stdint.h>
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */   
N
N/** 
N  * @brief Analog to Digital Converter  
N  */
N
Ntypedef struct
N{
N  __IO uint32_t SR;     /*!< ADC status register,                         Address offset: 0x00 */
X  volatile uint32_t SR;      
N  __IO uint32_t CR1;    /*!< ADC control register 1,                      Address offset: 0x04 */
X  volatile uint32_t CR1;     
N  __IO uint32_t CR2;    /*!< ADC control register 2,                      Address offset: 0x08 */
X  volatile uint32_t CR2;     
N  __IO uint32_t SMPR1;  /*!< ADC sample time register 1,                  Address offset: 0x0C */
X  volatile uint32_t SMPR1;   
N  __IO uint32_t SMPR2;  /*!< ADC sample time register 2,                  Address offset: 0x10 */
X  volatile uint32_t SMPR2;   
N  __IO uint32_t JOFR1;  /*!< ADC injected channel data offset register 1, Address offset: 0x14 */
X  volatile uint32_t JOFR1;   
N  __IO uint32_t JOFR2;  /*!< ADC injected channel data offset register 2, Address offset: 0x18 */
X  volatile uint32_t JOFR2;   
N  __IO uint32_t JOFR3;  /*!< ADC injected channel data offset register 3, Address offset: 0x1C */
X  volatile uint32_t JOFR3;   
N  __IO uint32_t JOFR4;  /*!< ADC injected channel data offset register 4, Address offset: 0x20 */
X  volatile uint32_t JOFR4;   
N  __IO uint32_t HTR;    /*!< ADC watchdog higher threshold register,      Address offset: 0x24 */
X  volatile uint32_t HTR;     
N  __IO uint32_t LTR;    /*!< ADC watchdog lower threshold register,       Address offset: 0x28 */
X  volatile uint32_t LTR;     
N  __IO uint32_t SQR1;   /*!< ADC regular sequence register 1,             Address offset: 0x2C */
X  volatile uint32_t SQR1;    
N  __IO uint32_t SQR2;   /*!< ADC regular sequence register 2,             Address offset: 0x30 */
X  volatile uint32_t SQR2;    
N  __IO uint32_t SQR3;   /*!< ADC regular sequence register 3,             Address offset: 0x34 */
X  volatile uint32_t SQR3;    
N  __IO uint32_t JSQR;   /*!< ADC injected sequence register,              Address offset: 0x38*/
X  volatile uint32_t JSQR;    
N  __IO uint32_t JDR1;   /*!< ADC injected data register 1,                Address offset: 0x3C */
X  volatile uint32_t JDR1;    
N  __IO uint32_t JDR2;   /*!< ADC injected data register 2,                Address offset: 0x40 */
X  volatile uint32_t JDR2;    
N  __IO uint32_t JDR3;   /*!< ADC injected data register 3,                Address offset: 0x44 */
X  volatile uint32_t JDR3;    
N  __IO uint32_t JDR4;   /*!< ADC injected data register 4,                Address offset: 0x48 */
X  volatile uint32_t JDR4;    
N  __IO uint32_t DR;     /*!< ADC regular data register,                   Address offset: 0x4C */
X  volatile uint32_t DR;      
N} ADC_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CSR;    /*!< ADC Common status register,                  Address offset: ADC1 base address + 0x300 */
X  volatile uint32_t CSR;     
N  __IO uint32_t CCR;    /*!< ADC common control register,                 Address offset: ADC1 base address + 0x304 */
X  volatile uint32_t CCR;     
N  __IO uint32_t CDR;    /*!< ADC common regular data register for dual
X  volatile uint32_t CDR;    
N                             AND triple modes,                            Address offset: ADC1 base address + 0x308 */
N} ADC_Common_TypeDef;
N
N
N/** 
N  * @brief Controller Area Network TxMailBox 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TIR;  /*!< CAN TX mailbox identifier register */
X  volatile uint32_t TIR;   
N  __IO uint32_t TDTR; /*!< CAN mailbox data length control and time stamp register */
X  volatile uint32_t TDTR;  
N  __IO uint32_t TDLR; /*!< CAN mailbox data low register */
X  volatile uint32_t TDLR;  
N  __IO uint32_t TDHR; /*!< CAN mailbox data high register */
X  volatile uint32_t TDHR;  
N} CAN_TxMailBox_TypeDef;
N
N/** 
N  * @brief Controller Area Network FIFOMailBox 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t RIR;  /*!< CAN receive FIFO mailbox identifier register */
X  volatile uint32_t RIR;   
N  __IO uint32_t RDTR; /*!< CAN receive FIFO mailbox data length control and time stamp register */
X  volatile uint32_t RDTR;  
N  __IO uint32_t RDLR; /*!< CAN receive FIFO mailbox data low register */
X  volatile uint32_t RDLR;  
N  __IO uint32_t RDHR; /*!< CAN receive FIFO mailbox data high register */
X  volatile uint32_t RDHR;  
N} CAN_FIFOMailBox_TypeDef;
N
N/** 
N  * @brief Controller Area Network FilterRegister 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t FR1; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR1;  
N  __IO uint32_t FR2; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR2;  
N} CAN_FilterRegister_TypeDef;
N
N/** 
N  * @brief Controller Area Network 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t              MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
X  volatile uint32_t              MCR;                  
N  __IO uint32_t              MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
X  volatile uint32_t              MSR;                  
N  __IO uint32_t              TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
X  volatile uint32_t              TSR;                  
N  __IO uint32_t              RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
X  volatile uint32_t              RF0R;                 
N  __IO uint32_t              RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
X  volatile uint32_t              RF1R;                 
N  __IO uint32_t              IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
X  volatile uint32_t              IER;                  
N  __IO uint32_t              ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
X  volatile uint32_t              ESR;                  
N  __IO uint32_t              BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
X  volatile uint32_t              BTR;                  
N  uint32_t                   RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
N  CAN_TxMailBox_TypeDef      sTxMailBox[3];       /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
N  CAN_FIFOMailBox_TypeDef    sFIFOMailBox[2];     /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
N  uint32_t                   RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
N  __IO uint32_t              FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
X  volatile uint32_t              FMR;                  
N  __IO uint32_t              FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
X  volatile uint32_t              FM1R;                 
N  uint32_t                   RESERVED2;           /*!< Reserved, 0x208                                                    */
N  __IO uint32_t              FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
X  volatile uint32_t              FS1R;                 
N  uint32_t                   RESERVED3;           /*!< Reserved, 0x210                                                    */
N  __IO uint32_t              FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
X  volatile uint32_t              FFA1R;                
N  uint32_t                   RESERVED4;           /*!< Reserved, 0x218                                                    */
N  __IO uint32_t              FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
X  volatile uint32_t              FA1R;                 
N  uint32_t                   RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */ 
N  CAN_FilterRegister_TypeDef sFilterRegister[28]; /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
N} CAN_TypeDef;
N
N/** 
N  * @brief CRC calculation unit 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;         /*!< CRC Data register,             Address offset: 0x00 */
X  volatile uint32_t DR;          
N  __IO uint8_t  IDR;        /*!< CRC Independent data register, Address offset: 0x04 */
X  volatile uint8_t  IDR;         
N  uint8_t       RESERVED0;  /*!< Reserved, 0x05                                      */
N  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                      */
N  __IO uint32_t CR;         /*!< CRC Control register,          Address offset: 0x08 */
X  volatile uint32_t CR;          
N} CRC_TypeDef;
N
N/** 
N  * @brief Digital to Analog Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;       /*!< DAC control register,                                    Address offset: 0x00 */
X  volatile uint32_t CR;        
N  __IO uint32_t SWTRIGR;  /*!< DAC software trigger register,                           Address offset: 0x04 */
X  volatile uint32_t SWTRIGR;   
N  __IO uint32_t DHR12R1;  /*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 */
X  volatile uint32_t DHR12R1;   
N  __IO uint32_t DHR12L1;  /*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C */
X  volatile uint32_t DHR12L1;   
N  __IO uint32_t DHR8R1;   /*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 */
X  volatile uint32_t DHR8R1;    
N  __IO uint32_t DHR12R2;  /*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 */
X  volatile uint32_t DHR12R2;   
N  __IO uint32_t DHR12L2;  /*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 */
X  volatile uint32_t DHR12L2;   
N  __IO uint32_t DHR8R2;   /*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C */
X  volatile uint32_t DHR8R2;    
N  __IO uint32_t DHR12RD;  /*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 */
X  volatile uint32_t DHR12RD;   
N  __IO uint32_t DHR12LD;  /*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 */
X  volatile uint32_t DHR12LD;   
N  __IO uint32_t DHR8RD;   /*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 */
X  volatile uint32_t DHR8RD;    
N  __IO uint32_t DOR1;     /*!< DAC channel1 data output register,                       Address offset: 0x2C */
X  volatile uint32_t DOR1;      
N  __IO uint32_t DOR2;     /*!< DAC channel2 data output register,                       Address offset: 0x30 */
X  volatile uint32_t DOR2;      
N  __IO uint32_t SR;       /*!< DAC status register,                                     Address offset: 0x34 */
X  volatile uint32_t SR;        
N} DAC_TypeDef;
N
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;  /*!< MCU device ID code,               Address offset: 0x00 */
X  volatile uint32_t IDCODE;   
N  __IO uint32_t CR;      /*!< Debug MCU configuration register, Address offset: 0x04 */
X  volatile uint32_t CR;       
N  __IO uint32_t APB1FZ;  /*!< Debug MCU APB1 freeze register,   Address offset: 0x08 */
X  volatile uint32_t APB1FZ;   
N  __IO uint32_t APB2FZ;  /*!< Debug MCU APB2 freeze register,   Address offset: 0x0C */
X  volatile uint32_t APB2FZ;   
N}DBGMCU_TypeDef;
N
N/** 
N  * @brief DCMI
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;       /*!< DCMI control register 1,                       Address offset: 0x00 */
X  volatile uint32_t CR;        
N  __IO uint32_t SR;       /*!< DCMI status register,                          Address offset: 0x04 */
X  volatile uint32_t SR;        
N  __IO uint32_t RISR;     /*!< DCMI raw interrupt status register,            Address offset: 0x08 */
X  volatile uint32_t RISR;      
N  __IO uint32_t IER;      /*!< DCMI interrupt enable register,                Address offset: 0x0C */
X  volatile uint32_t IER;       
N  __IO uint32_t MISR;     /*!< DCMI masked interrupt status register,         Address offset: 0x10 */
X  volatile uint32_t MISR;      
N  __IO uint32_t ICR;      /*!< DCMI interrupt clear register,                 Address offset: 0x14 */
X  volatile uint32_t ICR;       
N  __IO uint32_t ESCR;     /*!< DCMI embedded synchronization code register,   Address offset: 0x18 */
X  volatile uint32_t ESCR;      
N  __IO uint32_t ESUR;     /*!< DCMI embedded synchronization unmask register, Address offset: 0x1C */
X  volatile uint32_t ESUR;      
N  __IO uint32_t CWSTRTR;  /*!< DCMI crop window start,                        Address offset: 0x20 */
X  volatile uint32_t CWSTRTR;   
N  __IO uint32_t CWSIZER;  /*!< DCMI crop window size,                         Address offset: 0x24 */
X  volatile uint32_t CWSIZER;   
N  __IO uint32_t DR;       /*!< DCMI data register,                            Address offset: 0x28 */
X  volatile uint32_t DR;        
N} DCMI_TypeDef;
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;     /*!< DMA stream x configuration register      */
X  volatile uint32_t CR;      
N  __IO uint32_t NDTR;   /*!< DMA stream x number of data register     */
X  volatile uint32_t NDTR;    
N  __IO uint32_t PAR;    /*!< DMA stream x peripheral address register */
X  volatile uint32_t PAR;     
N  __IO uint32_t M0AR;   /*!< DMA stream x memory 0 address register   */
X  volatile uint32_t M0AR;    
N  __IO uint32_t M1AR;   /*!< DMA stream x memory 1 address register   */
X  volatile uint32_t M1AR;    
N  __IO uint32_t FCR;    /*!< DMA stream x FIFO control register       */
X  volatile uint32_t FCR;     
N} DMA_Stream_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t LISR;   /*!< DMA low interrupt status register,      Address offset: 0x00 */
X  volatile uint32_t LISR;    
N  __IO uint32_t HISR;   /*!< DMA high interrupt status register,     Address offset: 0x04 */
X  volatile uint32_t HISR;    
N  __IO uint32_t LIFCR;  /*!< DMA low interrupt flag clear register,  Address offset: 0x08 */
X  volatile uint32_t LIFCR;   
N  __IO uint32_t HIFCR;  /*!< DMA high interrupt flag clear register, Address offset: 0x0C */
X  volatile uint32_t HIFCR;   
N} DMA_TypeDef;
N
N/** 
N  * @brief Ethernet MAC
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MACCR;
X  volatile uint32_t MACCR;
N  __IO uint32_t MACFFR;
X  volatile uint32_t MACFFR;
N  __IO uint32_t MACHTHR;
X  volatile uint32_t MACHTHR;
N  __IO uint32_t MACHTLR;
X  volatile uint32_t MACHTLR;
N  __IO uint32_t MACMIIAR;
X  volatile uint32_t MACMIIAR;
N  __IO uint32_t MACMIIDR;
X  volatile uint32_t MACMIIDR;
N  __IO uint32_t MACFCR;
X  volatile uint32_t MACFCR;
N  __IO uint32_t MACVLANTR;             /*    8 */
X  volatile uint32_t MACVLANTR;              
N  uint32_t      RESERVED0[2];
N  __IO uint32_t MACRWUFFR;             /*   11 */
X  volatile uint32_t MACRWUFFR;              
N  __IO uint32_t MACPMTCSR;
X  volatile uint32_t MACPMTCSR;
N  uint32_t      RESERVED1;
N  __IO uint32_t MACDBGR;
X  volatile uint32_t MACDBGR;
N  __IO uint32_t MACSR;                 /*   15 */
X  volatile uint32_t MACSR;                  
N  __IO uint32_t MACIMR;
X  volatile uint32_t MACIMR;
N  __IO uint32_t MACA0HR;
X  volatile uint32_t MACA0HR;
N  __IO uint32_t MACA0LR;
X  volatile uint32_t MACA0LR;
N  __IO uint32_t MACA1HR;
X  volatile uint32_t MACA1HR;
N  __IO uint32_t MACA1LR;
X  volatile uint32_t MACA1LR;
N  __IO uint32_t MACA2HR;
X  volatile uint32_t MACA2HR;
N  __IO uint32_t MACA2LR;
X  volatile uint32_t MACA2LR;
N  __IO uint32_t MACA3HR;
X  volatile uint32_t MACA3HR;
N  __IO uint32_t MACA3LR;               /*   24 */
X  volatile uint32_t MACA3LR;                
N  uint32_t      RESERVED2[40];
N  __IO uint32_t MMCCR;                 /*   65 */
X  volatile uint32_t MMCCR;                  
N  __IO uint32_t MMCRIR;
X  volatile uint32_t MMCRIR;
N  __IO uint32_t MMCTIR;
X  volatile uint32_t MMCTIR;
N  __IO uint32_t MMCRIMR;
X  volatile uint32_t MMCRIMR;
N  __IO uint32_t MMCTIMR;               /*   69 */
X  volatile uint32_t MMCTIMR;                
N  uint32_t      RESERVED3[14];
N  __IO uint32_t MMCTGFSCCR;            /*   84 */
X  volatile uint32_t MMCTGFSCCR;             
N  __IO uint32_t MMCTGFMSCCR;
X  volatile uint32_t MMCTGFMSCCR;
N  uint32_t      RESERVED4[5];
N  __IO uint32_t MMCTGFCR;
X  volatile uint32_t MMCTGFCR;
N  uint32_t      RESERVED5[10];
N  __IO uint32_t MMCRFCECR;
X  volatile uint32_t MMCRFCECR;
N  __IO uint32_t MMCRFAECR;
X  volatile uint32_t MMCRFAECR;
N  uint32_t      RESERVED6[10];
N  __IO uint32_t MMCRGUFCR;
X  volatile uint32_t MMCRGUFCR;
N  uint32_t      RESERVED7[334];
N  __IO uint32_t PTPTSCR;
X  volatile uint32_t PTPTSCR;
N  __IO uint32_t PTPSSIR;
X  volatile uint32_t PTPSSIR;
N  __IO uint32_t PTPTSHR;
X  volatile uint32_t PTPTSHR;
N  __IO uint32_t PTPTSLR;
X  volatile uint32_t PTPTSLR;
N  __IO uint32_t PTPTSHUR;
X  volatile uint32_t PTPTSHUR;
N  __IO uint32_t PTPTSLUR;
X  volatile uint32_t PTPTSLUR;
N  __IO uint32_t PTPTSAR;
X  volatile uint32_t PTPTSAR;
N  __IO uint32_t PTPTTHR;
X  volatile uint32_t PTPTTHR;
N  __IO uint32_t PTPTTLR;
X  volatile uint32_t PTPTTLR;
N  __IO uint32_t RESERVED8;
X  volatile uint32_t RESERVED8;
N  __IO uint32_t PTPTSSR;
X  volatile uint32_t PTPTSSR;
N  uint32_t      RESERVED9[565];
N  __IO uint32_t DMABMR;
X  volatile uint32_t DMABMR;
N  __IO uint32_t DMATPDR;
X  volatile uint32_t DMATPDR;
N  __IO uint32_t DMARPDR;
X  volatile uint32_t DMARPDR;
N  __IO uint32_t DMARDLAR;
X  volatile uint32_t DMARDLAR;
N  __IO uint32_t DMATDLAR;
X  volatile uint32_t DMATDLAR;
N  __IO uint32_t DMASR;
X  volatile uint32_t DMASR;
N  __IO uint32_t DMAOMR;
X  volatile uint32_t DMAOMR;
N  __IO uint32_t DMAIER;
X  volatile uint32_t DMAIER;
N  __IO uint32_t DMAMFBOCR;
X  volatile uint32_t DMAMFBOCR;
N  __IO uint32_t DMARSWTR;
X  volatile uint32_t DMARSWTR;
N  uint32_t      RESERVED10[8];
N  __IO uint32_t DMACHTDR;
X  volatile uint32_t DMACHTDR;
N  __IO uint32_t DMACHRDR;
X  volatile uint32_t DMACHRDR;
N  __IO uint32_t DMACHTBAR;
X  volatile uint32_t DMACHTBAR;
N  __IO uint32_t DMACHRBAR;
X  volatile uint32_t DMACHRBAR;
N} ETH_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;    /*!< EXTI Interrupt mask register,            Address offset: 0x00 */
X  volatile uint32_t IMR;     
N  __IO uint32_t EMR;    /*!< EXTI Event mask register,                Address offset: 0x04 */
X  volatile uint32_t EMR;     
N  __IO uint32_t RTSR;   /*!< EXTI Rising trigger selection register,  Address offset: 0x08 */
X  volatile uint32_t RTSR;    
N  __IO uint32_t FTSR;   /*!< EXTI Falling trigger selection register, Address offset: 0x0C */
X  volatile uint32_t FTSR;    
N  __IO uint32_t SWIER;  /*!< EXTI Software interrupt event register,  Address offset: 0x10 */
X  volatile uint32_t SWIER;   
N  __IO uint32_t PR;     /*!< EXTI Pending register,                   Address offset: 0x14 */
X  volatile uint32_t PR;      
N} EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ACR;      /*!< FLASH access control register,   Address offset: 0x00 */
X  volatile uint32_t ACR;       
N  __IO uint32_t KEYR;     /*!< FLASH key register,              Address offset: 0x04 */
X  volatile uint32_t KEYR;      
N  __IO uint32_t OPTKEYR;  /*!< FLASH option key register,       Address offset: 0x08 */
X  volatile uint32_t OPTKEYR;   
N  __IO uint32_t SR;       /*!< FLASH status register,           Address offset: 0x0C */
X  volatile uint32_t SR;        
N  __IO uint32_t CR;       /*!< FLASH control register,          Address offset: 0x10 */
X  volatile uint32_t CR;        
N  __IO uint32_t OPTCR;    /*!< FLASH option control register ,  Address offset: 0x14 */
X  volatile uint32_t OPTCR;     
N  __IO uint32_t OPTCR1;   /*!< FLASH option control register 1, Address offset: 0x18 */
X  volatile uint32_t OPTCR1;    
N} FLASH_TypeDef;
N
N
N
N/** 
N  * @brief Flexible Static Memory Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t BTCR[8];    /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */   
X  volatile uint32_t BTCR[8];        
N} FSMC_Bank1_TypeDef;
N
N/** 
N  * @brief Flexible Static Memory Controller Bank1E
N  */
N
Ntypedef struct
N{
N  __IO uint32_t BWTR[7];    /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
X  volatile uint32_t BWTR[7];     
N} FSMC_Bank1E_TypeDef;
N
N/** 
N  * @brief Flexible Static Memory Controller Bank2
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t PCR2;       /*!< NAND Flash control register 2,                       Address offset: 0x60 */
X  volatile uint32_t PCR2;        
N  __IO uint32_t SR2;        /*!< NAND Flash FIFO status and interrupt register 2,     Address offset: 0x64 */
X  volatile uint32_t SR2;         
N  __IO uint32_t PMEM2;      /*!< NAND Flash Common memory space timing register 2,    Address offset: 0x68 */
X  volatile uint32_t PMEM2;       
N  __IO uint32_t PATT2;      /*!< NAND Flash Attribute memory space timing register 2, Address offset: 0x6C */
X  volatile uint32_t PATT2;       
N  uint32_t      RESERVED0;  /*!< Reserved, 0x70                                                            */
N  __IO uint32_t ECCR2;      /*!< NAND Flash ECC result registers 2,                   Address offset: 0x74 */
X  volatile uint32_t ECCR2;       
N  uint32_t      RESERVED1;  /*!< Reserved, 0x78                                                            */
N  uint32_t      RESERVED2;  /*!< Reserved, 0x7C                                                            */
N  __IO uint32_t PCR3;       /*!< NAND Flash control register 3,                       Address offset: 0x80 */
X  volatile uint32_t PCR3;        
N  __IO uint32_t SR3;        /*!< NAND Flash FIFO status and interrupt register 3,     Address offset: 0x84 */
X  volatile uint32_t SR3;         
N  __IO uint32_t PMEM3;      /*!< NAND Flash Common memory space timing register 3,    Address offset: 0x88 */
X  volatile uint32_t PMEM3;       
N  __IO uint32_t PATT3;      /*!< NAND Flash Attribute memory space timing register 3, Address offset: 0x8C */
X  volatile uint32_t PATT3;       
N  uint32_t      RESERVED3;  /*!< Reserved, 0x90                                                            */
N  __IO uint32_t ECCR3;      /*!< NAND Flash ECC result registers 3,                   Address offset: 0x94 */
X  volatile uint32_t ECCR3;       
N} FSMC_Bank2_3_TypeDef;
N
N/** 
N  * @brief Flexible Static Memory Controller Bank4
N  */
N
Ntypedef struct
N{
N  __IO uint32_t PCR4;       /*!< PC Card  control register 4,                       Address offset: 0xA0 */
X  volatile uint32_t PCR4;        
N  __IO uint32_t SR4;        /*!< PC Card  FIFO status and interrupt register 4,     Address offset: 0xA4 */
X  volatile uint32_t SR4;         
N  __IO uint32_t PMEM4;      /*!< PC Card  Common memory space timing register 4,    Address offset: 0xA8 */
X  volatile uint32_t PMEM4;       
N  __IO uint32_t PATT4;      /*!< PC Card  Attribute memory space timing register 4, Address offset: 0xAC */
X  volatile uint32_t PATT4;       
N  __IO uint32_t PIO4;       /*!< PC Card  I/O space timing register 4,              Address offset: 0xB0 */
X  volatile uint32_t PIO4;        
N} FSMC_Bank4_TypeDef; 
N
N/** 
N  * @brief General Purpose I/O
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00      */
X  volatile uint32_t MODER;     
N  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04      */
X  volatile uint32_t OTYPER;    
N  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08      */
X  volatile uint32_t OSPEEDR;   
N  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
X  volatile uint32_t PUPDR;     
N  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10      */
X  volatile uint32_t IDR;       
N  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14      */
X  volatile uint32_t ODR;       
N  __IO uint32_t BSRR;     /*!< GPIO port bit set/reset register,      Address offset: 0x18      */
X  volatile uint32_t BSRR;      
N  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C      */
X  volatile uint32_t LCKR;      
N  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];    
N} GPIO_TypeDef;
N
N/** 
N  * @brief System configuration controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MEMRMP;       /*!< SYSCFG memory remap register,                      Address offset: 0x00      */
X  volatile uint32_t MEMRMP;        
N  __IO uint32_t PMC;          /*!< SYSCFG peripheral mode configuration register,     Address offset: 0x04      */
X  volatile uint32_t PMC;           
N  __IO uint32_t EXTICR[4];    /*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 */
X  volatile uint32_t EXTICR[4];     
N  uint32_t      RESERVED[2];  /*!< Reserved, 0x18-0x1C                                                          */
N  __IO uint32_t CMPCR;        /*!< SYSCFG Compensation cell control register,         Address offset: 0x20      */
X  volatile uint32_t CMPCR;         
N} SYSCFG_TypeDef;
N
N/** 
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;        /*!< I2C Control register 1,     Address offset: 0x00 */
X  volatile uint32_t CR1;         
N  __IO uint32_t CR2;        /*!< I2C Control register 2,     Address offset: 0x04 */
X  volatile uint32_t CR2;         
N  __IO uint32_t OAR1;       /*!< I2C Own address register 1, Address offset: 0x08 */
X  volatile uint32_t OAR1;        
N  __IO uint32_t OAR2;       /*!< I2C Own address register 2, Address offset: 0x0C */
X  volatile uint32_t OAR2;        
N  __IO uint32_t DR;         /*!< I2C Data register,          Address offset: 0x10 */
X  volatile uint32_t DR;          
N  __IO uint32_t SR1;        /*!< I2C Status register 1,      Address offset: 0x14 */
X  volatile uint32_t SR1;         
N  __IO uint32_t SR2;        /*!< I2C Status register 2,      Address offset: 0x18 */
X  volatile uint32_t SR2;         
N  __IO uint32_t CCR;        /*!< I2C Clock control register, Address offset: 0x1C */
X  volatile uint32_t CCR;         
N  __IO uint32_t TRISE;      /*!< I2C TRISE register,         Address offset: 0x20 */
X  volatile uint32_t TRISE;       
N} I2C_TypeDef;
N
N/** 
N  * @brief Independent WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
X  volatile uint32_t KR;    
N  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
X  volatile uint32_t PR;    
N  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
X  volatile uint32_t RLR;   
N  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
X  volatile uint32_t SR;    
N} IWDG_TypeDef;
N
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
X  volatile uint32_t CSR;   
N} PWR_TypeDef;
N
N/** 
N  * @brief Reset and Clock Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< RCC clock control register,                                  Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t PLLCFGR;       /*!< RCC PLL configuration register,                              Address offset: 0x04 */
X  volatile uint32_t PLLCFGR;        
N  __IO uint32_t CFGR;          /*!< RCC clock configuration register,                            Address offset: 0x08 */
X  volatile uint32_t CFGR;           
N  __IO uint32_t CIR;           /*!< RCC clock interrupt register,                                Address offset: 0x0C */
X  volatile uint32_t CIR;            
N  __IO uint32_t AHB1RSTR;      /*!< RCC AHB1 peripheral reset register,                          Address offset: 0x10 */
X  volatile uint32_t AHB1RSTR;       
N  __IO uint32_t AHB2RSTR;      /*!< RCC AHB2 peripheral reset register,                          Address offset: 0x14 */
X  volatile uint32_t AHB2RSTR;       
N  __IO uint32_t AHB3RSTR;      /*!< RCC AHB3 peripheral reset register,                          Address offset: 0x18 */
X  volatile uint32_t AHB3RSTR;       
N  uint32_t      RESERVED0;     /*!< Reserved, 0x1C                                                                    */
N  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                          Address offset: 0x20 */
X  volatile uint32_t APB1RSTR;       
N  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                          Address offset: 0x24 */
X  volatile uint32_t APB2RSTR;       
N  uint32_t      RESERVED1[2];  /*!< Reserved, 0x28-0x2C                                                               */
N  __IO uint32_t AHB1ENR;       /*!< RCC AHB1 peripheral clock register,                          Address offset: 0x30 */
X  volatile uint32_t AHB1ENR;        
N  __IO uint32_t AHB2ENR;       /*!< RCC AHB2 peripheral clock register,                          Address offset: 0x34 */
X  volatile uint32_t AHB2ENR;        
N  __IO uint32_t AHB3ENR;       /*!< RCC AHB3 peripheral clock register,                          Address offset: 0x38 */
X  volatile uint32_t AHB3ENR;        
N  uint32_t      RESERVED2;     /*!< Reserved, 0x3C                                                                    */
N  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x40 */
X  volatile uint32_t APB1ENR;        
N  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x44 */
X  volatile uint32_t APB2ENR;        
N  uint32_t      RESERVED3[2];  /*!< Reserved, 0x48-0x4C                                                               */
N  __IO uint32_t AHB1LPENR;     /*!< RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 */
X  volatile uint32_t AHB1LPENR;      
N  __IO uint32_t AHB2LPENR;     /*!< RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 */
X  volatile uint32_t AHB2LPENR;      
N  __IO uint32_t AHB3LPENR;     /*!< RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 */
X  volatile uint32_t AHB3LPENR;      
N  uint32_t      RESERVED4;     /*!< Reserved, 0x5C                                                                    */
N  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 */
X  volatile uint32_t APB1LPENR;      
N  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 */
X  volatile uint32_t APB2LPENR;      
N  uint32_t      RESERVED5[2];  /*!< Reserved, 0x68-0x6C                                                               */
N  __IO uint32_t BDCR;          /*!< RCC Backup domain control register,                          Address offset: 0x70 */
X  volatile uint32_t BDCR;           
N  __IO uint32_t CSR;           /*!< RCC clock control & status register,                         Address offset: 0x74 */
X  volatile uint32_t CSR;            
N  uint32_t      RESERVED6[2];  /*!< Reserved, 0x78-0x7C                                                               */
N  __IO uint32_t SSCGR;         /*!< RCC spread spectrum clock generation register,               Address offset: 0x80 */
X  volatile uint32_t SSCGR;          
N  __IO uint32_t PLLI2SCFGR;    /*!< RCC PLLI2S configuration register,                           Address offset: 0x84 */
X  volatile uint32_t PLLI2SCFGR;     
N} RCC_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TR;      /*!< RTC time register,                                        Address offset: 0x00 */
X  volatile uint32_t TR;       
N  __IO uint32_t DR;      /*!< RTC date register,                                        Address offset: 0x04 */
X  volatile uint32_t DR;       
N  __IO uint32_t CR;      /*!< RTC control register,                                     Address offset: 0x08 */
X  volatile uint32_t CR;       
N  __IO uint32_t ISR;     /*!< RTC initialization and status register,                   Address offset: 0x0C */
X  volatile uint32_t ISR;      
N  __IO uint32_t PRER;    /*!< RTC prescaler register,                                   Address offset: 0x10 */
X  volatile uint32_t PRER;     
N  __IO uint32_t WUTR;    /*!< RTC wakeup timer register,                                Address offset: 0x14 */
X  volatile uint32_t WUTR;     
N  __IO uint32_t CALIBR;  /*!< RTC calibration register,                                 Address offset: 0x18 */
X  volatile uint32_t CALIBR;   
N  __IO uint32_t ALRMAR;  /*!< RTC alarm A register,                                     Address offset: 0x1C */
X  volatile uint32_t ALRMAR;   
N  __IO uint32_t ALRMBR;  /*!< RTC alarm B register,                                     Address offset: 0x20 */
X  volatile uint32_t ALRMBR;   
N  __IO uint32_t WPR;     /*!< RTC write protection register,                            Address offset: 0x24 */
X  volatile uint32_t WPR;      
N  __IO uint32_t SSR;     /*!< RTC sub second register,                                  Address offset: 0x28 */
X  volatile uint32_t SSR;      
N  __IO uint32_t SHIFTR;  /*!< RTC shift control register,                               Address offset: 0x2C */
X  volatile uint32_t SHIFTR;   
N  __IO uint32_t TSTR;    /*!< RTC time stamp time register,                             Address offset: 0x30 */
X  volatile uint32_t TSTR;     
N  __IO uint32_t TSDR;    /*!< RTC time stamp date register,                             Address offset: 0x34 */
X  volatile uint32_t TSDR;     
N  __IO uint32_t TSSSR;   /*!< RTC time-stamp sub second register,                       Address offset: 0x38 */
X  volatile uint32_t TSSSR;    
N  __IO uint32_t CALR;    /*!< RTC calibration register,                                 Address offset: 0x3C */
X  volatile uint32_t CALR;     
N  __IO uint32_t TAFCR;   /*!< RTC tamper and alternate function configuration register, Address offset: 0x40 */
X  volatile uint32_t TAFCR;    
N  __IO uint32_t ALRMASSR;/*!< RTC alarm A sub second register,                          Address offset: 0x44 */
X  volatile uint32_t ALRMASSR; 
N  __IO uint32_t ALRMBSSR;/*!< RTC alarm B sub second register,                          Address offset: 0x48 */
X  volatile uint32_t ALRMBSSR; 
N  uint32_t RESERVED7;    /*!< Reserved, 0x4C                                                                 */
N  __IO uint32_t BKP0R;   /*!< RTC backup register 1,                                    Address offset: 0x50 */
X  volatile uint32_t BKP0R;    
N  __IO uint32_t BKP1R;   /*!< RTC backup register 1,                                    Address offset: 0x54 */
X  volatile uint32_t BKP1R;    
N  __IO uint32_t BKP2R;   /*!< RTC backup register 2,                                    Address offset: 0x58 */
X  volatile uint32_t BKP2R;    
N  __IO uint32_t BKP3R;   /*!< RTC backup register 3,                                    Address offset: 0x5C */
X  volatile uint32_t BKP3R;    
N  __IO uint32_t BKP4R;   /*!< RTC backup register 4,                                    Address offset: 0x60 */
X  volatile uint32_t BKP4R;    
N  __IO uint32_t BKP5R;   /*!< RTC backup register 5,                                    Address offset: 0x64 */
X  volatile uint32_t BKP5R;    
N  __IO uint32_t BKP6R;   /*!< RTC backup register 6,                                    Address offset: 0x68 */
X  volatile uint32_t BKP6R;    
N  __IO uint32_t BKP7R;   /*!< RTC backup register 7,                                    Address offset: 0x6C */
X  volatile uint32_t BKP7R;    
N  __IO uint32_t BKP8R;   /*!< RTC backup register 8,                                    Address offset: 0x70 */
X  volatile uint32_t BKP8R;    
N  __IO uint32_t BKP9R;   /*!< RTC backup register 9,                                    Address offset: 0x74 */
X  volatile uint32_t BKP9R;    
N  __IO uint32_t BKP10R;  /*!< RTC backup register 10,                                   Address offset: 0x78 */
X  volatile uint32_t BKP10R;   
N  __IO uint32_t BKP11R;  /*!< RTC backup register 11,                                   Address offset: 0x7C */
X  volatile uint32_t BKP11R;   
N  __IO uint32_t BKP12R;  /*!< RTC backup register 12,                                   Address offset: 0x80 */
X  volatile uint32_t BKP12R;   
N  __IO uint32_t BKP13R;  /*!< RTC backup register 13,                                   Address offset: 0x84 */
X  volatile uint32_t BKP13R;   
N  __IO uint32_t BKP14R;  /*!< RTC backup register 14,                                   Address offset: 0x88 */
X  volatile uint32_t BKP14R;   
N  __IO uint32_t BKP15R;  /*!< RTC backup register 15,                                   Address offset: 0x8C */
X  volatile uint32_t BKP15R;   
N  __IO uint32_t BKP16R;  /*!< RTC backup register 16,                                   Address offset: 0x90 */
X  volatile uint32_t BKP16R;   
N  __IO uint32_t BKP17R;  /*!< RTC backup register 17,                                   Address offset: 0x94 */
X  volatile uint32_t BKP17R;   
N  __IO uint32_t BKP18R;  /*!< RTC backup register 18,                                   Address offset: 0x98 */
X  volatile uint32_t BKP18R;   
N  __IO uint32_t BKP19R;  /*!< RTC backup register 19,                                   Address offset: 0x9C */
X  volatile uint32_t BKP19R;   
N} RTC_TypeDef;
N
N/** 
N  * @brief SD host Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t POWER;                 /*!< SDIO power control register,    Address offset: 0x00 */
X  volatile uint32_t POWER;                  
N  __IO uint32_t CLKCR;                 /*!< SDI clock control register,     Address offset: 0x04 */
X  volatile uint32_t CLKCR;                  
N  __IO uint32_t ARG;                   /*!< SDIO argument register,         Address offset: 0x08 */
X  volatile uint32_t ARG;                    
N  __IO uint32_t CMD;                   /*!< SDIO command register,          Address offset: 0x0C */
X  volatile uint32_t CMD;                    
N  __IO const uint32_t  RESPCMD;        /*!< SDIO command response register, Address offset: 0x10 */
X  volatile const uint32_t  RESPCMD;         
N  __IO const uint32_t  RESP1;          /*!< SDIO response 1 register,       Address offset: 0x14 */
X  volatile const uint32_t  RESP1;           
N  __IO const uint32_t  RESP2;          /*!< SDIO response 2 register,       Address offset: 0x18 */
X  volatile const uint32_t  RESP2;           
N  __IO const uint32_t  RESP3;          /*!< SDIO response 3 register,       Address offset: 0x1C */
X  volatile const uint32_t  RESP3;           
N  __IO const uint32_t  RESP4;          /*!< SDIO response 4 register,       Address offset: 0x20 */
X  volatile const uint32_t  RESP4;           
N  __IO uint32_t DTIMER;                /*!< SDIO data timer register,       Address offset: 0x24 */
X  volatile uint32_t DTIMER;                 
N  __IO uint32_t DLEN;                  /*!< SDIO data length register,      Address offset: 0x28 */
X  volatile uint32_t DLEN;                   
N  __IO uint32_t DCTRL;                 /*!< SDIO data control register,     Address offset: 0x2C */
X  volatile uint32_t DCTRL;                  
N  __IO const uint32_t  DCOUNT;         /*!< SDIO data counter register,     Address offset: 0x30 */
X  volatile const uint32_t  DCOUNT;          
N  __IO const uint32_t  STA;            /*!< SDIO status register,           Address offset: 0x34 */
X  volatile const uint32_t  STA;             
N  __IO uint32_t ICR;                   /*!< SDIO interrupt clear register,  Address offset: 0x38 */
X  volatile uint32_t ICR;                    
N  __IO uint32_t MASK;                  /*!< SDIO mask register,             Address offset: 0x3C */
X  volatile uint32_t MASK;                   
N  uint32_t      RESERVED0[2];          /*!< Reserved, 0x40-0x44                                  */
N  __IO const uint32_t  FIFOCNT;        /*!< SDIO FIFO counter register,     Address offset: 0x48 */
X  volatile const uint32_t  FIFOCNT;         
N  uint32_t      RESERVED1[13];         /*!< Reserved, 0x4C-0x7C                                  */
N  __IO uint32_t FIFO;                  /*!< SDIO data FIFO register,        Address offset: 0x80 */
X  volatile uint32_t FIFO;                   
N} SDIO_TypeDef;
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;        /*!< SPI control register 1 (not used in I2S mode),      Address offset: 0x00 */
X  volatile uint32_t CR1;         
N  __IO uint32_t CR2;        /*!< SPI control register 2,                             Address offset: 0x04 */
X  volatile uint32_t CR2;         
N  __IO uint32_t SR;         /*!< SPI status register,                                Address offset: 0x08 */
X  volatile uint32_t SR;          
N  __IO uint32_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
X  volatile uint32_t DR;          
N  __IO uint32_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
X  volatile uint32_t CRCPR;       
N  __IO uint32_t RXCRCR;     /*!< SPI RX CRC register (not used in I2S mode),         Address offset: 0x14 */
X  volatile uint32_t RXCRCR;      
N  __IO uint32_t TXCRCR;     /*!< SPI TX CRC register (not used in I2S mode),         Address offset: 0x18 */
X  volatile uint32_t TXCRCR;      
N  __IO uint32_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
X  volatile uint32_t I2SCFGR;     
N  __IO uint32_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
X  volatile uint32_t I2SPR;       
N} SPI_TypeDef;
N
N
N/** 
N  * @brief TIM
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
X  volatile uint32_t CR1;          
N  __IO uint32_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
X  volatile uint32_t CR2;          
N  __IO uint32_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
X  volatile uint32_t SMCR;         
N  __IO uint32_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
X  volatile uint32_t DIER;         
N  __IO uint32_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
X  volatile uint32_t SR;           
N  __IO uint32_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
X  volatile uint32_t EGR;          
N  __IO uint32_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
X  volatile uint32_t CCMR1;        
N  __IO uint32_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
X  volatile uint32_t CCMR2;        
N  __IO uint32_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
X  volatile uint32_t CCER;         
N  __IO uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
X  volatile uint32_t CNT;          
N  __IO uint32_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
X  volatile uint32_t PSC;          
N  __IO uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
X  volatile uint32_t ARR;          
N  __IO uint32_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
X  volatile uint32_t RCR;          
N  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
X  volatile uint32_t CCR1;         
N  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
X  volatile uint32_t CCR2;         
N  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
X  volatile uint32_t CCR3;         
N  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
X  volatile uint32_t CCR4;         
N  __IO uint32_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
X  volatile uint32_t BDTR;         
N  __IO uint32_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
X  volatile uint32_t DCR;          
N  __IO uint32_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
X  volatile uint32_t DMAR;         
N  __IO uint32_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
X  volatile uint32_t OR;           
N} TIM_TypeDef;
N
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N 
Ntypedef struct
N{
N  __IO uint32_t SR;         /*!< USART Status register,                   Address offset: 0x00 */
X  volatile uint32_t SR;          
N  __IO uint32_t DR;         /*!< USART Data register,                     Address offset: 0x04 */
X  volatile uint32_t DR;          
N  __IO uint32_t BRR;        /*!< USART Baud rate register,                Address offset: 0x08 */
X  volatile uint32_t BRR;         
N  __IO uint32_t CR1;        /*!< USART Control register 1,                Address offset: 0x0C */
X  volatile uint32_t CR1;         
N  __IO uint32_t CR2;        /*!< USART Control register 2,                Address offset: 0x10 */
X  volatile uint32_t CR2;         
N  __IO uint32_t CR3;        /*!< USART Control register 3,                Address offset: 0x14 */
X  volatile uint32_t CR3;         
N  __IO uint32_t GTPR;       /*!< USART Guard time and prescaler register, Address offset: 0x18 */
X  volatile uint32_t GTPR;        
N} USART_TypeDef;
N
N/** 
N  * @brief Window WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;   
N  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;    
N} WWDG_TypeDef;
N
N/** 
N  * @brief RNG
N  */
N  
Ntypedef struct 
N{
N  __IO uint32_t CR;  /*!< RNG control register, Address offset: 0x00 */
X  volatile uint32_t CR;   
N  __IO uint32_t SR;  /*!< RNG status register,  Address offset: 0x04 */
X  volatile uint32_t SR;   
N  __IO uint32_t DR;  /*!< RNG data register,    Address offset: 0x08 */
X  volatile uint32_t DR;   
N} RNG_TypeDef;
N
N/** 
N  * @brief USB_OTG_Core_Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t GOTGCTL;              /*!< USB_OTG Control and Status Register          000h */
X  volatile uint32_t GOTGCTL;               
N  __IO uint32_t GOTGINT;              /*!< USB_OTG Interrupt Register                   004h */
X  volatile uint32_t GOTGINT;               
N  __IO uint32_t GAHBCFG;              /*!< Core AHB Configuration Register              008h */
X  volatile uint32_t GAHBCFG;               
N  __IO uint32_t GUSBCFG;              /*!< Core USB Configuration Register              00Ch */
X  volatile uint32_t GUSBCFG;               
N  __IO uint32_t GRSTCTL;              /*!< Core Reset Register                          010h */
X  volatile uint32_t GRSTCTL;               
N  __IO uint32_t GINTSTS;              /*!< Core Interrupt Register                      014h */
X  volatile uint32_t GINTSTS;               
N  __IO uint32_t GINTMSK;              /*!< Core Interrupt Mask Register                 018h */
X  volatile uint32_t GINTMSK;               
N  __IO uint32_t GRXSTSR;              /*!< Receive Sts Q Read Register                  01Ch */
X  volatile uint32_t GRXSTSR;               
N  __IO uint32_t GRXSTSP;              /*!< Receive Sts Q Read & POP Register            020h */
X  volatile uint32_t GRXSTSP;               
N  __IO uint32_t GRXFSIZ;              /*!< Receive FIFO Size Register                   024h */
X  volatile uint32_t GRXFSIZ;               
N  __IO uint32_t DIEPTXF0_HNPTXFSIZ;   /*!< EP0 / Non Periodic Tx FIFO Size Register     028h */
X  volatile uint32_t DIEPTXF0_HNPTXFSIZ;    
N  __IO uint32_t HNPTXSTS;             /*!< Non Periodic Tx FIFO/Queue Sts reg           02Ch */
X  volatile uint32_t HNPTXSTS;              
N  uint32_t Reserved30[2];             /*!< Reserved                                     030h */
N  __IO uint32_t GCCFG;                /*!< General Purpose IO Register                  038h */
X  volatile uint32_t GCCFG;                 
N  __IO uint32_t CID;                  /*!< User ID Register                             03Ch */
X  volatile uint32_t CID;                   
N  uint32_t  Reserved40[48];           /*!< Reserved                                0x40-0xFF */
N  __IO uint32_t HPTXFSIZ;             /*!< Host Periodic Tx FIFO Size Reg               100h */
X  volatile uint32_t HPTXFSIZ;              
N  __IO uint32_t DIEPTXF[0x0F];        /*!< dev Periodic Transmit FIFO                        */
X  volatile uint32_t DIEPTXF[0x0F];         
N} USB_OTG_GlobalTypeDef;
N
N/** 
N  * @brief USB_OTG_device_Registers
N  */
Ntypedef struct 
N{
N  __IO uint32_t DCFG;            /*!< dev Configuration Register   800h */
X  volatile uint32_t DCFG;             
N  __IO uint32_t DCTL;            /*!< dev Control Register         804h */
X  volatile uint32_t DCTL;             
N  __IO uint32_t DSTS;            /*!< dev Status Register (RO)     808h */
X  volatile uint32_t DSTS;             
N  uint32_t Reserved0C;           /*!< Reserved                     80Ch */
N  __IO uint32_t DIEPMSK;         /*!< dev IN Endpoint Mask         810h */
X  volatile uint32_t DIEPMSK;          
N  __IO uint32_t DOEPMSK;         /*!< dev OUT Endpoint Mask        814h */
X  volatile uint32_t DOEPMSK;          
N  __IO uint32_t DAINT;           /*!< dev All Endpoints Itr Reg    818h */
X  volatile uint32_t DAINT;            
N  __IO uint32_t DAINTMSK;        /*!< dev All Endpoints Itr Mask   81Ch */
X  volatile uint32_t DAINTMSK;         
N  uint32_t  Reserved20;          /*!< Reserved                     820h */
N  uint32_t Reserved9;            /*!< Reserved                     824h */
N  __IO uint32_t DVBUSDIS;        /*!< dev VBUS discharge Register  828h */
X  volatile uint32_t DVBUSDIS;         
N  __IO uint32_t DVBUSPULSE;      /*!< dev VBUS Pulse Register      82Ch */
X  volatile uint32_t DVBUSPULSE;       
N  __IO uint32_t DTHRCTL;         /*!< dev threshold                830h */
X  volatile uint32_t DTHRCTL;          
N  __IO uint32_t DIEPEMPMSK;      /*!< dev empty msk                834h */
X  volatile uint32_t DIEPEMPMSK;       
N  __IO uint32_t DEACHINT;        /*!< dedicated EP interrupt       838h */
X  volatile uint32_t DEACHINT;         
N  __IO uint32_t DEACHMSK;        /*!< dedicated EP msk             83Ch */
X  volatile uint32_t DEACHMSK;         
N  uint32_t Reserved40;           /*!< dedicated EP mask            840h */
N  __IO uint32_t DINEP1MSK;       /*!< dedicated EP mask            844h */
X  volatile uint32_t DINEP1MSK;        
N  uint32_t  Reserved44[15];      /*!< Reserved                 844-87Ch */
N  __IO uint32_t DOUTEP1MSK;      /*!< dedicated EP msk             884h */
X  volatile uint32_t DOUTEP1MSK;       
N} USB_OTG_DeviceTypeDef;
N
N/** 
N  * @brief USB_OTG_IN_Endpoint-Specific_Register
N  */
Ntypedef struct 
N{
N  __IO uint32_t DIEPCTL;           /*!< dev IN Endpoint Control Reg    900h + (ep_num * 20h) + 00h */
X  volatile uint32_t DIEPCTL;            
N  uint32_t Reserved04;             /*!< Reserved                       900h + (ep_num * 20h) + 04h */
N  __IO uint32_t DIEPINT;           /*!< dev IN Endpoint Itr Reg        900h + (ep_num * 20h) + 08h */
X  volatile uint32_t DIEPINT;            
N  uint32_t Reserved0C;             /*!< Reserved                       900h + (ep_num * 20h) + 0Ch */
N  __IO uint32_t DIEPTSIZ;          /*!< IN Endpoint Txfer Size         900h + (ep_num * 20h) + 10h */
X  volatile uint32_t DIEPTSIZ;           
N  __IO uint32_t DIEPDMA;           /*!< IN Endpoint DMA Address Reg    900h + (ep_num * 20h) + 14h */
X  volatile uint32_t DIEPDMA;            
N  __IO uint32_t DTXFSTS;           /*!< IN Endpoint Tx FIFO Status Reg 900h + (ep_num * 20h) + 18h */
X  volatile uint32_t DTXFSTS;            
N  uint32_t Reserved18;             /*!< Reserved  900h+(ep_num*20h)+1Ch-900h+ (ep_num * 20h) + 1Ch */
N} USB_OTG_INEndpointTypeDef;
N
N/** 
N  * @brief USB_OTG_OUT_Endpoint-Specific_Registers
N  */
Ntypedef struct 
N{
N  __IO uint32_t DOEPCTL;       /*!< dev OUT Endpoint Control Reg           B00h + (ep_num * 20h) + 00h */
X  volatile uint32_t DOEPCTL;        
N  uint32_t Reserved04;         /*!< Reserved                               B00h + (ep_num * 20h) + 04h */
N  __IO uint32_t DOEPINT;       /*!< dev OUT Endpoint Itr Reg               B00h + (ep_num * 20h) + 08h */
X  volatile uint32_t DOEPINT;        
N  uint32_t Reserved0C;         /*!< Reserved                               B00h + (ep_num * 20h) + 0Ch */
N  __IO uint32_t DOEPTSIZ;      /*!< dev OUT Endpoint Txfer Size            B00h + (ep_num * 20h) + 10h */
X  volatile uint32_t DOEPTSIZ;       
N  __IO uint32_t DOEPDMA;       /*!< dev OUT Endpoint DMA Address           B00h + (ep_num * 20h) + 14h */
X  volatile uint32_t DOEPDMA;        
N  uint32_t Reserved18[2];      /*!< Reserved B00h + (ep_num * 20h) + 18h - B00h + (ep_num * 20h) + 1Ch */
N} USB_OTG_OUTEndpointTypeDef;
N
N/** 
N  * @brief USB_OTG_Host_Mode_Register_Structures
N  */
Ntypedef struct 
N{
N  __IO uint32_t HCFG;             /*!< Host Configuration Register          400h */
X  volatile uint32_t HCFG;              
N  __IO uint32_t HFIR;             /*!< Host Frame Interval Register         404h */
X  volatile uint32_t HFIR;              
N  __IO uint32_t HFNUM;            /*!< Host Frame Nbr/Frame Remaining       408h */
X  volatile uint32_t HFNUM;             
N  uint32_t Reserved40C;           /*!< Reserved                             40Ch */
N  __IO uint32_t HPTXSTS;          /*!< Host Periodic Tx FIFO/ Queue Status  410h */
X  volatile uint32_t HPTXSTS;           
N  __IO uint32_t HAINT;            /*!< Host All Channels Interrupt Register 414h */
X  volatile uint32_t HAINT;             
N  __IO uint32_t HAINTMSK;         /*!< Host All Channels Interrupt Mask     418h */
X  volatile uint32_t HAINTMSK;          
N} USB_OTG_HostTypeDef;
N
N/** 
N  * @brief USB_OTG_Host_Channel_Specific_Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t HCCHAR;           /*!< Host Channel Characteristics Register    500h */
X  volatile uint32_t HCCHAR;            
N  __IO uint32_t HCSPLT;           /*!< Host Channel Split Control Register      504h */
X  volatile uint32_t HCSPLT;            
N  __IO uint32_t HCINT;            /*!< Host Channel Interrupt Register          508h */
X  volatile uint32_t HCINT;             
N  __IO uint32_t HCINTMSK;         /*!< Host Channel Interrupt Mask Register     50Ch */
X  volatile uint32_t HCINTMSK;          
N  __IO uint32_t HCTSIZ;           /*!< Host Channel Transfer Size Register      510h */
X  volatile uint32_t HCTSIZ;            
N  __IO uint32_t HCDMA;            /*!< Host Channel DMA Address Register        514h */
X  volatile uint32_t HCDMA;             
N  uint32_t Reserved[2];           /*!< Reserved                                      */
N} USB_OTG_HostChannelTypeDef;
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N#define FLASH_BASE            0x08000000UL /*!< FLASH(up to 1 MB) base address in the alias region                         */
N#define CCMDATARAM_BASE       0x10000000UL /*!< CCM(core coupled memory) data RAM(64 KB) base address in the alias region  */
N#define SRAM1_BASE            0x20000000UL /*!< SRAM1(112 KB) base address in the alias region                              */
N#define SRAM2_BASE            0x2001C000UL /*!< SRAM2(16 KB) base address in the alias region                              */
N#define PERIPH_BASE           0x40000000UL /*!< Peripheral base address in the alias region                                */
N#define BKPSRAM_BASE          0x40024000UL /*!< Backup SRAM(4 KB) base address in the alias region                         */
N#define FSMC_R_BASE           0xA0000000UL /*!< FSMC registers base address                                                */
N#define SRAM1_BB_BASE         0x22000000UL /*!< SRAM1(112 KB) base address in the bit-band region                          */
N#define SRAM2_BB_BASE         0x22380000UL /*!< SRAM2(16 KB) base address in the bit-band region                           */
N#define PERIPH_BB_BASE        0x42000000UL /*!< Peripheral base address in the bit-band region                             */
N#define BKPSRAM_BB_BASE       0x42480000UL /*!< Backup SRAM(4 KB) base address in the bit-band region                      */
N#define FLASH_END             0x080FFFFFUL /*!< FLASH end address                                                          */
N#define FLASH_OTP_BASE        0x1FFF7800UL /*!< Base address of : (up to 528 Bytes) embedded FLASH OTP Area                */
N#define FLASH_OTP_END         0x1FFF7A0FUL /*!< End address of : (up to 528 Bytes) embedded FLASH OTP Area                 */
N#define CCMDATARAM_END        0x1000FFFFUL /*!< CCM data RAM end address                                                   */
N
N/* Legacy defines */
N#define SRAM_BASE             SRAM1_BASE
N#define SRAM_BB_BASE          SRAM1_BB_BASE
N
N/*!< Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)
N#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000UL)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x10000000UL)
N
N/*!< APB1 peripherals */
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000UL)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400UL)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800UL)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00UL)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000UL)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400UL)
N#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800UL)
N#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00UL)
N#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000UL)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800UL)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00UL)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000UL)
N#define I2S2ext_BASE          (APB1PERIPH_BASE + 0x3400UL)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800UL)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00UL)
N#define I2S3ext_BASE          (APB1PERIPH_BASE + 0x4000UL)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400UL)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800UL)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00UL)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000UL)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400UL)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800UL)
N#define I2C3_BASE             (APB1PERIPH_BASE + 0x5C00UL)
N#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400UL)
N#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800UL)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000UL)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400UL)
N
N/*!< APB2 peripherals */
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x0000UL)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x0400UL)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x1000UL)
N#define USART6_BASE           (APB2PERIPH_BASE + 0x1400UL)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2000UL)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2100UL)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x2200UL)
N#define ADC123_COMMON_BASE    (APB2PERIPH_BASE + 0x2300UL)
N/* Legacy define */
N#define ADC_BASE               ADC123_COMMON_BASE
N#define SDIO_BASE             (APB2PERIPH_BASE + 0x2C00UL)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000UL)
N#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x3800UL)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x3C00UL)
N#define TIM9_BASE             (APB2PERIPH_BASE + 0x4000UL)
N#define TIM10_BASE            (APB2PERIPH_BASE + 0x4400UL)
N#define TIM11_BASE            (APB2PERIPH_BASE + 0x4800UL)
N
N/*!< AHB1 peripherals */
N#define GPIOA_BASE            (AHB1PERIPH_BASE + 0x0000UL)
N#define GPIOB_BASE            (AHB1PERIPH_BASE + 0x0400UL)
N#define GPIOC_BASE            (AHB1PERIPH_BASE + 0x0800UL)
N#define GPIOD_BASE            (AHB1PERIPH_BASE + 0x0C00UL)
N#define GPIOE_BASE            (AHB1PERIPH_BASE + 0x1000UL)
N#define GPIOF_BASE            (AHB1PERIPH_BASE + 0x1400UL)
N#define GPIOG_BASE            (AHB1PERIPH_BASE + 0x1800UL)
N#define GPIOH_BASE            (AHB1PERIPH_BASE + 0x1C00UL)
N#define GPIOI_BASE            (AHB1PERIPH_BASE + 0x2000UL)
N#define CRC_BASE              (AHB1PERIPH_BASE + 0x3000UL)
N#define RCC_BASE              (AHB1PERIPH_BASE + 0x3800UL)
N#define FLASH_R_BASE          (AHB1PERIPH_BASE + 0x3C00UL)
N#define DMA1_BASE             (AHB1PERIPH_BASE + 0x6000UL)
N#define DMA1_Stream0_BASE     (DMA1_BASE + 0x010UL)
N#define DMA1_Stream1_BASE     (DMA1_BASE + 0x028UL)
N#define DMA1_Stream2_BASE     (DMA1_BASE + 0x040UL)
N#define DMA1_Stream3_BASE     (DMA1_BASE + 0x058UL)
N#define DMA1_Stream4_BASE     (DMA1_BASE + 0x070UL)
N#define DMA1_Stream5_BASE     (DMA1_BASE + 0x088UL)
N#define DMA1_Stream6_BASE     (DMA1_BASE + 0x0A0UL)
N#define DMA1_Stream7_BASE     (DMA1_BASE + 0x0B8UL)
N#define DMA2_BASE             (AHB1PERIPH_BASE + 0x6400UL)
N#define DMA2_Stream0_BASE     (DMA2_BASE + 0x010UL)
N#define DMA2_Stream1_BASE     (DMA2_BASE + 0x028UL)
N#define DMA2_Stream2_BASE     (DMA2_BASE + 0x040UL)
N#define DMA2_Stream3_BASE     (DMA2_BASE + 0x058UL)
N#define DMA2_Stream4_BASE     (DMA2_BASE + 0x070UL)
N#define DMA2_Stream5_BASE     (DMA2_BASE + 0x088UL)
N#define DMA2_Stream6_BASE     (DMA2_BASE + 0x0A0UL)
N#define DMA2_Stream7_BASE     (DMA2_BASE + 0x0B8UL)
N#define ETH_BASE              (AHB1PERIPH_BASE + 0x8000UL)
N#define ETH_MAC_BASE          (ETH_BASE)
N#define ETH_MMC_BASE          (ETH_BASE + 0x0100UL)
N#define ETH_PTP_BASE          (ETH_BASE + 0x0700UL)
N#define ETH_DMA_BASE          (ETH_BASE + 0x1000UL)
N
N/*!< AHB2 peripherals */
N#define DCMI_BASE             (AHB2PERIPH_BASE + 0x50000UL)
N#define RNG_BASE              (AHB2PERIPH_BASE + 0x60800UL)
N
N/*!< FSMC Bankx registers base address */
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000UL)
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104UL)
N#define FSMC_Bank2_3_R_BASE   (FSMC_R_BASE + 0x0060UL)
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0UL)
N
N
N/*!< Debug MCU registers base address */
N#define DBGMCU_BASE           0xE0042000UL
N/*!< USB registers base address */
N#define USB_OTG_HS_PERIPH_BASE               0x40040000UL
N#define USB_OTG_FS_PERIPH_BASE               0x50000000UL
N
N#define USB_OTG_GLOBAL_BASE                  0x000UL
N#define USB_OTG_DEVICE_BASE                  0x800UL
N#define USB_OTG_IN_ENDPOINT_BASE             0x900UL
N#define USB_OTG_OUT_ENDPOINT_BASE            0xB00UL
N#define USB_OTG_EP_REG_SIZE                  0x20UL
N#define USB_OTG_HOST_BASE                    0x400UL
N#define USB_OTG_HOST_PORT_BASE               0x440UL
N#define USB_OTG_HOST_CHANNEL_BASE            0x500UL
N#define USB_OTG_HOST_CHANNEL_SIZE            0x20UL
N#define USB_OTG_PCGCCTL_BASE                 0xE00UL
N#define USB_OTG_FIFO_BASE                    0x1000UL
N#define USB_OTG_FIFO_SIZE                    0x1000UL
N
N#define UID_BASE                     0x1FFF7A10UL           /*!< Unique device ID register base address */
N#define FLASHSIZE_BASE               0x1FFF7A22UL           /*!< FLASH Size register base address       */
N#define PACKAGE_BASE                 0x1FFF7BF0UL           /*!< Package size register base address     */
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_declaration
N  * @{
N  */  
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
N#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
N#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define I2S2ext             ((SPI_TypeDef *) I2S2ext_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#define I2S3ext             ((SPI_TypeDef *) I2S3ext_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define USART3              ((USART_TypeDef *) USART3_BASE)
N#define UART4               ((USART_TypeDef *) UART4_BASE)
N#define UART5               ((USART_TypeDef *) UART5_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define I2C3                ((I2C_TypeDef *) I2C3_BASE)
N#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
N#define CAN2                ((CAN_TypeDef *) CAN2_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define DAC1                ((DAC_TypeDef *) DAC_BASE)
N#define DAC                 ((DAC_TypeDef *) DAC_BASE) /* Kept for legacy purpose */
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define USART6              ((USART_TypeDef *) USART6_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#define ADC123_COMMON       ((ADC_Common_TypeDef *) ADC123_COMMON_BASE)
N/* Legacy define */
N#define ADC                  ADC123_COMMON
N#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
N#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
N#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)
N#define GPIOI               ((GPIO_TypeDef *) GPIOI_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Stream0        ((DMA_Stream_TypeDef *) DMA1_Stream0_BASE)
N#define DMA1_Stream1        ((DMA_Stream_TypeDef *) DMA1_Stream1_BASE)
N#define DMA1_Stream2        ((DMA_Stream_TypeDef *) DMA1_Stream2_BASE)
N#define DMA1_Stream3        ((DMA_Stream_TypeDef *) DMA1_Stream3_BASE)
N#define DMA1_Stream4        ((DMA_Stream_TypeDef *) DMA1_Stream4_BASE)
N#define DMA1_Stream5        ((DMA_Stream_TypeDef *) DMA1_Stream5_BASE)
N#define DMA1_Stream6        ((DMA_Stream_TypeDef *) DMA1_Stream6_BASE)
N#define DMA1_Stream7        ((DMA_Stream_TypeDef *) DMA1_Stream7_BASE)
N#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#define DMA2_Stream0        ((DMA_Stream_TypeDef *) DMA2_Stream0_BASE)
N#define DMA2_Stream1        ((DMA_Stream_TypeDef *) DMA2_Stream1_BASE)
N#define DMA2_Stream2        ((DMA_Stream_TypeDef *) DMA2_Stream2_BASE)
N#define DMA2_Stream3        ((DMA_Stream_TypeDef *) DMA2_Stream3_BASE)
N#define DMA2_Stream4        ((DMA_Stream_TypeDef *) DMA2_Stream4_BASE)
N#define DMA2_Stream5        ((DMA_Stream_TypeDef *) DMA2_Stream5_BASE)
N#define DMA2_Stream6        ((DMA_Stream_TypeDef *) DMA2_Stream6_BASE)
N#define DMA2_Stream7        ((DMA_Stream_TypeDef *) DMA2_Stream7_BASE)
N#define ETH                 ((ETH_TypeDef *) ETH_BASE)  
N#define DCMI                ((DCMI_TypeDef *) DCMI_BASE)
N#define RNG                 ((RNG_TypeDef *) RNG_BASE)
N#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
N#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
N#define FSMC_Bank2_3        ((FSMC_Bank2_3_TypeDef *) FSMC_Bank2_3_R_BASE)
N#define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#define USB_OTG_FS          ((USB_OTG_GlobalTypeDef *) USB_OTG_FS_PERIPH_BASE)
N#define USB_OTG_HS          ((USB_OTG_GlobalTypeDef *) USB_OTG_HS_PERIPH_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N
N/** @addtogroup Hardware_Constant_Definition
N  * @{
N  */
N#define LSI_STARTUP_TIME                40U /*!< LSI Maximum startup time in us */
N/**
N  * @}
N  */
N
N  /** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N    
N/******************************************************************************/
N/*                         Peripheral Registers_Bits_Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Analog to Digital Converter                         */
N/*                                                                            */
N/******************************************************************************/
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F4 serie)
N */
N#define ADC_MULTIMODE_SUPPORT                                                  /*!<ADC Multimode feature available on specific devices */
N
N/********************  Bit definition for ADC_SR register  ********************/
N#define ADC_SR_AWD_Pos            (0U)                                         
N#define ADC_SR_AWD_Msk            (0x1UL << ADC_SR_AWD_Pos)                     /*!< 0x00000001 */
N#define ADC_SR_AWD                ADC_SR_AWD_Msk                               /*!<Analog watchdog flag */
N#define ADC_SR_EOC_Pos            (1U)                                         
N#define ADC_SR_EOC_Msk            (0x1UL << ADC_SR_EOC_Pos)                     /*!< 0x00000002 */
N#define ADC_SR_EOC                ADC_SR_EOC_Msk                               /*!<End of conversion */
N#define ADC_SR_JEOC_Pos           (2U)                                         
N#define ADC_SR_JEOC_Msk           (0x1UL << ADC_SR_JEOC_Pos)                    /*!< 0x00000004 */
N#define ADC_SR_JEOC               ADC_SR_JEOC_Msk                              /*!<Injected channel end of conversion */
N#define ADC_SR_JSTRT_Pos          (3U)                                         
N#define ADC_SR_JSTRT_Msk          (0x1UL << ADC_SR_JSTRT_Pos)                   /*!< 0x00000008 */
N#define ADC_SR_JSTRT              ADC_SR_JSTRT_Msk                             /*!<Injected channel Start flag */
N#define ADC_SR_STRT_Pos           (4U)                                         
N#define ADC_SR_STRT_Msk           (0x1UL << ADC_SR_STRT_Pos)                    /*!< 0x00000010 */
N#define ADC_SR_STRT               ADC_SR_STRT_Msk                              /*!<Regular channel Start flag */
N#define ADC_SR_OVR_Pos            (5U)                                         
N#define ADC_SR_OVR_Msk            (0x1UL << ADC_SR_OVR_Pos)                     /*!< 0x00000020 */
N#define ADC_SR_OVR                ADC_SR_OVR_Msk                               /*!<Overrun flag */
N
N/*******************  Bit definition for ADC_CR1 register  ********************/
N#define ADC_CR1_AWDCH_Pos         (0U)                                         
N#define ADC_CR1_AWDCH_Msk         (0x1FUL << ADC_CR1_AWDCH_Pos)                 /*!< 0x0000001F */
N#define ADC_CR1_AWDCH             ADC_CR1_AWDCH_Msk                            /*!<AWDCH[4:0] bits (Analog watchdog channel select bits) */
N#define ADC_CR1_AWDCH_0           (0x01UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000001 */
N#define ADC_CR1_AWDCH_1           (0x02UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000002 */
N#define ADC_CR1_AWDCH_2           (0x04UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000004 */
N#define ADC_CR1_AWDCH_3           (0x08UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000008 */
N#define ADC_CR1_AWDCH_4           (0x10UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000010 */
N#define ADC_CR1_EOCIE_Pos         (5U)                                         
N#define ADC_CR1_EOCIE_Msk         (0x1UL << ADC_CR1_EOCIE_Pos)                  /*!< 0x00000020 */
N#define ADC_CR1_EOCIE             ADC_CR1_EOCIE_Msk                            /*!<Interrupt enable for EOC */
N#define ADC_CR1_AWDIE_Pos         (6U)                                         
N#define ADC_CR1_AWDIE_Msk         (0x1UL << ADC_CR1_AWDIE_Pos)                  /*!< 0x00000040 */
N#define ADC_CR1_AWDIE             ADC_CR1_AWDIE_Msk                            /*!<AAnalog Watchdog interrupt enable */
N#define ADC_CR1_JEOCIE_Pos        (7U)                                         
N#define ADC_CR1_JEOCIE_Msk        (0x1UL << ADC_CR1_JEOCIE_Pos)                 /*!< 0x00000080 */
N#define ADC_CR1_JEOCIE            ADC_CR1_JEOCIE_Msk                           /*!<Interrupt enable for injected channels */
N#define ADC_CR1_SCAN_Pos          (8U)                                         
N#define ADC_CR1_SCAN_Msk          (0x1UL << ADC_CR1_SCAN_Pos)                   /*!< 0x00000100 */
N#define ADC_CR1_SCAN              ADC_CR1_SCAN_Msk                             /*!<Scan mode */
N#define ADC_CR1_AWDSGL_Pos        (9U)                                         
N#define ADC_CR1_AWDSGL_Msk        (0x1UL << ADC_CR1_AWDSGL_Pos)                 /*!< 0x00000200 */
N#define ADC_CR1_AWDSGL            ADC_CR1_AWDSGL_Msk                           /*!<Enable the watchdog on a single channel in scan mode */
N#define ADC_CR1_JAUTO_Pos         (10U)                                        
N#define ADC_CR1_JAUTO_Msk         (0x1UL << ADC_CR1_JAUTO_Pos)                  /*!< 0x00000400 */
N#define ADC_CR1_JAUTO             ADC_CR1_JAUTO_Msk                            /*!<Automatic injected group conversion */
N#define ADC_CR1_DISCEN_Pos        (11U)                                        
N#define ADC_CR1_DISCEN_Msk        (0x1UL << ADC_CR1_DISCEN_Pos)                 /*!< 0x00000800 */
N#define ADC_CR1_DISCEN            ADC_CR1_DISCEN_Msk                           /*!<Discontinuous mode on regular channels */
N#define ADC_CR1_JDISCEN_Pos       (12U)                                        
N#define ADC_CR1_JDISCEN_Msk       (0x1UL << ADC_CR1_JDISCEN_Pos)                /*!< 0x00001000 */
N#define ADC_CR1_JDISCEN           ADC_CR1_JDISCEN_Msk                          /*!<Discontinuous mode on injected channels */
N#define ADC_CR1_DISCNUM_Pos       (13U)                                        
N#define ADC_CR1_DISCNUM_Msk       (0x7UL << ADC_CR1_DISCNUM_Pos)                /*!< 0x0000E000 */
N#define ADC_CR1_DISCNUM           ADC_CR1_DISCNUM_Msk                          /*!<DISCNUM[2:0] bits (Discontinuous mode channel count) */
N#define ADC_CR1_DISCNUM_0         (0x1UL << ADC_CR1_DISCNUM_Pos)                /*!< 0x00002000 */
N#define ADC_CR1_DISCNUM_1         (0x2UL << ADC_CR1_DISCNUM_Pos)                /*!< 0x00004000 */
N#define ADC_CR1_DISCNUM_2         (0x4UL << ADC_CR1_DISCNUM_Pos)                /*!< 0x00008000 */
N#define ADC_CR1_JAWDEN_Pos        (22U)                                        
N#define ADC_CR1_JAWDEN_Msk        (0x1UL << ADC_CR1_JAWDEN_Pos)                 /*!< 0x00400000 */
N#define ADC_CR1_JAWDEN            ADC_CR1_JAWDEN_Msk                           /*!<Analog watchdog enable on injected channels */
N#define ADC_CR1_AWDEN_Pos         (23U)                                        
N#define ADC_CR1_AWDEN_Msk         (0x1UL << ADC_CR1_AWDEN_Pos)                  /*!< 0x00800000 */
N#define ADC_CR1_AWDEN             ADC_CR1_AWDEN_Msk                            /*!<Analog watchdog enable on regular channels */
N#define ADC_CR1_RES_Pos           (24U)                                        
N#define ADC_CR1_RES_Msk           (0x3UL << ADC_CR1_RES_Pos)                    /*!< 0x03000000 */
N#define ADC_CR1_RES               ADC_CR1_RES_Msk                              /*!<RES[2:0] bits (Resolution) */
N#define ADC_CR1_RES_0             (0x1UL << ADC_CR1_RES_Pos)                    /*!< 0x01000000 */
N#define ADC_CR1_RES_1             (0x2UL << ADC_CR1_RES_Pos)                    /*!< 0x02000000 */
N#define ADC_CR1_OVRIE_Pos         (26U)                                        
N#define ADC_CR1_OVRIE_Msk         (0x1UL << ADC_CR1_OVRIE_Pos)                  /*!< 0x04000000 */
N#define ADC_CR1_OVRIE             ADC_CR1_OVRIE_Msk                            /*!<overrun interrupt enable */
N  
N/*******************  Bit definition for ADC_CR2 register  ********************/
N#define ADC_CR2_ADON_Pos          (0U)                                         
N#define ADC_CR2_ADON_Msk          (0x1UL << ADC_CR2_ADON_Pos)                   /*!< 0x00000001 */
N#define ADC_CR2_ADON              ADC_CR2_ADON_Msk                             /*!<A/D Converter ON / OFF */
N#define ADC_CR2_CONT_Pos          (1U)                                         
N#define ADC_CR2_CONT_Msk          (0x1UL << ADC_CR2_CONT_Pos)                   /*!< 0x00000002 */
N#define ADC_CR2_CONT              ADC_CR2_CONT_Msk                             /*!<Continuous Conversion */
N#define ADC_CR2_DMA_Pos           (8U)                                         
N#define ADC_CR2_DMA_Msk           (0x1UL << ADC_CR2_DMA_Pos)                    /*!< 0x00000100 */
N#define ADC_CR2_DMA               ADC_CR2_DMA_Msk                              /*!<Direct Memory access mode */
N#define ADC_CR2_DDS_Pos           (9U)                                         
N#define ADC_CR2_DDS_Msk           (0x1UL << ADC_CR2_DDS_Pos)                    /*!< 0x00000200 */
N#define ADC_CR2_DDS               ADC_CR2_DDS_Msk                              /*!<DMA disable selection (Single ADC) */
N#define ADC_CR2_EOCS_Pos          (10U)                                        
N#define ADC_CR2_EOCS_Msk          (0x1UL << ADC_CR2_EOCS_Pos)                   /*!< 0x00000400 */
N#define ADC_CR2_EOCS              ADC_CR2_EOCS_Msk                             /*!<End of conversion selection */
N#define ADC_CR2_ALIGN_Pos         (11U)                                        
N#define ADC_CR2_ALIGN_Msk         (0x1UL << ADC_CR2_ALIGN_Pos)                  /*!< 0x00000800 */
N#define ADC_CR2_ALIGN             ADC_CR2_ALIGN_Msk                            /*!<Data Alignment */
N#define ADC_CR2_JEXTSEL_Pos       (16U)                                        
N#define ADC_CR2_JEXTSEL_Msk       (0xFUL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x000F0000 */
N#define ADC_CR2_JEXTSEL           ADC_CR2_JEXTSEL_Msk                          /*!<JEXTSEL[3:0] bits (External event select for injected group) */
N#define ADC_CR2_JEXTSEL_0         (0x1UL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x00010000 */
N#define ADC_CR2_JEXTSEL_1         (0x2UL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x00020000 */
N#define ADC_CR2_JEXTSEL_2         (0x4UL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x00040000 */
N#define ADC_CR2_JEXTSEL_3         (0x8UL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x00080000 */
N#define ADC_CR2_JEXTEN_Pos        (20U)                                        
N#define ADC_CR2_JEXTEN_Msk        (0x3UL << ADC_CR2_JEXTEN_Pos)                 /*!< 0x00300000 */
N#define ADC_CR2_JEXTEN            ADC_CR2_JEXTEN_Msk                           /*!<JEXTEN[1:0] bits (External Trigger Conversion mode for injected channelsp) */
N#define ADC_CR2_JEXTEN_0          (0x1UL << ADC_CR2_JEXTEN_Pos)                 /*!< 0x00100000 */
N#define ADC_CR2_JEXTEN_1          (0x2UL << ADC_CR2_JEXTEN_Pos)                 /*!< 0x00200000 */
N#define ADC_CR2_JSWSTART_Pos      (22U)                                        
N#define ADC_CR2_JSWSTART_Msk      (0x1UL << ADC_CR2_JSWSTART_Pos)               /*!< 0x00400000 */
N#define ADC_CR2_JSWSTART          ADC_CR2_JSWSTART_Msk                         /*!<Start Conversion of injected channels */
N#define ADC_CR2_EXTSEL_Pos        (24U)                                        
N#define ADC_CR2_EXTSEL_Msk        (0xFUL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x0F000000 */
N#define ADC_CR2_EXTSEL            ADC_CR2_EXTSEL_Msk                           /*!<EXTSEL[3:0] bits (External Event Select for regular group) */
N#define ADC_CR2_EXTSEL_0          (0x1UL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x01000000 */
N#define ADC_CR2_EXTSEL_1          (0x2UL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x02000000 */
N#define ADC_CR2_EXTSEL_2          (0x4UL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x04000000 */
N#define ADC_CR2_EXTSEL_3          (0x8UL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x08000000 */
N#define ADC_CR2_EXTEN_Pos         (28U)                                        
N#define ADC_CR2_EXTEN_Msk         (0x3UL << ADC_CR2_EXTEN_Pos)                  /*!< 0x30000000 */
N#define ADC_CR2_EXTEN             ADC_CR2_EXTEN_Msk                            /*!<EXTEN[1:0] bits (External Trigger Conversion mode for regular channelsp) */
N#define ADC_CR2_EXTEN_0           (0x1UL << ADC_CR2_EXTEN_Pos)                  /*!< 0x10000000 */
N#define ADC_CR2_EXTEN_1           (0x2UL << ADC_CR2_EXTEN_Pos)                  /*!< 0x20000000 */
N#define ADC_CR2_SWSTART_Pos       (30U)                                        
N#define ADC_CR2_SWSTART_Msk       (0x1UL << ADC_CR2_SWSTART_Pos)                /*!< 0x40000000 */
N#define ADC_CR2_SWSTART           ADC_CR2_SWSTART_Msk                          /*!<Start Conversion of regular channels */
N
N/******************  Bit definition for ADC_SMPR1 register  *******************/
N#define ADC_SMPR1_SMP10_Pos       (0U)                                         
N#define ADC_SMPR1_SMP10_Msk       (0x7UL << ADC_SMPR1_SMP10_Pos)                /*!< 0x00000007 */
N#define ADC_SMPR1_SMP10           ADC_SMPR1_SMP10_Msk                          /*!<SMP10[2:0] bits (Channel 10 Sample time selection) */
N#define ADC_SMPR1_SMP10_0         (0x1UL << ADC_SMPR1_SMP10_Pos)                /*!< 0x00000001 */
N#define ADC_SMPR1_SMP10_1         (0x2UL << ADC_SMPR1_SMP10_Pos)                /*!< 0x00000002 */
N#define ADC_SMPR1_SMP10_2         (0x4UL << ADC_SMPR1_SMP10_Pos)                /*!< 0x00000004 */
N#define ADC_SMPR1_SMP11_Pos       (3U)                                         
N#define ADC_SMPR1_SMP11_Msk       (0x7UL << ADC_SMPR1_SMP11_Pos)                /*!< 0x00000038 */
N#define ADC_SMPR1_SMP11           ADC_SMPR1_SMP11_Msk                          /*!<SMP11[2:0] bits (Channel 11 Sample time selection) */
N#define ADC_SMPR1_SMP11_0         (0x1UL << ADC_SMPR1_SMP11_Pos)                /*!< 0x00000008 */
N#define ADC_SMPR1_SMP11_1         (0x2UL << ADC_SMPR1_SMP11_Pos)                /*!< 0x00000010 */
N#define ADC_SMPR1_SMP11_2         (0x4UL << ADC_SMPR1_SMP11_Pos)                /*!< 0x00000020 */
N#define ADC_SMPR1_SMP12_Pos       (6U)                                         
N#define ADC_SMPR1_SMP12_Msk       (0x7UL << ADC_SMPR1_SMP12_Pos)                /*!< 0x000001C0 */
N#define ADC_SMPR1_SMP12           ADC_SMPR1_SMP12_Msk                          /*!<SMP12[2:0] bits (Channel 12 Sample time selection) */
N#define ADC_SMPR1_SMP12_0         (0x1UL << ADC_SMPR1_SMP12_Pos)                /*!< 0x00000040 */
N#define ADC_SMPR1_SMP12_1         (0x2UL << ADC_SMPR1_SMP12_Pos)                /*!< 0x00000080 */
N#define ADC_SMPR1_SMP12_2         (0x4UL << ADC_SMPR1_SMP12_Pos)                /*!< 0x00000100 */
N#define ADC_SMPR1_SMP13_Pos       (9U)                                         
N#define ADC_SMPR1_SMP13_Msk       (0x7UL << ADC_SMPR1_SMP13_Pos)                /*!< 0x00000E00 */
N#define ADC_SMPR1_SMP13           ADC_SMPR1_SMP13_Msk                          /*!<SMP13[2:0] bits (Channel 13 Sample time selection) */
N#define ADC_SMPR1_SMP13_0         (0x1UL << ADC_SMPR1_SMP13_Pos)                /*!< 0x00000200 */
N#define ADC_SMPR1_SMP13_1         (0x2UL << ADC_SMPR1_SMP13_Pos)                /*!< 0x00000400 */
N#define ADC_SMPR1_SMP13_2         (0x4UL << ADC_SMPR1_SMP13_Pos)                /*!< 0x00000800 */
N#define ADC_SMPR1_SMP14_Pos       (12U)                                        
N#define ADC_SMPR1_SMP14_Msk       (0x7UL << ADC_SMPR1_SMP14_Pos)                /*!< 0x00007000 */
N#define ADC_SMPR1_SMP14           ADC_SMPR1_SMP14_Msk                          /*!<SMP14[2:0] bits (Channel 14 Sample time selection) */
N#define ADC_SMPR1_SMP14_0         (0x1UL << ADC_SMPR1_SMP14_Pos)                /*!< 0x00001000 */
N#define ADC_SMPR1_SMP14_1         (0x2UL << ADC_SMPR1_SMP14_Pos)                /*!< 0x00002000 */
N#define ADC_SMPR1_SMP14_2         (0x4UL << ADC_SMPR1_SMP14_Pos)                /*!< 0x00004000 */
N#define ADC_SMPR1_SMP15_Pos       (15U)                                        
N#define ADC_SMPR1_SMP15_Msk       (0x7UL << ADC_SMPR1_SMP15_Pos)                /*!< 0x00038000 */
N#define ADC_SMPR1_SMP15           ADC_SMPR1_SMP15_Msk                          /*!<SMP15[2:0] bits (Channel 15 Sample time selection) */
N#define ADC_SMPR1_SMP15_0         (0x1UL << ADC_SMPR1_SMP15_Pos)                /*!< 0x00008000 */
N#define ADC_SMPR1_SMP15_1         (0x2UL << ADC_SMPR1_SMP15_Pos)                /*!< 0x00010000 */
N#define ADC_SMPR1_SMP15_2         (0x4UL << ADC_SMPR1_SMP15_Pos)                /*!< 0x00020000 */
N#define ADC_SMPR1_SMP16_Pos       (18U)                                        
N#define ADC_SMPR1_SMP16_Msk       (0x7UL << ADC_SMPR1_SMP16_Pos)                /*!< 0x001C0000 */
N#define ADC_SMPR1_SMP16           ADC_SMPR1_SMP16_Msk                          /*!<SMP16[2:0] bits (Channel 16 Sample time selection) */
N#define ADC_SMPR1_SMP16_0         (0x1UL << ADC_SMPR1_SMP16_Pos)                /*!< 0x00040000 */
N#define ADC_SMPR1_SMP16_1         (0x2UL << ADC_SMPR1_SMP16_Pos)                /*!< 0x00080000 */
N#define ADC_SMPR1_SMP16_2         (0x4UL << ADC_SMPR1_SMP16_Pos)                /*!< 0x00100000 */
N#define ADC_SMPR1_SMP17_Pos       (21U)                                        
N#define ADC_SMPR1_SMP17_Msk       (0x7UL << ADC_SMPR1_SMP17_Pos)                /*!< 0x00E00000 */
N#define ADC_SMPR1_SMP17           ADC_SMPR1_SMP17_Msk                          /*!<SMP17[2:0] bits (Channel 17 Sample time selection) */
N#define ADC_SMPR1_SMP17_0         (0x1UL << ADC_SMPR1_SMP17_Pos)                /*!< 0x00200000 */
N#define ADC_SMPR1_SMP17_1         (0x2UL << ADC_SMPR1_SMP17_Pos)                /*!< 0x00400000 */
N#define ADC_SMPR1_SMP17_2         (0x4UL << ADC_SMPR1_SMP17_Pos)                /*!< 0x00800000 */
N#define ADC_SMPR1_SMP18_Pos       (24U)                                        
N#define ADC_SMPR1_SMP18_Msk       (0x7UL << ADC_SMPR1_SMP18_Pos)                /*!< 0x07000000 */
N#define ADC_SMPR1_SMP18           ADC_SMPR1_SMP18_Msk                          /*!<SMP18[2:0] bits (Channel 18 Sample time selection) */
N#define ADC_SMPR1_SMP18_0         (0x1UL << ADC_SMPR1_SMP18_Pos)                /*!< 0x01000000 */
N#define ADC_SMPR1_SMP18_1         (0x2UL << ADC_SMPR1_SMP18_Pos)                /*!< 0x02000000 */
N#define ADC_SMPR1_SMP18_2         (0x4UL << ADC_SMPR1_SMP18_Pos)                /*!< 0x04000000 */
N
N/******************  Bit definition for ADC_SMPR2 register  *******************/
N#define ADC_SMPR2_SMP0_Pos        (0U)                                         
N#define ADC_SMPR2_SMP0_Msk        (0x7UL << ADC_SMPR2_SMP0_Pos)                 /*!< 0x00000007 */
N#define ADC_SMPR2_SMP0            ADC_SMPR2_SMP0_Msk                           /*!<SMP0[2:0] bits (Channel 0 Sample time selection) */
N#define ADC_SMPR2_SMP0_0          (0x1UL << ADC_SMPR2_SMP0_Pos)                 /*!< 0x00000001 */
N#define ADC_SMPR2_SMP0_1          (0x2UL << ADC_SMPR2_SMP0_Pos)                 /*!< 0x00000002 */
N#define ADC_SMPR2_SMP0_2          (0x4UL << ADC_SMPR2_SMP0_Pos)                 /*!< 0x00000004 */
N#define ADC_SMPR2_SMP1_Pos        (3U)                                         
N#define ADC_SMPR2_SMP1_Msk        (0x7UL << ADC_SMPR2_SMP1_Pos)                 /*!< 0x00000038 */
N#define ADC_SMPR2_SMP1            ADC_SMPR2_SMP1_Msk                           /*!<SMP1[2:0] bits (Channel 1 Sample time selection) */
N#define ADC_SMPR2_SMP1_0          (0x1UL << ADC_SMPR2_SMP1_Pos)                 /*!< 0x00000008 */
N#define ADC_SMPR2_SMP1_1          (0x2UL << ADC_SMPR2_SMP1_Pos)                 /*!< 0x00000010 */
N#define ADC_SMPR2_SMP1_2          (0x4UL << ADC_SMPR2_SMP1_Pos)                 /*!< 0x00000020 */
N#define ADC_SMPR2_SMP2_Pos        (6U)                                         
N#define ADC_SMPR2_SMP2_Msk        (0x7UL << ADC_SMPR2_SMP2_Pos)                 /*!< 0x000001C0 */
N#define ADC_SMPR2_SMP2            ADC_SMPR2_SMP2_Msk                           /*!<SMP2[2:0] bits (Channel 2 Sample time selection) */
N#define ADC_SMPR2_SMP2_0          (0x1UL << ADC_SMPR2_SMP2_Pos)                 /*!< 0x00000040 */
N#define ADC_SMPR2_SMP2_1          (0x2UL << ADC_SMPR2_SMP2_Pos)                 /*!< 0x00000080 */
N#define ADC_SMPR2_SMP2_2          (0x4UL << ADC_SMPR2_SMP2_Pos)                 /*!< 0x00000100 */
N#define ADC_SMPR2_SMP3_Pos        (9U)                                         
N#define ADC_SMPR2_SMP3_Msk        (0x7UL << ADC_SMPR2_SMP3_Pos)                 /*!< 0x00000E00 */
N#define ADC_SMPR2_SMP3            ADC_SMPR2_SMP3_Msk                           /*!<SMP3[2:0] bits (Channel 3 Sample time selection) */
N#define ADC_SMPR2_SMP3_0          (0x1UL << ADC_SMPR2_SMP3_Pos)                 /*!< 0x00000200 */
N#define ADC_SMPR2_SMP3_1          (0x2UL << ADC_SMPR2_SMP3_Pos)                 /*!< 0x00000400 */
N#define ADC_SMPR2_SMP3_2          (0x4UL << ADC_SMPR2_SMP3_Pos)                 /*!< 0x00000800 */
N#define ADC_SMPR2_SMP4_Pos        (12U)                                        
N#define ADC_SMPR2_SMP4_Msk        (0x7UL << ADC_SMPR2_SMP4_Pos)                 /*!< 0x00007000 */
N#define ADC_SMPR2_SMP4            ADC_SMPR2_SMP4_Msk                           /*!<SMP4[2:0] bits (Channel 4 Sample time selection) */
N#define ADC_SMPR2_SMP4_0          (0x1UL << ADC_SMPR2_SMP4_Pos)                 /*!< 0x00001000 */
N#define ADC_SMPR2_SMP4_1          (0x2UL << ADC_SMPR2_SMP4_Pos)                 /*!< 0x00002000 */
N#define ADC_SMPR2_SMP4_2          (0x4UL << ADC_SMPR2_SMP4_Pos)                 /*!< 0x00004000 */
N#define ADC_SMPR2_SMP5_Pos        (15U)                                        
N#define ADC_SMPR2_SMP5_Msk        (0x7UL << ADC_SMPR2_SMP5_Pos)                 /*!< 0x00038000 */
N#define ADC_SMPR2_SMP5            ADC_SMPR2_SMP5_Msk                           /*!<SMP5[2:0] bits (Channel 5 Sample time selection) */
N#define ADC_SMPR2_SMP5_0          (0x1UL << ADC_SMPR2_SMP5_Pos)                 /*!< 0x00008000 */
N#define ADC_SMPR2_SMP5_1          (0x2UL << ADC_SMPR2_SMP5_Pos)                 /*!< 0x00010000 */
N#define ADC_SMPR2_SMP5_2          (0x4UL << ADC_SMPR2_SMP5_Pos)                 /*!< 0x00020000 */
N#define ADC_SMPR2_SMP6_Pos        (18U)                                        
N#define ADC_SMPR2_SMP6_Msk        (0x7UL << ADC_SMPR2_SMP6_Pos)                 /*!< 0x001C0000 */
N#define ADC_SMPR2_SMP6            ADC_SMPR2_SMP6_Msk                           /*!<SMP6[2:0] bits (Channel 6 Sample time selection) */
N#define ADC_SMPR2_SMP6_0          (0x1UL << ADC_SMPR2_SMP6_Pos)                 /*!< 0x00040000 */
N#define ADC_SMPR2_SMP6_1          (0x2UL << ADC_SMPR2_SMP6_Pos)                 /*!< 0x00080000 */
N#define ADC_SMPR2_SMP6_2          (0x4UL << ADC_SMPR2_SMP6_Pos)                 /*!< 0x00100000 */
N#define ADC_SMPR2_SMP7_Pos        (21U)                                        
N#define ADC_SMPR2_SMP7_Msk        (0x7UL << ADC_SMPR2_SMP7_Pos)                 /*!< 0x00E00000 */
N#define ADC_SMPR2_SMP7            ADC_SMPR2_SMP7_Msk                           /*!<SMP7[2:0] bits (Channel 7 Sample time selection) */
N#define ADC_SMPR2_SMP7_0          (0x1UL << ADC_SMPR2_SMP7_Pos)                 /*!< 0x00200000 */
N#define ADC_SMPR2_SMP7_1          (0x2UL << ADC_SMPR2_SMP7_Pos)                 /*!< 0x00400000 */
N#define ADC_SMPR2_SMP7_2          (0x4UL << ADC_SMPR2_SMP7_Pos)                 /*!< 0x00800000 */
N#define ADC_SMPR2_SMP8_Pos        (24U)                                        
N#define ADC_SMPR2_SMP8_Msk        (0x7UL << ADC_SMPR2_SMP8_Pos)                 /*!< 0x07000000 */
N#define ADC_SMPR2_SMP8            ADC_SMPR2_SMP8_Msk                           /*!<SMP8[2:0] bits (Channel 8 Sample time selection) */
N#define ADC_SMPR2_SMP8_0          (0x1UL << ADC_SMPR2_SMP8_Pos)                 /*!< 0x01000000 */
N#define ADC_SMPR2_SMP8_1          (0x2UL << ADC_SMPR2_SMP8_Pos)                 /*!< 0x02000000 */
N#define ADC_SMPR2_SMP8_2          (0x4UL << ADC_SMPR2_SMP8_Pos)                 /*!< 0x04000000 */
N#define ADC_SMPR2_SMP9_Pos        (27U)                                        
N#define ADC_SMPR2_SMP9_Msk        (0x7UL << ADC_SMPR2_SMP9_Pos)                 /*!< 0x38000000 */
N#define ADC_SMPR2_SMP9            ADC_SMPR2_SMP9_Msk                           /*!<SMP9[2:0] bits (Channel 9 Sample time selection) */
N#define ADC_SMPR2_SMP9_0          (0x1UL << ADC_SMPR2_SMP9_Pos)                 /*!< 0x08000000 */
N#define ADC_SMPR2_SMP9_1          (0x2UL << ADC_SMPR2_SMP9_Pos)                 /*!< 0x10000000 */
N#define ADC_SMPR2_SMP9_2          (0x4UL << ADC_SMPR2_SMP9_Pos)                 /*!< 0x20000000 */
N
N/******************  Bit definition for ADC_JOFR1 register  *******************/
N#define ADC_JOFR1_JOFFSET1_Pos    (0U)                                         
N#define ADC_JOFR1_JOFFSET1_Msk    (0xFFFUL << ADC_JOFR1_JOFFSET1_Pos)           /*!< 0x00000FFF */
N#define ADC_JOFR1_JOFFSET1        ADC_JOFR1_JOFFSET1_Msk                       /*!<Data offset for injected channel 1 */
N
N/******************  Bit definition for ADC_JOFR2 register  *******************/
N#define ADC_JOFR2_JOFFSET2_Pos    (0U)                                         
N#define ADC_JOFR2_JOFFSET2_Msk    (0xFFFUL << ADC_JOFR2_JOFFSET2_Pos)           /*!< 0x00000FFF */
N#define ADC_JOFR2_JOFFSET2        ADC_JOFR2_JOFFSET2_Msk                       /*!<Data offset for injected channel 2 */
N
N/******************  Bit definition for ADC_JOFR3 register  *******************/
N#define ADC_JOFR3_JOFFSET3_Pos    (0U)                                         
N#define ADC_JOFR3_JOFFSET3_Msk    (0xFFFUL << ADC_JOFR3_JOFFSET3_Pos)           /*!< 0x00000FFF */
N#define ADC_JOFR3_JOFFSET3        ADC_JOFR3_JOFFSET3_Msk                       /*!<Data offset for injected channel 3 */
N
N/******************  Bit definition for ADC_JOFR4 register  *******************/
N#define ADC_JOFR4_JOFFSET4_Pos    (0U)                                         
N#define ADC_JOFR4_JOFFSET4_Msk    (0xFFFUL << ADC_JOFR4_JOFFSET4_Pos)           /*!< 0x00000FFF */
N#define ADC_JOFR4_JOFFSET4        ADC_JOFR4_JOFFSET4_Msk                       /*!<Data offset for injected channel 4 */
N
N/*******************  Bit definition for ADC_HTR register  ********************/
N#define ADC_HTR_HT_Pos            (0U)                                         
N#define ADC_HTR_HT_Msk            (0xFFFUL << ADC_HTR_HT_Pos)                   /*!< 0x00000FFF */
N#define ADC_HTR_HT                ADC_HTR_HT_Msk                               /*!<Analog watchdog high threshold */
N
N/*******************  Bit definition for ADC_LTR register  ********************/
N#define ADC_LTR_LT_Pos            (0U)                                         
N#define ADC_LTR_LT_Msk            (0xFFFUL << ADC_LTR_LT_Pos)                   /*!< 0x00000FFF */
N#define ADC_LTR_LT                ADC_LTR_LT_Msk                               /*!<Analog watchdog low threshold */
N
N/*******************  Bit definition for ADC_SQR1 register  *******************/
N#define ADC_SQR1_SQ13_Pos         (0U)                                         
N#define ADC_SQR1_SQ13_Msk         (0x1FUL << ADC_SQR1_SQ13_Pos)                 /*!< 0x0000001F */
N#define ADC_SQR1_SQ13             ADC_SQR1_SQ13_Msk                            /*!<SQ13[4:0] bits (13th conversion in regular sequence) */
N#define ADC_SQR1_SQ13_0           (0x01UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000001 */
N#define ADC_SQR1_SQ13_1           (0x02UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000002 */
N#define ADC_SQR1_SQ13_2           (0x04UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000004 */
N#define ADC_SQR1_SQ13_3           (0x08UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000008 */
N#define ADC_SQR1_SQ13_4           (0x10UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000010 */
N#define ADC_SQR1_SQ14_Pos         (5U)                                         
N#define ADC_SQR1_SQ14_Msk         (0x1FUL << ADC_SQR1_SQ14_Pos)                 /*!< 0x000003E0 */
N#define ADC_SQR1_SQ14             ADC_SQR1_SQ14_Msk                            /*!<SQ14[4:0] bits (14th conversion in regular sequence) */
N#define ADC_SQR1_SQ14_0           (0x01UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000020 */
N#define ADC_SQR1_SQ14_1           (0x02UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000040 */
N#define ADC_SQR1_SQ14_2           (0x04UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000080 */
N#define ADC_SQR1_SQ14_3           (0x08UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000100 */
N#define ADC_SQR1_SQ14_4           (0x10UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000200 */
N#define ADC_SQR1_SQ15_Pos         (10U)                                        
N#define ADC_SQR1_SQ15_Msk         (0x1FUL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00007C00 */
N#define ADC_SQR1_SQ15             ADC_SQR1_SQ15_Msk                            /*!<SQ15[4:0] bits (15th conversion in regular sequence) */
N#define ADC_SQR1_SQ15_0           (0x01UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00000400 */
N#define ADC_SQR1_SQ15_1           (0x02UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00000800 */
N#define ADC_SQR1_SQ15_2           (0x04UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00001000 */
N#define ADC_SQR1_SQ15_3           (0x08UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00002000 */
N#define ADC_SQR1_SQ15_4           (0x10UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00004000 */
N#define ADC_SQR1_SQ16_Pos         (15U)                                        
N#define ADC_SQR1_SQ16_Msk         (0x1FUL << ADC_SQR1_SQ16_Pos)                 /*!< 0x000F8000 */
N#define ADC_SQR1_SQ16             ADC_SQR1_SQ16_Msk                            /*!<SQ16[4:0] bits (16th conversion in regular sequence) */
N#define ADC_SQR1_SQ16_0           (0x01UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00008000 */
N#define ADC_SQR1_SQ16_1           (0x02UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00010000 */
N#define ADC_SQR1_SQ16_2           (0x04UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00020000 */
N#define ADC_SQR1_SQ16_3           (0x08UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00040000 */
N#define ADC_SQR1_SQ16_4           (0x10UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00080000 */
N#define ADC_SQR1_L_Pos            (20U)                                        
N#define ADC_SQR1_L_Msk            (0xFUL << ADC_SQR1_L_Pos)                     /*!< 0x00F00000 */
N#define ADC_SQR1_L                ADC_SQR1_L_Msk                               /*!<L[3:0] bits (Regular channel sequence length) */
N#define ADC_SQR1_L_0              (0x1UL << ADC_SQR1_L_Pos)                     /*!< 0x00100000 */
N#define ADC_SQR1_L_1              (0x2UL << ADC_SQR1_L_Pos)                     /*!< 0x00200000 */
N#define ADC_SQR1_L_2              (0x4UL << ADC_SQR1_L_Pos)                     /*!< 0x00400000 */
N#define ADC_SQR1_L_3              (0x8UL << ADC_SQR1_L_Pos)                     /*!< 0x00800000 */
N
N/*******************  Bit definition for ADC_SQR2 register  *******************/
N#define ADC_SQR2_SQ7_Pos          (0U)                                         
N#define ADC_SQR2_SQ7_Msk          (0x1FUL << ADC_SQR2_SQ7_Pos)                  /*!< 0x0000001F */
N#define ADC_SQR2_SQ7              ADC_SQR2_SQ7_Msk                             /*!<SQ7[4:0] bits (7th conversion in regular sequence) */
N#define ADC_SQR2_SQ7_0            (0x01UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000001 */
N#define ADC_SQR2_SQ7_1            (0x02UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000002 */
N#define ADC_SQR2_SQ7_2            (0x04UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000004 */
N#define ADC_SQR2_SQ7_3            (0x08UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000008 */
N#define ADC_SQR2_SQ7_4            (0x10UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000010 */
N#define ADC_SQR2_SQ8_Pos          (5U)                                         
N#define ADC_SQR2_SQ8_Msk          (0x1FUL << ADC_SQR2_SQ8_Pos)                  /*!< 0x000003E0 */
N#define ADC_SQR2_SQ8              ADC_SQR2_SQ8_Msk                             /*!<SQ8[4:0] bits (8th conversion in regular sequence) */
N#define ADC_SQR2_SQ8_0            (0x01UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000020 */
N#define ADC_SQR2_SQ8_1            (0x02UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000040 */
N#define ADC_SQR2_SQ8_2            (0x04UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000080 */
N#define ADC_SQR2_SQ8_3            (0x08UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000100 */
N#define ADC_SQR2_SQ8_4            (0x10UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000200 */
N#define ADC_SQR2_SQ9_Pos          (10U)                                        
N#define ADC_SQR2_SQ9_Msk          (0x1FUL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00007C00 */
N#define ADC_SQR2_SQ9              ADC_SQR2_SQ9_Msk                             /*!<SQ9[4:0] bits (9th conversion in regular sequence) */
N#define ADC_SQR2_SQ9_0            (0x01UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00000400 */
N#define ADC_SQR2_SQ9_1            (0x02UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00000800 */
N#define ADC_SQR2_SQ9_2            (0x04UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00001000 */
N#define ADC_SQR2_SQ9_3            (0x08UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00002000 */
N#define ADC_SQR2_SQ9_4            (0x10UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00004000 */
N#define ADC_SQR2_SQ10_Pos         (15U)                                        
N#define ADC_SQR2_SQ10_Msk         (0x1FUL << ADC_SQR2_SQ10_Pos)                 /*!< 0x000F8000 */
N#define ADC_SQR2_SQ10             ADC_SQR2_SQ10_Msk                            /*!<SQ10[4:0] bits (10th conversion in regular sequence) */
N#define ADC_SQR2_SQ10_0           (0x01UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00008000 */
N#define ADC_SQR2_SQ10_1           (0x02UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00010000 */
N#define ADC_SQR2_SQ10_2           (0x04UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00020000 */
N#define ADC_SQR2_SQ10_3           (0x08UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00040000 */
N#define ADC_SQR2_SQ10_4           (0x10UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00080000 */
N#define ADC_SQR2_SQ11_Pos         (20U)                                        
N#define ADC_SQR2_SQ11_Msk         (0x1FUL << ADC_SQR2_SQ11_Pos)                 /*!< 0x01F00000 */
N#define ADC_SQR2_SQ11             ADC_SQR2_SQ11_Msk                            /*!<SQ11[4:0] bits (11th conversion in regular sequence) */
N#define ADC_SQR2_SQ11_0           (0x01UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x00100000 */
N#define ADC_SQR2_SQ11_1           (0x02UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x00200000 */
N#define ADC_SQR2_SQ11_2           (0x04UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x00400000 */
N#define ADC_SQR2_SQ11_3           (0x08UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x00800000 */
N#define ADC_SQR2_SQ11_4           (0x10UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x01000000 */
N#define ADC_SQR2_SQ12_Pos         (25U)                                        
N#define ADC_SQR2_SQ12_Msk         (0x1FUL << ADC_SQR2_SQ12_Pos)                 /*!< 0x3E000000 */
N#define ADC_SQR2_SQ12             ADC_SQR2_SQ12_Msk                            /*!<SQ12[4:0] bits (12th conversion in regular sequence) */
N#define ADC_SQR2_SQ12_0           (0x01UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x02000000 */
N#define ADC_SQR2_SQ12_1           (0x02UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x04000000 */
N#define ADC_SQR2_SQ12_2           (0x04UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x08000000 */
N#define ADC_SQR2_SQ12_3           (0x08UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x10000000 */
N#define ADC_SQR2_SQ12_4           (0x10UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x20000000 */
N
N/*******************  Bit definition for ADC_SQR3 register  *******************/
N#define ADC_SQR3_SQ1_Pos          (0U)                                         
N#define ADC_SQR3_SQ1_Msk          (0x1FUL << ADC_SQR3_SQ1_Pos)                  /*!< 0x0000001F */
N#define ADC_SQR3_SQ1              ADC_SQR3_SQ1_Msk                             /*!<SQ1[4:0] bits (1st conversion in regular sequence) */
N#define ADC_SQR3_SQ1_0            (0x01UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000001 */
N#define ADC_SQR3_SQ1_1            (0x02UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000002 */
N#define ADC_SQR3_SQ1_2            (0x04UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000004 */
N#define ADC_SQR3_SQ1_3            (0x08UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000008 */
N#define ADC_SQR3_SQ1_4            (0x10UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000010 */
N#define ADC_SQR3_SQ2_Pos          (5U)                                         
N#define ADC_SQR3_SQ2_Msk          (0x1FUL << ADC_SQR3_SQ2_Pos)                  /*!< 0x000003E0 */
N#define ADC_SQR3_SQ2              ADC_SQR3_SQ2_Msk                             /*!<SQ2[4:0] bits (2nd conversion in regular sequence) */
N#define ADC_SQR3_SQ2_0            (0x01UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000020 */
N#define ADC_SQR3_SQ2_1            (0x02UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000040 */
N#define ADC_SQR3_SQ2_2            (0x04UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000080 */
N#define ADC_SQR3_SQ2_3            (0x08UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000100 */
N#define ADC_SQR3_SQ2_4            (0x10UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000200 */
N#define ADC_SQR3_SQ3_Pos          (10U)                                        
N#define ADC_SQR3_SQ3_Msk          (0x1FUL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00007C00 */
N#define ADC_SQR3_SQ3              ADC_SQR3_SQ3_Msk                             /*!<SQ3[4:0] bits (3rd conversion in regular sequence) */
N#define ADC_SQR3_SQ3_0            (0x01UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00000400 */
N#define ADC_SQR3_SQ3_1            (0x02UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00000800 */
N#define ADC_SQR3_SQ3_2            (0x04UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00001000 */
N#define ADC_SQR3_SQ3_3            (0x08UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00002000 */
N#define ADC_SQR3_SQ3_4            (0x10UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00004000 */
N#define ADC_SQR3_SQ4_Pos          (15U)                                        
N#define ADC_SQR3_SQ4_Msk          (0x1FUL << ADC_SQR3_SQ4_Pos)                  /*!< 0x000F8000 */
N#define ADC_SQR3_SQ4              ADC_SQR3_SQ4_Msk                             /*!<SQ4[4:0] bits (4th conversion in regular sequence) */
N#define ADC_SQR3_SQ4_0            (0x01UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00008000 */
N#define ADC_SQR3_SQ4_1            (0x02UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00010000 */
N#define ADC_SQR3_SQ4_2            (0x04UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00020000 */
N#define ADC_SQR3_SQ4_3            (0x08UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00040000 */
N#define ADC_SQR3_SQ4_4            (0x10UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00080000 */
N#define ADC_SQR3_SQ5_Pos          (20U)                                        
N#define ADC_SQR3_SQ5_Msk          (0x1FUL << ADC_SQR3_SQ5_Pos)                  /*!< 0x01F00000 */
N#define ADC_SQR3_SQ5              ADC_SQR3_SQ5_Msk                             /*!<SQ5[4:0] bits (5th conversion in regular sequence) */
N#define ADC_SQR3_SQ5_0            (0x01UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x00100000 */
N#define ADC_SQR3_SQ5_1            (0x02UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x00200000 */
N#define ADC_SQR3_SQ5_2            (0x04UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x00400000 */
N#define ADC_SQR3_SQ5_3            (0x08UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x00800000 */
N#define ADC_SQR3_SQ5_4            (0x10UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x01000000 */
N#define ADC_SQR3_SQ6_Pos          (25U)                                        
N#define ADC_SQR3_SQ6_Msk          (0x1FUL << ADC_SQR3_SQ6_Pos)                  /*!< 0x3E000000 */
N#define ADC_SQR3_SQ6              ADC_SQR3_SQ6_Msk                             /*!<SQ6[4:0] bits (6th conversion in regular sequence) */
N#define ADC_SQR3_SQ6_0            (0x01UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x02000000 */
N#define ADC_SQR3_SQ6_1            (0x02UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x04000000 */
N#define ADC_SQR3_SQ6_2            (0x04UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x08000000 */
N#define ADC_SQR3_SQ6_3            (0x08UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x10000000 */
N#define ADC_SQR3_SQ6_4            (0x10UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x20000000 */
N
N/*******************  Bit definition for ADC_JSQR register  *******************/
N#define ADC_JSQR_JSQ1_Pos         (0U)                                         
N#define ADC_JSQR_JSQ1_Msk         (0x1FUL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x0000001F */
N#define ADC_JSQR_JSQ1             ADC_JSQR_JSQ1_Msk                            /*!<JSQ1[4:0] bits (1st conversion in injected sequence) */  
N#define ADC_JSQR_JSQ1_0           (0x01UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000001 */
N#define ADC_JSQR_JSQ1_1           (0x02UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000002 */
N#define ADC_JSQR_JSQ1_2           (0x04UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000004 */
N#define ADC_JSQR_JSQ1_3           (0x08UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000008 */
N#define ADC_JSQR_JSQ1_4           (0x10UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000010 */
N#define ADC_JSQR_JSQ2_Pos         (5U)                                         
N#define ADC_JSQR_JSQ2_Msk         (0x1FUL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x000003E0 */
N#define ADC_JSQR_JSQ2             ADC_JSQR_JSQ2_Msk                            /*!<JSQ2[4:0] bits (2nd conversion in injected sequence) */
N#define ADC_JSQR_JSQ2_0           (0x01UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000020 */
N#define ADC_JSQR_JSQ2_1           (0x02UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000040 */
N#define ADC_JSQR_JSQ2_2           (0x04UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000080 */
N#define ADC_JSQR_JSQ2_3           (0x08UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000100 */
N#define ADC_JSQR_JSQ2_4           (0x10UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000200 */
N#define ADC_JSQR_JSQ3_Pos         (10U)                                        
N#define ADC_JSQR_JSQ3_Msk         (0x1FUL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00007C00 */
N#define ADC_JSQR_JSQ3             ADC_JSQR_JSQ3_Msk                            /*!<JSQ3[4:0] bits (3rd conversion in injected sequence) */
N#define ADC_JSQR_JSQ3_0           (0x01UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00000400 */
N#define ADC_JSQR_JSQ3_1           (0x02UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00000800 */
N#define ADC_JSQR_JSQ3_2           (0x04UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00001000 */
N#define ADC_JSQR_JSQ3_3           (0x08UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00002000 */
N#define ADC_JSQR_JSQ3_4           (0x10UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00004000 */
N#define ADC_JSQR_JSQ4_Pos         (15U)                                        
N#define ADC_JSQR_JSQ4_Msk         (0x1FUL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x000F8000 */
N#define ADC_JSQR_JSQ4             ADC_JSQR_JSQ4_Msk                            /*!<JSQ4[4:0] bits (4th conversion in injected sequence) */
N#define ADC_JSQR_JSQ4_0           (0x01UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00008000 */
N#define ADC_JSQR_JSQ4_1           (0x02UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00010000 */
N#define ADC_JSQR_JSQ4_2           (0x04UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00020000 */
N#define ADC_JSQR_JSQ4_3           (0x08UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00040000 */
N#define ADC_JSQR_JSQ4_4           (0x10UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00080000 */
N#define ADC_JSQR_JL_Pos           (20U)                                        
N#define ADC_JSQR_JL_Msk           (0x3UL << ADC_JSQR_JL_Pos)                    /*!< 0x00300000 */
N#define ADC_JSQR_JL               ADC_JSQR_JL_Msk                              /*!<JL[1:0] bits (Injected Sequence length) */
N#define ADC_JSQR_JL_0             (0x1UL << ADC_JSQR_JL_Pos)                    /*!< 0x00100000 */
N#define ADC_JSQR_JL_1             (0x2UL << ADC_JSQR_JL_Pos)                    /*!< 0x00200000 */
N
N/*******************  Bit definition for ADC_JDR1 register  *******************/
N#define ADC_JDR1_JDATA_Pos        (0U)                                         
N#define ADC_JDR1_JDATA_Msk        (0xFFFFUL << ADC_JDR1_JDATA_Pos)              /*!< 0x0000FFFF */
N#define ADC_JDR1_JDATA            ADC_JDR1_JDATA_Msk                           /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR2 register  *******************/
N#define ADC_JDR2_JDATA_Pos        (0U)                                         
N#define ADC_JDR2_JDATA_Msk        (0xFFFFUL << ADC_JDR2_JDATA_Pos)              /*!< 0x0000FFFF */
N#define ADC_JDR2_JDATA            ADC_JDR2_JDATA_Msk                           /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR3 register  *******************/
N#define ADC_JDR3_JDATA_Pos        (0U)                                         
N#define ADC_JDR3_JDATA_Msk        (0xFFFFUL << ADC_JDR3_JDATA_Pos)              /*!< 0x0000FFFF */
N#define ADC_JDR3_JDATA            ADC_JDR3_JDATA_Msk                           /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR4 register  *******************/
N#define ADC_JDR4_JDATA_Pos        (0U)                                         
N#define ADC_JDR4_JDATA_Msk        (0xFFFFUL << ADC_JDR4_JDATA_Pos)              /*!< 0x0000FFFF */
N#define ADC_JDR4_JDATA            ADC_JDR4_JDATA_Msk                           /*!<Injected data */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define ADC_DR_DATA_Pos           (0U)                                         
N#define ADC_DR_DATA_Msk           (0xFFFFUL << ADC_DR_DATA_Pos)                 /*!< 0x0000FFFF */
N#define ADC_DR_DATA               ADC_DR_DATA_Msk                              /*!<Regular data */
N#define ADC_DR_ADC2DATA_Pos       (16U)                                        
N#define ADC_DR_ADC2DATA_Msk       (0xFFFFUL << ADC_DR_ADC2DATA_Pos)             /*!< 0xFFFF0000 */
N#define ADC_DR_ADC2DATA           ADC_DR_ADC2DATA_Msk                          /*!<ADC2 data */
N
N/*******************  Bit definition for ADC_CSR register  ********************/
N#define ADC_CSR_AWD1_Pos          (0U)                                         
N#define ADC_CSR_AWD1_Msk          (0x1UL << ADC_CSR_AWD1_Pos)                   /*!< 0x00000001 */
N#define ADC_CSR_AWD1              ADC_CSR_AWD1_Msk                             /*!<ADC1 Analog watchdog flag */
N#define ADC_CSR_EOC1_Pos          (1U)                                         
N#define ADC_CSR_EOC1_Msk          (0x1UL << ADC_CSR_EOC1_Pos)                   /*!< 0x00000002 */
N#define ADC_CSR_EOC1              ADC_CSR_EOC1_Msk                             /*!<ADC1 End of conversion */
N#define ADC_CSR_JEOC1_Pos         (2U)                                         
N#define ADC_CSR_JEOC1_Msk         (0x1UL << ADC_CSR_JEOC1_Pos)                  /*!< 0x00000004 */
N#define ADC_CSR_JEOC1             ADC_CSR_JEOC1_Msk                            /*!<ADC1 Injected channel end of conversion */
N#define ADC_CSR_JSTRT1_Pos        (3U)                                         
N#define ADC_CSR_JSTRT1_Msk        (0x1UL << ADC_CSR_JSTRT1_Pos)                 /*!< 0x00000008 */
N#define ADC_CSR_JSTRT1            ADC_CSR_JSTRT1_Msk                           /*!<ADC1 Injected channel Start flag */
N#define ADC_CSR_STRT1_Pos         (4U)                                         
N#define ADC_CSR_STRT1_Msk         (0x1UL << ADC_CSR_STRT1_Pos)                  /*!< 0x00000010 */
N#define ADC_CSR_STRT1             ADC_CSR_STRT1_Msk                            /*!<ADC1 Regular channel Start flag */
N#define ADC_CSR_OVR1_Pos          (5U)                                         
N#define ADC_CSR_OVR1_Msk          (0x1UL << ADC_CSR_OVR1_Pos)                   /*!< 0x00000020 */
N#define ADC_CSR_OVR1              ADC_CSR_OVR1_Msk                             /*!<ADC1 DMA overrun  flag */
N#define ADC_CSR_AWD2_Pos          (8U)                                         
N#define ADC_CSR_AWD2_Msk          (0x1UL << ADC_CSR_AWD2_Pos)                   /*!< 0x00000100 */
N#define ADC_CSR_AWD2              ADC_CSR_AWD2_Msk                             /*!<ADC2 Analog watchdog flag */
N#define ADC_CSR_EOC2_Pos          (9U)                                         
N#define ADC_CSR_EOC2_Msk          (0x1UL << ADC_CSR_EOC2_Pos)                   /*!< 0x00000200 */
N#define ADC_CSR_EOC2              ADC_CSR_EOC2_Msk                             /*!<ADC2 End of conversion */
N#define ADC_CSR_JEOC2_Pos         (10U)                                        
N#define ADC_CSR_JEOC2_Msk         (0x1UL << ADC_CSR_JEOC2_Pos)                  /*!< 0x00000400 */
N#define ADC_CSR_JEOC2             ADC_CSR_JEOC2_Msk                            /*!<ADC2 Injected channel end of conversion */
N#define ADC_CSR_JSTRT2_Pos        (11U)                                        
N#define ADC_CSR_JSTRT2_Msk        (0x1UL << ADC_CSR_JSTRT2_Pos)                 /*!< 0x00000800 */
N#define ADC_CSR_JSTRT2            ADC_CSR_JSTRT2_Msk                           /*!<ADC2 Injected channel Start flag */
N#define ADC_CSR_STRT2_Pos         (12U)                                        
N#define ADC_CSR_STRT2_Msk         (0x1UL << ADC_CSR_STRT2_Pos)                  /*!< 0x00001000 */
N#define ADC_CSR_STRT2             ADC_CSR_STRT2_Msk                            /*!<ADC2 Regular channel Start flag */
N#define ADC_CSR_OVR2_Pos          (13U)                                        
N#define ADC_CSR_OVR2_Msk          (0x1UL << ADC_CSR_OVR2_Pos)                   /*!< 0x00002000 */
N#define ADC_CSR_OVR2              ADC_CSR_OVR2_Msk                             /*!<ADC2 DMA overrun  flag */
N#define ADC_CSR_AWD3_Pos          (16U)                                        
N#define ADC_CSR_AWD3_Msk          (0x1UL << ADC_CSR_AWD3_Pos)                   /*!< 0x00010000 */
N#define ADC_CSR_AWD3              ADC_CSR_AWD3_Msk                             /*!<ADC3 Analog watchdog flag */
N#define ADC_CSR_EOC3_Pos          (17U)                                        
N#define ADC_CSR_EOC3_Msk          (0x1UL << ADC_CSR_EOC3_Pos)                   /*!< 0x00020000 */
N#define ADC_CSR_EOC3              ADC_CSR_EOC3_Msk                             /*!<ADC3 End of conversion */
N#define ADC_CSR_JEOC3_Pos         (18U)                                        
N#define ADC_CSR_JEOC3_Msk         (0x1UL << ADC_CSR_JEOC3_Pos)                  /*!< 0x00040000 */
N#define ADC_CSR_JEOC3             ADC_CSR_JEOC3_Msk                            /*!<ADC3 Injected channel end of conversion */
N#define ADC_CSR_JSTRT3_Pos        (19U)                                        
N#define ADC_CSR_JSTRT3_Msk        (0x1UL << ADC_CSR_JSTRT3_Pos)                 /*!< 0x00080000 */
N#define ADC_CSR_JSTRT3            ADC_CSR_JSTRT3_Msk                           /*!<ADC3 Injected channel Start flag */
N#define ADC_CSR_STRT3_Pos         (20U)                                        
N#define ADC_CSR_STRT3_Msk         (0x1UL << ADC_CSR_STRT3_Pos)                  /*!< 0x00100000 */
N#define ADC_CSR_STRT3             ADC_CSR_STRT3_Msk                            /*!<ADC3 Regular channel Start flag */
N#define ADC_CSR_OVR3_Pos          (21U)                                        
N#define ADC_CSR_OVR3_Msk          (0x1UL << ADC_CSR_OVR3_Pos)                   /*!< 0x00200000 */
N#define ADC_CSR_OVR3              ADC_CSR_OVR3_Msk                             /*!<ADC3 DMA overrun  flag */
N
N/* Legacy defines */
N#define  ADC_CSR_DOVR1                        ADC_CSR_OVR1
N#define  ADC_CSR_DOVR2                        ADC_CSR_OVR2
N#define  ADC_CSR_DOVR3                        ADC_CSR_OVR3
N
N/*******************  Bit definition for ADC_CCR register  ********************/
N#define ADC_CCR_MULTI_Pos         (0U)                                         
N#define ADC_CCR_MULTI_Msk         (0x1FUL << ADC_CCR_MULTI_Pos)                 /*!< 0x0000001F */
N#define ADC_CCR_MULTI             ADC_CCR_MULTI_Msk                            /*!<MULTI[4:0] bits (Multi-ADC mode selection) */  
N#define ADC_CCR_MULTI_0           (0x01UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000001 */
N#define ADC_CCR_MULTI_1           (0x02UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000002 */
N#define ADC_CCR_MULTI_2           (0x04UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000004 */
N#define ADC_CCR_MULTI_3           (0x08UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000008 */
N#define ADC_CCR_MULTI_4           (0x10UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000010 */
N#define ADC_CCR_DELAY_Pos         (8U)                                         
N#define ADC_CCR_DELAY_Msk         (0xFUL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000F00 */
N#define ADC_CCR_DELAY             ADC_CCR_DELAY_Msk                            /*!<DELAY[3:0] bits (Delay between 2 sampling phases) */  
N#define ADC_CCR_DELAY_0           (0x1UL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000100 */
N#define ADC_CCR_DELAY_1           (0x2UL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000200 */
N#define ADC_CCR_DELAY_2           (0x4UL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000400 */
N#define ADC_CCR_DELAY_3           (0x8UL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000800 */
N#define ADC_CCR_DDS_Pos           (13U)                                        
N#define ADC_CCR_DDS_Msk           (0x1UL << ADC_CCR_DDS_Pos)                    /*!< 0x00002000 */
N#define ADC_CCR_DDS               ADC_CCR_DDS_Msk                              /*!<DMA disable selection (Multi-ADC mode) */
N#define ADC_CCR_DMA_Pos           (14U)                                        
N#define ADC_CCR_DMA_Msk           (0x3UL << ADC_CCR_DMA_Pos)                    /*!< 0x0000C000 */
N#define ADC_CCR_DMA               ADC_CCR_DMA_Msk                              /*!<DMA[1:0] bits (Direct Memory Access mode for multimode) */  
N#define ADC_CCR_DMA_0             (0x1UL << ADC_CCR_DMA_Pos)                    /*!< 0x00004000 */
N#define ADC_CCR_DMA_1             (0x2UL << ADC_CCR_DMA_Pos)                    /*!< 0x00008000 */
N#define ADC_CCR_ADCPRE_Pos        (16U)                                        
N#define ADC_CCR_ADCPRE_Msk        (0x3UL << ADC_CCR_ADCPRE_Pos)                 /*!< 0x00030000 */
N#define ADC_CCR_ADCPRE            ADC_CCR_ADCPRE_Msk                           /*!<ADCPRE[1:0] bits (ADC prescaler) */  
N#define ADC_CCR_ADCPRE_0          (0x1UL << ADC_CCR_ADCPRE_Pos)                 /*!< 0x00010000 */
N#define ADC_CCR_ADCPRE_1          (0x2UL << ADC_CCR_ADCPRE_Pos)                 /*!< 0x00020000 */
N#define ADC_CCR_VBATE_Pos         (22U)                                        
N#define ADC_CCR_VBATE_Msk         (0x1UL << ADC_CCR_VBATE_Pos)                  /*!< 0x00400000 */
N#define ADC_CCR_VBATE             ADC_CCR_VBATE_Msk                            /*!<VBAT Enable */
N#define ADC_CCR_TSVREFE_Pos       (23U)                                        
N#define ADC_CCR_TSVREFE_Msk       (0x1UL << ADC_CCR_TSVREFE_Pos)                /*!< 0x00800000 */
N#define ADC_CCR_TSVREFE           ADC_CCR_TSVREFE_Msk                          /*!<Temperature Sensor and VREFINT Enable */
N
N/*******************  Bit definition for ADC_CDR register  ********************/
N#define ADC_CDR_DATA1_Pos         (0U)                                         
N#define ADC_CDR_DATA1_Msk         (0xFFFFUL << ADC_CDR_DATA1_Pos)               /*!< 0x0000FFFF */
N#define ADC_CDR_DATA1             ADC_CDR_DATA1_Msk                            /*!<1st data of a pair of regular conversions */
N#define ADC_CDR_DATA2_Pos         (16U)                                        
N#define ADC_CDR_DATA2_Msk         (0xFFFFUL << ADC_CDR_DATA2_Pos)               /*!< 0xFFFF0000 */
N#define ADC_CDR_DATA2             ADC_CDR_DATA2_Msk                            /*!<2nd data of a pair of regular conversions */
N
N/* Legacy defines */
N#define ADC_CDR_RDATA_MST         ADC_CDR_DATA1
N#define ADC_CDR_RDATA_SLV         ADC_CDR_DATA2
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Controller Area Network                            */
N/*                                                                            */
N/******************************************************************************/
N/*!<CAN control and status registers */
N/*******************  Bit definition for CAN_MCR register  ********************/
N#define CAN_MCR_INRQ_Pos       (0U)                                            
N#define CAN_MCR_INRQ_Msk       (0x1UL << CAN_MCR_INRQ_Pos)                      /*!< 0x00000001 */
N#define CAN_MCR_INRQ           CAN_MCR_INRQ_Msk                                /*!<Initialization Request */
N#define CAN_MCR_SLEEP_Pos      (1U)                                            
N#define CAN_MCR_SLEEP_Msk      (0x1UL << CAN_MCR_SLEEP_Pos)                     /*!< 0x00000002 */
N#define CAN_MCR_SLEEP          CAN_MCR_SLEEP_Msk                               /*!<Sleep Mode Request */
N#define CAN_MCR_TXFP_Pos       (2U)                                            
N#define CAN_MCR_TXFP_Msk       (0x1UL << CAN_MCR_TXFP_Pos)                      /*!< 0x00000004 */
N#define CAN_MCR_TXFP           CAN_MCR_TXFP_Msk                                /*!<Transmit FIFO Priority */
N#define CAN_MCR_RFLM_Pos       (3U)                                            
N#define CAN_MCR_RFLM_Msk       (0x1UL << CAN_MCR_RFLM_Pos)                      /*!< 0x00000008 */
N#define CAN_MCR_RFLM           CAN_MCR_RFLM_Msk                                /*!<Receive FIFO Locked Mode */
N#define CAN_MCR_NART_Pos       (4U)                                            
N#define CAN_MCR_NART_Msk       (0x1UL << CAN_MCR_NART_Pos)                      /*!< 0x00000010 */
N#define CAN_MCR_NART           CAN_MCR_NART_Msk                                /*!<No Automatic Retransmission */
N#define CAN_MCR_AWUM_Pos       (5U)                                            
N#define CAN_MCR_AWUM_Msk       (0x1UL << CAN_MCR_AWUM_Pos)                      /*!< 0x00000020 */
N#define CAN_MCR_AWUM           CAN_MCR_AWUM_Msk                                /*!<Automatic Wakeup Mode */
N#define CAN_MCR_ABOM_Pos       (6U)                                            
N#define CAN_MCR_ABOM_Msk       (0x1UL << CAN_MCR_ABOM_Pos)                      /*!< 0x00000040 */
N#define CAN_MCR_ABOM           CAN_MCR_ABOM_Msk                                /*!<Automatic Bus-Off Management */
N#define CAN_MCR_TTCM_Pos       (7U)                                            
N#define CAN_MCR_TTCM_Msk       (0x1UL << CAN_MCR_TTCM_Pos)                      /*!< 0x00000080 */
N#define CAN_MCR_TTCM           CAN_MCR_TTCM_Msk                                /*!<Time Triggered Communication Mode */
N#define CAN_MCR_RESET_Pos      (15U)                                           
N#define CAN_MCR_RESET_Msk      (0x1UL << CAN_MCR_RESET_Pos)                     /*!< 0x00008000 */
N#define CAN_MCR_RESET          CAN_MCR_RESET_Msk                               /*!<bxCAN software master reset */
N#define CAN_MCR_DBF_Pos        (16U)                                           
N#define CAN_MCR_DBF_Msk        (0x1UL << CAN_MCR_DBF_Pos)                       /*!< 0x00010000 */
N#define CAN_MCR_DBF            CAN_MCR_DBF_Msk                                 /*!<bxCAN Debug freeze */
N/*******************  Bit definition for CAN_MSR register  ********************/
N#define CAN_MSR_INAK_Pos       (0U)                                            
N#define CAN_MSR_INAK_Msk       (0x1UL << CAN_MSR_INAK_Pos)                      /*!< 0x00000001 */
N#define CAN_MSR_INAK           CAN_MSR_INAK_Msk                                /*!<Initialization Acknowledge */
N#define CAN_MSR_SLAK_Pos       (1U)                                            
N#define CAN_MSR_SLAK_Msk       (0x1UL << CAN_MSR_SLAK_Pos)                      /*!< 0x00000002 */
N#define CAN_MSR_SLAK           CAN_MSR_SLAK_Msk                                /*!<Sleep Acknowledge */
N#define CAN_MSR_ERRI_Pos       (2U)                                            
N#define CAN_MSR_ERRI_Msk       (0x1UL << CAN_MSR_ERRI_Pos)                      /*!< 0x00000004 */
N#define CAN_MSR_ERRI           CAN_MSR_ERRI_Msk                                /*!<Error Interrupt */
N#define CAN_MSR_WKUI_Pos       (3U)                                            
N#define CAN_MSR_WKUI_Msk       (0x1UL << CAN_MSR_WKUI_Pos)                      /*!< 0x00000008 */
N#define CAN_MSR_WKUI           CAN_MSR_WKUI_Msk                                /*!<Wakeup Interrupt */
N#define CAN_MSR_SLAKI_Pos      (4U)                                            
N#define CAN_MSR_SLAKI_Msk      (0x1UL << CAN_MSR_SLAKI_Pos)                     /*!< 0x00000010 */
N#define CAN_MSR_SLAKI          CAN_MSR_SLAKI_Msk                               /*!<Sleep Acknowledge Interrupt */
N#define CAN_MSR_TXM_Pos        (8U)                                            
N#define CAN_MSR_TXM_Msk        (0x1UL << CAN_MSR_TXM_Pos)                       /*!< 0x00000100 */
N#define CAN_MSR_TXM            CAN_MSR_TXM_Msk                                 /*!<Transmit Mode */
N#define CAN_MSR_RXM_Pos        (9U)                                            
N#define CAN_MSR_RXM_Msk        (0x1UL << CAN_MSR_RXM_Pos)                       /*!< 0x00000200 */
N#define CAN_MSR_RXM            CAN_MSR_RXM_Msk                                 /*!<Receive Mode */
N#define CAN_MSR_SAMP_Pos       (10U)                                           
N#define CAN_MSR_SAMP_Msk       (0x1UL << CAN_MSR_SAMP_Pos)                      /*!< 0x00000400 */
N#define CAN_MSR_SAMP           CAN_MSR_SAMP_Msk                                /*!<Last Sample Point */
N#define CAN_MSR_RX_Pos         (11U)                                           
N#define CAN_MSR_RX_Msk         (0x1UL << CAN_MSR_RX_Pos)                        /*!< 0x00000800 */
N#define CAN_MSR_RX             CAN_MSR_RX_Msk                                  /*!<CAN Rx Signal */
N
N/*******************  Bit definition for CAN_TSR register  ********************/
N#define CAN_TSR_RQCP0_Pos      (0U)                                            
N#define CAN_TSR_RQCP0_Msk      (0x1UL << CAN_TSR_RQCP0_Pos)                     /*!< 0x00000001 */
N#define CAN_TSR_RQCP0          CAN_TSR_RQCP0_Msk                               /*!<Request Completed Mailbox0 */
N#define CAN_TSR_TXOK0_Pos      (1U)                                            
N#define CAN_TSR_TXOK0_Msk      (0x1UL << CAN_TSR_TXOK0_Pos)                     /*!< 0x00000002 */
N#define CAN_TSR_TXOK0          CAN_TSR_TXOK0_Msk                               /*!<Transmission OK of Mailbox0 */
N#define CAN_TSR_ALST0_Pos      (2U)                                            
N#define CAN_TSR_ALST0_Msk      (0x1UL << CAN_TSR_ALST0_Pos)                     /*!< 0x00000004 */
N#define CAN_TSR_ALST0          CAN_TSR_ALST0_Msk                               /*!<Arbitration Lost for Mailbox0 */
N#define CAN_TSR_TERR0_Pos      (3U)                                            
N#define CAN_TSR_TERR0_Msk      (0x1UL << CAN_TSR_TERR0_Pos)                     /*!< 0x00000008 */
N#define CAN_TSR_TERR0          CAN_TSR_TERR0_Msk                               /*!<Transmission Error of Mailbox0 */
N#define CAN_TSR_ABRQ0_Pos      (7U)                                            
N#define CAN_TSR_ABRQ0_Msk      (0x1UL << CAN_TSR_ABRQ0_Pos)                     /*!< 0x00000080 */
N#define CAN_TSR_ABRQ0          CAN_TSR_ABRQ0_Msk                               /*!<Abort Request for Mailbox0 */
N#define CAN_TSR_RQCP1_Pos      (8U)                                            
N#define CAN_TSR_RQCP1_Msk      (0x1UL << CAN_TSR_RQCP1_Pos)                     /*!< 0x00000100 */
N#define CAN_TSR_RQCP1          CAN_TSR_RQCP1_Msk                               /*!<Request Completed Mailbox1 */
N#define CAN_TSR_TXOK1_Pos      (9U)                                            
N#define CAN_TSR_TXOK1_Msk      (0x1UL << CAN_TSR_TXOK1_Pos)                     /*!< 0x00000200 */
N#define CAN_TSR_TXOK1          CAN_TSR_TXOK1_Msk                               /*!<Transmission OK of Mailbox1 */
N#define CAN_TSR_ALST1_Pos      (10U)                                           
N#define CAN_TSR_ALST1_Msk      (0x1UL << CAN_TSR_ALST1_Pos)                     /*!< 0x00000400 */
N#define CAN_TSR_ALST1          CAN_TSR_ALST1_Msk                               /*!<Arbitration Lost for Mailbox1 */
N#define CAN_TSR_TERR1_Pos      (11U)                                           
N#define CAN_TSR_TERR1_Msk      (0x1UL << CAN_TSR_TERR1_Pos)                     /*!< 0x00000800 */
N#define CAN_TSR_TERR1          CAN_TSR_TERR1_Msk                               /*!<Transmission Error of Mailbox1 */
N#define CAN_TSR_ABRQ1_Pos      (15U)                                           
N#define CAN_TSR_ABRQ1_Msk      (0x1UL << CAN_TSR_ABRQ1_Pos)                     /*!< 0x00008000 */
N#define CAN_TSR_ABRQ1          CAN_TSR_ABRQ1_Msk                               /*!<Abort Request for Mailbox 1 */
N#define CAN_TSR_RQCP2_Pos      (16U)                                           
N#define CAN_TSR_RQCP2_Msk      (0x1UL << CAN_TSR_RQCP2_Pos)                     /*!< 0x00010000 */
N#define CAN_TSR_RQCP2          CAN_TSR_RQCP2_Msk                               /*!<Request Completed Mailbox2 */
N#define CAN_TSR_TXOK2_Pos      (17U)                                           
N#define CAN_TSR_TXOK2_Msk      (0x1UL << CAN_TSR_TXOK2_Pos)                     /*!< 0x00020000 */
N#define CAN_TSR_TXOK2          CAN_TSR_TXOK2_Msk                               /*!<Transmission OK of Mailbox 2 */
N#define CAN_TSR_ALST2_Pos      (18U)                                           
N#define CAN_TSR_ALST2_Msk      (0x1UL << CAN_TSR_ALST2_Pos)                     /*!< 0x00040000 */
N#define CAN_TSR_ALST2          CAN_TSR_ALST2_Msk                               /*!<Arbitration Lost for mailbox 2 */
N#define CAN_TSR_TERR2_Pos      (19U)                                           
N#define CAN_TSR_TERR2_Msk      (0x1UL << CAN_TSR_TERR2_Pos)                     /*!< 0x00080000 */
N#define CAN_TSR_TERR2          CAN_TSR_TERR2_Msk                               /*!<Transmission Error of Mailbox 2 */
N#define CAN_TSR_ABRQ2_Pos      (23U)                                           
N#define CAN_TSR_ABRQ2_Msk      (0x1UL << CAN_TSR_ABRQ2_Pos)                     /*!< 0x00800000 */
N#define CAN_TSR_ABRQ2          CAN_TSR_ABRQ2_Msk                               /*!<Abort Request for Mailbox 2 */
N#define CAN_TSR_CODE_Pos       (24U)                                           
N#define CAN_TSR_CODE_Msk       (0x3UL << CAN_TSR_CODE_Pos)                      /*!< 0x03000000 */
N#define CAN_TSR_CODE           CAN_TSR_CODE_Msk                                /*!<Mailbox Code */
N
N#define CAN_TSR_TME_Pos        (26U)                                           
N#define CAN_TSR_TME_Msk        (0x7UL << CAN_TSR_TME_Pos)                       /*!< 0x1C000000 */
N#define CAN_TSR_TME            CAN_TSR_TME_Msk                                 /*!<TME[2:0] bits */
N#define CAN_TSR_TME0_Pos       (26U)                                           
N#define CAN_TSR_TME0_Msk       (0x1UL << CAN_TSR_TME0_Pos)                      /*!< 0x04000000 */
N#define CAN_TSR_TME0           CAN_TSR_TME0_Msk                                /*!<Transmit Mailbox 0 Empty */
N#define CAN_TSR_TME1_Pos       (27U)                                           
N#define CAN_TSR_TME1_Msk       (0x1UL << CAN_TSR_TME1_Pos)                      /*!< 0x08000000 */
N#define CAN_TSR_TME1           CAN_TSR_TME1_Msk                                /*!<Transmit Mailbox 1 Empty */
N#define CAN_TSR_TME2_Pos       (28U)                                           
N#define CAN_TSR_TME2_Msk       (0x1UL << CAN_TSR_TME2_Pos)                      /*!< 0x10000000 */
N#define CAN_TSR_TME2           CAN_TSR_TME2_Msk                                /*!<Transmit Mailbox 2 Empty */
N
N#define CAN_TSR_LOW_Pos        (29U)                                           
N#define CAN_TSR_LOW_Msk        (0x7UL << CAN_TSR_LOW_Pos)                       /*!< 0xE0000000 */
N#define CAN_TSR_LOW            CAN_TSR_LOW_Msk                                 /*!<LOW[2:0] bits */
N#define CAN_TSR_LOW0_Pos       (29U)                                           
N#define CAN_TSR_LOW0_Msk       (0x1UL << CAN_TSR_LOW0_Pos)                      /*!< 0x20000000 */
N#define CAN_TSR_LOW0           CAN_TSR_LOW0_Msk                                /*!<Lowest Priority Flag for Mailbox 0 */
N#define CAN_TSR_LOW1_Pos       (30U)                                           
N#define CAN_TSR_LOW1_Msk       (0x1UL << CAN_TSR_LOW1_Pos)                      /*!< 0x40000000 */
N#define CAN_TSR_LOW1           CAN_TSR_LOW1_Msk                                /*!<Lowest Priority Flag for Mailbox 1 */
N#define CAN_TSR_LOW2_Pos       (31U)                                           
N#define CAN_TSR_LOW2_Msk       (0x1UL << CAN_TSR_LOW2_Pos)                      /*!< 0x80000000 */
N#define CAN_TSR_LOW2           CAN_TSR_LOW2_Msk                                /*!<Lowest Priority Flag for Mailbox 2 */
N
N/*******************  Bit definition for CAN_RF0R register  *******************/
N#define CAN_RF0R_FMP0_Pos      (0U)                                            
N#define CAN_RF0R_FMP0_Msk      (0x3UL << CAN_RF0R_FMP0_Pos)                     /*!< 0x00000003 */
N#define CAN_RF0R_FMP0          CAN_RF0R_FMP0_Msk                               /*!<FIFO 0 Message Pending */
N#define CAN_RF0R_FULL0_Pos     (3U)                                            
N#define CAN_RF0R_FULL0_Msk     (0x1UL << CAN_RF0R_FULL0_Pos)                    /*!< 0x00000008 */
N#define CAN_RF0R_FULL0         CAN_RF0R_FULL0_Msk                              /*!<FIFO 0 Full */
N#define CAN_RF0R_FOVR0_Pos     (4U)                                            
N#define CAN_RF0R_FOVR0_Msk     (0x1UL << CAN_RF0R_FOVR0_Pos)                    /*!< 0x00000010 */
N#define CAN_RF0R_FOVR0         CAN_RF0R_FOVR0_Msk                              /*!<FIFO 0 Overrun */
N#define CAN_RF0R_RFOM0_Pos     (5U)                                            
N#define CAN_RF0R_RFOM0_Msk     (0x1UL << CAN_RF0R_RFOM0_Pos)                    /*!< 0x00000020 */
N#define CAN_RF0R_RFOM0         CAN_RF0R_RFOM0_Msk                              /*!<Release FIFO 0 Output Mailbox */
N
N/*******************  Bit definition for CAN_RF1R register  *******************/
N#define CAN_RF1R_FMP1_Pos      (0U)                                            
N#define CAN_RF1R_FMP1_Msk      (0x3UL << CAN_RF1R_FMP1_Pos)                     /*!< 0x00000003 */
N#define CAN_RF1R_FMP1          CAN_RF1R_FMP1_Msk                               /*!<FIFO 1 Message Pending */
N#define CAN_RF1R_FULL1_Pos     (3U)                                            
N#define CAN_RF1R_FULL1_Msk     (0x1UL << CAN_RF1R_FULL1_Pos)                    /*!< 0x00000008 */
N#define CAN_RF1R_FULL1         CAN_RF1R_FULL1_Msk                              /*!<FIFO 1 Full */
N#define CAN_RF1R_FOVR1_Pos     (4U)                                            
N#define CAN_RF1R_FOVR1_Msk     (0x1UL << CAN_RF1R_FOVR1_Pos)                    /*!< 0x00000010 */
N#define CAN_RF1R_FOVR1         CAN_RF1R_FOVR1_Msk                              /*!<FIFO 1 Overrun */
N#define CAN_RF1R_RFOM1_Pos     (5U)                                            
N#define CAN_RF1R_RFOM1_Msk     (0x1UL << CAN_RF1R_RFOM1_Pos)                    /*!< 0x00000020 */
N#define CAN_RF1R_RFOM1         CAN_RF1R_RFOM1_Msk                              /*!<Release FIFO 1 Output Mailbox */
N
N/********************  Bit definition for CAN_IER register  *******************/
N#define CAN_IER_TMEIE_Pos      (0U)                                            
N#define CAN_IER_TMEIE_Msk      (0x1UL << CAN_IER_TMEIE_Pos)                     /*!< 0x00000001 */
N#define CAN_IER_TMEIE          CAN_IER_TMEIE_Msk                               /*!<Transmit Mailbox Empty Interrupt Enable */
N#define CAN_IER_FMPIE0_Pos     (1U)                                            
N#define CAN_IER_FMPIE0_Msk     (0x1UL << CAN_IER_FMPIE0_Pos)                    /*!< 0x00000002 */
N#define CAN_IER_FMPIE0         CAN_IER_FMPIE0_Msk                              /*!<FIFO Message Pending Interrupt Enable */
N#define CAN_IER_FFIE0_Pos      (2U)                                            
N#define CAN_IER_FFIE0_Msk      (0x1UL << CAN_IER_FFIE0_Pos)                     /*!< 0x00000004 */
N#define CAN_IER_FFIE0          CAN_IER_FFIE0_Msk                               /*!<FIFO Full Interrupt Enable */
N#define CAN_IER_FOVIE0_Pos     (3U)                                            
N#define CAN_IER_FOVIE0_Msk     (0x1UL << CAN_IER_FOVIE0_Pos)                    /*!< 0x00000008 */
N#define CAN_IER_FOVIE0         CAN_IER_FOVIE0_Msk                              /*!<FIFO Overrun Interrupt Enable */
N#define CAN_IER_FMPIE1_Pos     (4U)                                            
N#define CAN_IER_FMPIE1_Msk     (0x1UL << CAN_IER_FMPIE1_Pos)                    /*!< 0x00000010 */
N#define CAN_IER_FMPIE1         CAN_IER_FMPIE1_Msk                              /*!<FIFO Message Pending Interrupt Enable */
N#define CAN_IER_FFIE1_Pos      (5U)                                            
N#define CAN_IER_FFIE1_Msk      (0x1UL << CAN_IER_FFIE1_Pos)                     /*!< 0x00000020 */
N#define CAN_IER_FFIE1          CAN_IER_FFIE1_Msk                               /*!<FIFO Full Interrupt Enable */
N#define CAN_IER_FOVIE1_Pos     (6U)                                            
N#define CAN_IER_FOVIE1_Msk     (0x1UL << CAN_IER_FOVIE1_Pos)                    /*!< 0x00000040 */
N#define CAN_IER_FOVIE1         CAN_IER_FOVIE1_Msk                              /*!<FIFO Overrun Interrupt Enable */
N#define CAN_IER_EWGIE_Pos      (8U)                                            
N#define CAN_IER_EWGIE_Msk      (0x1UL << CAN_IER_EWGIE_Pos)                     /*!< 0x00000100 */
N#define CAN_IER_EWGIE          CAN_IER_EWGIE_Msk                               /*!<Error Warning Interrupt Enable */
N#define CAN_IER_EPVIE_Pos      (9U)                                            
N#define CAN_IER_EPVIE_Msk      (0x1UL << CAN_IER_EPVIE_Pos)                     /*!< 0x00000200 */
N#define CAN_IER_EPVIE          CAN_IER_EPVIE_Msk                               /*!<Error Passive Interrupt Enable */
N#define CAN_IER_BOFIE_Pos      (10U)                                           
N#define CAN_IER_BOFIE_Msk      (0x1UL << CAN_IER_BOFIE_Pos)                     /*!< 0x00000400 */
N#define CAN_IER_BOFIE          CAN_IER_BOFIE_Msk                               /*!<Bus-Off Interrupt Enable */
N#define CAN_IER_LECIE_Pos      (11U)                                           
N#define CAN_IER_LECIE_Msk      (0x1UL << CAN_IER_LECIE_Pos)                     /*!< 0x00000800 */
N#define CAN_IER_LECIE          CAN_IER_LECIE_Msk                               /*!<Last Error Code Interrupt Enable */
N#define CAN_IER_ERRIE_Pos      (15U)                                           
N#define CAN_IER_ERRIE_Msk      (0x1UL << CAN_IER_ERRIE_Pos)                     /*!< 0x00008000 */
N#define CAN_IER_ERRIE          CAN_IER_ERRIE_Msk                               /*!<Error Interrupt Enable */
N#define CAN_IER_WKUIE_Pos      (16U)                                           
N#define CAN_IER_WKUIE_Msk      (0x1UL << CAN_IER_WKUIE_Pos)                     /*!< 0x00010000 */
N#define CAN_IER_WKUIE          CAN_IER_WKUIE_Msk                               /*!<Wakeup Interrupt Enable */
N#define CAN_IER_SLKIE_Pos      (17U)                                           
N#define CAN_IER_SLKIE_Msk      (0x1UL << CAN_IER_SLKIE_Pos)                     /*!< 0x00020000 */
N#define CAN_IER_SLKIE          CAN_IER_SLKIE_Msk                               /*!<Sleep Interrupt Enable */
N#define CAN_IER_EWGIE_Pos      (8U)                                            
N
N/********************  Bit definition for CAN_ESR register  *******************/
N#define CAN_ESR_EWGF_Pos       (0U)                                            
N#define CAN_ESR_EWGF_Msk       (0x1UL << CAN_ESR_EWGF_Pos)                      /*!< 0x00000001 */
N#define CAN_ESR_EWGF           CAN_ESR_EWGF_Msk                                /*!<Error Warning Flag */
N#define CAN_ESR_EPVF_Pos       (1U)                                            
N#define CAN_ESR_EPVF_Msk       (0x1UL << CAN_ESR_EPVF_Pos)                      /*!< 0x00000002 */
N#define CAN_ESR_EPVF           CAN_ESR_EPVF_Msk                                /*!<Error Passive Flag */
N#define CAN_ESR_BOFF_Pos       (2U)                                            
N#define CAN_ESR_BOFF_Msk       (0x1UL << CAN_ESR_BOFF_Pos)                      /*!< 0x00000004 */
N#define CAN_ESR_BOFF           CAN_ESR_BOFF_Msk                                /*!<Bus-Off Flag */
N
N#define CAN_ESR_LEC_Pos        (4U)                                            
N#define CAN_ESR_LEC_Msk        (0x7UL << CAN_ESR_LEC_Pos)                       /*!< 0x00000070 */
N#define CAN_ESR_LEC            CAN_ESR_LEC_Msk                                 /*!<LEC[2:0] bits (Last Error Code) */
N#define CAN_ESR_LEC_0          (0x1UL << CAN_ESR_LEC_Pos)                       /*!< 0x00000010 */
N#define CAN_ESR_LEC_1          (0x2UL << CAN_ESR_LEC_Pos)                       /*!< 0x00000020 */
N#define CAN_ESR_LEC_2          (0x4UL << CAN_ESR_LEC_Pos)                       /*!< 0x00000040 */
N
N#define CAN_ESR_TEC_Pos        (16U)                                           
N#define CAN_ESR_TEC_Msk        (0xFFUL << CAN_ESR_TEC_Pos)                      /*!< 0x00FF0000 */
N#define CAN_ESR_TEC            CAN_ESR_TEC_Msk                                 /*!<Least significant byte of the 9-bit Transmit Error Counter */
N#define CAN_ESR_REC_Pos        (24U)                                           
N#define CAN_ESR_REC_Msk        (0xFFUL << CAN_ESR_REC_Pos)                      /*!< 0xFF000000 */
N#define CAN_ESR_REC            CAN_ESR_REC_Msk                                 /*!<Receive Error Counter */
N
N/*******************  Bit definition for CAN_BTR register  ********************/
N#define CAN_BTR_BRP_Pos        (0U)                                            
N#define CAN_BTR_BRP_Msk        (0x3FFUL << CAN_BTR_BRP_Pos)                     /*!< 0x000003FF */
N#define CAN_BTR_BRP            CAN_BTR_BRP_Msk                                 /*!<Baud Rate Prescaler */
N#define CAN_BTR_TS1_Pos        (16U)                                           
N#define CAN_BTR_TS1_Msk        (0xFUL << CAN_BTR_TS1_Pos)                       /*!< 0x000F0000 */
N#define CAN_BTR_TS1            CAN_BTR_TS1_Msk                                 /*!<Time Segment 1 */
N#define CAN_BTR_TS1_0          (0x1UL << CAN_BTR_TS1_Pos)                       /*!< 0x00010000 */
N#define CAN_BTR_TS1_1          (0x2UL << CAN_BTR_TS1_Pos)                       /*!< 0x00020000 */
N#define CAN_BTR_TS1_2          (0x4UL << CAN_BTR_TS1_Pos)                       /*!< 0x00040000 */
N#define CAN_BTR_TS1_3          (0x8UL << CAN_BTR_TS1_Pos)                       /*!< 0x00080000 */
N#define CAN_BTR_TS2_Pos        (20U)                                           
N#define CAN_BTR_TS2_Msk        (0x7UL << CAN_BTR_TS2_Pos)                       /*!< 0x00700000 */
N#define CAN_BTR_TS2            CAN_BTR_TS2_Msk                                 /*!<Time Segment 2 */
N#define CAN_BTR_TS2_0          (0x1UL << CAN_BTR_TS2_Pos)                       /*!< 0x00100000 */
N#define CAN_BTR_TS2_1          (0x2UL << CAN_BTR_TS2_Pos)                       /*!< 0x00200000 */
N#define CAN_BTR_TS2_2          (0x4UL << CAN_BTR_TS2_Pos)                       /*!< 0x00400000 */
N#define CAN_BTR_SJW_Pos        (24U)                                           
N#define CAN_BTR_SJW_Msk        (0x3UL << CAN_BTR_SJW_Pos)                       /*!< 0x03000000 */
N#define CAN_BTR_SJW            CAN_BTR_SJW_Msk                                 /*!<Resynchronization Jump Width */
N#define CAN_BTR_SJW_0          (0x1UL << CAN_BTR_SJW_Pos)                       /*!< 0x01000000 */
N#define CAN_BTR_SJW_1          (0x2UL << CAN_BTR_SJW_Pos)                       /*!< 0x02000000 */
N#define CAN_BTR_LBKM_Pos       (30U)                                           
N#define CAN_BTR_LBKM_Msk       (0x1UL << CAN_BTR_LBKM_Pos)                      /*!< 0x40000000 */
N#define CAN_BTR_LBKM           CAN_BTR_LBKM_Msk                                /*!<Loop Back Mode (Debug) */
N#define CAN_BTR_SILM_Pos       (31U)                                           
N#define CAN_BTR_SILM_Msk       (0x1UL << CAN_BTR_SILM_Pos)                      /*!< 0x80000000 */
N#define CAN_BTR_SILM           CAN_BTR_SILM_Msk                                /*!<Silent Mode */
N
N
N/*!<Mailbox registers */
N/******************  Bit definition for CAN_TI0R register  ********************/
N#define CAN_TI0R_TXRQ_Pos      (0U)                                            
N#define CAN_TI0R_TXRQ_Msk      (0x1UL << CAN_TI0R_TXRQ_Pos)                     /*!< 0x00000001 */
N#define CAN_TI0R_TXRQ          CAN_TI0R_TXRQ_Msk                               /*!<Transmit Mailbox Request */
N#define CAN_TI0R_RTR_Pos       (1U)                                            
N#define CAN_TI0R_RTR_Msk       (0x1UL << CAN_TI0R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_TI0R_RTR           CAN_TI0R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_TI0R_IDE_Pos       (2U)                                            
N#define CAN_TI0R_IDE_Msk       (0x1UL << CAN_TI0R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_TI0R_IDE           CAN_TI0R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_TI0R_EXID_Pos      (3U)                                            
N#define CAN_TI0R_EXID_Msk      (0x3FFFFUL << CAN_TI0R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_TI0R_EXID          CAN_TI0R_EXID_Msk                               /*!<Extended Identifier */
N#define CAN_TI0R_STID_Pos      (21U)                                           
N#define CAN_TI0R_STID_Msk      (0x7FFUL << CAN_TI0R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_TI0R_STID          CAN_TI0R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/******************  Bit definition for CAN_TDT0R register  *******************/
N#define CAN_TDT0R_DLC_Pos      (0U)                                            
N#define CAN_TDT0R_DLC_Msk      (0xFUL << CAN_TDT0R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_TDT0R_DLC          CAN_TDT0R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_TDT0R_TGT_Pos      (8U)                                            
N#define CAN_TDT0R_TGT_Msk      (0x1UL << CAN_TDT0R_TGT_Pos)                     /*!< 0x00000100 */
N#define CAN_TDT0R_TGT          CAN_TDT0R_TGT_Msk                               /*!<Transmit Global Time */
N#define CAN_TDT0R_TIME_Pos     (16U)                                           
N#define CAN_TDT0R_TIME_Msk     (0xFFFFUL << CAN_TDT0R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_TDT0R_TIME         CAN_TDT0R_TIME_Msk                              /*!<Message Time Stamp */
N
N/******************  Bit definition for CAN_TDL0R register  *******************/
N#define CAN_TDL0R_DATA0_Pos    (0U)                                            
N#define CAN_TDL0R_DATA0_Msk    (0xFFUL << CAN_TDL0R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_TDL0R_DATA0        CAN_TDL0R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_TDL0R_DATA1_Pos    (8U)                                            
N#define CAN_TDL0R_DATA1_Msk    (0xFFUL << CAN_TDL0R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDL0R_DATA1        CAN_TDL0R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_TDL0R_DATA2_Pos    (16U)                                           
N#define CAN_TDL0R_DATA2_Msk    (0xFFUL << CAN_TDL0R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDL0R_DATA2        CAN_TDL0R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_TDL0R_DATA3_Pos    (24U)                                           
N#define CAN_TDL0R_DATA3_Msk    (0xFFUL << CAN_TDL0R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDL0R_DATA3        CAN_TDL0R_DATA3_Msk                             /*!<Data byte 3 */
N
N/******************  Bit definition for CAN_TDH0R register  *******************/
N#define CAN_TDH0R_DATA4_Pos    (0U)                                            
N#define CAN_TDH0R_DATA4_Msk    (0xFFUL << CAN_TDH0R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_TDH0R_DATA4        CAN_TDH0R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_TDH0R_DATA5_Pos    (8U)                                            
N#define CAN_TDH0R_DATA5_Msk    (0xFFUL << CAN_TDH0R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDH0R_DATA5        CAN_TDH0R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_TDH0R_DATA6_Pos    (16U)                                           
N#define CAN_TDH0R_DATA6_Msk    (0xFFUL << CAN_TDH0R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDH0R_DATA6        CAN_TDH0R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_TDH0R_DATA7_Pos    (24U)                                           
N#define CAN_TDH0R_DATA7_Msk    (0xFFUL << CAN_TDH0R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDH0R_DATA7        CAN_TDH0R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI1R register  *******************/
N#define CAN_TI1R_TXRQ_Pos      (0U)                                            
N#define CAN_TI1R_TXRQ_Msk      (0x1UL << CAN_TI1R_TXRQ_Pos)                     /*!< 0x00000001 */
N#define CAN_TI1R_TXRQ          CAN_TI1R_TXRQ_Msk                               /*!<Transmit Mailbox Request */
N#define CAN_TI1R_RTR_Pos       (1U)                                            
N#define CAN_TI1R_RTR_Msk       (0x1UL << CAN_TI1R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_TI1R_RTR           CAN_TI1R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_TI1R_IDE_Pos       (2U)                                            
N#define CAN_TI1R_IDE_Msk       (0x1UL << CAN_TI1R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_TI1R_IDE           CAN_TI1R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_TI1R_EXID_Pos      (3U)                                            
N#define CAN_TI1R_EXID_Msk      (0x3FFFFUL << CAN_TI1R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_TI1R_EXID          CAN_TI1R_EXID_Msk                               /*!<Extended Identifier */
N#define CAN_TI1R_STID_Pos      (21U)                                           
N#define CAN_TI1R_STID_Msk      (0x7FFUL << CAN_TI1R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_TI1R_STID          CAN_TI1R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT1R register  ******************/
N#define CAN_TDT1R_DLC_Pos      (0U)                                            
N#define CAN_TDT1R_DLC_Msk      (0xFUL << CAN_TDT1R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_TDT1R_DLC          CAN_TDT1R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_TDT1R_TGT_Pos      (8U)                                            
N#define CAN_TDT1R_TGT_Msk      (0x1UL << CAN_TDT1R_TGT_Pos)                     /*!< 0x00000100 */
N#define CAN_TDT1R_TGT          CAN_TDT1R_TGT_Msk                               /*!<Transmit Global Time */
N#define CAN_TDT1R_TIME_Pos     (16U)                                           
N#define CAN_TDT1R_TIME_Msk     (0xFFFFUL << CAN_TDT1R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_TDT1R_TIME         CAN_TDT1R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL1R register  ******************/
N#define CAN_TDL1R_DATA0_Pos    (0U)                                            
N#define CAN_TDL1R_DATA0_Msk    (0xFFUL << CAN_TDL1R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_TDL1R_DATA0        CAN_TDL1R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_TDL1R_DATA1_Pos    (8U)                                            
N#define CAN_TDL1R_DATA1_Msk    (0xFFUL << CAN_TDL1R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDL1R_DATA1        CAN_TDL1R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_TDL1R_DATA2_Pos    (16U)                                           
N#define CAN_TDL1R_DATA2_Msk    (0xFFUL << CAN_TDL1R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDL1R_DATA2        CAN_TDL1R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_TDL1R_DATA3_Pos    (24U)                                           
N#define CAN_TDL1R_DATA3_Msk    (0xFFUL << CAN_TDL1R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDL1R_DATA3        CAN_TDL1R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH1R register  ******************/
N#define CAN_TDH1R_DATA4_Pos    (0U)                                            
N#define CAN_TDH1R_DATA4_Msk    (0xFFUL << CAN_TDH1R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_TDH1R_DATA4        CAN_TDH1R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_TDH1R_DATA5_Pos    (8U)                                            
N#define CAN_TDH1R_DATA5_Msk    (0xFFUL << CAN_TDH1R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDH1R_DATA5        CAN_TDH1R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_TDH1R_DATA6_Pos    (16U)                                           
N#define CAN_TDH1R_DATA6_Msk    (0xFFUL << CAN_TDH1R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDH1R_DATA6        CAN_TDH1R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_TDH1R_DATA7_Pos    (24U)                                           
N#define CAN_TDH1R_DATA7_Msk    (0xFFUL << CAN_TDH1R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDH1R_DATA7        CAN_TDH1R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI2R register  *******************/
N#define CAN_TI2R_TXRQ_Pos      (0U)                                            
N#define CAN_TI2R_TXRQ_Msk      (0x1UL << CAN_TI2R_TXRQ_Pos)                     /*!< 0x00000001 */
N#define CAN_TI2R_TXRQ          CAN_TI2R_TXRQ_Msk                               /*!<Transmit Mailbox Request */
N#define CAN_TI2R_RTR_Pos       (1U)                                            
N#define CAN_TI2R_RTR_Msk       (0x1UL << CAN_TI2R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_TI2R_RTR           CAN_TI2R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_TI2R_IDE_Pos       (2U)                                            
N#define CAN_TI2R_IDE_Msk       (0x1UL << CAN_TI2R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_TI2R_IDE           CAN_TI2R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_TI2R_EXID_Pos      (3U)                                            
N#define CAN_TI2R_EXID_Msk      (0x3FFFFUL << CAN_TI2R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_TI2R_EXID          CAN_TI2R_EXID_Msk                               /*!<Extended identifier */
N#define CAN_TI2R_STID_Pos      (21U)                                           
N#define CAN_TI2R_STID_Msk      (0x7FFUL << CAN_TI2R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_TI2R_STID          CAN_TI2R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT2R register  ******************/  
N#define CAN_TDT2R_DLC_Pos      (0U)                                            
N#define CAN_TDT2R_DLC_Msk      (0xFUL << CAN_TDT2R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_TDT2R_DLC          CAN_TDT2R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_TDT2R_TGT_Pos      (8U)                                            
N#define CAN_TDT2R_TGT_Msk      (0x1UL << CAN_TDT2R_TGT_Pos)                     /*!< 0x00000100 */
N#define CAN_TDT2R_TGT          CAN_TDT2R_TGT_Msk                               /*!<Transmit Global Time */
N#define CAN_TDT2R_TIME_Pos     (16U)                                           
N#define CAN_TDT2R_TIME_Msk     (0xFFFFUL << CAN_TDT2R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_TDT2R_TIME         CAN_TDT2R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL2R register  ******************/
N#define CAN_TDL2R_DATA0_Pos    (0U)                                            
N#define CAN_TDL2R_DATA0_Msk    (0xFFUL << CAN_TDL2R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_TDL2R_DATA0        CAN_TDL2R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_TDL2R_DATA1_Pos    (8U)                                            
N#define CAN_TDL2R_DATA1_Msk    (0xFFUL << CAN_TDL2R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDL2R_DATA1        CAN_TDL2R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_TDL2R_DATA2_Pos    (16U)                                           
N#define CAN_TDL2R_DATA2_Msk    (0xFFUL << CAN_TDL2R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDL2R_DATA2        CAN_TDL2R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_TDL2R_DATA3_Pos    (24U)                                           
N#define CAN_TDL2R_DATA3_Msk    (0xFFUL << CAN_TDL2R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDL2R_DATA3        CAN_TDL2R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH2R register  ******************/
N#define CAN_TDH2R_DATA4_Pos    (0U)                                            
N#define CAN_TDH2R_DATA4_Msk    (0xFFUL << CAN_TDH2R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_TDH2R_DATA4        CAN_TDH2R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_TDH2R_DATA5_Pos    (8U)                                            
N#define CAN_TDH2R_DATA5_Msk    (0xFFUL << CAN_TDH2R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDH2R_DATA5        CAN_TDH2R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_TDH2R_DATA6_Pos    (16U)                                           
N#define CAN_TDH2R_DATA6_Msk    (0xFFUL << CAN_TDH2R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDH2R_DATA6        CAN_TDH2R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_TDH2R_DATA7_Pos    (24U)                                           
N#define CAN_TDH2R_DATA7_Msk    (0xFFUL << CAN_TDH2R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDH2R_DATA7        CAN_TDH2R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI0R register  *******************/
N#define CAN_RI0R_RTR_Pos       (1U)                                            
N#define CAN_RI0R_RTR_Msk       (0x1UL << CAN_RI0R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_RI0R_RTR           CAN_RI0R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_RI0R_IDE_Pos       (2U)                                            
N#define CAN_RI0R_IDE_Msk       (0x1UL << CAN_RI0R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_RI0R_IDE           CAN_RI0R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_RI0R_EXID_Pos      (3U)                                            
N#define CAN_RI0R_EXID_Msk      (0x3FFFFUL << CAN_RI0R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_RI0R_EXID          CAN_RI0R_EXID_Msk                               /*!<Extended Identifier */
N#define CAN_RI0R_STID_Pos      (21U)                                           
N#define CAN_RI0R_STID_Msk      (0x7FFUL << CAN_RI0R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_RI0R_STID          CAN_RI0R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT0R register  ******************/
N#define CAN_RDT0R_DLC_Pos      (0U)                                            
N#define CAN_RDT0R_DLC_Msk      (0xFUL << CAN_RDT0R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_RDT0R_DLC          CAN_RDT0R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_RDT0R_FMI_Pos      (8U)                                            
N#define CAN_RDT0R_FMI_Msk      (0xFFUL << CAN_RDT0R_FMI_Pos)                    /*!< 0x0000FF00 */
N#define CAN_RDT0R_FMI          CAN_RDT0R_FMI_Msk                               /*!<Filter Match Index */
N#define CAN_RDT0R_TIME_Pos     (16U)                                           
N#define CAN_RDT0R_TIME_Msk     (0xFFFFUL << CAN_RDT0R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_RDT0R_TIME         CAN_RDT0R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL0R register  ******************/
N#define CAN_RDL0R_DATA0_Pos    (0U)                                            
N#define CAN_RDL0R_DATA0_Msk    (0xFFUL << CAN_RDL0R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_RDL0R_DATA0        CAN_RDL0R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_RDL0R_DATA1_Pos    (8U)                                            
N#define CAN_RDL0R_DATA1_Msk    (0xFFUL << CAN_RDL0R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_RDL0R_DATA1        CAN_RDL0R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_RDL0R_DATA2_Pos    (16U)                                           
N#define CAN_RDL0R_DATA2_Msk    (0xFFUL << CAN_RDL0R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_RDL0R_DATA2        CAN_RDL0R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_RDL0R_DATA3_Pos    (24U)                                           
N#define CAN_RDL0R_DATA3_Msk    (0xFFUL << CAN_RDL0R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_RDL0R_DATA3        CAN_RDL0R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH0R register  ******************/
N#define CAN_RDH0R_DATA4_Pos    (0U)                                            
N#define CAN_RDH0R_DATA4_Msk    (0xFFUL << CAN_RDH0R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_RDH0R_DATA4        CAN_RDH0R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_RDH0R_DATA5_Pos    (8U)                                            
N#define CAN_RDH0R_DATA5_Msk    (0xFFUL << CAN_RDH0R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_RDH0R_DATA5        CAN_RDH0R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_RDH0R_DATA6_Pos    (16U)                                           
N#define CAN_RDH0R_DATA6_Msk    (0xFFUL << CAN_RDH0R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_RDH0R_DATA6        CAN_RDH0R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_RDH0R_DATA7_Pos    (24U)                                           
N#define CAN_RDH0R_DATA7_Msk    (0xFFUL << CAN_RDH0R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_RDH0R_DATA7        CAN_RDH0R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI1R register  *******************/
N#define CAN_RI1R_RTR_Pos       (1U)                                            
N#define CAN_RI1R_RTR_Msk       (0x1UL << CAN_RI1R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_RI1R_RTR           CAN_RI1R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_RI1R_IDE_Pos       (2U)                                            
N#define CAN_RI1R_IDE_Msk       (0x1UL << CAN_RI1R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_RI1R_IDE           CAN_RI1R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_RI1R_EXID_Pos      (3U)                                            
N#define CAN_RI1R_EXID_Msk      (0x3FFFFUL << CAN_RI1R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_RI1R_EXID          CAN_RI1R_EXID_Msk                               /*!<Extended identifier */
N#define CAN_RI1R_STID_Pos      (21U)                                           
N#define CAN_RI1R_STID_Msk      (0x7FFUL << CAN_RI1R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_RI1R_STID          CAN_RI1R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT1R register  ******************/
N#define CAN_RDT1R_DLC_Pos      (0U)                                            
N#define CAN_RDT1R_DLC_Msk      (0xFUL << CAN_RDT1R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_RDT1R_DLC          CAN_RDT1R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_RDT1R_FMI_Pos      (8U)                                            
N#define CAN_RDT1R_FMI_Msk      (0xFFUL << CAN_RDT1R_FMI_Pos)                    /*!< 0x0000FF00 */
N#define CAN_RDT1R_FMI          CAN_RDT1R_FMI_Msk                               /*!<Filter Match Index */
N#define CAN_RDT1R_TIME_Pos     (16U)                                           
N#define CAN_RDT1R_TIME_Msk     (0xFFFFUL << CAN_RDT1R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_RDT1R_TIME         CAN_RDT1R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL1R register  ******************/
N#define CAN_RDL1R_DATA0_Pos    (0U)                                            
N#define CAN_RDL1R_DATA0_Msk    (0xFFUL << CAN_RDL1R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_RDL1R_DATA0        CAN_RDL1R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_RDL1R_DATA1_Pos    (8U)                                            
N#define CAN_RDL1R_DATA1_Msk    (0xFFUL << CAN_RDL1R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_RDL1R_DATA1        CAN_RDL1R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_RDL1R_DATA2_Pos    (16U)                                           
N#define CAN_RDL1R_DATA2_Msk    (0xFFUL << CAN_RDL1R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_RDL1R_DATA2        CAN_RDL1R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_RDL1R_DATA3_Pos    (24U)                                           
N#define CAN_RDL1R_DATA3_Msk    (0xFFUL << CAN_RDL1R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_RDL1R_DATA3        CAN_RDL1R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH1R register  ******************/
N#define CAN_RDH1R_DATA4_Pos    (0U)                                            
N#define CAN_RDH1R_DATA4_Msk    (0xFFUL << CAN_RDH1R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_RDH1R_DATA4        CAN_RDH1R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_RDH1R_DATA5_Pos    (8U)                                            
N#define CAN_RDH1R_DATA5_Msk    (0xFFUL << CAN_RDH1R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_RDH1R_DATA5        CAN_RDH1R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_RDH1R_DATA6_Pos    (16U)                                           
N#define CAN_RDH1R_DATA6_Msk    (0xFFUL << CAN_RDH1R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_RDH1R_DATA6        CAN_RDH1R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_RDH1R_DATA7_Pos    (24U)                                           
N#define CAN_RDH1R_DATA7_Msk    (0xFFUL << CAN_RDH1R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_RDH1R_DATA7        CAN_RDH1R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*!<CAN filter registers */
N/*******************  Bit definition for CAN_FMR register  ********************/
N#define CAN_FMR_FINIT_Pos      (0U)                                            
N#define CAN_FMR_FINIT_Msk      (0x1UL << CAN_FMR_FINIT_Pos)                     /*!< 0x00000001 */
N#define CAN_FMR_FINIT          CAN_FMR_FINIT_Msk                               /*!<Filter Init Mode */
N#define CAN_FMR_CAN2SB_Pos     (8U)                                            
N#define CAN_FMR_CAN2SB_Msk     (0x3FUL << CAN_FMR_CAN2SB_Pos)                   /*!< 0x00003F00 */
N#define CAN_FMR_CAN2SB         CAN_FMR_CAN2SB_Msk                              /*!<CAN2 start bank */
N
N/*******************  Bit definition for CAN_FM1R register  *******************/
N#define CAN_FM1R_FBM_Pos       (0U)                                            
N#define CAN_FM1R_FBM_Msk       (0xFFFFFFFUL << CAN_FM1R_FBM_Pos)                /*!< 0x0FFFFFFF */
N#define CAN_FM1R_FBM           CAN_FM1R_FBM_Msk                                /*!<Filter Mode */
N#define CAN_FM1R_FBM0_Pos      (0U)                                            
N#define CAN_FM1R_FBM0_Msk      (0x1UL << CAN_FM1R_FBM0_Pos)                     /*!< 0x00000001 */
N#define CAN_FM1R_FBM0          CAN_FM1R_FBM0_Msk                               /*!<Filter Init Mode bit 0 */
N#define CAN_FM1R_FBM1_Pos      (1U)                                            
N#define CAN_FM1R_FBM1_Msk      (0x1UL << CAN_FM1R_FBM1_Pos)                     /*!< 0x00000002 */
N#define CAN_FM1R_FBM1          CAN_FM1R_FBM1_Msk                               /*!<Filter Init Mode bit 1 */
N#define CAN_FM1R_FBM2_Pos      (2U)                                            
N#define CAN_FM1R_FBM2_Msk      (0x1UL << CAN_FM1R_FBM2_Pos)                     /*!< 0x00000004 */
N#define CAN_FM1R_FBM2          CAN_FM1R_FBM2_Msk                               /*!<Filter Init Mode bit 2 */
N#define CAN_FM1R_FBM3_Pos      (3U)                                            
N#define CAN_FM1R_FBM3_Msk      (0x1UL << CAN_FM1R_FBM3_Pos)                     /*!< 0x00000008 */
N#define CAN_FM1R_FBM3          CAN_FM1R_FBM3_Msk                               /*!<Filter Init Mode bit 3 */
N#define CAN_FM1R_FBM4_Pos      (4U)                                            
N#define CAN_FM1R_FBM4_Msk      (0x1UL << CAN_FM1R_FBM4_Pos)                     /*!< 0x00000010 */
N#define CAN_FM1R_FBM4          CAN_FM1R_FBM4_Msk                               /*!<Filter Init Mode bit 4 */
N#define CAN_FM1R_FBM5_Pos      (5U)                                            
N#define CAN_FM1R_FBM5_Msk      (0x1UL << CAN_FM1R_FBM5_Pos)                     /*!< 0x00000020 */
N#define CAN_FM1R_FBM5          CAN_FM1R_FBM5_Msk                               /*!<Filter Init Mode bit 5 */
N#define CAN_FM1R_FBM6_Pos      (6U)                                            
N#define CAN_FM1R_FBM6_Msk      (0x1UL << CAN_FM1R_FBM6_Pos)                     /*!< 0x00000040 */
N#define CAN_FM1R_FBM6          CAN_FM1R_FBM6_Msk                               /*!<Filter Init Mode bit 6 */
N#define CAN_FM1R_FBM7_Pos      (7U)                                            
N#define CAN_FM1R_FBM7_Msk      (0x1UL << CAN_FM1R_FBM7_Pos)                     /*!< 0x00000080 */
N#define CAN_FM1R_FBM7          CAN_FM1R_FBM7_Msk                               /*!<Filter Init Mode bit 7 */
N#define CAN_FM1R_FBM8_Pos      (8U)                                            
N#define CAN_FM1R_FBM8_Msk      (0x1UL << CAN_FM1R_FBM8_Pos)                     /*!< 0x00000100 */
N#define CAN_FM1R_FBM8          CAN_FM1R_FBM8_Msk                               /*!<Filter Init Mode bit 8 */
N#define CAN_FM1R_FBM9_Pos      (9U)                                            
N#define CAN_FM1R_FBM9_Msk      (0x1UL << CAN_FM1R_FBM9_Pos)                     /*!< 0x00000200 */
N#define CAN_FM1R_FBM9          CAN_FM1R_FBM9_Msk                               /*!<Filter Init Mode bit 9 */
N#define CAN_FM1R_FBM10_Pos     (10U)                                           
N#define CAN_FM1R_FBM10_Msk     (0x1UL << CAN_FM1R_FBM10_Pos)                    /*!< 0x00000400 */
N#define CAN_FM1R_FBM10         CAN_FM1R_FBM10_Msk                              /*!<Filter Init Mode bit 10 */
N#define CAN_FM1R_FBM11_Pos     (11U)                                           
N#define CAN_FM1R_FBM11_Msk     (0x1UL << CAN_FM1R_FBM11_Pos)                    /*!< 0x00000800 */
N#define CAN_FM1R_FBM11         CAN_FM1R_FBM11_Msk                              /*!<Filter Init Mode bit 11 */
N#define CAN_FM1R_FBM12_Pos     (12U)                                           
N#define CAN_FM1R_FBM12_Msk     (0x1UL << CAN_FM1R_FBM12_Pos)                    /*!< 0x00001000 */
N#define CAN_FM1R_FBM12         CAN_FM1R_FBM12_Msk                              /*!<Filter Init Mode bit 12 */
N#define CAN_FM1R_FBM13_Pos     (13U)                                           
N#define CAN_FM1R_FBM13_Msk     (0x1UL << CAN_FM1R_FBM13_Pos)                    /*!< 0x00002000 */
N#define CAN_FM1R_FBM13         CAN_FM1R_FBM13_Msk                              /*!<Filter Init Mode bit 13 */
N#define CAN_FM1R_FBM14_Pos     (14U)                                           
N#define CAN_FM1R_FBM14_Msk     (0x1UL << CAN_FM1R_FBM14_Pos)                    /*!< 0x00004000 */
N#define CAN_FM1R_FBM14         CAN_FM1R_FBM14_Msk                              /*!<Filter Init Mode bit 14 */
N#define CAN_FM1R_FBM15_Pos     (15U)                                           
N#define CAN_FM1R_FBM15_Msk     (0x1UL << CAN_FM1R_FBM15_Pos)                    /*!< 0x00008000 */
N#define CAN_FM1R_FBM15         CAN_FM1R_FBM15_Msk                              /*!<Filter Init Mode bit 15 */
N#define CAN_FM1R_FBM16_Pos     (16U)                                           
N#define CAN_FM1R_FBM16_Msk     (0x1UL << CAN_FM1R_FBM16_Pos)                    /*!< 0x00010000 */
N#define CAN_FM1R_FBM16         CAN_FM1R_FBM16_Msk                              /*!<Filter Init Mode bit 16 */
N#define CAN_FM1R_FBM17_Pos     (17U)                                           
N#define CAN_FM1R_FBM17_Msk     (0x1UL << CAN_FM1R_FBM17_Pos)                    /*!< 0x00020000 */
N#define CAN_FM1R_FBM17         CAN_FM1R_FBM17_Msk                              /*!<Filter Init Mode bit 17 */
N#define CAN_FM1R_FBM18_Pos     (18U)                                           
N#define CAN_FM1R_FBM18_Msk     (0x1UL << CAN_FM1R_FBM18_Pos)                    /*!< 0x00040000 */
N#define CAN_FM1R_FBM18         CAN_FM1R_FBM18_Msk                              /*!<Filter Init Mode bit 18 */
N#define CAN_FM1R_FBM19_Pos     (19U)                                           
N#define CAN_FM1R_FBM19_Msk     (0x1UL << CAN_FM1R_FBM19_Pos)                    /*!< 0x00080000 */
N#define CAN_FM1R_FBM19         CAN_FM1R_FBM19_Msk                              /*!<Filter Init Mode bit 19 */
N#define CAN_FM1R_FBM20_Pos     (20U)                                           
N#define CAN_FM1R_FBM20_Msk     (0x1UL << CAN_FM1R_FBM20_Pos)                    /*!< 0x00100000 */
N#define CAN_FM1R_FBM20         CAN_FM1R_FBM20_Msk                              /*!<Filter Init Mode bit 20 */
N#define CAN_FM1R_FBM21_Pos     (21U)                                           
N#define CAN_FM1R_FBM21_Msk     (0x1UL << CAN_FM1R_FBM21_Pos)                    /*!< 0x00200000 */
N#define CAN_FM1R_FBM21         CAN_FM1R_FBM21_Msk                              /*!<Filter Init Mode bit 21 */
N#define CAN_FM1R_FBM22_Pos     (22U)                                           
N#define CAN_FM1R_FBM22_Msk     (0x1UL << CAN_FM1R_FBM22_Pos)                    /*!< 0x00400000 */
N#define CAN_FM1R_FBM22         CAN_FM1R_FBM22_Msk                              /*!<Filter Init Mode bit 22 */
N#define CAN_FM1R_FBM23_Pos     (23U)                                           
N#define CAN_FM1R_FBM23_Msk     (0x1UL << CAN_FM1R_FBM23_Pos)                    /*!< 0x00800000 */
N#define CAN_FM1R_FBM23         CAN_FM1R_FBM23_Msk                              /*!<Filter Init Mode bit 23 */
N#define CAN_FM1R_FBM24_Pos     (24U)                                           
N#define CAN_FM1R_FBM24_Msk     (0x1UL << CAN_FM1R_FBM24_Pos)                    /*!< 0x01000000 */
N#define CAN_FM1R_FBM24         CAN_FM1R_FBM24_Msk                              /*!<Filter Init Mode bit 24 */
N#define CAN_FM1R_FBM25_Pos     (25U)                                           
N#define CAN_FM1R_FBM25_Msk     (0x1UL << CAN_FM1R_FBM25_Pos)                    /*!< 0x02000000 */
N#define CAN_FM1R_FBM25         CAN_FM1R_FBM25_Msk                              /*!<Filter Init Mode bit 25 */
N#define CAN_FM1R_FBM26_Pos     (26U)                                           
N#define CAN_FM1R_FBM26_Msk     (0x1UL << CAN_FM1R_FBM26_Pos)                    /*!< 0x04000000 */
N#define CAN_FM1R_FBM26         CAN_FM1R_FBM26_Msk                              /*!<Filter Init Mode bit 26 */
N#define CAN_FM1R_FBM27_Pos     (27U)                                           
N#define CAN_FM1R_FBM27_Msk     (0x1UL << CAN_FM1R_FBM27_Pos)                    /*!< 0x08000000 */
N#define CAN_FM1R_FBM27         CAN_FM1R_FBM27_Msk                              /*!<Filter Init Mode bit 27 */
N
N/*******************  Bit definition for CAN_FS1R register  *******************/
N#define CAN_FS1R_FSC_Pos       (0U)                                            
N#define CAN_FS1R_FSC_Msk       (0xFFFFFFFUL << CAN_FS1R_FSC_Pos)                /*!< 0x0FFFFFFF */
N#define CAN_FS1R_FSC           CAN_FS1R_FSC_Msk                                /*!<Filter Scale Configuration */
N#define CAN_FS1R_FSC0_Pos      (0U)                                            
N#define CAN_FS1R_FSC0_Msk      (0x1UL << CAN_FS1R_FSC0_Pos)                     /*!< 0x00000001 */
N#define CAN_FS1R_FSC0          CAN_FS1R_FSC0_Msk                               /*!<Filter Scale Configuration bit 0 */
N#define CAN_FS1R_FSC1_Pos      (1U)                                            
N#define CAN_FS1R_FSC1_Msk      (0x1UL << CAN_FS1R_FSC1_Pos)                     /*!< 0x00000002 */
N#define CAN_FS1R_FSC1          CAN_FS1R_FSC1_Msk                               /*!<Filter Scale Configuration bit 1 */
N#define CAN_FS1R_FSC2_Pos      (2U)                                            
N#define CAN_FS1R_FSC2_Msk      (0x1UL << CAN_FS1R_FSC2_Pos)                     /*!< 0x00000004 */
N#define CAN_FS1R_FSC2          CAN_FS1R_FSC2_Msk                               /*!<Filter Scale Configuration bit 2 */
N#define CAN_FS1R_FSC3_Pos      (3U)                                            
N#define CAN_FS1R_FSC3_Msk      (0x1UL << CAN_FS1R_FSC3_Pos)                     /*!< 0x00000008 */
N#define CAN_FS1R_FSC3          CAN_FS1R_FSC3_Msk                               /*!<Filter Scale Configuration bit 3 */
N#define CAN_FS1R_FSC4_Pos      (4U)                                            
N#define CAN_FS1R_FSC4_Msk      (0x1UL << CAN_FS1R_FSC4_Pos)                     /*!< 0x00000010 */
N#define CAN_FS1R_FSC4          CAN_FS1R_FSC4_Msk                               /*!<Filter Scale Configuration bit 4 */
N#define CAN_FS1R_FSC5_Pos      (5U)                                            
N#define CAN_FS1R_FSC5_Msk      (0x1UL << CAN_FS1R_FSC5_Pos)                     /*!< 0x00000020 */
N#define CAN_FS1R_FSC5          CAN_FS1R_FSC5_Msk                               /*!<Filter Scale Configuration bit 5 */
N#define CAN_FS1R_FSC6_Pos      (6U)                                            
N#define CAN_FS1R_FSC6_Msk      (0x1UL << CAN_FS1R_FSC6_Pos)                     /*!< 0x00000040 */
N#define CAN_FS1R_FSC6          CAN_FS1R_FSC6_Msk                               /*!<Filter Scale Configuration bit 6 */
N#define CAN_FS1R_FSC7_Pos      (7U)                                            
N#define CAN_FS1R_FSC7_Msk      (0x1UL << CAN_FS1R_FSC7_Pos)                     /*!< 0x00000080 */
N#define CAN_FS1R_FSC7          CAN_FS1R_FSC7_Msk                               /*!<Filter Scale Configuration bit 7 */
N#define CAN_FS1R_FSC8_Pos      (8U)                                            
N#define CAN_FS1R_FSC8_Msk      (0x1UL << CAN_FS1R_FSC8_Pos)                     /*!< 0x00000100 */
N#define CAN_FS1R_FSC8          CAN_FS1R_FSC8_Msk                               /*!<Filter Scale Configuration bit 8 */
N#define CAN_FS1R_FSC9_Pos      (9U)                                            
N#define CAN_FS1R_FSC9_Msk      (0x1UL << CAN_FS1R_FSC9_Pos)                     /*!< 0x00000200 */
N#define CAN_FS1R_FSC9          CAN_FS1R_FSC9_Msk                               /*!<Filter Scale Configuration bit 9 */
N#define CAN_FS1R_FSC10_Pos     (10U)                                           
N#define CAN_FS1R_FSC10_Msk     (0x1UL << CAN_FS1R_FSC10_Pos)                    /*!< 0x00000400 */
N#define CAN_FS1R_FSC10         CAN_FS1R_FSC10_Msk                              /*!<Filter Scale Configuration bit 10 */
N#define CAN_FS1R_FSC11_Pos     (11U)                                           
N#define CAN_FS1R_FSC11_Msk     (0x1UL << CAN_FS1R_FSC11_Pos)                    /*!< 0x00000800 */
N#define CAN_FS1R_FSC11         CAN_FS1R_FSC11_Msk                              /*!<Filter Scale Configuration bit 11 */
N#define CAN_FS1R_FSC12_Pos     (12U)                                           
N#define CAN_FS1R_FSC12_Msk     (0x1UL << CAN_FS1R_FSC12_Pos)                    /*!< 0x00001000 */
N#define CAN_FS1R_FSC12         CAN_FS1R_FSC12_Msk                              /*!<Filter Scale Configuration bit 12 */
N#define CAN_FS1R_FSC13_Pos     (13U)                                           
N#define CAN_FS1R_FSC13_Msk     (0x1UL << CAN_FS1R_FSC13_Pos)                    /*!< 0x00002000 */
N#define CAN_FS1R_FSC13         CAN_FS1R_FSC13_Msk                              /*!<Filter Scale Configuration bit 13 */
N#define CAN_FS1R_FSC14_Pos     (14U)                                           
N#define CAN_FS1R_FSC14_Msk     (0x1UL << CAN_FS1R_FSC14_Pos)                    /*!< 0x00004000 */
N#define CAN_FS1R_FSC14         CAN_FS1R_FSC14_Msk                              /*!<Filter Scale Configuration bit 14 */
N#define CAN_FS1R_FSC15_Pos     (15U)                                           
N#define CAN_FS1R_FSC15_Msk     (0x1UL << CAN_FS1R_FSC15_Pos)                    /*!< 0x00008000 */
N#define CAN_FS1R_FSC15         CAN_FS1R_FSC15_Msk                              /*!<Filter Scale Configuration bit 15 */
N#define CAN_FS1R_FSC16_Pos     (16U)                                           
N#define CAN_FS1R_FSC16_Msk     (0x1UL << CAN_FS1R_FSC16_Pos)                    /*!< 0x00010000 */
N#define CAN_FS1R_FSC16         CAN_FS1R_FSC16_Msk                              /*!<Filter Scale Configuration bit 16 */
N#define CAN_FS1R_FSC17_Pos     (17U)                                           
N#define CAN_FS1R_FSC17_Msk     (0x1UL << CAN_FS1R_FSC17_Pos)                    /*!< 0x00020000 */
N#define CAN_FS1R_FSC17         CAN_FS1R_FSC17_Msk                              /*!<Filter Scale Configuration bit 17 */
N#define CAN_FS1R_FSC18_Pos     (18U)                                           
N#define CAN_FS1R_FSC18_Msk     (0x1UL << CAN_FS1R_FSC18_Pos)                    /*!< 0x00040000 */
N#define CAN_FS1R_FSC18         CAN_FS1R_FSC18_Msk                              /*!<Filter Scale Configuration bit 18 */
N#define CAN_FS1R_FSC19_Pos     (19U)                                           
N#define CAN_FS1R_FSC19_Msk     (0x1UL << CAN_FS1R_FSC19_Pos)                    /*!< 0x00080000 */
N#define CAN_FS1R_FSC19         CAN_FS1R_FSC19_Msk                              /*!<Filter Scale Configuration bit 19 */
N#define CAN_FS1R_FSC20_Pos     (20U)                                           
N#define CAN_FS1R_FSC20_Msk     (0x1UL << CAN_FS1R_FSC20_Pos)                    /*!< 0x00100000 */
N#define CAN_FS1R_FSC20         CAN_FS1R_FSC20_Msk                              /*!<Filter Scale Configuration bit 20 */
N#define CAN_FS1R_FSC21_Pos     (21U)                                           
N#define CAN_FS1R_FSC21_Msk     (0x1UL << CAN_FS1R_FSC21_Pos)                    /*!< 0x00200000 */
N#define CAN_FS1R_FSC21         CAN_FS1R_FSC21_Msk                              /*!<Filter Scale Configuration bit 21 */
N#define CAN_FS1R_FSC22_Pos     (22U)                                           
N#define CAN_FS1R_FSC22_Msk     (0x1UL << CAN_FS1R_FSC22_Pos)                    /*!< 0x00400000 */
N#define CAN_FS1R_FSC22         CAN_FS1R_FSC22_Msk                              /*!<Filter Scale Configuration bit 22 */
N#define CAN_FS1R_FSC23_Pos     (23U)                                           
N#define CAN_FS1R_FSC23_Msk     (0x1UL << CAN_FS1R_FSC23_Pos)                    /*!< 0x00800000 */
N#define CAN_FS1R_FSC23         CAN_FS1R_FSC23_Msk                              /*!<Filter Scale Configuration bit 23 */
N#define CAN_FS1R_FSC24_Pos     (24U)                                           
N#define CAN_FS1R_FSC24_Msk     (0x1UL << CAN_FS1R_FSC24_Pos)                    /*!< 0x01000000 */
N#define CAN_FS1R_FSC24         CAN_FS1R_FSC24_Msk                              /*!<Filter Scale Configuration bit 24 */
N#define CAN_FS1R_FSC25_Pos     (25U)                                           
N#define CAN_FS1R_FSC25_Msk     (0x1UL << CAN_FS1R_FSC25_Pos)                    /*!< 0x02000000 */
N#define CAN_FS1R_FSC25         CAN_FS1R_FSC25_Msk                              /*!<Filter Scale Configuration bit 25 */
N#define CAN_FS1R_FSC26_Pos     (26U)                                           
N#define CAN_FS1R_FSC26_Msk     (0x1UL << CAN_FS1R_FSC26_Pos)                    /*!< 0x04000000 */
N#define CAN_FS1R_FSC26         CAN_FS1R_FSC26_Msk                              /*!<Filter Scale Configuration bit 26 */
N#define CAN_FS1R_FSC27_Pos     (27U)                                           
N#define CAN_FS1R_FSC27_Msk     (0x1UL << CAN_FS1R_FSC27_Pos)                    /*!< 0x08000000 */
N#define CAN_FS1R_FSC27         CAN_FS1R_FSC27_Msk                              /*!<Filter Scale Configuration bit 27 */
N
N/******************  Bit definition for CAN_FFA1R register  *******************/
N#define CAN_FFA1R_FFA_Pos      (0U)                                            
N#define CAN_FFA1R_FFA_Msk      (0xFFFFFFFUL << CAN_FFA1R_FFA_Pos)               /*!< 0x0FFFFFFF */
N#define CAN_FFA1R_FFA          CAN_FFA1R_FFA_Msk                               /*!<Filter FIFO Assignment */
N#define CAN_FFA1R_FFA0_Pos     (0U)                                            
N#define CAN_FFA1R_FFA0_Msk     (0x1UL << CAN_FFA1R_FFA0_Pos)                    /*!< 0x00000001 */
N#define CAN_FFA1R_FFA0         CAN_FFA1R_FFA0_Msk                              /*!<Filter FIFO Assignment bit 0 */
N#define CAN_FFA1R_FFA1_Pos     (1U)                                            
N#define CAN_FFA1R_FFA1_Msk     (0x1UL << CAN_FFA1R_FFA1_Pos)                    /*!< 0x00000002 */
N#define CAN_FFA1R_FFA1         CAN_FFA1R_FFA1_Msk                              /*!<Filter FIFO Assignment bit 1 */
N#define CAN_FFA1R_FFA2_Pos     (2U)                                            
N#define CAN_FFA1R_FFA2_Msk     (0x1UL << CAN_FFA1R_FFA2_Pos)                    /*!< 0x00000004 */
N#define CAN_FFA1R_FFA2         CAN_FFA1R_FFA2_Msk                              /*!<Filter FIFO Assignment bit 2 */
N#define CAN_FFA1R_FFA3_Pos     (3U)                                            
N#define CAN_FFA1R_FFA3_Msk     (0x1UL << CAN_FFA1R_FFA3_Pos)                    /*!< 0x00000008 */
N#define CAN_FFA1R_FFA3         CAN_FFA1R_FFA3_Msk                              /*!<Filter FIFO Assignment bit 3 */
N#define CAN_FFA1R_FFA4_Pos     (4U)                                            
N#define CAN_FFA1R_FFA4_Msk     (0x1UL << CAN_FFA1R_FFA4_Pos)                    /*!< 0x00000010 */
N#define CAN_FFA1R_FFA4         CAN_FFA1R_FFA4_Msk                              /*!<Filter FIFO Assignment bit 4 */
N#define CAN_FFA1R_FFA5_Pos     (5U)                                            
N#define CAN_FFA1R_FFA5_Msk     (0x1UL << CAN_FFA1R_FFA5_Pos)                    /*!< 0x00000020 */
N#define CAN_FFA1R_FFA5         CAN_FFA1R_FFA5_Msk                              /*!<Filter FIFO Assignment bit 5 */
N#define CAN_FFA1R_FFA6_Pos     (6U)                                            
N#define CAN_FFA1R_FFA6_Msk     (0x1UL << CAN_FFA1R_FFA6_Pos)                    /*!< 0x00000040 */
N#define CAN_FFA1R_FFA6         CAN_FFA1R_FFA6_Msk                              /*!<Filter FIFO Assignment bit 6 */
N#define CAN_FFA1R_FFA7_Pos     (7U)                                            
N#define CAN_FFA1R_FFA7_Msk     (0x1UL << CAN_FFA1R_FFA7_Pos)                    /*!< 0x00000080 */
N#define CAN_FFA1R_FFA7         CAN_FFA1R_FFA7_Msk                              /*!<Filter FIFO Assignment bit 7 */
N#define CAN_FFA1R_FFA8_Pos     (8U)                                            
N#define CAN_FFA1R_FFA8_Msk     (0x1UL << CAN_FFA1R_FFA8_Pos)                    /*!< 0x00000100 */
N#define CAN_FFA1R_FFA8         CAN_FFA1R_FFA8_Msk                              /*!<Filter FIFO Assignment bit 8 */
N#define CAN_FFA1R_FFA9_Pos     (9U)                                            
N#define CAN_FFA1R_FFA9_Msk     (0x1UL << CAN_FFA1R_FFA9_Pos)                    /*!< 0x00000200 */
N#define CAN_FFA1R_FFA9         CAN_FFA1R_FFA9_Msk                              /*!<Filter FIFO Assignment bit 9 */
N#define CAN_FFA1R_FFA10_Pos    (10U)                                           
N#define CAN_FFA1R_FFA10_Msk    (0x1UL << CAN_FFA1R_FFA10_Pos)                   /*!< 0x00000400 */
N#define CAN_FFA1R_FFA10        CAN_FFA1R_FFA10_Msk                             /*!<Filter FIFO Assignment bit 10 */
N#define CAN_FFA1R_FFA11_Pos    (11U)                                           
N#define CAN_FFA1R_FFA11_Msk    (0x1UL << CAN_FFA1R_FFA11_Pos)                   /*!< 0x00000800 */
N#define CAN_FFA1R_FFA11        CAN_FFA1R_FFA11_Msk                             /*!<Filter FIFO Assignment bit 11 */
N#define CAN_FFA1R_FFA12_Pos    (12U)                                           
N#define CAN_FFA1R_FFA12_Msk    (0x1UL << CAN_FFA1R_FFA12_Pos)                   /*!< 0x00001000 */
N#define CAN_FFA1R_FFA12        CAN_FFA1R_FFA12_Msk                             /*!<Filter FIFO Assignment bit 12 */
N#define CAN_FFA1R_FFA13_Pos    (13U)                                           
N#define CAN_FFA1R_FFA13_Msk    (0x1UL << CAN_FFA1R_FFA13_Pos)                   /*!< 0x00002000 */
N#define CAN_FFA1R_FFA13        CAN_FFA1R_FFA13_Msk                             /*!<Filter FIFO Assignment bit 13 */
N#define CAN_FFA1R_FFA14_Pos    (14U)                                           
N#define CAN_FFA1R_FFA14_Msk    (0x1UL << CAN_FFA1R_FFA14_Pos)                   /*!< 0x00004000 */
N#define CAN_FFA1R_FFA14        CAN_FFA1R_FFA14_Msk                             /*!<Filter FIFO Assignment bit 14 */
N#define CAN_FFA1R_FFA15_Pos    (15U)                                           
N#define CAN_FFA1R_FFA15_Msk    (0x1UL << CAN_FFA1R_FFA15_Pos)                   /*!< 0x00008000 */
N#define CAN_FFA1R_FFA15        CAN_FFA1R_FFA15_Msk                             /*!<Filter FIFO Assignment bit 15 */
N#define CAN_FFA1R_FFA16_Pos    (16U)                                           
N#define CAN_FFA1R_FFA16_Msk    (0x1UL << CAN_FFA1R_FFA16_Pos)                   /*!< 0x00010000 */
N#define CAN_FFA1R_FFA16        CAN_FFA1R_FFA16_Msk                             /*!<Filter FIFO Assignment bit 16 */
N#define CAN_FFA1R_FFA17_Pos    (17U)                                           
N#define CAN_FFA1R_FFA17_Msk    (0x1UL << CAN_FFA1R_FFA17_Pos)                   /*!< 0x00020000 */
N#define CAN_FFA1R_FFA17        CAN_FFA1R_FFA17_Msk                             /*!<Filter FIFO Assignment bit 17 */
N#define CAN_FFA1R_FFA18_Pos    (18U)                                           
N#define CAN_FFA1R_FFA18_Msk    (0x1UL << CAN_FFA1R_FFA18_Pos)                   /*!< 0x00040000 */
N#define CAN_FFA1R_FFA18        CAN_FFA1R_FFA18_Msk                             /*!<Filter FIFO Assignment bit 18 */
N#define CAN_FFA1R_FFA19_Pos    (19U)                                           
N#define CAN_FFA1R_FFA19_Msk    (0x1UL << CAN_FFA1R_FFA19_Pos)                   /*!< 0x00080000 */
N#define CAN_FFA1R_FFA19        CAN_FFA1R_FFA19_Msk                             /*!<Filter FIFO Assignment bit 19 */
N#define CAN_FFA1R_FFA20_Pos    (20U)                                           
N#define CAN_FFA1R_FFA20_Msk    (0x1UL << CAN_FFA1R_FFA20_Pos)                   /*!< 0x00100000 */
N#define CAN_FFA1R_FFA20        CAN_FFA1R_FFA20_Msk                             /*!<Filter FIFO Assignment bit 20 */
N#define CAN_FFA1R_FFA21_Pos    (21U)                                           
N#define CAN_FFA1R_FFA21_Msk    (0x1UL << CAN_FFA1R_FFA21_Pos)                   /*!< 0x00200000 */
N#define CAN_FFA1R_FFA21        CAN_FFA1R_FFA21_Msk                             /*!<Filter FIFO Assignment bit 21 */
N#define CAN_FFA1R_FFA22_Pos    (22U)                                           
N#define CAN_FFA1R_FFA22_Msk    (0x1UL << CAN_FFA1R_FFA22_Pos)                   /*!< 0x00400000 */
N#define CAN_FFA1R_FFA22        CAN_FFA1R_FFA22_Msk                             /*!<Filter FIFO Assignment bit 22 */
N#define CAN_FFA1R_FFA23_Pos    (23U)                                           
N#define CAN_FFA1R_FFA23_Msk    (0x1UL << CAN_FFA1R_FFA23_Pos)                   /*!< 0x00800000 */
N#define CAN_FFA1R_FFA23        CAN_FFA1R_FFA23_Msk                             /*!<Filter FIFO Assignment bit 23 */
N#define CAN_FFA1R_FFA24_Pos    (24U)                                           
N#define CAN_FFA1R_FFA24_Msk    (0x1UL << CAN_FFA1R_FFA24_Pos)                   /*!< 0x01000000 */
N#define CAN_FFA1R_FFA24        CAN_FFA1R_FFA24_Msk                             /*!<Filter FIFO Assignment bit 24 */
N#define CAN_FFA1R_FFA25_Pos    (25U)                                           
N#define CAN_FFA1R_FFA25_Msk    (0x1UL << CAN_FFA1R_FFA25_Pos)                   /*!< 0x02000000 */
N#define CAN_FFA1R_FFA25        CAN_FFA1R_FFA25_Msk                             /*!<Filter FIFO Assignment bit 25 */
N#define CAN_FFA1R_FFA26_Pos    (26U)                                           
N#define CAN_FFA1R_FFA26_Msk    (0x1UL << CAN_FFA1R_FFA26_Pos)                   /*!< 0x04000000 */
N#define CAN_FFA1R_FFA26        CAN_FFA1R_FFA26_Msk                             /*!<Filter FIFO Assignment bit 26 */
N#define CAN_FFA1R_FFA27_Pos    (27U)                                           
N#define CAN_FFA1R_FFA27_Msk    (0x1UL << CAN_FFA1R_FFA27_Pos)                   /*!< 0x08000000 */
N#define CAN_FFA1R_FFA27        CAN_FFA1R_FFA27_Msk                             /*!<Filter FIFO Assignment bit 27 */
N
N/*******************  Bit definition for CAN_FA1R register  *******************/
N#define CAN_FA1R_FACT_Pos      (0U)                                            
N#define CAN_FA1R_FACT_Msk      (0xFFFFFFFUL << CAN_FA1R_FACT_Pos)               /*!< 0x0FFFFFFF */
N#define CAN_FA1R_FACT          CAN_FA1R_FACT_Msk                               /*!<Filter Active */
N#define CAN_FA1R_FACT0_Pos     (0U)                                            
N#define CAN_FA1R_FACT0_Msk     (0x1UL << CAN_FA1R_FACT0_Pos)                    /*!< 0x00000001 */
N#define CAN_FA1R_FACT0         CAN_FA1R_FACT0_Msk                              /*!<Filter Active bit 0 */
N#define CAN_FA1R_FACT1_Pos     (1U)                                            
N#define CAN_FA1R_FACT1_Msk     (0x1UL << CAN_FA1R_FACT1_Pos)                    /*!< 0x00000002 */
N#define CAN_FA1R_FACT1         CAN_FA1R_FACT1_Msk                              /*!<Filter Active bit 1 */
N#define CAN_FA1R_FACT2_Pos     (2U)                                            
N#define CAN_FA1R_FACT2_Msk     (0x1UL << CAN_FA1R_FACT2_Pos)                    /*!< 0x00000004 */
N#define CAN_FA1R_FACT2         CAN_FA1R_FACT2_Msk                              /*!<Filter Active bit 2 */
N#define CAN_FA1R_FACT3_Pos     (3U)                                            
N#define CAN_FA1R_FACT3_Msk     (0x1UL << CAN_FA1R_FACT3_Pos)                    /*!< 0x00000008 */
N#define CAN_FA1R_FACT3         CAN_FA1R_FACT3_Msk                              /*!<Filter Active bit 3 */
N#define CAN_FA1R_FACT4_Pos     (4U)                                            
N#define CAN_FA1R_FACT4_Msk     (0x1UL << CAN_FA1R_FACT4_Pos)                    /*!< 0x00000010 */
N#define CAN_FA1R_FACT4         CAN_FA1R_FACT4_Msk                              /*!<Filter Active bit 4 */
N#define CAN_FA1R_FACT5_Pos     (5U)                                            
N#define CAN_FA1R_FACT5_Msk     (0x1UL << CAN_FA1R_FACT5_Pos)                    /*!< 0x00000020 */
N#define CAN_FA1R_FACT5         CAN_FA1R_FACT5_Msk                              /*!<Filter Active bit 5 */
N#define CAN_FA1R_FACT6_Pos     (6U)                                            
N#define CAN_FA1R_FACT6_Msk     (0x1UL << CAN_FA1R_FACT6_Pos)                    /*!< 0x00000040 */
N#define CAN_FA1R_FACT6         CAN_FA1R_FACT6_Msk                              /*!<Filter Active bit 6 */
N#define CAN_FA1R_FACT7_Pos     (7U)                                            
N#define CAN_FA1R_FACT7_Msk     (0x1UL << CAN_FA1R_FACT7_Pos)                    /*!< 0x00000080 */
N#define CAN_FA1R_FACT7         CAN_FA1R_FACT7_Msk                              /*!<Filter Active bit 7 */
N#define CAN_FA1R_FACT8_Pos     (8U)                                            
N#define CAN_FA1R_FACT8_Msk     (0x1UL << CAN_FA1R_FACT8_Pos)                    /*!< 0x00000100 */
N#define CAN_FA1R_FACT8         CAN_FA1R_FACT8_Msk                              /*!<Filter Active bit 8 */
N#define CAN_FA1R_FACT9_Pos     (9U)                                            
N#define CAN_FA1R_FACT9_Msk     (0x1UL << CAN_FA1R_FACT9_Pos)                    /*!< 0x00000200 */
N#define CAN_FA1R_FACT9         CAN_FA1R_FACT9_Msk                              /*!<Filter Active bit 9 */
N#define CAN_FA1R_FACT10_Pos    (10U)                                           
N#define CAN_FA1R_FACT10_Msk    (0x1UL << CAN_FA1R_FACT10_Pos)                   /*!< 0x00000400 */
N#define CAN_FA1R_FACT10        CAN_FA1R_FACT10_Msk                             /*!<Filter Active bit 10 */
N#define CAN_FA1R_FACT11_Pos    (11U)                                           
N#define CAN_FA1R_FACT11_Msk    (0x1UL << CAN_FA1R_FACT11_Pos)                   /*!< 0x00000800 */
N#define CAN_FA1R_FACT11        CAN_FA1R_FACT11_Msk                             /*!<Filter Active bit 11 */
N#define CAN_FA1R_FACT12_Pos    (12U)                                           
N#define CAN_FA1R_FACT12_Msk    (0x1UL << CAN_FA1R_FACT12_Pos)                   /*!< 0x00001000 */
N#define CAN_FA1R_FACT12        CAN_FA1R_FACT12_Msk                             /*!<Filter Active bit 12 */
N#define CAN_FA1R_FACT13_Pos    (13U)                                           
N#define CAN_FA1R_FACT13_Msk    (0x1UL << CAN_FA1R_FACT13_Pos)                   /*!< 0x00002000 */
N#define CAN_FA1R_FACT13        CAN_FA1R_FACT13_Msk                             /*!<Filter Active bit 13 */
N#define CAN_FA1R_FACT14_Pos    (14U)                                           
N#define CAN_FA1R_FACT14_Msk    (0x1UL << CAN_FA1R_FACT14_Pos)                   /*!< 0x00004000 */
N#define CAN_FA1R_FACT14        CAN_FA1R_FACT14_Msk                             /*!<Filter Active bit 14 */
N#define CAN_FA1R_FACT15_Pos    (15U)                                           
N#define CAN_FA1R_FACT15_Msk    (0x1UL << CAN_FA1R_FACT15_Pos)                   /*!< 0x00008000 */
N#define CAN_FA1R_FACT15        CAN_FA1R_FACT15_Msk                             /*!<Filter Active bit 15 */
N#define CAN_FA1R_FACT16_Pos    (16U)                                           
N#define CAN_FA1R_FACT16_Msk    (0x1UL << CAN_FA1R_FACT16_Pos)                   /*!< 0x00010000 */
N#define CAN_FA1R_FACT16        CAN_FA1R_FACT16_Msk                             /*!<Filter Active bit 16 */
N#define CAN_FA1R_FACT17_Pos    (17U)                                           
N#define CAN_FA1R_FACT17_Msk    (0x1UL << CAN_FA1R_FACT17_Pos)                   /*!< 0x00020000 */
N#define CAN_FA1R_FACT17        CAN_FA1R_FACT17_Msk                             /*!<Filter Active bit 17 */
N#define CAN_FA1R_FACT18_Pos    (18U)                                           
N#define CAN_FA1R_FACT18_Msk    (0x1UL << CAN_FA1R_FACT18_Pos)                   /*!< 0x00040000 */
N#define CAN_FA1R_FACT18        CAN_FA1R_FACT18_Msk                             /*!<Filter Active bit 18 */
N#define CAN_FA1R_FACT19_Pos    (19U)                                           
N#define CAN_FA1R_FACT19_Msk    (0x1UL << CAN_FA1R_FACT19_Pos)                   /*!< 0x00080000 */
N#define CAN_FA1R_FACT19        CAN_FA1R_FACT19_Msk                             /*!<Filter Active bit 19 */
N#define CAN_FA1R_FACT20_Pos    (20U)                                           
N#define CAN_FA1R_FACT20_Msk    (0x1UL << CAN_FA1R_FACT20_Pos)                   /*!< 0x00100000 */
N#define CAN_FA1R_FACT20        CAN_FA1R_FACT20_Msk                             /*!<Filter Active bit 20 */
N#define CAN_FA1R_FACT21_Pos    (21U)                                           
N#define CAN_FA1R_FACT21_Msk    (0x1UL << CAN_FA1R_FACT21_Pos)                   /*!< 0x00200000 */
N#define CAN_FA1R_FACT21        CAN_FA1R_FACT21_Msk                             /*!<Filter Active bit 21 */
N#define CAN_FA1R_FACT22_Pos    (22U)                                           
N#define CAN_FA1R_FACT22_Msk    (0x1UL << CAN_FA1R_FACT22_Pos)                   /*!< 0x00400000 */
N#define CAN_FA1R_FACT22        CAN_FA1R_FACT22_Msk                             /*!<Filter Active bit 22 */
N#define CAN_FA1R_FACT23_Pos    (23U)                                           
N#define CAN_FA1R_FACT23_Msk    (0x1UL << CAN_FA1R_FACT23_Pos)                   /*!< 0x00800000 */
N#define CAN_FA1R_FACT23        CAN_FA1R_FACT23_Msk                             /*!<Filter Active bit 23 */
N#define CAN_FA1R_FACT24_Pos    (24U)                                           
N#define CAN_FA1R_FACT24_Msk    (0x1UL << CAN_FA1R_FACT24_Pos)                   /*!< 0x01000000 */
N#define CAN_FA1R_FACT24        CAN_FA1R_FACT24_Msk                             /*!<Filter Active bit 24 */
N#define CAN_FA1R_FACT25_Pos    (25U)                                           
N#define CAN_FA1R_FACT25_Msk    (0x1UL << CAN_FA1R_FACT25_Pos)                   /*!< 0x02000000 */
N#define CAN_FA1R_FACT25        CAN_FA1R_FACT25_Msk                             /*!<Filter Active bit 25 */
N#define CAN_FA1R_FACT26_Pos    (26U)                                           
N#define CAN_FA1R_FACT26_Msk    (0x1UL << CAN_FA1R_FACT26_Pos)                   /*!< 0x04000000 */
N#define CAN_FA1R_FACT26        CAN_FA1R_FACT26_Msk                             /*!<Filter Active bit 26 */
N#define CAN_FA1R_FACT27_Pos    (27U)                                           
N#define CAN_FA1R_FACT27_Msk    (0x1UL << CAN_FA1R_FACT27_Pos)                   /*!< 0x08000000 */
N#define CAN_FA1R_FACT27        CAN_FA1R_FACT27_Msk                             /*!<Filter Active bit 27 */
N
N
N/*******************  Bit definition for CAN_F0R1 register  *******************/
N#define CAN_F0R1_FB0_Pos       (0U)                                            
N#define CAN_F0R1_FB0_Msk       (0x1UL << CAN_F0R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F0R1_FB0           CAN_F0R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F0R1_FB1_Pos       (1U)                                            
N#define CAN_F0R1_FB1_Msk       (0x1UL << CAN_F0R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F0R1_FB1           CAN_F0R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F0R1_FB2_Pos       (2U)                                            
N#define CAN_F0R1_FB2_Msk       (0x1UL << CAN_F0R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F0R1_FB2           CAN_F0R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F0R1_FB3_Pos       (3U)                                            
N#define CAN_F0R1_FB3_Msk       (0x1UL << CAN_F0R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F0R1_FB3           CAN_F0R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F0R1_FB4_Pos       (4U)                                            
N#define CAN_F0R1_FB4_Msk       (0x1UL << CAN_F0R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F0R1_FB4           CAN_F0R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F0R1_FB5_Pos       (5U)                                            
N#define CAN_F0R1_FB5_Msk       (0x1UL << CAN_F0R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F0R1_FB5           CAN_F0R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F0R1_FB6_Pos       (6U)                                            
N#define CAN_F0R1_FB6_Msk       (0x1UL << CAN_F0R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F0R1_FB6           CAN_F0R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F0R1_FB7_Pos       (7U)                                            
N#define CAN_F0R1_FB7_Msk       (0x1UL << CAN_F0R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F0R1_FB7           CAN_F0R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F0R1_FB8_Pos       (8U)                                            
N#define CAN_F0R1_FB8_Msk       (0x1UL << CAN_F0R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F0R1_FB8           CAN_F0R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F0R1_FB9_Pos       (9U)                                            
N#define CAN_F0R1_FB9_Msk       (0x1UL << CAN_F0R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F0R1_FB9           CAN_F0R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F0R1_FB10_Pos      (10U)                                           
N#define CAN_F0R1_FB10_Msk      (0x1UL << CAN_F0R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F0R1_FB10          CAN_F0R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F0R1_FB11_Pos      (11U)                                           
N#define CAN_F0R1_FB11_Msk      (0x1UL << CAN_F0R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F0R1_FB11          CAN_F0R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F0R1_FB12_Pos      (12U)                                           
N#define CAN_F0R1_FB12_Msk      (0x1UL << CAN_F0R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F0R1_FB12          CAN_F0R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F0R1_FB13_Pos      (13U)                                           
N#define CAN_F0R1_FB13_Msk      (0x1UL << CAN_F0R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F0R1_FB13          CAN_F0R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F0R1_FB14_Pos      (14U)                                           
N#define CAN_F0R1_FB14_Msk      (0x1UL << CAN_F0R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F0R1_FB14          CAN_F0R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F0R1_FB15_Pos      (15U)                                           
N#define CAN_F0R1_FB15_Msk      (0x1UL << CAN_F0R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F0R1_FB15          CAN_F0R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F0R1_FB16_Pos      (16U)                                           
N#define CAN_F0R1_FB16_Msk      (0x1UL << CAN_F0R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F0R1_FB16          CAN_F0R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F0R1_FB17_Pos      (17U)                                           
N#define CAN_F0R1_FB17_Msk      (0x1UL << CAN_F0R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F0R1_FB17          CAN_F0R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F0R1_FB18_Pos      (18U)                                           
N#define CAN_F0R1_FB18_Msk      (0x1UL << CAN_F0R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F0R1_FB18          CAN_F0R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F0R1_FB19_Pos      (19U)                                           
N#define CAN_F0R1_FB19_Msk      (0x1UL << CAN_F0R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F0R1_FB19          CAN_F0R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F0R1_FB20_Pos      (20U)                                           
N#define CAN_F0R1_FB20_Msk      (0x1UL << CAN_F0R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F0R1_FB20          CAN_F0R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F0R1_FB21_Pos      (21U)                                           
N#define CAN_F0R1_FB21_Msk      (0x1UL << CAN_F0R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F0R1_FB21          CAN_F0R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F0R1_FB22_Pos      (22U)                                           
N#define CAN_F0R1_FB22_Msk      (0x1UL << CAN_F0R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F0R1_FB22          CAN_F0R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F0R1_FB23_Pos      (23U)                                           
N#define CAN_F0R1_FB23_Msk      (0x1UL << CAN_F0R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F0R1_FB23          CAN_F0R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F0R1_FB24_Pos      (24U)                                           
N#define CAN_F0R1_FB24_Msk      (0x1UL << CAN_F0R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F0R1_FB24          CAN_F0R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F0R1_FB25_Pos      (25U)                                           
N#define CAN_F0R1_FB25_Msk      (0x1UL << CAN_F0R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F0R1_FB25          CAN_F0R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F0R1_FB26_Pos      (26U)                                           
N#define CAN_F0R1_FB26_Msk      (0x1UL << CAN_F0R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F0R1_FB26          CAN_F0R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F0R1_FB27_Pos      (27U)                                           
N#define CAN_F0R1_FB27_Msk      (0x1UL << CAN_F0R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F0R1_FB27          CAN_F0R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F0R1_FB28_Pos      (28U)                                           
N#define CAN_F0R1_FB28_Msk      (0x1UL << CAN_F0R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F0R1_FB28          CAN_F0R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F0R1_FB29_Pos      (29U)                                           
N#define CAN_F0R1_FB29_Msk      (0x1UL << CAN_F0R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F0R1_FB29          CAN_F0R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F0R1_FB30_Pos      (30U)                                           
N#define CAN_F0R1_FB30_Msk      (0x1UL << CAN_F0R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F0R1_FB30          CAN_F0R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F0R1_FB31_Pos      (31U)                                           
N#define CAN_F0R1_FB31_Msk      (0x1UL << CAN_F0R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F0R1_FB31          CAN_F0R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R1 register  *******************/
N#define CAN_F1R1_FB0_Pos       (0U)                                            
N#define CAN_F1R1_FB0_Msk       (0x1UL << CAN_F1R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F1R1_FB0           CAN_F1R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F1R1_FB1_Pos       (1U)                                            
N#define CAN_F1R1_FB1_Msk       (0x1UL << CAN_F1R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F1R1_FB1           CAN_F1R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F1R1_FB2_Pos       (2U)                                            
N#define CAN_F1R1_FB2_Msk       (0x1UL << CAN_F1R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F1R1_FB2           CAN_F1R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F1R1_FB3_Pos       (3U)                                            
N#define CAN_F1R1_FB3_Msk       (0x1UL << CAN_F1R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F1R1_FB3           CAN_F1R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F1R1_FB4_Pos       (4U)                                            
N#define CAN_F1R1_FB4_Msk       (0x1UL << CAN_F1R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F1R1_FB4           CAN_F1R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F1R1_FB5_Pos       (5U)                                            
N#define CAN_F1R1_FB5_Msk       (0x1UL << CAN_F1R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F1R1_FB5           CAN_F1R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F1R1_FB6_Pos       (6U)                                            
N#define CAN_F1R1_FB6_Msk       (0x1UL << CAN_F1R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F1R1_FB6           CAN_F1R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F1R1_FB7_Pos       (7U)                                            
N#define CAN_F1R1_FB7_Msk       (0x1UL << CAN_F1R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F1R1_FB7           CAN_F1R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F1R1_FB8_Pos       (8U)                                            
N#define CAN_F1R1_FB8_Msk       (0x1UL << CAN_F1R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F1R1_FB8           CAN_F1R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F1R1_FB9_Pos       (9U)                                            
N#define CAN_F1R1_FB9_Msk       (0x1UL << CAN_F1R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F1R1_FB9           CAN_F1R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F1R1_FB10_Pos      (10U)                                           
N#define CAN_F1R1_FB10_Msk      (0x1UL << CAN_F1R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F1R1_FB10          CAN_F1R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F1R1_FB11_Pos      (11U)                                           
N#define CAN_F1R1_FB11_Msk      (0x1UL << CAN_F1R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F1R1_FB11          CAN_F1R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F1R1_FB12_Pos      (12U)                                           
N#define CAN_F1R1_FB12_Msk      (0x1UL << CAN_F1R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F1R1_FB12          CAN_F1R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F1R1_FB13_Pos      (13U)                                           
N#define CAN_F1R1_FB13_Msk      (0x1UL << CAN_F1R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F1R1_FB13          CAN_F1R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F1R1_FB14_Pos      (14U)                                           
N#define CAN_F1R1_FB14_Msk      (0x1UL << CAN_F1R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F1R1_FB14          CAN_F1R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F1R1_FB15_Pos      (15U)                                           
N#define CAN_F1R1_FB15_Msk      (0x1UL << CAN_F1R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F1R1_FB15          CAN_F1R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F1R1_FB16_Pos      (16U)                                           
N#define CAN_F1R1_FB16_Msk      (0x1UL << CAN_F1R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F1R1_FB16          CAN_F1R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F1R1_FB17_Pos      (17U)                                           
N#define CAN_F1R1_FB17_Msk      (0x1UL << CAN_F1R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F1R1_FB17          CAN_F1R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F1R1_FB18_Pos      (18U)                                           
N#define CAN_F1R1_FB18_Msk      (0x1UL << CAN_F1R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F1R1_FB18          CAN_F1R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F1R1_FB19_Pos      (19U)                                           
N#define CAN_F1R1_FB19_Msk      (0x1UL << CAN_F1R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F1R1_FB19          CAN_F1R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F1R1_FB20_Pos      (20U)                                           
N#define CAN_F1R1_FB20_Msk      (0x1UL << CAN_F1R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F1R1_FB20          CAN_F1R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F1R1_FB21_Pos      (21U)                                           
N#define CAN_F1R1_FB21_Msk      (0x1UL << CAN_F1R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F1R1_FB21          CAN_F1R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F1R1_FB22_Pos      (22U)                                           
N#define CAN_F1R1_FB22_Msk      (0x1UL << CAN_F1R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F1R1_FB22          CAN_F1R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F1R1_FB23_Pos      (23U)                                           
N#define CAN_F1R1_FB23_Msk      (0x1UL << CAN_F1R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F1R1_FB23          CAN_F1R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F1R1_FB24_Pos      (24U)                                           
N#define CAN_F1R1_FB24_Msk      (0x1UL << CAN_F1R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F1R1_FB24          CAN_F1R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F1R1_FB25_Pos      (25U)                                           
N#define CAN_F1R1_FB25_Msk      (0x1UL << CAN_F1R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F1R1_FB25          CAN_F1R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F1R1_FB26_Pos      (26U)                                           
N#define CAN_F1R1_FB26_Msk      (0x1UL << CAN_F1R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F1R1_FB26          CAN_F1R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F1R1_FB27_Pos      (27U)                                           
N#define CAN_F1R1_FB27_Msk      (0x1UL << CAN_F1R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F1R1_FB27          CAN_F1R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F1R1_FB28_Pos      (28U)                                           
N#define CAN_F1R1_FB28_Msk      (0x1UL << CAN_F1R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F1R1_FB28          CAN_F1R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F1R1_FB29_Pos      (29U)                                           
N#define CAN_F1R1_FB29_Msk      (0x1UL << CAN_F1R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F1R1_FB29          CAN_F1R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F1R1_FB30_Pos      (30U)                                           
N#define CAN_F1R1_FB30_Msk      (0x1UL << CAN_F1R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F1R1_FB30          CAN_F1R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F1R1_FB31_Pos      (31U)                                           
N#define CAN_F1R1_FB31_Msk      (0x1UL << CAN_F1R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F1R1_FB31          CAN_F1R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R1 register  *******************/
N#define CAN_F2R1_FB0_Pos       (0U)                                            
N#define CAN_F2R1_FB0_Msk       (0x1UL << CAN_F2R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F2R1_FB0           CAN_F2R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F2R1_FB1_Pos       (1U)                                            
N#define CAN_F2R1_FB1_Msk       (0x1UL << CAN_F2R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F2R1_FB1           CAN_F2R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F2R1_FB2_Pos       (2U)                                            
N#define CAN_F2R1_FB2_Msk       (0x1UL << CAN_F2R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F2R1_FB2           CAN_F2R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F2R1_FB3_Pos       (3U)                                            
N#define CAN_F2R1_FB3_Msk       (0x1UL << CAN_F2R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F2R1_FB3           CAN_F2R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F2R1_FB4_Pos       (4U)                                            
N#define CAN_F2R1_FB4_Msk       (0x1UL << CAN_F2R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F2R1_FB4           CAN_F2R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F2R1_FB5_Pos       (5U)                                            
N#define CAN_F2R1_FB5_Msk       (0x1UL << CAN_F2R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F2R1_FB5           CAN_F2R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F2R1_FB6_Pos       (6U)                                            
N#define CAN_F2R1_FB6_Msk       (0x1UL << CAN_F2R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F2R1_FB6           CAN_F2R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F2R1_FB7_Pos       (7U)                                            
N#define CAN_F2R1_FB7_Msk       (0x1UL << CAN_F2R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F2R1_FB7           CAN_F2R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F2R1_FB8_Pos       (8U)                                            
N#define CAN_F2R1_FB8_Msk       (0x1UL << CAN_F2R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F2R1_FB8           CAN_F2R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F2R1_FB9_Pos       (9U)                                            
N#define CAN_F2R1_FB9_Msk       (0x1UL << CAN_F2R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F2R1_FB9           CAN_F2R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F2R1_FB10_Pos      (10U)                                           
N#define CAN_F2R1_FB10_Msk      (0x1UL << CAN_F2R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F2R1_FB10          CAN_F2R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F2R1_FB11_Pos      (11U)                                           
N#define CAN_F2R1_FB11_Msk      (0x1UL << CAN_F2R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F2R1_FB11          CAN_F2R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F2R1_FB12_Pos      (12U)                                           
N#define CAN_F2R1_FB12_Msk      (0x1UL << CAN_F2R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F2R1_FB12          CAN_F2R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F2R1_FB13_Pos      (13U)                                           
N#define CAN_F2R1_FB13_Msk      (0x1UL << CAN_F2R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F2R1_FB13          CAN_F2R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F2R1_FB14_Pos      (14U)                                           
N#define CAN_F2R1_FB14_Msk      (0x1UL << CAN_F2R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F2R1_FB14          CAN_F2R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F2R1_FB15_Pos      (15U)                                           
N#define CAN_F2R1_FB15_Msk      (0x1UL << CAN_F2R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F2R1_FB15          CAN_F2R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F2R1_FB16_Pos      (16U)                                           
N#define CAN_F2R1_FB16_Msk      (0x1UL << CAN_F2R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F2R1_FB16          CAN_F2R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F2R1_FB17_Pos      (17U)                                           
N#define CAN_F2R1_FB17_Msk      (0x1UL << CAN_F2R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F2R1_FB17          CAN_F2R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F2R1_FB18_Pos      (18U)                                           
N#define CAN_F2R1_FB18_Msk      (0x1UL << CAN_F2R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F2R1_FB18          CAN_F2R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F2R1_FB19_Pos      (19U)                                           
N#define CAN_F2R1_FB19_Msk      (0x1UL << CAN_F2R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F2R1_FB19          CAN_F2R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F2R1_FB20_Pos      (20U)                                           
N#define CAN_F2R1_FB20_Msk      (0x1UL << CAN_F2R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F2R1_FB20          CAN_F2R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F2R1_FB21_Pos      (21U)                                           
N#define CAN_F2R1_FB21_Msk      (0x1UL << CAN_F2R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F2R1_FB21          CAN_F2R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F2R1_FB22_Pos      (22U)                                           
N#define CAN_F2R1_FB22_Msk      (0x1UL << CAN_F2R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F2R1_FB22          CAN_F2R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F2R1_FB23_Pos      (23U)                                           
N#define CAN_F2R1_FB23_Msk      (0x1UL << CAN_F2R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F2R1_FB23          CAN_F2R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F2R1_FB24_Pos      (24U)                                           
N#define CAN_F2R1_FB24_Msk      (0x1UL << CAN_F2R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F2R1_FB24          CAN_F2R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F2R1_FB25_Pos      (25U)                                           
N#define CAN_F2R1_FB25_Msk      (0x1UL << CAN_F2R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F2R1_FB25          CAN_F2R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F2R1_FB26_Pos      (26U)                                           
N#define CAN_F2R1_FB26_Msk      (0x1UL << CAN_F2R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F2R1_FB26          CAN_F2R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F2R1_FB27_Pos      (27U)                                           
N#define CAN_F2R1_FB27_Msk      (0x1UL << CAN_F2R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F2R1_FB27          CAN_F2R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F2R1_FB28_Pos      (28U)                                           
N#define CAN_F2R1_FB28_Msk      (0x1UL << CAN_F2R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F2R1_FB28          CAN_F2R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F2R1_FB29_Pos      (29U)                                           
N#define CAN_F2R1_FB29_Msk      (0x1UL << CAN_F2R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F2R1_FB29          CAN_F2R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F2R1_FB30_Pos      (30U)                                           
N#define CAN_F2R1_FB30_Msk      (0x1UL << CAN_F2R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F2R1_FB30          CAN_F2R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F2R1_FB31_Pos      (31U)                                           
N#define CAN_F2R1_FB31_Msk      (0x1UL << CAN_F2R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F2R1_FB31          CAN_F2R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R1 register  *******************/
N#define CAN_F3R1_FB0_Pos       (0U)                                            
N#define CAN_F3R1_FB0_Msk       (0x1UL << CAN_F3R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F3R1_FB0           CAN_F3R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F3R1_FB1_Pos       (1U)                                            
N#define CAN_F3R1_FB1_Msk       (0x1UL << CAN_F3R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F3R1_FB1           CAN_F3R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F3R1_FB2_Pos       (2U)                                            
N#define CAN_F3R1_FB2_Msk       (0x1UL << CAN_F3R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F3R1_FB2           CAN_F3R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F3R1_FB3_Pos       (3U)                                            
N#define CAN_F3R1_FB3_Msk       (0x1UL << CAN_F3R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F3R1_FB3           CAN_F3R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F3R1_FB4_Pos       (4U)                                            
N#define CAN_F3R1_FB4_Msk       (0x1UL << CAN_F3R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F3R1_FB4           CAN_F3R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F3R1_FB5_Pos       (5U)                                            
N#define CAN_F3R1_FB5_Msk       (0x1UL << CAN_F3R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F3R1_FB5           CAN_F3R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F3R1_FB6_Pos       (6U)                                            
N#define CAN_F3R1_FB6_Msk       (0x1UL << CAN_F3R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F3R1_FB6           CAN_F3R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F3R1_FB7_Pos       (7U)                                            
N#define CAN_F3R1_FB7_Msk       (0x1UL << CAN_F3R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F3R1_FB7           CAN_F3R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F3R1_FB8_Pos       (8U)                                            
N#define CAN_F3R1_FB8_Msk       (0x1UL << CAN_F3R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F3R1_FB8           CAN_F3R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F3R1_FB9_Pos       (9U)                                            
N#define CAN_F3R1_FB9_Msk       (0x1UL << CAN_F3R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F3R1_FB9           CAN_F3R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F3R1_FB10_Pos      (10U)                                           
N#define CAN_F3R1_FB10_Msk      (0x1UL << CAN_F3R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F3R1_FB10          CAN_F3R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F3R1_FB11_Pos      (11U)                                           
N#define CAN_F3R1_FB11_Msk      (0x1UL << CAN_F3R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F3R1_FB11          CAN_F3R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F3R1_FB12_Pos      (12U)                                           
N#define CAN_F3R1_FB12_Msk      (0x1UL << CAN_F3R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F3R1_FB12          CAN_F3R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F3R1_FB13_Pos      (13U)                                           
N#define CAN_F3R1_FB13_Msk      (0x1UL << CAN_F3R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F3R1_FB13          CAN_F3R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F3R1_FB14_Pos      (14U)                                           
N#define CAN_F3R1_FB14_Msk      (0x1UL << CAN_F3R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F3R1_FB14          CAN_F3R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F3R1_FB15_Pos      (15U)                                           
N#define CAN_F3R1_FB15_Msk      (0x1UL << CAN_F3R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F3R1_FB15          CAN_F3R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F3R1_FB16_Pos      (16U)                                           
N#define CAN_F3R1_FB16_Msk      (0x1UL << CAN_F3R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F3R1_FB16          CAN_F3R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F3R1_FB17_Pos      (17U)                                           
N#define CAN_F3R1_FB17_Msk      (0x1UL << CAN_F3R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F3R1_FB17          CAN_F3R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F3R1_FB18_Pos      (18U)                                           
N#define CAN_F3R1_FB18_Msk      (0x1UL << CAN_F3R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F3R1_FB18          CAN_F3R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F3R1_FB19_Pos      (19U)                                           
N#define CAN_F3R1_FB19_Msk      (0x1UL << CAN_F3R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F3R1_FB19          CAN_F3R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F3R1_FB20_Pos      (20U)                                           
N#define CAN_F3R1_FB20_Msk      (0x1UL << CAN_F3R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F3R1_FB20          CAN_F3R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F3R1_FB21_Pos      (21U)                                           
N#define CAN_F3R1_FB21_Msk      (0x1UL << CAN_F3R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F3R1_FB21          CAN_F3R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F3R1_FB22_Pos      (22U)                                           
N#define CAN_F3R1_FB22_Msk      (0x1UL << CAN_F3R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F3R1_FB22          CAN_F3R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F3R1_FB23_Pos      (23U)                                           
N#define CAN_F3R1_FB23_Msk      (0x1UL << CAN_F3R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F3R1_FB23          CAN_F3R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F3R1_FB24_Pos      (24U)                                           
N#define CAN_F3R1_FB24_Msk      (0x1UL << CAN_F3R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F3R1_FB24          CAN_F3R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F3R1_FB25_Pos      (25U)                                           
N#define CAN_F3R1_FB25_Msk      (0x1UL << CAN_F3R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F3R1_FB25          CAN_F3R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F3R1_FB26_Pos      (26U)                                           
N#define CAN_F3R1_FB26_Msk      (0x1UL << CAN_F3R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F3R1_FB26          CAN_F3R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F3R1_FB27_Pos      (27U)                                           
N#define CAN_F3R1_FB27_Msk      (0x1UL << CAN_F3R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F3R1_FB27          CAN_F3R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F3R1_FB28_Pos      (28U)                                           
N#define CAN_F3R1_FB28_Msk      (0x1UL << CAN_F3R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F3R1_FB28          CAN_F3R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F3R1_FB29_Pos      (29U)                                           
N#define CAN_F3R1_FB29_Msk      (0x1UL << CAN_F3R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F3R1_FB29          CAN_F3R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F3R1_FB30_Pos      (30U)                                           
N#define CAN_F3R1_FB30_Msk      (0x1UL << CAN_F3R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F3R1_FB30          CAN_F3R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F3R1_FB31_Pos      (31U)                                           
N#define CAN_F3R1_FB31_Msk      (0x1UL << CAN_F3R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F3R1_FB31          CAN_F3R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R1 register  *******************/
N#define CAN_F4R1_FB0_Pos       (0U)                                            
N#define CAN_F4R1_FB0_Msk       (0x1UL << CAN_F4R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F4R1_FB0           CAN_F4R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F4R1_FB1_Pos       (1U)                                            
N#define CAN_F4R1_FB1_Msk       (0x1UL << CAN_F4R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F4R1_FB1           CAN_F4R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F4R1_FB2_Pos       (2U)                                            
N#define CAN_F4R1_FB2_Msk       (0x1UL << CAN_F4R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F4R1_FB2           CAN_F4R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F4R1_FB3_Pos       (3U)                                            
N#define CAN_F4R1_FB3_Msk       (0x1UL << CAN_F4R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F4R1_FB3           CAN_F4R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F4R1_FB4_Pos       (4U)                                            
N#define CAN_F4R1_FB4_Msk       (0x1UL << CAN_F4R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F4R1_FB4           CAN_F4R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F4R1_FB5_Pos       (5U)                                            
N#define CAN_F4R1_FB5_Msk       (0x1UL << CAN_F4R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F4R1_FB5           CAN_F4R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F4R1_FB6_Pos       (6U)                                            
N#define CAN_F4R1_FB6_Msk       (0x1UL << CAN_F4R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F4R1_FB6           CAN_F4R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F4R1_FB7_Pos       (7U)                                            
N#define CAN_F4R1_FB7_Msk       (0x1UL << CAN_F4R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F4R1_FB7           CAN_F4R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F4R1_FB8_Pos       (8U)                                            
N#define CAN_F4R1_FB8_Msk       (0x1UL << CAN_F4R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F4R1_FB8           CAN_F4R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F4R1_FB9_Pos       (9U)                                            
N#define CAN_F4R1_FB9_Msk       (0x1UL << CAN_F4R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F4R1_FB9           CAN_F4R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F4R1_FB10_Pos      (10U)                                           
N#define CAN_F4R1_FB10_Msk      (0x1UL << CAN_F4R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F4R1_FB10          CAN_F4R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F4R1_FB11_Pos      (11U)                                           
N#define CAN_F4R1_FB11_Msk      (0x1UL << CAN_F4R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F4R1_FB11          CAN_F4R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F4R1_FB12_Pos      (12U)                                           
N#define CAN_F4R1_FB12_Msk      (0x1UL << CAN_F4R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F4R1_FB12          CAN_F4R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F4R1_FB13_Pos      (13U)                                           
N#define CAN_F4R1_FB13_Msk      (0x1UL << CAN_F4R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F4R1_FB13          CAN_F4R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F4R1_FB14_Pos      (14U)                                           
N#define CAN_F4R1_FB14_Msk      (0x1UL << CAN_F4R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F4R1_FB14          CAN_F4R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F4R1_FB15_Pos      (15U)                                           
N#define CAN_F4R1_FB15_Msk      (0x1UL << CAN_F4R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F4R1_FB15          CAN_F4R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F4R1_FB16_Pos      (16U)                                           
N#define CAN_F4R1_FB16_Msk      (0x1UL << CAN_F4R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F4R1_FB16          CAN_F4R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F4R1_FB17_Pos      (17U)                                           
N#define CAN_F4R1_FB17_Msk      (0x1UL << CAN_F4R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F4R1_FB17          CAN_F4R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F4R1_FB18_Pos      (18U)                                           
N#define CAN_F4R1_FB18_Msk      (0x1UL << CAN_F4R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F4R1_FB18          CAN_F4R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F4R1_FB19_Pos      (19U)                                           
N#define CAN_F4R1_FB19_Msk      (0x1UL << CAN_F4R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F4R1_FB19          CAN_F4R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F4R1_FB20_Pos      (20U)                                           
N#define CAN_F4R1_FB20_Msk      (0x1UL << CAN_F4R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F4R1_FB20          CAN_F4R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F4R1_FB21_Pos      (21U)                                           
N#define CAN_F4R1_FB21_Msk      (0x1UL << CAN_F4R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F4R1_FB21          CAN_F4R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F4R1_FB22_Pos      (22U)                                           
N#define CAN_F4R1_FB22_Msk      (0x1UL << CAN_F4R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F4R1_FB22          CAN_F4R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F4R1_FB23_Pos      (23U)                                           
N#define CAN_F4R1_FB23_Msk      (0x1UL << CAN_F4R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F4R1_FB23          CAN_F4R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F4R1_FB24_Pos      (24U)                                           
N#define CAN_F4R1_FB24_Msk      (0x1UL << CAN_F4R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F4R1_FB24          CAN_F4R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F4R1_FB25_Pos      (25U)                                           
N#define CAN_F4R1_FB25_Msk      (0x1UL << CAN_F4R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F4R1_FB25          CAN_F4R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F4R1_FB26_Pos      (26U)                                           
N#define CAN_F4R1_FB26_Msk      (0x1UL << CAN_F4R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F4R1_FB26          CAN_F4R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F4R1_FB27_Pos      (27U)                                           
N#define CAN_F4R1_FB27_Msk      (0x1UL << CAN_F4R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F4R1_FB27          CAN_F4R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F4R1_FB28_Pos      (28U)                                           
N#define CAN_F4R1_FB28_Msk      (0x1UL << CAN_F4R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F4R1_FB28          CAN_F4R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F4R1_FB29_Pos      (29U)                                           
N#define CAN_F4R1_FB29_Msk      (0x1UL << CAN_F4R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F4R1_FB29          CAN_F4R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F4R1_FB30_Pos      (30U)                                           
N#define CAN_F4R1_FB30_Msk      (0x1UL << CAN_F4R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F4R1_FB30          CAN_F4R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F4R1_FB31_Pos      (31U)                                           
N#define CAN_F4R1_FB31_Msk      (0x1UL << CAN_F4R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F4R1_FB31          CAN_F4R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R1 register  *******************/
N#define CAN_F5R1_FB0_Pos       (0U)                                            
N#define CAN_F5R1_FB0_Msk       (0x1UL << CAN_F5R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F5R1_FB0           CAN_F5R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F5R1_FB1_Pos       (1U)                                            
N#define CAN_F5R1_FB1_Msk       (0x1UL << CAN_F5R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F5R1_FB1           CAN_F5R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F5R1_FB2_Pos       (2U)                                            
N#define CAN_F5R1_FB2_Msk       (0x1UL << CAN_F5R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F5R1_FB2           CAN_F5R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F5R1_FB3_Pos       (3U)                                            
N#define CAN_F5R1_FB3_Msk       (0x1UL << CAN_F5R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F5R1_FB3           CAN_F5R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F5R1_FB4_Pos       (4U)                                            
N#define CAN_F5R1_FB4_Msk       (0x1UL << CAN_F5R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F5R1_FB4           CAN_F5R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F5R1_FB5_Pos       (5U)                                            
N#define CAN_F5R1_FB5_Msk       (0x1UL << CAN_F5R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F5R1_FB5           CAN_F5R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F5R1_FB6_Pos       (6U)                                            
N#define CAN_F5R1_FB6_Msk       (0x1UL << CAN_F5R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F5R1_FB6           CAN_F5R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F5R1_FB7_Pos       (7U)                                            
N#define CAN_F5R1_FB7_Msk       (0x1UL << CAN_F5R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F5R1_FB7           CAN_F5R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F5R1_FB8_Pos       (8U)                                            
N#define CAN_F5R1_FB8_Msk       (0x1UL << CAN_F5R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F5R1_FB8           CAN_F5R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F5R1_FB9_Pos       (9U)                                            
N#define CAN_F5R1_FB9_Msk       (0x1UL << CAN_F5R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F5R1_FB9           CAN_F5R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F5R1_FB10_Pos      (10U)                                           
N#define CAN_F5R1_FB10_Msk      (0x1UL << CAN_F5R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F5R1_FB10          CAN_F5R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F5R1_FB11_Pos      (11U)                                           
N#define CAN_F5R1_FB11_Msk      (0x1UL << CAN_F5R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F5R1_FB11          CAN_F5R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F5R1_FB12_Pos      (12U)                                           
N#define CAN_F5R1_FB12_Msk      (0x1UL << CAN_F5R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F5R1_FB12          CAN_F5R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F5R1_FB13_Pos      (13U)                                           
N#define CAN_F5R1_FB13_Msk      (0x1UL << CAN_F5R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F5R1_FB13          CAN_F5R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F5R1_FB14_Pos      (14U)                                           
N#define CAN_F5R1_FB14_Msk      (0x1UL << CAN_F5R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F5R1_FB14          CAN_F5R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F5R1_FB15_Pos      (15U)                                           
N#define CAN_F5R1_FB15_Msk      (0x1UL << CAN_F5R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F5R1_FB15          CAN_F5R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F5R1_FB16_Pos      (16U)                                           
N#define CAN_F5R1_FB16_Msk      (0x1UL << CAN_F5R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F5R1_FB16          CAN_F5R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F5R1_FB17_Pos      (17U)                                           
N#define CAN_F5R1_FB17_Msk      (0x1UL << CAN_F5R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F5R1_FB17          CAN_F5R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F5R1_FB18_Pos      (18U)                                           
N#define CAN_F5R1_FB18_Msk      (0x1UL << CAN_F5R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F5R1_FB18          CAN_F5R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F5R1_FB19_Pos      (19U)                                           
N#define CAN_F5R1_FB19_Msk      (0x1UL << CAN_F5R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F5R1_FB19          CAN_F5R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F5R1_FB20_Pos      (20U)                                           
N#define CAN_F5R1_FB20_Msk      (0x1UL << CAN_F5R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F5R1_FB20          CAN_F5R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F5R1_FB21_Pos      (21U)                                           
N#define CAN_F5R1_FB21_Msk      (0x1UL << CAN_F5R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F5R1_FB21          CAN_F5R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F5R1_FB22_Pos      (22U)                                           
N#define CAN_F5R1_FB22_Msk      (0x1UL << CAN_F5R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F5R1_FB22          CAN_F5R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F5R1_FB23_Pos      (23U)                                           
N#define CAN_F5R1_FB23_Msk      (0x1UL << CAN_F5R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F5R1_FB23          CAN_F5R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F5R1_FB24_Pos      (24U)                                           
N#define CAN_F5R1_FB24_Msk      (0x1UL << CAN_F5R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F5R1_FB24          CAN_F5R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F5R1_FB25_Pos      (25U)                                           
N#define CAN_F5R1_FB25_Msk      (0x1UL << CAN_F5R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F5R1_FB25          CAN_F5R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F5R1_FB26_Pos      (26U)                                           
N#define CAN_F5R1_FB26_Msk      (0x1UL << CAN_F5R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F5R1_FB26          CAN_F5R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F5R1_FB27_Pos      (27U)                                           
N#define CAN_F5R1_FB27_Msk      (0x1UL << CAN_F5R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F5R1_FB27          CAN_F5R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F5R1_FB28_Pos      (28U)                                           
N#define CAN_F5R1_FB28_Msk      (0x1UL << CAN_F5R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F5R1_FB28          CAN_F5R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F5R1_FB29_Pos      (29U)                                           
N#define CAN_F5R1_FB29_Msk      (0x1UL << CAN_F5R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F5R1_FB29          CAN_F5R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F5R1_FB30_Pos      (30U)                                           
N#define CAN_F5R1_FB30_Msk      (0x1UL << CAN_F5R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F5R1_FB30          CAN_F5R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F5R1_FB31_Pos      (31U)                                           
N#define CAN_F5R1_FB31_Msk      (0x1UL << CAN_F5R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F5R1_FB31          CAN_F5R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R1 register  *******************/
N#define CAN_F6R1_FB0_Pos       (0U)                                            
N#define CAN_F6R1_FB0_Msk       (0x1UL << CAN_F6R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F6R1_FB0           CAN_F6R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F6R1_FB1_Pos       (1U)                                            
N#define CAN_F6R1_FB1_Msk       (0x1UL << CAN_F6R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F6R1_FB1           CAN_F6R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F6R1_FB2_Pos       (2U)                                            
N#define CAN_F6R1_FB2_Msk       (0x1UL << CAN_F6R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F6R1_FB2           CAN_F6R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F6R1_FB3_Pos       (3U)                                            
N#define CAN_F6R1_FB3_Msk       (0x1UL << CAN_F6R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F6R1_FB3           CAN_F6R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F6R1_FB4_Pos       (4U)                                            
N#define CAN_F6R1_FB4_Msk       (0x1UL << CAN_F6R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F6R1_FB4           CAN_F6R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F6R1_FB5_Pos       (5U)                                            
N#define CAN_F6R1_FB5_Msk       (0x1UL << CAN_F6R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F6R1_FB5           CAN_F6R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F6R1_FB6_Pos       (6U)                                            
N#define CAN_F6R1_FB6_Msk       (0x1UL << CAN_F6R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F6R1_FB6           CAN_F6R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F6R1_FB7_Pos       (7U)                                            
N#define CAN_F6R1_FB7_Msk       (0x1UL << CAN_F6R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F6R1_FB7           CAN_F6R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F6R1_FB8_Pos       (8U)                                            
N#define CAN_F6R1_FB8_Msk       (0x1UL << CAN_F6R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F6R1_FB8           CAN_F6R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F6R1_FB9_Pos       (9U)                                            
N#define CAN_F6R1_FB9_Msk       (0x1UL << CAN_F6R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F6R1_FB9           CAN_F6R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F6R1_FB10_Pos      (10U)                                           
N#define CAN_F6R1_FB10_Msk      (0x1UL << CAN_F6R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F6R1_FB10          CAN_F6R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F6R1_FB11_Pos      (11U)                                           
N#define CAN_F6R1_FB11_Msk      (0x1UL << CAN_F6R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F6R1_FB11          CAN_F6R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F6R1_FB12_Pos      (12U)                                           
N#define CAN_F6R1_FB12_Msk      (0x1UL << CAN_F6R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F6R1_FB12          CAN_F6R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F6R1_FB13_Pos      (13U)                                           
N#define CAN_F6R1_FB13_Msk      (0x1UL << CAN_F6R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F6R1_FB13          CAN_F6R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F6R1_FB14_Pos      (14U)                                           
N#define CAN_F6R1_FB14_Msk      (0x1UL << CAN_F6R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F6R1_FB14          CAN_F6R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F6R1_FB15_Pos      (15U)                                           
N#define CAN_F6R1_FB15_Msk      (0x1UL << CAN_F6R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F6R1_FB15          CAN_F6R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F6R1_FB16_Pos      (16U)                                           
N#define CAN_F6R1_FB16_Msk      (0x1UL << CAN_F6R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F6R1_FB16          CAN_F6R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F6R1_FB17_Pos      (17U)                                           
N#define CAN_F6R1_FB17_Msk      (0x1UL << CAN_F6R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F6R1_FB17          CAN_F6R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F6R1_FB18_Pos      (18U)                                           
N#define CAN_F6R1_FB18_Msk      (0x1UL << CAN_F6R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F6R1_FB18          CAN_F6R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F6R1_FB19_Pos      (19U)                                           
N#define CAN_F6R1_FB19_Msk      (0x1UL << CAN_F6R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F6R1_FB19          CAN_F6R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F6R1_FB20_Pos      (20U)                                           
N#define CAN_F6R1_FB20_Msk      (0x1UL << CAN_F6R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F6R1_FB20          CAN_F6R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F6R1_FB21_Pos      (21U)                                           
N#define CAN_F6R1_FB21_Msk      (0x1UL << CAN_F6R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F6R1_FB21          CAN_F6R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F6R1_FB22_Pos      (22U)                                           
N#define CAN_F6R1_FB22_Msk      (0x1UL << CAN_F6R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F6R1_FB22          CAN_F6R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F6R1_FB23_Pos      (23U)                                           
N#define CAN_F6R1_FB23_Msk      (0x1UL << CAN_F6R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F6R1_FB23          CAN_F6R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F6R1_FB24_Pos      (24U)                                           
N#define CAN_F6R1_FB24_Msk      (0x1UL << CAN_F6R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F6R1_FB24          CAN_F6R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F6R1_FB25_Pos      (25U)                                           
N#define CAN_F6R1_FB25_Msk      (0x1UL << CAN_F6R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F6R1_FB25          CAN_F6R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F6R1_FB26_Pos      (26U)                                           
N#define CAN_F6R1_FB26_Msk      (0x1UL << CAN_F6R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F6R1_FB26          CAN_F6R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F6R1_FB27_Pos      (27U)                                           
N#define CAN_F6R1_FB27_Msk      (0x1UL << CAN_F6R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F6R1_FB27          CAN_F6R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F6R1_FB28_Pos      (28U)                                           
N#define CAN_F6R1_FB28_Msk      (0x1UL << CAN_F6R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F6R1_FB28          CAN_F6R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F6R1_FB29_Pos      (29U)                                           
N#define CAN_F6R1_FB29_Msk      (0x1UL << CAN_F6R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F6R1_FB29          CAN_F6R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F6R1_FB30_Pos      (30U)                                           
N#define CAN_F6R1_FB30_Msk      (0x1UL << CAN_F6R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F6R1_FB30          CAN_F6R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F6R1_FB31_Pos      (31U)                                           
N#define CAN_F6R1_FB31_Msk      (0x1UL << CAN_F6R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F6R1_FB31          CAN_F6R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R1 register  *******************/
N#define CAN_F7R1_FB0_Pos       (0U)                                            
N#define CAN_F7R1_FB0_Msk       (0x1UL << CAN_F7R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F7R1_FB0           CAN_F7R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F7R1_FB1_Pos       (1U)                                            
N#define CAN_F7R1_FB1_Msk       (0x1UL << CAN_F7R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F7R1_FB1           CAN_F7R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F7R1_FB2_Pos       (2U)                                            
N#define CAN_F7R1_FB2_Msk       (0x1UL << CAN_F7R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F7R1_FB2           CAN_F7R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F7R1_FB3_Pos       (3U)                                            
N#define CAN_F7R1_FB3_Msk       (0x1UL << CAN_F7R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F7R1_FB3           CAN_F7R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F7R1_FB4_Pos       (4U)                                            
N#define CAN_F7R1_FB4_Msk       (0x1UL << CAN_F7R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F7R1_FB4           CAN_F7R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F7R1_FB5_Pos       (5U)                                            
N#define CAN_F7R1_FB5_Msk       (0x1UL << CAN_F7R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F7R1_FB5           CAN_F7R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F7R1_FB6_Pos       (6U)                                            
N#define CAN_F7R1_FB6_Msk       (0x1UL << CAN_F7R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F7R1_FB6           CAN_F7R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F7R1_FB7_Pos       (7U)                                            
N#define CAN_F7R1_FB7_Msk       (0x1UL << CAN_F7R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F7R1_FB7           CAN_F7R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F7R1_FB8_Pos       (8U)                                            
N#define CAN_F7R1_FB8_Msk       (0x1UL << CAN_F7R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F7R1_FB8           CAN_F7R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F7R1_FB9_Pos       (9U)                                            
N#define CAN_F7R1_FB9_Msk       (0x1UL << CAN_F7R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F7R1_FB9           CAN_F7R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F7R1_FB10_Pos      (10U)                                           
N#define CAN_F7R1_FB10_Msk      (0x1UL << CAN_F7R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F7R1_FB10          CAN_F7R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F7R1_FB11_Pos      (11U)                                           
N#define CAN_F7R1_FB11_Msk      (0x1UL << CAN_F7R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F7R1_FB11          CAN_F7R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F7R1_FB12_Pos      (12U)                                           
N#define CAN_F7R1_FB12_Msk      (0x1UL << CAN_F7R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F7R1_FB12          CAN_F7R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F7R1_FB13_Pos      (13U)                                           
N#define CAN_F7R1_FB13_Msk      (0x1UL << CAN_F7R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F7R1_FB13          CAN_F7R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F7R1_FB14_Pos      (14U)                                           
N#define CAN_F7R1_FB14_Msk      (0x1UL << CAN_F7R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F7R1_FB14          CAN_F7R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F7R1_FB15_Pos      (15U)                                           
N#define CAN_F7R1_FB15_Msk      (0x1UL << CAN_F7R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F7R1_FB15          CAN_F7R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F7R1_FB16_Pos      (16U)                                           
N#define CAN_F7R1_FB16_Msk      (0x1UL << CAN_F7R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F7R1_FB16          CAN_F7R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F7R1_FB17_Pos      (17U)                                           
N#define CAN_F7R1_FB17_Msk      (0x1UL << CAN_F7R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F7R1_FB17          CAN_F7R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F7R1_FB18_Pos      (18U)                                           
N#define CAN_F7R1_FB18_Msk      (0x1UL << CAN_F7R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F7R1_FB18          CAN_F7R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F7R1_FB19_Pos      (19U)                                           
N#define CAN_F7R1_FB19_Msk      (0x1UL << CAN_F7R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F7R1_FB19          CAN_F7R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F7R1_FB20_Pos      (20U)                                           
N#define CAN_F7R1_FB20_Msk      (0x1UL << CAN_F7R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F7R1_FB20          CAN_F7R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F7R1_FB21_Pos      (21U)                                           
N#define CAN_F7R1_FB21_Msk      (0x1UL << CAN_F7R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F7R1_FB21          CAN_F7R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F7R1_FB22_Pos      (22U)                                           
N#define CAN_F7R1_FB22_Msk      (0x1UL << CAN_F7R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F7R1_FB22          CAN_F7R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F7R1_FB23_Pos      (23U)                                           
N#define CAN_F7R1_FB23_Msk      (0x1UL << CAN_F7R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F7R1_FB23          CAN_F7R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F7R1_FB24_Pos      (24U)                                           
N#define CAN_F7R1_FB24_Msk      (0x1UL << CAN_F7R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F7R1_FB24          CAN_F7R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F7R1_FB25_Pos      (25U)                                           
N#define CAN_F7R1_FB25_Msk      (0x1UL << CAN_F7R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F7R1_FB25          CAN_F7R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F7R1_FB26_Pos      (26U)                                           
N#define CAN_F7R1_FB26_Msk      (0x1UL << CAN_F7R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F7R1_FB26          CAN_F7R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F7R1_FB27_Pos      (27U)                                           
N#define CAN_F7R1_FB27_Msk      (0x1UL << CAN_F7R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F7R1_FB27          CAN_F7R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F7R1_FB28_Pos      (28U)                                           
N#define CAN_F7R1_FB28_Msk      (0x1UL << CAN_F7R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F7R1_FB28          CAN_F7R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F7R1_FB29_Pos      (29U)                                           
N#define CAN_F7R1_FB29_Msk      (0x1UL << CAN_F7R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F7R1_FB29          CAN_F7R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F7R1_FB30_Pos      (30U)                                           
N#define CAN_F7R1_FB30_Msk      (0x1UL << CAN_F7R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F7R1_FB30          CAN_F7R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F7R1_FB31_Pos      (31U)                                           
N#define CAN_F7R1_FB31_Msk      (0x1UL << CAN_F7R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F7R1_FB31          CAN_F7R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R1 register  *******************/
N#define CAN_F8R1_FB0_Pos       (0U)                                            
N#define CAN_F8R1_FB0_Msk       (0x1UL << CAN_F8R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F8R1_FB0           CAN_F8R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F8R1_FB1_Pos       (1U)                                            
N#define CAN_F8R1_FB1_Msk       (0x1UL << CAN_F8R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F8R1_FB1           CAN_F8R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F8R1_FB2_Pos       (2U)                                            
N#define CAN_F8R1_FB2_Msk       (0x1UL << CAN_F8R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F8R1_FB2           CAN_F8R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F8R1_FB3_Pos       (3U)                                            
N#define CAN_F8R1_FB3_Msk       (0x1UL << CAN_F8R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F8R1_FB3           CAN_F8R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F8R1_FB4_Pos       (4U)                                            
N#define CAN_F8R1_FB4_Msk       (0x1UL << CAN_F8R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F8R1_FB4           CAN_F8R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F8R1_FB5_Pos       (5U)                                            
N#define CAN_F8R1_FB5_Msk       (0x1UL << CAN_F8R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F8R1_FB5           CAN_F8R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F8R1_FB6_Pos       (6U)                                            
N#define CAN_F8R1_FB6_Msk       (0x1UL << CAN_F8R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F8R1_FB6           CAN_F8R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F8R1_FB7_Pos       (7U)                                            
N#define CAN_F8R1_FB7_Msk       (0x1UL << CAN_F8R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F8R1_FB7           CAN_F8R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F8R1_FB8_Pos       (8U)                                            
N#define CAN_F8R1_FB8_Msk       (0x1UL << CAN_F8R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F8R1_FB8           CAN_F8R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F8R1_FB9_Pos       (9U)                                            
N#define CAN_F8R1_FB9_Msk       (0x1UL << CAN_F8R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F8R1_FB9           CAN_F8R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F8R1_FB10_Pos      (10U)                                           
N#define CAN_F8R1_FB10_Msk      (0x1UL << CAN_F8R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F8R1_FB10          CAN_F8R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F8R1_FB11_Pos      (11U)                                           
N#define CAN_F8R1_FB11_Msk      (0x1UL << CAN_F8R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F8R1_FB11          CAN_F8R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F8R1_FB12_Pos      (12U)                                           
N#define CAN_F8R1_FB12_Msk      (0x1UL << CAN_F8R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F8R1_FB12          CAN_F8R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F8R1_FB13_Pos      (13U)                                           
N#define CAN_F8R1_FB13_Msk      (0x1UL << CAN_F8R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F8R1_FB13          CAN_F8R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F8R1_FB14_Pos      (14U)                                           
N#define CAN_F8R1_FB14_Msk      (0x1UL << CAN_F8R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F8R1_FB14          CAN_F8R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F8R1_FB15_Pos      (15U)                                           
N#define CAN_F8R1_FB15_Msk      (0x1UL << CAN_F8R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F8R1_FB15          CAN_F8R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F8R1_FB16_Pos      (16U)                                           
N#define CAN_F8R1_FB16_Msk      (0x1UL << CAN_F8R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F8R1_FB16          CAN_F8R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F8R1_FB17_Pos      (17U)                                           
N#define CAN_F8R1_FB17_Msk      (0x1UL << CAN_F8R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F8R1_FB17          CAN_F8R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F8R1_FB18_Pos      (18U)                                           
N#define CAN_F8R1_FB18_Msk      (0x1UL << CAN_F8R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F8R1_FB18          CAN_F8R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F8R1_FB19_Pos      (19U)                                           
N#define CAN_F8R1_FB19_Msk      (0x1UL << CAN_F8R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F8R1_FB19          CAN_F8R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F8R1_FB20_Pos      (20U)                                           
N#define CAN_F8R1_FB20_Msk      (0x1UL << CAN_F8R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F8R1_FB20          CAN_F8R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F8R1_FB21_Pos      (21U)                                           
N#define CAN_F8R1_FB21_Msk      (0x1UL << CAN_F8R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F8R1_FB21          CAN_F8R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F8R1_FB22_Pos      (22U)                                           
N#define CAN_F8R1_FB22_Msk      (0x1UL << CAN_F8R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F8R1_FB22          CAN_F8R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F8R1_FB23_Pos      (23U)                                           
N#define CAN_F8R1_FB23_Msk      (0x1UL << CAN_F8R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F8R1_FB23          CAN_F8R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F8R1_FB24_Pos      (24U)                                           
N#define CAN_F8R1_FB24_Msk      (0x1UL << CAN_F8R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F8R1_FB24          CAN_F8R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F8R1_FB25_Pos      (25U)                                           
N#define CAN_F8R1_FB25_Msk      (0x1UL << CAN_F8R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F8R1_FB25          CAN_F8R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F8R1_FB26_Pos      (26U)                                           
N#define CAN_F8R1_FB26_Msk      (0x1UL << CAN_F8R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F8R1_FB26          CAN_F8R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F8R1_FB27_Pos      (27U)                                           
N#define CAN_F8R1_FB27_Msk      (0x1UL << CAN_F8R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F8R1_FB27          CAN_F8R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F8R1_FB28_Pos      (28U)                                           
N#define CAN_F8R1_FB28_Msk      (0x1UL << CAN_F8R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F8R1_FB28          CAN_F8R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F8R1_FB29_Pos      (29U)                                           
N#define CAN_F8R1_FB29_Msk      (0x1UL << CAN_F8R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F8R1_FB29          CAN_F8R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F8R1_FB30_Pos      (30U)                                           
N#define CAN_F8R1_FB30_Msk      (0x1UL << CAN_F8R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F8R1_FB30          CAN_F8R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F8R1_FB31_Pos      (31U)                                           
N#define CAN_F8R1_FB31_Msk      (0x1UL << CAN_F8R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F8R1_FB31          CAN_F8R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R1 register  *******************/
N#define CAN_F9R1_FB0_Pos       (0U)                                            
N#define CAN_F9R1_FB0_Msk       (0x1UL << CAN_F9R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F9R1_FB0           CAN_F9R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F9R1_FB1_Pos       (1U)                                            
N#define CAN_F9R1_FB1_Msk       (0x1UL << CAN_F9R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F9R1_FB1           CAN_F9R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F9R1_FB2_Pos       (2U)                                            
N#define CAN_F9R1_FB2_Msk       (0x1UL << CAN_F9R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F9R1_FB2           CAN_F9R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F9R1_FB3_Pos       (3U)                                            
N#define CAN_F9R1_FB3_Msk       (0x1UL << CAN_F9R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F9R1_FB3           CAN_F9R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F9R1_FB4_Pos       (4U)                                            
N#define CAN_F9R1_FB4_Msk       (0x1UL << CAN_F9R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F9R1_FB4           CAN_F9R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F9R1_FB5_Pos       (5U)                                            
N#define CAN_F9R1_FB5_Msk       (0x1UL << CAN_F9R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F9R1_FB5           CAN_F9R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F9R1_FB6_Pos       (6U)                                            
N#define CAN_F9R1_FB6_Msk       (0x1UL << CAN_F9R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F9R1_FB6           CAN_F9R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F9R1_FB7_Pos       (7U)                                            
N#define CAN_F9R1_FB7_Msk       (0x1UL << CAN_F9R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F9R1_FB7           CAN_F9R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F9R1_FB8_Pos       (8U)                                            
N#define CAN_F9R1_FB8_Msk       (0x1UL << CAN_F9R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F9R1_FB8           CAN_F9R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F9R1_FB9_Pos       (9U)                                            
N#define CAN_F9R1_FB9_Msk       (0x1UL << CAN_F9R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F9R1_FB9           CAN_F9R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F9R1_FB10_Pos      (10U)                                           
N#define CAN_F9R1_FB10_Msk      (0x1UL << CAN_F9R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F9R1_FB10          CAN_F9R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F9R1_FB11_Pos      (11U)                                           
N#define CAN_F9R1_FB11_Msk      (0x1UL << CAN_F9R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F9R1_FB11          CAN_F9R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F9R1_FB12_Pos      (12U)                                           
N#define CAN_F9R1_FB12_Msk      (0x1UL << CAN_F9R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F9R1_FB12          CAN_F9R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F9R1_FB13_Pos      (13U)                                           
N#define CAN_F9R1_FB13_Msk      (0x1UL << CAN_F9R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F9R1_FB13          CAN_F9R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F9R1_FB14_Pos      (14U)                                           
N#define CAN_F9R1_FB14_Msk      (0x1UL << CAN_F9R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F9R1_FB14          CAN_F9R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F9R1_FB15_Pos      (15U)                                           
N#define CAN_F9R1_FB15_Msk      (0x1UL << CAN_F9R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F9R1_FB15          CAN_F9R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F9R1_FB16_Pos      (16U)                                           
N#define CAN_F9R1_FB16_Msk      (0x1UL << CAN_F9R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F9R1_FB16          CAN_F9R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F9R1_FB17_Pos      (17U)                                           
N#define CAN_F9R1_FB17_Msk      (0x1UL << CAN_F9R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F9R1_FB17          CAN_F9R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F9R1_FB18_Pos      (18U)                                           
N#define CAN_F9R1_FB18_Msk      (0x1UL << CAN_F9R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F9R1_FB18          CAN_F9R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F9R1_FB19_Pos      (19U)                                           
N#define CAN_F9R1_FB19_Msk      (0x1UL << CAN_F9R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F9R1_FB19          CAN_F9R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F9R1_FB20_Pos      (20U)                                           
N#define CAN_F9R1_FB20_Msk      (0x1UL << CAN_F9R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F9R1_FB20          CAN_F9R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F9R1_FB21_Pos      (21U)                                           
N#define CAN_F9R1_FB21_Msk      (0x1UL << CAN_F9R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F9R1_FB21          CAN_F9R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F9R1_FB22_Pos      (22U)                                           
N#define CAN_F9R1_FB22_Msk      (0x1UL << CAN_F9R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F9R1_FB22          CAN_F9R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F9R1_FB23_Pos      (23U)                                           
N#define CAN_F9R1_FB23_Msk      (0x1UL << CAN_F9R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F9R1_FB23          CAN_F9R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F9R1_FB24_Pos      (24U)                                           
N#define CAN_F9R1_FB24_Msk      (0x1UL << CAN_F9R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F9R1_FB24          CAN_F9R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F9R1_FB25_Pos      (25U)                                           
N#define CAN_F9R1_FB25_Msk      (0x1UL << CAN_F9R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F9R1_FB25          CAN_F9R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F9R1_FB26_Pos      (26U)                                           
N#define CAN_F9R1_FB26_Msk      (0x1UL << CAN_F9R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F9R1_FB26          CAN_F9R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F9R1_FB27_Pos      (27U)                                           
N#define CAN_F9R1_FB27_Msk      (0x1UL << CAN_F9R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F9R1_FB27          CAN_F9R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F9R1_FB28_Pos      (28U)                                           
N#define CAN_F9R1_FB28_Msk      (0x1UL << CAN_F9R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F9R1_FB28          CAN_F9R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F9R1_FB29_Pos      (29U)                                           
N#define CAN_F9R1_FB29_Msk      (0x1UL << CAN_F9R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F9R1_FB29          CAN_F9R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F9R1_FB30_Pos      (30U)                                           
N#define CAN_F9R1_FB30_Msk      (0x1UL << CAN_F9R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F9R1_FB30          CAN_F9R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F9R1_FB31_Pos      (31U)                                           
N#define CAN_F9R1_FB31_Msk      (0x1UL << CAN_F9R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F9R1_FB31          CAN_F9R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R1 register  ******************/
N#define CAN_F10R1_FB0_Pos      (0U)                                            
N#define CAN_F10R1_FB0_Msk      (0x1UL << CAN_F10R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F10R1_FB0          CAN_F10R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F10R1_FB1_Pos      (1U)                                            
N#define CAN_F10R1_FB1_Msk      (0x1UL << CAN_F10R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F10R1_FB1          CAN_F10R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F10R1_FB2_Pos      (2U)                                            
N#define CAN_F10R1_FB2_Msk      (0x1UL << CAN_F10R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F10R1_FB2          CAN_F10R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F10R1_FB3_Pos      (3U)                                            
N#define CAN_F10R1_FB3_Msk      (0x1UL << CAN_F10R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F10R1_FB3          CAN_F10R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F10R1_FB4_Pos      (4U)                                            
N#define CAN_F10R1_FB4_Msk      (0x1UL << CAN_F10R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F10R1_FB4          CAN_F10R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F10R1_FB5_Pos      (5U)                                            
N#define CAN_F10R1_FB5_Msk      (0x1UL << CAN_F10R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F10R1_FB5          CAN_F10R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F10R1_FB6_Pos      (6U)                                            
N#define CAN_F10R1_FB6_Msk      (0x1UL << CAN_F10R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F10R1_FB6          CAN_F10R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F10R1_FB7_Pos      (7U)                                            
N#define CAN_F10R1_FB7_Msk      (0x1UL << CAN_F10R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F10R1_FB7          CAN_F10R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F10R1_FB8_Pos      (8U)                                            
N#define CAN_F10R1_FB8_Msk      (0x1UL << CAN_F10R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F10R1_FB8          CAN_F10R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F10R1_FB9_Pos      (9U)                                            
N#define CAN_F10R1_FB9_Msk      (0x1UL << CAN_F10R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F10R1_FB9          CAN_F10R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F10R1_FB10_Pos     (10U)                                           
N#define CAN_F10R1_FB10_Msk     (0x1UL << CAN_F10R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F10R1_FB10         CAN_F10R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F10R1_FB11_Pos     (11U)                                           
N#define CAN_F10R1_FB11_Msk     (0x1UL << CAN_F10R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F10R1_FB11         CAN_F10R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F10R1_FB12_Pos     (12U)                                           
N#define CAN_F10R1_FB12_Msk     (0x1UL << CAN_F10R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F10R1_FB12         CAN_F10R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F10R1_FB13_Pos     (13U)                                           
N#define CAN_F10R1_FB13_Msk     (0x1UL << CAN_F10R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F10R1_FB13         CAN_F10R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F10R1_FB14_Pos     (14U)                                           
N#define CAN_F10R1_FB14_Msk     (0x1UL << CAN_F10R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F10R1_FB14         CAN_F10R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F10R1_FB15_Pos     (15U)                                           
N#define CAN_F10R1_FB15_Msk     (0x1UL << CAN_F10R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F10R1_FB15         CAN_F10R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F10R1_FB16_Pos     (16U)                                           
N#define CAN_F10R1_FB16_Msk     (0x1UL << CAN_F10R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F10R1_FB16         CAN_F10R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F10R1_FB17_Pos     (17U)                                           
N#define CAN_F10R1_FB17_Msk     (0x1UL << CAN_F10R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F10R1_FB17         CAN_F10R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F10R1_FB18_Pos     (18U)                                           
N#define CAN_F10R1_FB18_Msk     (0x1UL << CAN_F10R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F10R1_FB18         CAN_F10R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F10R1_FB19_Pos     (19U)                                           
N#define CAN_F10R1_FB19_Msk     (0x1UL << CAN_F10R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F10R1_FB19         CAN_F10R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F10R1_FB20_Pos     (20U)                                           
N#define CAN_F10R1_FB20_Msk     (0x1UL << CAN_F10R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F10R1_FB20         CAN_F10R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F10R1_FB21_Pos     (21U)                                           
N#define CAN_F10R1_FB21_Msk     (0x1UL << CAN_F10R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F10R1_FB21         CAN_F10R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F10R1_FB22_Pos     (22U)                                           
N#define CAN_F10R1_FB22_Msk     (0x1UL << CAN_F10R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F10R1_FB22         CAN_F10R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F10R1_FB23_Pos     (23U)                                           
N#define CAN_F10R1_FB23_Msk     (0x1UL << CAN_F10R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F10R1_FB23         CAN_F10R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F10R1_FB24_Pos     (24U)                                           
N#define CAN_F10R1_FB24_Msk     (0x1UL << CAN_F10R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F10R1_FB24         CAN_F10R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F10R1_FB25_Pos     (25U)                                           
N#define CAN_F10R1_FB25_Msk     (0x1UL << CAN_F10R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F10R1_FB25         CAN_F10R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F10R1_FB26_Pos     (26U)                                           
N#define CAN_F10R1_FB26_Msk     (0x1UL << CAN_F10R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F10R1_FB26         CAN_F10R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F10R1_FB27_Pos     (27U)                                           
N#define CAN_F10R1_FB27_Msk     (0x1UL << CAN_F10R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F10R1_FB27         CAN_F10R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F10R1_FB28_Pos     (28U)                                           
N#define CAN_F10R1_FB28_Msk     (0x1UL << CAN_F10R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F10R1_FB28         CAN_F10R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F10R1_FB29_Pos     (29U)                                           
N#define CAN_F10R1_FB29_Msk     (0x1UL << CAN_F10R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F10R1_FB29         CAN_F10R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F10R1_FB30_Pos     (30U)                                           
N#define CAN_F10R1_FB30_Msk     (0x1UL << CAN_F10R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F10R1_FB30         CAN_F10R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F10R1_FB31_Pos     (31U)                                           
N#define CAN_F10R1_FB31_Msk     (0x1UL << CAN_F10R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F10R1_FB31         CAN_F10R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R1 register  ******************/
N#define CAN_F11R1_FB0_Pos      (0U)                                            
N#define CAN_F11R1_FB0_Msk      (0x1UL << CAN_F11R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F11R1_FB0          CAN_F11R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F11R1_FB1_Pos      (1U)                                            
N#define CAN_F11R1_FB1_Msk      (0x1UL << CAN_F11R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F11R1_FB1          CAN_F11R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F11R1_FB2_Pos      (2U)                                            
N#define CAN_F11R1_FB2_Msk      (0x1UL << CAN_F11R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F11R1_FB2          CAN_F11R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F11R1_FB3_Pos      (3U)                                            
N#define CAN_F11R1_FB3_Msk      (0x1UL << CAN_F11R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F11R1_FB3          CAN_F11R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F11R1_FB4_Pos      (4U)                                            
N#define CAN_F11R1_FB4_Msk      (0x1UL << CAN_F11R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F11R1_FB4          CAN_F11R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F11R1_FB5_Pos      (5U)                                            
N#define CAN_F11R1_FB5_Msk      (0x1UL << CAN_F11R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F11R1_FB5          CAN_F11R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F11R1_FB6_Pos      (6U)                                            
N#define CAN_F11R1_FB6_Msk      (0x1UL << CAN_F11R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F11R1_FB6          CAN_F11R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F11R1_FB7_Pos      (7U)                                            
N#define CAN_F11R1_FB7_Msk      (0x1UL << CAN_F11R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F11R1_FB7          CAN_F11R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F11R1_FB8_Pos      (8U)                                            
N#define CAN_F11R1_FB8_Msk      (0x1UL << CAN_F11R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F11R1_FB8          CAN_F11R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F11R1_FB9_Pos      (9U)                                            
N#define CAN_F11R1_FB9_Msk      (0x1UL << CAN_F11R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F11R1_FB9          CAN_F11R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F11R1_FB10_Pos     (10U)                                           
N#define CAN_F11R1_FB10_Msk     (0x1UL << CAN_F11R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F11R1_FB10         CAN_F11R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F11R1_FB11_Pos     (11U)                                           
N#define CAN_F11R1_FB11_Msk     (0x1UL << CAN_F11R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F11R1_FB11         CAN_F11R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F11R1_FB12_Pos     (12U)                                           
N#define CAN_F11R1_FB12_Msk     (0x1UL << CAN_F11R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F11R1_FB12         CAN_F11R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F11R1_FB13_Pos     (13U)                                           
N#define CAN_F11R1_FB13_Msk     (0x1UL << CAN_F11R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F11R1_FB13         CAN_F11R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F11R1_FB14_Pos     (14U)                                           
N#define CAN_F11R1_FB14_Msk     (0x1UL << CAN_F11R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F11R1_FB14         CAN_F11R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F11R1_FB15_Pos     (15U)                                           
N#define CAN_F11R1_FB15_Msk     (0x1UL << CAN_F11R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F11R1_FB15         CAN_F11R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F11R1_FB16_Pos     (16U)                                           
N#define CAN_F11R1_FB16_Msk     (0x1UL << CAN_F11R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F11R1_FB16         CAN_F11R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F11R1_FB17_Pos     (17U)                                           
N#define CAN_F11R1_FB17_Msk     (0x1UL << CAN_F11R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F11R1_FB17         CAN_F11R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F11R1_FB18_Pos     (18U)                                           
N#define CAN_F11R1_FB18_Msk     (0x1UL << CAN_F11R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F11R1_FB18         CAN_F11R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F11R1_FB19_Pos     (19U)                                           
N#define CAN_F11R1_FB19_Msk     (0x1UL << CAN_F11R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F11R1_FB19         CAN_F11R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F11R1_FB20_Pos     (20U)                                           
N#define CAN_F11R1_FB20_Msk     (0x1UL << CAN_F11R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F11R1_FB20         CAN_F11R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F11R1_FB21_Pos     (21U)                                           
N#define CAN_F11R1_FB21_Msk     (0x1UL << CAN_F11R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F11R1_FB21         CAN_F11R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F11R1_FB22_Pos     (22U)                                           
N#define CAN_F11R1_FB22_Msk     (0x1UL << CAN_F11R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F11R1_FB22         CAN_F11R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F11R1_FB23_Pos     (23U)                                           
N#define CAN_F11R1_FB23_Msk     (0x1UL << CAN_F11R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F11R1_FB23         CAN_F11R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F11R1_FB24_Pos     (24U)                                           
N#define CAN_F11R1_FB24_Msk     (0x1UL << CAN_F11R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F11R1_FB24         CAN_F11R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F11R1_FB25_Pos     (25U)                                           
N#define CAN_F11R1_FB25_Msk     (0x1UL << CAN_F11R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F11R1_FB25         CAN_F11R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F11R1_FB26_Pos     (26U)                                           
N#define CAN_F11R1_FB26_Msk     (0x1UL << CAN_F11R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F11R1_FB26         CAN_F11R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F11R1_FB27_Pos     (27U)                                           
N#define CAN_F11R1_FB27_Msk     (0x1UL << CAN_F11R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F11R1_FB27         CAN_F11R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F11R1_FB28_Pos     (28U)                                           
N#define CAN_F11R1_FB28_Msk     (0x1UL << CAN_F11R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F11R1_FB28         CAN_F11R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F11R1_FB29_Pos     (29U)                                           
N#define CAN_F11R1_FB29_Msk     (0x1UL << CAN_F11R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F11R1_FB29         CAN_F11R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F11R1_FB30_Pos     (30U)                                           
N#define CAN_F11R1_FB30_Msk     (0x1UL << CAN_F11R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F11R1_FB30         CAN_F11R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F11R1_FB31_Pos     (31U)                                           
N#define CAN_F11R1_FB31_Msk     (0x1UL << CAN_F11R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F11R1_FB31         CAN_F11R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R1 register  ******************/
N#define CAN_F12R1_FB0_Pos      (0U)                                            
N#define CAN_F12R1_FB0_Msk      (0x1UL << CAN_F12R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F12R1_FB0          CAN_F12R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F12R1_FB1_Pos      (1U)                                            
N#define CAN_F12R1_FB1_Msk      (0x1UL << CAN_F12R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F12R1_FB1          CAN_F12R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F12R1_FB2_Pos      (2U)                                            
N#define CAN_F12R1_FB2_Msk      (0x1UL << CAN_F12R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F12R1_FB2          CAN_F12R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F12R1_FB3_Pos      (3U)                                            
N#define CAN_F12R1_FB3_Msk      (0x1UL << CAN_F12R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F12R1_FB3          CAN_F12R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F12R1_FB4_Pos      (4U)                                            
N#define CAN_F12R1_FB4_Msk      (0x1UL << CAN_F12R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F12R1_FB4          CAN_F12R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F12R1_FB5_Pos      (5U)                                            
N#define CAN_F12R1_FB5_Msk      (0x1UL << CAN_F12R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F12R1_FB5          CAN_F12R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F12R1_FB6_Pos      (6U)                                            
N#define CAN_F12R1_FB6_Msk      (0x1UL << CAN_F12R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F12R1_FB6          CAN_F12R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F12R1_FB7_Pos      (7U)                                            
N#define CAN_F12R1_FB7_Msk      (0x1UL << CAN_F12R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F12R1_FB7          CAN_F12R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F12R1_FB8_Pos      (8U)                                            
N#define CAN_F12R1_FB8_Msk      (0x1UL << CAN_F12R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F12R1_FB8          CAN_F12R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F12R1_FB9_Pos      (9U)                                            
N#define CAN_F12R1_FB9_Msk      (0x1UL << CAN_F12R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F12R1_FB9          CAN_F12R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F12R1_FB10_Pos     (10U)                                           
N#define CAN_F12R1_FB10_Msk     (0x1UL << CAN_F12R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F12R1_FB10         CAN_F12R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F12R1_FB11_Pos     (11U)                                           
N#define CAN_F12R1_FB11_Msk     (0x1UL << CAN_F12R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F12R1_FB11         CAN_F12R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F12R1_FB12_Pos     (12U)                                           
N#define CAN_F12R1_FB12_Msk     (0x1UL << CAN_F12R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F12R1_FB12         CAN_F12R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F12R1_FB13_Pos     (13U)                                           
N#define CAN_F12R1_FB13_Msk     (0x1UL << CAN_F12R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F12R1_FB13         CAN_F12R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F12R1_FB14_Pos     (14U)                                           
N#define CAN_F12R1_FB14_Msk     (0x1UL << CAN_F12R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F12R1_FB14         CAN_F12R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F12R1_FB15_Pos     (15U)                                           
N#define CAN_F12R1_FB15_Msk     (0x1UL << CAN_F12R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F12R1_FB15         CAN_F12R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F12R1_FB16_Pos     (16U)                                           
N#define CAN_F12R1_FB16_Msk     (0x1UL << CAN_F12R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F12R1_FB16         CAN_F12R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F12R1_FB17_Pos     (17U)                                           
N#define CAN_F12R1_FB17_Msk     (0x1UL << CAN_F12R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F12R1_FB17         CAN_F12R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F12R1_FB18_Pos     (18U)                                           
N#define CAN_F12R1_FB18_Msk     (0x1UL << CAN_F12R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F12R1_FB18         CAN_F12R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F12R1_FB19_Pos     (19U)                                           
N#define CAN_F12R1_FB19_Msk     (0x1UL << CAN_F12R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F12R1_FB19         CAN_F12R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F12R1_FB20_Pos     (20U)                                           
N#define CAN_F12R1_FB20_Msk     (0x1UL << CAN_F12R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F12R1_FB20         CAN_F12R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F12R1_FB21_Pos     (21U)                                           
N#define CAN_F12R1_FB21_Msk     (0x1UL << CAN_F12R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F12R1_FB21         CAN_F12R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F12R1_FB22_Pos     (22U)                                           
N#define CAN_F12R1_FB22_Msk     (0x1UL << CAN_F12R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F12R1_FB22         CAN_F12R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F12R1_FB23_Pos     (23U)                                           
N#define CAN_F12R1_FB23_Msk     (0x1UL << CAN_F12R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F12R1_FB23         CAN_F12R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F12R1_FB24_Pos     (24U)                                           
N#define CAN_F12R1_FB24_Msk     (0x1UL << CAN_F12R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F12R1_FB24         CAN_F12R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F12R1_FB25_Pos     (25U)                                           
N#define CAN_F12R1_FB25_Msk     (0x1UL << CAN_F12R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F12R1_FB25         CAN_F12R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F12R1_FB26_Pos     (26U)                                           
N#define CAN_F12R1_FB26_Msk     (0x1UL << CAN_F12R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F12R1_FB26         CAN_F12R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F12R1_FB27_Pos     (27U)                                           
N#define CAN_F12R1_FB27_Msk     (0x1UL << CAN_F12R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F12R1_FB27         CAN_F12R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F12R1_FB28_Pos     (28U)                                           
N#define CAN_F12R1_FB28_Msk     (0x1UL << CAN_F12R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F12R1_FB28         CAN_F12R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F12R1_FB29_Pos     (29U)                                           
N#define CAN_F12R1_FB29_Msk     (0x1UL << CAN_F12R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F12R1_FB29         CAN_F12R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F12R1_FB30_Pos     (30U)                                           
N#define CAN_F12R1_FB30_Msk     (0x1UL << CAN_F12R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F12R1_FB30         CAN_F12R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F12R1_FB31_Pos     (31U)                                           
N#define CAN_F12R1_FB31_Msk     (0x1UL << CAN_F12R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F12R1_FB31         CAN_F12R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R1 register  ******************/
N#define CAN_F13R1_FB0_Pos      (0U)                                            
N#define CAN_F13R1_FB0_Msk      (0x1UL << CAN_F13R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F13R1_FB0          CAN_F13R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F13R1_FB1_Pos      (1U)                                            
N#define CAN_F13R1_FB1_Msk      (0x1UL << CAN_F13R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F13R1_FB1          CAN_F13R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F13R1_FB2_Pos      (2U)                                            
N#define CAN_F13R1_FB2_Msk      (0x1UL << CAN_F13R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F13R1_FB2          CAN_F13R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F13R1_FB3_Pos      (3U)                                            
N#define CAN_F13R1_FB3_Msk      (0x1UL << CAN_F13R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F13R1_FB3          CAN_F13R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F13R1_FB4_Pos      (4U)                                            
N#define CAN_F13R1_FB4_Msk      (0x1UL << CAN_F13R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F13R1_FB4          CAN_F13R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F13R1_FB5_Pos      (5U)                                            
N#define CAN_F13R1_FB5_Msk      (0x1UL << CAN_F13R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F13R1_FB5          CAN_F13R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F13R1_FB6_Pos      (6U)                                            
N#define CAN_F13R1_FB6_Msk      (0x1UL << CAN_F13R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F13R1_FB6          CAN_F13R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F13R1_FB7_Pos      (7U)                                            
N#define CAN_F13R1_FB7_Msk      (0x1UL << CAN_F13R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F13R1_FB7          CAN_F13R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F13R1_FB8_Pos      (8U)                                            
N#define CAN_F13R1_FB8_Msk      (0x1UL << CAN_F13R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F13R1_FB8          CAN_F13R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F13R1_FB9_Pos      (9U)                                            
N#define CAN_F13R1_FB9_Msk      (0x1UL << CAN_F13R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F13R1_FB9          CAN_F13R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F13R1_FB10_Pos     (10U)                                           
N#define CAN_F13R1_FB10_Msk     (0x1UL << CAN_F13R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F13R1_FB10         CAN_F13R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F13R1_FB11_Pos     (11U)                                           
N#define CAN_F13R1_FB11_Msk     (0x1UL << CAN_F13R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F13R1_FB11         CAN_F13R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F13R1_FB12_Pos     (12U)                                           
N#define CAN_F13R1_FB12_Msk     (0x1UL << CAN_F13R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F13R1_FB12         CAN_F13R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F13R1_FB13_Pos     (13U)                                           
N#define CAN_F13R1_FB13_Msk     (0x1UL << CAN_F13R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F13R1_FB13         CAN_F13R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F13R1_FB14_Pos     (14U)                                           
N#define CAN_F13R1_FB14_Msk     (0x1UL << CAN_F13R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F13R1_FB14         CAN_F13R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F13R1_FB15_Pos     (15U)                                           
N#define CAN_F13R1_FB15_Msk     (0x1UL << CAN_F13R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F13R1_FB15         CAN_F13R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F13R1_FB16_Pos     (16U)                                           
N#define CAN_F13R1_FB16_Msk     (0x1UL << CAN_F13R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F13R1_FB16         CAN_F13R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F13R1_FB17_Pos     (17U)                                           
N#define CAN_F13R1_FB17_Msk     (0x1UL << CAN_F13R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F13R1_FB17         CAN_F13R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F13R1_FB18_Pos     (18U)                                           
N#define CAN_F13R1_FB18_Msk     (0x1UL << CAN_F13R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F13R1_FB18         CAN_F13R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F13R1_FB19_Pos     (19U)                                           
N#define CAN_F13R1_FB19_Msk     (0x1UL << CAN_F13R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F13R1_FB19         CAN_F13R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F13R1_FB20_Pos     (20U)                                           
N#define CAN_F13R1_FB20_Msk     (0x1UL << CAN_F13R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F13R1_FB20         CAN_F13R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F13R1_FB21_Pos     (21U)                                           
N#define CAN_F13R1_FB21_Msk     (0x1UL << CAN_F13R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F13R1_FB21         CAN_F13R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F13R1_FB22_Pos     (22U)                                           
N#define CAN_F13R1_FB22_Msk     (0x1UL << CAN_F13R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F13R1_FB22         CAN_F13R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F13R1_FB23_Pos     (23U)                                           
N#define CAN_F13R1_FB23_Msk     (0x1UL << CAN_F13R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F13R1_FB23         CAN_F13R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F13R1_FB24_Pos     (24U)                                           
N#define CAN_F13R1_FB24_Msk     (0x1UL << CAN_F13R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F13R1_FB24         CAN_F13R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F13R1_FB25_Pos     (25U)                                           
N#define CAN_F13R1_FB25_Msk     (0x1UL << CAN_F13R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F13R1_FB25         CAN_F13R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F13R1_FB26_Pos     (26U)                                           
N#define CAN_F13R1_FB26_Msk     (0x1UL << CAN_F13R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F13R1_FB26         CAN_F13R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F13R1_FB27_Pos     (27U)                                           
N#define CAN_F13R1_FB27_Msk     (0x1UL << CAN_F13R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F13R1_FB27         CAN_F13R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F13R1_FB28_Pos     (28U)                                           
N#define CAN_F13R1_FB28_Msk     (0x1UL << CAN_F13R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F13R1_FB28         CAN_F13R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F13R1_FB29_Pos     (29U)                                           
N#define CAN_F13R1_FB29_Msk     (0x1UL << CAN_F13R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F13R1_FB29         CAN_F13R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F13R1_FB30_Pos     (30U)                                           
N#define CAN_F13R1_FB30_Msk     (0x1UL << CAN_F13R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F13R1_FB30         CAN_F13R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F13R1_FB31_Pos     (31U)                                           
N#define CAN_F13R1_FB31_Msk     (0x1UL << CAN_F13R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F13R1_FB31         CAN_F13R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F0R2 register  *******************/
N#define CAN_F0R2_FB0_Pos       (0U)                                            
N#define CAN_F0R2_FB0_Msk       (0x1UL << CAN_F0R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F0R2_FB0           CAN_F0R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F0R2_FB1_Pos       (1U)                                            
N#define CAN_F0R2_FB1_Msk       (0x1UL << CAN_F0R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F0R2_FB1           CAN_F0R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F0R2_FB2_Pos       (2U)                                            
N#define CAN_F0R2_FB2_Msk       (0x1UL << CAN_F0R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F0R2_FB2           CAN_F0R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F0R2_FB3_Pos       (3U)                                            
N#define CAN_F0R2_FB3_Msk       (0x1UL << CAN_F0R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F0R2_FB3           CAN_F0R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F0R2_FB4_Pos       (4U)                                            
N#define CAN_F0R2_FB4_Msk       (0x1UL << CAN_F0R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F0R2_FB4           CAN_F0R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F0R2_FB5_Pos       (5U)                                            
N#define CAN_F0R2_FB5_Msk       (0x1UL << CAN_F0R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F0R2_FB5           CAN_F0R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F0R2_FB6_Pos       (6U)                                            
N#define CAN_F0R2_FB6_Msk       (0x1UL << CAN_F0R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F0R2_FB6           CAN_F0R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F0R2_FB7_Pos       (7U)                                            
N#define CAN_F0R2_FB7_Msk       (0x1UL << CAN_F0R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F0R2_FB7           CAN_F0R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F0R2_FB8_Pos       (8U)                                            
N#define CAN_F0R2_FB8_Msk       (0x1UL << CAN_F0R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F0R2_FB8           CAN_F0R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F0R2_FB9_Pos       (9U)                                            
N#define CAN_F0R2_FB9_Msk       (0x1UL << CAN_F0R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F0R2_FB9           CAN_F0R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F0R2_FB10_Pos      (10U)                                           
N#define CAN_F0R2_FB10_Msk      (0x1UL << CAN_F0R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F0R2_FB10          CAN_F0R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F0R2_FB11_Pos      (11U)                                           
N#define CAN_F0R2_FB11_Msk      (0x1UL << CAN_F0R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F0R2_FB11          CAN_F0R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F0R2_FB12_Pos      (12U)                                           
N#define CAN_F0R2_FB12_Msk      (0x1UL << CAN_F0R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F0R2_FB12          CAN_F0R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F0R2_FB13_Pos      (13U)                                           
N#define CAN_F0R2_FB13_Msk      (0x1UL << CAN_F0R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F0R2_FB13          CAN_F0R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F0R2_FB14_Pos      (14U)                                           
N#define CAN_F0R2_FB14_Msk      (0x1UL << CAN_F0R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F0R2_FB14          CAN_F0R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F0R2_FB15_Pos      (15U)                                           
N#define CAN_F0R2_FB15_Msk      (0x1UL << CAN_F0R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F0R2_FB15          CAN_F0R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F0R2_FB16_Pos      (16U)                                           
N#define CAN_F0R2_FB16_Msk      (0x1UL << CAN_F0R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F0R2_FB16          CAN_F0R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F0R2_FB17_Pos      (17U)                                           
N#define CAN_F0R2_FB17_Msk      (0x1UL << CAN_F0R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F0R2_FB17          CAN_F0R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F0R2_FB18_Pos      (18U)                                           
N#define CAN_F0R2_FB18_Msk      (0x1UL << CAN_F0R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F0R2_FB18          CAN_F0R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F0R2_FB19_Pos      (19U)                                           
N#define CAN_F0R2_FB19_Msk      (0x1UL << CAN_F0R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F0R2_FB19          CAN_F0R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F0R2_FB20_Pos      (20U)                                           
N#define CAN_F0R2_FB20_Msk      (0x1UL << CAN_F0R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F0R2_FB20          CAN_F0R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F0R2_FB21_Pos      (21U)                                           
N#define CAN_F0R2_FB21_Msk      (0x1UL << CAN_F0R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F0R2_FB21          CAN_F0R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F0R2_FB22_Pos      (22U)                                           
N#define CAN_F0R2_FB22_Msk      (0x1UL << CAN_F0R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F0R2_FB22          CAN_F0R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F0R2_FB23_Pos      (23U)                                           
N#define CAN_F0R2_FB23_Msk      (0x1UL << CAN_F0R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F0R2_FB23          CAN_F0R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F0R2_FB24_Pos      (24U)                                           
N#define CAN_F0R2_FB24_Msk      (0x1UL << CAN_F0R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F0R2_FB24          CAN_F0R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F0R2_FB25_Pos      (25U)                                           
N#define CAN_F0R2_FB25_Msk      (0x1UL << CAN_F0R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F0R2_FB25          CAN_F0R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F0R2_FB26_Pos      (26U)                                           
N#define CAN_F0R2_FB26_Msk      (0x1UL << CAN_F0R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F0R2_FB26          CAN_F0R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F0R2_FB27_Pos      (27U)                                           
N#define CAN_F0R2_FB27_Msk      (0x1UL << CAN_F0R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F0R2_FB27          CAN_F0R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F0R2_FB28_Pos      (28U)                                           
N#define CAN_F0R2_FB28_Msk      (0x1UL << CAN_F0R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F0R2_FB28          CAN_F0R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F0R2_FB29_Pos      (29U)                                           
N#define CAN_F0R2_FB29_Msk      (0x1UL << CAN_F0R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F0R2_FB29          CAN_F0R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F0R2_FB30_Pos      (30U)                                           
N#define CAN_F0R2_FB30_Msk      (0x1UL << CAN_F0R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F0R2_FB30          CAN_F0R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F0R2_FB31_Pos      (31U)                                           
N#define CAN_F0R2_FB31_Msk      (0x1UL << CAN_F0R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F0R2_FB31          CAN_F0R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R2 register  *******************/
N#define CAN_F1R2_FB0_Pos       (0U)                                            
N#define CAN_F1R2_FB0_Msk       (0x1UL << CAN_F1R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F1R2_FB0           CAN_F1R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F1R2_FB1_Pos       (1U)                                            
N#define CAN_F1R2_FB1_Msk       (0x1UL << CAN_F1R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F1R2_FB1           CAN_F1R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F1R2_FB2_Pos       (2U)                                            
N#define CAN_F1R2_FB2_Msk       (0x1UL << CAN_F1R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F1R2_FB2           CAN_F1R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F1R2_FB3_Pos       (3U)                                            
N#define CAN_F1R2_FB3_Msk       (0x1UL << CAN_F1R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F1R2_FB3           CAN_F1R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F1R2_FB4_Pos       (4U)                                            
N#define CAN_F1R2_FB4_Msk       (0x1UL << CAN_F1R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F1R2_FB4           CAN_F1R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F1R2_FB5_Pos       (5U)                                            
N#define CAN_F1R2_FB5_Msk       (0x1UL << CAN_F1R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F1R2_FB5           CAN_F1R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F1R2_FB6_Pos       (6U)                                            
N#define CAN_F1R2_FB6_Msk       (0x1UL << CAN_F1R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F1R2_FB6           CAN_F1R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F1R2_FB7_Pos       (7U)                                            
N#define CAN_F1R2_FB7_Msk       (0x1UL << CAN_F1R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F1R2_FB7           CAN_F1R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F1R2_FB8_Pos       (8U)                                            
N#define CAN_F1R2_FB8_Msk       (0x1UL << CAN_F1R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F1R2_FB8           CAN_F1R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F1R2_FB9_Pos       (9U)                                            
N#define CAN_F1R2_FB9_Msk       (0x1UL << CAN_F1R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F1R2_FB9           CAN_F1R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F1R2_FB10_Pos      (10U)                                           
N#define CAN_F1R2_FB10_Msk      (0x1UL << CAN_F1R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F1R2_FB10          CAN_F1R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F1R2_FB11_Pos      (11U)                                           
N#define CAN_F1R2_FB11_Msk      (0x1UL << CAN_F1R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F1R2_FB11          CAN_F1R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F1R2_FB12_Pos      (12U)                                           
N#define CAN_F1R2_FB12_Msk      (0x1UL << CAN_F1R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F1R2_FB12          CAN_F1R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F1R2_FB13_Pos      (13U)                                           
N#define CAN_F1R2_FB13_Msk      (0x1UL << CAN_F1R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F1R2_FB13          CAN_F1R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F1R2_FB14_Pos      (14U)                                           
N#define CAN_F1R2_FB14_Msk      (0x1UL << CAN_F1R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F1R2_FB14          CAN_F1R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F1R2_FB15_Pos      (15U)                                           
N#define CAN_F1R2_FB15_Msk      (0x1UL << CAN_F1R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F1R2_FB15          CAN_F1R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F1R2_FB16_Pos      (16U)                                           
N#define CAN_F1R2_FB16_Msk      (0x1UL << CAN_F1R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F1R2_FB16          CAN_F1R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F1R2_FB17_Pos      (17U)                                           
N#define CAN_F1R2_FB17_Msk      (0x1UL << CAN_F1R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F1R2_FB17          CAN_F1R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F1R2_FB18_Pos      (18U)                                           
N#define CAN_F1R2_FB18_Msk      (0x1UL << CAN_F1R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F1R2_FB18          CAN_F1R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F1R2_FB19_Pos      (19U)                                           
N#define CAN_F1R2_FB19_Msk      (0x1UL << CAN_F1R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F1R2_FB19          CAN_F1R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F1R2_FB20_Pos      (20U)                                           
N#define CAN_F1R2_FB20_Msk      (0x1UL << CAN_F1R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F1R2_FB20          CAN_F1R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F1R2_FB21_Pos      (21U)                                           
N#define CAN_F1R2_FB21_Msk      (0x1UL << CAN_F1R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F1R2_FB21          CAN_F1R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F1R2_FB22_Pos      (22U)                                           
N#define CAN_F1R2_FB22_Msk      (0x1UL << CAN_F1R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F1R2_FB22          CAN_F1R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F1R2_FB23_Pos      (23U)                                           
N#define CAN_F1R2_FB23_Msk      (0x1UL << CAN_F1R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F1R2_FB23          CAN_F1R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F1R2_FB24_Pos      (24U)                                           
N#define CAN_F1R2_FB24_Msk      (0x1UL << CAN_F1R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F1R2_FB24          CAN_F1R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F1R2_FB25_Pos      (25U)                                           
N#define CAN_F1R2_FB25_Msk      (0x1UL << CAN_F1R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F1R2_FB25          CAN_F1R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F1R2_FB26_Pos      (26U)                                           
N#define CAN_F1R2_FB26_Msk      (0x1UL << CAN_F1R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F1R2_FB26          CAN_F1R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F1R2_FB27_Pos      (27U)                                           
N#define CAN_F1R2_FB27_Msk      (0x1UL << CAN_F1R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F1R2_FB27          CAN_F1R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F1R2_FB28_Pos      (28U)                                           
N#define CAN_F1R2_FB28_Msk      (0x1UL << CAN_F1R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F1R2_FB28          CAN_F1R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F1R2_FB29_Pos      (29U)                                           
N#define CAN_F1R2_FB29_Msk      (0x1UL << CAN_F1R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F1R2_FB29          CAN_F1R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F1R2_FB30_Pos      (30U)                                           
N#define CAN_F1R2_FB30_Msk      (0x1UL << CAN_F1R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F1R2_FB30          CAN_F1R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F1R2_FB31_Pos      (31U)                                           
N#define CAN_F1R2_FB31_Msk      (0x1UL << CAN_F1R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F1R2_FB31          CAN_F1R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R2 register  *******************/
N#define CAN_F2R2_FB0_Pos       (0U)                                            
N#define CAN_F2R2_FB0_Msk       (0x1UL << CAN_F2R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F2R2_FB0           CAN_F2R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F2R2_FB1_Pos       (1U)                                            
N#define CAN_F2R2_FB1_Msk       (0x1UL << CAN_F2R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F2R2_FB1           CAN_F2R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F2R2_FB2_Pos       (2U)                                            
N#define CAN_F2R2_FB2_Msk       (0x1UL << CAN_F2R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F2R2_FB2           CAN_F2R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F2R2_FB3_Pos       (3U)                                            
N#define CAN_F2R2_FB3_Msk       (0x1UL << CAN_F2R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F2R2_FB3           CAN_F2R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F2R2_FB4_Pos       (4U)                                            
N#define CAN_F2R2_FB4_Msk       (0x1UL << CAN_F2R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F2R2_FB4           CAN_F2R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F2R2_FB5_Pos       (5U)                                            
N#define CAN_F2R2_FB5_Msk       (0x1UL << CAN_F2R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F2R2_FB5           CAN_F2R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F2R2_FB6_Pos       (6U)                                            
N#define CAN_F2R2_FB6_Msk       (0x1UL << CAN_F2R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F2R2_FB6           CAN_F2R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F2R2_FB7_Pos       (7U)                                            
N#define CAN_F2R2_FB7_Msk       (0x1UL << CAN_F2R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F2R2_FB7           CAN_F2R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F2R2_FB8_Pos       (8U)                                            
N#define CAN_F2R2_FB8_Msk       (0x1UL << CAN_F2R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F2R2_FB8           CAN_F2R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F2R2_FB9_Pos       (9U)                                            
N#define CAN_F2R2_FB9_Msk       (0x1UL << CAN_F2R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F2R2_FB9           CAN_F2R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F2R2_FB10_Pos      (10U)                                           
N#define CAN_F2R2_FB10_Msk      (0x1UL << CAN_F2R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F2R2_FB10          CAN_F2R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F2R2_FB11_Pos      (11U)                                           
N#define CAN_F2R2_FB11_Msk      (0x1UL << CAN_F2R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F2R2_FB11          CAN_F2R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F2R2_FB12_Pos      (12U)                                           
N#define CAN_F2R2_FB12_Msk      (0x1UL << CAN_F2R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F2R2_FB12          CAN_F2R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F2R2_FB13_Pos      (13U)                                           
N#define CAN_F2R2_FB13_Msk      (0x1UL << CAN_F2R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F2R2_FB13          CAN_F2R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F2R2_FB14_Pos      (14U)                                           
N#define CAN_F2R2_FB14_Msk      (0x1UL << CAN_F2R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F2R2_FB14          CAN_F2R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F2R2_FB15_Pos      (15U)                                           
N#define CAN_F2R2_FB15_Msk      (0x1UL << CAN_F2R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F2R2_FB15          CAN_F2R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F2R2_FB16_Pos      (16U)                                           
N#define CAN_F2R2_FB16_Msk      (0x1UL << CAN_F2R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F2R2_FB16          CAN_F2R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F2R2_FB17_Pos      (17U)                                           
N#define CAN_F2R2_FB17_Msk      (0x1UL << CAN_F2R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F2R2_FB17          CAN_F2R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F2R2_FB18_Pos      (18U)                                           
N#define CAN_F2R2_FB18_Msk      (0x1UL << CAN_F2R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F2R2_FB18          CAN_F2R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F2R2_FB19_Pos      (19U)                                           
N#define CAN_F2R2_FB19_Msk      (0x1UL << CAN_F2R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F2R2_FB19          CAN_F2R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F2R2_FB20_Pos      (20U)                                           
N#define CAN_F2R2_FB20_Msk      (0x1UL << CAN_F2R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F2R2_FB20          CAN_F2R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F2R2_FB21_Pos      (21U)                                           
N#define CAN_F2R2_FB21_Msk      (0x1UL << CAN_F2R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F2R2_FB21          CAN_F2R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F2R2_FB22_Pos      (22U)                                           
N#define CAN_F2R2_FB22_Msk      (0x1UL << CAN_F2R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F2R2_FB22          CAN_F2R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F2R2_FB23_Pos      (23U)                                           
N#define CAN_F2R2_FB23_Msk      (0x1UL << CAN_F2R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F2R2_FB23          CAN_F2R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F2R2_FB24_Pos      (24U)                                           
N#define CAN_F2R2_FB24_Msk      (0x1UL << CAN_F2R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F2R2_FB24          CAN_F2R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F2R2_FB25_Pos      (25U)                                           
N#define CAN_F2R2_FB25_Msk      (0x1UL << CAN_F2R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F2R2_FB25          CAN_F2R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F2R2_FB26_Pos      (26U)                                           
N#define CAN_F2R2_FB26_Msk      (0x1UL << CAN_F2R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F2R2_FB26          CAN_F2R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F2R2_FB27_Pos      (27U)                                           
N#define CAN_F2R2_FB27_Msk      (0x1UL << CAN_F2R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F2R2_FB27          CAN_F2R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F2R2_FB28_Pos      (28U)                                           
N#define CAN_F2R2_FB28_Msk      (0x1UL << CAN_F2R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F2R2_FB28          CAN_F2R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F2R2_FB29_Pos      (29U)                                           
N#define CAN_F2R2_FB29_Msk      (0x1UL << CAN_F2R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F2R2_FB29          CAN_F2R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F2R2_FB30_Pos      (30U)                                           
N#define CAN_F2R2_FB30_Msk      (0x1UL << CAN_F2R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F2R2_FB30          CAN_F2R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F2R2_FB31_Pos      (31U)                                           
N#define CAN_F2R2_FB31_Msk      (0x1UL << CAN_F2R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F2R2_FB31          CAN_F2R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R2 register  *******************/
N#define CAN_F3R2_FB0_Pos       (0U)                                            
N#define CAN_F3R2_FB0_Msk       (0x1UL << CAN_F3R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F3R2_FB0           CAN_F3R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F3R2_FB1_Pos       (1U)                                            
N#define CAN_F3R2_FB1_Msk       (0x1UL << CAN_F3R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F3R2_FB1           CAN_F3R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F3R2_FB2_Pos       (2U)                                            
N#define CAN_F3R2_FB2_Msk       (0x1UL << CAN_F3R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F3R2_FB2           CAN_F3R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F3R2_FB3_Pos       (3U)                                            
N#define CAN_F3R2_FB3_Msk       (0x1UL << CAN_F3R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F3R2_FB3           CAN_F3R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F3R2_FB4_Pos       (4U)                                            
N#define CAN_F3R2_FB4_Msk       (0x1UL << CAN_F3R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F3R2_FB4           CAN_F3R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F3R2_FB5_Pos       (5U)                                            
N#define CAN_F3R2_FB5_Msk       (0x1UL << CAN_F3R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F3R2_FB5           CAN_F3R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F3R2_FB6_Pos       (6U)                                            
N#define CAN_F3R2_FB6_Msk       (0x1UL << CAN_F3R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F3R2_FB6           CAN_F3R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F3R2_FB7_Pos       (7U)                                            
N#define CAN_F3R2_FB7_Msk       (0x1UL << CAN_F3R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F3R2_FB7           CAN_F3R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F3R2_FB8_Pos       (8U)                                            
N#define CAN_F3R2_FB8_Msk       (0x1UL << CAN_F3R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F3R2_FB8           CAN_F3R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F3R2_FB9_Pos       (9U)                                            
N#define CAN_F3R2_FB9_Msk       (0x1UL << CAN_F3R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F3R2_FB9           CAN_F3R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F3R2_FB10_Pos      (10U)                                           
N#define CAN_F3R2_FB10_Msk      (0x1UL << CAN_F3R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F3R2_FB10          CAN_F3R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F3R2_FB11_Pos      (11U)                                           
N#define CAN_F3R2_FB11_Msk      (0x1UL << CAN_F3R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F3R2_FB11          CAN_F3R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F3R2_FB12_Pos      (12U)                                           
N#define CAN_F3R2_FB12_Msk      (0x1UL << CAN_F3R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F3R2_FB12          CAN_F3R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F3R2_FB13_Pos      (13U)                                           
N#define CAN_F3R2_FB13_Msk      (0x1UL << CAN_F3R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F3R2_FB13          CAN_F3R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F3R2_FB14_Pos      (14U)                                           
N#define CAN_F3R2_FB14_Msk      (0x1UL << CAN_F3R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F3R2_FB14          CAN_F3R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F3R2_FB15_Pos      (15U)                                           
N#define CAN_F3R2_FB15_Msk      (0x1UL << CAN_F3R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F3R2_FB15          CAN_F3R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F3R2_FB16_Pos      (16U)                                           
N#define CAN_F3R2_FB16_Msk      (0x1UL << CAN_F3R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F3R2_FB16          CAN_F3R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F3R2_FB17_Pos      (17U)                                           
N#define CAN_F3R2_FB17_Msk      (0x1UL << CAN_F3R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F3R2_FB17          CAN_F3R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F3R2_FB18_Pos      (18U)                                           
N#define CAN_F3R2_FB18_Msk      (0x1UL << CAN_F3R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F3R2_FB18          CAN_F3R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F3R2_FB19_Pos      (19U)                                           
N#define CAN_F3R2_FB19_Msk      (0x1UL << CAN_F3R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F3R2_FB19          CAN_F3R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F3R2_FB20_Pos      (20U)                                           
N#define CAN_F3R2_FB20_Msk      (0x1UL << CAN_F3R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F3R2_FB20          CAN_F3R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F3R2_FB21_Pos      (21U)                                           
N#define CAN_F3R2_FB21_Msk      (0x1UL << CAN_F3R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F3R2_FB21          CAN_F3R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F3R2_FB22_Pos      (22U)                                           
N#define CAN_F3R2_FB22_Msk      (0x1UL << CAN_F3R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F3R2_FB22          CAN_F3R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F3R2_FB23_Pos      (23U)                                           
N#define CAN_F3R2_FB23_Msk      (0x1UL << CAN_F3R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F3R2_FB23          CAN_F3R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F3R2_FB24_Pos      (24U)                                           
N#define CAN_F3R2_FB24_Msk      (0x1UL << CAN_F3R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F3R2_FB24          CAN_F3R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F3R2_FB25_Pos      (25U)                                           
N#define CAN_F3R2_FB25_Msk      (0x1UL << CAN_F3R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F3R2_FB25          CAN_F3R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F3R2_FB26_Pos      (26U)                                           
N#define CAN_F3R2_FB26_Msk      (0x1UL << CAN_F3R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F3R2_FB26          CAN_F3R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F3R2_FB27_Pos      (27U)                                           
N#define CAN_F3R2_FB27_Msk      (0x1UL << CAN_F3R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F3R2_FB27          CAN_F3R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F3R2_FB28_Pos      (28U)                                           
N#define CAN_F3R2_FB28_Msk      (0x1UL << CAN_F3R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F3R2_FB28          CAN_F3R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F3R2_FB29_Pos      (29U)                                           
N#define CAN_F3R2_FB29_Msk      (0x1UL << CAN_F3R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F3R2_FB29          CAN_F3R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F3R2_FB30_Pos      (30U)                                           
N#define CAN_F3R2_FB30_Msk      (0x1UL << CAN_F3R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F3R2_FB30          CAN_F3R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F3R2_FB31_Pos      (31U)                                           
N#define CAN_F3R2_FB31_Msk      (0x1UL << CAN_F3R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F3R2_FB31          CAN_F3R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R2 register  *******************/
N#define CAN_F4R2_FB0_Pos       (0U)                                            
N#define CAN_F4R2_FB0_Msk       (0x1UL << CAN_F4R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F4R2_FB0           CAN_F4R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F4R2_FB1_Pos       (1U)                                            
N#define CAN_F4R2_FB1_Msk       (0x1UL << CAN_F4R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F4R2_FB1           CAN_F4R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F4R2_FB2_Pos       (2U)                                            
N#define CAN_F4R2_FB2_Msk       (0x1UL << CAN_F4R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F4R2_FB2           CAN_F4R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F4R2_FB3_Pos       (3U)                                            
N#define CAN_F4R2_FB3_Msk       (0x1UL << CAN_F4R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F4R2_FB3           CAN_F4R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F4R2_FB4_Pos       (4U)                                            
N#define CAN_F4R2_FB4_Msk       (0x1UL << CAN_F4R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F4R2_FB4           CAN_F4R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F4R2_FB5_Pos       (5U)                                            
N#define CAN_F4R2_FB5_Msk       (0x1UL << CAN_F4R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F4R2_FB5           CAN_F4R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F4R2_FB6_Pos       (6U)                                            
N#define CAN_F4R2_FB6_Msk       (0x1UL << CAN_F4R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F4R2_FB6           CAN_F4R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F4R2_FB7_Pos       (7U)                                            
N#define CAN_F4R2_FB7_Msk       (0x1UL << CAN_F4R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F4R2_FB7           CAN_F4R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F4R2_FB8_Pos       (8U)                                            
N#define CAN_F4R2_FB8_Msk       (0x1UL << CAN_F4R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F4R2_FB8           CAN_F4R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F4R2_FB9_Pos       (9U)                                            
N#define CAN_F4R2_FB9_Msk       (0x1UL << CAN_F4R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F4R2_FB9           CAN_F4R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F4R2_FB10_Pos      (10U)                                           
N#define CAN_F4R2_FB10_Msk      (0x1UL << CAN_F4R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F4R2_FB10          CAN_F4R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F4R2_FB11_Pos      (11U)                                           
N#define CAN_F4R2_FB11_Msk      (0x1UL << CAN_F4R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F4R2_FB11          CAN_F4R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F4R2_FB12_Pos      (12U)                                           
N#define CAN_F4R2_FB12_Msk      (0x1UL << CAN_F4R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F4R2_FB12          CAN_F4R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F4R2_FB13_Pos      (13U)                                           
N#define CAN_F4R2_FB13_Msk      (0x1UL << CAN_F4R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F4R2_FB13          CAN_F4R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F4R2_FB14_Pos      (14U)                                           
N#define CAN_F4R2_FB14_Msk      (0x1UL << CAN_F4R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F4R2_FB14          CAN_F4R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F4R2_FB15_Pos      (15U)                                           
N#define CAN_F4R2_FB15_Msk      (0x1UL << CAN_F4R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F4R2_FB15          CAN_F4R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F4R2_FB16_Pos      (16U)                                           
N#define CAN_F4R2_FB16_Msk      (0x1UL << CAN_F4R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F4R2_FB16          CAN_F4R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F4R2_FB17_Pos      (17U)                                           
N#define CAN_F4R2_FB17_Msk      (0x1UL << CAN_F4R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F4R2_FB17          CAN_F4R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F4R2_FB18_Pos      (18U)                                           
N#define CAN_F4R2_FB18_Msk      (0x1UL << CAN_F4R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F4R2_FB18          CAN_F4R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F4R2_FB19_Pos      (19U)                                           
N#define CAN_F4R2_FB19_Msk      (0x1UL << CAN_F4R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F4R2_FB19          CAN_F4R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F4R2_FB20_Pos      (20U)                                           
N#define CAN_F4R2_FB20_Msk      (0x1UL << CAN_F4R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F4R2_FB20          CAN_F4R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F4R2_FB21_Pos      (21U)                                           
N#define CAN_F4R2_FB21_Msk      (0x1UL << CAN_F4R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F4R2_FB21          CAN_F4R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F4R2_FB22_Pos      (22U)                                           
N#define CAN_F4R2_FB22_Msk      (0x1UL << CAN_F4R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F4R2_FB22          CAN_F4R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F4R2_FB23_Pos      (23U)                                           
N#define CAN_F4R2_FB23_Msk      (0x1UL << CAN_F4R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F4R2_FB23          CAN_F4R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F4R2_FB24_Pos      (24U)                                           
N#define CAN_F4R2_FB24_Msk      (0x1UL << CAN_F4R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F4R2_FB24          CAN_F4R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F4R2_FB25_Pos      (25U)                                           
N#define CAN_F4R2_FB25_Msk      (0x1UL << CAN_F4R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F4R2_FB25          CAN_F4R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F4R2_FB26_Pos      (26U)                                           
N#define CAN_F4R2_FB26_Msk      (0x1UL << CAN_F4R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F4R2_FB26          CAN_F4R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F4R2_FB27_Pos      (27U)                                           
N#define CAN_F4R2_FB27_Msk      (0x1UL << CAN_F4R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F4R2_FB27          CAN_F4R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F4R2_FB28_Pos      (28U)                                           
N#define CAN_F4R2_FB28_Msk      (0x1UL << CAN_F4R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F4R2_FB28          CAN_F4R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F4R2_FB29_Pos      (29U)                                           
N#define CAN_F4R2_FB29_Msk      (0x1UL << CAN_F4R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F4R2_FB29          CAN_F4R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F4R2_FB30_Pos      (30U)                                           
N#define CAN_F4R2_FB30_Msk      (0x1UL << CAN_F4R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F4R2_FB30          CAN_F4R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F4R2_FB31_Pos      (31U)                                           
N#define CAN_F4R2_FB31_Msk      (0x1UL << CAN_F4R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F4R2_FB31          CAN_F4R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R2 register  *******************/
N#define CAN_F5R2_FB0_Pos       (0U)                                            
N#define CAN_F5R2_FB0_Msk       (0x1UL << CAN_F5R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F5R2_FB0           CAN_F5R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F5R2_FB1_Pos       (1U)                                            
N#define CAN_F5R2_FB1_Msk       (0x1UL << CAN_F5R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F5R2_FB1           CAN_F5R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F5R2_FB2_Pos       (2U)                                            
N#define CAN_F5R2_FB2_Msk       (0x1UL << CAN_F5R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F5R2_FB2           CAN_F5R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F5R2_FB3_Pos       (3U)                                            
N#define CAN_F5R2_FB3_Msk       (0x1UL << CAN_F5R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F5R2_FB3           CAN_F5R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F5R2_FB4_Pos       (4U)                                            
N#define CAN_F5R2_FB4_Msk       (0x1UL << CAN_F5R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F5R2_FB4           CAN_F5R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F5R2_FB5_Pos       (5U)                                            
N#define CAN_F5R2_FB5_Msk       (0x1UL << CAN_F5R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F5R2_FB5           CAN_F5R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F5R2_FB6_Pos       (6U)                                            
N#define CAN_F5R2_FB6_Msk       (0x1UL << CAN_F5R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F5R2_FB6           CAN_F5R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F5R2_FB7_Pos       (7U)                                            
N#define CAN_F5R2_FB7_Msk       (0x1UL << CAN_F5R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F5R2_FB7           CAN_F5R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F5R2_FB8_Pos       (8U)                                            
N#define CAN_F5R2_FB8_Msk       (0x1UL << CAN_F5R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F5R2_FB8           CAN_F5R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F5R2_FB9_Pos       (9U)                                            
N#define CAN_F5R2_FB9_Msk       (0x1UL << CAN_F5R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F5R2_FB9           CAN_F5R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F5R2_FB10_Pos      (10U)                                           
N#define CAN_F5R2_FB10_Msk      (0x1UL << CAN_F5R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F5R2_FB10          CAN_F5R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F5R2_FB11_Pos      (11U)                                           
N#define CAN_F5R2_FB11_Msk      (0x1UL << CAN_F5R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F5R2_FB11          CAN_F5R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F5R2_FB12_Pos      (12U)                                           
N#define CAN_F5R2_FB12_Msk      (0x1UL << CAN_F5R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F5R2_FB12          CAN_F5R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F5R2_FB13_Pos      (13U)                                           
N#define CAN_F5R2_FB13_Msk      (0x1UL << CAN_F5R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F5R2_FB13          CAN_F5R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F5R2_FB14_Pos      (14U)                                           
N#define CAN_F5R2_FB14_Msk      (0x1UL << CAN_F5R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F5R2_FB14          CAN_F5R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F5R2_FB15_Pos      (15U)                                           
N#define CAN_F5R2_FB15_Msk      (0x1UL << CAN_F5R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F5R2_FB15          CAN_F5R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F5R2_FB16_Pos      (16U)                                           
N#define CAN_F5R2_FB16_Msk      (0x1UL << CAN_F5R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F5R2_FB16          CAN_F5R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F5R2_FB17_Pos      (17U)                                           
N#define CAN_F5R2_FB17_Msk      (0x1UL << CAN_F5R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F5R2_FB17          CAN_F5R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F5R2_FB18_Pos      (18U)                                           
N#define CAN_F5R2_FB18_Msk      (0x1UL << CAN_F5R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F5R2_FB18          CAN_F5R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F5R2_FB19_Pos      (19U)                                           
N#define CAN_F5R2_FB19_Msk      (0x1UL << CAN_F5R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F5R2_FB19          CAN_F5R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F5R2_FB20_Pos      (20U)                                           
N#define CAN_F5R2_FB20_Msk      (0x1UL << CAN_F5R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F5R2_FB20          CAN_F5R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F5R2_FB21_Pos      (21U)                                           
N#define CAN_F5R2_FB21_Msk      (0x1UL << CAN_F5R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F5R2_FB21          CAN_F5R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F5R2_FB22_Pos      (22U)                                           
N#define CAN_F5R2_FB22_Msk      (0x1UL << CAN_F5R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F5R2_FB22          CAN_F5R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F5R2_FB23_Pos      (23U)                                           
N#define CAN_F5R2_FB23_Msk      (0x1UL << CAN_F5R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F5R2_FB23          CAN_F5R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F5R2_FB24_Pos      (24U)                                           
N#define CAN_F5R2_FB24_Msk      (0x1UL << CAN_F5R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F5R2_FB24          CAN_F5R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F5R2_FB25_Pos      (25U)                                           
N#define CAN_F5R2_FB25_Msk      (0x1UL << CAN_F5R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F5R2_FB25          CAN_F5R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F5R2_FB26_Pos      (26U)                                           
N#define CAN_F5R2_FB26_Msk      (0x1UL << CAN_F5R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F5R2_FB26          CAN_F5R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F5R2_FB27_Pos      (27U)                                           
N#define CAN_F5R2_FB27_Msk      (0x1UL << CAN_F5R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F5R2_FB27          CAN_F5R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F5R2_FB28_Pos      (28U)                                           
N#define CAN_F5R2_FB28_Msk      (0x1UL << CAN_F5R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F5R2_FB28          CAN_F5R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F5R2_FB29_Pos      (29U)                                           
N#define CAN_F5R2_FB29_Msk      (0x1UL << CAN_F5R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F5R2_FB29          CAN_F5R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F5R2_FB30_Pos      (30U)                                           
N#define CAN_F5R2_FB30_Msk      (0x1UL << CAN_F5R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F5R2_FB30          CAN_F5R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F5R2_FB31_Pos      (31U)                                           
N#define CAN_F5R2_FB31_Msk      (0x1UL << CAN_F5R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F5R2_FB31          CAN_F5R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R2 register  *******************/
N#define CAN_F6R2_FB0_Pos       (0U)                                            
N#define CAN_F6R2_FB0_Msk       (0x1UL << CAN_F6R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F6R2_FB0           CAN_F6R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F6R2_FB1_Pos       (1U)                                            
N#define CAN_F6R2_FB1_Msk       (0x1UL << CAN_F6R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F6R2_FB1           CAN_F6R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F6R2_FB2_Pos       (2U)                                            
N#define CAN_F6R2_FB2_Msk       (0x1UL << CAN_F6R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F6R2_FB2           CAN_F6R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F6R2_FB3_Pos       (3U)                                            
N#define CAN_F6R2_FB3_Msk       (0x1UL << CAN_F6R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F6R2_FB3           CAN_F6R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F6R2_FB4_Pos       (4U)                                            
N#define CAN_F6R2_FB4_Msk       (0x1UL << CAN_F6R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F6R2_FB4           CAN_F6R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F6R2_FB5_Pos       (5U)                                            
N#define CAN_F6R2_FB5_Msk       (0x1UL << CAN_F6R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F6R2_FB5           CAN_F6R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F6R2_FB6_Pos       (6U)                                            
N#define CAN_F6R2_FB6_Msk       (0x1UL << CAN_F6R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F6R2_FB6           CAN_F6R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F6R2_FB7_Pos       (7U)                                            
N#define CAN_F6R2_FB7_Msk       (0x1UL << CAN_F6R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F6R2_FB7           CAN_F6R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F6R2_FB8_Pos       (8U)                                            
N#define CAN_F6R2_FB8_Msk       (0x1UL << CAN_F6R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F6R2_FB8           CAN_F6R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F6R2_FB9_Pos       (9U)                                            
N#define CAN_F6R2_FB9_Msk       (0x1UL << CAN_F6R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F6R2_FB9           CAN_F6R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F6R2_FB10_Pos      (10U)                                           
N#define CAN_F6R2_FB10_Msk      (0x1UL << CAN_F6R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F6R2_FB10          CAN_F6R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F6R2_FB11_Pos      (11U)                                           
N#define CAN_F6R2_FB11_Msk      (0x1UL << CAN_F6R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F6R2_FB11          CAN_F6R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F6R2_FB12_Pos      (12U)                                           
N#define CAN_F6R2_FB12_Msk      (0x1UL << CAN_F6R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F6R2_FB12          CAN_F6R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F6R2_FB13_Pos      (13U)                                           
N#define CAN_F6R2_FB13_Msk      (0x1UL << CAN_F6R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F6R2_FB13          CAN_F6R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F6R2_FB14_Pos      (14U)                                           
N#define CAN_F6R2_FB14_Msk      (0x1UL << CAN_F6R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F6R2_FB14          CAN_F6R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F6R2_FB15_Pos      (15U)                                           
N#define CAN_F6R2_FB15_Msk      (0x1UL << CAN_F6R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F6R2_FB15          CAN_F6R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F6R2_FB16_Pos      (16U)                                           
N#define CAN_F6R2_FB16_Msk      (0x1UL << CAN_F6R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F6R2_FB16          CAN_F6R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F6R2_FB17_Pos      (17U)                                           
N#define CAN_F6R2_FB17_Msk      (0x1UL << CAN_F6R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F6R2_FB17          CAN_F6R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F6R2_FB18_Pos      (18U)                                           
N#define CAN_F6R2_FB18_Msk      (0x1UL << CAN_F6R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F6R2_FB18          CAN_F6R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F6R2_FB19_Pos      (19U)                                           
N#define CAN_F6R2_FB19_Msk      (0x1UL << CAN_F6R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F6R2_FB19          CAN_F6R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F6R2_FB20_Pos      (20U)                                           
N#define CAN_F6R2_FB20_Msk      (0x1UL << CAN_F6R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F6R2_FB20          CAN_F6R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F6R2_FB21_Pos      (21U)                                           
N#define CAN_F6R2_FB21_Msk      (0x1UL << CAN_F6R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F6R2_FB21          CAN_F6R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F6R2_FB22_Pos      (22U)                                           
N#define CAN_F6R2_FB22_Msk      (0x1UL << CAN_F6R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F6R2_FB22          CAN_F6R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F6R2_FB23_Pos      (23U)                                           
N#define CAN_F6R2_FB23_Msk      (0x1UL << CAN_F6R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F6R2_FB23          CAN_F6R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F6R2_FB24_Pos      (24U)                                           
N#define CAN_F6R2_FB24_Msk      (0x1UL << CAN_F6R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F6R2_FB24          CAN_F6R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F6R2_FB25_Pos      (25U)                                           
N#define CAN_F6R2_FB25_Msk      (0x1UL << CAN_F6R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F6R2_FB25          CAN_F6R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F6R2_FB26_Pos      (26U)                                           
N#define CAN_F6R2_FB26_Msk      (0x1UL << CAN_F6R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F6R2_FB26          CAN_F6R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F6R2_FB27_Pos      (27U)                                           
N#define CAN_F6R2_FB27_Msk      (0x1UL << CAN_F6R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F6R2_FB27          CAN_F6R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F6R2_FB28_Pos      (28U)                                           
N#define CAN_F6R2_FB28_Msk      (0x1UL << CAN_F6R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F6R2_FB28          CAN_F6R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F6R2_FB29_Pos      (29U)                                           
N#define CAN_F6R2_FB29_Msk      (0x1UL << CAN_F6R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F6R2_FB29          CAN_F6R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F6R2_FB30_Pos      (30U)                                           
N#define CAN_F6R2_FB30_Msk      (0x1UL << CAN_F6R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F6R2_FB30          CAN_F6R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F6R2_FB31_Pos      (31U)                                           
N#define CAN_F6R2_FB31_Msk      (0x1UL << CAN_F6R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F6R2_FB31          CAN_F6R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R2 register  *******************/
N#define CAN_F7R2_FB0_Pos       (0U)                                            
N#define CAN_F7R2_FB0_Msk       (0x1UL << CAN_F7R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F7R2_FB0           CAN_F7R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F7R2_FB1_Pos       (1U)                                            
N#define CAN_F7R2_FB1_Msk       (0x1UL << CAN_F7R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F7R2_FB1           CAN_F7R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F7R2_FB2_Pos       (2U)                                            
N#define CAN_F7R2_FB2_Msk       (0x1UL << CAN_F7R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F7R2_FB2           CAN_F7R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F7R2_FB3_Pos       (3U)                                            
N#define CAN_F7R2_FB3_Msk       (0x1UL << CAN_F7R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F7R2_FB3           CAN_F7R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F7R2_FB4_Pos       (4U)                                            
N#define CAN_F7R2_FB4_Msk       (0x1UL << CAN_F7R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F7R2_FB4           CAN_F7R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F7R2_FB5_Pos       (5U)                                            
N#define CAN_F7R2_FB5_Msk       (0x1UL << CAN_F7R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F7R2_FB5           CAN_F7R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F7R2_FB6_Pos       (6U)                                            
N#define CAN_F7R2_FB6_Msk       (0x1UL << CAN_F7R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F7R2_FB6           CAN_F7R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F7R2_FB7_Pos       (7U)                                            
N#define CAN_F7R2_FB7_Msk       (0x1UL << CAN_F7R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F7R2_FB7           CAN_F7R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F7R2_FB8_Pos       (8U)                                            
N#define CAN_F7R2_FB8_Msk       (0x1UL << CAN_F7R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F7R2_FB8           CAN_F7R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F7R2_FB9_Pos       (9U)                                            
N#define CAN_F7R2_FB9_Msk       (0x1UL << CAN_F7R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F7R2_FB9           CAN_F7R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F7R2_FB10_Pos      (10U)                                           
N#define CAN_F7R2_FB10_Msk      (0x1UL << CAN_F7R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F7R2_FB10          CAN_F7R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F7R2_FB11_Pos      (11U)                                           
N#define CAN_F7R2_FB11_Msk      (0x1UL << CAN_F7R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F7R2_FB11          CAN_F7R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F7R2_FB12_Pos      (12U)                                           
N#define CAN_F7R2_FB12_Msk      (0x1UL << CAN_F7R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F7R2_FB12          CAN_F7R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F7R2_FB13_Pos      (13U)                                           
N#define CAN_F7R2_FB13_Msk      (0x1UL << CAN_F7R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F7R2_FB13          CAN_F7R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F7R2_FB14_Pos      (14U)                                           
N#define CAN_F7R2_FB14_Msk      (0x1UL << CAN_F7R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F7R2_FB14          CAN_F7R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F7R2_FB15_Pos      (15U)                                           
N#define CAN_F7R2_FB15_Msk      (0x1UL << CAN_F7R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F7R2_FB15          CAN_F7R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F7R2_FB16_Pos      (16U)                                           
N#define CAN_F7R2_FB16_Msk      (0x1UL << CAN_F7R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F7R2_FB16          CAN_F7R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F7R2_FB17_Pos      (17U)                                           
N#define CAN_F7R2_FB17_Msk      (0x1UL << CAN_F7R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F7R2_FB17          CAN_F7R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F7R2_FB18_Pos      (18U)                                           
N#define CAN_F7R2_FB18_Msk      (0x1UL << CAN_F7R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F7R2_FB18          CAN_F7R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F7R2_FB19_Pos      (19U)                                           
N#define CAN_F7R2_FB19_Msk      (0x1UL << CAN_F7R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F7R2_FB19          CAN_F7R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F7R2_FB20_Pos      (20U)                                           
N#define CAN_F7R2_FB20_Msk      (0x1UL << CAN_F7R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F7R2_FB20          CAN_F7R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F7R2_FB21_Pos      (21U)                                           
N#define CAN_F7R2_FB21_Msk      (0x1UL << CAN_F7R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F7R2_FB21          CAN_F7R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F7R2_FB22_Pos      (22U)                                           
N#define CAN_F7R2_FB22_Msk      (0x1UL << CAN_F7R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F7R2_FB22          CAN_F7R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F7R2_FB23_Pos      (23U)                                           
N#define CAN_F7R2_FB23_Msk      (0x1UL << CAN_F7R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F7R2_FB23          CAN_F7R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F7R2_FB24_Pos      (24U)                                           
N#define CAN_F7R2_FB24_Msk      (0x1UL << CAN_F7R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F7R2_FB24          CAN_F7R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F7R2_FB25_Pos      (25U)                                           
N#define CAN_F7R2_FB25_Msk      (0x1UL << CAN_F7R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F7R2_FB25          CAN_F7R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F7R2_FB26_Pos      (26U)                                           
N#define CAN_F7R2_FB26_Msk      (0x1UL << CAN_F7R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F7R2_FB26          CAN_F7R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F7R2_FB27_Pos      (27U)                                           
N#define CAN_F7R2_FB27_Msk      (0x1UL << CAN_F7R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F7R2_FB27          CAN_F7R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F7R2_FB28_Pos      (28U)                                           
N#define CAN_F7R2_FB28_Msk      (0x1UL << CAN_F7R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F7R2_FB28          CAN_F7R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F7R2_FB29_Pos      (29U)                                           
N#define CAN_F7R2_FB29_Msk      (0x1UL << CAN_F7R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F7R2_FB29          CAN_F7R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F7R2_FB30_Pos      (30U)                                           
N#define CAN_F7R2_FB30_Msk      (0x1UL << CAN_F7R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F7R2_FB30          CAN_F7R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F7R2_FB31_Pos      (31U)                                           
N#define CAN_F7R2_FB31_Msk      (0x1UL << CAN_F7R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F7R2_FB31          CAN_F7R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R2 register  *******************/
N#define CAN_F8R2_FB0_Pos       (0U)                                            
N#define CAN_F8R2_FB0_Msk       (0x1UL << CAN_F8R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F8R2_FB0           CAN_F8R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F8R2_FB1_Pos       (1U)                                            
N#define CAN_F8R2_FB1_Msk       (0x1UL << CAN_F8R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F8R2_FB1           CAN_F8R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F8R2_FB2_Pos       (2U)                                            
N#define CAN_F8R2_FB2_Msk       (0x1UL << CAN_F8R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F8R2_FB2           CAN_F8R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F8R2_FB3_Pos       (3U)                                            
N#define CAN_F8R2_FB3_Msk       (0x1UL << CAN_F8R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F8R2_FB3           CAN_F8R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F8R2_FB4_Pos       (4U)                                            
N#define CAN_F8R2_FB4_Msk       (0x1UL << CAN_F8R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F8R2_FB4           CAN_F8R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F8R2_FB5_Pos       (5U)                                            
N#define CAN_F8R2_FB5_Msk       (0x1UL << CAN_F8R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F8R2_FB5           CAN_F8R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F8R2_FB6_Pos       (6U)                                            
N#define CAN_F8R2_FB6_Msk       (0x1UL << CAN_F8R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F8R2_FB6           CAN_F8R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F8R2_FB7_Pos       (7U)                                            
N#define CAN_F8R2_FB7_Msk       (0x1UL << CAN_F8R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F8R2_FB7           CAN_F8R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F8R2_FB8_Pos       (8U)                                            
N#define CAN_F8R2_FB8_Msk       (0x1UL << CAN_F8R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F8R2_FB8           CAN_F8R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F8R2_FB9_Pos       (9U)                                            
N#define CAN_F8R2_FB9_Msk       (0x1UL << CAN_F8R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F8R2_FB9           CAN_F8R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F8R2_FB10_Pos      (10U)                                           
N#define CAN_F8R2_FB10_Msk      (0x1UL << CAN_F8R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F8R2_FB10          CAN_F8R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F8R2_FB11_Pos      (11U)                                           
N#define CAN_F8R2_FB11_Msk      (0x1UL << CAN_F8R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F8R2_FB11          CAN_F8R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F8R2_FB12_Pos      (12U)                                           
N#define CAN_F8R2_FB12_Msk      (0x1UL << CAN_F8R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F8R2_FB12          CAN_F8R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F8R2_FB13_Pos      (13U)                                           
N#define CAN_F8R2_FB13_Msk      (0x1UL << CAN_F8R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F8R2_FB13          CAN_F8R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F8R2_FB14_Pos      (14U)                                           
N#define CAN_F8R2_FB14_Msk      (0x1UL << CAN_F8R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F8R2_FB14          CAN_F8R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F8R2_FB15_Pos      (15U)                                           
N#define CAN_F8R2_FB15_Msk      (0x1UL << CAN_F8R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F8R2_FB15          CAN_F8R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F8R2_FB16_Pos      (16U)                                           
N#define CAN_F8R2_FB16_Msk      (0x1UL << CAN_F8R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F8R2_FB16          CAN_F8R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F8R2_FB17_Pos      (17U)                                           
N#define CAN_F8R2_FB17_Msk      (0x1UL << CAN_F8R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F8R2_FB17          CAN_F8R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F8R2_FB18_Pos      (18U)                                           
N#define CAN_F8R2_FB18_Msk      (0x1UL << CAN_F8R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F8R2_FB18          CAN_F8R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F8R2_FB19_Pos      (19U)                                           
N#define CAN_F8R2_FB19_Msk      (0x1UL << CAN_F8R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F8R2_FB19          CAN_F8R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F8R2_FB20_Pos      (20U)                                           
N#define CAN_F8R2_FB20_Msk      (0x1UL << CAN_F8R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F8R2_FB20          CAN_F8R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F8R2_FB21_Pos      (21U)                                           
N#define CAN_F8R2_FB21_Msk      (0x1UL << CAN_F8R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F8R2_FB21          CAN_F8R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F8R2_FB22_Pos      (22U)                                           
N#define CAN_F8R2_FB22_Msk      (0x1UL << CAN_F8R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F8R2_FB22          CAN_F8R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F8R2_FB23_Pos      (23U)                                           
N#define CAN_F8R2_FB23_Msk      (0x1UL << CAN_F8R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F8R2_FB23          CAN_F8R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F8R2_FB24_Pos      (24U)                                           
N#define CAN_F8R2_FB24_Msk      (0x1UL << CAN_F8R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F8R2_FB24          CAN_F8R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F8R2_FB25_Pos      (25U)                                           
N#define CAN_F8R2_FB25_Msk      (0x1UL << CAN_F8R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F8R2_FB25          CAN_F8R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F8R2_FB26_Pos      (26U)                                           
N#define CAN_F8R2_FB26_Msk      (0x1UL << CAN_F8R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F8R2_FB26          CAN_F8R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F8R2_FB27_Pos      (27U)                                           
N#define CAN_F8R2_FB27_Msk      (0x1UL << CAN_F8R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F8R2_FB27          CAN_F8R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F8R2_FB28_Pos      (28U)                                           
N#define CAN_F8R2_FB28_Msk      (0x1UL << CAN_F8R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F8R2_FB28          CAN_F8R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F8R2_FB29_Pos      (29U)                                           
N#define CAN_F8R2_FB29_Msk      (0x1UL << CAN_F8R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F8R2_FB29          CAN_F8R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F8R2_FB30_Pos      (30U)                                           
N#define CAN_F8R2_FB30_Msk      (0x1UL << CAN_F8R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F8R2_FB30          CAN_F8R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F8R2_FB31_Pos      (31U)                                           
N#define CAN_F8R2_FB31_Msk      (0x1UL << CAN_F8R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F8R2_FB31          CAN_F8R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R2 register  *******************/
N#define CAN_F9R2_FB0_Pos       (0U)                                            
N#define CAN_F9R2_FB0_Msk       (0x1UL << CAN_F9R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F9R2_FB0           CAN_F9R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F9R2_FB1_Pos       (1U)                                            
N#define CAN_F9R2_FB1_Msk       (0x1UL << CAN_F9R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F9R2_FB1           CAN_F9R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F9R2_FB2_Pos       (2U)                                            
N#define CAN_F9R2_FB2_Msk       (0x1UL << CAN_F9R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F9R2_FB2           CAN_F9R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F9R2_FB3_Pos       (3U)                                            
N#define CAN_F9R2_FB3_Msk       (0x1UL << CAN_F9R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F9R2_FB3           CAN_F9R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F9R2_FB4_Pos       (4U)                                            
N#define CAN_F9R2_FB4_Msk       (0x1UL << CAN_F9R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F9R2_FB4           CAN_F9R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F9R2_FB5_Pos       (5U)                                            
N#define CAN_F9R2_FB5_Msk       (0x1UL << CAN_F9R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F9R2_FB5           CAN_F9R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F9R2_FB6_Pos       (6U)                                            
N#define CAN_F9R2_FB6_Msk       (0x1UL << CAN_F9R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F9R2_FB6           CAN_F9R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F9R2_FB7_Pos       (7U)                                            
N#define CAN_F9R2_FB7_Msk       (0x1UL << CAN_F9R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F9R2_FB7           CAN_F9R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F9R2_FB8_Pos       (8U)                                            
N#define CAN_F9R2_FB8_Msk       (0x1UL << CAN_F9R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F9R2_FB8           CAN_F9R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F9R2_FB9_Pos       (9U)                                            
N#define CAN_F9R2_FB9_Msk       (0x1UL << CAN_F9R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F9R2_FB9           CAN_F9R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F9R2_FB10_Pos      (10U)                                           
N#define CAN_F9R2_FB10_Msk      (0x1UL << CAN_F9R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F9R2_FB10          CAN_F9R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F9R2_FB11_Pos      (11U)                                           
N#define CAN_F9R2_FB11_Msk      (0x1UL << CAN_F9R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F9R2_FB11          CAN_F9R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F9R2_FB12_Pos      (12U)                                           
N#define CAN_F9R2_FB12_Msk      (0x1UL << CAN_F9R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F9R2_FB12          CAN_F9R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F9R2_FB13_Pos      (13U)                                           
N#define CAN_F9R2_FB13_Msk      (0x1UL << CAN_F9R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F9R2_FB13          CAN_F9R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F9R2_FB14_Pos      (14U)                                           
N#define CAN_F9R2_FB14_Msk      (0x1UL << CAN_F9R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F9R2_FB14          CAN_F9R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F9R2_FB15_Pos      (15U)                                           
N#define CAN_F9R2_FB15_Msk      (0x1UL << CAN_F9R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F9R2_FB15          CAN_F9R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F9R2_FB16_Pos      (16U)                                           
N#define CAN_F9R2_FB16_Msk      (0x1UL << CAN_F9R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F9R2_FB16          CAN_F9R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F9R2_FB17_Pos      (17U)                                           
N#define CAN_F9R2_FB17_Msk      (0x1UL << CAN_F9R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F9R2_FB17          CAN_F9R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F9R2_FB18_Pos      (18U)                                           
N#define CAN_F9R2_FB18_Msk      (0x1UL << CAN_F9R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F9R2_FB18          CAN_F9R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F9R2_FB19_Pos      (19U)                                           
N#define CAN_F9R2_FB19_Msk      (0x1UL << CAN_F9R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F9R2_FB19          CAN_F9R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F9R2_FB20_Pos      (20U)                                           
N#define CAN_F9R2_FB20_Msk      (0x1UL << CAN_F9R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F9R2_FB20          CAN_F9R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F9R2_FB21_Pos      (21U)                                           
N#define CAN_F9R2_FB21_Msk      (0x1UL << CAN_F9R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F9R2_FB21          CAN_F9R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F9R2_FB22_Pos      (22U)                                           
N#define CAN_F9R2_FB22_Msk      (0x1UL << CAN_F9R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F9R2_FB22          CAN_F9R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F9R2_FB23_Pos      (23U)                                           
N#define CAN_F9R2_FB23_Msk      (0x1UL << CAN_F9R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F9R2_FB23          CAN_F9R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F9R2_FB24_Pos      (24U)                                           
N#define CAN_F9R2_FB24_Msk      (0x1UL << CAN_F9R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F9R2_FB24          CAN_F9R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F9R2_FB25_Pos      (25U)                                           
N#define CAN_F9R2_FB25_Msk      (0x1UL << CAN_F9R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F9R2_FB25          CAN_F9R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F9R2_FB26_Pos      (26U)                                           
N#define CAN_F9R2_FB26_Msk      (0x1UL << CAN_F9R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F9R2_FB26          CAN_F9R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F9R2_FB27_Pos      (27U)                                           
N#define CAN_F9R2_FB27_Msk      (0x1UL << CAN_F9R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F9R2_FB27          CAN_F9R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F9R2_FB28_Pos      (28U)                                           
N#define CAN_F9R2_FB28_Msk      (0x1UL << CAN_F9R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F9R2_FB28          CAN_F9R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F9R2_FB29_Pos      (29U)                                           
N#define CAN_F9R2_FB29_Msk      (0x1UL << CAN_F9R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F9R2_FB29          CAN_F9R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F9R2_FB30_Pos      (30U)                                           
N#define CAN_F9R2_FB30_Msk      (0x1UL << CAN_F9R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F9R2_FB30          CAN_F9R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F9R2_FB31_Pos      (31U)                                           
N#define CAN_F9R2_FB31_Msk      (0x1UL << CAN_F9R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F9R2_FB31          CAN_F9R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R2 register  ******************/
N#define CAN_F10R2_FB0_Pos      (0U)                                            
N#define CAN_F10R2_FB0_Msk      (0x1UL << CAN_F10R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F10R2_FB0          CAN_F10R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F10R2_FB1_Pos      (1U)                                            
N#define CAN_F10R2_FB1_Msk      (0x1UL << CAN_F10R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F10R2_FB1          CAN_F10R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F10R2_FB2_Pos      (2U)                                            
N#define CAN_F10R2_FB2_Msk      (0x1UL << CAN_F10R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F10R2_FB2          CAN_F10R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F10R2_FB3_Pos      (3U)                                            
N#define CAN_F10R2_FB3_Msk      (0x1UL << CAN_F10R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F10R2_FB3          CAN_F10R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F10R2_FB4_Pos      (4U)                                            
N#define CAN_F10R2_FB4_Msk      (0x1UL << CAN_F10R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F10R2_FB4          CAN_F10R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F10R2_FB5_Pos      (5U)                                            
N#define CAN_F10R2_FB5_Msk      (0x1UL << CAN_F10R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F10R2_FB5          CAN_F10R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F10R2_FB6_Pos      (6U)                                            
N#define CAN_F10R2_FB6_Msk      (0x1UL << CAN_F10R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F10R2_FB6          CAN_F10R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F10R2_FB7_Pos      (7U)                                            
N#define CAN_F10R2_FB7_Msk      (0x1UL << CAN_F10R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F10R2_FB7          CAN_F10R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F10R2_FB8_Pos      (8U)                                            
N#define CAN_F10R2_FB8_Msk      (0x1UL << CAN_F10R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F10R2_FB8          CAN_F10R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F10R2_FB9_Pos      (9U)                                            
N#define CAN_F10R2_FB9_Msk      (0x1UL << CAN_F10R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F10R2_FB9          CAN_F10R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F10R2_FB10_Pos     (10U)                                           
N#define CAN_F10R2_FB10_Msk     (0x1UL << CAN_F10R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F10R2_FB10         CAN_F10R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F10R2_FB11_Pos     (11U)                                           
N#define CAN_F10R2_FB11_Msk     (0x1UL << CAN_F10R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F10R2_FB11         CAN_F10R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F10R2_FB12_Pos     (12U)                                           
N#define CAN_F10R2_FB12_Msk     (0x1UL << CAN_F10R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F10R2_FB12         CAN_F10R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F10R2_FB13_Pos     (13U)                                           
N#define CAN_F10R2_FB13_Msk     (0x1UL << CAN_F10R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F10R2_FB13         CAN_F10R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F10R2_FB14_Pos     (14U)                                           
N#define CAN_F10R2_FB14_Msk     (0x1UL << CAN_F10R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F10R2_FB14         CAN_F10R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F10R2_FB15_Pos     (15U)                                           
N#define CAN_F10R2_FB15_Msk     (0x1UL << CAN_F10R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F10R2_FB15         CAN_F10R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F10R2_FB16_Pos     (16U)                                           
N#define CAN_F10R2_FB16_Msk     (0x1UL << CAN_F10R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F10R2_FB16         CAN_F10R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F10R2_FB17_Pos     (17U)                                           
N#define CAN_F10R2_FB17_Msk     (0x1UL << CAN_F10R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F10R2_FB17         CAN_F10R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F10R2_FB18_Pos     (18U)                                           
N#define CAN_F10R2_FB18_Msk     (0x1UL << CAN_F10R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F10R2_FB18         CAN_F10R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F10R2_FB19_Pos     (19U)                                           
N#define CAN_F10R2_FB19_Msk     (0x1UL << CAN_F10R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F10R2_FB19         CAN_F10R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F10R2_FB20_Pos     (20U)                                           
N#define CAN_F10R2_FB20_Msk     (0x1UL << CAN_F10R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F10R2_FB20         CAN_F10R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F10R2_FB21_Pos     (21U)                                           
N#define CAN_F10R2_FB21_Msk     (0x1UL << CAN_F10R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F10R2_FB21         CAN_F10R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F10R2_FB22_Pos     (22U)                                           
N#define CAN_F10R2_FB22_Msk     (0x1UL << CAN_F10R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F10R2_FB22         CAN_F10R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F10R2_FB23_Pos     (23U)                                           
N#define CAN_F10R2_FB23_Msk     (0x1UL << CAN_F10R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F10R2_FB23         CAN_F10R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F10R2_FB24_Pos     (24U)                                           
N#define CAN_F10R2_FB24_Msk     (0x1UL << CAN_F10R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F10R2_FB24         CAN_F10R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F10R2_FB25_Pos     (25U)                                           
N#define CAN_F10R2_FB25_Msk     (0x1UL << CAN_F10R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F10R2_FB25         CAN_F10R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F10R2_FB26_Pos     (26U)                                           
N#define CAN_F10R2_FB26_Msk     (0x1UL << CAN_F10R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F10R2_FB26         CAN_F10R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F10R2_FB27_Pos     (27U)                                           
N#define CAN_F10R2_FB27_Msk     (0x1UL << CAN_F10R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F10R2_FB27         CAN_F10R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F10R2_FB28_Pos     (28U)                                           
N#define CAN_F10R2_FB28_Msk     (0x1UL << CAN_F10R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F10R2_FB28         CAN_F10R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F10R2_FB29_Pos     (29U)                                           
N#define CAN_F10R2_FB29_Msk     (0x1UL << CAN_F10R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F10R2_FB29         CAN_F10R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F10R2_FB30_Pos     (30U)                                           
N#define CAN_F10R2_FB30_Msk     (0x1UL << CAN_F10R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F10R2_FB30         CAN_F10R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F10R2_FB31_Pos     (31U)                                           
N#define CAN_F10R2_FB31_Msk     (0x1UL << CAN_F10R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F10R2_FB31         CAN_F10R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R2 register  ******************/
N#define CAN_F11R2_FB0_Pos      (0U)                                            
N#define CAN_F11R2_FB0_Msk      (0x1UL << CAN_F11R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F11R2_FB0          CAN_F11R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F11R2_FB1_Pos      (1U)                                            
N#define CAN_F11R2_FB1_Msk      (0x1UL << CAN_F11R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F11R2_FB1          CAN_F11R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F11R2_FB2_Pos      (2U)                                            
N#define CAN_F11R2_FB2_Msk      (0x1UL << CAN_F11R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F11R2_FB2          CAN_F11R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F11R2_FB3_Pos      (3U)                                            
N#define CAN_F11R2_FB3_Msk      (0x1UL << CAN_F11R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F11R2_FB3          CAN_F11R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F11R2_FB4_Pos      (4U)                                            
N#define CAN_F11R2_FB4_Msk      (0x1UL << CAN_F11R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F11R2_FB4          CAN_F11R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F11R2_FB5_Pos      (5U)                                            
N#define CAN_F11R2_FB5_Msk      (0x1UL << CAN_F11R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F11R2_FB5          CAN_F11R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F11R2_FB6_Pos      (6U)                                            
N#define CAN_F11R2_FB6_Msk      (0x1UL << CAN_F11R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F11R2_FB6          CAN_F11R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F11R2_FB7_Pos      (7U)                                            
N#define CAN_F11R2_FB7_Msk      (0x1UL << CAN_F11R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F11R2_FB7          CAN_F11R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F11R2_FB8_Pos      (8U)                                            
N#define CAN_F11R2_FB8_Msk      (0x1UL << CAN_F11R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F11R2_FB8          CAN_F11R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F11R2_FB9_Pos      (9U)                                            
N#define CAN_F11R2_FB9_Msk      (0x1UL << CAN_F11R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F11R2_FB9          CAN_F11R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F11R2_FB10_Pos     (10U)                                           
N#define CAN_F11R2_FB10_Msk     (0x1UL << CAN_F11R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F11R2_FB10         CAN_F11R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F11R2_FB11_Pos     (11U)                                           
N#define CAN_F11R2_FB11_Msk     (0x1UL << CAN_F11R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F11R2_FB11         CAN_F11R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F11R2_FB12_Pos     (12U)                                           
N#define CAN_F11R2_FB12_Msk     (0x1UL << CAN_F11R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F11R2_FB12         CAN_F11R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F11R2_FB13_Pos     (13U)                                           
N#define CAN_F11R2_FB13_Msk     (0x1UL << CAN_F11R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F11R2_FB13         CAN_F11R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F11R2_FB14_Pos     (14U)                                           
N#define CAN_F11R2_FB14_Msk     (0x1UL << CAN_F11R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F11R2_FB14         CAN_F11R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F11R2_FB15_Pos     (15U)                                           
N#define CAN_F11R2_FB15_Msk     (0x1UL << CAN_F11R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F11R2_FB15         CAN_F11R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F11R2_FB16_Pos     (16U)                                           
N#define CAN_F11R2_FB16_Msk     (0x1UL << CAN_F11R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F11R2_FB16         CAN_F11R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F11R2_FB17_Pos     (17U)                                           
N#define CAN_F11R2_FB17_Msk     (0x1UL << CAN_F11R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F11R2_FB17         CAN_F11R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F11R2_FB18_Pos     (18U)                                           
N#define CAN_F11R2_FB18_Msk     (0x1UL << CAN_F11R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F11R2_FB18         CAN_F11R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F11R2_FB19_Pos     (19U)                                           
N#define CAN_F11R2_FB19_Msk     (0x1UL << CAN_F11R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F11R2_FB19         CAN_F11R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F11R2_FB20_Pos     (20U)                                           
N#define CAN_F11R2_FB20_Msk     (0x1UL << CAN_F11R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F11R2_FB20         CAN_F11R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F11R2_FB21_Pos     (21U)                                           
N#define CAN_F11R2_FB21_Msk     (0x1UL << CAN_F11R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F11R2_FB21         CAN_F11R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F11R2_FB22_Pos     (22U)                                           
N#define CAN_F11R2_FB22_Msk     (0x1UL << CAN_F11R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F11R2_FB22         CAN_F11R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F11R2_FB23_Pos     (23U)                                           
N#define CAN_F11R2_FB23_Msk     (0x1UL << CAN_F11R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F11R2_FB23         CAN_F11R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F11R2_FB24_Pos     (24U)                                           
N#define CAN_F11R2_FB24_Msk     (0x1UL << CAN_F11R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F11R2_FB24         CAN_F11R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F11R2_FB25_Pos     (25U)                                           
N#define CAN_F11R2_FB25_Msk     (0x1UL << CAN_F11R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F11R2_FB25         CAN_F11R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F11R2_FB26_Pos     (26U)                                           
N#define CAN_F11R2_FB26_Msk     (0x1UL << CAN_F11R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F11R2_FB26         CAN_F11R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F11R2_FB27_Pos     (27U)                                           
N#define CAN_F11R2_FB27_Msk     (0x1UL << CAN_F11R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F11R2_FB27         CAN_F11R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F11R2_FB28_Pos     (28U)                                           
N#define CAN_F11R2_FB28_Msk     (0x1UL << CAN_F11R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F11R2_FB28         CAN_F11R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F11R2_FB29_Pos     (29U)                                           
N#define CAN_F11R2_FB29_Msk     (0x1UL << CAN_F11R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F11R2_FB29         CAN_F11R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F11R2_FB30_Pos     (30U)                                           
N#define CAN_F11R2_FB30_Msk     (0x1UL << CAN_F11R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F11R2_FB30         CAN_F11R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F11R2_FB31_Pos     (31U)                                           
N#define CAN_F11R2_FB31_Msk     (0x1UL << CAN_F11R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F11R2_FB31         CAN_F11R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R2 register  ******************/
N#define CAN_F12R2_FB0_Pos      (0U)                                            
N#define CAN_F12R2_FB0_Msk      (0x1UL << CAN_F12R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F12R2_FB0          CAN_F12R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F12R2_FB1_Pos      (1U)                                            
N#define CAN_F12R2_FB1_Msk      (0x1UL << CAN_F12R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F12R2_FB1          CAN_F12R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F12R2_FB2_Pos      (2U)                                            
N#define CAN_F12R2_FB2_Msk      (0x1UL << CAN_F12R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F12R2_FB2          CAN_F12R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F12R2_FB3_Pos      (3U)                                            
N#define CAN_F12R2_FB3_Msk      (0x1UL << CAN_F12R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F12R2_FB3          CAN_F12R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F12R2_FB4_Pos      (4U)                                            
N#define CAN_F12R2_FB4_Msk      (0x1UL << CAN_F12R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F12R2_FB4          CAN_F12R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F12R2_FB5_Pos      (5U)                                            
N#define CAN_F12R2_FB5_Msk      (0x1UL << CAN_F12R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F12R2_FB5          CAN_F12R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F12R2_FB6_Pos      (6U)                                            
N#define CAN_F12R2_FB6_Msk      (0x1UL << CAN_F12R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F12R2_FB6          CAN_F12R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F12R2_FB7_Pos      (7U)                                            
N#define CAN_F12R2_FB7_Msk      (0x1UL << CAN_F12R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F12R2_FB7          CAN_F12R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F12R2_FB8_Pos      (8U)                                            
N#define CAN_F12R2_FB8_Msk      (0x1UL << CAN_F12R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F12R2_FB8          CAN_F12R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F12R2_FB9_Pos      (9U)                                            
N#define CAN_F12R2_FB9_Msk      (0x1UL << CAN_F12R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F12R2_FB9          CAN_F12R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F12R2_FB10_Pos     (10U)                                           
N#define CAN_F12R2_FB10_Msk     (0x1UL << CAN_F12R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F12R2_FB10         CAN_F12R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F12R2_FB11_Pos     (11U)                                           
N#define CAN_F12R2_FB11_Msk     (0x1UL << CAN_F12R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F12R2_FB11         CAN_F12R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F12R2_FB12_Pos     (12U)                                           
N#define CAN_F12R2_FB12_Msk     (0x1UL << CAN_F12R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F12R2_FB12         CAN_F12R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F12R2_FB13_Pos     (13U)                                           
N#define CAN_F12R2_FB13_Msk     (0x1UL << CAN_F12R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F12R2_FB13         CAN_F12R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F12R2_FB14_Pos     (14U)                                           
N#define CAN_F12R2_FB14_Msk     (0x1UL << CAN_F12R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F12R2_FB14         CAN_F12R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F12R2_FB15_Pos     (15U)                                           
N#define CAN_F12R2_FB15_Msk     (0x1UL << CAN_F12R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F12R2_FB15         CAN_F12R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F12R2_FB16_Pos     (16U)                                           
N#define CAN_F12R2_FB16_Msk     (0x1UL << CAN_F12R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F12R2_FB16         CAN_F12R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F12R2_FB17_Pos     (17U)                                           
N#define CAN_F12R2_FB17_Msk     (0x1UL << CAN_F12R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F12R2_FB17         CAN_F12R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F12R2_FB18_Pos     (18U)                                           
N#define CAN_F12R2_FB18_Msk     (0x1UL << CAN_F12R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F12R2_FB18         CAN_F12R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F12R2_FB19_Pos     (19U)                                           
N#define CAN_F12R2_FB19_Msk     (0x1UL << CAN_F12R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F12R2_FB19         CAN_F12R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F12R2_FB20_Pos     (20U)                                           
N#define CAN_F12R2_FB20_Msk     (0x1UL << CAN_F12R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F12R2_FB20         CAN_F12R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F12R2_FB21_Pos     (21U)                                           
N#define CAN_F12R2_FB21_Msk     (0x1UL << CAN_F12R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F12R2_FB21         CAN_F12R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F12R2_FB22_Pos     (22U)                                           
N#define CAN_F12R2_FB22_Msk     (0x1UL << CAN_F12R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F12R2_FB22         CAN_F12R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F12R2_FB23_Pos     (23U)                                           
N#define CAN_F12R2_FB23_Msk     (0x1UL << CAN_F12R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F12R2_FB23         CAN_F12R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F12R2_FB24_Pos     (24U)                                           
N#define CAN_F12R2_FB24_Msk     (0x1UL << CAN_F12R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F12R2_FB24         CAN_F12R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F12R2_FB25_Pos     (25U)                                           
N#define CAN_F12R2_FB25_Msk     (0x1UL << CAN_F12R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F12R2_FB25         CAN_F12R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F12R2_FB26_Pos     (26U)                                           
N#define CAN_F12R2_FB26_Msk     (0x1UL << CAN_F12R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F12R2_FB26         CAN_F12R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F12R2_FB27_Pos     (27U)                                           
N#define CAN_F12R2_FB27_Msk     (0x1UL << CAN_F12R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F12R2_FB27         CAN_F12R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F12R2_FB28_Pos     (28U)                                           
N#define CAN_F12R2_FB28_Msk     (0x1UL << CAN_F12R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F12R2_FB28         CAN_F12R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F12R2_FB29_Pos     (29U)                                           
N#define CAN_F12R2_FB29_Msk     (0x1UL << CAN_F12R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F12R2_FB29         CAN_F12R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F12R2_FB30_Pos     (30U)                                           
N#define CAN_F12R2_FB30_Msk     (0x1UL << CAN_F12R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F12R2_FB30         CAN_F12R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F12R2_FB31_Pos     (31U)                                           
N#define CAN_F12R2_FB31_Msk     (0x1UL << CAN_F12R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F12R2_FB31         CAN_F12R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R2 register  ******************/
N#define CAN_F13R2_FB0_Pos      (0U)                                            
N#define CAN_F13R2_FB0_Msk      (0x1UL << CAN_F13R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F13R2_FB0          CAN_F13R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F13R2_FB1_Pos      (1U)                                            
N#define CAN_F13R2_FB1_Msk      (0x1UL << CAN_F13R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F13R2_FB1          CAN_F13R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F13R2_FB2_Pos      (2U)                                            
N#define CAN_F13R2_FB2_Msk      (0x1UL << CAN_F13R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F13R2_FB2          CAN_F13R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F13R2_FB3_Pos      (3U)                                            
N#define CAN_F13R2_FB3_Msk      (0x1UL << CAN_F13R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F13R2_FB3          CAN_F13R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F13R2_FB4_Pos      (4U)                                            
N#define CAN_F13R2_FB4_Msk      (0x1UL << CAN_F13R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F13R2_FB4          CAN_F13R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F13R2_FB5_Pos      (5U)                                            
N#define CAN_F13R2_FB5_Msk      (0x1UL << CAN_F13R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F13R2_FB5          CAN_F13R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F13R2_FB6_Pos      (6U)                                            
N#define CAN_F13R2_FB6_Msk      (0x1UL << CAN_F13R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F13R2_FB6          CAN_F13R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F13R2_FB7_Pos      (7U)                                            
N#define CAN_F13R2_FB7_Msk      (0x1UL << CAN_F13R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F13R2_FB7          CAN_F13R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F13R2_FB8_Pos      (8U)                                            
N#define CAN_F13R2_FB8_Msk      (0x1UL << CAN_F13R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F13R2_FB8          CAN_F13R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F13R2_FB9_Pos      (9U)                                            
N#define CAN_F13R2_FB9_Msk      (0x1UL << CAN_F13R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F13R2_FB9          CAN_F13R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F13R2_FB10_Pos     (10U)                                           
N#define CAN_F13R2_FB10_Msk     (0x1UL << CAN_F13R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F13R2_FB10         CAN_F13R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F13R2_FB11_Pos     (11U)                                           
N#define CAN_F13R2_FB11_Msk     (0x1UL << CAN_F13R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F13R2_FB11         CAN_F13R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F13R2_FB12_Pos     (12U)                                           
N#define CAN_F13R2_FB12_Msk     (0x1UL << CAN_F13R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F13R2_FB12         CAN_F13R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F13R2_FB13_Pos     (13U)                                           
N#define CAN_F13R2_FB13_Msk     (0x1UL << CAN_F13R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F13R2_FB13         CAN_F13R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F13R2_FB14_Pos     (14U)                                           
N#define CAN_F13R2_FB14_Msk     (0x1UL << CAN_F13R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F13R2_FB14         CAN_F13R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F13R2_FB15_Pos     (15U)                                           
N#define CAN_F13R2_FB15_Msk     (0x1UL << CAN_F13R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F13R2_FB15         CAN_F13R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F13R2_FB16_Pos     (16U)                                           
N#define CAN_F13R2_FB16_Msk     (0x1UL << CAN_F13R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F13R2_FB16         CAN_F13R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F13R2_FB17_Pos     (17U)                                           
N#define CAN_F13R2_FB17_Msk     (0x1UL << CAN_F13R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F13R2_FB17         CAN_F13R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F13R2_FB18_Pos     (18U)                                           
N#define CAN_F13R2_FB18_Msk     (0x1UL << CAN_F13R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F13R2_FB18         CAN_F13R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F13R2_FB19_Pos     (19U)                                           
N#define CAN_F13R2_FB19_Msk     (0x1UL << CAN_F13R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F13R2_FB19         CAN_F13R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F13R2_FB20_Pos     (20U)                                           
N#define CAN_F13R2_FB20_Msk     (0x1UL << CAN_F13R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F13R2_FB20         CAN_F13R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F13R2_FB21_Pos     (21U)                                           
N#define CAN_F13R2_FB21_Msk     (0x1UL << CAN_F13R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F13R2_FB21         CAN_F13R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F13R2_FB22_Pos     (22U)                                           
N#define CAN_F13R2_FB22_Msk     (0x1UL << CAN_F13R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F13R2_FB22         CAN_F13R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F13R2_FB23_Pos     (23U)                                           
N#define CAN_F13R2_FB23_Msk     (0x1UL << CAN_F13R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F13R2_FB23         CAN_F13R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F13R2_FB24_Pos     (24U)                                           
N#define CAN_F13R2_FB24_Msk     (0x1UL << CAN_F13R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F13R2_FB24         CAN_F13R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F13R2_FB25_Pos     (25U)                                           
N#define CAN_F13R2_FB25_Msk     (0x1UL << CAN_F13R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F13R2_FB25         CAN_F13R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F13R2_FB26_Pos     (26U)                                           
N#define CAN_F13R2_FB26_Msk     (0x1UL << CAN_F13R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F13R2_FB26         CAN_F13R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F13R2_FB27_Pos     (27U)                                           
N#define CAN_F13R2_FB27_Msk     (0x1UL << CAN_F13R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F13R2_FB27         CAN_F13R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F13R2_FB28_Pos     (28U)                                           
N#define CAN_F13R2_FB28_Msk     (0x1UL << CAN_F13R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F13R2_FB28         CAN_F13R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F13R2_FB29_Pos     (29U)                                           
N#define CAN_F13R2_FB29_Msk     (0x1UL << CAN_F13R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F13R2_FB29         CAN_F13R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F13R2_FB30_Pos     (30U)                                           
N#define CAN_F13R2_FB30_Msk     (0x1UL << CAN_F13R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F13R2_FB30         CAN_F13R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F13R2_FB31_Pos     (31U)                                           
N#define CAN_F13R2_FB31_Msk     (0x1UL << CAN_F13R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F13R2_FB31         CAN_F13R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRC calculation unit                              */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CRC_DR register  *********************/
N#define CRC_DR_DR_Pos       (0U)                                               
N#define CRC_DR_DR_Msk       (0xFFFFFFFFUL << CRC_DR_DR_Pos)                     /*!< 0xFFFFFFFF */
N#define CRC_DR_DR           CRC_DR_DR_Msk                                      /*!< Data register bits */
N
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define CRC_IDR_IDR_Pos     (0U)                                               
N#define CRC_IDR_IDR_Msk     (0xFFUL << CRC_IDR_IDR_Pos)                         /*!< 0x000000FF */
N#define CRC_IDR_IDR         CRC_IDR_IDR_Msk                                    /*!< General-purpose 8-bit data register bits */
N
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define CRC_CR_RESET_Pos    (0U)                                               
N#define CRC_CR_RESET_Msk    (0x1UL << CRC_CR_RESET_Pos)                         /*!< 0x00000001 */
N#define CRC_CR_RESET        CRC_CR_RESET_Msk                                   /*!< RESET bit */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Digital to Analog Converter                           */
N/*                                                                            */
N/******************************************************************************/
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F4 serie)
N */
N#define DAC_CHANNEL2_SUPPORT                                    /*!< DAC feature available only on specific devices: availability of DAC channel 2 */
N/********************  Bit definition for DAC_CR register  ********************/
N#define DAC_CR_EN1_Pos              (0U)                                       
N#define DAC_CR_EN1_Msk              (0x1UL << DAC_CR_EN1_Pos)                   /*!< 0x00000001 */
N#define DAC_CR_EN1                  DAC_CR_EN1_Msk                             /*!<DAC channel1 enable */
N#define DAC_CR_BOFF1_Pos            (1U)                                       
N#define DAC_CR_BOFF1_Msk            (0x1UL << DAC_CR_BOFF1_Pos)                 /*!< 0x00000002 */
N#define DAC_CR_BOFF1                DAC_CR_BOFF1_Msk                           /*!<DAC channel1 output buffer disable */
N#define DAC_CR_TEN1_Pos             (2U)                                       
N#define DAC_CR_TEN1_Msk             (0x1UL << DAC_CR_TEN1_Pos)                  /*!< 0x00000004 */
N#define DAC_CR_TEN1                 DAC_CR_TEN1_Msk                            /*!<DAC channel1 Trigger enable */
N
N#define DAC_CR_TSEL1_Pos            (3U)                                       
N#define DAC_CR_TSEL1_Msk            (0x7UL << DAC_CR_TSEL1_Pos)                 /*!< 0x00000038 */
N#define DAC_CR_TSEL1                DAC_CR_TSEL1_Msk                           /*!<TSEL1[2:0] (DAC channel1 Trigger selection) */
N#define DAC_CR_TSEL1_0              (0x1UL << DAC_CR_TSEL1_Pos)                 /*!< 0x00000008 */
N#define DAC_CR_TSEL1_1              (0x2UL << DAC_CR_TSEL1_Pos)                 /*!< 0x00000010 */
N#define DAC_CR_TSEL1_2              (0x4UL << DAC_CR_TSEL1_Pos)                 /*!< 0x00000020 */
N
N#define DAC_CR_WAVE1_Pos            (6U)                                       
N#define DAC_CR_WAVE1_Msk            (0x3UL << DAC_CR_WAVE1_Pos)                 /*!< 0x000000C0 */
N#define DAC_CR_WAVE1                DAC_CR_WAVE1_Msk                           /*!<WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
N#define DAC_CR_WAVE1_0              (0x1UL << DAC_CR_WAVE1_Pos)                 /*!< 0x00000040 */
N#define DAC_CR_WAVE1_1              (0x2UL << DAC_CR_WAVE1_Pos)                 /*!< 0x00000080 */
N
N#define DAC_CR_MAMP1_Pos            (8U)                                       
N#define DAC_CR_MAMP1_Msk            (0xFUL << DAC_CR_MAMP1_Pos)                 /*!< 0x00000F00 */
N#define DAC_CR_MAMP1                DAC_CR_MAMP1_Msk                           /*!<MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
N#define DAC_CR_MAMP1_0              (0x1UL << DAC_CR_MAMP1_Pos)                 /*!< 0x00000100 */
N#define DAC_CR_MAMP1_1              (0x2UL << DAC_CR_MAMP1_Pos)                 /*!< 0x00000200 */
N#define DAC_CR_MAMP1_2              (0x4UL << DAC_CR_MAMP1_Pos)                 /*!< 0x00000400 */
N#define DAC_CR_MAMP1_3              (0x8UL << DAC_CR_MAMP1_Pos)                 /*!< 0x00000800 */
N
N#define DAC_CR_DMAEN1_Pos           (12U)                                      
N#define DAC_CR_DMAEN1_Msk           (0x1UL << DAC_CR_DMAEN1_Pos)                /*!< 0x00001000 */
N#define DAC_CR_DMAEN1               DAC_CR_DMAEN1_Msk                          /*!<DAC channel1 DMA enable */
N#define DAC_CR_DMAUDRIE1_Pos        (13U)                                      
N#define DAC_CR_DMAUDRIE1_Msk        (0x1UL << DAC_CR_DMAUDRIE1_Pos)             /*!< 0x00002000 */
N#define DAC_CR_DMAUDRIE1            DAC_CR_DMAUDRIE1_Msk                       /*!<DAC channel1 DMA underrun interrupt enable*/
N#define DAC_CR_EN2_Pos              (16U)                                      
N#define DAC_CR_EN2_Msk              (0x1UL << DAC_CR_EN2_Pos)                   /*!< 0x00010000 */
N#define DAC_CR_EN2                  DAC_CR_EN2_Msk                             /*!<DAC channel2 enable */
N#define DAC_CR_BOFF2_Pos            (17U)                                      
N#define DAC_CR_BOFF2_Msk            (0x1UL << DAC_CR_BOFF2_Pos)                 /*!< 0x00020000 */
N#define DAC_CR_BOFF2                DAC_CR_BOFF2_Msk                           /*!<DAC channel2 output buffer disable */
N#define DAC_CR_TEN2_Pos             (18U)                                      
N#define DAC_CR_TEN2_Msk             (0x1UL << DAC_CR_TEN2_Pos)                  /*!< 0x00040000 */
N#define DAC_CR_TEN2                 DAC_CR_TEN2_Msk                            /*!<DAC channel2 Trigger enable */
N
N#define DAC_CR_TSEL2_Pos            (19U)                                      
N#define DAC_CR_TSEL2_Msk            (0x7UL << DAC_CR_TSEL2_Pos)                 /*!< 0x00380000 */
N#define DAC_CR_TSEL2                DAC_CR_TSEL2_Msk                           /*!<TSEL2[2:0] (DAC channel2 Trigger selection) */
N#define DAC_CR_TSEL2_0              (0x1UL << DAC_CR_TSEL2_Pos)                 /*!< 0x00080000 */
N#define DAC_CR_TSEL2_1              (0x2UL << DAC_CR_TSEL2_Pos)                 /*!< 0x00100000 */
N#define DAC_CR_TSEL2_2              (0x4UL << DAC_CR_TSEL2_Pos)                 /*!< 0x00200000 */
N
N#define DAC_CR_WAVE2_Pos            (22U)                                      
N#define DAC_CR_WAVE2_Msk            (0x3UL << DAC_CR_WAVE2_Pos)                 /*!< 0x00C00000 */
N#define DAC_CR_WAVE2                DAC_CR_WAVE2_Msk                           /*!<WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
N#define DAC_CR_WAVE2_0              (0x1UL << DAC_CR_WAVE2_Pos)                 /*!< 0x00400000 */
N#define DAC_CR_WAVE2_1              (0x2UL << DAC_CR_WAVE2_Pos)                 /*!< 0x00800000 */
N
N#define DAC_CR_MAMP2_Pos            (24U)                                      
N#define DAC_CR_MAMP2_Msk            (0xFUL << DAC_CR_MAMP2_Pos)                 /*!< 0x0F000000 */
N#define DAC_CR_MAMP2                DAC_CR_MAMP2_Msk                           /*!<MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
N#define DAC_CR_MAMP2_0              (0x1UL << DAC_CR_MAMP2_Pos)                 /*!< 0x01000000 */
N#define DAC_CR_MAMP2_1              (0x2UL << DAC_CR_MAMP2_Pos)                 /*!< 0x02000000 */
N#define DAC_CR_MAMP2_2              (0x4UL << DAC_CR_MAMP2_Pos)                 /*!< 0x04000000 */
N#define DAC_CR_MAMP2_3              (0x8UL << DAC_CR_MAMP2_Pos)                 /*!< 0x08000000 */
N
N#define DAC_CR_DMAEN2_Pos           (28U)                                      
N#define DAC_CR_DMAEN2_Msk           (0x1UL << DAC_CR_DMAEN2_Pos)                /*!< 0x10000000 */
N#define DAC_CR_DMAEN2               DAC_CR_DMAEN2_Msk                          /*!<DAC channel2 DMA enabled */
N#define DAC_CR_DMAUDRIE2_Pos        (29U)                                      
N#define DAC_CR_DMAUDRIE2_Msk        (0x1UL << DAC_CR_DMAUDRIE2_Pos)             /*!< 0x20000000 */
N#define DAC_CR_DMAUDRIE2            DAC_CR_DMAUDRIE2_Msk                       /*!<DAC channel2 DMA underrun interrupt enable*/
N
N/*****************  Bit definition for DAC_SWTRIGR register  ******************/
N#define DAC_SWTRIGR_SWTRIG1_Pos     (0U)                                       
N#define DAC_SWTRIGR_SWTRIG1_Msk     (0x1UL << DAC_SWTRIGR_SWTRIG1_Pos)          /*!< 0x00000001 */
N#define DAC_SWTRIGR_SWTRIG1         DAC_SWTRIGR_SWTRIG1_Msk                    /*!<DAC channel1 software trigger */
N#define DAC_SWTRIGR_SWTRIG2_Pos     (1U)                                       
N#define DAC_SWTRIGR_SWTRIG2_Msk     (0x1UL << DAC_SWTRIGR_SWTRIG2_Pos)          /*!< 0x00000002 */
N#define DAC_SWTRIGR_SWTRIG2         DAC_SWTRIGR_SWTRIG2_Msk                    /*!<DAC channel2 software trigger */
N
N/*****************  Bit definition for DAC_DHR12R1 register  ******************/
N#define DAC_DHR12R1_DACC1DHR_Pos    (0U)                                       
N#define DAC_DHR12R1_DACC1DHR_Msk    (0xFFFUL << DAC_DHR12R1_DACC1DHR_Pos)       /*!< 0x00000FFF */
N#define DAC_DHR12R1_DACC1DHR        DAC_DHR12R1_DACC1DHR_Msk                   /*!<DAC channel1 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L1 register  ******************/
N#define DAC_DHR12L1_DACC1DHR_Pos    (4U)                                       
N#define DAC_DHR12L1_DACC1DHR_Msk    (0xFFFUL << DAC_DHR12L1_DACC1DHR_Pos)       /*!< 0x0000FFF0 */
N#define DAC_DHR12L1_DACC1DHR        DAC_DHR12L1_DACC1DHR_Msk                   /*!<DAC channel1 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R1 register  ******************/
N#define DAC_DHR8R1_DACC1DHR_Pos     (0U)                                       
N#define DAC_DHR8R1_DACC1DHR_Msk     (0xFFUL << DAC_DHR8R1_DACC1DHR_Pos)         /*!< 0x000000FF */
N#define DAC_DHR8R1_DACC1DHR         DAC_DHR8R1_DACC1DHR_Msk                    /*!<DAC channel1 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12R2 register  ******************/
N#define DAC_DHR12R2_DACC2DHR_Pos    (0U)                                       
N#define DAC_DHR12R2_DACC2DHR_Msk    (0xFFFUL << DAC_DHR12R2_DACC2DHR_Pos)       /*!< 0x00000FFF */
N#define DAC_DHR12R2_DACC2DHR        DAC_DHR12R2_DACC2DHR_Msk                   /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L2 register  ******************/
N#define DAC_DHR12L2_DACC2DHR_Pos    (4U)                                       
N#define DAC_DHR12L2_DACC2DHR_Msk    (0xFFFUL << DAC_DHR12L2_DACC2DHR_Pos)       /*!< 0x0000FFF0 */
N#define DAC_DHR12L2_DACC2DHR        DAC_DHR12L2_DACC2DHR_Msk                   /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R2 register  ******************/
N#define DAC_DHR8R2_DACC2DHR_Pos     (0U)                                       
N#define DAC_DHR8R2_DACC2DHR_Msk     (0xFFUL << DAC_DHR8R2_DACC2DHR_Pos)         /*!< 0x000000FF */
N#define DAC_DHR8R2_DACC2DHR         DAC_DHR8R2_DACC2DHR_Msk                    /*!<DAC channel2 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12RD register  ******************/
N#define DAC_DHR12RD_DACC1DHR_Pos    (0U)                                       
N#define DAC_DHR12RD_DACC1DHR_Msk    (0xFFFUL << DAC_DHR12RD_DACC1DHR_Pos)       /*!< 0x00000FFF */
N#define DAC_DHR12RD_DACC1DHR        DAC_DHR12RD_DACC1DHR_Msk                   /*!<DAC channel1 12-bit Right aligned data */
N#define DAC_DHR12RD_DACC2DHR_Pos    (16U)                                      
N#define DAC_DHR12RD_DACC2DHR_Msk    (0xFFFUL << DAC_DHR12RD_DACC2DHR_Pos)       /*!< 0x0FFF0000 */
N#define DAC_DHR12RD_DACC2DHR        DAC_DHR12RD_DACC2DHR_Msk                   /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12LD register  ******************/
N#define DAC_DHR12LD_DACC1DHR_Pos    (4U)                                       
N#define DAC_DHR12LD_DACC1DHR_Msk    (0xFFFUL << DAC_DHR12LD_DACC1DHR_Pos)       /*!< 0x0000FFF0 */
N#define DAC_DHR12LD_DACC1DHR        DAC_DHR12LD_DACC1DHR_Msk                   /*!<DAC channel1 12-bit Left aligned data */
N#define DAC_DHR12LD_DACC2DHR_Pos    (20U)                                      
N#define DAC_DHR12LD_DACC2DHR_Msk    (0xFFFUL << DAC_DHR12LD_DACC2DHR_Pos)       /*!< 0xFFF00000 */
N#define DAC_DHR12LD_DACC2DHR        DAC_DHR12LD_DACC2DHR_Msk                   /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8RD register  ******************/
N#define DAC_DHR8RD_DACC1DHR_Pos     (0U)                                       
N#define DAC_DHR8RD_DACC1DHR_Msk     (0xFFUL << DAC_DHR8RD_DACC1DHR_Pos)         /*!< 0x000000FF */
N#define DAC_DHR8RD_DACC1DHR         DAC_DHR8RD_DACC1DHR_Msk                    /*!<DAC channel1 8-bit Right aligned data */
N#define DAC_DHR8RD_DACC2DHR_Pos     (8U)                                       
N#define DAC_DHR8RD_DACC2DHR_Msk     (0xFFUL << DAC_DHR8RD_DACC2DHR_Pos)         /*!< 0x0000FF00 */
N#define DAC_DHR8RD_DACC2DHR         DAC_DHR8RD_DACC2DHR_Msk                    /*!<DAC channel2 8-bit Right aligned data */
N
N/*******************  Bit definition for DAC_DOR1 register  *******************/
N#define DAC_DOR1_DACC1DOR_Pos       (0U)                                       
N#define DAC_DOR1_DACC1DOR_Msk       (0xFFFUL << DAC_DOR1_DACC1DOR_Pos)          /*!< 0x00000FFF */
N#define DAC_DOR1_DACC1DOR           DAC_DOR1_DACC1DOR_Msk                      /*!<DAC channel1 data output */
N
N/*******************  Bit definition for DAC_DOR2 register  *******************/
N#define DAC_DOR2_DACC2DOR_Pos       (0U)                                       
N#define DAC_DOR2_DACC2DOR_Msk       (0xFFFUL << DAC_DOR2_DACC2DOR_Pos)          /*!< 0x00000FFF */
N#define DAC_DOR2_DACC2DOR           DAC_DOR2_DACC2DOR_Msk                      /*!<DAC channel2 data output */
N
N/********************  Bit definition for DAC_SR register  ********************/
N#define DAC_SR_DMAUDR1_Pos          (13U)                                      
N#define DAC_SR_DMAUDR1_Msk          (0x1UL << DAC_SR_DMAUDR1_Pos)               /*!< 0x00002000 */
N#define DAC_SR_DMAUDR1              DAC_SR_DMAUDR1_Msk                         /*!<DAC channel1 DMA underrun flag */
N#define DAC_SR_DMAUDR2_Pos          (29U)                                      
N#define DAC_SR_DMAUDR2_Msk          (0x1UL << DAC_SR_DMAUDR2_Pos)               /*!< 0x20000000 */
N#define DAC_SR_DMAUDR2              DAC_SR_DMAUDR2_Msk                         /*!<DAC channel2 DMA underrun flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    DCMI                                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for DCMI_CR register  ******************/
N#define DCMI_CR_CAPTURE_Pos        (0U)                                        
N#define DCMI_CR_CAPTURE_Msk        (0x1UL << DCMI_CR_CAPTURE_Pos)               /*!< 0x00000001 */
N#define DCMI_CR_CAPTURE            DCMI_CR_CAPTURE_Msk                         
N#define DCMI_CR_CM_Pos             (1U)                                        
N#define DCMI_CR_CM_Msk             (0x1UL << DCMI_CR_CM_Pos)                    /*!< 0x00000002 */
N#define DCMI_CR_CM                 DCMI_CR_CM_Msk                              
N#define DCMI_CR_CROP_Pos           (2U)                                        
N#define DCMI_CR_CROP_Msk           (0x1UL << DCMI_CR_CROP_Pos)                  /*!< 0x00000004 */
N#define DCMI_CR_CROP               DCMI_CR_CROP_Msk                            
N#define DCMI_CR_JPEG_Pos           (3U)                                        
N#define DCMI_CR_JPEG_Msk           (0x1UL << DCMI_CR_JPEG_Pos)                  /*!< 0x00000008 */
N#define DCMI_CR_JPEG               DCMI_CR_JPEG_Msk                            
N#define DCMI_CR_ESS_Pos            (4U)                                        
N#define DCMI_CR_ESS_Msk            (0x1UL << DCMI_CR_ESS_Pos)                   /*!< 0x00000010 */
N#define DCMI_CR_ESS                DCMI_CR_ESS_Msk                             
N#define DCMI_CR_PCKPOL_Pos         (5U)                                        
N#define DCMI_CR_PCKPOL_Msk         (0x1UL << DCMI_CR_PCKPOL_Pos)                /*!< 0x00000020 */
N#define DCMI_CR_PCKPOL             DCMI_CR_PCKPOL_Msk                          
N#define DCMI_CR_HSPOL_Pos          (6U)                                        
N#define DCMI_CR_HSPOL_Msk          (0x1UL << DCMI_CR_HSPOL_Pos)                 /*!< 0x00000040 */
N#define DCMI_CR_HSPOL              DCMI_CR_HSPOL_Msk                           
N#define DCMI_CR_VSPOL_Pos          (7U)                                        
N#define DCMI_CR_VSPOL_Msk          (0x1UL << DCMI_CR_VSPOL_Pos)                 /*!< 0x00000080 */
N#define DCMI_CR_VSPOL              DCMI_CR_VSPOL_Msk                           
N#define DCMI_CR_FCRC_0             0x00000100U                                 
N#define DCMI_CR_FCRC_1             0x00000200U                                 
N#define DCMI_CR_EDM_0              0x00000400U                                 
N#define DCMI_CR_EDM_1              0x00000800U                                 
N#define DCMI_CR_CRE_Pos            (12U)                                       
N#define DCMI_CR_CRE_Msk            (0x1UL << DCMI_CR_CRE_Pos)                   /*!< 0x00001000 */
N#define DCMI_CR_CRE                DCMI_CR_CRE_Msk                             
N#define DCMI_CR_ENABLE_Pos         (14U)                                       
N#define DCMI_CR_ENABLE_Msk         (0x1UL << DCMI_CR_ENABLE_Pos)                /*!< 0x00004000 */
N#define DCMI_CR_ENABLE             DCMI_CR_ENABLE_Msk                          
N
N/********************  Bits definition for DCMI_SR register  ******************/
N#define DCMI_SR_HSYNC_Pos          (0U)                                        
N#define DCMI_SR_HSYNC_Msk          (0x1UL << DCMI_SR_HSYNC_Pos)                 /*!< 0x00000001 */
N#define DCMI_SR_HSYNC              DCMI_SR_HSYNC_Msk                           
N#define DCMI_SR_VSYNC_Pos          (1U)                                        
N#define DCMI_SR_VSYNC_Msk          (0x1UL << DCMI_SR_VSYNC_Pos)                 /*!< 0x00000002 */
N#define DCMI_SR_VSYNC              DCMI_SR_VSYNC_Msk                           
N#define DCMI_SR_FNE_Pos            (2U)                                        
N#define DCMI_SR_FNE_Msk            (0x1UL << DCMI_SR_FNE_Pos)                   /*!< 0x00000004 */
N#define DCMI_SR_FNE                DCMI_SR_FNE_Msk                             
N
N/********************  Bits definition for DCMI_RIS register  *****************/
N#define DCMI_RIS_FRAME_RIS_Pos     (0U)                                        
N#define DCMI_RIS_FRAME_RIS_Msk     (0x1UL << DCMI_RIS_FRAME_RIS_Pos)            /*!< 0x00000001 */
N#define DCMI_RIS_FRAME_RIS         DCMI_RIS_FRAME_RIS_Msk                      
N#define DCMI_RIS_OVR_RIS_Pos       (1U)                                        
N#define DCMI_RIS_OVR_RIS_Msk       (0x1UL << DCMI_RIS_OVR_RIS_Pos)              /*!< 0x00000002 */
N#define DCMI_RIS_OVR_RIS           DCMI_RIS_OVR_RIS_Msk                        
N#define DCMI_RIS_ERR_RIS_Pos       (2U)                                        
N#define DCMI_RIS_ERR_RIS_Msk       (0x1UL << DCMI_RIS_ERR_RIS_Pos)              /*!< 0x00000004 */
N#define DCMI_RIS_ERR_RIS           DCMI_RIS_ERR_RIS_Msk                        
N#define DCMI_RIS_VSYNC_RIS_Pos     (3U)                                        
N#define DCMI_RIS_VSYNC_RIS_Msk     (0x1UL << DCMI_RIS_VSYNC_RIS_Pos)            /*!< 0x00000008 */
N#define DCMI_RIS_VSYNC_RIS         DCMI_RIS_VSYNC_RIS_Msk                      
N#define DCMI_RIS_LINE_RIS_Pos      (4U)                                        
N#define DCMI_RIS_LINE_RIS_Msk      (0x1UL << DCMI_RIS_LINE_RIS_Pos)             /*!< 0x00000010 */
N#define DCMI_RIS_LINE_RIS          DCMI_RIS_LINE_RIS_Msk                       
N/* Legacy defines */
N#define DCMI_RISR_FRAME_RIS                  DCMI_RIS_FRAME_RIS
N#define DCMI_RISR_OVR_RIS                    DCMI_RIS_OVR_RIS
N#define DCMI_RISR_ERR_RIS                    DCMI_RIS_ERR_RIS
N#define DCMI_RISR_VSYNC_RIS                  DCMI_RIS_VSYNC_RIS
N#define DCMI_RISR_LINE_RIS                   DCMI_RIS_LINE_RIS
N#define DCMI_RISR_OVF_RIS                    DCMI_RIS_OVR_RIS
N
N/********************  Bits definition for DCMI_IER register  *****************/
N#define DCMI_IER_FRAME_IE_Pos      (0U)                                        
N#define DCMI_IER_FRAME_IE_Msk      (0x1UL << DCMI_IER_FRAME_IE_Pos)             /*!< 0x00000001 */
N#define DCMI_IER_FRAME_IE          DCMI_IER_FRAME_IE_Msk                       
N#define DCMI_IER_OVR_IE_Pos        (1U)                                        
N#define DCMI_IER_OVR_IE_Msk        (0x1UL << DCMI_IER_OVR_IE_Pos)               /*!< 0x00000002 */
N#define DCMI_IER_OVR_IE            DCMI_IER_OVR_IE_Msk                         
N#define DCMI_IER_ERR_IE_Pos        (2U)                                        
N#define DCMI_IER_ERR_IE_Msk        (0x1UL << DCMI_IER_ERR_IE_Pos)               /*!< 0x00000004 */
N#define DCMI_IER_ERR_IE            DCMI_IER_ERR_IE_Msk                         
N#define DCMI_IER_VSYNC_IE_Pos      (3U)                                        
N#define DCMI_IER_VSYNC_IE_Msk      (0x1UL << DCMI_IER_VSYNC_IE_Pos)             /*!< 0x00000008 */
N#define DCMI_IER_VSYNC_IE          DCMI_IER_VSYNC_IE_Msk                       
N#define DCMI_IER_LINE_IE_Pos       (4U)                                        
N#define DCMI_IER_LINE_IE_Msk       (0x1UL << DCMI_IER_LINE_IE_Pos)              /*!< 0x00000010 */
N#define DCMI_IER_LINE_IE           DCMI_IER_LINE_IE_Msk                        
N/* Legacy defines */
N#define DCMI_IER_OVF_IE                      DCMI_IER_OVR_IE
N
N/********************  Bits definition for DCMI_MIS register  *****************/
N#define DCMI_MIS_FRAME_MIS_Pos     (0U)                                        
N#define DCMI_MIS_FRAME_MIS_Msk     (0x1UL << DCMI_MIS_FRAME_MIS_Pos)            /*!< 0x00000001 */
N#define DCMI_MIS_FRAME_MIS         DCMI_MIS_FRAME_MIS_Msk                      
N#define DCMI_MIS_OVR_MIS_Pos       (1U)                                        
N#define DCMI_MIS_OVR_MIS_Msk       (0x1UL << DCMI_MIS_OVR_MIS_Pos)              /*!< 0x00000002 */
N#define DCMI_MIS_OVR_MIS           DCMI_MIS_OVR_MIS_Msk                        
N#define DCMI_MIS_ERR_MIS_Pos       (2U)                                        
N#define DCMI_MIS_ERR_MIS_Msk       (0x1UL << DCMI_MIS_ERR_MIS_Pos)              /*!< 0x00000004 */
N#define DCMI_MIS_ERR_MIS           DCMI_MIS_ERR_MIS_Msk                        
N#define DCMI_MIS_VSYNC_MIS_Pos     (3U)                                        
N#define DCMI_MIS_VSYNC_MIS_Msk     (0x1UL << DCMI_MIS_VSYNC_MIS_Pos)            /*!< 0x00000008 */
N#define DCMI_MIS_VSYNC_MIS         DCMI_MIS_VSYNC_MIS_Msk                      
N#define DCMI_MIS_LINE_MIS_Pos      (4U)                                        
N#define DCMI_MIS_LINE_MIS_Msk      (0x1UL << DCMI_MIS_LINE_MIS_Pos)             /*!< 0x00000010 */
N#define DCMI_MIS_LINE_MIS          DCMI_MIS_LINE_MIS_Msk                       
N
N/* Legacy defines */
N#define DCMI_MISR_FRAME_MIS                  DCMI_MIS_FRAME_MIS
N#define DCMI_MISR_OVF_MIS                    DCMI_MIS_OVR_MIS
N#define DCMI_MISR_ERR_MIS                    DCMI_MIS_ERR_MIS
N#define DCMI_MISR_VSYNC_MIS                  DCMI_MIS_VSYNC_MIS
N#define DCMI_MISR_LINE_MIS                   DCMI_MIS_LINE_MIS
N
N/********************  Bits definition for DCMI_ICR register  *****************/
N#define DCMI_ICR_FRAME_ISC_Pos     (0U)                                        
N#define DCMI_ICR_FRAME_ISC_Msk     (0x1UL << DCMI_ICR_FRAME_ISC_Pos)            /*!< 0x00000001 */
N#define DCMI_ICR_FRAME_ISC         DCMI_ICR_FRAME_ISC_Msk                      
N#define DCMI_ICR_OVR_ISC_Pos       (1U)                                        
N#define DCMI_ICR_OVR_ISC_Msk       (0x1UL << DCMI_ICR_OVR_ISC_Pos)              /*!< 0x00000002 */
N#define DCMI_ICR_OVR_ISC           DCMI_ICR_OVR_ISC_Msk                        
N#define DCMI_ICR_ERR_ISC_Pos       (2U)                                        
N#define DCMI_ICR_ERR_ISC_Msk       (0x1UL << DCMI_ICR_ERR_ISC_Pos)              /*!< 0x00000004 */
N#define DCMI_ICR_ERR_ISC           DCMI_ICR_ERR_ISC_Msk                        
N#define DCMI_ICR_VSYNC_ISC_Pos     (3U)                                        
N#define DCMI_ICR_VSYNC_ISC_Msk     (0x1UL << DCMI_ICR_VSYNC_ISC_Pos)            /*!< 0x00000008 */
N#define DCMI_ICR_VSYNC_ISC         DCMI_ICR_VSYNC_ISC_Msk                      
N#define DCMI_ICR_LINE_ISC_Pos      (4U)                                        
N#define DCMI_ICR_LINE_ISC_Msk      (0x1UL << DCMI_ICR_LINE_ISC_Pos)             /*!< 0x00000010 */
N#define DCMI_ICR_LINE_ISC          DCMI_ICR_LINE_ISC_Msk                       
N
N/* Legacy defines */
N#define DCMI_ICR_OVF_ISC                     DCMI_ICR_OVR_ISC
N
N/********************  Bits definition for DCMI_ESCR register  ******************/
N#define DCMI_ESCR_FSC_Pos          (0U)                                        
N#define DCMI_ESCR_FSC_Msk          (0xFFUL << DCMI_ESCR_FSC_Pos)                /*!< 0x000000FF */
N#define DCMI_ESCR_FSC              DCMI_ESCR_FSC_Msk                           
N#define DCMI_ESCR_LSC_Pos          (8U)                                        
N#define DCMI_ESCR_LSC_Msk          (0xFFUL << DCMI_ESCR_LSC_Pos)                /*!< 0x0000FF00 */
N#define DCMI_ESCR_LSC              DCMI_ESCR_LSC_Msk                           
N#define DCMI_ESCR_LEC_Pos          (16U)                                       
N#define DCMI_ESCR_LEC_Msk          (0xFFUL << DCMI_ESCR_LEC_Pos)                /*!< 0x00FF0000 */
N#define DCMI_ESCR_LEC              DCMI_ESCR_LEC_Msk                           
N#define DCMI_ESCR_FEC_Pos          (24U)                                       
N#define DCMI_ESCR_FEC_Msk          (0xFFUL << DCMI_ESCR_FEC_Pos)                /*!< 0xFF000000 */
N#define DCMI_ESCR_FEC              DCMI_ESCR_FEC_Msk                           
N
N/********************  Bits definition for DCMI_ESUR register  ******************/
N#define DCMI_ESUR_FSU_Pos          (0U)                                        
N#define DCMI_ESUR_FSU_Msk          (0xFFUL << DCMI_ESUR_FSU_Pos)                /*!< 0x000000FF */
N#define DCMI_ESUR_FSU              DCMI_ESUR_FSU_Msk                           
N#define DCMI_ESUR_LSU_Pos          (8U)                                        
N#define DCMI_ESUR_LSU_Msk          (0xFFUL << DCMI_ESUR_LSU_Pos)                /*!< 0x0000FF00 */
N#define DCMI_ESUR_LSU              DCMI_ESUR_LSU_Msk                           
N#define DCMI_ESUR_LEU_Pos          (16U)                                       
N#define DCMI_ESUR_LEU_Msk          (0xFFUL << DCMI_ESUR_LEU_Pos)                /*!< 0x00FF0000 */
N#define DCMI_ESUR_LEU              DCMI_ESUR_LEU_Msk                           
N#define DCMI_ESUR_FEU_Pos          (24U)                                       
N#define DCMI_ESUR_FEU_Msk          (0xFFUL << DCMI_ESUR_FEU_Pos)                /*!< 0xFF000000 */
N#define DCMI_ESUR_FEU              DCMI_ESUR_FEU_Msk                           
N
N/********************  Bits definition for DCMI_CWSTRT register  ******************/
N#define DCMI_CWSTRT_HOFFCNT_Pos    (0U)                                        
N#define DCMI_CWSTRT_HOFFCNT_Msk    (0x3FFFUL << DCMI_CWSTRT_HOFFCNT_Pos)        /*!< 0x00003FFF */
N#define DCMI_CWSTRT_HOFFCNT        DCMI_CWSTRT_HOFFCNT_Msk                     
N#define DCMI_CWSTRT_VST_Pos        (16U)                                       
N#define DCMI_CWSTRT_VST_Msk        (0x1FFFUL << DCMI_CWSTRT_VST_Pos)            /*!< 0x1FFF0000 */
N#define DCMI_CWSTRT_VST            DCMI_CWSTRT_VST_Msk                         
N
N/********************  Bits definition for DCMI_CWSIZE register  ******************/
N#define DCMI_CWSIZE_CAPCNT_Pos     (0U)                                        
N#define DCMI_CWSIZE_CAPCNT_Msk     (0x3FFFUL << DCMI_CWSIZE_CAPCNT_Pos)         /*!< 0x00003FFF */
N#define DCMI_CWSIZE_CAPCNT         DCMI_CWSIZE_CAPCNT_Msk                      
N#define DCMI_CWSIZE_VLINE_Pos      (16U)                                       
N#define DCMI_CWSIZE_VLINE_Msk      (0x3FFFUL << DCMI_CWSIZE_VLINE_Pos)          /*!< 0x3FFF0000 */
N#define DCMI_CWSIZE_VLINE          DCMI_CWSIZE_VLINE_Msk                       
N
N/********************  Bits definition for DCMI_DR register  *********************/
N#define DCMI_DR_BYTE0_Pos          (0U)                                        
N#define DCMI_DR_BYTE0_Msk          (0xFFUL << DCMI_DR_BYTE0_Pos)                /*!< 0x000000FF */
N#define DCMI_DR_BYTE0              DCMI_DR_BYTE0_Msk                           
N#define DCMI_DR_BYTE1_Pos          (8U)                                        
N#define DCMI_DR_BYTE1_Msk          (0xFFUL << DCMI_DR_BYTE1_Pos)                /*!< 0x0000FF00 */
N#define DCMI_DR_BYTE1              DCMI_DR_BYTE1_Msk                           
N#define DCMI_DR_BYTE2_Pos          (16U)                                       
N#define DCMI_DR_BYTE2_Msk          (0xFFUL << DCMI_DR_BYTE2_Pos)                /*!< 0x00FF0000 */
N#define DCMI_DR_BYTE2              DCMI_DR_BYTE2_Msk                           
N#define DCMI_DR_BYTE3_Pos          (24U)                                       
N#define DCMI_DR_BYTE3_Msk          (0xFFUL << DCMI_DR_BYTE3_Pos)                /*!< 0xFF000000 */
N#define DCMI_DR_BYTE3              DCMI_DR_BYTE3_Msk                           
N
N/******************************************************************************/
N/*                                                                            */
N/*                             DMA Controller                                 */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for DMA_SxCR register  *****************/
N#define DMA_SxCR_CHSEL_Pos       (25U)                                         
N#define DMA_SxCR_CHSEL_Msk       (0x7UL << DMA_SxCR_CHSEL_Pos)                  /*!< 0x0E000000 */
N#define DMA_SxCR_CHSEL           DMA_SxCR_CHSEL_Msk                            
N#define DMA_SxCR_CHSEL_0         0x02000000U                                   
N#define DMA_SxCR_CHSEL_1         0x04000000U                                   
N#define DMA_SxCR_CHSEL_2         0x08000000U                                   
N#define DMA_SxCR_MBURST_Pos      (23U)                                         
N#define DMA_SxCR_MBURST_Msk      (0x3UL << DMA_SxCR_MBURST_Pos)                 /*!< 0x01800000 */
N#define DMA_SxCR_MBURST          DMA_SxCR_MBURST_Msk                           
N#define DMA_SxCR_MBURST_0        (0x1UL << DMA_SxCR_MBURST_Pos)                 /*!< 0x00800000 */
N#define DMA_SxCR_MBURST_1        (0x2UL << DMA_SxCR_MBURST_Pos)                 /*!< 0x01000000 */
N#define DMA_SxCR_PBURST_Pos      (21U)                                         
N#define DMA_SxCR_PBURST_Msk      (0x3UL << DMA_SxCR_PBURST_Pos)                 /*!< 0x00600000 */
N#define DMA_SxCR_PBURST          DMA_SxCR_PBURST_Msk                           
N#define DMA_SxCR_PBURST_0        (0x1UL << DMA_SxCR_PBURST_Pos)                 /*!< 0x00200000 */
N#define DMA_SxCR_PBURST_1        (0x2UL << DMA_SxCR_PBURST_Pos)                 /*!< 0x00400000 */
N#define DMA_SxCR_CT_Pos          (19U)                                         
N#define DMA_SxCR_CT_Msk          (0x1UL << DMA_SxCR_CT_Pos)                     /*!< 0x00080000 */
N#define DMA_SxCR_CT              DMA_SxCR_CT_Msk                               
N#define DMA_SxCR_DBM_Pos         (18U)                                         
N#define DMA_SxCR_DBM_Msk         (0x1UL << DMA_SxCR_DBM_Pos)                    /*!< 0x00040000 */
N#define DMA_SxCR_DBM             DMA_SxCR_DBM_Msk                              
N#define DMA_SxCR_PL_Pos          (16U)                                         
N#define DMA_SxCR_PL_Msk          (0x3UL << DMA_SxCR_PL_Pos)                     /*!< 0x00030000 */
N#define DMA_SxCR_PL              DMA_SxCR_PL_Msk                               
N#define DMA_SxCR_PL_0            (0x1UL << DMA_SxCR_PL_Pos)                     /*!< 0x00010000 */
N#define DMA_SxCR_PL_1            (0x2UL << DMA_SxCR_PL_Pos)                     /*!< 0x00020000 */
N#define DMA_SxCR_PINCOS_Pos      (15U)                                         
N#define DMA_SxCR_PINCOS_Msk      (0x1UL << DMA_SxCR_PINCOS_Pos)                 /*!< 0x00008000 */
N#define DMA_SxCR_PINCOS          DMA_SxCR_PINCOS_Msk                           
N#define DMA_SxCR_MSIZE_Pos       (13U)                                         
N#define DMA_SxCR_MSIZE_Msk       (0x3UL << DMA_SxCR_MSIZE_Pos)                  /*!< 0x00006000 */
N#define DMA_SxCR_MSIZE           DMA_SxCR_MSIZE_Msk                            
N#define DMA_SxCR_MSIZE_0         (0x1UL << DMA_SxCR_MSIZE_Pos)                  /*!< 0x00002000 */
N#define DMA_SxCR_MSIZE_1         (0x2UL << DMA_SxCR_MSIZE_Pos)                  /*!< 0x00004000 */
N#define DMA_SxCR_PSIZE_Pos       (11U)                                         
N#define DMA_SxCR_PSIZE_Msk       (0x3UL << DMA_SxCR_PSIZE_Pos)                  /*!< 0x00001800 */
N#define DMA_SxCR_PSIZE           DMA_SxCR_PSIZE_Msk                            
N#define DMA_SxCR_PSIZE_0         (0x1UL << DMA_SxCR_PSIZE_Pos)                  /*!< 0x00000800 */
N#define DMA_SxCR_PSIZE_1         (0x2UL << DMA_SxCR_PSIZE_Pos)                  /*!< 0x00001000 */
N#define DMA_SxCR_MINC_Pos        (10U)                                         
N#define DMA_SxCR_MINC_Msk        (0x1UL << DMA_SxCR_MINC_Pos)                   /*!< 0x00000400 */
N#define DMA_SxCR_MINC            DMA_SxCR_MINC_Msk                             
N#define DMA_SxCR_PINC_Pos        (9U)                                          
N#define DMA_SxCR_PINC_Msk        (0x1UL << DMA_SxCR_PINC_Pos)                   /*!< 0x00000200 */
N#define DMA_SxCR_PINC            DMA_SxCR_PINC_Msk                             
N#define DMA_SxCR_CIRC_Pos        (8U)                                          
N#define DMA_SxCR_CIRC_Msk        (0x1UL << DMA_SxCR_CIRC_Pos)                   /*!< 0x00000100 */
N#define DMA_SxCR_CIRC            DMA_SxCR_CIRC_Msk                             
N#define DMA_SxCR_DIR_Pos         (6U)                                          
N#define DMA_SxCR_DIR_Msk         (0x3UL << DMA_SxCR_DIR_Pos)                    /*!< 0x000000C0 */
N#define DMA_SxCR_DIR             DMA_SxCR_DIR_Msk                              
N#define DMA_SxCR_DIR_0           (0x1UL << DMA_SxCR_DIR_Pos)                    /*!< 0x00000040 */
N#define DMA_SxCR_DIR_1           (0x2UL << DMA_SxCR_DIR_Pos)                    /*!< 0x00000080 */
N#define DMA_SxCR_PFCTRL_Pos      (5U)                                          
N#define DMA_SxCR_PFCTRL_Msk      (0x1UL << DMA_SxCR_PFCTRL_Pos)                 /*!< 0x00000020 */
N#define DMA_SxCR_PFCTRL          DMA_SxCR_PFCTRL_Msk                           
N#define DMA_SxCR_TCIE_Pos        (4U)                                          
N#define DMA_SxCR_TCIE_Msk        (0x1UL << DMA_SxCR_TCIE_Pos)                   /*!< 0x00000010 */
N#define DMA_SxCR_TCIE            DMA_SxCR_TCIE_Msk                             
N#define DMA_SxCR_HTIE_Pos        (3U)                                          
N#define DMA_SxCR_HTIE_Msk        (0x1UL << DMA_SxCR_HTIE_Pos)                   /*!< 0x00000008 */
N#define DMA_SxCR_HTIE            DMA_SxCR_HTIE_Msk                             
N#define DMA_SxCR_TEIE_Pos        (2U)                                          
N#define DMA_SxCR_TEIE_Msk        (0x1UL << DMA_SxCR_TEIE_Pos)                   /*!< 0x00000004 */
N#define DMA_SxCR_TEIE            DMA_SxCR_TEIE_Msk                             
N#define DMA_SxCR_DMEIE_Pos       (1U)                                          
N#define DMA_SxCR_DMEIE_Msk       (0x1UL << DMA_SxCR_DMEIE_Pos)                  /*!< 0x00000002 */
N#define DMA_SxCR_DMEIE           DMA_SxCR_DMEIE_Msk                            
N#define DMA_SxCR_EN_Pos          (0U)                                          
N#define DMA_SxCR_EN_Msk          (0x1UL << DMA_SxCR_EN_Pos)                     /*!< 0x00000001 */
N#define DMA_SxCR_EN              DMA_SxCR_EN_Msk                               
N
N/* Legacy defines */
N#define DMA_SxCR_ACK_Pos         (20U)                                         
N#define DMA_SxCR_ACK_Msk         (0x1UL << DMA_SxCR_ACK_Pos)                    /*!< 0x00100000 */
N#define DMA_SxCR_ACK             DMA_SxCR_ACK_Msk                              
N
N/********************  Bits definition for DMA_SxCNDTR register  **************/
N#define DMA_SxNDT_Pos            (0U)                                          
N#define DMA_SxNDT_Msk            (0xFFFFUL << DMA_SxNDT_Pos)                    /*!< 0x0000FFFF */
N#define DMA_SxNDT                DMA_SxNDT_Msk                                 
N#define DMA_SxNDT_0              (0x0001UL << DMA_SxNDT_Pos)                    /*!< 0x00000001 */
N#define DMA_SxNDT_1              (0x0002UL << DMA_SxNDT_Pos)                    /*!< 0x00000002 */
N#define DMA_SxNDT_2              (0x0004UL << DMA_SxNDT_Pos)                    /*!< 0x00000004 */
N#define DMA_SxNDT_3              (0x0008UL << DMA_SxNDT_Pos)                    /*!< 0x00000008 */
N#define DMA_SxNDT_4              (0x0010UL << DMA_SxNDT_Pos)                    /*!< 0x00000010 */
N#define DMA_SxNDT_5              (0x0020UL << DMA_SxNDT_Pos)                    /*!< 0x00000020 */
N#define DMA_SxNDT_6              (0x0040UL << DMA_SxNDT_Pos)                    /*!< 0x00000040 */
N#define DMA_SxNDT_7              (0x0080UL << DMA_SxNDT_Pos)                    /*!< 0x00000080 */
N#define DMA_SxNDT_8              (0x0100UL << DMA_SxNDT_Pos)                    /*!< 0x00000100 */
N#define DMA_SxNDT_9              (0x0200UL << DMA_SxNDT_Pos)                    /*!< 0x00000200 */
N#define DMA_SxNDT_10             (0x0400UL << DMA_SxNDT_Pos)                    /*!< 0x00000400 */
N#define DMA_SxNDT_11             (0x0800UL << DMA_SxNDT_Pos)                    /*!< 0x00000800 */
N#define DMA_SxNDT_12             (0x1000UL << DMA_SxNDT_Pos)                    /*!< 0x00001000 */
N#define DMA_SxNDT_13             (0x2000UL << DMA_SxNDT_Pos)                    /*!< 0x00002000 */
N#define DMA_SxNDT_14             (0x4000UL << DMA_SxNDT_Pos)                    /*!< 0x00004000 */
N#define DMA_SxNDT_15             (0x8000UL << DMA_SxNDT_Pos)                    /*!< 0x00008000 */
N
N/********************  Bits definition for DMA_SxFCR register  ****************/ 
N#define DMA_SxFCR_FEIE_Pos       (7U)                                          
N#define DMA_SxFCR_FEIE_Msk       (0x1UL << DMA_SxFCR_FEIE_Pos)                  /*!< 0x00000080 */
N#define DMA_SxFCR_FEIE           DMA_SxFCR_FEIE_Msk                            
N#define DMA_SxFCR_FS_Pos         (3U)                                          
N#define DMA_SxFCR_FS_Msk         (0x7UL << DMA_SxFCR_FS_Pos)                    /*!< 0x00000038 */
N#define DMA_SxFCR_FS             DMA_SxFCR_FS_Msk                              
N#define DMA_SxFCR_FS_0           (0x1UL << DMA_SxFCR_FS_Pos)                    /*!< 0x00000008 */
N#define DMA_SxFCR_FS_1           (0x2UL << DMA_SxFCR_FS_Pos)                    /*!< 0x00000010 */
N#define DMA_SxFCR_FS_2           (0x4UL << DMA_SxFCR_FS_Pos)                    /*!< 0x00000020 */
N#define DMA_SxFCR_DMDIS_Pos      (2U)                                          
N#define DMA_SxFCR_DMDIS_Msk      (0x1UL << DMA_SxFCR_DMDIS_Pos)                 /*!< 0x00000004 */
N#define DMA_SxFCR_DMDIS          DMA_SxFCR_DMDIS_Msk                           
N#define DMA_SxFCR_FTH_Pos        (0U)                                          
N#define DMA_SxFCR_FTH_Msk        (0x3UL << DMA_SxFCR_FTH_Pos)                   /*!< 0x00000003 */
N#define DMA_SxFCR_FTH            DMA_SxFCR_FTH_Msk                             
N#define DMA_SxFCR_FTH_0          (0x1UL << DMA_SxFCR_FTH_Pos)                   /*!< 0x00000001 */
N#define DMA_SxFCR_FTH_1          (0x2UL << DMA_SxFCR_FTH_Pos)                   /*!< 0x00000002 */
N
N/********************  Bits definition for DMA_LISR register  *****************/ 
N#define DMA_LISR_TCIF3_Pos       (27U)                                         
N#define DMA_LISR_TCIF3_Msk       (0x1UL << DMA_LISR_TCIF3_Pos)                  /*!< 0x08000000 */
N#define DMA_LISR_TCIF3           DMA_LISR_TCIF3_Msk                            
N#define DMA_LISR_HTIF3_Pos       (26U)                                         
N#define DMA_LISR_HTIF3_Msk       (0x1UL << DMA_LISR_HTIF3_Pos)                  /*!< 0x04000000 */
N#define DMA_LISR_HTIF3           DMA_LISR_HTIF3_Msk                            
N#define DMA_LISR_TEIF3_Pos       (25U)                                         
N#define DMA_LISR_TEIF3_Msk       (0x1UL << DMA_LISR_TEIF3_Pos)                  /*!< 0x02000000 */
N#define DMA_LISR_TEIF3           DMA_LISR_TEIF3_Msk                            
N#define DMA_LISR_DMEIF3_Pos      (24U)                                         
N#define DMA_LISR_DMEIF3_Msk      (0x1UL << DMA_LISR_DMEIF3_Pos)                 /*!< 0x01000000 */
N#define DMA_LISR_DMEIF3          DMA_LISR_DMEIF3_Msk                           
N#define DMA_LISR_FEIF3_Pos       (22U)                                         
N#define DMA_LISR_FEIF3_Msk       (0x1UL << DMA_LISR_FEIF3_Pos)                  /*!< 0x00400000 */
N#define DMA_LISR_FEIF3           DMA_LISR_FEIF3_Msk                            
N#define DMA_LISR_TCIF2_Pos       (21U)                                         
N#define DMA_LISR_TCIF2_Msk       (0x1UL << DMA_LISR_TCIF2_Pos)                  /*!< 0x00200000 */
N#define DMA_LISR_TCIF2           DMA_LISR_TCIF2_Msk                            
N#define DMA_LISR_HTIF2_Pos       (20U)                                         
N#define DMA_LISR_HTIF2_Msk       (0x1UL << DMA_LISR_HTIF2_Pos)                  /*!< 0x00100000 */
N#define DMA_LISR_HTIF2           DMA_LISR_HTIF2_Msk                            
N#define DMA_LISR_TEIF2_Pos       (19U)                                         
N#define DMA_LISR_TEIF2_Msk       (0x1UL << DMA_LISR_TEIF2_Pos)                  /*!< 0x00080000 */
N#define DMA_LISR_TEIF2           DMA_LISR_TEIF2_Msk                            
N#define DMA_LISR_DMEIF2_Pos      (18U)                                         
N#define DMA_LISR_DMEIF2_Msk      (0x1UL << DMA_LISR_DMEIF2_Pos)                 /*!< 0x00040000 */
N#define DMA_LISR_DMEIF2          DMA_LISR_DMEIF2_Msk                           
N#define DMA_LISR_FEIF2_Pos       (16U)                                         
N#define DMA_LISR_FEIF2_Msk       (0x1UL << DMA_LISR_FEIF2_Pos)                  /*!< 0x00010000 */
N#define DMA_LISR_FEIF2           DMA_LISR_FEIF2_Msk                            
N#define DMA_LISR_TCIF1_Pos       (11U)                                         
N#define DMA_LISR_TCIF1_Msk       (0x1UL << DMA_LISR_TCIF1_Pos)                  /*!< 0x00000800 */
N#define DMA_LISR_TCIF1           DMA_LISR_TCIF1_Msk                            
N#define DMA_LISR_HTIF1_Pos       (10U)                                         
N#define DMA_LISR_HTIF1_Msk       (0x1UL << DMA_LISR_HTIF1_Pos)                  /*!< 0x00000400 */
N#define DMA_LISR_HTIF1           DMA_LISR_HTIF1_Msk                            
N#define DMA_LISR_TEIF1_Pos       (9U)                                          
N#define DMA_LISR_TEIF1_Msk       (0x1UL << DMA_LISR_TEIF1_Pos)                  /*!< 0x00000200 */
N#define DMA_LISR_TEIF1           DMA_LISR_TEIF1_Msk                            
N#define DMA_LISR_DMEIF1_Pos      (8U)                                          
N#define DMA_LISR_DMEIF1_Msk      (0x1UL << DMA_LISR_DMEIF1_Pos)                 /*!< 0x00000100 */
N#define DMA_LISR_DMEIF1          DMA_LISR_DMEIF1_Msk                           
N#define DMA_LISR_FEIF1_Pos       (6U)                                          
N#define DMA_LISR_FEIF1_Msk       (0x1UL << DMA_LISR_FEIF1_Pos)                  /*!< 0x00000040 */
N#define DMA_LISR_FEIF1           DMA_LISR_FEIF1_Msk                            
N#define DMA_LISR_TCIF0_Pos       (5U)                                          
N#define DMA_LISR_TCIF0_Msk       (0x1UL << DMA_LISR_TCIF0_Pos)                  /*!< 0x00000020 */
N#define DMA_LISR_TCIF0           DMA_LISR_TCIF0_Msk                            
N#define DMA_LISR_HTIF0_Pos       (4U)                                          
N#define DMA_LISR_HTIF0_Msk       (0x1UL << DMA_LISR_HTIF0_Pos)                  /*!< 0x00000010 */
N#define DMA_LISR_HTIF0           DMA_LISR_HTIF0_Msk                            
N#define DMA_LISR_TEIF0_Pos       (3U)                                          
N#define DMA_LISR_TEIF0_Msk       (0x1UL << DMA_LISR_TEIF0_Pos)                  /*!< 0x00000008 */
N#define DMA_LISR_TEIF0           DMA_LISR_TEIF0_Msk                            
N#define DMA_LISR_DMEIF0_Pos      (2U)                                          
N#define DMA_LISR_DMEIF0_Msk      (0x1UL << DMA_LISR_DMEIF0_Pos)                 /*!< 0x00000004 */
N#define DMA_LISR_DMEIF0          DMA_LISR_DMEIF0_Msk                           
N#define DMA_LISR_FEIF0_Pos       (0U)                                          
N#define DMA_LISR_FEIF0_Msk       (0x1UL << DMA_LISR_FEIF0_Pos)                  /*!< 0x00000001 */
N#define DMA_LISR_FEIF0           DMA_LISR_FEIF0_Msk                            
N
N/********************  Bits definition for DMA_HISR register  *****************/ 
N#define DMA_HISR_TCIF7_Pos       (27U)                                         
N#define DMA_HISR_TCIF7_Msk       (0x1UL << DMA_HISR_TCIF7_Pos)                  /*!< 0x08000000 */
N#define DMA_HISR_TCIF7           DMA_HISR_TCIF7_Msk                            
N#define DMA_HISR_HTIF7_Pos       (26U)                                         
N#define DMA_HISR_HTIF7_Msk       (0x1UL << DMA_HISR_HTIF7_Pos)                  /*!< 0x04000000 */
N#define DMA_HISR_HTIF7           DMA_HISR_HTIF7_Msk                            
N#define DMA_HISR_TEIF7_Pos       (25U)                                         
N#define DMA_HISR_TEIF7_Msk       (0x1UL << DMA_HISR_TEIF7_Pos)                  /*!< 0x02000000 */
N#define DMA_HISR_TEIF7           DMA_HISR_TEIF7_Msk                            
N#define DMA_HISR_DMEIF7_Pos      (24U)                                         
N#define DMA_HISR_DMEIF7_Msk      (0x1UL << DMA_HISR_DMEIF7_Pos)                 /*!< 0x01000000 */
N#define DMA_HISR_DMEIF7          DMA_HISR_DMEIF7_Msk                           
N#define DMA_HISR_FEIF7_Pos       (22U)                                         
N#define DMA_HISR_FEIF7_Msk       (0x1UL << DMA_HISR_FEIF7_Pos)                  /*!< 0x00400000 */
N#define DMA_HISR_FEIF7           DMA_HISR_FEIF7_Msk                            
N#define DMA_HISR_TCIF6_Pos       (21U)                                         
N#define DMA_HISR_TCIF6_Msk       (0x1UL << DMA_HISR_TCIF6_Pos)                  /*!< 0x00200000 */
N#define DMA_HISR_TCIF6           DMA_HISR_TCIF6_Msk                            
N#define DMA_HISR_HTIF6_Pos       (20U)                                         
N#define DMA_HISR_HTIF6_Msk       (0x1UL << DMA_HISR_HTIF6_Pos)                  /*!< 0x00100000 */
N#define DMA_HISR_HTIF6           DMA_HISR_HTIF6_Msk                            
N#define DMA_HISR_TEIF6_Pos       (19U)                                         
N#define DMA_HISR_TEIF6_Msk       (0x1UL << DMA_HISR_TEIF6_Pos)                  /*!< 0x00080000 */
N#define DMA_HISR_TEIF6           DMA_HISR_TEIF6_Msk                            
N#define DMA_HISR_DMEIF6_Pos      (18U)                                         
N#define DMA_HISR_DMEIF6_Msk      (0x1UL << DMA_HISR_DMEIF6_Pos)                 /*!< 0x00040000 */
N#define DMA_HISR_DMEIF6          DMA_HISR_DMEIF6_Msk                           
N#define DMA_HISR_FEIF6_Pos       (16U)                                         
N#define DMA_HISR_FEIF6_Msk       (0x1UL << DMA_HISR_FEIF6_Pos)                  /*!< 0x00010000 */
N#define DMA_HISR_FEIF6           DMA_HISR_FEIF6_Msk                            
N#define DMA_HISR_TCIF5_Pos       (11U)                                         
N#define DMA_HISR_TCIF5_Msk       (0x1UL << DMA_HISR_TCIF5_Pos)                  /*!< 0x00000800 */
N#define DMA_HISR_TCIF5           DMA_HISR_TCIF5_Msk                            
N#define DMA_HISR_HTIF5_Pos       (10U)                                         
N#define DMA_HISR_HTIF5_Msk       (0x1UL << DMA_HISR_HTIF5_Pos)                  /*!< 0x00000400 */
N#define DMA_HISR_HTIF5           DMA_HISR_HTIF5_Msk                            
N#define DMA_HISR_TEIF5_Pos       (9U)                                          
N#define DMA_HISR_TEIF5_Msk       (0x1UL << DMA_HISR_TEIF5_Pos)                  /*!< 0x00000200 */
N#define DMA_HISR_TEIF5           DMA_HISR_TEIF5_Msk                            
N#define DMA_HISR_DMEIF5_Pos      (8U)                                          
N#define DMA_HISR_DMEIF5_Msk      (0x1UL << DMA_HISR_DMEIF5_Pos)                 /*!< 0x00000100 */
N#define DMA_HISR_DMEIF5          DMA_HISR_DMEIF5_Msk                           
N#define DMA_HISR_FEIF5_Pos       (6U)                                          
N#define DMA_HISR_FEIF5_Msk       (0x1UL << DMA_HISR_FEIF5_Pos)                  /*!< 0x00000040 */
N#define DMA_HISR_FEIF5           DMA_HISR_FEIF5_Msk                            
N#define DMA_HISR_TCIF4_Pos       (5U)                                          
N#define DMA_HISR_TCIF4_Msk       (0x1UL << DMA_HISR_TCIF4_Pos)                  /*!< 0x00000020 */
N#define DMA_HISR_TCIF4           DMA_HISR_TCIF4_Msk                            
N#define DMA_HISR_HTIF4_Pos       (4U)                                          
N#define DMA_HISR_HTIF4_Msk       (0x1UL << DMA_HISR_HTIF4_Pos)                  /*!< 0x00000010 */
N#define DMA_HISR_HTIF4           DMA_HISR_HTIF4_Msk                            
N#define DMA_HISR_TEIF4_Pos       (3U)                                          
N#define DMA_HISR_TEIF4_Msk       (0x1UL << DMA_HISR_TEIF4_Pos)                  /*!< 0x00000008 */
N#define DMA_HISR_TEIF4           DMA_HISR_TEIF4_Msk                            
N#define DMA_HISR_DMEIF4_Pos      (2U)                                          
N#define DMA_HISR_DMEIF4_Msk      (0x1UL << DMA_HISR_DMEIF4_Pos)                 /*!< 0x00000004 */
N#define DMA_HISR_DMEIF4          DMA_HISR_DMEIF4_Msk                           
N#define DMA_HISR_FEIF4_Pos       (0U)                                          
N#define DMA_HISR_FEIF4_Msk       (0x1UL << DMA_HISR_FEIF4_Pos)                  /*!< 0x00000001 */
N#define DMA_HISR_FEIF4           DMA_HISR_FEIF4_Msk                            
N
N/********************  Bits definition for DMA_LIFCR register  ****************/ 
N#define DMA_LIFCR_CTCIF3_Pos     (27U)                                         
N#define DMA_LIFCR_CTCIF3_Msk     (0x1UL << DMA_LIFCR_CTCIF3_Pos)                /*!< 0x08000000 */
N#define DMA_LIFCR_CTCIF3         DMA_LIFCR_CTCIF3_Msk                          
N#define DMA_LIFCR_CHTIF3_Pos     (26U)                                         
N#define DMA_LIFCR_CHTIF3_Msk     (0x1UL << DMA_LIFCR_CHTIF3_Pos)                /*!< 0x04000000 */
N#define DMA_LIFCR_CHTIF3         DMA_LIFCR_CHTIF3_Msk                          
N#define DMA_LIFCR_CTEIF3_Pos     (25U)                                         
N#define DMA_LIFCR_CTEIF3_Msk     (0x1UL << DMA_LIFCR_CTEIF3_Pos)                /*!< 0x02000000 */
N#define DMA_LIFCR_CTEIF3         DMA_LIFCR_CTEIF3_Msk                          
N#define DMA_LIFCR_CDMEIF3_Pos    (24U)                                         
N#define DMA_LIFCR_CDMEIF3_Msk    (0x1UL << DMA_LIFCR_CDMEIF3_Pos)               /*!< 0x01000000 */
N#define DMA_LIFCR_CDMEIF3        DMA_LIFCR_CDMEIF3_Msk                         
N#define DMA_LIFCR_CFEIF3_Pos     (22U)                                         
N#define DMA_LIFCR_CFEIF3_Msk     (0x1UL << DMA_LIFCR_CFEIF3_Pos)                /*!< 0x00400000 */
N#define DMA_LIFCR_CFEIF3         DMA_LIFCR_CFEIF3_Msk                          
N#define DMA_LIFCR_CTCIF2_Pos     (21U)                                         
N#define DMA_LIFCR_CTCIF2_Msk     (0x1UL << DMA_LIFCR_CTCIF2_Pos)                /*!< 0x00200000 */
N#define DMA_LIFCR_CTCIF2         DMA_LIFCR_CTCIF2_Msk                          
N#define DMA_LIFCR_CHTIF2_Pos     (20U)                                         
N#define DMA_LIFCR_CHTIF2_Msk     (0x1UL << DMA_LIFCR_CHTIF2_Pos)                /*!< 0x00100000 */
N#define DMA_LIFCR_CHTIF2         DMA_LIFCR_CHTIF2_Msk                          
N#define DMA_LIFCR_CTEIF2_Pos     (19U)                                         
N#define DMA_LIFCR_CTEIF2_Msk     (0x1UL << DMA_LIFCR_CTEIF2_Pos)                /*!< 0x00080000 */
N#define DMA_LIFCR_CTEIF2         DMA_LIFCR_CTEIF2_Msk                          
N#define DMA_LIFCR_CDMEIF2_Pos    (18U)                                         
N#define DMA_LIFCR_CDMEIF2_Msk    (0x1UL << DMA_LIFCR_CDMEIF2_Pos)               /*!< 0x00040000 */
N#define DMA_LIFCR_CDMEIF2        DMA_LIFCR_CDMEIF2_Msk                         
N#define DMA_LIFCR_CFEIF2_Pos     (16U)                                         
N#define DMA_LIFCR_CFEIF2_Msk     (0x1UL << DMA_LIFCR_CFEIF2_Pos)                /*!< 0x00010000 */
N#define DMA_LIFCR_CFEIF2         DMA_LIFCR_CFEIF2_Msk                          
N#define DMA_LIFCR_CTCIF1_Pos     (11U)                                         
N#define DMA_LIFCR_CTCIF1_Msk     (0x1UL << DMA_LIFCR_CTCIF1_Pos)                /*!< 0x00000800 */
N#define DMA_LIFCR_CTCIF1         DMA_LIFCR_CTCIF1_Msk                          
N#define DMA_LIFCR_CHTIF1_Pos     (10U)                                         
N#define DMA_LIFCR_CHTIF1_Msk     (0x1UL << DMA_LIFCR_CHTIF1_Pos)                /*!< 0x00000400 */
N#define DMA_LIFCR_CHTIF1         DMA_LIFCR_CHTIF1_Msk                          
N#define DMA_LIFCR_CTEIF1_Pos     (9U)                                          
N#define DMA_LIFCR_CTEIF1_Msk     (0x1UL << DMA_LIFCR_CTEIF1_Pos)                /*!< 0x00000200 */
N#define DMA_LIFCR_CTEIF1         DMA_LIFCR_CTEIF1_Msk                          
N#define DMA_LIFCR_CDMEIF1_Pos    (8U)                                          
N#define DMA_LIFCR_CDMEIF1_Msk    (0x1UL << DMA_LIFCR_CDMEIF1_Pos)               /*!< 0x00000100 */
N#define DMA_LIFCR_CDMEIF1        DMA_LIFCR_CDMEIF1_Msk                         
N#define DMA_LIFCR_CFEIF1_Pos     (6U)                                          
N#define DMA_LIFCR_CFEIF1_Msk     (0x1UL << DMA_LIFCR_CFEIF1_Pos)                /*!< 0x00000040 */
N#define DMA_LIFCR_CFEIF1         DMA_LIFCR_CFEIF1_Msk                          
N#define DMA_LIFCR_CTCIF0_Pos     (5U)                                          
N#define DMA_LIFCR_CTCIF0_Msk     (0x1UL << DMA_LIFCR_CTCIF0_Pos)                /*!< 0x00000020 */
N#define DMA_LIFCR_CTCIF0         DMA_LIFCR_CTCIF0_Msk                          
N#define DMA_LIFCR_CHTIF0_Pos     (4U)                                          
N#define DMA_LIFCR_CHTIF0_Msk     (0x1UL << DMA_LIFCR_CHTIF0_Pos)                /*!< 0x00000010 */
N#define DMA_LIFCR_CHTIF0         DMA_LIFCR_CHTIF0_Msk                          
N#define DMA_LIFCR_CTEIF0_Pos     (3U)                                          
N#define DMA_LIFCR_CTEIF0_Msk     (0x1UL << DMA_LIFCR_CTEIF0_Pos)                /*!< 0x00000008 */
N#define DMA_LIFCR_CTEIF0         DMA_LIFCR_CTEIF0_Msk                          
N#define DMA_LIFCR_CDMEIF0_Pos    (2U)                                          
N#define DMA_LIFCR_CDMEIF0_Msk    (0x1UL << DMA_LIFCR_CDMEIF0_Pos)               /*!< 0x00000004 */
N#define DMA_LIFCR_CDMEIF0        DMA_LIFCR_CDMEIF0_Msk                         
N#define DMA_LIFCR_CFEIF0_Pos     (0U)                                          
N#define DMA_LIFCR_CFEIF0_Msk     (0x1UL << DMA_LIFCR_CFEIF0_Pos)                /*!< 0x00000001 */
N#define DMA_LIFCR_CFEIF0         DMA_LIFCR_CFEIF0_Msk                          
N
N/********************  Bits definition for DMA_HIFCR  register  ****************/ 
N#define DMA_HIFCR_CTCIF7_Pos     (27U)                                         
N#define DMA_HIFCR_CTCIF7_Msk     (0x1UL << DMA_HIFCR_CTCIF7_Pos)                /*!< 0x08000000 */
N#define DMA_HIFCR_CTCIF7         DMA_HIFCR_CTCIF7_Msk                          
N#define DMA_HIFCR_CHTIF7_Pos     (26U)                                         
N#define DMA_HIFCR_CHTIF7_Msk     (0x1UL << DMA_HIFCR_CHTIF7_Pos)                /*!< 0x04000000 */
N#define DMA_HIFCR_CHTIF7         DMA_HIFCR_CHTIF7_Msk                          
N#define DMA_HIFCR_CTEIF7_Pos     (25U)                                         
N#define DMA_HIFCR_CTEIF7_Msk     (0x1UL << DMA_HIFCR_CTEIF7_Pos)                /*!< 0x02000000 */
N#define DMA_HIFCR_CTEIF7         DMA_HIFCR_CTEIF7_Msk                          
N#define DMA_HIFCR_CDMEIF7_Pos    (24U)                                         
N#define DMA_HIFCR_CDMEIF7_Msk    (0x1UL << DMA_HIFCR_CDMEIF7_Pos)               /*!< 0x01000000 */
N#define DMA_HIFCR_CDMEIF7        DMA_HIFCR_CDMEIF7_Msk                         
N#define DMA_HIFCR_CFEIF7_Pos     (22U)                                         
N#define DMA_HIFCR_CFEIF7_Msk     (0x1UL << DMA_HIFCR_CFEIF7_Pos)                /*!< 0x00400000 */
N#define DMA_HIFCR_CFEIF7         DMA_HIFCR_CFEIF7_Msk                          
N#define DMA_HIFCR_CTCIF6_Pos     (21U)                                         
N#define DMA_HIFCR_CTCIF6_Msk     (0x1UL << DMA_HIFCR_CTCIF6_Pos)                /*!< 0x00200000 */
N#define DMA_HIFCR_CTCIF6         DMA_HIFCR_CTCIF6_Msk                          
N#define DMA_HIFCR_CHTIF6_Pos     (20U)                                         
N#define DMA_HIFCR_CHTIF6_Msk     (0x1UL << DMA_HIFCR_CHTIF6_Pos)                /*!< 0x00100000 */
N#define DMA_HIFCR_CHTIF6         DMA_HIFCR_CHTIF6_Msk                          
N#define DMA_HIFCR_CTEIF6_Pos     (19U)                                         
N#define DMA_HIFCR_CTEIF6_Msk     (0x1UL << DMA_HIFCR_CTEIF6_Pos)                /*!< 0x00080000 */
N#define DMA_HIFCR_CTEIF6         DMA_HIFCR_CTEIF6_Msk                          
N#define DMA_HIFCR_CDMEIF6_Pos    (18U)                                         
N#define DMA_HIFCR_CDMEIF6_Msk    (0x1UL << DMA_HIFCR_CDMEIF6_Pos)               /*!< 0x00040000 */
N#define DMA_HIFCR_CDMEIF6        DMA_HIFCR_CDMEIF6_Msk                         
N#define DMA_HIFCR_CFEIF6_Pos     (16U)                                         
N#define DMA_HIFCR_CFEIF6_Msk     (0x1UL << DMA_HIFCR_CFEIF6_Pos)                /*!< 0x00010000 */
N#define DMA_HIFCR_CFEIF6         DMA_HIFCR_CFEIF6_Msk                          
N#define DMA_HIFCR_CTCIF5_Pos     (11U)                                         
N#define DMA_HIFCR_CTCIF5_Msk     (0x1UL << DMA_HIFCR_CTCIF5_Pos)                /*!< 0x00000800 */
N#define DMA_HIFCR_CTCIF5         DMA_HIFCR_CTCIF5_Msk                          
N#define DMA_HIFCR_CHTIF5_Pos     (10U)                                         
N#define DMA_HIFCR_CHTIF5_Msk     (0x1UL << DMA_HIFCR_CHTIF5_Pos)                /*!< 0x00000400 */
N#define DMA_HIFCR_CHTIF5         DMA_HIFCR_CHTIF5_Msk                          
N#define DMA_HIFCR_CTEIF5_Pos     (9U)                                          
N#define DMA_HIFCR_CTEIF5_Msk     (0x1UL << DMA_HIFCR_CTEIF5_Pos)                /*!< 0x00000200 */
N#define DMA_HIFCR_CTEIF5         DMA_HIFCR_CTEIF5_Msk                          
N#define DMA_HIFCR_CDMEIF5_Pos    (8U)                                          
N#define DMA_HIFCR_CDMEIF5_Msk    (0x1UL << DMA_HIFCR_CDMEIF5_Pos)               /*!< 0x00000100 */
N#define DMA_HIFCR_CDMEIF5        DMA_HIFCR_CDMEIF5_Msk                         
N#define DMA_HIFCR_CFEIF5_Pos     (6U)                                          
N#define DMA_HIFCR_CFEIF5_Msk     (0x1UL << DMA_HIFCR_CFEIF5_Pos)                /*!< 0x00000040 */
N#define DMA_HIFCR_CFEIF5         DMA_HIFCR_CFEIF5_Msk                          
N#define DMA_HIFCR_CTCIF4_Pos     (5U)                                          
N#define DMA_HIFCR_CTCIF4_Msk     (0x1UL << DMA_HIFCR_CTCIF4_Pos)                /*!< 0x00000020 */
N#define DMA_HIFCR_CTCIF4         DMA_HIFCR_CTCIF4_Msk                          
N#define DMA_HIFCR_CHTIF4_Pos     (4U)                                          
N#define DMA_HIFCR_CHTIF4_Msk     (0x1UL << DMA_HIFCR_CHTIF4_Pos)                /*!< 0x00000010 */
N#define DMA_HIFCR_CHTIF4         DMA_HIFCR_CHTIF4_Msk                          
N#define DMA_HIFCR_CTEIF4_Pos     (3U)                                          
N#define DMA_HIFCR_CTEIF4_Msk     (0x1UL << DMA_HIFCR_CTEIF4_Pos)                /*!< 0x00000008 */
N#define DMA_HIFCR_CTEIF4         DMA_HIFCR_CTEIF4_Msk                          
N#define DMA_HIFCR_CDMEIF4_Pos    (2U)                                          
N#define DMA_HIFCR_CDMEIF4_Msk    (0x1UL << DMA_HIFCR_CDMEIF4_Pos)               /*!< 0x00000004 */
N#define DMA_HIFCR_CDMEIF4        DMA_HIFCR_CDMEIF4_Msk                         
N#define DMA_HIFCR_CFEIF4_Pos     (0U)                                          
N#define DMA_HIFCR_CFEIF4_Msk     (0x1UL << DMA_HIFCR_CFEIF4_Pos)                /*!< 0x00000001 */
N#define DMA_HIFCR_CFEIF4         DMA_HIFCR_CFEIF4_Msk                          
N
N/******************  Bit definition for DMA_SxPAR register  ********************/
N#define DMA_SxPAR_PA_Pos         (0U)                                          
N#define DMA_SxPAR_PA_Msk         (0xFFFFFFFFUL << DMA_SxPAR_PA_Pos)             /*!< 0xFFFFFFFF */
N#define DMA_SxPAR_PA             DMA_SxPAR_PA_Msk                              /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_SxM0AR register  ********************/
N#define DMA_SxM0AR_M0A_Pos       (0U)                                          
N#define DMA_SxM0AR_M0A_Msk       (0xFFFFFFFFUL << DMA_SxM0AR_M0A_Pos)           /*!< 0xFFFFFFFF */
N#define DMA_SxM0AR_M0A           DMA_SxM0AR_M0A_Msk                            /*!< Memory Address */
N
N/******************  Bit definition for DMA_SxM1AR register  ********************/
N#define DMA_SxM1AR_M1A_Pos       (0U)                                          
N#define DMA_SxM1AR_M1A_Msk       (0xFFFFFFFFUL << DMA_SxM1AR_M1A_Pos)           /*!< 0xFFFFFFFF */
N#define DMA_SxM1AR_M1A           DMA_SxM1AR_M1A_Msk                            /*!< Memory Address */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                    External Interrupt/Event Controller                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define EXTI_IMR_MR0_Pos          (0U)                                         
N#define EXTI_IMR_MR0_Msk          (0x1UL << EXTI_IMR_MR0_Pos)                   /*!< 0x00000001 */
N#define EXTI_IMR_MR0              EXTI_IMR_MR0_Msk                             /*!< Interrupt Mask on line 0 */
N#define EXTI_IMR_MR1_Pos          (1U)                                         
N#define EXTI_IMR_MR1_Msk          (0x1UL << EXTI_IMR_MR1_Pos)                   /*!< 0x00000002 */
N#define EXTI_IMR_MR1              EXTI_IMR_MR1_Msk                             /*!< Interrupt Mask on line 1 */
N#define EXTI_IMR_MR2_Pos          (2U)                                         
N#define EXTI_IMR_MR2_Msk          (0x1UL << EXTI_IMR_MR2_Pos)                   /*!< 0x00000004 */
N#define EXTI_IMR_MR2              EXTI_IMR_MR2_Msk                             /*!< Interrupt Mask on line 2 */
N#define EXTI_IMR_MR3_Pos          (3U)                                         
N#define EXTI_IMR_MR3_Msk          (0x1UL << EXTI_IMR_MR3_Pos)                   /*!< 0x00000008 */
N#define EXTI_IMR_MR3              EXTI_IMR_MR3_Msk                             /*!< Interrupt Mask on line 3 */
N#define EXTI_IMR_MR4_Pos          (4U)                                         
N#define EXTI_IMR_MR4_Msk          (0x1UL << EXTI_IMR_MR4_Pos)                   /*!< 0x00000010 */
N#define EXTI_IMR_MR4              EXTI_IMR_MR4_Msk                             /*!< Interrupt Mask on line 4 */
N#define EXTI_IMR_MR5_Pos          (5U)                                         
N#define EXTI_IMR_MR5_Msk          (0x1UL << EXTI_IMR_MR5_Pos)                   /*!< 0x00000020 */
N#define EXTI_IMR_MR5              EXTI_IMR_MR5_Msk                             /*!< Interrupt Mask on line 5 */
N#define EXTI_IMR_MR6_Pos          (6U)                                         
N#define EXTI_IMR_MR6_Msk          (0x1UL << EXTI_IMR_MR6_Pos)                   /*!< 0x00000040 */
N#define EXTI_IMR_MR6              EXTI_IMR_MR6_Msk                             /*!< Interrupt Mask on line 6 */
N#define EXTI_IMR_MR7_Pos          (7U)                                         
N#define EXTI_IMR_MR7_Msk          (0x1UL << EXTI_IMR_MR7_Pos)                   /*!< 0x00000080 */
N#define EXTI_IMR_MR7              EXTI_IMR_MR7_Msk                             /*!< Interrupt Mask on line 7 */
N#define EXTI_IMR_MR8_Pos          (8U)                                         
N#define EXTI_IMR_MR8_Msk          (0x1UL << EXTI_IMR_MR8_Pos)                   /*!< 0x00000100 */
N#define EXTI_IMR_MR8              EXTI_IMR_MR8_Msk                             /*!< Interrupt Mask on line 8 */
N#define EXTI_IMR_MR9_Pos          (9U)                                         
N#define EXTI_IMR_MR9_Msk          (0x1UL << EXTI_IMR_MR9_Pos)                   /*!< 0x00000200 */
N#define EXTI_IMR_MR9              EXTI_IMR_MR9_Msk                             /*!< Interrupt Mask on line 9 */
N#define EXTI_IMR_MR10_Pos         (10U)                                        
N#define EXTI_IMR_MR10_Msk         (0x1UL << EXTI_IMR_MR10_Pos)                  /*!< 0x00000400 */
N#define EXTI_IMR_MR10             EXTI_IMR_MR10_Msk                            /*!< Interrupt Mask on line 10 */
N#define EXTI_IMR_MR11_Pos         (11U)                                        
N#define EXTI_IMR_MR11_Msk         (0x1UL << EXTI_IMR_MR11_Pos)                  /*!< 0x00000800 */
N#define EXTI_IMR_MR11             EXTI_IMR_MR11_Msk                            /*!< Interrupt Mask on line 11 */
N#define EXTI_IMR_MR12_Pos         (12U)                                        
N#define EXTI_IMR_MR12_Msk         (0x1UL << EXTI_IMR_MR12_Pos)                  /*!< 0x00001000 */
N#define EXTI_IMR_MR12             EXTI_IMR_MR12_Msk                            /*!< Interrupt Mask on line 12 */
N#define EXTI_IMR_MR13_Pos         (13U)                                        
N#define EXTI_IMR_MR13_Msk         (0x1UL << EXTI_IMR_MR13_Pos)                  /*!< 0x00002000 */
N#define EXTI_IMR_MR13             EXTI_IMR_MR13_Msk                            /*!< Interrupt Mask on line 13 */
N#define EXTI_IMR_MR14_Pos         (14U)                                        
N#define EXTI_IMR_MR14_Msk         (0x1UL << EXTI_IMR_MR14_Pos)                  /*!< 0x00004000 */
N#define EXTI_IMR_MR14             EXTI_IMR_MR14_Msk                            /*!< Interrupt Mask on line 14 */
N#define EXTI_IMR_MR15_Pos         (15U)                                        
N#define EXTI_IMR_MR15_Msk         (0x1UL << EXTI_IMR_MR15_Pos)                  /*!< 0x00008000 */
N#define EXTI_IMR_MR15             EXTI_IMR_MR15_Msk                            /*!< Interrupt Mask on line 15 */
N#define EXTI_IMR_MR16_Pos         (16U)                                        
N#define EXTI_IMR_MR16_Msk         (0x1UL << EXTI_IMR_MR16_Pos)                  /*!< 0x00010000 */
N#define EXTI_IMR_MR16             EXTI_IMR_MR16_Msk                            /*!< Interrupt Mask on line 16 */
N#define EXTI_IMR_MR17_Pos         (17U)                                        
N#define EXTI_IMR_MR17_Msk         (0x1UL << EXTI_IMR_MR17_Pos)                  /*!< 0x00020000 */
N#define EXTI_IMR_MR17             EXTI_IMR_MR17_Msk                            /*!< Interrupt Mask on line 17 */
N#define EXTI_IMR_MR18_Pos         (18U)                                        
N#define EXTI_IMR_MR18_Msk         (0x1UL << EXTI_IMR_MR18_Pos)                  /*!< 0x00040000 */
N#define EXTI_IMR_MR18             EXTI_IMR_MR18_Msk                            /*!< Interrupt Mask on line 18 */
N#define EXTI_IMR_MR19_Pos         (19U)                                        
N#define EXTI_IMR_MR19_Msk         (0x1UL << EXTI_IMR_MR19_Pos)                  /*!< 0x00080000 */
N#define EXTI_IMR_MR19             EXTI_IMR_MR19_Msk                            /*!< Interrupt Mask on line 19 */
N#define EXTI_IMR_MR20_Pos         (20U)                                        
N#define EXTI_IMR_MR20_Msk         (0x1UL << EXTI_IMR_MR20_Pos)                  /*!< 0x00100000 */
N#define EXTI_IMR_MR20             EXTI_IMR_MR20_Msk                            /*!< Interrupt Mask on line 20 */
N#define EXTI_IMR_MR21_Pos         (21U)                                        
N#define EXTI_IMR_MR21_Msk         (0x1UL << EXTI_IMR_MR21_Pos)                  /*!< 0x00200000 */
N#define EXTI_IMR_MR21             EXTI_IMR_MR21_Msk                            /*!< Interrupt Mask on line 21 */
N#define EXTI_IMR_MR22_Pos         (22U)                                        
N#define EXTI_IMR_MR22_Msk         (0x1UL << EXTI_IMR_MR22_Pos)                  /*!< 0x00400000 */
N#define EXTI_IMR_MR22             EXTI_IMR_MR22_Msk                            /*!< Interrupt Mask on line 22 */
N
N/* Reference Defines */
N#define  EXTI_IMR_IM0                        EXTI_IMR_MR0
N#define  EXTI_IMR_IM1                        EXTI_IMR_MR1
N#define  EXTI_IMR_IM2                        EXTI_IMR_MR2
N#define  EXTI_IMR_IM3                        EXTI_IMR_MR3
N#define  EXTI_IMR_IM4                        EXTI_IMR_MR4
N#define  EXTI_IMR_IM5                        EXTI_IMR_MR5
N#define  EXTI_IMR_IM6                        EXTI_IMR_MR6
N#define  EXTI_IMR_IM7                        EXTI_IMR_MR7
N#define  EXTI_IMR_IM8                        EXTI_IMR_MR8
N#define  EXTI_IMR_IM9                        EXTI_IMR_MR9
N#define  EXTI_IMR_IM10                       EXTI_IMR_MR10
N#define  EXTI_IMR_IM11                       EXTI_IMR_MR11
N#define  EXTI_IMR_IM12                       EXTI_IMR_MR12
N#define  EXTI_IMR_IM13                       EXTI_IMR_MR13
N#define  EXTI_IMR_IM14                       EXTI_IMR_MR14
N#define  EXTI_IMR_IM15                       EXTI_IMR_MR15
N#define  EXTI_IMR_IM16                       EXTI_IMR_MR16
N#define  EXTI_IMR_IM17                       EXTI_IMR_MR17
N#define  EXTI_IMR_IM18                       EXTI_IMR_MR18
N#define  EXTI_IMR_IM19                       EXTI_IMR_MR19
N#define  EXTI_IMR_IM20                       EXTI_IMR_MR20
N#define  EXTI_IMR_IM21                       EXTI_IMR_MR21
N#define  EXTI_IMR_IM22                       EXTI_IMR_MR22
N#define EXTI_IMR_IM_Pos           (0U)                                         
N#define EXTI_IMR_IM_Msk           (0x7FFFFFUL << EXTI_IMR_IM_Pos)               /*!< 0x007FFFFF */
N#define EXTI_IMR_IM               EXTI_IMR_IM_Msk                              /*!< Interrupt Mask All */
N
N/*******************  Bit definition for EXTI_EMR register  *******************/
N#define EXTI_EMR_MR0_Pos          (0U)                                         
N#define EXTI_EMR_MR0_Msk          (0x1UL << EXTI_EMR_MR0_Pos)                   /*!< 0x00000001 */
N#define EXTI_EMR_MR0              EXTI_EMR_MR0_Msk                             /*!< Event Mask on line 0 */
N#define EXTI_EMR_MR1_Pos          (1U)                                         
N#define EXTI_EMR_MR1_Msk          (0x1UL << EXTI_EMR_MR1_Pos)                   /*!< 0x00000002 */
N#define EXTI_EMR_MR1              EXTI_EMR_MR1_Msk                             /*!< Event Mask on line 1 */
N#define EXTI_EMR_MR2_Pos          (2U)                                         
N#define EXTI_EMR_MR2_Msk          (0x1UL << EXTI_EMR_MR2_Pos)                   /*!< 0x00000004 */
N#define EXTI_EMR_MR2              EXTI_EMR_MR2_Msk                             /*!< Event Mask on line 2 */
N#define EXTI_EMR_MR3_Pos          (3U)                                         
N#define EXTI_EMR_MR3_Msk          (0x1UL << EXTI_EMR_MR3_Pos)                   /*!< 0x00000008 */
N#define EXTI_EMR_MR3              EXTI_EMR_MR3_Msk                             /*!< Event Mask on line 3 */
N#define EXTI_EMR_MR4_Pos          (4U)                                         
N#define EXTI_EMR_MR4_Msk          (0x1UL << EXTI_EMR_MR4_Pos)                   /*!< 0x00000010 */
N#define EXTI_EMR_MR4              EXTI_EMR_MR4_Msk                             /*!< Event Mask on line 4 */
N#define EXTI_EMR_MR5_Pos          (5U)                                         
N#define EXTI_EMR_MR5_Msk          (0x1UL << EXTI_EMR_MR5_Pos)                   /*!< 0x00000020 */
N#define EXTI_EMR_MR5              EXTI_EMR_MR5_Msk                             /*!< Event Mask on line 5 */
N#define EXTI_EMR_MR6_Pos          (6U)                                         
N#define EXTI_EMR_MR6_Msk          (0x1UL << EXTI_EMR_MR6_Pos)                   /*!< 0x00000040 */
N#define EXTI_EMR_MR6              EXTI_EMR_MR6_Msk                             /*!< Event Mask on line 6 */
N#define EXTI_EMR_MR7_Pos          (7U)                                         
N#define EXTI_EMR_MR7_Msk          (0x1UL << EXTI_EMR_MR7_Pos)                   /*!< 0x00000080 */
N#define EXTI_EMR_MR7              EXTI_EMR_MR7_Msk                             /*!< Event Mask on line 7 */
N#define EXTI_EMR_MR8_Pos          (8U)                                         
N#define EXTI_EMR_MR8_Msk          (0x1UL << EXTI_EMR_MR8_Pos)                   /*!< 0x00000100 */
N#define EXTI_EMR_MR8              EXTI_EMR_MR8_Msk                             /*!< Event Mask on line 8 */
N#define EXTI_EMR_MR9_Pos          (9U)                                         
N#define EXTI_EMR_MR9_Msk          (0x1UL << EXTI_EMR_MR9_Pos)                   /*!< 0x00000200 */
N#define EXTI_EMR_MR9              EXTI_EMR_MR9_Msk                             /*!< Event Mask on line 9 */
N#define EXTI_EMR_MR10_Pos         (10U)                                        
N#define EXTI_EMR_MR10_Msk         (0x1UL << EXTI_EMR_MR10_Pos)                  /*!< 0x00000400 */
N#define EXTI_EMR_MR10             EXTI_EMR_MR10_Msk                            /*!< Event Mask on line 10 */
N#define EXTI_EMR_MR11_Pos         (11U)                                        
N#define EXTI_EMR_MR11_Msk         (0x1UL << EXTI_EMR_MR11_Pos)                  /*!< 0x00000800 */
N#define EXTI_EMR_MR11             EXTI_EMR_MR11_Msk                            /*!< Event Mask on line 11 */
N#define EXTI_EMR_MR12_Pos         (12U)                                        
N#define EXTI_EMR_MR12_Msk         (0x1UL << EXTI_EMR_MR12_Pos)                  /*!< 0x00001000 */
N#define EXTI_EMR_MR12             EXTI_EMR_MR12_Msk                            /*!< Event Mask on line 12 */
N#define EXTI_EMR_MR13_Pos         (13U)                                        
N#define EXTI_EMR_MR13_Msk         (0x1UL << EXTI_EMR_MR13_Pos)                  /*!< 0x00002000 */
N#define EXTI_EMR_MR13             EXTI_EMR_MR13_Msk                            /*!< Event Mask on line 13 */
N#define EXTI_EMR_MR14_Pos         (14U)                                        
N#define EXTI_EMR_MR14_Msk         (0x1UL << EXTI_EMR_MR14_Pos)                  /*!< 0x00004000 */
N#define EXTI_EMR_MR14             EXTI_EMR_MR14_Msk                            /*!< Event Mask on line 14 */
N#define EXTI_EMR_MR15_Pos         (15U)                                        
N#define EXTI_EMR_MR15_Msk         (0x1UL << EXTI_EMR_MR15_Pos)                  /*!< 0x00008000 */
N#define EXTI_EMR_MR15             EXTI_EMR_MR15_Msk                            /*!< Event Mask on line 15 */
N#define EXTI_EMR_MR16_Pos         (16U)                                        
N#define EXTI_EMR_MR16_Msk         (0x1UL << EXTI_EMR_MR16_Pos)                  /*!< 0x00010000 */
N#define EXTI_EMR_MR16             EXTI_EMR_MR16_Msk                            /*!< Event Mask on line 16 */
N#define EXTI_EMR_MR17_Pos         (17U)                                        
N#define EXTI_EMR_MR17_Msk         (0x1UL << EXTI_EMR_MR17_Pos)                  /*!< 0x00020000 */
N#define EXTI_EMR_MR17             EXTI_EMR_MR17_Msk                            /*!< Event Mask on line 17 */
N#define EXTI_EMR_MR18_Pos         (18U)                                        
N#define EXTI_EMR_MR18_Msk         (0x1UL << EXTI_EMR_MR18_Pos)                  /*!< 0x00040000 */
N#define EXTI_EMR_MR18             EXTI_EMR_MR18_Msk                            /*!< Event Mask on line 18 */
N#define EXTI_EMR_MR19_Pos         (19U)                                        
N#define EXTI_EMR_MR19_Msk         (0x1UL << EXTI_EMR_MR19_Pos)                  /*!< 0x00080000 */
N#define EXTI_EMR_MR19             EXTI_EMR_MR19_Msk                            /*!< Event Mask on line 19 */
N#define EXTI_EMR_MR20_Pos         (20U)                                        
N#define EXTI_EMR_MR20_Msk         (0x1UL << EXTI_EMR_MR20_Pos)                  /*!< 0x00100000 */
N#define EXTI_EMR_MR20             EXTI_EMR_MR20_Msk                            /*!< Event Mask on line 20 */
N#define EXTI_EMR_MR21_Pos         (21U)                                        
N#define EXTI_EMR_MR21_Msk         (0x1UL << EXTI_EMR_MR21_Pos)                  /*!< 0x00200000 */
N#define EXTI_EMR_MR21             EXTI_EMR_MR21_Msk                            /*!< Event Mask on line 21 */
N#define EXTI_EMR_MR22_Pos         (22U)                                        
N#define EXTI_EMR_MR22_Msk         (0x1UL << EXTI_EMR_MR22_Pos)                  /*!< 0x00400000 */
N#define EXTI_EMR_MR22             EXTI_EMR_MR22_Msk                            /*!< Event Mask on line 22 */
N
N/* Reference Defines */
N#define  EXTI_EMR_EM0                        EXTI_EMR_MR0
N#define  EXTI_EMR_EM1                        EXTI_EMR_MR1
N#define  EXTI_EMR_EM2                        EXTI_EMR_MR2
N#define  EXTI_EMR_EM3                        EXTI_EMR_MR3
N#define  EXTI_EMR_EM4                        EXTI_EMR_MR4
N#define  EXTI_EMR_EM5                        EXTI_EMR_MR5
N#define  EXTI_EMR_EM6                        EXTI_EMR_MR6
N#define  EXTI_EMR_EM7                        EXTI_EMR_MR7
N#define  EXTI_EMR_EM8                        EXTI_EMR_MR8
N#define  EXTI_EMR_EM9                        EXTI_EMR_MR9
N#define  EXTI_EMR_EM10                       EXTI_EMR_MR10
N#define  EXTI_EMR_EM11                       EXTI_EMR_MR11
N#define  EXTI_EMR_EM12                       EXTI_EMR_MR12
N#define  EXTI_EMR_EM13                       EXTI_EMR_MR13
N#define  EXTI_EMR_EM14                       EXTI_EMR_MR14
N#define  EXTI_EMR_EM15                       EXTI_EMR_MR15
N#define  EXTI_EMR_EM16                       EXTI_EMR_MR16
N#define  EXTI_EMR_EM17                       EXTI_EMR_MR17
N#define  EXTI_EMR_EM18                       EXTI_EMR_MR18
N#define  EXTI_EMR_EM19                       EXTI_EMR_MR19
N#define  EXTI_EMR_EM20                       EXTI_EMR_MR20
N#define  EXTI_EMR_EM21                       EXTI_EMR_MR21
N#define  EXTI_EMR_EM22                       EXTI_EMR_MR22
N
N/******************  Bit definition for EXTI_RTSR register  *******************/
N#define EXTI_RTSR_TR0_Pos         (0U)                                         
N#define EXTI_RTSR_TR0_Msk         (0x1UL << EXTI_RTSR_TR0_Pos)                  /*!< 0x00000001 */
N#define EXTI_RTSR_TR0             EXTI_RTSR_TR0_Msk                            /*!< Rising trigger event configuration bit of line 0 */
N#define EXTI_RTSR_TR1_Pos         (1U)                                         
N#define EXTI_RTSR_TR1_Msk         (0x1UL << EXTI_RTSR_TR1_Pos)                  /*!< 0x00000002 */
N#define EXTI_RTSR_TR1             EXTI_RTSR_TR1_Msk                            /*!< Rising trigger event configuration bit of line 1 */
N#define EXTI_RTSR_TR2_Pos         (2U)                                         
N#define EXTI_RTSR_TR2_Msk         (0x1UL << EXTI_RTSR_TR2_Pos)                  /*!< 0x00000004 */
N#define EXTI_RTSR_TR2             EXTI_RTSR_TR2_Msk                            /*!< Rising trigger event configuration bit of line 2 */
N#define EXTI_RTSR_TR3_Pos         (3U)                                         
N#define EXTI_RTSR_TR3_Msk         (0x1UL << EXTI_RTSR_TR3_Pos)                  /*!< 0x00000008 */
N#define EXTI_RTSR_TR3             EXTI_RTSR_TR3_Msk                            /*!< Rising trigger event configuration bit of line 3 */
N#define EXTI_RTSR_TR4_Pos         (4U)                                         
N#define EXTI_RTSR_TR4_Msk         (0x1UL << EXTI_RTSR_TR4_Pos)                  /*!< 0x00000010 */
N#define EXTI_RTSR_TR4             EXTI_RTSR_TR4_Msk                            /*!< Rising trigger event configuration bit of line 4 */
N#define EXTI_RTSR_TR5_Pos         (5U)                                         
N#define EXTI_RTSR_TR5_Msk         (0x1UL << EXTI_RTSR_TR5_Pos)                  /*!< 0x00000020 */
N#define EXTI_RTSR_TR5             EXTI_RTSR_TR5_Msk                            /*!< Rising trigger event configuration bit of line 5 */
N#define EXTI_RTSR_TR6_Pos         (6U)                                         
N#define EXTI_RTSR_TR6_Msk         (0x1UL << EXTI_RTSR_TR6_Pos)                  /*!< 0x00000040 */
N#define EXTI_RTSR_TR6             EXTI_RTSR_TR6_Msk                            /*!< Rising trigger event configuration bit of line 6 */
N#define EXTI_RTSR_TR7_Pos         (7U)                                         
N#define EXTI_RTSR_TR7_Msk         (0x1UL << EXTI_RTSR_TR7_Pos)                  /*!< 0x00000080 */
N#define EXTI_RTSR_TR7             EXTI_RTSR_TR7_Msk                            /*!< Rising trigger event configuration bit of line 7 */
N#define EXTI_RTSR_TR8_Pos         (8U)                                         
N#define EXTI_RTSR_TR8_Msk         (0x1UL << EXTI_RTSR_TR8_Pos)                  /*!< 0x00000100 */
N#define EXTI_RTSR_TR8             EXTI_RTSR_TR8_Msk                            /*!< Rising trigger event configuration bit of line 8 */
N#define EXTI_RTSR_TR9_Pos         (9U)                                         
N#define EXTI_RTSR_TR9_Msk         (0x1UL << EXTI_RTSR_TR9_Pos)                  /*!< 0x00000200 */
N#define EXTI_RTSR_TR9             EXTI_RTSR_TR9_Msk                            /*!< Rising trigger event configuration bit of line 9 */
N#define EXTI_RTSR_TR10_Pos        (10U)                                        
N#define EXTI_RTSR_TR10_Msk        (0x1UL << EXTI_RTSR_TR10_Pos)                 /*!< 0x00000400 */
N#define EXTI_RTSR_TR10            EXTI_RTSR_TR10_Msk                           /*!< Rising trigger event configuration bit of line 10 */
N#define EXTI_RTSR_TR11_Pos        (11U)                                        
N#define EXTI_RTSR_TR11_Msk        (0x1UL << EXTI_RTSR_TR11_Pos)                 /*!< 0x00000800 */
N#define EXTI_RTSR_TR11            EXTI_RTSR_TR11_Msk                           /*!< Rising trigger event configuration bit of line 11 */
N#define EXTI_RTSR_TR12_Pos        (12U)                                        
N#define EXTI_RTSR_TR12_Msk        (0x1UL << EXTI_RTSR_TR12_Pos)                 /*!< 0x00001000 */
N#define EXTI_RTSR_TR12            EXTI_RTSR_TR12_Msk                           /*!< Rising trigger event configuration bit of line 12 */
N#define EXTI_RTSR_TR13_Pos        (13U)                                        
N#define EXTI_RTSR_TR13_Msk        (0x1UL << EXTI_RTSR_TR13_Pos)                 /*!< 0x00002000 */
N#define EXTI_RTSR_TR13            EXTI_RTSR_TR13_Msk                           /*!< Rising trigger event configuration bit of line 13 */
N#define EXTI_RTSR_TR14_Pos        (14U)                                        
N#define EXTI_RTSR_TR14_Msk        (0x1UL << EXTI_RTSR_TR14_Pos)                 /*!< 0x00004000 */
N#define EXTI_RTSR_TR14            EXTI_RTSR_TR14_Msk                           /*!< Rising trigger event configuration bit of line 14 */
N#define EXTI_RTSR_TR15_Pos        (15U)                                        
N#define EXTI_RTSR_TR15_Msk        (0x1UL << EXTI_RTSR_TR15_Pos)                 /*!< 0x00008000 */
N#define EXTI_RTSR_TR15            EXTI_RTSR_TR15_Msk                           /*!< Rising trigger event configuration bit of line 15 */
N#define EXTI_RTSR_TR16_Pos        (16U)                                        
N#define EXTI_RTSR_TR16_Msk        (0x1UL << EXTI_RTSR_TR16_Pos)                 /*!< 0x00010000 */
N#define EXTI_RTSR_TR16            EXTI_RTSR_TR16_Msk                           /*!< Rising trigger event configuration bit of line 16 */
N#define EXTI_RTSR_TR17_Pos        (17U)                                        
N#define EXTI_RTSR_TR17_Msk        (0x1UL << EXTI_RTSR_TR17_Pos)                 /*!< 0x00020000 */
N#define EXTI_RTSR_TR17            EXTI_RTSR_TR17_Msk                           /*!< Rising trigger event configuration bit of line 17 */
N#define EXTI_RTSR_TR18_Pos        (18U)                                        
N#define EXTI_RTSR_TR18_Msk        (0x1UL << EXTI_RTSR_TR18_Pos)                 /*!< 0x00040000 */
N#define EXTI_RTSR_TR18            EXTI_RTSR_TR18_Msk                           /*!< Rising trigger event configuration bit of line 18 */
N#define EXTI_RTSR_TR19_Pos        (19U)                                        
N#define EXTI_RTSR_TR19_Msk        (0x1UL << EXTI_RTSR_TR19_Pos)                 /*!< 0x00080000 */
N#define EXTI_RTSR_TR19            EXTI_RTSR_TR19_Msk                           /*!< Rising trigger event configuration bit of line 19 */
N#define EXTI_RTSR_TR20_Pos        (20U)                                        
N#define EXTI_RTSR_TR20_Msk        (0x1UL << EXTI_RTSR_TR20_Pos)                 /*!< 0x00100000 */
N#define EXTI_RTSR_TR20            EXTI_RTSR_TR20_Msk                           /*!< Rising trigger event configuration bit of line 20 */
N#define EXTI_RTSR_TR21_Pos        (21U)                                        
N#define EXTI_RTSR_TR21_Msk        (0x1UL << EXTI_RTSR_TR21_Pos)                 /*!< 0x00200000 */
N#define EXTI_RTSR_TR21            EXTI_RTSR_TR21_Msk                           /*!< Rising trigger event configuration bit of line 21 */
N#define EXTI_RTSR_TR22_Pos        (22U)                                        
N#define EXTI_RTSR_TR22_Msk        (0x1UL << EXTI_RTSR_TR22_Pos)                 /*!< 0x00400000 */
N#define EXTI_RTSR_TR22            EXTI_RTSR_TR22_Msk                           /*!< Rising trigger event configuration bit of line 22 */
N
N/******************  Bit definition for EXTI_FTSR register  *******************/
N#define EXTI_FTSR_TR0_Pos         (0U)                                         
N#define EXTI_FTSR_TR0_Msk         (0x1UL << EXTI_FTSR_TR0_Pos)                  /*!< 0x00000001 */
N#define EXTI_FTSR_TR0             EXTI_FTSR_TR0_Msk                            /*!< Falling trigger event configuration bit of line 0 */
N#define EXTI_FTSR_TR1_Pos         (1U)                                         
N#define EXTI_FTSR_TR1_Msk         (0x1UL << EXTI_FTSR_TR1_Pos)                  /*!< 0x00000002 */
N#define EXTI_FTSR_TR1             EXTI_FTSR_TR1_Msk                            /*!< Falling trigger event configuration bit of line 1 */
N#define EXTI_FTSR_TR2_Pos         (2U)                                         
N#define EXTI_FTSR_TR2_Msk         (0x1UL << EXTI_FTSR_TR2_Pos)                  /*!< 0x00000004 */
N#define EXTI_FTSR_TR2             EXTI_FTSR_TR2_Msk                            /*!< Falling trigger event configuration bit of line 2 */
N#define EXTI_FTSR_TR3_Pos         (3U)                                         
N#define EXTI_FTSR_TR3_Msk         (0x1UL << EXTI_FTSR_TR3_Pos)                  /*!< 0x00000008 */
N#define EXTI_FTSR_TR3             EXTI_FTSR_TR3_Msk                            /*!< Falling trigger event configuration bit of line 3 */
N#define EXTI_FTSR_TR4_Pos         (4U)                                         
N#define EXTI_FTSR_TR4_Msk         (0x1UL << EXTI_FTSR_TR4_Pos)                  /*!< 0x00000010 */
N#define EXTI_FTSR_TR4             EXTI_FTSR_TR4_Msk                            /*!< Falling trigger event configuration bit of line 4 */
N#define EXTI_FTSR_TR5_Pos         (5U)                                         
N#define EXTI_FTSR_TR5_Msk         (0x1UL << EXTI_FTSR_TR5_Pos)                  /*!< 0x00000020 */
N#define EXTI_FTSR_TR5             EXTI_FTSR_TR5_Msk                            /*!< Falling trigger event configuration bit of line 5 */
N#define EXTI_FTSR_TR6_Pos         (6U)                                         
N#define EXTI_FTSR_TR6_Msk         (0x1UL << EXTI_FTSR_TR6_Pos)                  /*!< 0x00000040 */
N#define EXTI_FTSR_TR6             EXTI_FTSR_TR6_Msk                            /*!< Falling trigger event configuration bit of line 6 */
N#define EXTI_FTSR_TR7_Pos         (7U)                                         
N#define EXTI_FTSR_TR7_Msk         (0x1UL << EXTI_FTSR_TR7_Pos)                  /*!< 0x00000080 */
N#define EXTI_FTSR_TR7             EXTI_FTSR_TR7_Msk                            /*!< Falling trigger event configuration bit of line 7 */
N#define EXTI_FTSR_TR8_Pos         (8U)                                         
N#define EXTI_FTSR_TR8_Msk         (0x1UL << EXTI_FTSR_TR8_Pos)                  /*!< 0x00000100 */
N#define EXTI_FTSR_TR8             EXTI_FTSR_TR8_Msk                            /*!< Falling trigger event configuration bit of line 8 */
N#define EXTI_FTSR_TR9_Pos         (9U)                                         
N#define EXTI_FTSR_TR9_Msk         (0x1UL << EXTI_FTSR_TR9_Pos)                  /*!< 0x00000200 */
N#define EXTI_FTSR_TR9             EXTI_FTSR_TR9_Msk                            /*!< Falling trigger event configuration bit of line 9 */
N#define EXTI_FTSR_TR10_Pos        (10U)                                        
N#define EXTI_FTSR_TR10_Msk        (0x1UL << EXTI_FTSR_TR10_Pos)                 /*!< 0x00000400 */
N#define EXTI_FTSR_TR10            EXTI_FTSR_TR10_Msk                           /*!< Falling trigger event configuration bit of line 10 */
N#define EXTI_FTSR_TR11_Pos        (11U)                                        
N#define EXTI_FTSR_TR11_Msk        (0x1UL << EXTI_FTSR_TR11_Pos)                 /*!< 0x00000800 */
N#define EXTI_FTSR_TR11            EXTI_FTSR_TR11_Msk                           /*!< Falling trigger event configuration bit of line 11 */
N#define EXTI_FTSR_TR12_Pos        (12U)                                        
N#define EXTI_FTSR_TR12_Msk        (0x1UL << EXTI_FTSR_TR12_Pos)                 /*!< 0x00001000 */
N#define EXTI_FTSR_TR12            EXTI_FTSR_TR12_Msk                           /*!< Falling trigger event configuration bit of line 12 */
N#define EXTI_FTSR_TR13_Pos        (13U)                                        
N#define EXTI_FTSR_TR13_Msk        (0x1UL << EXTI_FTSR_TR13_Pos)                 /*!< 0x00002000 */
N#define EXTI_FTSR_TR13            EXTI_FTSR_TR13_Msk                           /*!< Falling trigger event configuration bit of line 13 */
N#define EXTI_FTSR_TR14_Pos        (14U)                                        
N#define EXTI_FTSR_TR14_Msk        (0x1UL << EXTI_FTSR_TR14_Pos)                 /*!< 0x00004000 */
N#define EXTI_FTSR_TR14            EXTI_FTSR_TR14_Msk                           /*!< Falling trigger event configuration bit of line 14 */
N#define EXTI_FTSR_TR15_Pos        (15U)                                        
N#define EXTI_FTSR_TR15_Msk        (0x1UL << EXTI_FTSR_TR15_Pos)                 /*!< 0x00008000 */
N#define EXTI_FTSR_TR15            EXTI_FTSR_TR15_Msk                           /*!< Falling trigger event configuration bit of line 15 */
N#define EXTI_FTSR_TR16_Pos        (16U)                                        
N#define EXTI_FTSR_TR16_Msk        (0x1UL << EXTI_FTSR_TR16_Pos)                 /*!< 0x00010000 */
N#define EXTI_FTSR_TR16            EXTI_FTSR_TR16_Msk                           /*!< Falling trigger event configuration bit of line 16 */
N#define EXTI_FTSR_TR17_Pos        (17U)                                        
N#define EXTI_FTSR_TR17_Msk        (0x1UL << EXTI_FTSR_TR17_Pos)                 /*!< 0x00020000 */
N#define EXTI_FTSR_TR17            EXTI_FTSR_TR17_Msk                           /*!< Falling trigger event configuration bit of line 17 */
N#define EXTI_FTSR_TR18_Pos        (18U)                                        
N#define EXTI_FTSR_TR18_Msk        (0x1UL << EXTI_FTSR_TR18_Pos)                 /*!< 0x00040000 */
N#define EXTI_FTSR_TR18            EXTI_FTSR_TR18_Msk                           /*!< Falling trigger event configuration bit of line 18 */
N#define EXTI_FTSR_TR19_Pos        (19U)                                        
N#define EXTI_FTSR_TR19_Msk        (0x1UL << EXTI_FTSR_TR19_Pos)                 /*!< 0x00080000 */
N#define EXTI_FTSR_TR19            EXTI_FTSR_TR19_Msk                           /*!< Falling trigger event configuration bit of line 19 */
N#define EXTI_FTSR_TR20_Pos        (20U)                                        
N#define EXTI_FTSR_TR20_Msk        (0x1UL << EXTI_FTSR_TR20_Pos)                 /*!< 0x00100000 */
N#define EXTI_FTSR_TR20            EXTI_FTSR_TR20_Msk                           /*!< Falling trigger event configuration bit of line 20 */
N#define EXTI_FTSR_TR21_Pos        (21U)                                        
N#define EXTI_FTSR_TR21_Msk        (0x1UL << EXTI_FTSR_TR21_Pos)                 /*!< 0x00200000 */
N#define EXTI_FTSR_TR21            EXTI_FTSR_TR21_Msk                           /*!< Falling trigger event configuration bit of line 21 */
N#define EXTI_FTSR_TR22_Pos        (22U)                                        
N#define EXTI_FTSR_TR22_Msk        (0x1UL << EXTI_FTSR_TR22_Pos)                 /*!< 0x00400000 */
N#define EXTI_FTSR_TR22            EXTI_FTSR_TR22_Msk                           /*!< Falling trigger event configuration bit of line 22 */
N
N/******************  Bit definition for EXTI_SWIER register  ******************/
N#define EXTI_SWIER_SWIER0_Pos     (0U)                                         
N#define EXTI_SWIER_SWIER0_Msk     (0x1UL << EXTI_SWIER_SWIER0_Pos)              /*!< 0x00000001 */
N#define EXTI_SWIER_SWIER0         EXTI_SWIER_SWIER0_Msk                        /*!< Software Interrupt on line 0 */
N#define EXTI_SWIER_SWIER1_Pos     (1U)                                         
N#define EXTI_SWIER_SWIER1_Msk     (0x1UL << EXTI_SWIER_SWIER1_Pos)              /*!< 0x00000002 */
N#define EXTI_SWIER_SWIER1         EXTI_SWIER_SWIER1_Msk                        /*!< Software Interrupt on line 1 */
N#define EXTI_SWIER_SWIER2_Pos     (2U)                                         
N#define EXTI_SWIER_SWIER2_Msk     (0x1UL << EXTI_SWIER_SWIER2_Pos)              /*!< 0x00000004 */
N#define EXTI_SWIER_SWIER2         EXTI_SWIER_SWIER2_Msk                        /*!< Software Interrupt on line 2 */
N#define EXTI_SWIER_SWIER3_Pos     (3U)                                         
N#define EXTI_SWIER_SWIER3_Msk     (0x1UL << EXTI_SWIER_SWIER3_Pos)              /*!< 0x00000008 */
N#define EXTI_SWIER_SWIER3         EXTI_SWIER_SWIER3_Msk                        /*!< Software Interrupt on line 3 */
N#define EXTI_SWIER_SWIER4_Pos     (4U)                                         
N#define EXTI_SWIER_SWIER4_Msk     (0x1UL << EXTI_SWIER_SWIER4_Pos)              /*!< 0x00000010 */
N#define EXTI_SWIER_SWIER4         EXTI_SWIER_SWIER4_Msk                        /*!< Software Interrupt on line 4 */
N#define EXTI_SWIER_SWIER5_Pos     (5U)                                         
N#define EXTI_SWIER_SWIER5_Msk     (0x1UL << EXTI_SWIER_SWIER5_Pos)              /*!< 0x00000020 */
N#define EXTI_SWIER_SWIER5         EXTI_SWIER_SWIER5_Msk                        /*!< Software Interrupt on line 5 */
N#define EXTI_SWIER_SWIER6_Pos     (6U)                                         
N#define EXTI_SWIER_SWIER6_Msk     (0x1UL << EXTI_SWIER_SWIER6_Pos)              /*!< 0x00000040 */
N#define EXTI_SWIER_SWIER6         EXTI_SWIER_SWIER6_Msk                        /*!< Software Interrupt on line 6 */
N#define EXTI_SWIER_SWIER7_Pos     (7U)                                         
N#define EXTI_SWIER_SWIER7_Msk     (0x1UL << EXTI_SWIER_SWIER7_Pos)              /*!< 0x00000080 */
N#define EXTI_SWIER_SWIER7         EXTI_SWIER_SWIER7_Msk                        /*!< Software Interrupt on line 7 */
N#define EXTI_SWIER_SWIER8_Pos     (8U)                                         
N#define EXTI_SWIER_SWIER8_Msk     (0x1UL << EXTI_SWIER_SWIER8_Pos)              /*!< 0x00000100 */
N#define EXTI_SWIER_SWIER8         EXTI_SWIER_SWIER8_Msk                        /*!< Software Interrupt on line 8 */
N#define EXTI_SWIER_SWIER9_Pos     (9U)                                         
N#define EXTI_SWIER_SWIER9_Msk     (0x1UL << EXTI_SWIER_SWIER9_Pos)              /*!< 0x00000200 */
N#define EXTI_SWIER_SWIER9         EXTI_SWIER_SWIER9_Msk                        /*!< Software Interrupt on line 9 */
N#define EXTI_SWIER_SWIER10_Pos    (10U)                                        
N#define EXTI_SWIER_SWIER10_Msk    (0x1UL << EXTI_SWIER_SWIER10_Pos)             /*!< 0x00000400 */
N#define EXTI_SWIER_SWIER10        EXTI_SWIER_SWIER10_Msk                       /*!< Software Interrupt on line 10 */
N#define EXTI_SWIER_SWIER11_Pos    (11U)                                        
N#define EXTI_SWIER_SWIER11_Msk    (0x1UL << EXTI_SWIER_SWIER11_Pos)             /*!< 0x00000800 */
N#define EXTI_SWIER_SWIER11        EXTI_SWIER_SWIER11_Msk                       /*!< Software Interrupt on line 11 */
N#define EXTI_SWIER_SWIER12_Pos    (12U)                                        
N#define EXTI_SWIER_SWIER12_Msk    (0x1UL << EXTI_SWIER_SWIER12_Pos)             /*!< 0x00001000 */
N#define EXTI_SWIER_SWIER12        EXTI_SWIER_SWIER12_Msk                       /*!< Software Interrupt on line 12 */
N#define EXTI_SWIER_SWIER13_Pos    (13U)                                        
N#define EXTI_SWIER_SWIER13_Msk    (0x1UL << EXTI_SWIER_SWIER13_Pos)             /*!< 0x00002000 */
N#define EXTI_SWIER_SWIER13        EXTI_SWIER_SWIER13_Msk                       /*!< Software Interrupt on line 13 */
N#define EXTI_SWIER_SWIER14_Pos    (14U)                                        
N#define EXTI_SWIER_SWIER14_Msk    (0x1UL << EXTI_SWIER_SWIER14_Pos)             /*!< 0x00004000 */
N#define EXTI_SWIER_SWIER14        EXTI_SWIER_SWIER14_Msk                       /*!< Software Interrupt on line 14 */
N#define EXTI_SWIER_SWIER15_Pos    (15U)                                        
N#define EXTI_SWIER_SWIER15_Msk    (0x1UL << EXTI_SWIER_SWIER15_Pos)             /*!< 0x00008000 */
N#define EXTI_SWIER_SWIER15        EXTI_SWIER_SWIER15_Msk                       /*!< Software Interrupt on line 15 */
N#define EXTI_SWIER_SWIER16_Pos    (16U)                                        
N#define EXTI_SWIER_SWIER16_Msk    (0x1UL << EXTI_SWIER_SWIER16_Pos)             /*!< 0x00010000 */
N#define EXTI_SWIER_SWIER16        EXTI_SWIER_SWIER16_Msk                       /*!< Software Interrupt on line 16 */
N#define EXTI_SWIER_SWIER17_Pos    (17U)                                        
N#define EXTI_SWIER_SWIER17_Msk    (0x1UL << EXTI_SWIER_SWIER17_Pos)             /*!< 0x00020000 */
N#define EXTI_SWIER_SWIER17        EXTI_SWIER_SWIER17_Msk                       /*!< Software Interrupt on line 17 */
N#define EXTI_SWIER_SWIER18_Pos    (18U)                                        
N#define EXTI_SWIER_SWIER18_Msk    (0x1UL << EXTI_SWIER_SWIER18_Pos)             /*!< 0x00040000 */
N#define EXTI_SWIER_SWIER18        EXTI_SWIER_SWIER18_Msk                       /*!< Software Interrupt on line 18 */
N#define EXTI_SWIER_SWIER19_Pos    (19U)                                        
N#define EXTI_SWIER_SWIER19_Msk    (0x1UL << EXTI_SWIER_SWIER19_Pos)             /*!< 0x00080000 */
N#define EXTI_SWIER_SWIER19        EXTI_SWIER_SWIER19_Msk                       /*!< Software Interrupt on line 19 */
N#define EXTI_SWIER_SWIER20_Pos    (20U)                                        
N#define EXTI_SWIER_SWIER20_Msk    (0x1UL << EXTI_SWIER_SWIER20_Pos)             /*!< 0x00100000 */
N#define EXTI_SWIER_SWIER20        EXTI_SWIER_SWIER20_Msk                       /*!< Software Interrupt on line 20 */
N#define EXTI_SWIER_SWIER21_Pos    (21U)                                        
N#define EXTI_SWIER_SWIER21_Msk    (0x1UL << EXTI_SWIER_SWIER21_Pos)             /*!< 0x00200000 */
N#define EXTI_SWIER_SWIER21        EXTI_SWIER_SWIER21_Msk                       /*!< Software Interrupt on line 21 */
N#define EXTI_SWIER_SWIER22_Pos    (22U)                                        
N#define EXTI_SWIER_SWIER22_Msk    (0x1UL << EXTI_SWIER_SWIER22_Pos)             /*!< 0x00400000 */
N#define EXTI_SWIER_SWIER22        EXTI_SWIER_SWIER22_Msk                       /*!< Software Interrupt on line 22 */
N
N/*******************  Bit definition for EXTI_PR register  ********************/
N#define EXTI_PR_PR0_Pos           (0U)                                         
N#define EXTI_PR_PR0_Msk           (0x1UL << EXTI_PR_PR0_Pos)                    /*!< 0x00000001 */
N#define EXTI_PR_PR0               EXTI_PR_PR0_Msk                              /*!< Pending bit for line 0 */
N#define EXTI_PR_PR1_Pos           (1U)                                         
N#define EXTI_PR_PR1_Msk           (0x1UL << EXTI_PR_PR1_Pos)                    /*!< 0x00000002 */
N#define EXTI_PR_PR1               EXTI_PR_PR1_Msk                              /*!< Pending bit for line 1 */
N#define EXTI_PR_PR2_Pos           (2U)                                         
N#define EXTI_PR_PR2_Msk           (0x1UL << EXTI_PR_PR2_Pos)                    /*!< 0x00000004 */
N#define EXTI_PR_PR2               EXTI_PR_PR2_Msk                              /*!< Pending bit for line 2 */
N#define EXTI_PR_PR3_Pos           (3U)                                         
N#define EXTI_PR_PR3_Msk           (0x1UL << EXTI_PR_PR3_Pos)                    /*!< 0x00000008 */
N#define EXTI_PR_PR3               EXTI_PR_PR3_Msk                              /*!< Pending bit for line 3 */
N#define EXTI_PR_PR4_Pos           (4U)                                         
N#define EXTI_PR_PR4_Msk           (0x1UL << EXTI_PR_PR4_Pos)                    /*!< 0x00000010 */
N#define EXTI_PR_PR4               EXTI_PR_PR4_Msk                              /*!< Pending bit for line 4 */
N#define EXTI_PR_PR5_Pos           (5U)                                         
N#define EXTI_PR_PR5_Msk           (0x1UL << EXTI_PR_PR5_Pos)                    /*!< 0x00000020 */
N#define EXTI_PR_PR5               EXTI_PR_PR5_Msk                              /*!< Pending bit for line 5 */
N#define EXTI_PR_PR6_Pos           (6U)                                         
N#define EXTI_PR_PR6_Msk           (0x1UL << EXTI_PR_PR6_Pos)                    /*!< 0x00000040 */
N#define EXTI_PR_PR6               EXTI_PR_PR6_Msk                              /*!< Pending bit for line 6 */
N#define EXTI_PR_PR7_Pos           (7U)                                         
N#define EXTI_PR_PR7_Msk           (0x1UL << EXTI_PR_PR7_Pos)                    /*!< 0x00000080 */
N#define EXTI_PR_PR7               EXTI_PR_PR7_Msk                              /*!< Pending bit for line 7 */
N#define EXTI_PR_PR8_Pos           (8U)                                         
N#define EXTI_PR_PR8_Msk           (0x1UL << EXTI_PR_PR8_Pos)                    /*!< 0x00000100 */
N#define EXTI_PR_PR8               EXTI_PR_PR8_Msk                              /*!< Pending bit for line 8 */
N#define EXTI_PR_PR9_Pos           (9U)                                         
N#define EXTI_PR_PR9_Msk           (0x1UL << EXTI_PR_PR9_Pos)                    /*!< 0x00000200 */
N#define EXTI_PR_PR9               EXTI_PR_PR9_Msk                              /*!< Pending bit for line 9 */
N#define EXTI_PR_PR10_Pos          (10U)                                        
N#define EXTI_PR_PR10_Msk          (0x1UL << EXTI_PR_PR10_Pos)                   /*!< 0x00000400 */
N#define EXTI_PR_PR10              EXTI_PR_PR10_Msk                             /*!< Pending bit for line 10 */
N#define EXTI_PR_PR11_Pos          (11U)                                        
N#define EXTI_PR_PR11_Msk          (0x1UL << EXTI_PR_PR11_Pos)                   /*!< 0x00000800 */
N#define EXTI_PR_PR11              EXTI_PR_PR11_Msk                             /*!< Pending bit for line 11 */
N#define EXTI_PR_PR12_Pos          (12U)                                        
N#define EXTI_PR_PR12_Msk          (0x1UL << EXTI_PR_PR12_Pos)                   /*!< 0x00001000 */
N#define EXTI_PR_PR12              EXTI_PR_PR12_Msk                             /*!< Pending bit for line 12 */
N#define EXTI_PR_PR13_Pos          (13U)                                        
N#define EXTI_PR_PR13_Msk          (0x1UL << EXTI_PR_PR13_Pos)                   /*!< 0x00002000 */
N#define EXTI_PR_PR13              EXTI_PR_PR13_Msk                             /*!< Pending bit for line 13 */
N#define EXTI_PR_PR14_Pos          (14U)                                        
N#define EXTI_PR_PR14_Msk          (0x1UL << EXTI_PR_PR14_Pos)                   /*!< 0x00004000 */
N#define EXTI_PR_PR14              EXTI_PR_PR14_Msk                             /*!< Pending bit for line 14 */
N#define EXTI_PR_PR15_Pos          (15U)                                        
N#define EXTI_PR_PR15_Msk          (0x1UL << EXTI_PR_PR15_Pos)                   /*!< 0x00008000 */
N#define EXTI_PR_PR15              EXTI_PR_PR15_Msk                             /*!< Pending bit for line 15 */
N#define EXTI_PR_PR16_Pos          (16U)                                        
N#define EXTI_PR_PR16_Msk          (0x1UL << EXTI_PR_PR16_Pos)                   /*!< 0x00010000 */
N#define EXTI_PR_PR16              EXTI_PR_PR16_Msk                             /*!< Pending bit for line 16 */
N#define EXTI_PR_PR17_Pos          (17U)                                        
N#define EXTI_PR_PR17_Msk          (0x1UL << EXTI_PR_PR17_Pos)                   /*!< 0x00020000 */
N#define EXTI_PR_PR17              EXTI_PR_PR17_Msk                             /*!< Pending bit for line 17 */
N#define EXTI_PR_PR18_Pos          (18U)                                        
N#define EXTI_PR_PR18_Msk          (0x1UL << EXTI_PR_PR18_Pos)                   /*!< 0x00040000 */
N#define EXTI_PR_PR18              EXTI_PR_PR18_Msk                             /*!< Pending bit for line 18 */
N#define EXTI_PR_PR19_Pos          (19U)                                        
N#define EXTI_PR_PR19_Msk          (0x1UL << EXTI_PR_PR19_Pos)                   /*!< 0x00080000 */
N#define EXTI_PR_PR19              EXTI_PR_PR19_Msk                             /*!< Pending bit for line 19 */
N#define EXTI_PR_PR20_Pos          (20U)                                        
N#define EXTI_PR_PR20_Msk          (0x1UL << EXTI_PR_PR20_Pos)                   /*!< 0x00100000 */
N#define EXTI_PR_PR20              EXTI_PR_PR20_Msk                             /*!< Pending bit for line 20 */
N#define EXTI_PR_PR21_Pos          (21U)                                        
N#define EXTI_PR_PR21_Msk          (0x1UL << EXTI_PR_PR21_Pos)                   /*!< 0x00200000 */
N#define EXTI_PR_PR21              EXTI_PR_PR21_Msk                             /*!< Pending bit for line 21 */
N#define EXTI_PR_PR22_Pos          (22U)                                        
N#define EXTI_PR_PR22_Msk          (0x1UL << EXTI_PR_PR22_Pos)                   /*!< 0x00400000 */
N#define EXTI_PR_PR22              EXTI_PR_PR22_Msk                             /*!< Pending bit for line 22 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    FLASH                                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bits definition for FLASH_ACR register  *****************/
N#define FLASH_ACR_LATENCY_Pos          (0U)
N#define FLASH_ACR_LATENCY_Msk          (0x7UL << FLASH_ACR_LATENCY_Pos)         /*!< 0x00000007 */
N#define FLASH_ACR_LATENCY              FLASH_ACR_LATENCY_Msk
N#define FLASH_ACR_LATENCY_0WS          0x00000000U
N#define FLASH_ACR_LATENCY_1WS          0x00000001U
N#define FLASH_ACR_LATENCY_2WS          0x00000002U
N#define FLASH_ACR_LATENCY_3WS          0x00000003U
N#define FLASH_ACR_LATENCY_4WS          0x00000004U
N#define FLASH_ACR_LATENCY_5WS          0x00000005U
N#define FLASH_ACR_LATENCY_6WS          0x00000006U
N#define FLASH_ACR_LATENCY_7WS          0x00000007U
N
N
N#define FLASH_ACR_PRFTEN_Pos           (8U)                                    
N#define FLASH_ACR_PRFTEN_Msk           (0x1UL << FLASH_ACR_PRFTEN_Pos)          /*!< 0x00000100 */
N#define FLASH_ACR_PRFTEN               FLASH_ACR_PRFTEN_Msk                    
N#define FLASH_ACR_ICEN_Pos             (9U)                                    
N#define FLASH_ACR_ICEN_Msk             (0x1UL << FLASH_ACR_ICEN_Pos)            /*!< 0x00000200 */
N#define FLASH_ACR_ICEN                 FLASH_ACR_ICEN_Msk                      
N#define FLASH_ACR_DCEN_Pos             (10U)                                   
N#define FLASH_ACR_DCEN_Msk             (0x1UL << FLASH_ACR_DCEN_Pos)            /*!< 0x00000400 */
N#define FLASH_ACR_DCEN                 FLASH_ACR_DCEN_Msk                      
N#define FLASH_ACR_ICRST_Pos            (11U)                                   
N#define FLASH_ACR_ICRST_Msk            (0x1UL << FLASH_ACR_ICRST_Pos)           /*!< 0x00000800 */
N#define FLASH_ACR_ICRST                FLASH_ACR_ICRST_Msk                     
N#define FLASH_ACR_DCRST_Pos            (12U)                                   
N#define FLASH_ACR_DCRST_Msk            (0x1UL << FLASH_ACR_DCRST_Pos)           /*!< 0x00001000 */
N#define FLASH_ACR_DCRST                FLASH_ACR_DCRST_Msk                     
N#define FLASH_ACR_BYTE0_ADDRESS_Pos    (10U)                                   
N#define FLASH_ACR_BYTE0_ADDRESS_Msk    (0x10008FUL << FLASH_ACR_BYTE0_ADDRESS_Pos) /*!< 0x40023C00 */
N#define FLASH_ACR_BYTE0_ADDRESS        FLASH_ACR_BYTE0_ADDRESS_Msk             
N#define FLASH_ACR_BYTE2_ADDRESS_Pos    (0U)                                    
N#define FLASH_ACR_BYTE2_ADDRESS_Msk    (0x40023C03UL << FLASH_ACR_BYTE2_ADDRESS_Pos) /*!< 0x40023C03 */
N#define FLASH_ACR_BYTE2_ADDRESS        FLASH_ACR_BYTE2_ADDRESS_Msk             
N
N/*******************  Bits definition for FLASH_SR register  ******************/
N#define FLASH_SR_EOP_Pos               (0U)                                    
N#define FLASH_SR_EOP_Msk               (0x1UL << FLASH_SR_EOP_Pos)              /*!< 0x00000001 */
N#define FLASH_SR_EOP                   FLASH_SR_EOP_Msk                        
N#define FLASH_SR_SOP_Pos               (1U)                                    
N#define FLASH_SR_SOP_Msk               (0x1UL << FLASH_SR_SOP_Pos)              /*!< 0x00000002 */
N#define FLASH_SR_SOP                   FLASH_SR_SOP_Msk                        
N#define FLASH_SR_WRPERR_Pos            (4U)                                    
N#define FLASH_SR_WRPERR_Msk            (0x1UL << FLASH_SR_WRPERR_Pos)           /*!< 0x00000010 */
N#define FLASH_SR_WRPERR                FLASH_SR_WRPERR_Msk                     
N#define FLASH_SR_PGAERR_Pos            (5U)                                    
N#define FLASH_SR_PGAERR_Msk            (0x1UL << FLASH_SR_PGAERR_Pos)           /*!< 0x00000020 */
N#define FLASH_SR_PGAERR                FLASH_SR_PGAERR_Msk                     
N#define FLASH_SR_PGPERR_Pos            (6U)                                    
N#define FLASH_SR_PGPERR_Msk            (0x1UL << FLASH_SR_PGPERR_Pos)           /*!< 0x00000040 */
N#define FLASH_SR_PGPERR                FLASH_SR_PGPERR_Msk                     
N#define FLASH_SR_PGSERR_Pos            (7U)                                    
N#define FLASH_SR_PGSERR_Msk            (0x1UL << FLASH_SR_PGSERR_Pos)           /*!< 0x00000080 */
N#define FLASH_SR_PGSERR                FLASH_SR_PGSERR_Msk                     
N#define FLASH_SR_BSY_Pos               (16U)                                   
N#define FLASH_SR_BSY_Msk               (0x1UL << FLASH_SR_BSY_Pos)              /*!< 0x00010000 */
N#define FLASH_SR_BSY                   FLASH_SR_BSY_Msk                        
N
N/*******************  Bits definition for FLASH_CR register  ******************/
N#define FLASH_CR_PG_Pos                (0U)                                    
N#define FLASH_CR_PG_Msk                (0x1UL << FLASH_CR_PG_Pos)               /*!< 0x00000001 */
N#define FLASH_CR_PG                    FLASH_CR_PG_Msk                         
N#define FLASH_CR_SER_Pos               (1U)                                    
N#define FLASH_CR_SER_Msk               (0x1UL << FLASH_CR_SER_Pos)              /*!< 0x00000002 */
N#define FLASH_CR_SER                   FLASH_CR_SER_Msk                        
N#define FLASH_CR_MER_Pos               (2U)                                    
N#define FLASH_CR_MER_Msk               (0x1UL << FLASH_CR_MER_Pos)              /*!< 0x00000004 */
N#define FLASH_CR_MER                   FLASH_CR_MER_Msk                        
N#define FLASH_CR_SNB_Pos               (3U)                                    
N#define FLASH_CR_SNB_Msk               (0x1FUL << FLASH_CR_SNB_Pos)             /*!< 0x000000F8 */
N#define FLASH_CR_SNB                   FLASH_CR_SNB_Msk                        
N#define FLASH_CR_SNB_0                 (0x01UL << FLASH_CR_SNB_Pos)             /*!< 0x00000008 */
N#define FLASH_CR_SNB_1                 (0x02UL << FLASH_CR_SNB_Pos)             /*!< 0x00000010 */
N#define FLASH_CR_SNB_2                 (0x04UL << FLASH_CR_SNB_Pos)             /*!< 0x00000020 */
N#define FLASH_CR_SNB_3                 (0x08UL << FLASH_CR_SNB_Pos)             /*!< 0x00000040 */
N#define FLASH_CR_SNB_4                 (0x10UL << FLASH_CR_SNB_Pos)             /*!< 0x00000080 */
N#define FLASH_CR_PSIZE_Pos             (8U)                                    
N#define FLASH_CR_PSIZE_Msk             (0x3UL << FLASH_CR_PSIZE_Pos)            /*!< 0x00000300 */
N#define FLASH_CR_PSIZE                 FLASH_CR_PSIZE_Msk                      
N#define FLASH_CR_PSIZE_0               (0x1UL << FLASH_CR_PSIZE_Pos)            /*!< 0x00000100 */
N#define FLASH_CR_PSIZE_1               (0x2UL << FLASH_CR_PSIZE_Pos)            /*!< 0x00000200 */
N#define FLASH_CR_STRT_Pos              (16U)                                   
N#define FLASH_CR_STRT_Msk              (0x1UL << FLASH_CR_STRT_Pos)             /*!< 0x00010000 */
N#define FLASH_CR_STRT                  FLASH_CR_STRT_Msk                       
N#define FLASH_CR_EOPIE_Pos             (24U)                                   
N#define FLASH_CR_EOPIE_Msk             (0x1UL << FLASH_CR_EOPIE_Pos)            /*!< 0x01000000 */
N#define FLASH_CR_EOPIE                 FLASH_CR_EOPIE_Msk                      
N#define FLASH_CR_ERRIE_Pos             (25U)
N#define FLASH_CR_ERRIE_Msk             (0x1UL << FLASH_CR_ERRIE_Pos)
N#define FLASH_CR_ERRIE                 FLASH_CR_ERRIE_Msk
N#define FLASH_CR_LOCK_Pos              (31U)                                   
N#define FLASH_CR_LOCK_Msk              (0x1UL << FLASH_CR_LOCK_Pos)             /*!< 0x80000000 */
N#define FLASH_CR_LOCK                  FLASH_CR_LOCK_Msk                       
N
N/*******************  Bits definition for FLASH_OPTCR register  ***************/
N#define FLASH_OPTCR_OPTLOCK_Pos        (0U)                                    
N#define FLASH_OPTCR_OPTLOCK_Msk        (0x1UL << FLASH_OPTCR_OPTLOCK_Pos)       /*!< 0x00000001 */
N#define FLASH_OPTCR_OPTLOCK            FLASH_OPTCR_OPTLOCK_Msk                 
N#define FLASH_OPTCR_OPTSTRT_Pos        (1U)                                    
N#define FLASH_OPTCR_OPTSTRT_Msk        (0x1UL << FLASH_OPTCR_OPTSTRT_Pos)       /*!< 0x00000002 */
N#define FLASH_OPTCR_OPTSTRT            FLASH_OPTCR_OPTSTRT_Msk                 
N
N#define FLASH_OPTCR_BOR_LEV_0          0x00000004U                             
N#define FLASH_OPTCR_BOR_LEV_1          0x00000008U                             
N#define FLASH_OPTCR_BOR_LEV_Pos        (2U)                                    
N#define FLASH_OPTCR_BOR_LEV_Msk        (0x3UL << FLASH_OPTCR_BOR_LEV_Pos)       /*!< 0x0000000C */
N#define FLASH_OPTCR_BOR_LEV            FLASH_OPTCR_BOR_LEV_Msk                 
N#define FLASH_OPTCR_WDG_SW_Pos         (5U)                                    
N#define FLASH_OPTCR_WDG_SW_Msk         (0x1UL << FLASH_OPTCR_WDG_SW_Pos)        /*!< 0x00000020 */
N#define FLASH_OPTCR_WDG_SW             FLASH_OPTCR_WDG_SW_Msk                  
N#define FLASH_OPTCR_nRST_STOP_Pos      (6U)                                    
N#define FLASH_OPTCR_nRST_STOP_Msk      (0x1UL << FLASH_OPTCR_nRST_STOP_Pos)     /*!< 0x00000040 */
N#define FLASH_OPTCR_nRST_STOP          FLASH_OPTCR_nRST_STOP_Msk               
N#define FLASH_OPTCR_nRST_STDBY_Pos     (7U)                                    
N#define FLASH_OPTCR_nRST_STDBY_Msk     (0x1UL << FLASH_OPTCR_nRST_STDBY_Pos)    /*!< 0x00000080 */
N#define FLASH_OPTCR_nRST_STDBY         FLASH_OPTCR_nRST_STDBY_Msk              
N#define FLASH_OPTCR_RDP_Pos            (8U)                                    
N#define FLASH_OPTCR_RDP_Msk            (0xFFUL << FLASH_OPTCR_RDP_Pos)          /*!< 0x0000FF00 */
N#define FLASH_OPTCR_RDP                FLASH_OPTCR_RDP_Msk                     
N#define FLASH_OPTCR_RDP_0              (0x01UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00000100 */
N#define FLASH_OPTCR_RDP_1              (0x02UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00000200 */
N#define FLASH_OPTCR_RDP_2              (0x04UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00000400 */
N#define FLASH_OPTCR_RDP_3              (0x08UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00000800 */
N#define FLASH_OPTCR_RDP_4              (0x10UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00001000 */
N#define FLASH_OPTCR_RDP_5              (0x20UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00002000 */
N#define FLASH_OPTCR_RDP_6              (0x40UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00004000 */
N#define FLASH_OPTCR_RDP_7              (0x80UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00008000 */
N#define FLASH_OPTCR_nWRP_Pos           (16U)                                   
N#define FLASH_OPTCR_nWRP_Msk           (0xFFFUL << FLASH_OPTCR_nWRP_Pos)        /*!< 0x0FFF0000 */
N#define FLASH_OPTCR_nWRP               FLASH_OPTCR_nWRP_Msk                    
N#define FLASH_OPTCR_nWRP_0             0x00010000U                             
N#define FLASH_OPTCR_nWRP_1             0x00020000U                             
N#define FLASH_OPTCR_nWRP_2             0x00040000U                             
N#define FLASH_OPTCR_nWRP_3             0x00080000U                             
N#define FLASH_OPTCR_nWRP_4             0x00100000U                             
N#define FLASH_OPTCR_nWRP_5             0x00200000U                             
N#define FLASH_OPTCR_nWRP_6             0x00400000U                             
N#define FLASH_OPTCR_nWRP_7             0x00800000U                             
N#define FLASH_OPTCR_nWRP_8             0x01000000U                             
N#define FLASH_OPTCR_nWRP_9             0x02000000U                             
N#define FLASH_OPTCR_nWRP_10            0x04000000U                             
N#define FLASH_OPTCR_nWRP_11            0x08000000U                             
N                                             
N/******************  Bits definition for FLASH_OPTCR1 register  ***************/
N#define FLASH_OPTCR1_nWRP_Pos          (16U)                                   
N#define FLASH_OPTCR1_nWRP_Msk          (0xFFFUL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x0FFF0000 */
N#define FLASH_OPTCR1_nWRP              FLASH_OPTCR1_nWRP_Msk                   
N#define FLASH_OPTCR1_nWRP_0            (0x001UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00010000 */
N#define FLASH_OPTCR1_nWRP_1            (0x002UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00020000 */
N#define FLASH_OPTCR1_nWRP_2            (0x004UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00040000 */
N#define FLASH_OPTCR1_nWRP_3            (0x008UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00080000 */
N#define FLASH_OPTCR1_nWRP_4            (0x010UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00100000 */
N#define FLASH_OPTCR1_nWRP_5            (0x020UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00200000 */
N#define FLASH_OPTCR1_nWRP_6            (0x040UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00400000 */
N#define FLASH_OPTCR1_nWRP_7            (0x080UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00800000 */
N#define FLASH_OPTCR1_nWRP_8            (0x100UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x01000000 */
N#define FLASH_OPTCR1_nWRP_9            (0x200UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x02000000 */
N#define FLASH_OPTCR1_nWRP_10           (0x400UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x04000000 */
N#define FLASH_OPTCR1_nWRP_11           (0x800UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x08000000 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                   Flexible Static Memory Controller                        */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for FSMC_BCR1 register  *******************/
N#define FSMC_BCR1_MBKEN_Pos          (0U)                                      
N#define FSMC_BCR1_MBKEN_Msk          (0x1UL << FSMC_BCR1_MBKEN_Pos)             /*!< 0x00000001 */
N#define FSMC_BCR1_MBKEN              FSMC_BCR1_MBKEN_Msk                       /*!<Memory bank enable bit                 */
N#define FSMC_BCR1_MUXEN_Pos          (1U)                                      
N#define FSMC_BCR1_MUXEN_Msk          (0x1UL << FSMC_BCR1_MUXEN_Pos)             /*!< 0x00000002 */
N#define FSMC_BCR1_MUXEN              FSMC_BCR1_MUXEN_Msk                       /*!<Address/data multiplexing enable bit   */
N
N#define FSMC_BCR1_MTYP_Pos           (2U)                                      
N#define FSMC_BCR1_MTYP_Msk           (0x3UL << FSMC_BCR1_MTYP_Pos)              /*!< 0x0000000C */
N#define FSMC_BCR1_MTYP               FSMC_BCR1_MTYP_Msk                        /*!<MTYP[1:0] bits (Memory type)           */
N#define FSMC_BCR1_MTYP_0             (0x1UL << FSMC_BCR1_MTYP_Pos)              /*!< 0x00000004 */
N#define FSMC_BCR1_MTYP_1             (0x2UL << FSMC_BCR1_MTYP_Pos)              /*!< 0x00000008 */
N
N#define FSMC_BCR1_MWID_Pos           (4U)                                      
N#define FSMC_BCR1_MWID_Msk           (0x3UL << FSMC_BCR1_MWID_Pos)              /*!< 0x00000030 */
N#define FSMC_BCR1_MWID               FSMC_BCR1_MWID_Msk                        /*!<MWID[1:0] bits (Memory data bus width) */
N#define FSMC_BCR1_MWID_0             (0x1UL << FSMC_BCR1_MWID_Pos)              /*!< 0x00000010 */
N#define FSMC_BCR1_MWID_1             (0x2UL << FSMC_BCR1_MWID_Pos)              /*!< 0x00000020 */
N
N#define FSMC_BCR1_FACCEN_Pos         (6U)                                      
N#define FSMC_BCR1_FACCEN_Msk         (0x1UL << FSMC_BCR1_FACCEN_Pos)            /*!< 0x00000040 */
N#define FSMC_BCR1_FACCEN             FSMC_BCR1_FACCEN_Msk                      /*!<Flash access enable                    */
N#define FSMC_BCR1_BURSTEN_Pos        (8U)                                      
N#define FSMC_BCR1_BURSTEN_Msk        (0x1UL << FSMC_BCR1_BURSTEN_Pos)           /*!< 0x00000100 */
N#define FSMC_BCR1_BURSTEN            FSMC_BCR1_BURSTEN_Msk                     /*!<Burst enable bit                       */
N#define FSMC_BCR1_WAITPOL_Pos        (9U)                                      
N#define FSMC_BCR1_WAITPOL_Msk        (0x1UL << FSMC_BCR1_WAITPOL_Pos)           /*!< 0x00000200 */
N#define FSMC_BCR1_WAITPOL            FSMC_BCR1_WAITPOL_Msk                     /*!<Wait signal polarity bit               */
N#define FSMC_BCR1_WRAPMOD_Pos        (10U)                                     
N#define FSMC_BCR1_WRAPMOD_Msk        (0x1UL << FSMC_BCR1_WRAPMOD_Pos)           /*!< 0x00000400 */
N#define FSMC_BCR1_WRAPMOD            FSMC_BCR1_WRAPMOD_Msk                     /*!<Wrapped burst mode support             */
N#define FSMC_BCR1_WAITCFG_Pos        (11U)                                     
N#define FSMC_BCR1_WAITCFG_Msk        (0x1UL << FSMC_BCR1_WAITCFG_Pos)           /*!< 0x00000800 */
N#define FSMC_BCR1_WAITCFG            FSMC_BCR1_WAITCFG_Msk                     /*!<Wait timing configuration              */
N#define FSMC_BCR1_WREN_Pos           (12U)                                     
N#define FSMC_BCR1_WREN_Msk           (0x1UL << FSMC_BCR1_WREN_Pos)              /*!< 0x00001000 */
N#define FSMC_BCR1_WREN               FSMC_BCR1_WREN_Msk                        /*!<Write enable bit                       */
N#define FSMC_BCR1_WAITEN_Pos         (13U)                                     
N#define FSMC_BCR1_WAITEN_Msk         (0x1UL << FSMC_BCR1_WAITEN_Pos)            /*!< 0x00002000 */
N#define FSMC_BCR1_WAITEN             FSMC_BCR1_WAITEN_Msk                      /*!<Wait enable bit                        */
N#define FSMC_BCR1_EXTMOD_Pos         (14U)                                     
N#define FSMC_BCR1_EXTMOD_Msk         (0x1UL << FSMC_BCR1_EXTMOD_Pos)            /*!< 0x00004000 */
N#define FSMC_BCR1_EXTMOD             FSMC_BCR1_EXTMOD_Msk                      /*!<Extended mode enable                   */
N#define FSMC_BCR1_ASYNCWAIT_Pos      (15U)                                     
N#define FSMC_BCR1_ASYNCWAIT_Msk      (0x1UL << FSMC_BCR1_ASYNCWAIT_Pos)         /*!< 0x00008000 */
N#define FSMC_BCR1_ASYNCWAIT          FSMC_BCR1_ASYNCWAIT_Msk                   /*!<Asynchronous wait                      */
N#define FSMC_BCR1_CPSIZE_Pos         (16U)                                     
N#define FSMC_BCR1_CPSIZE_Msk         (0x7UL << FSMC_BCR1_CPSIZE_Pos)            /*!< 0x00070000 */
N#define FSMC_BCR1_CPSIZE             FSMC_BCR1_CPSIZE_Msk                      /*!<CRAM page size */
N#define FSMC_BCR1_CPSIZE_0           (0x1UL << FSMC_BCR1_CPSIZE_Pos)            /*!< 0x00010000 */
N#define FSMC_BCR1_CPSIZE_1           (0x2UL << FSMC_BCR1_CPSIZE_Pos)            /*!< 0x00020000 */
N#define FSMC_BCR1_CPSIZE_2           (0x4UL << FSMC_BCR1_CPSIZE_Pos)            /*!< 0x00040000 */
N#define FSMC_BCR1_CBURSTRW_Pos       (19U)                                     
N#define FSMC_BCR1_CBURSTRW_Msk       (0x1UL << FSMC_BCR1_CBURSTRW_Pos)          /*!< 0x00080000 */
N#define FSMC_BCR1_CBURSTRW           FSMC_BCR1_CBURSTRW_Msk                    /*!<Write burst enable                     */
N
N/******************  Bit definition for FSMC_BCR2 register  *******************/
N#define FSMC_BCR2_MBKEN_Pos          (0U)                                      
N#define FSMC_BCR2_MBKEN_Msk          (0x1UL << FSMC_BCR2_MBKEN_Pos)             /*!< 0x00000001 */
N#define FSMC_BCR2_MBKEN              FSMC_BCR2_MBKEN_Msk                       /*!<Memory bank enable bit                */
N#define FSMC_BCR2_MUXEN_Pos          (1U)                                      
N#define FSMC_BCR2_MUXEN_Msk          (0x1UL << FSMC_BCR2_MUXEN_Pos)             /*!< 0x00000002 */
N#define FSMC_BCR2_MUXEN              FSMC_BCR2_MUXEN_Msk                       /*!<Address/data multiplexing enable bit   */
N
N#define FSMC_BCR2_MTYP_Pos           (2U)                                      
N#define FSMC_BCR2_MTYP_Msk           (0x3UL << FSMC_BCR2_MTYP_Pos)              /*!< 0x0000000C */
N#define FSMC_BCR2_MTYP               FSMC_BCR2_MTYP_Msk                        /*!<MTYP[1:0] bits (Memory type)           */
N#define FSMC_BCR2_MTYP_0             (0x1UL << FSMC_BCR2_MTYP_Pos)              /*!< 0x00000004 */
N#define FSMC_BCR2_MTYP_1             (0x2UL << FSMC_BCR2_MTYP_Pos)              /*!< 0x00000008 */
N
N#define FSMC_BCR2_MWID_Pos           (4U)                                      
N#define FSMC_BCR2_MWID_Msk           (0x3UL << FSMC_BCR2_MWID_Pos)              /*!< 0x00000030 */
N#define FSMC_BCR2_MWID               FSMC_BCR2_MWID_Msk                        /*!<MWID[1:0] bits (Memory data bus width) */
N#define FSMC_BCR2_MWID_0             (0x1UL << FSMC_BCR2_MWID_Pos)              /*!< 0x00000010 */
N#define FSMC_BCR2_MWID_1             (0x2UL << FSMC_BCR2_MWID_Pos)              /*!< 0x00000020 */
N
N#define FSMC_BCR2_FACCEN_Pos         (6U)                                      
N#define FSMC_BCR2_FACCEN_Msk         (0x1UL << FSMC_BCR2_FACCEN_Pos)            /*!< 0x00000040 */
N#define FSMC_BCR2_FACCEN             FSMC_BCR2_FACCEN_Msk                      /*!<Flash access enable                    */
N#define FSMC_BCR2_BURSTEN_Pos        (8U)                                      
N#define FSMC_BCR2_BURSTEN_Msk        (0x1UL << FSMC_BCR2_BURSTEN_Pos)           /*!< 0x00000100 */
N#define FSMC_BCR2_BURSTEN            FSMC_BCR2_BURSTEN_Msk                     /*!<Burst enable bit                       */
N#define FSMC_BCR2_WAITPOL_Pos        (9U)                                      
N#define FSMC_BCR2_WAITPOL_Msk        (0x1UL << FSMC_BCR2_WAITPOL_Pos)           /*!< 0x00000200 */
N#define FSMC_BCR2_WAITPOL            FSMC_BCR2_WAITPOL_Msk                     /*!<Wait signal polarity bit               */
N#define FSMC_BCR2_WRAPMOD_Pos        (10U)                                     
N#define FSMC_BCR2_WRAPMOD_Msk        (0x1UL << FSMC_BCR2_WRAPMOD_Pos)           /*!< 0x00000400 */
N#define FSMC_BCR2_WRAPMOD            FSMC_BCR2_WRAPMOD_Msk                     /*!<Wrapped burst mode support             */
N#define FSMC_BCR2_WAITCFG_Pos        (11U)                                     
N#define FSMC_BCR2_WAITCFG_Msk        (0x1UL << FSMC_BCR2_WAITCFG_Pos)           /*!< 0x00000800 */
N#define FSMC_BCR2_WAITCFG            FSMC_BCR2_WAITCFG_Msk                     /*!<Wait timing configuration              */
N#define FSMC_BCR2_WREN_Pos           (12U)                                     
N#define FSMC_BCR2_WREN_Msk           (0x1UL << FSMC_BCR2_WREN_Pos)              /*!< 0x00001000 */
N#define FSMC_BCR2_WREN               FSMC_BCR2_WREN_Msk                        /*!<Write enable bit                       */
N#define FSMC_BCR2_WAITEN_Pos         (13U)                                     
N#define FSMC_BCR2_WAITEN_Msk         (0x1UL << FSMC_BCR2_WAITEN_Pos)            /*!< 0x00002000 */
N#define FSMC_BCR2_WAITEN             FSMC_BCR2_WAITEN_Msk                      /*!<Wait enable bit                        */
N#define FSMC_BCR2_EXTMOD_Pos         (14U)                                     
N#define FSMC_BCR2_EXTMOD_Msk         (0x1UL << FSMC_BCR2_EXTMOD_Pos)            /*!< 0x00004000 */
N#define FSMC_BCR2_EXTMOD             FSMC_BCR2_EXTMOD_Msk                      /*!<Extended mode enable                   */
N#define FSMC_BCR2_ASYNCWAIT_Pos      (15U)                                     
N#define FSMC_BCR2_ASYNCWAIT_Msk      (0x1UL << FSMC_BCR2_ASYNCWAIT_Pos)         /*!< 0x00008000 */
N#define FSMC_BCR2_ASYNCWAIT          FSMC_BCR2_ASYNCWAIT_Msk                   /*!<Asynchronous wait                      */
N#define FSMC_BCR2_CPSIZE_Pos         (16U)                                     
N#define FSMC_BCR2_CPSIZE_Msk         (0x7UL << FSMC_BCR2_CPSIZE_Pos)            /*!< 0x00070000 */
N#define FSMC_BCR2_CPSIZE             FSMC_BCR2_CPSIZE_Msk                      /*!<CRAM page size */
N#define FSMC_BCR2_CPSIZE_0           (0x1UL << FSMC_BCR2_CPSIZE_Pos)            /*!< 0x00010000 */
N#define FSMC_BCR2_CPSIZE_1           (0x2UL << FSMC_BCR2_CPSIZE_Pos)            /*!< 0x00020000 */
N#define FSMC_BCR2_CPSIZE_2           (0x4UL << FSMC_BCR2_CPSIZE_Pos)            /*!< 0x00040000 */
N#define FSMC_BCR2_CBURSTRW_Pos       (19U)                                     
N#define FSMC_BCR2_CBURSTRW_Msk       (0x1UL << FSMC_BCR2_CBURSTRW_Pos)          /*!< 0x00080000 */
N#define FSMC_BCR2_CBURSTRW           FSMC_BCR2_CBURSTRW_Msk                    /*!<Write burst enable                     */
N
N/******************  Bit definition for FSMC_BCR3 register  *******************/
N#define FSMC_BCR3_MBKEN_Pos          (0U)                                      
N#define FSMC_BCR3_MBKEN_Msk          (0x1UL << FSMC_BCR3_MBKEN_Pos)             /*!< 0x00000001 */
N#define FSMC_BCR3_MBKEN              FSMC_BCR3_MBKEN_Msk                       /*!<Memory bank enable bit                 */
N#define FSMC_BCR3_MUXEN_Pos          (1U)                                      
N#define FSMC_BCR3_MUXEN_Msk          (0x1UL << FSMC_BCR3_MUXEN_Pos)             /*!< 0x00000002 */
N#define FSMC_BCR3_MUXEN              FSMC_BCR3_MUXEN_Msk                       /*!<Address/data multiplexing enable bit   */
N
N#define FSMC_BCR3_MTYP_Pos           (2U)                                      
N#define FSMC_BCR3_MTYP_Msk           (0x3UL << FSMC_BCR3_MTYP_Pos)              /*!< 0x0000000C */
N#define FSMC_BCR3_MTYP               FSMC_BCR3_MTYP_Msk                        /*!<MTYP[1:0] bits (Memory type)           */
N#define FSMC_BCR3_MTYP_0             (0x1UL << FSMC_BCR3_MTYP_Pos)              /*!< 0x00000004 */
N#define FSMC_BCR3_MTYP_1             (0x2UL << FSMC_BCR3_MTYP_Pos)              /*!< 0x00000008 */
N
N#define FSMC_BCR3_MWID_Pos           (4U)                                      
N#define FSMC_BCR3_MWID_Msk           (0x3UL << FSMC_BCR3_MWID_Pos)              /*!< 0x00000030 */
N#define FSMC_BCR3_MWID               FSMC_BCR3_MWID_Msk                        /*!<MWID[1:0] bits (Memory data bus width) */
N#define FSMC_BCR3_MWID_0             (0x1UL << FSMC_BCR3_MWID_Pos)              /*!< 0x00000010 */
N#define FSMC_BCR3_MWID_1             (0x2UL << FSMC_BCR3_MWID_Pos)              /*!< 0x00000020 */
N
N#define FSMC_BCR3_FACCEN_Pos         (6U)                                      
N#define FSMC_BCR3_FACCEN_Msk         (0x1UL << FSMC_BCR3_FACCEN_Pos)            /*!< 0x00000040 */
N#define FSMC_BCR3_FACCEN             FSMC_BCR3_FACCEN_Msk                      /*!<Flash access enable                    */
N#define FSMC_BCR3_BURSTEN_Pos        (8U)                                      
N#define FSMC_BCR3_BURSTEN_Msk        (0x1UL << FSMC_BCR3_BURSTEN_Pos)           /*!< 0x00000100 */
N#define FSMC_BCR3_BURSTEN            FSMC_BCR3_BURSTEN_Msk                     /*!<Burst enable bit                       */
N#define FSMC_BCR3_WAITPOL_Pos        (9U)                                      
N#define FSMC_BCR3_WAITPOL_Msk        (0x1UL << FSMC_BCR3_WAITPOL_Pos)           /*!< 0x00000200 */
N#define FSMC_BCR3_WAITPOL            FSMC_BCR3_WAITPOL_Msk                     /*!<Wait signal polarity bit               */
N#define FSMC_BCR3_WRAPMOD_Pos        (10U)                                     
N#define FSMC_BCR3_WRAPMOD_Msk        (0x1UL << FSMC_BCR3_WRAPMOD_Pos)           /*!< 0x00000400 */
N#define FSMC_BCR3_WRAPMOD            FSMC_BCR3_WRAPMOD_Msk                     /*!<Wrapped burst mode support             */
N#define FSMC_BCR3_WAITCFG_Pos        (11U)                                     
N#define FSMC_BCR3_WAITCFG_Msk        (0x1UL << FSMC_BCR3_WAITCFG_Pos)           /*!< 0x00000800 */
N#define FSMC_BCR3_WAITCFG            FSMC_BCR3_WAITCFG_Msk                     /*!<Wait timing configuration              */
N#define FSMC_BCR3_WREN_Pos           (12U)                                     
N#define FSMC_BCR3_WREN_Msk           (0x1UL << FSMC_BCR3_WREN_Pos)              /*!< 0x00001000 */
N#define FSMC_BCR3_WREN               FSMC_BCR3_WREN_Msk                        /*!<Write enable bit                       */
N#define FSMC_BCR3_WAITEN_Pos         (13U)                                     
N#define FSMC_BCR3_WAITEN_Msk         (0x1UL << FSMC_BCR3_WAITEN_Pos)            /*!< 0x00002000 */
N#define FSMC_BCR3_WAITEN             FSMC_BCR3_WAITEN_Msk                      /*!<Wait enable bit                        */
N#define FSMC_BCR3_EXTMOD_Pos         (14U)                                     
N#define FSMC_BCR3_EXTMOD_Msk         (0x1UL << FSMC_BCR3_EXTMOD_Pos)            /*!< 0x00004000 */
N#define FSMC_BCR3_EXTMOD             FSMC_BCR3_EXTMOD_Msk                      /*!<Extended mode enable                   */
N#define FSMC_BCR3_ASYNCWAIT_Pos      (15U)                                     
N#define FSMC_BCR3_ASYNCWAIT_Msk      (0x1UL << FSMC_BCR3_ASYNCWAIT_Pos)         /*!< 0x00008000 */
N#define FSMC_BCR3_ASYNCWAIT          FSMC_BCR3_ASYNCWAIT_Msk                   /*!<Asynchronous wait                      */
N#define FSMC_BCR3_CPSIZE_Pos         (16U)                                     
N#define FSMC_BCR3_CPSIZE_Msk         (0x7UL << FSMC_BCR3_CPSIZE_Pos)            /*!< 0x00070000 */
N#define FSMC_BCR3_CPSIZE             FSMC_BCR3_CPSIZE_Msk                      /*!<CRAM page size */
N#define FSMC_BCR3_CPSIZE_0           (0x1UL << FSMC_BCR3_CPSIZE_Pos)            /*!< 0x00010000 */
N#define FSMC_BCR3_CPSIZE_1           (0x2UL << FSMC_BCR3_CPSIZE_Pos)            /*!< 0x00020000 */
N#define FSMC_BCR3_CPSIZE_2           (0x4UL << FSMC_BCR3_CPSIZE_Pos)            /*!< 0x00040000 */
N#define FSMC_BCR3_CBURSTRW_Pos       (19U)                                     
N#define FSMC_BCR3_CBURSTRW_Msk       (0x1UL << FSMC_BCR3_CBURSTRW_Pos)          /*!< 0x00080000 */
N#define FSMC_BCR3_CBURSTRW           FSMC_BCR3_CBURSTRW_Msk                    /*!<Write burst enable                     */
N
N/******************  Bit definition for FSMC_BCR4 register  *******************/
N#define FSMC_BCR4_MBKEN_Pos          (0U)                                      
N#define FSMC_BCR4_MBKEN_Msk          (0x1UL << FSMC_BCR4_MBKEN_Pos)             /*!< 0x00000001 */
N#define FSMC_BCR4_MBKEN              FSMC_BCR4_MBKEN_Msk                       /*!<Memory bank enable bit */
N#define FSMC_BCR4_MUXEN_Pos          (1U)                                      
N#define FSMC_BCR4_MUXEN_Msk          (0x1UL << FSMC_BCR4_MUXEN_Pos)             /*!< 0x00000002 */
N#define FSMC_BCR4_MUXEN              FSMC_BCR4_MUXEN_Msk                       /*!<Address/data multiplexing enable bit   */
N
N#define FSMC_BCR4_MTYP_Pos           (2U)                                      
N#define FSMC_BCR4_MTYP_Msk           (0x3UL << FSMC_BCR4_MTYP_Pos)              /*!< 0x0000000C */
N#define FSMC_BCR4_MTYP               FSMC_BCR4_MTYP_Msk                        /*!<MTYP[1:0] bits (Memory type)           */
N#define FSMC_BCR4_MTYP_0             (0x1UL << FSMC_BCR4_MTYP_Pos)              /*!< 0x00000004 */
N#define FSMC_BCR4_MTYP_1             (0x2UL << FSMC_BCR4_MTYP_Pos)              /*!< 0x00000008 */
N
N#define FSMC_BCR4_MWID_Pos           (4U)                                      
N#define FSMC_BCR4_MWID_Msk           (0x3UL << FSMC_BCR4_MWID_Pos)              /*!< 0x00000030 */
N#define FSMC_BCR4_MWID               FSMC_BCR4_MWID_Msk                        /*!<MWID[1:0] bits (Memory data bus width) */
N#define FSMC_BCR4_MWID_0             (0x1UL << FSMC_BCR4_MWID_Pos)              /*!< 0x00000010 */
N#define FSMC_BCR4_MWID_1             (0x2UL << FSMC_BCR4_MWID_Pos)              /*!< 0x00000020 */
N
N#define FSMC_BCR4_FACCEN_Pos         (6U)                                      
N#define FSMC_BCR4_FACCEN_Msk         (0x1UL << FSMC_BCR4_FACCEN_Pos)            /*!< 0x00000040 */
N#define FSMC_BCR4_FACCEN             FSMC_BCR4_FACCEN_Msk                      /*!<Flash access enable                    */
N#define FSMC_BCR4_BURSTEN_Pos        (8U)                                      
N#define FSMC_BCR4_BURSTEN_Msk        (0x1UL << FSMC_BCR4_BURSTEN_Pos)           /*!< 0x00000100 */
N#define FSMC_BCR4_BURSTEN            FSMC_BCR4_BURSTEN_Msk                     /*!<Burst enable bit                       */
N#define FSMC_BCR4_WAITPOL_Pos        (9U)                                      
N#define FSMC_BCR4_WAITPOL_Msk        (0x1UL << FSMC_BCR4_WAITPOL_Pos)           /*!< 0x00000200 */
N#define FSMC_BCR4_WAITPOL            FSMC_BCR4_WAITPOL_Msk                     /*!<Wait signal polarity bit               */
N#define FSMC_BCR4_WRAPMOD_Pos        (10U)                                     
N#define FSMC_BCR4_WRAPMOD_Msk        (0x1UL << FSMC_BCR4_WRAPMOD_Pos)           /*!< 0x00000400 */
N#define FSMC_BCR4_WRAPMOD            FSMC_BCR4_WRAPMOD_Msk                     /*!<Wrapped burst mode support             */
N#define FSMC_BCR4_WAITCFG_Pos        (11U)                                     
N#define FSMC_BCR4_WAITCFG_Msk        (0x1UL << FSMC_BCR4_WAITCFG_Pos)           /*!< 0x00000800 */
N#define FSMC_BCR4_WAITCFG            FSMC_BCR4_WAITCFG_Msk                     /*!<Wait timing configuration              */
N#define FSMC_BCR4_WREN_Pos           (12U)                                     
N#define FSMC_BCR4_WREN_Msk           (0x1UL << FSMC_BCR4_WREN_Pos)              /*!< 0x00001000 */
N#define FSMC_BCR4_WREN               FSMC_BCR4_WREN_Msk                        /*!<Write enable bit                       */
N#define FSMC_BCR4_WAITEN_Pos         (13U)                                     
N#define FSMC_BCR4_WAITEN_Msk         (0x1UL << FSMC_BCR4_WAITEN_Pos)            /*!< 0x00002000 */
N#define FSMC_BCR4_WAITEN             FSMC_BCR4_WAITEN_Msk                      /*!<Wait enable bit                        */
N#define FSMC_BCR4_EXTMOD_Pos         (14U)                                     
N#define FSMC_BCR4_EXTMOD_Msk         (0x1UL << FSMC_BCR4_EXTMOD_Pos)            /*!< 0x00004000 */
N#define FSMC_BCR4_EXTMOD             FSMC_BCR4_EXTMOD_Msk                      /*!<Extended mode enable                   */
N#define FSMC_BCR4_ASYNCWAIT_Pos      (15U)                                     
N#define FSMC_BCR4_ASYNCWAIT_Msk      (0x1UL << FSMC_BCR4_ASYNCWAIT_Pos)         /*!< 0x00008000 */
N#define FSMC_BCR4_ASYNCWAIT          FSMC_BCR4_ASYNCWAIT_Msk                   /*!<Asynchronous wait                      */
N#define FSMC_BCR4_CPSIZE_Pos         (16U)                                     
N#define FSMC_BCR4_CPSIZE_Msk         (0x7UL << FSMC_BCR4_CPSIZE_Pos)            /*!< 0x00070000 */
N#define FSMC_BCR4_CPSIZE             FSMC_BCR4_CPSIZE_Msk                      /*!<CRAM page size */
N#define FSMC_BCR4_CPSIZE_0           (0x1UL << FSMC_BCR4_CPSIZE_Pos)            /*!< 0x00010000 */
N#define FSMC_BCR4_CPSIZE_1           (0x2UL << FSMC_BCR4_CPSIZE_Pos)            /*!< 0x00020000 */
N#define FSMC_BCR4_CPSIZE_2           (0x4UL << FSMC_BCR4_CPSIZE_Pos)            /*!< 0x00040000 */
N#define FSMC_BCR4_CBURSTRW_Pos       (19U)                                     
N#define FSMC_BCR4_CBURSTRW_Msk       (0x1UL << FSMC_BCR4_CBURSTRW_Pos)          /*!< 0x00080000 */
N#define FSMC_BCR4_CBURSTRW           FSMC_BCR4_CBURSTRW_Msk                    /*!<Write burst enable                     */
N
N/******************  Bit definition for FSMC_BTR1 register  ******************/
N#define FSMC_BTR1_ADDSET_Pos         (0U)                                      
N#define FSMC_BTR1_ADDSET_Msk         (0xFUL << FSMC_BTR1_ADDSET_Pos)            /*!< 0x0000000F */
N#define FSMC_BTR1_ADDSET             FSMC_BTR1_ADDSET_Msk                      /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define FSMC_BTR1_ADDSET_0           (0x1UL << FSMC_BTR1_ADDSET_Pos)            /*!< 0x00000001 */
N#define FSMC_BTR1_ADDSET_1           (0x2UL << FSMC_BTR1_ADDSET_Pos)            /*!< 0x00000002 */
N#define FSMC_BTR1_ADDSET_2           (0x4UL << FSMC_BTR1_ADDSET_Pos)            /*!< 0x00000004 */
N#define FSMC_BTR1_ADDSET_3           (0x8UL << FSMC_BTR1_ADDSET_Pos)            /*!< 0x00000008 */
N
N#define FSMC_BTR1_ADDHLD_Pos         (4U)                                      
N#define FSMC_BTR1_ADDHLD_Msk         (0xFUL << FSMC_BTR1_ADDHLD_Pos)            /*!< 0x000000F0 */
N#define FSMC_BTR1_ADDHLD             FSMC_BTR1_ADDHLD_Msk                      /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define FSMC_BTR1_ADDHLD_0           (0x1UL << FSMC_BTR1_ADDHLD_Pos)            /*!< 0x00000010 */
N#define FSMC_BTR1_ADDHLD_1           (0x2UL << FSMC_BTR1_ADDHLD_Pos)            /*!< 0x00000020 */
N#define FSMC_BTR1_ADDHLD_2           (0x4UL << FSMC_BTR1_ADDHLD_Pos)            /*!< 0x00000040 */
N#define FSMC_BTR1_ADDHLD_3           (0x8UL << FSMC_BTR1_ADDHLD_Pos)            /*!< 0x00000080 */
N
N#define FSMC_BTR1_DATAST_Pos         (8U)                                      
N#define FSMC_BTR1_DATAST_Msk         (0xFFUL << FSMC_BTR1_DATAST_Pos)           /*!< 0x0000FF00 */
N#define FSMC_BTR1_DATAST             FSMC_BTR1_DATAST_Msk                      /*!<DATAST [7:0] bits (Data-phase duration) */
N#define FSMC_BTR1_DATAST_0           (0x01UL << FSMC_BTR1_DATAST_Pos)           /*!< 0x00000100 */
N#define FSMC_BTR1_DATAST_1           (0x02UL << FSMC_BTR1_DATAST_Pos)           /*!< 0x00000200 */
N#define FSMC_BTR1_DATAST_2           (0x04UL << FSMC_BTR1_DATAST_Pos)           /*!< 0x00000400 */
N#define FSMC_BTR1_DATAST_3           (0x08UL << FSMC_BTR1_DATAST_Pos)           /*!< 0x00000800 */
N#define FSMC_BTR1_DATAST_4           (0x10UL << FSMC_BTR1_DATAST_Pos)           /*!< 0x00001000 */
N#define FSMC_BTR1_DATAST_5           (0x20UL << FSMC_BTR1_DATAST_Pos)           /*!< 0x00002000 */
N#define FSMC_BTR1_DATAST_6           (0x40UL << FSMC_BTR1_DATAST_Pos)           /*!< 0x00004000 */
N#define FSMC_BTR1_DATAST_7           (0x80UL << FSMC_BTR1_DATAST_Pos)           /*!< 0x00008000 */
N
N#define FSMC_BTR1_BUSTURN_Pos        (16U)                                     
N#define FSMC_BTR1_BUSTURN_Msk        (0xFUL << FSMC_BTR1_BUSTURN_Pos)           /*!< 0x000F0000 */
N#define FSMC_BTR1_BUSTURN            FSMC_BTR1_BUSTURN_Msk                     /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define FSMC_BTR1_BUSTURN_0          (0x1UL << FSMC_BTR1_BUSTURN_Pos)           /*!< 0x00010000 */
N#define FSMC_BTR1_BUSTURN_1          (0x2UL << FSMC_BTR1_BUSTURN_Pos)           /*!< 0x00020000 */
N#define FSMC_BTR1_BUSTURN_2          (0x4UL << FSMC_BTR1_BUSTURN_Pos)           /*!< 0x00040000 */
N#define FSMC_BTR1_BUSTURN_3          (0x8UL << FSMC_BTR1_BUSTURN_Pos)           /*!< 0x00080000 */
N
N#define FSMC_BTR1_CLKDIV_Pos         (20U)                                     
N#define FSMC_BTR1_CLKDIV_Msk         (0xFUL << FSMC_BTR1_CLKDIV_Pos)            /*!< 0x00F00000 */
N#define FSMC_BTR1_CLKDIV             FSMC_BTR1_CLKDIV_Msk                      /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define FSMC_BTR1_CLKDIV_0           (0x1UL << FSMC_BTR1_CLKDIV_Pos)            /*!< 0x00100000 */
N#define FSMC_BTR1_CLKDIV_1           (0x2UL << FSMC_BTR1_CLKDIV_Pos)            /*!< 0x00200000 */
N#define FSMC_BTR1_CLKDIV_2           (0x4UL << FSMC_BTR1_CLKDIV_Pos)            /*!< 0x00400000 */
N#define FSMC_BTR1_CLKDIV_3           (0x8UL << FSMC_BTR1_CLKDIV_Pos)            /*!< 0x00800000 */
N
N#define FSMC_BTR1_DATLAT_Pos         (24U)                                     
N#define FSMC_BTR1_DATLAT_Msk         (0xFUL << FSMC_BTR1_DATLAT_Pos)            /*!< 0x0F000000 */
N#define FSMC_BTR1_DATLAT             FSMC_BTR1_DATLAT_Msk                      /*!<DATLA[3:0] bits (Data latency) */
N#define FSMC_BTR1_DATLAT_0           (0x1UL << FSMC_BTR1_DATLAT_Pos)            /*!< 0x01000000 */
N#define FSMC_BTR1_DATLAT_1           (0x2UL << FSMC_BTR1_DATLAT_Pos)            /*!< 0x02000000 */
N#define FSMC_BTR1_DATLAT_2           (0x4UL << FSMC_BTR1_DATLAT_Pos)            /*!< 0x04000000 */
N#define FSMC_BTR1_DATLAT_3           (0x8UL << FSMC_BTR1_DATLAT_Pos)            /*!< 0x08000000 */
N
N#define FSMC_BTR1_ACCMOD_Pos         (28U)                                     
N#define FSMC_BTR1_ACCMOD_Msk         (0x3UL << FSMC_BTR1_ACCMOD_Pos)            /*!< 0x30000000 */
N#define FSMC_BTR1_ACCMOD             FSMC_BTR1_ACCMOD_Msk                      /*!<ACCMOD[1:0] bits (Access mode) */
N#define FSMC_BTR1_ACCMOD_0           (0x1UL << FSMC_BTR1_ACCMOD_Pos)            /*!< 0x10000000 */
N#define FSMC_BTR1_ACCMOD_1           (0x2UL << FSMC_BTR1_ACCMOD_Pos)            /*!< 0x20000000 */
N
N/******************  Bit definition for FSMC_BTR2 register  *******************/
N#define FSMC_BTR2_ADDSET_Pos         (0U)                                      
N#define FSMC_BTR2_ADDSET_Msk         (0xFUL << FSMC_BTR2_ADDSET_Pos)            /*!< 0x0000000F */
N#define FSMC_BTR2_ADDSET             FSMC_BTR2_ADDSET_Msk                      /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define FSMC_BTR2_ADDSET_0           (0x1UL << FSMC_BTR2_ADDSET_Pos)            /*!< 0x00000001 */
N#define FSMC_BTR2_ADDSET_1           (0x2UL << FSMC_BTR2_ADDSET_Pos)            /*!< 0x00000002 */
N#define FSMC_BTR2_ADDSET_2           (0x4UL << FSMC_BTR2_ADDSET_Pos)            /*!< 0x00000004 */
N#define FSMC_BTR2_ADDSET_3           (0x8UL << FSMC_BTR2_ADDSET_Pos)            /*!< 0x00000008 */
N
N#define FSMC_BTR2_ADDHLD_Pos         (4U)                                      
N#define FSMC_BTR2_ADDHLD_Msk         (0xFUL << FSMC_BTR2_ADDHLD_Pos)            /*!< 0x000000F0 */
N#define FSMC_BTR2_ADDHLD             FSMC_BTR2_ADDHLD_Msk                      /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define FSMC_BTR2_ADDHLD_0           (0x1UL << FSMC_BTR2_ADDHLD_Pos)            /*!< 0x00000010 */
N#define FSMC_BTR2_ADDHLD_1           (0x2UL << FSMC_BTR2_ADDHLD_Pos)            /*!< 0x00000020 */
N#define FSMC_BTR2_ADDHLD_2           (0x4UL << FSMC_BTR2_ADDHLD_Pos)            /*!< 0x00000040 */
N#define FSMC_BTR2_ADDHLD_3           (0x8UL << FSMC_BTR2_ADDHLD_Pos)            /*!< 0x00000080 */
N
N#define FSMC_BTR2_DATAST_Pos         (8U)                                      
N#define FSMC_BTR2_DATAST_Msk         (0xFFUL << FSMC_BTR2_DATAST_Pos)           /*!< 0x0000FF00 */
N#define FSMC_BTR2_DATAST             FSMC_BTR2_DATAST_Msk                      /*!<DATAST [7:0] bits (Data-phase duration) */
N#define FSMC_BTR2_DATAST_0           (0x01UL << FSMC_BTR2_DATAST_Pos)           /*!< 0x00000100 */
N#define FSMC_BTR2_DATAST_1           (0x02UL << FSMC_BTR2_DATAST_Pos)           /*!< 0x00000200 */
N#define FSMC_BTR2_DATAST_2           (0x04UL << FSMC_BTR2_DATAST_Pos)           /*!< 0x00000400 */
N#define FSMC_BTR2_DATAST_3           (0x08UL << FSMC_BTR2_DATAST_Pos)           /*!< 0x00000800 */
N#define FSMC_BTR2_DATAST_4           (0x10UL << FSMC_BTR2_DATAST_Pos)           /*!< 0x00001000 */
N#define FSMC_BTR2_DATAST_5           (0x20UL << FSMC_BTR2_DATAST_Pos)           /*!< 0x00002000 */
N#define FSMC_BTR2_DATAST_6           (0x40UL << FSMC_BTR2_DATAST_Pos)           /*!< 0x00004000 */
N#define FSMC_BTR2_DATAST_7           (0x80UL << FSMC_BTR2_DATAST_Pos)           /*!< 0x00008000 */
N
N#define FSMC_BTR2_BUSTURN_Pos        (16U)                                     
N#define FSMC_BTR2_BUSTURN_Msk        (0xFUL << FSMC_BTR2_BUSTURN_Pos)           /*!< 0x000F0000 */
N#define FSMC_BTR2_BUSTURN            FSMC_BTR2_BUSTURN_Msk                     /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define FSMC_BTR2_BUSTURN_0          (0x1UL << FSMC_BTR2_BUSTURN_Pos)           /*!< 0x00010000 */
N#define FSMC_BTR2_BUSTURN_1          (0x2UL << FSMC_BTR2_BUSTURN_Pos)           /*!< 0x00020000 */
N#define FSMC_BTR2_BUSTURN_2          (0x4UL << FSMC_BTR2_BUSTURN_Pos)           /*!< 0x00040000 */
N#define FSMC_BTR2_BUSTURN_3          (0x8UL << FSMC_BTR2_BUSTURN_Pos)           /*!< 0x00080000 */
N
N#define FSMC_BTR2_CLKDIV_Pos         (20U)                                     
N#define FSMC_BTR2_CLKDIV_Msk         (0xFUL << FSMC_BTR2_CLKDIV_Pos)            /*!< 0x00F00000 */
N#define FSMC_BTR2_CLKDIV             FSMC_BTR2_CLKDIV_Msk                      /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define FSMC_BTR2_CLKDIV_0           (0x1UL << FSMC_BTR2_CLKDIV_Pos)            /*!< 0x00100000 */
N#define FSMC_BTR2_CLKDIV_1           (0x2UL << FSMC_BTR2_CLKDIV_Pos)            /*!< 0x00200000 */
N#define FSMC_BTR2_CLKDIV_2           (0x4UL << FSMC_BTR2_CLKDIV_Pos)            /*!< 0x00400000 */
N#define FSMC_BTR2_CLKDIV_3           (0x8UL << FSMC_BTR2_CLKDIV_Pos)            /*!< 0x00800000 */
N
N#define FSMC_BTR2_DATLAT_Pos         (24U)                                     
N#define FSMC_BTR2_DATLAT_Msk         (0xFUL << FSMC_BTR2_DATLAT_Pos)            /*!< 0x0F000000 */
N#define FSMC_BTR2_DATLAT             FSMC_BTR2_DATLAT_Msk                      /*!<DATLA[3:0] bits (Data latency) */
N#define FSMC_BTR2_DATLAT_0           (0x1UL << FSMC_BTR2_DATLAT_Pos)            /*!< 0x01000000 */
N#define FSMC_BTR2_DATLAT_1           (0x2UL << FSMC_BTR2_DATLAT_Pos)            /*!< 0x02000000 */
N#define FSMC_BTR2_DATLAT_2           (0x4UL << FSMC_BTR2_DATLAT_Pos)            /*!< 0x04000000 */
N#define FSMC_BTR2_DATLAT_3           (0x8UL << FSMC_BTR2_DATLAT_Pos)            /*!< 0x08000000 */
N
N#define FSMC_BTR2_ACCMOD_Pos         (28U)                                     
N#define FSMC_BTR2_ACCMOD_Msk         (0x3UL << FSMC_BTR2_ACCMOD_Pos)            /*!< 0x30000000 */
N#define FSMC_BTR2_ACCMOD             FSMC_BTR2_ACCMOD_Msk                      /*!<ACCMOD[1:0] bits (Access mode) */
N#define FSMC_BTR2_ACCMOD_0           (0x1UL << FSMC_BTR2_ACCMOD_Pos)            /*!< 0x10000000 */
N#define FSMC_BTR2_ACCMOD_1           (0x2UL << FSMC_BTR2_ACCMOD_Pos)            /*!< 0x20000000 */
N
N/*******************  Bit definition for FSMC_BTR3 register  *******************/
N#define FSMC_BTR3_ADDSET_Pos         (0U)                                      
N#define FSMC_BTR3_ADDSET_Msk         (0xFUL << FSMC_BTR3_ADDSET_Pos)            /*!< 0x0000000F */
N#define FSMC_BTR3_ADDSET             FSMC_BTR3_ADDSET_Msk                      /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define FSMC_BTR3_ADDSET_0           (0x1UL << FSMC_BTR3_ADDSET_Pos)            /*!< 0x00000001 */
N#define FSMC_BTR3_ADDSET_1           (0x2UL << FSMC_BTR3_ADDSET_Pos)            /*!< 0x00000002 */
N#define FSMC_BTR3_ADDSET_2           (0x4UL << FSMC_BTR3_ADDSET_Pos)            /*!< 0x00000004 */
N#define FSMC_BTR3_ADDSET_3           (0x8UL << FSMC_BTR3_ADDSET_Pos)            /*!< 0x00000008 */
N
N#define FSMC_BTR3_ADDHLD_Pos         (4U)                                      
N#define FSMC_BTR3_ADDHLD_Msk         (0xFUL << FSMC_BTR3_ADDHLD_Pos)            /*!< 0x000000F0 */
N#define FSMC_BTR3_ADDHLD             FSMC_BTR3_ADDHLD_Msk                      /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define FSMC_BTR3_ADDHLD_0           (0x1UL << FSMC_BTR3_ADDHLD_Pos)            /*!< 0x00000010 */
N#define FSMC_BTR3_ADDHLD_1           (0x2UL << FSMC_BTR3_ADDHLD_Pos)            /*!< 0x00000020 */
N#define FSMC_BTR3_ADDHLD_2           (0x4UL << FSMC_BTR3_ADDHLD_Pos)            /*!< 0x00000040 */
N#define FSMC_BTR3_ADDHLD_3           (0x8UL << FSMC_BTR3_ADDHLD_Pos)            /*!< 0x00000080 */
N
N#define FSMC_BTR3_DATAST_Pos         (8U)                                      
N#define FSMC_BTR3_DATAST_Msk         (0xFFUL << FSMC_BTR3_DATAST_Pos)           /*!< 0x0000FF00 */
N#define FSMC_BTR3_DATAST             FSMC_BTR3_DATAST_Msk                      /*!<DATAST [7:0] bits (Data-phase duration) */
N#define FSMC_BTR3_DATAST_0           (0x01UL << FSMC_BTR3_DATAST_Pos)           /*!< 0x00000100 */
N#define FSMC_BTR3_DATAST_1           (0x02UL << FSMC_BTR3_DATAST_Pos)           /*!< 0x00000200 */
N#define FSMC_BTR3_DATAST_2           (0x04UL << FSMC_BTR3_DATAST_Pos)           /*!< 0x00000400 */
N#define FSMC_BTR3_DATAST_3           (0x08UL << FSMC_BTR3_DATAST_Pos)           /*!< 0x00000800 */
N#define FSMC_BTR3_DATAST_4           (0x10UL << FSMC_BTR3_DATAST_Pos)           /*!< 0x00001000 */
N#define FSMC_BTR3_DATAST_5           (0x20UL << FSMC_BTR3_DATAST_Pos)           /*!< 0x00002000 */
N#define FSMC_BTR3_DATAST_6           (0x40UL << FSMC_BTR3_DATAST_Pos)           /*!< 0x00004000 */
N#define FSMC_BTR3_DATAST_7           (0x80UL << FSMC_BTR3_DATAST_Pos)           /*!< 0x00008000 */
N
N#define FSMC_BTR3_BUSTURN_Pos        (16U)                                     
N#define FSMC_BTR3_BUSTURN_Msk        (0xFUL << FSMC_BTR3_BUSTURN_Pos)           /*!< 0x000F0000 */
N#define FSMC_BTR3_BUSTURN            FSMC_BTR3_BUSTURN_Msk                     /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define FSMC_BTR3_BUSTURN_0          (0x1UL << FSMC_BTR3_BUSTURN_Pos)           /*!< 0x00010000 */
N#define FSMC_BTR3_BUSTURN_1          (0x2UL << FSMC_BTR3_BUSTURN_Pos)           /*!< 0x00020000 */
N#define FSMC_BTR3_BUSTURN_2          (0x4UL << FSMC_BTR3_BUSTURN_Pos)           /*!< 0x00040000 */
N#define FSMC_BTR3_BUSTURN_3          (0x8UL << FSMC_BTR3_BUSTURN_Pos)           /*!< 0x00080000 */
N
N#define FSMC_BTR3_CLKDIV_Pos         (20U)                                     
N#define FSMC_BTR3_CLKDIV_Msk         (0xFUL << FSMC_BTR3_CLKDIV_Pos)            /*!< 0x00F00000 */
N#define FSMC_BTR3_CLKDIV             FSMC_BTR3_CLKDIV_Msk                      /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define FSMC_BTR3_CLKDIV_0           (0x1UL << FSMC_BTR3_CLKDIV_Pos)            /*!< 0x00100000 */
N#define FSMC_BTR3_CLKDIV_1           (0x2UL << FSMC_BTR3_CLKDIV_Pos)            /*!< 0x00200000 */
N#define FSMC_BTR3_CLKDIV_2           (0x4UL << FSMC_BTR3_CLKDIV_Pos)            /*!< 0x00400000 */
N#define FSMC_BTR3_CLKDIV_3           (0x8UL << FSMC_BTR3_CLKDIV_Pos)            /*!< 0x00800000 */
N
N#define FSMC_BTR3_DATLAT_Pos         (24U)                                     
N#define FSMC_BTR3_DATLAT_Msk         (0xFUL << FSMC_BTR3_DATLAT_Pos)            /*!< 0x0F000000 */
N#define FSMC_BTR3_DATLAT             FSMC_BTR3_DATLAT_Msk                      /*!<DATLA[3:0] bits (Data latency) */
N#define FSMC_BTR3_DATLAT_0           (0x1UL << FSMC_BTR3_DATLAT_Pos)            /*!< 0x01000000 */
N#define FSMC_BTR3_DATLAT_1           (0x2UL << FSMC_BTR3_DATLAT_Pos)            /*!< 0x02000000 */
N#define FSMC_BTR3_DATLAT_2           (0x4UL << FSMC_BTR3_DATLAT_Pos)            /*!< 0x04000000 */
N#define FSMC_BTR3_DATLAT_3           (0x8UL << FSMC_BTR3_DATLAT_Pos)            /*!< 0x08000000 */
N
N#define FSMC_BTR3_ACCMOD_Pos         (28U)                                     
N#define FSMC_BTR3_ACCMOD_Msk         (0x3UL << FSMC_BTR3_ACCMOD_Pos)            /*!< 0x30000000 */
N#define FSMC_BTR3_ACCMOD             FSMC_BTR3_ACCMOD_Msk                      /*!<ACCMOD[1:0] bits (Access mode) */
N#define FSMC_BTR3_ACCMOD_0           (0x1UL << FSMC_BTR3_ACCMOD_Pos)            /*!< 0x10000000 */
N#define FSMC_BTR3_ACCMOD_1           (0x2UL << FSMC_BTR3_ACCMOD_Pos)            /*!< 0x20000000 */
N
N/******************  Bit definition for FSMC_BTR4 register  *******************/
N#define FSMC_BTR4_ADDSET_Pos         (0U)                                      
N#define FSMC_BTR4_ADDSET_Msk         (0xFUL << FSMC_BTR4_ADDSET_Pos)            /*!< 0x0000000F */
N#define FSMC_BTR4_ADDSET             FSMC_BTR4_ADDSET_Msk                      /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define FSMC_BTR4_ADDSET_0           (0x1UL << FSMC_BTR4_ADDSET_Pos)            /*!< 0x00000001 */
N#define FSMC_BTR4_ADDSET_1           (0x2UL << FSMC_BTR4_ADDSET_Pos)            /*!< 0x00000002 */
N#define FSMC_BTR4_ADDSET_2           (0x4UL << FSMC_BTR4_ADDSET_Pos)            /*!< 0x00000004 */
N#define FSMC_BTR4_ADDSET_3           (0x8UL << FSMC_BTR4_ADDSET_Pos)            /*!< 0x00000008 */
N
N#define FSMC_BTR4_ADDHLD_Pos         (4U)                                      
N#define FSMC_BTR4_ADDHLD_Msk         (0xFUL << FSMC_BTR4_ADDHLD_Pos)            /*!< 0x000000F0 */
N#define FSMC_BTR4_ADDHLD             FSMC_BTR4_ADDHLD_Msk                      /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define FSMC_BTR4_ADDHLD_0           (0x1UL << FSMC_BTR4_ADDHLD_Pos)            /*!< 0x00000010 */
N#define FSMC_BTR4_ADDHLD_1           (0x2UL << FSMC_BTR4_ADDHLD_Pos)            /*!< 0x00000020 */
N#define FSMC_BTR4_ADDHLD_2           (0x4UL << FSMC_BTR4_ADDHLD_Pos)            /*!< 0x00000040 */
N#define FSMC_BTR4_ADDHLD_3           (0x8UL << FSMC_BTR4_ADDHLD_Pos)            /*!< 0x00000080 */
N
N#define FSMC_BTR4_DATAST_Pos         (8U)                                      
N#define FSMC_BTR4_DATAST_Msk         (0xFFUL << FSMC_BTR4_DATAST_Pos)           /*!< 0x0000FF00 */
N#define FSMC_BTR4_DATAST             FSMC_BTR4_DATAST_Msk                      /*!<DATAST [7:0] bits (Data-phase duration) */
N#define FSMC_BTR4_DATAST_0           (0x01UL << FSMC_BTR4_DATAST_Pos)           /*!< 0x00000100 */
N#define FSMC_BTR4_DATAST_1           (0x02UL << FSMC_BTR4_DATAST_Pos)           /*!< 0x00000200 */
N#define FSMC_BTR4_DATAST_2           (0x04UL << FSMC_BTR4_DATAST_Pos)           /*!< 0x00000400 */
N#define FSMC_BTR4_DATAST_3           (0x08UL << FSMC_BTR4_DATAST_Pos)           /*!< 0x00000800 */
N#define FSMC_BTR4_DATAST_4           (0x10UL << FSMC_BTR4_DATAST_Pos)           /*!< 0x00001000 */
N#define FSMC_BTR4_DATAST_5           (0x20UL << FSMC_BTR4_DATAST_Pos)           /*!< 0x00002000 */
N#define FSMC_BTR4_DATAST_6           (0x40UL << FSMC_BTR4_DATAST_Pos)           /*!< 0x00004000 */
N#define FSMC_BTR4_DATAST_7           (0x80UL << FSMC_BTR4_DATAST_Pos)           /*!< 0x00008000 */
N
N#define FSMC_BTR4_BUSTURN_Pos        (16U)                                     
N#define FSMC_BTR4_BUSTURN_Msk        (0xFUL << FSMC_BTR4_BUSTURN_Pos)           /*!< 0x000F0000 */
N#define FSMC_BTR4_BUSTURN            FSMC_BTR4_BUSTURN_Msk                     /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define FSMC_BTR4_BUSTURN_0          (0x1UL << FSMC_BTR4_BUSTURN_Pos)           /*!< 0x00010000 */
N#define FSMC_BTR4_BUSTURN_1          (0x2UL << FSMC_BTR4_BUSTURN_Pos)           /*!< 0x00020000 */
N#define FSMC_BTR4_BUSTURN_2          (0x4UL << FSMC_BTR4_BUSTURN_Pos)           /*!< 0x00040000 */
N#define FSMC_BTR4_BUSTURN_3          (0x8UL << FSMC_BTR4_BUSTURN_Pos)           /*!< 0x00080000 */
N
N#define FSMC_BTR4_CLKDIV_Pos         (20U)                                     
N#define FSMC_BTR4_CLKDIV_Msk         (0xFUL << FSMC_BTR4_CLKDIV_Pos)            /*!< 0x00F00000 */
N#define FSMC_BTR4_CLKDIV             FSMC_BTR4_CLKDIV_Msk                      /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define FSMC_BTR4_CLKDIV_0           (0x1UL << FSMC_BTR4_CLKDIV_Pos)            /*!< 0x00100000 */
N#define FSMC_BTR4_CLKDIV_1           (0x2UL << FSMC_BTR4_CLKDIV_Pos)            /*!< 0x00200000 */
N#define FSMC_BTR4_CLKDIV_2           (0x4UL << FSMC_BTR4_CLKDIV_Pos)            /*!< 0x00400000 */
N#define FSMC_BTR4_CLKDIV_3           (0x8UL << FSMC_BTR4_CLKDIV_Pos)            /*!< 0x00800000 */
N
N#define FSMC_BTR4_DATLAT_Pos         (24U)                                     
N#define FSMC_BTR4_DATLAT_Msk         (0xFUL << FSMC_BTR4_DATLAT_Pos)            /*!< 0x0F000000 */
N#define FSMC_BTR4_DATLAT             FSMC_BTR4_DATLAT_Msk                      /*!<DATLA[3:0] bits (Data latency) */
N#define FSMC_BTR4_DATLAT_0           (0x1UL << FSMC_BTR4_DATLAT_Pos)            /*!< 0x01000000 */
N#define FSMC_BTR4_DATLAT_1           (0x2UL << FSMC_BTR4_DATLAT_Pos)            /*!< 0x02000000 */
N#define FSMC_BTR4_DATLAT_2           (0x4UL << FSMC_BTR4_DATLAT_Pos)            /*!< 0x04000000 */
N#define FSMC_BTR4_DATLAT_3           (0x8UL << FSMC_BTR4_DATLAT_Pos)            /*!< 0x08000000 */
N
N#define FSMC_BTR4_ACCMOD_Pos         (28U)                                     
N#define FSMC_BTR4_ACCMOD_Msk         (0x3UL << FSMC_BTR4_ACCMOD_Pos)            /*!< 0x30000000 */
N#define FSMC_BTR4_ACCMOD             FSMC_BTR4_ACCMOD_Msk                      /*!<ACCMOD[1:0] bits (Access mode) */
N#define FSMC_BTR4_ACCMOD_0           (0x1UL << FSMC_BTR4_ACCMOD_Pos)            /*!< 0x10000000 */
N#define FSMC_BTR4_ACCMOD_1           (0x2UL << FSMC_BTR4_ACCMOD_Pos)            /*!< 0x20000000 */
N
N/******************  Bit definition for FSMC_BWTR1 register  ******************/
N#define FSMC_BWTR1_ADDSET_Pos        (0U)                                      
N#define FSMC_BWTR1_ADDSET_Msk        (0xFUL << FSMC_BWTR1_ADDSET_Pos)           /*!< 0x0000000F */
N#define FSMC_BWTR1_ADDSET            FSMC_BWTR1_ADDSET_Msk                     /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define FSMC_BWTR1_ADDSET_0          (0x1UL << FSMC_BWTR1_ADDSET_Pos)           /*!< 0x00000001 */
N#define FSMC_BWTR1_ADDSET_1          (0x2UL << FSMC_BWTR1_ADDSET_Pos)           /*!< 0x00000002 */
N#define FSMC_BWTR1_ADDSET_2          (0x4UL << FSMC_BWTR1_ADDSET_Pos)           /*!< 0x00000004 */
N#define FSMC_BWTR1_ADDSET_3          (0x8UL << FSMC_BWTR1_ADDSET_Pos)           /*!< 0x00000008 */
N
N#define FSMC_BWTR1_ADDHLD_Pos        (4U)                                      
N#define FSMC_BWTR1_ADDHLD_Msk        (0xFUL << FSMC_BWTR1_ADDHLD_Pos)           /*!< 0x000000F0 */
N#define FSMC_BWTR1_ADDHLD            FSMC_BWTR1_ADDHLD_Msk                     /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define FSMC_BWTR1_ADDHLD_0          (0x1UL << FSMC_BWTR1_ADDHLD_Pos)           /*!< 0x00000010 */
N#define FSMC_BWTR1_ADDHLD_1          (0x2UL << FSMC_BWTR1_ADDHLD_Pos)           /*!< 0x00000020 */
N#define FSMC_BWTR1_ADDHLD_2          (0x4UL << FSMC_BWTR1_ADDHLD_Pos)           /*!< 0x00000040 */
N#define FSMC_BWTR1_ADDHLD_3          (0x8UL << FSMC_BWTR1_ADDHLD_Pos)           /*!< 0x00000080 */
N
N#define FSMC_BWTR1_DATAST_Pos        (8U)                                      
N#define FSMC_BWTR1_DATAST_Msk        (0xFFUL << FSMC_BWTR1_DATAST_Pos)          /*!< 0x0000FF00 */
N#define FSMC_BWTR1_DATAST            FSMC_BWTR1_DATAST_Msk                     /*!<DATAST [7:0] bits (Data-phase duration) */
N#define FSMC_BWTR1_DATAST_0          (0x01UL << FSMC_BWTR1_DATAST_Pos)          /*!< 0x00000100 */
N#define FSMC_BWTR1_DATAST_1          (0x02UL << FSMC_BWTR1_DATAST_Pos)          /*!< 0x00000200 */
N#define FSMC_BWTR1_DATAST_2          (0x04UL << FSMC_BWTR1_DATAST_Pos)          /*!< 0x00000400 */
N#define FSMC_BWTR1_DATAST_3          (0x08UL << FSMC_BWTR1_DATAST_Pos)          /*!< 0x00000800 */
N#define FSMC_BWTR1_DATAST_4          (0x10UL << FSMC_BWTR1_DATAST_Pos)          /*!< 0x00001000 */
N#define FSMC_BWTR1_DATAST_5          (0x20UL << FSMC_BWTR1_DATAST_Pos)          /*!< 0x00002000 */
N#define FSMC_BWTR1_DATAST_6          (0x40UL << FSMC_BWTR1_DATAST_Pos)          /*!< 0x00004000 */
N#define FSMC_BWTR1_DATAST_7          (0x80UL << FSMC_BWTR1_DATAST_Pos)          /*!< 0x00008000 */
N
N#define FSMC_BWTR1_BUSTURN_Pos       (16U)                                     
N#define FSMC_BWTR1_BUSTURN_Msk       (0xFUL << FSMC_BWTR1_BUSTURN_Pos)          /*!< 0x000F0000 */
N#define FSMC_BWTR1_BUSTURN           FSMC_BWTR1_BUSTURN_Msk                    /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
N#define FSMC_BWTR1_BUSTURN_0         (0x1UL << FSMC_BWTR1_BUSTURN_Pos)          /*!< 0x00010000 */
N#define FSMC_BWTR1_BUSTURN_1         (0x2UL << FSMC_BWTR1_BUSTURN_Pos)          /*!< 0x00020000 */
N#define FSMC_BWTR1_BUSTURN_2         (0x4UL << FSMC_BWTR1_BUSTURN_Pos)          /*!< 0x00040000 */
N#define FSMC_BWTR1_BUSTURN_3         (0x8UL << FSMC_BWTR1_BUSTURN_Pos)          /*!< 0x00080000 */
N
N#define FSMC_BWTR1_ACCMOD_Pos        (28U)                                     
N#define FSMC_BWTR1_ACCMOD_Msk        (0x3UL << FSMC_BWTR1_ACCMOD_Pos)           /*!< 0x30000000 */
N#define FSMC_BWTR1_ACCMOD            FSMC_BWTR1_ACCMOD_Msk                     /*!<ACCMOD[1:0] bits (Access mode) */
N#define FSMC_BWTR1_ACCMOD_0          (0x1UL << FSMC_BWTR1_ACCMOD_Pos)           /*!< 0x10000000 */
N#define FSMC_BWTR1_ACCMOD_1          (0x2UL << FSMC_BWTR1_ACCMOD_Pos)           /*!< 0x20000000 */
N
N/******************  Bit definition for FSMC_BWTR2 register  ******************/
N#define FSMC_BWTR2_ADDSET_Pos        (0U)                                      
N#define FSMC_BWTR2_ADDSET_Msk        (0xFUL << FSMC_BWTR2_ADDSET_Pos)           /*!< 0x0000000F */
N#define FSMC_BWTR2_ADDSET            FSMC_BWTR2_ADDSET_Msk                     /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define FSMC_BWTR2_ADDSET_0          (0x1UL << FSMC_BWTR2_ADDSET_Pos)           /*!< 0x00000001 */
N#define FSMC_BWTR2_ADDSET_1          (0x2UL << FSMC_BWTR2_ADDSET_Pos)           /*!< 0x00000002 */
N#define FSMC_BWTR2_ADDSET_2          (0x4UL << FSMC_BWTR2_ADDSET_Pos)           /*!< 0x00000004 */
N#define FSMC_BWTR2_ADDSET_3          (0x8UL << FSMC_BWTR2_ADDSET_Pos)           /*!< 0x00000008 */
N
N#define FSMC_BWTR2_ADDHLD_Pos        (4U)                                      
N#define FSMC_BWTR2_ADDHLD_Msk        (0xFUL << FSMC_BWTR2_ADDHLD_Pos)           /*!< 0x000000F0 */
N#define FSMC_BWTR2_ADDHLD            FSMC_BWTR2_ADDHLD_Msk                     /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define FSMC_BWTR2_ADDHLD_0          (0x1UL << FSMC_BWTR2_ADDHLD_Pos)           /*!< 0x00000010 */
N#define FSMC_BWTR2_ADDHLD_1          (0x2UL << FSMC_BWTR2_ADDHLD_Pos)           /*!< 0x00000020 */
N#define FSMC_BWTR2_ADDHLD_2          (0x4UL << FSMC_BWTR2_ADDHLD_Pos)           /*!< 0x00000040 */
N#define FSMC_BWTR2_ADDHLD_3          (0x8UL << FSMC_BWTR2_ADDHLD_Pos)           /*!< 0x00000080 */
N
N#define FSMC_BWTR2_DATAST_Pos        (8U)                                      
N#define FSMC_BWTR2_DATAST_Msk        (0xFFUL << FSMC_BWTR2_DATAST_Pos)          /*!< 0x0000FF00 */
N#define FSMC_BWTR2_DATAST            FSMC_BWTR2_DATAST_Msk                     /*!<DATAST [7:0] bits (Data-phase duration) */
N#define FSMC_BWTR2_DATAST_0          (0x01UL << FSMC_BWTR2_DATAST_Pos)          /*!< 0x00000100 */
N#define FSMC_BWTR2_DATAST_1          (0x02UL << FSMC_BWTR2_DATAST_Pos)          /*!< 0x00000200 */
N#define FSMC_BWTR2_DATAST_2          (0x04UL << FSMC_BWTR2_DATAST_Pos)          /*!< 0x00000400 */
N#define FSMC_BWTR2_DATAST_3          (0x08UL << FSMC_BWTR2_DATAST_Pos)          /*!< 0x00000800 */
N#define FSMC_BWTR2_DATAST_4          (0x10UL << FSMC_BWTR2_DATAST_Pos)          /*!< 0x00001000 */
N#define FSMC_BWTR2_DATAST_5          (0x20UL << FSMC_BWTR2_DATAST_Pos)          /*!< 0x00002000 */
N#define FSMC_BWTR2_DATAST_6          (0x40UL << FSMC_BWTR2_DATAST_Pos)          /*!< 0x00004000 */
N#define FSMC_BWTR2_DATAST_7          (0x80UL << FSMC_BWTR2_DATAST_Pos)          /*!< 0x00008000 */
N
N#define FSMC_BWTR2_BUSTURN_Pos       (16U)                                     
N#define FSMC_BWTR2_BUSTURN_Msk       (0xFUL << FSMC_BWTR2_BUSTURN_Pos)          /*!< 0x000F0000 */
N#define FSMC_BWTR2_BUSTURN           FSMC_BWTR2_BUSTURN_Msk                    /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
N#define FSMC_BWTR2_BUSTURN_0         (0x1UL << FSMC_BWTR2_BUSTURN_Pos)          /*!< 0x00010000 */
N#define FSMC_BWTR2_BUSTURN_1         (0x2UL << FSMC_BWTR2_BUSTURN_Pos)          /*!< 0x00020000 */
N#define FSMC_BWTR2_BUSTURN_2         (0x4UL << FSMC_BWTR2_BUSTURN_Pos)          /*!< 0x00040000 */
N#define FSMC_BWTR2_BUSTURN_3         (0x8UL << FSMC_BWTR2_BUSTURN_Pos)          /*!< 0x00080000 */
N
N#define FSMC_BWTR2_ACCMOD_Pos        (28U)                                     
N#define FSMC_BWTR2_ACCMOD_Msk        (0x3UL << FSMC_BWTR2_ACCMOD_Pos)           /*!< 0x30000000 */
N#define FSMC_BWTR2_ACCMOD            FSMC_BWTR2_ACCMOD_Msk                     /*!<ACCMOD[1:0] bits (Access mode) */
N#define FSMC_BWTR2_ACCMOD_0          (0x1UL << FSMC_BWTR2_ACCMOD_Pos)           /*!< 0x10000000 */
N#define FSMC_BWTR2_ACCMOD_1          (0x2UL << FSMC_BWTR2_ACCMOD_Pos)           /*!< 0x20000000 */
N
N/******************  Bit definition for FSMC_BWTR3 register  ******************/
N#define FSMC_BWTR3_ADDSET_Pos        (0U)                                      
N#define FSMC_BWTR3_ADDSET_Msk        (0xFUL << FSMC_BWTR3_ADDSET_Pos)           /*!< 0x0000000F */
N#define FSMC_BWTR3_ADDSET            FSMC_BWTR3_ADDSET_Msk                     /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define FSMC_BWTR3_ADDSET_0          (0x1UL << FSMC_BWTR3_ADDSET_Pos)           /*!< 0x00000001 */
N#define FSMC_BWTR3_ADDSET_1          (0x2UL << FSMC_BWTR3_ADDSET_Pos)           /*!< 0x00000002 */
N#define FSMC_BWTR3_ADDSET_2          (0x4UL << FSMC_BWTR3_ADDSET_Pos)           /*!< 0x00000004 */
N#define FSMC_BWTR3_ADDSET_3          (0x8UL << FSMC_BWTR3_ADDSET_Pos)           /*!< 0x00000008 */
N
N#define FSMC_BWTR3_ADDHLD_Pos        (4U)                                      
N#define FSMC_BWTR3_ADDHLD_Msk        (0xFUL << FSMC_BWTR3_ADDHLD_Pos)           /*!< 0x000000F0 */
N#define FSMC_BWTR3_ADDHLD            FSMC_BWTR3_ADDHLD_Msk                     /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define FSMC_BWTR3_ADDHLD_0          (0x1UL << FSMC_BWTR3_ADDHLD_Pos)           /*!< 0x00000010 */
N#define FSMC_BWTR3_ADDHLD_1          (0x2UL << FSMC_BWTR3_ADDHLD_Pos)           /*!< 0x00000020 */
N#define FSMC_BWTR3_ADDHLD_2          (0x4UL << FSMC_BWTR3_ADDHLD_Pos)           /*!< 0x00000040 */
N#define FSMC_BWTR3_ADDHLD_3          (0x8UL << FSMC_BWTR3_ADDHLD_Pos)           /*!< 0x00000080 */
N
N#define FSMC_BWTR3_DATAST_Pos        (8U)                                      
N#define FSMC_BWTR3_DATAST_Msk        (0xFFUL << FSMC_BWTR3_DATAST_Pos)          /*!< 0x0000FF00 */
N#define FSMC_BWTR3_DATAST            FSMC_BWTR3_DATAST_Msk                     /*!<DATAST [7:0] bits (Data-phase duration) */
N#define FSMC_BWTR3_DATAST_0          (0x01UL << FSMC_BWTR3_DATAST_Pos)          /*!< 0x00000100 */
N#define FSMC_BWTR3_DATAST_1          (0x02UL << FSMC_BWTR3_DATAST_Pos)          /*!< 0x00000200 */
N#define FSMC_BWTR3_DATAST_2          (0x04UL << FSMC_BWTR3_DATAST_Pos)          /*!< 0x00000400 */
N#define FSMC_BWTR3_DATAST_3          (0x08UL << FSMC_BWTR3_DATAST_Pos)          /*!< 0x00000800 */
N#define FSMC_BWTR3_DATAST_4          (0x10UL << FSMC_BWTR3_DATAST_Pos)          /*!< 0x00001000 */
N#define FSMC_BWTR3_DATAST_5          (0x20UL << FSMC_BWTR3_DATAST_Pos)          /*!< 0x00002000 */
N#define FSMC_BWTR3_DATAST_6          (0x40UL << FSMC_BWTR3_DATAST_Pos)          /*!< 0x00004000 */
N#define FSMC_BWTR3_DATAST_7          (0x80UL << FSMC_BWTR3_DATAST_Pos)          /*!< 0x00008000 */
N
N#define FSMC_BWTR3_BUSTURN_Pos       (16U)                                     
N#define FSMC_BWTR3_BUSTURN_Msk       (0xFUL << FSMC_BWTR3_BUSTURN_Pos)          /*!< 0x000F0000 */
N#define FSMC_BWTR3_BUSTURN           FSMC_BWTR3_BUSTURN_Msk                    /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
N#define FSMC_BWTR3_BUSTURN_0         (0x1UL << FSMC_BWTR3_BUSTURN_Pos)          /*!< 0x00010000 */
N#define FSMC_BWTR3_BUSTURN_1         (0x2UL << FSMC_BWTR3_BUSTURN_Pos)          /*!< 0x00020000 */
N#define FSMC_BWTR3_BUSTURN_2         (0x4UL << FSMC_BWTR3_BUSTURN_Pos)          /*!< 0x00040000 */
N#define FSMC_BWTR3_BUSTURN_3         (0x8UL << FSMC_BWTR3_BUSTURN_Pos)          /*!< 0x00080000 */
N
N#define FSMC_BWTR3_ACCMOD_Pos        (28U)                                     
N#define FSMC_BWTR3_ACCMOD_Msk        (0x3UL << FSMC_BWTR3_ACCMOD_Pos)           /*!< 0x30000000 */
N#define FSMC_BWTR3_ACCMOD            FSMC_BWTR3_ACCMOD_Msk                     /*!<ACCMOD[1:0] bits (Access mode) */
N#define FSMC_BWTR3_ACCMOD_0          (0x1UL << FSMC_BWTR3_ACCMOD_Pos)           /*!< 0x10000000 */
N#define FSMC_BWTR3_ACCMOD_1          (0x2UL << FSMC_BWTR3_ACCMOD_Pos)           /*!< 0x20000000 */
N
N/******************  Bit definition for FSMC_BWTR4 register  ******************/
N#define FSMC_BWTR4_ADDSET_Pos        (0U)                                      
N#define FSMC_BWTR4_ADDSET_Msk        (0xFUL << FSMC_BWTR4_ADDSET_Pos)           /*!< 0x0000000F */
N#define FSMC_BWTR4_ADDSET            FSMC_BWTR4_ADDSET_Msk                     /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define FSMC_BWTR4_ADDSET_0          (0x1UL << FSMC_BWTR4_ADDSET_Pos)           /*!< 0x00000001 */
N#define FSMC_BWTR4_ADDSET_1          (0x2UL << FSMC_BWTR4_ADDSET_Pos)           /*!< 0x00000002 */
N#define FSMC_BWTR4_ADDSET_2          (0x4UL << FSMC_BWTR4_ADDSET_Pos)           /*!< 0x00000004 */
N#define FSMC_BWTR4_ADDSET_3          (0x8UL << FSMC_BWTR4_ADDSET_Pos)           /*!< 0x00000008 */
N
N#define FSMC_BWTR4_ADDHLD_Pos        (4U)                                      
N#define FSMC_BWTR4_ADDHLD_Msk        (0xFUL << FSMC_BWTR4_ADDHLD_Pos)           /*!< 0x000000F0 */
N#define FSMC_BWTR4_ADDHLD            FSMC_BWTR4_ADDHLD_Msk                     /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define FSMC_BWTR4_ADDHLD_0          (0x1UL << FSMC_BWTR4_ADDHLD_Pos)           /*!< 0x00000010 */
N#define FSMC_BWTR4_ADDHLD_1          (0x2UL << FSMC_BWTR4_ADDHLD_Pos)           /*!< 0x00000020 */
N#define FSMC_BWTR4_ADDHLD_2          (0x4UL << FSMC_BWTR4_ADDHLD_Pos)           /*!< 0x00000040 */
N#define FSMC_BWTR4_ADDHLD_3          (0x8UL << FSMC_BWTR4_ADDHLD_Pos)           /*!< 0x00000080 */
N
N#define FSMC_BWTR4_DATAST_Pos        (8U)                                      
N#define FSMC_BWTR4_DATAST_Msk        (0xFFUL << FSMC_BWTR4_DATAST_Pos)          /*!< 0x0000FF00 */
N#define FSMC_BWTR4_DATAST            FSMC_BWTR4_DATAST_Msk                     /*!<DATAST [3:0] bits (Data-phase duration) */
N#define FSMC_BWTR4_DATAST_0          0x00000100U                               /*!<Bit 0 */
N#define FSMC_BWTR4_DATAST_1          0x00000200U                               /*!<Bit 1 */
N#define FSMC_BWTR4_DATAST_2          0x00000400U                               /*!<Bit 2 */
N#define FSMC_BWTR4_DATAST_3          0x00000800U                               /*!<Bit 3 */
N#define FSMC_BWTR4_DATAST_4          0x00001000U                               /*!<Bit 4 */
N#define FSMC_BWTR4_DATAST_5          0x00002000U                               /*!<Bit 5 */
N#define FSMC_BWTR4_DATAST_6          0x00004000U                               /*!<Bit 6 */
N#define FSMC_BWTR4_DATAST_7          0x00008000U                               /*!<Bit 7 */
N
N#define FSMC_BWTR4_BUSTURN_Pos       (16U)                                     
N#define FSMC_BWTR4_BUSTURN_Msk       (0xFUL << FSMC_BWTR4_BUSTURN_Pos)          /*!< 0x000F0000 */
N#define FSMC_BWTR4_BUSTURN           FSMC_BWTR4_BUSTURN_Msk                    /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
N#define FSMC_BWTR4_BUSTURN_0         (0x1UL << FSMC_BWTR4_BUSTURN_Pos)          /*!< 0x00010000 */
N#define FSMC_BWTR4_BUSTURN_1         (0x2UL << FSMC_BWTR4_BUSTURN_Pos)          /*!< 0x00020000 */
N#define FSMC_BWTR4_BUSTURN_2         (0x4UL << FSMC_BWTR4_BUSTURN_Pos)          /*!< 0x00040000 */
N#define FSMC_BWTR4_BUSTURN_3         (0x8UL << FSMC_BWTR4_BUSTURN_Pos)          /*!< 0x00080000 */
N
N#define FSMC_BWTR4_ACCMOD_Pos        (28U)                                     
N#define FSMC_BWTR4_ACCMOD_Msk        (0x3UL << FSMC_BWTR4_ACCMOD_Pos)           /*!< 0x30000000 */
N#define FSMC_BWTR4_ACCMOD            FSMC_BWTR4_ACCMOD_Msk                     /*!<ACCMOD[1:0] bits (Access mode) */
N#define FSMC_BWTR4_ACCMOD_0          (0x1UL << FSMC_BWTR4_ACCMOD_Pos)           /*!< 0x10000000 */
N#define FSMC_BWTR4_ACCMOD_1          (0x2UL << FSMC_BWTR4_ACCMOD_Pos)           /*!< 0x20000000 */
N
N/******************  Bit definition for FSMC_PCR2 register  *******************/
N#define FSMC_PCR2_PWAITEN_Pos        (1U)                                      
N#define FSMC_PCR2_PWAITEN_Msk        (0x1UL << FSMC_PCR2_PWAITEN_Pos)           /*!< 0x00000002 */
N#define FSMC_PCR2_PWAITEN            FSMC_PCR2_PWAITEN_Msk                     /*!<Wait feature enable bit */
N#define FSMC_PCR2_PBKEN_Pos          (2U)                                      
N#define FSMC_PCR2_PBKEN_Msk          (0x1UL << FSMC_PCR2_PBKEN_Pos)             /*!< 0x00000004 */
N#define FSMC_PCR2_PBKEN              FSMC_PCR2_PBKEN_Msk                       /*!<PC Card/NAND Flash memory bank enable bit */
N#define FSMC_PCR2_PTYP_Pos           (3U)                                      
N#define FSMC_PCR2_PTYP_Msk           (0x1UL << FSMC_PCR2_PTYP_Pos)              /*!< 0x00000008 */
N#define FSMC_PCR2_PTYP               FSMC_PCR2_PTYP_Msk                        /*!<Memory type */
N
N#define FSMC_PCR2_PWID_Pos           (4U)                                      
N#define FSMC_PCR2_PWID_Msk           (0x3UL << FSMC_PCR2_PWID_Pos)              /*!< 0x00000030 */
N#define FSMC_PCR2_PWID               FSMC_PCR2_PWID_Msk                        /*!<PWID[1:0] bits (NAND Flash databus width) */
N#define FSMC_PCR2_PWID_0             (0x1UL << FSMC_PCR2_PWID_Pos)              /*!< 0x00000010 */
N#define FSMC_PCR2_PWID_1             (0x2UL << FSMC_PCR2_PWID_Pos)              /*!< 0x00000020 */
N
N#define FSMC_PCR2_ECCEN_Pos          (6U)                                      
N#define FSMC_PCR2_ECCEN_Msk          (0x1UL << FSMC_PCR2_ECCEN_Pos)             /*!< 0x00000040 */
N#define FSMC_PCR2_ECCEN              FSMC_PCR2_ECCEN_Msk                       /*!<ECC computation logic enable bit */
N
N#define FSMC_PCR2_TCLR_Pos           (9U)                                      
N#define FSMC_PCR2_TCLR_Msk           (0xFUL << FSMC_PCR2_TCLR_Pos)              /*!< 0x00001E00 */
N#define FSMC_PCR2_TCLR               FSMC_PCR2_TCLR_Msk                        /*!<TCLR[3:0] bits (CLE to RE delay) */
N#define FSMC_PCR2_TCLR_0             (0x1UL << FSMC_PCR2_TCLR_Pos)              /*!< 0x00000200 */
N#define FSMC_PCR2_TCLR_1             (0x2UL << FSMC_PCR2_TCLR_Pos)              /*!< 0x00000400 */
N#define FSMC_PCR2_TCLR_2             (0x4UL << FSMC_PCR2_TCLR_Pos)              /*!< 0x00000800 */
N#define FSMC_PCR2_TCLR_3             (0x8UL << FSMC_PCR2_TCLR_Pos)              /*!< 0x00001000 */
N
N#define FSMC_PCR2_TAR_Pos            (13U)                                     
N#define FSMC_PCR2_TAR_Msk            (0xFUL << FSMC_PCR2_TAR_Pos)               /*!< 0x0001E000 */
N#define FSMC_PCR2_TAR                FSMC_PCR2_TAR_Msk                         /*!<TAR[3:0] bits (ALE to RE delay) */
N#define FSMC_PCR2_TAR_0              (0x1UL << FSMC_PCR2_TAR_Pos)               /*!< 0x00002000 */
N#define FSMC_PCR2_TAR_1              (0x2UL << FSMC_PCR2_TAR_Pos)               /*!< 0x00004000 */
N#define FSMC_PCR2_TAR_2              (0x4UL << FSMC_PCR2_TAR_Pos)               /*!< 0x00008000 */
N#define FSMC_PCR2_TAR_3              (0x8UL << FSMC_PCR2_TAR_Pos)               /*!< 0x00010000 */
N
N#define FSMC_PCR2_ECCPS_Pos          (17U)                                     
N#define FSMC_PCR2_ECCPS_Msk          (0x7UL << FSMC_PCR2_ECCPS_Pos)             /*!< 0x000E0000 */
N#define FSMC_PCR2_ECCPS              FSMC_PCR2_ECCPS_Msk                       /*!<ECCPS[1:0] bits (ECC page size) */
N#define FSMC_PCR2_ECCPS_0            (0x1UL << FSMC_PCR2_ECCPS_Pos)             /*!< 0x00020000 */
N#define FSMC_PCR2_ECCPS_1            (0x2UL << FSMC_PCR2_ECCPS_Pos)             /*!< 0x00040000 */
N#define FSMC_PCR2_ECCPS_2            (0x4UL << FSMC_PCR2_ECCPS_Pos)             /*!< 0x00080000 */
N
N/******************  Bit definition for FSMC_PCR3 register  *******************/
N#define FSMC_PCR3_PWAITEN_Pos        (1U)                                      
N#define FSMC_PCR3_PWAITEN_Msk        (0x1UL << FSMC_PCR3_PWAITEN_Pos)           /*!< 0x00000002 */
N#define FSMC_PCR3_PWAITEN            FSMC_PCR3_PWAITEN_Msk                     /*!<Wait feature enable bit */
N#define FSMC_PCR3_PBKEN_Pos          (2U)                                      
N#define FSMC_PCR3_PBKEN_Msk          (0x1UL << FSMC_PCR3_PBKEN_Pos)             /*!< 0x00000004 */
N#define FSMC_PCR3_PBKEN              FSMC_PCR3_PBKEN_Msk                       /*!<PC Card/NAND Flash memory bank enable bit */
N#define FSMC_PCR3_PTYP_Pos           (3U)                                      
N#define FSMC_PCR3_PTYP_Msk           (0x1UL << FSMC_PCR3_PTYP_Pos)              /*!< 0x00000008 */
N#define FSMC_PCR3_PTYP               FSMC_PCR3_PTYP_Msk                        /*!<Memory type */
N
N#define FSMC_PCR3_PWID_Pos           (4U)                                      
N#define FSMC_PCR3_PWID_Msk           (0x3UL << FSMC_PCR3_PWID_Pos)              /*!< 0x00000030 */
N#define FSMC_PCR3_PWID               FSMC_PCR3_PWID_Msk                        /*!<PWID[1:0] bits (NAND Flash databus width) */
N#define FSMC_PCR3_PWID_0             (0x1UL << FSMC_PCR3_PWID_Pos)              /*!< 0x00000010 */
N#define FSMC_PCR3_PWID_1             (0x2UL << FSMC_PCR3_PWID_Pos)              /*!< 0x00000020 */
N
N#define FSMC_PCR3_ECCEN_Pos          (6U)                                      
N#define FSMC_PCR3_ECCEN_Msk          (0x1UL << FSMC_PCR3_ECCEN_Pos)             /*!< 0x00000040 */
N#define FSMC_PCR3_ECCEN              FSMC_PCR3_ECCEN_Msk                       /*!<ECC computation logic enable bit */
N
N#define FSMC_PCR3_TCLR_Pos           (9U)                                      
N#define FSMC_PCR3_TCLR_Msk           (0xFUL << FSMC_PCR3_TCLR_Pos)              /*!< 0x00001E00 */
N#define FSMC_PCR3_TCLR               FSMC_PCR3_TCLR_Msk                        /*!<TCLR[3:0] bits (CLE to RE delay) */
N#define FSMC_PCR3_TCLR_0             (0x1UL << FSMC_PCR3_TCLR_Pos)              /*!< 0x00000200 */
N#define FSMC_PCR3_TCLR_1             (0x2UL << FSMC_PCR3_TCLR_Pos)              /*!< 0x00000400 */
N#define FSMC_PCR3_TCLR_2             (0x4UL << FSMC_PCR3_TCLR_Pos)              /*!< 0x00000800 */
N#define FSMC_PCR3_TCLR_3             (0x8UL << FSMC_PCR3_TCLR_Pos)              /*!< 0x00001000 */
N
N#define FSMC_PCR3_TAR_Pos            (13U)                                     
N#define FSMC_PCR3_TAR_Msk            (0xFUL << FSMC_PCR3_TAR_Pos)               /*!< 0x0001E000 */
N#define FSMC_PCR3_TAR                FSMC_PCR3_TAR_Msk                         /*!<TAR[3:0] bits (ALE to RE delay) */
N#define FSMC_PCR3_TAR_0              (0x1UL << FSMC_PCR3_TAR_Pos)               /*!< 0x00002000 */
N#define FSMC_PCR3_TAR_1              (0x2UL << FSMC_PCR3_TAR_Pos)               /*!< 0x00004000 */
N#define FSMC_PCR3_TAR_2              (0x4UL << FSMC_PCR3_TAR_Pos)               /*!< 0x00008000 */
N#define FSMC_PCR3_TAR_3              (0x8UL << FSMC_PCR3_TAR_Pos)               /*!< 0x00010000 */
N
N#define FSMC_PCR3_ECCPS_Pos          (17U)                                     
N#define FSMC_PCR3_ECCPS_Msk          (0x7UL << FSMC_PCR3_ECCPS_Pos)             /*!< 0x000E0000 */
N#define FSMC_PCR3_ECCPS              FSMC_PCR3_ECCPS_Msk                       /*!<ECCPS[2:0] bits (ECC page size) */
N#define FSMC_PCR3_ECCPS_0            (0x1UL << FSMC_PCR3_ECCPS_Pos)             /*!< 0x00020000 */
N#define FSMC_PCR3_ECCPS_1            (0x2UL << FSMC_PCR3_ECCPS_Pos)             /*!< 0x00040000 */
N#define FSMC_PCR3_ECCPS_2            (0x4UL << FSMC_PCR3_ECCPS_Pos)             /*!< 0x00080000 */
N
N/******************  Bit definition for FSMC_PCR4 register  *******************/
N#define FSMC_PCR4_PWAITEN_Pos        (1U)                                      
N#define FSMC_PCR4_PWAITEN_Msk        (0x1UL << FSMC_PCR4_PWAITEN_Pos)           /*!< 0x00000002 */
N#define FSMC_PCR4_PWAITEN            FSMC_PCR4_PWAITEN_Msk                     /*!<Wait feature enable bit */
N#define FSMC_PCR4_PBKEN_Pos          (2U)                                      
N#define FSMC_PCR4_PBKEN_Msk          (0x1UL << FSMC_PCR4_PBKEN_Pos)             /*!< 0x00000004 */
N#define FSMC_PCR4_PBKEN              FSMC_PCR4_PBKEN_Msk                       /*!<PC Card/NAND Flash memory bank enable bit */
N#define FSMC_PCR4_PTYP_Pos           (3U)                                      
N#define FSMC_PCR4_PTYP_Msk           (0x1UL << FSMC_PCR4_PTYP_Pos)              /*!< 0x00000008 */
N#define FSMC_PCR4_PTYP               FSMC_PCR4_PTYP_Msk                        /*!<Memory type */
N
N#define FSMC_PCR4_PWID_Pos           (4U)                                      
N#define FSMC_PCR4_PWID_Msk           (0x3UL << FSMC_PCR4_PWID_Pos)              /*!< 0x00000030 */
N#define FSMC_PCR4_PWID               FSMC_PCR4_PWID_Msk                        /*!<PWID[1:0] bits (NAND Flash databus width) */
N#define FSMC_PCR4_PWID_0             (0x1UL << FSMC_PCR4_PWID_Pos)              /*!< 0x00000010 */
N#define FSMC_PCR4_PWID_1             (0x2UL << FSMC_PCR4_PWID_Pos)              /*!< 0x00000020 */
N
N#define FSMC_PCR4_ECCEN_Pos          (6U)                                      
N#define FSMC_PCR4_ECCEN_Msk          (0x1UL << FSMC_PCR4_ECCEN_Pos)             /*!< 0x00000040 */
N#define FSMC_PCR4_ECCEN              FSMC_PCR4_ECCEN_Msk                       /*!<ECC computation logic enable bit */
N
N#define FSMC_PCR4_TCLR_Pos           (9U)                                      
N#define FSMC_PCR4_TCLR_Msk           (0xFUL << FSMC_PCR4_TCLR_Pos)              /*!< 0x00001E00 */
N#define FSMC_PCR4_TCLR               FSMC_PCR4_TCLR_Msk                        /*!<TCLR[3:0] bits (CLE to RE delay) */
N#define FSMC_PCR4_TCLR_0             (0x1UL << FSMC_PCR4_TCLR_Pos)              /*!< 0x00000200 */
N#define FSMC_PCR4_TCLR_1             (0x2UL << FSMC_PCR4_TCLR_Pos)              /*!< 0x00000400 */
N#define FSMC_PCR4_TCLR_2             (0x4UL << FSMC_PCR4_TCLR_Pos)              /*!< 0x00000800 */
N#define FSMC_PCR4_TCLR_3             (0x8UL << FSMC_PCR4_TCLR_Pos)              /*!< 0x00001000 */
N
N#define FSMC_PCR4_TAR_Pos            (13U)                                     
N#define FSMC_PCR4_TAR_Msk            (0xFUL << FSMC_PCR4_TAR_Pos)               /*!< 0x0001E000 */
N#define FSMC_PCR4_TAR                FSMC_PCR4_TAR_Msk                         /*!<TAR[3:0] bits (ALE to RE delay) */
N#define FSMC_PCR4_TAR_0              (0x1UL << FSMC_PCR4_TAR_Pos)               /*!< 0x00002000 */
N#define FSMC_PCR4_TAR_1              (0x2UL << FSMC_PCR4_TAR_Pos)               /*!< 0x00004000 */
N#define FSMC_PCR4_TAR_2              (0x4UL << FSMC_PCR4_TAR_Pos)               /*!< 0x00008000 */
N#define FSMC_PCR4_TAR_3              (0x8UL << FSMC_PCR4_TAR_Pos)               /*!< 0x00010000 */
N
N#define FSMC_PCR4_ECCPS_Pos          (17U)                                     
N#define FSMC_PCR4_ECCPS_Msk          (0x7UL << FSMC_PCR4_ECCPS_Pos)             /*!< 0x000E0000 */
N#define FSMC_PCR4_ECCPS              FSMC_PCR4_ECCPS_Msk                       /*!<ECCPS[2:0] bits (ECC page size) */
N#define FSMC_PCR4_ECCPS_0            (0x1UL << FSMC_PCR4_ECCPS_Pos)             /*!< 0x00020000 */
N#define FSMC_PCR4_ECCPS_1            (0x2UL << FSMC_PCR4_ECCPS_Pos)             /*!< 0x00040000 */
N#define FSMC_PCR4_ECCPS_2            (0x4UL << FSMC_PCR4_ECCPS_Pos)             /*!< 0x00080000 */
N
N/*******************  Bit definition for FSMC_SR2 register  *******************/
N#define FSMC_SR2_IRS_Pos             (0U)                                      
N#define FSMC_SR2_IRS_Msk             (0x1UL << FSMC_SR2_IRS_Pos)                /*!< 0x00000001 */
N#define FSMC_SR2_IRS                 FSMC_SR2_IRS_Msk                          /*!<Interrupt Rising Edge status                */
N#define FSMC_SR2_ILS_Pos             (1U)                                      
N#define FSMC_SR2_ILS_Msk             (0x1UL << FSMC_SR2_ILS_Pos)                /*!< 0x00000002 */
N#define FSMC_SR2_ILS                 FSMC_SR2_ILS_Msk                          /*!<Interrupt Level status                      */
N#define FSMC_SR2_IFS_Pos             (2U)                                      
N#define FSMC_SR2_IFS_Msk             (0x1UL << FSMC_SR2_IFS_Pos)                /*!< 0x00000004 */
N#define FSMC_SR2_IFS                 FSMC_SR2_IFS_Msk                          /*!<Interrupt Falling Edge status               */
N#define FSMC_SR2_IREN_Pos            (3U)                                      
N#define FSMC_SR2_IREN_Msk            (0x1UL << FSMC_SR2_IREN_Pos)               /*!< 0x00000008 */
N#define FSMC_SR2_IREN                FSMC_SR2_IREN_Msk                         /*!<Interrupt Rising Edge detection Enable bit  */
N#define FSMC_SR2_ILEN_Pos            (4U)                                      
N#define FSMC_SR2_ILEN_Msk            (0x1UL << FSMC_SR2_ILEN_Pos)               /*!< 0x00000010 */
N#define FSMC_SR2_ILEN                FSMC_SR2_ILEN_Msk                         /*!<Interrupt Level detection Enable bit        */
N#define FSMC_SR2_IFEN_Pos            (5U)                                      
N#define FSMC_SR2_IFEN_Msk            (0x1UL << FSMC_SR2_IFEN_Pos)               /*!< 0x00000020 */
N#define FSMC_SR2_IFEN                FSMC_SR2_IFEN_Msk                         /*!<Interrupt Falling Edge detection Enable bit */
N#define FSMC_SR2_FEMPT_Pos           (6U)                                      
N#define FSMC_SR2_FEMPT_Msk           (0x1UL << FSMC_SR2_FEMPT_Pos)              /*!< 0x00000040 */
N#define FSMC_SR2_FEMPT               FSMC_SR2_FEMPT_Msk                        /*!<FIFO empty */
N
N/*******************  Bit definition for FSMC_SR3 register  *******************/
N#define FSMC_SR3_IRS_Pos             (0U)                                      
N#define FSMC_SR3_IRS_Msk             (0x1UL << FSMC_SR3_IRS_Pos)                /*!< 0x00000001 */
N#define FSMC_SR3_IRS                 FSMC_SR3_IRS_Msk                          /*!<Interrupt Rising Edge status                */
N#define FSMC_SR3_ILS_Pos             (1U)                                      
N#define FSMC_SR3_ILS_Msk             (0x1UL << FSMC_SR3_ILS_Pos)                /*!< 0x00000002 */
N#define FSMC_SR3_ILS                 FSMC_SR3_ILS_Msk                          /*!<Interrupt Level status                      */
N#define FSMC_SR3_IFS_Pos             (2U)                                      
N#define FSMC_SR3_IFS_Msk             (0x1UL << FSMC_SR3_IFS_Pos)                /*!< 0x00000004 */
N#define FSMC_SR3_IFS                 FSMC_SR3_IFS_Msk                          /*!<Interrupt Falling Edge status               */
N#define FSMC_SR3_IREN_Pos            (3U)                                      
N#define FSMC_SR3_IREN_Msk            (0x1UL << FSMC_SR3_IREN_Pos)               /*!< 0x00000008 */
N#define FSMC_SR3_IREN                FSMC_SR3_IREN_Msk                         /*!<Interrupt Rising Edge detection Enable bit  */
N#define FSMC_SR3_ILEN_Pos            (4U)                                      
N#define FSMC_SR3_ILEN_Msk            (0x1UL << FSMC_SR3_ILEN_Pos)               /*!< 0x00000010 */
N#define FSMC_SR3_ILEN                FSMC_SR3_ILEN_Msk                         /*!<Interrupt Level detection Enable bit        */
N#define FSMC_SR3_IFEN_Pos            (5U)                                      
N#define FSMC_SR3_IFEN_Msk            (0x1UL << FSMC_SR3_IFEN_Pos)               /*!< 0x00000020 */
N#define FSMC_SR3_IFEN                FSMC_SR3_IFEN_Msk                         /*!<Interrupt Falling Edge detection Enable bit */
N#define FSMC_SR3_FEMPT_Pos           (6U)                                      
N#define FSMC_SR3_FEMPT_Msk           (0x1UL << FSMC_SR3_FEMPT_Pos)              /*!< 0x00000040 */
N#define FSMC_SR3_FEMPT               FSMC_SR3_FEMPT_Msk                        /*!<FIFO empty */
N
N/*******************  Bit definition for FSMC_SR4 register  *******************/
N#define FSMC_SR4_IRS_Pos             (0U)                                      
N#define FSMC_SR4_IRS_Msk             (0x1UL << FSMC_SR4_IRS_Pos)                /*!< 0x00000001 */
N#define FSMC_SR4_IRS                 FSMC_SR4_IRS_Msk                          /*!<Interrupt Rising Edge status                 */
N#define FSMC_SR4_ILS_Pos             (1U)                                      
N#define FSMC_SR4_ILS_Msk             (0x1UL << FSMC_SR4_ILS_Pos)                /*!< 0x00000002 */
N#define FSMC_SR4_ILS                 FSMC_SR4_ILS_Msk                          /*!<Interrupt Level status                       */
N#define FSMC_SR4_IFS_Pos             (2U)                                      
N#define FSMC_SR4_IFS_Msk             (0x1UL << FSMC_SR4_IFS_Pos)                /*!< 0x00000004 */
N#define FSMC_SR4_IFS                 FSMC_SR4_IFS_Msk                          /*!<Interrupt Falling Edge status                */
N#define FSMC_SR4_IREN_Pos            (3U)                                      
N#define FSMC_SR4_IREN_Msk            (0x1UL << FSMC_SR4_IREN_Pos)               /*!< 0x00000008 */
N#define FSMC_SR4_IREN                FSMC_SR4_IREN_Msk                         /*!<Interrupt Rising Edge detection Enable bit   */
N#define FSMC_SR4_ILEN_Pos            (4U)                                      
N#define FSMC_SR4_ILEN_Msk            (0x1UL << FSMC_SR4_ILEN_Pos)               /*!< 0x00000010 */
N#define FSMC_SR4_ILEN                FSMC_SR4_ILEN_Msk                         /*!<Interrupt Level detection Enable bit         */
N#define FSMC_SR4_IFEN_Pos            (5U)                                      
N#define FSMC_SR4_IFEN_Msk            (0x1UL << FSMC_SR4_IFEN_Pos)               /*!< 0x00000020 */
N#define FSMC_SR4_IFEN                FSMC_SR4_IFEN_Msk                         /*!<Interrupt Falling Edge detection Enable bit  */
N#define FSMC_SR4_FEMPT_Pos           (6U)                                      
N#define FSMC_SR4_FEMPT_Msk           (0x1UL << FSMC_SR4_FEMPT_Pos)              /*!< 0x00000040 */
N#define FSMC_SR4_FEMPT               FSMC_SR4_FEMPT_Msk                        /*!<FIFO empty */
N
N/******************  Bit definition for FSMC_PMEM2 register  ******************/
N#define FSMC_PMEM2_MEMSET2_Pos       (0U)                                      
N#define FSMC_PMEM2_MEMSET2_Msk       (0xFFUL << FSMC_PMEM2_MEMSET2_Pos)         /*!< 0x000000FF */
N#define FSMC_PMEM2_MEMSET2           FSMC_PMEM2_MEMSET2_Msk                    /*!<MEMSET2[7:0] bits (Common memory 2 setup time) */
N#define FSMC_PMEM2_MEMSET2_0         (0x01UL << FSMC_PMEM2_MEMSET2_Pos)         /*!< 0x00000001 */
N#define FSMC_PMEM2_MEMSET2_1         (0x02UL << FSMC_PMEM2_MEMSET2_Pos)         /*!< 0x00000002 */
N#define FSMC_PMEM2_MEMSET2_2         (0x04UL << FSMC_PMEM2_MEMSET2_Pos)         /*!< 0x00000004 */
N#define FSMC_PMEM2_MEMSET2_3         (0x08UL << FSMC_PMEM2_MEMSET2_Pos)         /*!< 0x00000008 */
N#define FSMC_PMEM2_MEMSET2_4         (0x10UL << FSMC_PMEM2_MEMSET2_Pos)         /*!< 0x00000010 */
N#define FSMC_PMEM2_MEMSET2_5         (0x20UL << FSMC_PMEM2_MEMSET2_Pos)         /*!< 0x00000020 */
N#define FSMC_PMEM2_MEMSET2_6         (0x40UL << FSMC_PMEM2_MEMSET2_Pos)         /*!< 0x00000040 */
N#define FSMC_PMEM2_MEMSET2_7         (0x80UL << FSMC_PMEM2_MEMSET2_Pos)         /*!< 0x00000080 */
N
N#define FSMC_PMEM2_MEMWAIT2_Pos      (8U)                                      
N#define FSMC_PMEM2_MEMWAIT2_Msk      (0xFFUL << FSMC_PMEM2_MEMWAIT2_Pos)        /*!< 0x0000FF00 */
N#define FSMC_PMEM2_MEMWAIT2          FSMC_PMEM2_MEMWAIT2_Msk                   /*!<MEMWAIT2[7:0] bits (Common memory 2 wait time) */
N#define FSMC_PMEM2_MEMWAIT2_0        (0x01UL << FSMC_PMEM2_MEMWAIT2_Pos)        /*!< 0x00000100 */
N#define FSMC_PMEM2_MEMWAIT2_1        (0x02UL << FSMC_PMEM2_MEMWAIT2_Pos)        /*!< 0x00000200 */
N#define FSMC_PMEM2_MEMWAIT2_2        (0x04UL << FSMC_PMEM2_MEMWAIT2_Pos)        /*!< 0x00000400 */
N#define FSMC_PMEM2_MEMWAIT2_3        (0x08UL << FSMC_PMEM2_MEMWAIT2_Pos)        /*!< 0x00000800 */
N#define FSMC_PMEM2_MEMWAIT2_4        (0x10UL << FSMC_PMEM2_MEMWAIT2_Pos)        /*!< 0x00001000 */
N#define FSMC_PMEM2_MEMWAIT2_5        (0x20UL << FSMC_PMEM2_MEMWAIT2_Pos)        /*!< 0x00002000 */
N#define FSMC_PMEM2_MEMWAIT2_6        (0x40UL << FSMC_PMEM2_MEMWAIT2_Pos)        /*!< 0x00004000 */
N#define FSMC_PMEM2_MEMWAIT2_7        (0x80UL << FSMC_PMEM2_MEMWAIT2_Pos)        /*!< 0x00008000 */
N
N#define FSMC_PMEM2_MEMHOLD2_Pos      (16U)                                     
N#define FSMC_PMEM2_MEMHOLD2_Msk      (0xFFUL << FSMC_PMEM2_MEMHOLD2_Pos)        /*!< 0x00FF0000 */
N#define FSMC_PMEM2_MEMHOLD2          FSMC_PMEM2_MEMHOLD2_Msk                   /*!<MEMHOLD2[7:0] bits (Common memory 2 hold time) */
N#define FSMC_PMEM2_MEMHOLD2_0        (0x01UL << FSMC_PMEM2_MEMHOLD2_Pos)        /*!< 0x00010000 */
N#define FSMC_PMEM2_MEMHOLD2_1        (0x02UL << FSMC_PMEM2_MEMHOLD2_Pos)        /*!< 0x00020000 */
N#define FSMC_PMEM2_MEMHOLD2_2        (0x04UL << FSMC_PMEM2_MEMHOLD2_Pos)        /*!< 0x00040000 */
N#define FSMC_PMEM2_MEMHOLD2_3        (0x08UL << FSMC_PMEM2_MEMHOLD2_Pos)        /*!< 0x00080000 */
N#define FSMC_PMEM2_MEMHOLD2_4        (0x10UL << FSMC_PMEM2_MEMHOLD2_Pos)        /*!< 0x00100000 */
N#define FSMC_PMEM2_MEMHOLD2_5        (0x20UL << FSMC_PMEM2_MEMHOLD2_Pos)        /*!< 0x00200000 */
N#define FSMC_PMEM2_MEMHOLD2_6        (0x40UL << FSMC_PMEM2_MEMHOLD2_Pos)        /*!< 0x00400000 */
N#define FSMC_PMEM2_MEMHOLD2_7        (0x80UL << FSMC_PMEM2_MEMHOLD2_Pos)        /*!< 0x00800000 */
N
N#define FSMC_PMEM2_MEMHIZ2_Pos       (24U)                                     
N#define FSMC_PMEM2_MEMHIZ2_Msk       (0xFFUL << FSMC_PMEM2_MEMHIZ2_Pos)         /*!< 0xFF000000 */
N#define FSMC_PMEM2_MEMHIZ2           FSMC_PMEM2_MEMHIZ2_Msk                    /*!<MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
N#define FSMC_PMEM2_MEMHIZ2_0         (0x01UL << FSMC_PMEM2_MEMHIZ2_Pos)         /*!< 0x01000000 */
N#define FSMC_PMEM2_MEMHIZ2_1         (0x02UL << FSMC_PMEM2_MEMHIZ2_Pos)         /*!< 0x02000000 */
N#define FSMC_PMEM2_MEMHIZ2_2         (0x04UL << FSMC_PMEM2_MEMHIZ2_Pos)         /*!< 0x04000000 */
N#define FSMC_PMEM2_MEMHIZ2_3         (0x08UL << FSMC_PMEM2_MEMHIZ2_Pos)         /*!< 0x08000000 */
N#define FSMC_PMEM2_MEMHIZ2_4         (0x10UL << FSMC_PMEM2_MEMHIZ2_Pos)         /*!< 0x10000000 */
N#define FSMC_PMEM2_MEMHIZ2_5         (0x20UL << FSMC_PMEM2_MEMHIZ2_Pos)         /*!< 0x20000000 */
N#define FSMC_PMEM2_MEMHIZ2_6         (0x40UL << FSMC_PMEM2_MEMHIZ2_Pos)         /*!< 0x40000000 */
N#define FSMC_PMEM2_MEMHIZ2_7         (0x80UL << FSMC_PMEM2_MEMHIZ2_Pos)         /*!< 0x80000000 */
N
N/******************  Bit definition for FSMC_PMEM3 register  ******************/
N#define FSMC_PMEM3_MEMSET3_Pos       (0U)                                      
N#define FSMC_PMEM3_MEMSET3_Msk       (0xFFUL << FSMC_PMEM3_MEMSET3_Pos)         /*!< 0x000000FF */
N#define FSMC_PMEM3_MEMSET3           FSMC_PMEM3_MEMSET3_Msk                    /*!<MEMSET3[7:0] bits (Common memory 3 setup time) */
N#define FSMC_PMEM3_MEMSET3_0         (0x01UL << FSMC_PMEM3_MEMSET3_Pos)         /*!< 0x00000001 */
N#define FSMC_PMEM3_MEMSET3_1         (0x02UL << FSMC_PMEM3_MEMSET3_Pos)         /*!< 0x00000002 */
N#define FSMC_PMEM3_MEMSET3_2         (0x04UL << FSMC_PMEM3_MEMSET3_Pos)         /*!< 0x00000004 */
N#define FSMC_PMEM3_MEMSET3_3         (0x08UL << FSMC_PMEM3_MEMSET3_Pos)         /*!< 0x00000008 */
N#define FSMC_PMEM3_MEMSET3_4         (0x10UL << FSMC_PMEM3_MEMSET3_Pos)         /*!< 0x00000010 */
N#define FSMC_PMEM3_MEMSET3_5         (0x20UL << FSMC_PMEM3_MEMSET3_Pos)         /*!< 0x00000020 */
N#define FSMC_PMEM3_MEMSET3_6         (0x40UL << FSMC_PMEM3_MEMSET3_Pos)         /*!< 0x00000040 */
N#define FSMC_PMEM3_MEMSET3_7         (0x80UL << FSMC_PMEM3_MEMSET3_Pos)         /*!< 0x00000080 */
N
N#define FSMC_PMEM3_MEMWAIT3_Pos      (8U)                                      
N#define FSMC_PMEM3_MEMWAIT3_Msk      (0xFFUL << FSMC_PMEM3_MEMWAIT3_Pos)        /*!< 0x0000FF00 */
N#define FSMC_PMEM3_MEMWAIT3          FSMC_PMEM3_MEMWAIT3_Msk                   /*!<MEMWAIT3[7:0] bits (Common memory 3 wait time) */
N#define FSMC_PMEM3_MEMWAIT3_0        (0x01UL << FSMC_PMEM3_MEMWAIT3_Pos)        /*!< 0x00000100 */
N#define FSMC_PMEM3_MEMWAIT3_1        (0x02UL << FSMC_PMEM3_MEMWAIT3_Pos)        /*!< 0x00000200 */
N#define FSMC_PMEM3_MEMWAIT3_2        (0x04UL << FSMC_PMEM3_MEMWAIT3_Pos)        /*!< 0x00000400 */
N#define FSMC_PMEM3_MEMWAIT3_3        (0x08UL << FSMC_PMEM3_MEMWAIT3_Pos)        /*!< 0x00000800 */
N#define FSMC_PMEM3_MEMWAIT3_4        (0x10UL << FSMC_PMEM3_MEMWAIT3_Pos)        /*!< 0x00001000 */
N#define FSMC_PMEM3_MEMWAIT3_5        (0x20UL << FSMC_PMEM3_MEMWAIT3_Pos)        /*!< 0x00002000 */
N#define FSMC_PMEM3_MEMWAIT3_6        (0x40UL << FSMC_PMEM3_MEMWAIT3_Pos)        /*!< 0x00004000 */
N#define FSMC_PMEM3_MEMWAIT3_7        (0x80UL << FSMC_PMEM3_MEMWAIT3_Pos)        /*!< 0x00008000 */
N
N#define FSMC_PMEM3_MEMHOLD3_Pos      (16U)                                     
N#define FSMC_PMEM3_MEMHOLD3_Msk      (0xFFUL << FSMC_PMEM3_MEMHOLD3_Pos)        /*!< 0x00FF0000 */
N#define FSMC_PMEM3_MEMHOLD3          FSMC_PMEM3_MEMHOLD3_Msk                   /*!<MEMHOLD3[7:0] bits (Common memory 3 hold time) */
N#define FSMC_PMEM3_MEMHOLD3_0        (0x01UL << FSMC_PMEM3_MEMHOLD3_Pos)        /*!< 0x00010000 */
N#define FSMC_PMEM3_MEMHOLD3_1        (0x02UL << FSMC_PMEM3_MEMHOLD3_Pos)        /*!< 0x00020000 */
N#define FSMC_PMEM3_MEMHOLD3_2        (0x04UL << FSMC_PMEM3_MEMHOLD3_Pos)        /*!< 0x00040000 */
N#define FSMC_PMEM3_MEMHOLD3_3        (0x08UL << FSMC_PMEM3_MEMHOLD3_Pos)        /*!< 0x00080000 */
N#define FSMC_PMEM3_MEMHOLD3_4        (0x10UL << FSMC_PMEM3_MEMHOLD3_Pos)        /*!< 0x00100000 */
N#define FSMC_PMEM3_MEMHOLD3_5        (0x20UL << FSMC_PMEM3_MEMHOLD3_Pos)        /*!< 0x00200000 */
N#define FSMC_PMEM3_MEMHOLD3_6        (0x40UL << FSMC_PMEM3_MEMHOLD3_Pos)        /*!< 0x00400000 */
N#define FSMC_PMEM3_MEMHOLD3_7        (0x80UL << FSMC_PMEM3_MEMHOLD3_Pos)        /*!< 0x00800000 */
N
N#define FSMC_PMEM3_MEMHIZ3_Pos       (24U)                                     
N#define FSMC_PMEM3_MEMHIZ3_Msk       (0xFFUL << FSMC_PMEM3_MEMHIZ3_Pos)         /*!< 0xFF000000 */
N#define FSMC_PMEM3_MEMHIZ3           FSMC_PMEM3_MEMHIZ3_Msk                    /*!<MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
N#define FSMC_PMEM3_MEMHIZ3_0         (0x01UL << FSMC_PMEM3_MEMHIZ3_Pos)         /*!< 0x01000000 */
N#define FSMC_PMEM3_MEMHIZ3_1         (0x02UL << FSMC_PMEM3_MEMHIZ3_Pos)         /*!< 0x02000000 */
N#define FSMC_PMEM3_MEMHIZ3_2         (0x04UL << FSMC_PMEM3_MEMHIZ3_Pos)         /*!< 0x04000000 */
N#define FSMC_PMEM3_MEMHIZ3_3         (0x08UL << FSMC_PMEM3_MEMHIZ3_Pos)         /*!< 0x08000000 */
N#define FSMC_PMEM3_MEMHIZ3_4         (0x10UL << FSMC_PMEM3_MEMHIZ3_Pos)         /*!< 0x10000000 */
N#define FSMC_PMEM3_MEMHIZ3_5         (0x20UL << FSMC_PMEM3_MEMHIZ3_Pos)         /*!< 0x20000000 */
N#define FSMC_PMEM3_MEMHIZ3_6         (0x40UL << FSMC_PMEM3_MEMHIZ3_Pos)         /*!< 0x40000000 */
N#define FSMC_PMEM3_MEMHIZ3_7         (0x80UL << FSMC_PMEM3_MEMHIZ3_Pos)         /*!< 0x80000000 */
N
N/******************  Bit definition for FSMC_PMEM4 register  ******************/
N#define FSMC_PMEM4_MEMSET4_Pos       (0U)                                      
N#define FSMC_PMEM4_MEMSET4_Msk       (0xFFUL << FSMC_PMEM4_MEMSET4_Pos)         /*!< 0x000000FF */
N#define FSMC_PMEM4_MEMSET4           FSMC_PMEM4_MEMSET4_Msk                    /*!<MEMSET4[7:0] bits (Common memory 4 setup time) */
N#define FSMC_PMEM4_MEMSET4_0         (0x01UL << FSMC_PMEM4_MEMSET4_Pos)         /*!< 0x00000001 */
N#define FSMC_PMEM4_MEMSET4_1         (0x02UL << FSMC_PMEM4_MEMSET4_Pos)         /*!< 0x00000002 */
N#define FSMC_PMEM4_MEMSET4_2         (0x04UL << FSMC_PMEM4_MEMSET4_Pos)         /*!< 0x00000004 */
N#define FSMC_PMEM4_MEMSET4_3         (0x08UL << FSMC_PMEM4_MEMSET4_Pos)         /*!< 0x00000008 */
N#define FSMC_PMEM4_MEMSET4_4         (0x10UL << FSMC_PMEM4_MEMSET4_Pos)         /*!< 0x00000010 */
N#define FSMC_PMEM4_MEMSET4_5         (0x20UL << FSMC_PMEM4_MEMSET4_Pos)         /*!< 0x00000020 */
N#define FSMC_PMEM4_MEMSET4_6         (0x40UL << FSMC_PMEM4_MEMSET4_Pos)         /*!< 0x00000040 */
N#define FSMC_PMEM4_MEMSET4_7         (0x80UL << FSMC_PMEM4_MEMSET4_Pos)         /*!< 0x00000080 */
N
N#define FSMC_PMEM4_MEMWAIT4_Pos      (8U)                                      
N#define FSMC_PMEM4_MEMWAIT4_Msk      (0xFFUL << FSMC_PMEM4_MEMWAIT4_Pos)        /*!< 0x0000FF00 */
N#define FSMC_PMEM4_MEMWAIT4          FSMC_PMEM4_MEMWAIT4_Msk                   /*!<MEMWAIT4[7:0] bits (Common memory 4 wait time) */
N#define FSMC_PMEM4_MEMWAIT4_0        (0x01UL << FSMC_PMEM4_MEMWAIT4_Pos)        /*!< 0x00000100 */
N#define FSMC_PMEM4_MEMWAIT4_1        (0x02UL << FSMC_PMEM4_MEMWAIT4_Pos)        /*!< 0x00000200 */
N#define FSMC_PMEM4_MEMWAIT4_2        (0x04UL << FSMC_PMEM4_MEMWAIT4_Pos)        /*!< 0x00000400 */
N#define FSMC_PMEM4_MEMWAIT4_3        (0x08UL << FSMC_PMEM4_MEMWAIT4_Pos)        /*!< 0x00000800 */
N#define FSMC_PMEM4_MEMWAIT4_4        (0x10UL << FSMC_PMEM4_MEMWAIT4_Pos)        /*!< 0x00001000 */
N#define FSMC_PMEM4_MEMWAIT4_5        (0x20UL << FSMC_PMEM4_MEMWAIT4_Pos)        /*!< 0x00002000 */
N#define FSMC_PMEM4_MEMWAIT4_6        (0x40UL << FSMC_PMEM4_MEMWAIT4_Pos)        /*!< 0x00004000 */
N#define FSMC_PMEM4_MEMWAIT4_7        (0x80UL << FSMC_PMEM4_MEMWAIT4_Pos)        /*!< 0x00008000 */
N
N#define FSMC_PMEM4_MEMHOLD4_Pos      (16U)                                     
N#define FSMC_PMEM4_MEMHOLD4_Msk      (0xFFUL << FSMC_PMEM4_MEMHOLD4_Pos)        /*!< 0x00FF0000 */
N#define FSMC_PMEM4_MEMHOLD4          FSMC_PMEM4_MEMHOLD4_Msk                   /*!<MEMHOLD4[7:0] bits (Common memory 4 hold time) */
N#define FSMC_PMEM4_MEMHOLD4_0        (0x01UL << FSMC_PMEM4_MEMHOLD4_Pos)        /*!< 0x00010000 */
N#define FSMC_PMEM4_MEMHOLD4_1        (0x02UL << FSMC_PMEM4_MEMHOLD4_Pos)        /*!< 0x00020000 */
N#define FSMC_PMEM4_MEMHOLD4_2        (0x04UL << FSMC_PMEM4_MEMHOLD4_Pos)        /*!< 0x00040000 */
N#define FSMC_PMEM4_MEMHOLD4_3        (0x08UL << FSMC_PMEM4_MEMHOLD4_Pos)        /*!< 0x00080000 */
N#define FSMC_PMEM4_MEMHOLD4_4        (0x10UL << FSMC_PMEM4_MEMHOLD4_Pos)        /*!< 0x00100000 */
N#define FSMC_PMEM4_MEMHOLD4_5        (0x20UL << FSMC_PMEM4_MEMHOLD4_Pos)        /*!< 0x00200000 */
N#define FSMC_PMEM4_MEMHOLD4_6        (0x40UL << FSMC_PMEM4_MEMHOLD4_Pos)        /*!< 0x00400000 */
N#define FSMC_PMEM4_MEMHOLD4_7        (0x80UL << FSMC_PMEM4_MEMHOLD4_Pos)        /*!< 0x00800000 */
N
N#define FSMC_PMEM4_MEMHIZ4_Pos       (24U)                                     
N#define FSMC_PMEM4_MEMHIZ4_Msk       (0xFFUL << FSMC_PMEM4_MEMHIZ4_Pos)         /*!< 0xFF000000 */
N#define FSMC_PMEM4_MEMHIZ4           FSMC_PMEM4_MEMHIZ4_Msk                    /*!<MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
N#define FSMC_PMEM4_MEMHIZ4_0         (0x01UL << FSMC_PMEM4_MEMHIZ4_Pos)         /*!< 0x01000000 */
N#define FSMC_PMEM4_MEMHIZ4_1         (0x02UL << FSMC_PMEM4_MEMHIZ4_Pos)         /*!< 0x02000000 */
N#define FSMC_PMEM4_MEMHIZ4_2         (0x04UL << FSMC_PMEM4_MEMHIZ4_Pos)         /*!< 0x04000000 */
N#define FSMC_PMEM4_MEMHIZ4_3         (0x08UL << FSMC_PMEM4_MEMHIZ4_Pos)         /*!< 0x08000000 */
N#define FSMC_PMEM4_MEMHIZ4_4         (0x10UL << FSMC_PMEM4_MEMHIZ4_Pos)         /*!< 0x10000000 */
N#define FSMC_PMEM4_MEMHIZ4_5         (0x20UL << FSMC_PMEM4_MEMHIZ4_Pos)         /*!< 0x20000000 */
N#define FSMC_PMEM4_MEMHIZ4_6         (0x40UL << FSMC_PMEM4_MEMHIZ4_Pos)         /*!< 0x40000000 */
N#define FSMC_PMEM4_MEMHIZ4_7         (0x80UL << FSMC_PMEM4_MEMHIZ4_Pos)         /*!< 0x80000000 */
N
N/******************  Bit definition for FSMC_PATT2 register  ******************/
N#define FSMC_PATT2_ATTSET2_Pos       (0U)                                      
N#define FSMC_PATT2_ATTSET2_Msk       (0xFFUL << FSMC_PATT2_ATTSET2_Pos)         /*!< 0x000000FF */
N#define FSMC_PATT2_ATTSET2           FSMC_PATT2_ATTSET2_Msk                    /*!<ATTSET2[7:0] bits (Attribute memory 2 setup time) */
N#define FSMC_PATT2_ATTSET2_0         (0x01UL << FSMC_PATT2_ATTSET2_Pos)         /*!< 0x00000001 */
N#define FSMC_PATT2_ATTSET2_1         (0x02UL << FSMC_PATT2_ATTSET2_Pos)         /*!< 0x00000002 */
N#define FSMC_PATT2_ATTSET2_2         (0x04UL << FSMC_PATT2_ATTSET2_Pos)         /*!< 0x00000004 */
N#define FSMC_PATT2_ATTSET2_3         (0x08UL << FSMC_PATT2_ATTSET2_Pos)         /*!< 0x00000008 */
N#define FSMC_PATT2_ATTSET2_4         (0x10UL << FSMC_PATT2_ATTSET2_Pos)         /*!< 0x00000010 */
N#define FSMC_PATT2_ATTSET2_5         (0x20UL << FSMC_PATT2_ATTSET2_Pos)         /*!< 0x00000020 */
N#define FSMC_PATT2_ATTSET2_6         (0x40UL << FSMC_PATT2_ATTSET2_Pos)         /*!< 0x00000040 */
N#define FSMC_PATT2_ATTSET2_7         (0x80UL << FSMC_PATT2_ATTSET2_Pos)         /*!< 0x00000080 */
N
N#define FSMC_PATT2_ATTWAIT2_Pos      (8U)                                      
N#define FSMC_PATT2_ATTWAIT2_Msk      (0xFFUL << FSMC_PATT2_ATTWAIT2_Pos)        /*!< 0x0000FF00 */
N#define FSMC_PATT2_ATTWAIT2          FSMC_PATT2_ATTWAIT2_Msk                   /*!<ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
N#define FSMC_PATT2_ATTWAIT2_0        (0x01UL << FSMC_PATT2_ATTWAIT2_Pos)        /*!< 0x00000100 */
N#define FSMC_PATT2_ATTWAIT2_1        (0x02UL << FSMC_PATT2_ATTWAIT2_Pos)        /*!< 0x00000200 */
N#define FSMC_PATT2_ATTWAIT2_2        (0x04UL << FSMC_PATT2_ATTWAIT2_Pos)        /*!< 0x00000400 */
N#define FSMC_PATT2_ATTWAIT2_3        (0x08UL << FSMC_PATT2_ATTWAIT2_Pos)        /*!< 0x00000800 */
N#define FSMC_PATT2_ATTWAIT2_4        (0x10UL << FSMC_PATT2_ATTWAIT2_Pos)        /*!< 0x00001000 */
N#define FSMC_PATT2_ATTWAIT2_5        (0x20UL << FSMC_PATT2_ATTWAIT2_Pos)        /*!< 0x00002000 */
N#define FSMC_PATT2_ATTWAIT2_6        (0x40UL << FSMC_PATT2_ATTWAIT2_Pos)        /*!< 0x00004000 */
N#define FSMC_PATT2_ATTWAIT2_7        (0x80UL << FSMC_PATT2_ATTWAIT2_Pos)        /*!< 0x00008000 */
N
N#define FSMC_PATT2_ATTHOLD2_Pos      (16U)                                     
N#define FSMC_PATT2_ATTHOLD2_Msk      (0xFFUL << FSMC_PATT2_ATTHOLD2_Pos)        /*!< 0x00FF0000 */
N#define FSMC_PATT2_ATTHOLD2          FSMC_PATT2_ATTHOLD2_Msk                   /*!<ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
N#define FSMC_PATT2_ATTHOLD2_0        (0x01UL << FSMC_PATT2_ATTHOLD2_Pos)        /*!< 0x00010000 */
N#define FSMC_PATT2_ATTHOLD2_1        (0x02UL << FSMC_PATT2_ATTHOLD2_Pos)        /*!< 0x00020000 */
N#define FSMC_PATT2_ATTHOLD2_2        (0x04UL << FSMC_PATT2_ATTHOLD2_Pos)        /*!< 0x00040000 */
N#define FSMC_PATT2_ATTHOLD2_3        (0x08UL << FSMC_PATT2_ATTHOLD2_Pos)        /*!< 0x00080000 */
N#define FSMC_PATT2_ATTHOLD2_4        (0x10UL << FSMC_PATT2_ATTHOLD2_Pos)        /*!< 0x00100000 */
N#define FSMC_PATT2_ATTHOLD2_5        (0x20UL << FSMC_PATT2_ATTHOLD2_Pos)        /*!< 0x00200000 */
N#define FSMC_PATT2_ATTHOLD2_6        (0x40UL << FSMC_PATT2_ATTHOLD2_Pos)        /*!< 0x00400000 */
N#define FSMC_PATT2_ATTHOLD2_7        (0x80UL << FSMC_PATT2_ATTHOLD2_Pos)        /*!< 0x00800000 */
N
N#define FSMC_PATT2_ATTHIZ2_Pos       (24U)                                     
N#define FSMC_PATT2_ATTHIZ2_Msk       (0xFFUL << FSMC_PATT2_ATTHIZ2_Pos)         /*!< 0xFF000000 */
N#define FSMC_PATT2_ATTHIZ2           FSMC_PATT2_ATTHIZ2_Msk                    /*!<ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
N#define FSMC_PATT2_ATTHIZ2_0         (0x01UL << FSMC_PATT2_ATTHIZ2_Pos)         /*!< 0x01000000 */
N#define FSMC_PATT2_ATTHIZ2_1         (0x02UL << FSMC_PATT2_ATTHIZ2_Pos)         /*!< 0x02000000 */
N#define FSMC_PATT2_ATTHIZ2_2         (0x04UL << FSMC_PATT2_ATTHIZ2_Pos)         /*!< 0x04000000 */
N#define FSMC_PATT2_ATTHIZ2_3         (0x08UL << FSMC_PATT2_ATTHIZ2_Pos)         /*!< 0x08000000 */
N#define FSMC_PATT2_ATTHIZ2_4         (0x10UL << FSMC_PATT2_ATTHIZ2_Pos)         /*!< 0x10000000 */
N#define FSMC_PATT2_ATTHIZ2_5         (0x20UL << FSMC_PATT2_ATTHIZ2_Pos)         /*!< 0x20000000 */
N#define FSMC_PATT2_ATTHIZ2_6         (0x40UL << FSMC_PATT2_ATTHIZ2_Pos)         /*!< 0x40000000 */
N#define FSMC_PATT2_ATTHIZ2_7         (0x80UL << FSMC_PATT2_ATTHIZ2_Pos)         /*!< 0x80000000 */
N
N/******************  Bit definition for FSMC_PATT3 register  ******************/
N#define FSMC_PATT3_ATTSET3_Pos       (0U)                                      
N#define FSMC_PATT3_ATTSET3_Msk       (0xFFUL << FSMC_PATT3_ATTSET3_Pos)         /*!< 0x000000FF */
N#define FSMC_PATT3_ATTSET3           FSMC_PATT3_ATTSET3_Msk                    /*!<ATTSET3[7:0] bits (Attribute memory 3 setup time) */
N#define FSMC_PATT3_ATTSET3_0         (0x01UL << FSMC_PATT3_ATTSET3_Pos)         /*!< 0x00000001 */
N#define FSMC_PATT3_ATTSET3_1         (0x02UL << FSMC_PATT3_ATTSET3_Pos)         /*!< 0x00000002 */
N#define FSMC_PATT3_ATTSET3_2         (0x04UL << FSMC_PATT3_ATTSET3_Pos)         /*!< 0x00000004 */
N#define FSMC_PATT3_ATTSET3_3         (0x08UL << FSMC_PATT3_ATTSET3_Pos)         /*!< 0x00000008 */
N#define FSMC_PATT3_ATTSET3_4         (0x10UL << FSMC_PATT3_ATTSET3_Pos)         /*!< 0x00000010 */
N#define FSMC_PATT3_ATTSET3_5         (0x20UL << FSMC_PATT3_ATTSET3_Pos)         /*!< 0x00000020 */
N#define FSMC_PATT3_ATTSET3_6         (0x40UL << FSMC_PATT3_ATTSET3_Pos)         /*!< 0x00000040 */
N#define FSMC_PATT3_ATTSET3_7         (0x80UL << FSMC_PATT3_ATTSET3_Pos)         /*!< 0x00000080 */
N
N#define FSMC_PATT3_ATTWAIT3_Pos      (8U)                                      
N#define FSMC_PATT3_ATTWAIT3_Msk      (0xFFUL << FSMC_PATT3_ATTWAIT3_Pos)        /*!< 0x0000FF00 */
N#define FSMC_PATT3_ATTWAIT3          FSMC_PATT3_ATTWAIT3_Msk                   /*!<ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
N#define FSMC_PATT3_ATTWAIT3_0        (0x01UL << FSMC_PATT3_ATTWAIT3_Pos)        /*!< 0x00000100 */
N#define FSMC_PATT3_ATTWAIT3_1        (0x02UL << FSMC_PATT3_ATTWAIT3_Pos)        /*!< 0x00000200 */
N#define FSMC_PATT3_ATTWAIT3_2        (0x04UL << FSMC_PATT3_ATTWAIT3_Pos)        /*!< 0x00000400 */
N#define FSMC_PATT3_ATTWAIT3_3        (0x08UL << FSMC_PATT3_ATTWAIT3_Pos)        /*!< 0x00000800 */
N#define FSMC_PATT3_ATTWAIT3_4        (0x10UL << FSMC_PATT3_ATTWAIT3_Pos)        /*!< 0x00001000 */
N#define FSMC_PATT3_ATTWAIT3_5        (0x20UL << FSMC_PATT3_ATTWAIT3_Pos)        /*!< 0x00002000 */
N#define FSMC_PATT3_ATTWAIT3_6        (0x40UL << FSMC_PATT3_ATTWAIT3_Pos)        /*!< 0x00004000 */
N#define FSMC_PATT3_ATTWAIT3_7        (0x80UL << FSMC_PATT3_ATTWAIT3_Pos)        /*!< 0x00008000 */
N
N#define FSMC_PATT3_ATTHOLD3_Pos      (16U)                                     
N#define FSMC_PATT3_ATTHOLD3_Msk      (0xFFUL << FSMC_PATT3_ATTHOLD3_Pos)        /*!< 0x00FF0000 */
N#define FSMC_PATT3_ATTHOLD3          FSMC_PATT3_ATTHOLD3_Msk                   /*!<ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
N#define FSMC_PATT3_ATTHOLD3_0        (0x01UL << FSMC_PATT3_ATTHOLD3_Pos)        /*!< 0x00010000 */
N#define FSMC_PATT3_ATTHOLD3_1        (0x02UL << FSMC_PATT3_ATTHOLD3_Pos)        /*!< 0x00020000 */
N#define FSMC_PATT3_ATTHOLD3_2        (0x04UL << FSMC_PATT3_ATTHOLD3_Pos)        /*!< 0x00040000 */
N#define FSMC_PATT3_ATTHOLD3_3        (0x08UL << FSMC_PATT3_ATTHOLD3_Pos)        /*!< 0x00080000 */
N#define FSMC_PATT3_ATTHOLD3_4        (0x10UL << FSMC_PATT3_ATTHOLD3_Pos)        /*!< 0x00100000 */
N#define FSMC_PATT3_ATTHOLD3_5        (0x20UL << FSMC_PATT3_ATTHOLD3_Pos)        /*!< 0x00200000 */
N#define FSMC_PATT3_ATTHOLD3_6        (0x40UL << FSMC_PATT3_ATTHOLD3_Pos)        /*!< 0x00400000 */
N#define FSMC_PATT3_ATTHOLD3_7        (0x80UL << FSMC_PATT3_ATTHOLD3_Pos)        /*!< 0x00800000 */
N
N#define FSMC_PATT3_ATTHIZ3_Pos       (24U)                                     
N#define FSMC_PATT3_ATTHIZ3_Msk       (0xFFUL << FSMC_PATT3_ATTHIZ3_Pos)         /*!< 0xFF000000 */
N#define FSMC_PATT3_ATTHIZ3           FSMC_PATT3_ATTHIZ3_Msk                    /*!<ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
N#define FSMC_PATT3_ATTHIZ3_0         (0x01UL << FSMC_PATT3_ATTHIZ3_Pos)         /*!< 0x01000000 */
N#define FSMC_PATT3_ATTHIZ3_1         (0x02UL << FSMC_PATT3_ATTHIZ3_Pos)         /*!< 0x02000000 */
N#define FSMC_PATT3_ATTHIZ3_2         (0x04UL << FSMC_PATT3_ATTHIZ3_Pos)         /*!< 0x04000000 */
N#define FSMC_PATT3_ATTHIZ3_3         (0x08UL << FSMC_PATT3_ATTHIZ3_Pos)         /*!< 0x08000000 */
N#define FSMC_PATT3_ATTHIZ3_4         (0x10UL << FSMC_PATT3_ATTHIZ3_Pos)         /*!< 0x10000000 */
N#define FSMC_PATT3_ATTHIZ3_5         (0x20UL << FSMC_PATT3_ATTHIZ3_Pos)         /*!< 0x20000000 */
N#define FSMC_PATT3_ATTHIZ3_6         (0x40UL << FSMC_PATT3_ATTHIZ3_Pos)         /*!< 0x40000000 */
N#define FSMC_PATT3_ATTHIZ3_7         (0x80UL << FSMC_PATT3_ATTHIZ3_Pos)         /*!< 0x80000000 */
N
N/******************  Bit definition for FSMC_PATT4 register  ******************/
N#define FSMC_PATT4_ATTSET4_Pos       (0U)                                      
N#define FSMC_PATT4_ATTSET4_Msk       (0xFFUL << FSMC_PATT4_ATTSET4_Pos)         /*!< 0x000000FF */
N#define FSMC_PATT4_ATTSET4           FSMC_PATT4_ATTSET4_Msk                    /*!<ATTSET4[7:0] bits (Attribute memory 4 setup time) */
N#define FSMC_PATT4_ATTSET4_0         (0x01UL << FSMC_PATT4_ATTSET4_Pos)         /*!< 0x00000001 */
N#define FSMC_PATT4_ATTSET4_1         (0x02UL << FSMC_PATT4_ATTSET4_Pos)         /*!< 0x00000002 */
N#define FSMC_PATT4_ATTSET4_2         (0x04UL << FSMC_PATT4_ATTSET4_Pos)         /*!< 0x00000004 */
N#define FSMC_PATT4_ATTSET4_3         (0x08UL << FSMC_PATT4_ATTSET4_Pos)         /*!< 0x00000008 */
N#define FSMC_PATT4_ATTSET4_4         (0x10UL << FSMC_PATT4_ATTSET4_Pos)         /*!< 0x00000010 */
N#define FSMC_PATT4_ATTSET4_5         (0x20UL << FSMC_PATT4_ATTSET4_Pos)         /*!< 0x00000020 */
N#define FSMC_PATT4_ATTSET4_6         (0x40UL << FSMC_PATT4_ATTSET4_Pos)         /*!< 0x00000040 */
N#define FSMC_PATT4_ATTSET4_7         (0x80UL << FSMC_PATT4_ATTSET4_Pos)         /*!< 0x00000080 */
N
N#define FSMC_PATT4_ATTWAIT4_Pos      (8U)                                      
N#define FSMC_PATT4_ATTWAIT4_Msk      (0xFFUL << FSMC_PATT4_ATTWAIT4_Pos)        /*!< 0x0000FF00 */
N#define FSMC_PATT4_ATTWAIT4          FSMC_PATT4_ATTWAIT4_Msk                   /*!<ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
N#define FSMC_PATT4_ATTWAIT4_0        (0x01UL << FSMC_PATT4_ATTWAIT4_Pos)        /*!< 0x00000100 */
N#define FSMC_PATT4_ATTWAIT4_1        (0x02UL << FSMC_PATT4_ATTWAIT4_Pos)        /*!< 0x00000200 */
N#define FSMC_PATT4_ATTWAIT4_2        (0x04UL << FSMC_PATT4_ATTWAIT4_Pos)        /*!< 0x00000400 */
N#define FSMC_PATT4_ATTWAIT4_3        (0x08UL << FSMC_PATT4_ATTWAIT4_Pos)        /*!< 0x00000800 */
N#define FSMC_PATT4_ATTWAIT4_4        (0x10UL << FSMC_PATT4_ATTWAIT4_Pos)        /*!< 0x00001000 */
N#define FSMC_PATT4_ATTWAIT4_5        (0x20UL << FSMC_PATT4_ATTWAIT4_Pos)        /*!< 0x00002000 */
N#define FSMC_PATT4_ATTWAIT4_6        (0x40UL << FSMC_PATT4_ATTWAIT4_Pos)        /*!< 0x00004000 */
N#define FSMC_PATT4_ATTWAIT4_7        (0x80UL << FSMC_PATT4_ATTWAIT4_Pos)        /*!< 0x00008000 */
N
N#define FSMC_PATT4_ATTHOLD4_Pos      (16U)                                     
N#define FSMC_PATT4_ATTHOLD4_Msk      (0xFFUL << FSMC_PATT4_ATTHOLD4_Pos)        /*!< 0x00FF0000 */
N#define FSMC_PATT4_ATTHOLD4          FSMC_PATT4_ATTHOLD4_Msk                   /*!<ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
N#define FSMC_PATT4_ATTHOLD4_0        (0x01UL << FSMC_PATT4_ATTHOLD4_Pos)        /*!< 0x00010000 */
N#define FSMC_PATT4_ATTHOLD4_1        (0x02UL << FSMC_PATT4_ATTHOLD4_Pos)        /*!< 0x00020000 */
N#define FSMC_PATT4_ATTHOLD4_2        (0x04UL << FSMC_PATT4_ATTHOLD4_Pos)        /*!< 0x00040000 */
N#define FSMC_PATT4_ATTHOLD4_3        (0x08UL << FSMC_PATT4_ATTHOLD4_Pos)        /*!< 0x00080000 */
N#define FSMC_PATT4_ATTHOLD4_4        (0x10UL << FSMC_PATT4_ATTHOLD4_Pos)        /*!< 0x00100000 */
N#define FSMC_PATT4_ATTHOLD4_5        (0x20UL << FSMC_PATT4_ATTHOLD4_Pos)        /*!< 0x00200000 */
N#define FSMC_PATT4_ATTHOLD4_6        (0x40UL << FSMC_PATT4_ATTHOLD4_Pos)        /*!< 0x00400000 */
N#define FSMC_PATT4_ATTHOLD4_7        (0x80UL << FSMC_PATT4_ATTHOLD4_Pos)        /*!< 0x00800000 */
N
N#define FSMC_PATT4_ATTHIZ4_Pos       (24U)                                     
N#define FSMC_PATT4_ATTHIZ4_Msk       (0xFFUL << FSMC_PATT4_ATTHIZ4_Pos)         /*!< 0xFF000000 */
N#define FSMC_PATT4_ATTHIZ4           FSMC_PATT4_ATTHIZ4_Msk                    /*!<ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
N#define FSMC_PATT4_ATTHIZ4_0         (0x01UL << FSMC_PATT4_ATTHIZ4_Pos)         /*!< 0x01000000 */
N#define FSMC_PATT4_ATTHIZ4_1         (0x02UL << FSMC_PATT4_ATTHIZ4_Pos)         /*!< 0x02000000 */
N#define FSMC_PATT4_ATTHIZ4_2         (0x04UL << FSMC_PATT4_ATTHIZ4_Pos)         /*!< 0x04000000 */
N#define FSMC_PATT4_ATTHIZ4_3         (0x08UL << FSMC_PATT4_ATTHIZ4_Pos)         /*!< 0x08000000 */
N#define FSMC_PATT4_ATTHIZ4_4         (0x10UL << FSMC_PATT4_ATTHIZ4_Pos)         /*!< 0x10000000 */
N#define FSMC_PATT4_ATTHIZ4_5         (0x20UL << FSMC_PATT4_ATTHIZ4_Pos)         /*!< 0x20000000 */
N#define FSMC_PATT4_ATTHIZ4_6         (0x40UL << FSMC_PATT4_ATTHIZ4_Pos)         /*!< 0x40000000 */
N#define FSMC_PATT4_ATTHIZ4_7         (0x80UL << FSMC_PATT4_ATTHIZ4_Pos)         /*!< 0x80000000 */
N
N/******************  Bit definition for FSMC_PIO4 register  *******************/
N#define FSMC_PIO4_IOSET4_Pos         (0U)                                      
N#define FSMC_PIO4_IOSET4_Msk         (0xFFUL << FSMC_PIO4_IOSET4_Pos)           /*!< 0x000000FF */
N#define FSMC_PIO4_IOSET4             FSMC_PIO4_IOSET4_Msk                      /*!<IOSET4[7:0] bits (I/O 4 setup time) */
N#define FSMC_PIO4_IOSET4_0           (0x01UL << FSMC_PIO4_IOSET4_Pos)           /*!< 0x00000001 */
N#define FSMC_PIO4_IOSET4_1           (0x02UL << FSMC_PIO4_IOSET4_Pos)           /*!< 0x00000002 */
N#define FSMC_PIO4_IOSET4_2           (0x04UL << FSMC_PIO4_IOSET4_Pos)           /*!< 0x00000004 */
N#define FSMC_PIO4_IOSET4_3           (0x08UL << FSMC_PIO4_IOSET4_Pos)           /*!< 0x00000008 */
N#define FSMC_PIO4_IOSET4_4           (0x10UL << FSMC_PIO4_IOSET4_Pos)           /*!< 0x00000010 */
N#define FSMC_PIO4_IOSET4_5           (0x20UL << FSMC_PIO4_IOSET4_Pos)           /*!< 0x00000020 */
N#define FSMC_PIO4_IOSET4_6           (0x40UL << FSMC_PIO4_IOSET4_Pos)           /*!< 0x00000040 */
N#define FSMC_PIO4_IOSET4_7           (0x80UL << FSMC_PIO4_IOSET4_Pos)           /*!< 0x00000080 */
N
N#define FSMC_PIO4_IOWAIT4_Pos        (8U)                                      
N#define FSMC_PIO4_IOWAIT4_Msk        (0xFFUL << FSMC_PIO4_IOWAIT4_Pos)          /*!< 0x0000FF00 */
N#define FSMC_PIO4_IOWAIT4            FSMC_PIO4_IOWAIT4_Msk                     /*!<IOWAIT4[7:0] bits (I/O 4 wait time) */
N#define FSMC_PIO4_IOWAIT4_0          (0x01UL << FSMC_PIO4_IOWAIT4_Pos)          /*!< 0x00000100 */
N#define FSMC_PIO4_IOWAIT4_1          (0x02UL << FSMC_PIO4_IOWAIT4_Pos)          /*!< 0x00000200 */
N#define FSMC_PIO4_IOWAIT4_2          (0x04UL << FSMC_PIO4_IOWAIT4_Pos)          /*!< 0x00000400 */
N#define FSMC_PIO4_IOWAIT4_3          (0x08UL << FSMC_PIO4_IOWAIT4_Pos)          /*!< 0x00000800 */
N#define FSMC_PIO4_IOWAIT4_4          (0x10UL << FSMC_PIO4_IOWAIT4_Pos)          /*!< 0x00001000 */
N#define FSMC_PIO4_IOWAIT4_5          (0x20UL << FSMC_PIO4_IOWAIT4_Pos)          /*!< 0x00002000 */
N#define FSMC_PIO4_IOWAIT4_6          (0x40UL << FSMC_PIO4_IOWAIT4_Pos)          /*!< 0x00004000 */
N#define FSMC_PIO4_IOWAIT4_7          (0x80UL << FSMC_PIO4_IOWAIT4_Pos)          /*!< 0x00008000 */
N
N#define FSMC_PIO4_IOHOLD4_Pos        (16U)                                     
N#define FSMC_PIO4_IOHOLD4_Msk        (0xFFUL << FSMC_PIO4_IOHOLD4_Pos)          /*!< 0x00FF0000 */
N#define FSMC_PIO4_IOHOLD4            FSMC_PIO4_IOHOLD4_Msk                     /*!<IOHOLD4[7:0] bits (I/O 4 hold time) */
N#define FSMC_PIO4_IOHOLD4_0          (0x01UL << FSMC_PIO4_IOHOLD4_Pos)          /*!< 0x00010000 */
N#define FSMC_PIO4_IOHOLD4_1          (0x02UL << FSMC_PIO4_IOHOLD4_Pos)          /*!< 0x00020000 */
N#define FSMC_PIO4_IOHOLD4_2          (0x04UL << FSMC_PIO4_IOHOLD4_Pos)          /*!< 0x00040000 */
N#define FSMC_PIO4_IOHOLD4_3          (0x08UL << FSMC_PIO4_IOHOLD4_Pos)          /*!< 0x00080000 */
N#define FSMC_PIO4_IOHOLD4_4          (0x10UL << FSMC_PIO4_IOHOLD4_Pos)          /*!< 0x00100000 */
N#define FSMC_PIO4_IOHOLD4_5          (0x20UL << FSMC_PIO4_IOHOLD4_Pos)          /*!< 0x00200000 */
N#define FSMC_PIO4_IOHOLD4_6          (0x40UL << FSMC_PIO4_IOHOLD4_Pos)          /*!< 0x00400000 */
N#define FSMC_PIO4_IOHOLD4_7          (0x80UL << FSMC_PIO4_IOHOLD4_Pos)          /*!< 0x00800000 */
N
N#define FSMC_PIO4_IOHIZ4_Pos         (24U)                                     
N#define FSMC_PIO4_IOHIZ4_Msk         (0xFFUL << FSMC_PIO4_IOHIZ4_Pos)           /*!< 0xFF000000 */
N#define FSMC_PIO4_IOHIZ4             FSMC_PIO4_IOHIZ4_Msk                      /*!<IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
N#define FSMC_PIO4_IOHIZ4_0           (0x01UL << FSMC_PIO4_IOHIZ4_Pos)           /*!< 0x01000000 */
N#define FSMC_PIO4_IOHIZ4_1           (0x02UL << FSMC_PIO4_IOHIZ4_Pos)           /*!< 0x02000000 */
N#define FSMC_PIO4_IOHIZ4_2           (0x04UL << FSMC_PIO4_IOHIZ4_Pos)           /*!< 0x04000000 */
N#define FSMC_PIO4_IOHIZ4_3           (0x08UL << FSMC_PIO4_IOHIZ4_Pos)           /*!< 0x08000000 */
N#define FSMC_PIO4_IOHIZ4_4           (0x10UL << FSMC_PIO4_IOHIZ4_Pos)           /*!< 0x10000000 */
N#define FSMC_PIO4_IOHIZ4_5           (0x20UL << FSMC_PIO4_IOHIZ4_Pos)           /*!< 0x20000000 */
N#define FSMC_PIO4_IOHIZ4_6           (0x40UL << FSMC_PIO4_IOHIZ4_Pos)           /*!< 0x40000000 */
N#define FSMC_PIO4_IOHIZ4_7           (0x80UL << FSMC_PIO4_IOHIZ4_Pos)           /*!< 0x80000000 */
N
N/******************  Bit definition for FSMC_ECCR2 register  ******************/
N#define FSMC_ECCR2_ECC2_Pos          (0U)                                      
N#define FSMC_ECCR2_ECC2_Msk          (0xFFFFFFFFUL << FSMC_ECCR2_ECC2_Pos)      /*!< 0xFFFFFFFF */
N#define FSMC_ECCR2_ECC2              FSMC_ECCR2_ECC2_Msk                       /*!<ECC result */
N
N/******************  Bit definition for FSMC_ECCR3 register  ******************/
N#define FSMC_ECCR3_ECC3_Pos          (0U)                                      
N#define FSMC_ECCR3_ECC3_Msk          (0xFFFFFFFFUL << FSMC_ECCR3_ECC3_Pos)      /*!< 0xFFFFFFFF */
N#define FSMC_ECCR3_ECC3              FSMC_ECCR3_ECC3_Msk                       /*!<ECC result */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            General Purpose I/O                             */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bits definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODER0_Pos            (0U)                                  
N#define GPIO_MODER_MODER0_Msk            (0x3UL << GPIO_MODER_MODER0_Pos)       /*!< 0x00000003 */
N#define GPIO_MODER_MODER0                GPIO_MODER_MODER0_Msk                 
N#define GPIO_MODER_MODER0_0              (0x1UL << GPIO_MODER_MODER0_Pos)       /*!< 0x00000001 */
N#define GPIO_MODER_MODER0_1              (0x2UL << GPIO_MODER_MODER0_Pos)       /*!< 0x00000002 */
N#define GPIO_MODER_MODER1_Pos            (2U)                                  
N#define GPIO_MODER_MODER1_Msk            (0x3UL << GPIO_MODER_MODER1_Pos)       /*!< 0x0000000C */
N#define GPIO_MODER_MODER1                GPIO_MODER_MODER1_Msk                 
N#define GPIO_MODER_MODER1_0              (0x1UL << GPIO_MODER_MODER1_Pos)       /*!< 0x00000004 */
N#define GPIO_MODER_MODER1_1              (0x2UL << GPIO_MODER_MODER1_Pos)       /*!< 0x00000008 */
N#define GPIO_MODER_MODER2_Pos            (4U)                                  
N#define GPIO_MODER_MODER2_Msk            (0x3UL << GPIO_MODER_MODER2_Pos)       /*!< 0x00000030 */
N#define GPIO_MODER_MODER2                GPIO_MODER_MODER2_Msk                 
N#define GPIO_MODER_MODER2_0              (0x1UL << GPIO_MODER_MODER2_Pos)       /*!< 0x00000010 */
N#define GPIO_MODER_MODER2_1              (0x2UL << GPIO_MODER_MODER2_Pos)       /*!< 0x00000020 */
N#define GPIO_MODER_MODER3_Pos            (6U)                                  
N#define GPIO_MODER_MODER3_Msk            (0x3UL << GPIO_MODER_MODER3_Pos)       /*!< 0x000000C0 */
N#define GPIO_MODER_MODER3                GPIO_MODER_MODER3_Msk                 
N#define GPIO_MODER_MODER3_0              (0x1UL << GPIO_MODER_MODER3_Pos)       /*!< 0x00000040 */
N#define GPIO_MODER_MODER3_1              (0x2UL << GPIO_MODER_MODER3_Pos)       /*!< 0x00000080 */
N#define GPIO_MODER_MODER4_Pos            (8U)                                  
N#define GPIO_MODER_MODER4_Msk            (0x3UL << GPIO_MODER_MODER4_Pos)       /*!< 0x00000300 */
N#define GPIO_MODER_MODER4                GPIO_MODER_MODER4_Msk                 
N#define GPIO_MODER_MODER4_0              (0x1UL << GPIO_MODER_MODER4_Pos)       /*!< 0x00000100 */
N#define GPIO_MODER_MODER4_1              (0x2UL << GPIO_MODER_MODER4_Pos)       /*!< 0x00000200 */
N#define GPIO_MODER_MODER5_Pos            (10U)                                 
N#define GPIO_MODER_MODER5_Msk            (0x3UL << GPIO_MODER_MODER5_Pos)       /*!< 0x00000C00 */
N#define GPIO_MODER_MODER5                GPIO_MODER_MODER5_Msk                 
N#define GPIO_MODER_MODER5_0              (0x1UL << GPIO_MODER_MODER5_Pos)       /*!< 0x00000400 */
N#define GPIO_MODER_MODER5_1              (0x2UL << GPIO_MODER_MODER5_Pos)       /*!< 0x00000800 */
N#define GPIO_MODER_MODER6_Pos            (12U)                                 
N#define GPIO_MODER_MODER6_Msk            (0x3UL << GPIO_MODER_MODER6_Pos)       /*!< 0x00003000 */
N#define GPIO_MODER_MODER6                GPIO_MODER_MODER6_Msk                 
N#define GPIO_MODER_MODER6_0              (0x1UL << GPIO_MODER_MODER6_Pos)       /*!< 0x00001000 */
N#define GPIO_MODER_MODER6_1              (0x2UL << GPIO_MODER_MODER6_Pos)       /*!< 0x00002000 */
N#define GPIO_MODER_MODER7_Pos            (14U)                                 
N#define GPIO_MODER_MODER7_Msk            (0x3UL << GPIO_MODER_MODER7_Pos)       /*!< 0x0000C000 */
N#define GPIO_MODER_MODER7                GPIO_MODER_MODER7_Msk                 
N#define GPIO_MODER_MODER7_0              (0x1UL << GPIO_MODER_MODER7_Pos)       /*!< 0x00004000 */
N#define GPIO_MODER_MODER7_1              (0x2UL << GPIO_MODER_MODER7_Pos)       /*!< 0x00008000 */
N#define GPIO_MODER_MODER8_Pos            (16U)                                 
N#define GPIO_MODER_MODER8_Msk            (0x3UL << GPIO_MODER_MODER8_Pos)       /*!< 0x00030000 */
N#define GPIO_MODER_MODER8                GPIO_MODER_MODER8_Msk                 
N#define GPIO_MODER_MODER8_0              (0x1UL << GPIO_MODER_MODER8_Pos)       /*!< 0x00010000 */
N#define GPIO_MODER_MODER8_1              (0x2UL << GPIO_MODER_MODER8_Pos)       /*!< 0x00020000 */
N#define GPIO_MODER_MODER9_Pos            (18U)                                 
N#define GPIO_MODER_MODER9_Msk            (0x3UL << GPIO_MODER_MODER9_Pos)       /*!< 0x000C0000 */
N#define GPIO_MODER_MODER9                GPIO_MODER_MODER9_Msk                 
N#define GPIO_MODER_MODER9_0              (0x1UL << GPIO_MODER_MODER9_Pos)       /*!< 0x00040000 */
N#define GPIO_MODER_MODER9_1              (0x2UL << GPIO_MODER_MODER9_Pos)       /*!< 0x00080000 */
N#define GPIO_MODER_MODER10_Pos           (20U)                                 
N#define GPIO_MODER_MODER10_Msk           (0x3UL << GPIO_MODER_MODER10_Pos)      /*!< 0x00300000 */
N#define GPIO_MODER_MODER10               GPIO_MODER_MODER10_Msk                
N#define GPIO_MODER_MODER10_0             (0x1UL << GPIO_MODER_MODER10_Pos)      /*!< 0x00100000 */
N#define GPIO_MODER_MODER10_1             (0x2UL << GPIO_MODER_MODER10_Pos)      /*!< 0x00200000 */
N#define GPIO_MODER_MODER11_Pos           (22U)                                 
N#define GPIO_MODER_MODER11_Msk           (0x3UL << GPIO_MODER_MODER11_Pos)      /*!< 0x00C00000 */
N#define GPIO_MODER_MODER11               GPIO_MODER_MODER11_Msk                
N#define GPIO_MODER_MODER11_0             (0x1UL << GPIO_MODER_MODER11_Pos)      /*!< 0x00400000 */
N#define GPIO_MODER_MODER11_1             (0x2UL << GPIO_MODER_MODER11_Pos)      /*!< 0x00800000 */
N#define GPIO_MODER_MODER12_Pos           (24U)                                 
N#define GPIO_MODER_MODER12_Msk           (0x3UL << GPIO_MODER_MODER12_Pos)      /*!< 0x03000000 */
N#define GPIO_MODER_MODER12               GPIO_MODER_MODER12_Msk                
N#define GPIO_MODER_MODER12_0             (0x1UL << GPIO_MODER_MODER12_Pos)      /*!< 0x01000000 */
N#define GPIO_MODER_MODER12_1             (0x2UL << GPIO_MODER_MODER12_Pos)      /*!< 0x02000000 */
N#define GPIO_MODER_MODER13_Pos           (26U)                                 
N#define GPIO_MODER_MODER13_Msk           (0x3UL << GPIO_MODER_MODER13_Pos)      /*!< 0x0C000000 */
N#define GPIO_MODER_MODER13               GPIO_MODER_MODER13_Msk                
N#define GPIO_MODER_MODER13_0             (0x1UL << GPIO_MODER_MODER13_Pos)      /*!< 0x04000000 */
N#define GPIO_MODER_MODER13_1             (0x2UL << GPIO_MODER_MODER13_Pos)      /*!< 0x08000000 */
N#define GPIO_MODER_MODER14_Pos           (28U)                                 
N#define GPIO_MODER_MODER14_Msk           (0x3UL << GPIO_MODER_MODER14_Pos)      /*!< 0x30000000 */
N#define GPIO_MODER_MODER14               GPIO_MODER_MODER14_Msk                
N#define GPIO_MODER_MODER14_0             (0x1UL << GPIO_MODER_MODER14_Pos)      /*!< 0x10000000 */
N#define GPIO_MODER_MODER14_1             (0x2UL << GPIO_MODER_MODER14_Pos)      /*!< 0x20000000 */
N#define GPIO_MODER_MODER15_Pos           (30U)                                 
N#define GPIO_MODER_MODER15_Msk           (0x3UL << GPIO_MODER_MODER15_Pos)      /*!< 0xC0000000 */
N#define GPIO_MODER_MODER15               GPIO_MODER_MODER15_Msk                
N#define GPIO_MODER_MODER15_0             (0x1UL << GPIO_MODER_MODER15_Pos)      /*!< 0x40000000 */
N#define GPIO_MODER_MODER15_1             (0x2UL << GPIO_MODER_MODER15_Pos)      /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_MODER_MODE0_Pos             GPIO_MODER_MODER0_Pos                                  
N#define GPIO_MODER_MODE0_Msk             GPIO_MODER_MODER0_Msk
N#define GPIO_MODER_MODE0                 GPIO_MODER_MODER0                 
N#define GPIO_MODER_MODE0_0               GPIO_MODER_MODER0_0
N#define GPIO_MODER_MODE0_1               GPIO_MODER_MODER0_1
N#define GPIO_MODER_MODE1_Pos             GPIO_MODER_MODER1_Pos                                  
N#define GPIO_MODER_MODE1_Msk             GPIO_MODER_MODER1_Msk
N#define GPIO_MODER_MODE1                 GPIO_MODER_MODER1                  
N#define GPIO_MODER_MODE1_0               GPIO_MODER_MODER1_0
N#define GPIO_MODER_MODE1_1               GPIO_MODER_MODER1_1
N#define GPIO_MODER_MODE2_Pos             GPIO_MODER_MODER2_Pos
N#define GPIO_MODER_MODE2_Msk             GPIO_MODER_MODER2_Msk
N#define GPIO_MODER_MODE2                 GPIO_MODER_MODER2                 
N#define GPIO_MODER_MODE2_0               GPIO_MODER_MODER2_0
N#define GPIO_MODER_MODE2_1               GPIO_MODER_MODER2_1
N#define GPIO_MODER_MODE3_Pos             GPIO_MODER_MODER3_Pos                                
N#define GPIO_MODER_MODE3_Msk             GPIO_MODER_MODER3_Msk
N#define GPIO_MODER_MODE3                 GPIO_MODER_MODER3
N#define GPIO_MODER_MODE3_0               GPIO_MODER_MODER3_0
N#define GPIO_MODER_MODE3_1               GPIO_MODER_MODER3_1
N#define GPIO_MODER_MODE4_Pos             GPIO_MODER_MODER4_Pos
N#define GPIO_MODER_MODE4_Msk             GPIO_MODER_MODER4_Msk
N#define GPIO_MODER_MODE4                 GPIO_MODER_MODER4
N#define GPIO_MODER_MODE4_0               GPIO_MODER_MODER4_0
N#define GPIO_MODER_MODE4_1               GPIO_MODER_MODER4_1
N#define GPIO_MODER_MODE5_Pos             GPIO_MODER_MODER5_Pos
N#define GPIO_MODER_MODE5_Msk             GPIO_MODER_MODER5_Msk
N#define GPIO_MODER_MODE5                 GPIO_MODER_MODER5
N#define GPIO_MODER_MODE5_0               GPIO_MODER_MODER5_0
N#define GPIO_MODER_MODE5_1               GPIO_MODER_MODER5_1
N#define GPIO_MODER_MODE6_Pos             GPIO_MODER_MODER6_Pos
N#define GPIO_MODER_MODE6_Msk             GPIO_MODER_MODER6_Msk
N#define GPIO_MODER_MODE6                 GPIO_MODER_MODER6
N#define GPIO_MODER_MODE6_0               GPIO_MODER_MODER6_0
N#define GPIO_MODER_MODE6_1               GPIO_MODER_MODER6_1
N#define GPIO_MODER_MODE7_Pos             GPIO_MODER_MODER7_Pos
N#define GPIO_MODER_MODE7_Msk             GPIO_MODER_MODER7_Msk
N#define GPIO_MODER_MODE7                 GPIO_MODER_MODER7
N#define GPIO_MODER_MODE7_0               GPIO_MODER_MODER7_0
N#define GPIO_MODER_MODE7_1               GPIO_MODER_MODER7_1
N#define GPIO_MODER_MODE8_Pos             GPIO_MODER_MODER8_Pos
N#define GPIO_MODER_MODE8_Msk             GPIO_MODER_MODER8_Msk
N#define GPIO_MODER_MODE8                 GPIO_MODER_MODER8
N#define GPIO_MODER_MODE8_0               GPIO_MODER_MODER8_0
N#define GPIO_MODER_MODE8_1               GPIO_MODER_MODER8_1
N#define GPIO_MODER_MODE9_Pos             GPIO_MODER_MODER9_Pos
N#define GPIO_MODER_MODE9_Msk             GPIO_MODER_MODER9_Msk
N#define GPIO_MODER_MODE9                 GPIO_MODER_MODER9
N#define GPIO_MODER_MODE9_0               GPIO_MODER_MODER9_0
N#define GPIO_MODER_MODE9_1               GPIO_MODER_MODER9_1
N#define GPIO_MODER_MODE10_Pos            GPIO_MODER_MODER10_Pos
N#define GPIO_MODER_MODE10_Msk            GPIO_MODER_MODER10_Msk
N#define GPIO_MODER_MODE10                GPIO_MODER_MODER10
N#define GPIO_MODER_MODE10_0              GPIO_MODER_MODER10_0
N#define GPIO_MODER_MODE10_1              GPIO_MODER_MODER10_1
N#define GPIO_MODER_MODE11_Pos            GPIO_MODER_MODER11_Pos
N#define GPIO_MODER_MODE11_Msk            GPIO_MODER_MODER11_Msk
N#define GPIO_MODER_MODE11                GPIO_MODER_MODER11
N#define GPIO_MODER_MODE11_0              GPIO_MODER_MODER11_0
N#define GPIO_MODER_MODE11_1              GPIO_MODER_MODER11_1
N#define GPIO_MODER_MODE12_Pos            GPIO_MODER_MODER12_Pos
N#define GPIO_MODER_MODE12_Msk            GPIO_MODER_MODER12_Msk
N#define GPIO_MODER_MODE12                GPIO_MODER_MODER12
N#define GPIO_MODER_MODE12_0              GPIO_MODER_MODER12_0
N#define GPIO_MODER_MODE12_1              GPIO_MODER_MODER12_1
N#define GPIO_MODER_MODE13_Pos            GPIO_MODER_MODER13_Pos
N#define GPIO_MODER_MODE13_Msk            GPIO_MODER_MODER13_Msk
N#define GPIO_MODER_MODE13                GPIO_MODER_MODER13
N#define GPIO_MODER_MODE13_0              GPIO_MODER_MODER13_0
N#define GPIO_MODER_MODE13_1              GPIO_MODER_MODER13_1
N#define GPIO_MODER_MODE14_Pos            GPIO_MODER_MODER14_Pos
N#define GPIO_MODER_MODE14_Msk            GPIO_MODER_MODER14_Msk
N#define GPIO_MODER_MODE14                GPIO_MODER_MODER14
N#define GPIO_MODER_MODE14_0              GPIO_MODER_MODER14_0
N#define GPIO_MODER_MODE14_1              GPIO_MODER_MODER14_1
N#define GPIO_MODER_MODE15_Pos            GPIO_MODER_MODER15_Pos
N#define GPIO_MODER_MODE15_Msk            GPIO_MODER_MODER15_Msk
N#define GPIO_MODER_MODE15                GPIO_MODER_MODER15
N#define GPIO_MODER_MODE15_0              GPIO_MODER_MODER15_0
N#define GPIO_MODER_MODE15_1              GPIO_MODER_MODER15_1
N
N/******************  Bits definition for GPIO_OTYPER register  ****************/
N#define GPIO_OTYPER_OT0_Pos              (0U)                                  
N#define GPIO_OTYPER_OT0_Msk              (0x1UL << GPIO_OTYPER_OT0_Pos)         /*!< 0x00000001 */
N#define GPIO_OTYPER_OT0                  GPIO_OTYPER_OT0_Msk                   
N#define GPIO_OTYPER_OT1_Pos              (1U)                                  
N#define GPIO_OTYPER_OT1_Msk              (0x1UL << GPIO_OTYPER_OT1_Pos)         /*!< 0x00000002 */
N#define GPIO_OTYPER_OT1                  GPIO_OTYPER_OT1_Msk                   
N#define GPIO_OTYPER_OT2_Pos              (2U)                                  
N#define GPIO_OTYPER_OT2_Msk              (0x1UL << GPIO_OTYPER_OT2_Pos)         /*!< 0x00000004 */
N#define GPIO_OTYPER_OT2                  GPIO_OTYPER_OT2_Msk                   
N#define GPIO_OTYPER_OT3_Pos              (3U)                                  
N#define GPIO_OTYPER_OT3_Msk              (0x1UL << GPIO_OTYPER_OT3_Pos)         /*!< 0x00000008 */
N#define GPIO_OTYPER_OT3                  GPIO_OTYPER_OT3_Msk                   
N#define GPIO_OTYPER_OT4_Pos              (4U)                                  
N#define GPIO_OTYPER_OT4_Msk              (0x1UL << GPIO_OTYPER_OT4_Pos)         /*!< 0x00000010 */
N#define GPIO_OTYPER_OT4                  GPIO_OTYPER_OT4_Msk                   
N#define GPIO_OTYPER_OT5_Pos              (5U)                                  
N#define GPIO_OTYPER_OT5_Msk              (0x1UL << GPIO_OTYPER_OT5_Pos)         /*!< 0x00000020 */
N#define GPIO_OTYPER_OT5                  GPIO_OTYPER_OT5_Msk                   
N#define GPIO_OTYPER_OT6_Pos              (6U)                                  
N#define GPIO_OTYPER_OT6_Msk              (0x1UL << GPIO_OTYPER_OT6_Pos)         /*!< 0x00000040 */
N#define GPIO_OTYPER_OT6                  GPIO_OTYPER_OT6_Msk                   
N#define GPIO_OTYPER_OT7_Pos              (7U)                                  
N#define GPIO_OTYPER_OT7_Msk              (0x1UL << GPIO_OTYPER_OT7_Pos)         /*!< 0x00000080 */
N#define GPIO_OTYPER_OT7                  GPIO_OTYPER_OT7_Msk                   
N#define GPIO_OTYPER_OT8_Pos              (8U)                                  
N#define GPIO_OTYPER_OT8_Msk              (0x1UL << GPIO_OTYPER_OT8_Pos)         /*!< 0x00000100 */
N#define GPIO_OTYPER_OT8                  GPIO_OTYPER_OT8_Msk                   
N#define GPIO_OTYPER_OT9_Pos              (9U)                                  
N#define GPIO_OTYPER_OT9_Msk              (0x1UL << GPIO_OTYPER_OT9_Pos)         /*!< 0x00000200 */
N#define GPIO_OTYPER_OT9                  GPIO_OTYPER_OT9_Msk                   
N#define GPIO_OTYPER_OT10_Pos             (10U)                                 
N#define GPIO_OTYPER_OT10_Msk             (0x1UL << GPIO_OTYPER_OT10_Pos)        /*!< 0x00000400 */
N#define GPIO_OTYPER_OT10                 GPIO_OTYPER_OT10_Msk                  
N#define GPIO_OTYPER_OT11_Pos             (11U)                                 
N#define GPIO_OTYPER_OT11_Msk             (0x1UL << GPIO_OTYPER_OT11_Pos)        /*!< 0x00000800 */
N#define GPIO_OTYPER_OT11                 GPIO_OTYPER_OT11_Msk                  
N#define GPIO_OTYPER_OT12_Pos             (12U)                                 
N#define GPIO_OTYPER_OT12_Msk             (0x1UL << GPIO_OTYPER_OT12_Pos)        /*!< 0x00001000 */
N#define GPIO_OTYPER_OT12                 GPIO_OTYPER_OT12_Msk                  
N#define GPIO_OTYPER_OT13_Pos             (13U)                                 
N#define GPIO_OTYPER_OT13_Msk             (0x1UL << GPIO_OTYPER_OT13_Pos)        /*!< 0x00002000 */
N#define GPIO_OTYPER_OT13                 GPIO_OTYPER_OT13_Msk                  
N#define GPIO_OTYPER_OT14_Pos             (14U)                                 
N#define GPIO_OTYPER_OT14_Msk             (0x1UL << GPIO_OTYPER_OT14_Pos)        /*!< 0x00004000 */
N#define GPIO_OTYPER_OT14                 GPIO_OTYPER_OT14_Msk                  
N#define GPIO_OTYPER_OT15_Pos             (15U)                                 
N#define GPIO_OTYPER_OT15_Msk             (0x1UL << GPIO_OTYPER_OT15_Pos)        /*!< 0x00008000 */
N#define GPIO_OTYPER_OT15                 GPIO_OTYPER_OT15_Msk                  
N
N/* Legacy defines */
N#define GPIO_OTYPER_OT_0                 GPIO_OTYPER_OT0
N#define GPIO_OTYPER_OT_1                 GPIO_OTYPER_OT1
N#define GPIO_OTYPER_OT_2                 GPIO_OTYPER_OT2
N#define GPIO_OTYPER_OT_3                 GPIO_OTYPER_OT3
N#define GPIO_OTYPER_OT_4                 GPIO_OTYPER_OT4
N#define GPIO_OTYPER_OT_5                 GPIO_OTYPER_OT5
N#define GPIO_OTYPER_OT_6                 GPIO_OTYPER_OT6
N#define GPIO_OTYPER_OT_7                 GPIO_OTYPER_OT7
N#define GPIO_OTYPER_OT_8                 GPIO_OTYPER_OT8
N#define GPIO_OTYPER_OT_9                 GPIO_OTYPER_OT9
N#define GPIO_OTYPER_OT_10                GPIO_OTYPER_OT10
N#define GPIO_OTYPER_OT_11                GPIO_OTYPER_OT11
N#define GPIO_OTYPER_OT_12                GPIO_OTYPER_OT12
N#define GPIO_OTYPER_OT_13                GPIO_OTYPER_OT13
N#define GPIO_OTYPER_OT_14                GPIO_OTYPER_OT14
N#define GPIO_OTYPER_OT_15                GPIO_OTYPER_OT15
N
N/******************  Bits definition for GPIO_OSPEEDR register  ***************/
N#define GPIO_OSPEEDR_OSPEED0_Pos         (0U)                                  
N#define GPIO_OSPEEDR_OSPEED0_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED0_Pos)    /*!< 0x00000003 */
N#define GPIO_OSPEEDR_OSPEED0             GPIO_OSPEEDR_OSPEED0_Msk              
N#define GPIO_OSPEEDR_OSPEED0_0           (0x1UL << GPIO_OSPEEDR_OSPEED0_Pos)    /*!< 0x00000001 */
N#define GPIO_OSPEEDR_OSPEED0_1           (0x2UL << GPIO_OSPEEDR_OSPEED0_Pos)    /*!< 0x00000002 */
N#define GPIO_OSPEEDR_OSPEED1_Pos         (2U)                                  
N#define GPIO_OSPEEDR_OSPEED1_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED1_Pos)    /*!< 0x0000000C */
N#define GPIO_OSPEEDR_OSPEED1             GPIO_OSPEEDR_OSPEED1_Msk              
N#define GPIO_OSPEEDR_OSPEED1_0           (0x1UL << GPIO_OSPEEDR_OSPEED1_Pos)    /*!< 0x00000004 */
N#define GPIO_OSPEEDR_OSPEED1_1           (0x2UL << GPIO_OSPEEDR_OSPEED1_Pos)    /*!< 0x00000008 */
N#define GPIO_OSPEEDR_OSPEED2_Pos         (4U)                                  
N#define GPIO_OSPEEDR_OSPEED2_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED2_Pos)    /*!< 0x00000030 */
N#define GPIO_OSPEEDR_OSPEED2             GPIO_OSPEEDR_OSPEED2_Msk              
N#define GPIO_OSPEEDR_OSPEED2_0           (0x1UL << GPIO_OSPEEDR_OSPEED2_Pos)    /*!< 0x00000010 */
N#define GPIO_OSPEEDR_OSPEED2_1           (0x2UL << GPIO_OSPEEDR_OSPEED2_Pos)    /*!< 0x00000020 */
N#define GPIO_OSPEEDR_OSPEED3_Pos         (6U)                                  
N#define GPIO_OSPEEDR_OSPEED3_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED3_Pos)    /*!< 0x000000C0 */
N#define GPIO_OSPEEDR_OSPEED3             GPIO_OSPEEDR_OSPEED3_Msk              
N#define GPIO_OSPEEDR_OSPEED3_0           (0x1UL << GPIO_OSPEEDR_OSPEED3_Pos)    /*!< 0x00000040 */
N#define GPIO_OSPEEDR_OSPEED3_1           (0x2UL << GPIO_OSPEEDR_OSPEED3_Pos)    /*!< 0x00000080 */
N#define GPIO_OSPEEDR_OSPEED4_Pos         (8U)                                  
N#define GPIO_OSPEEDR_OSPEED4_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED4_Pos)    /*!< 0x00000300 */
N#define GPIO_OSPEEDR_OSPEED4             GPIO_OSPEEDR_OSPEED4_Msk              
N#define GPIO_OSPEEDR_OSPEED4_0           (0x1UL << GPIO_OSPEEDR_OSPEED4_Pos)    /*!< 0x00000100 */
N#define GPIO_OSPEEDR_OSPEED4_1           (0x2UL << GPIO_OSPEEDR_OSPEED4_Pos)    /*!< 0x00000200 */
N#define GPIO_OSPEEDR_OSPEED5_Pos         (10U)                                 
N#define GPIO_OSPEEDR_OSPEED5_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED5_Pos)    /*!< 0x00000C00 */
N#define GPIO_OSPEEDR_OSPEED5             GPIO_OSPEEDR_OSPEED5_Msk              
N#define GPIO_OSPEEDR_OSPEED5_0           (0x1UL << GPIO_OSPEEDR_OSPEED5_Pos)    /*!< 0x00000400 */
N#define GPIO_OSPEEDR_OSPEED5_1           (0x2UL << GPIO_OSPEEDR_OSPEED5_Pos)    /*!< 0x00000800 */
N#define GPIO_OSPEEDR_OSPEED6_Pos         (12U)                                 
N#define GPIO_OSPEEDR_OSPEED6_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED6_Pos)    /*!< 0x00003000 */
N#define GPIO_OSPEEDR_OSPEED6             GPIO_OSPEEDR_OSPEED6_Msk              
N#define GPIO_OSPEEDR_OSPEED6_0           (0x1UL << GPIO_OSPEEDR_OSPEED6_Pos)    /*!< 0x00001000 */
N#define GPIO_OSPEEDR_OSPEED6_1           (0x2UL << GPIO_OSPEEDR_OSPEED6_Pos)    /*!< 0x00002000 */
N#define GPIO_OSPEEDR_OSPEED7_Pos         (14U)                                 
N#define GPIO_OSPEEDR_OSPEED7_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED7_Pos)    /*!< 0x0000C000 */
N#define GPIO_OSPEEDR_OSPEED7             GPIO_OSPEEDR_OSPEED7_Msk              
N#define GPIO_OSPEEDR_OSPEED7_0           (0x1UL << GPIO_OSPEEDR_OSPEED7_Pos)    /*!< 0x00004000 */
N#define GPIO_OSPEEDR_OSPEED7_1           (0x2UL << GPIO_OSPEEDR_OSPEED7_Pos)    /*!< 0x00008000 */
N#define GPIO_OSPEEDR_OSPEED8_Pos         (16U)                                 
N#define GPIO_OSPEEDR_OSPEED8_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED8_Pos)    /*!< 0x00030000 */
N#define GPIO_OSPEEDR_OSPEED8             GPIO_OSPEEDR_OSPEED8_Msk              
N#define GPIO_OSPEEDR_OSPEED8_0           (0x1UL << GPIO_OSPEEDR_OSPEED8_Pos)    /*!< 0x00010000 */
N#define GPIO_OSPEEDR_OSPEED8_1           (0x2UL << GPIO_OSPEEDR_OSPEED8_Pos)    /*!< 0x00020000 */
N#define GPIO_OSPEEDR_OSPEED9_Pos         (18U)                                 
N#define GPIO_OSPEEDR_OSPEED9_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED9_Pos)    /*!< 0x000C0000 */
N#define GPIO_OSPEEDR_OSPEED9             GPIO_OSPEEDR_OSPEED9_Msk              
N#define GPIO_OSPEEDR_OSPEED9_0           (0x1UL << GPIO_OSPEEDR_OSPEED9_Pos)    /*!< 0x00040000 */
N#define GPIO_OSPEEDR_OSPEED9_1           (0x2UL << GPIO_OSPEEDR_OSPEED9_Pos)    /*!< 0x00080000 */
N#define GPIO_OSPEEDR_OSPEED10_Pos        (20U)                                 
N#define GPIO_OSPEEDR_OSPEED10_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED10_Pos)   /*!< 0x00300000 */
N#define GPIO_OSPEEDR_OSPEED10            GPIO_OSPEEDR_OSPEED10_Msk             
N#define GPIO_OSPEEDR_OSPEED10_0          (0x1UL << GPIO_OSPEEDR_OSPEED10_Pos)   /*!< 0x00100000 */
N#define GPIO_OSPEEDR_OSPEED10_1          (0x2UL << GPIO_OSPEEDR_OSPEED10_Pos)   /*!< 0x00200000 */
N#define GPIO_OSPEEDR_OSPEED11_Pos        (22U)                                 
N#define GPIO_OSPEEDR_OSPEED11_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED11_Pos)   /*!< 0x00C00000 */
N#define GPIO_OSPEEDR_OSPEED11            GPIO_OSPEEDR_OSPEED11_Msk             
N#define GPIO_OSPEEDR_OSPEED11_0          (0x1UL << GPIO_OSPEEDR_OSPEED11_Pos)   /*!< 0x00400000 */
N#define GPIO_OSPEEDR_OSPEED11_1          (0x2UL << GPIO_OSPEEDR_OSPEED11_Pos)   /*!< 0x00800000 */
N#define GPIO_OSPEEDR_OSPEED12_Pos        (24U)                                 
N#define GPIO_OSPEEDR_OSPEED12_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED12_Pos)   /*!< 0x03000000 */
N#define GPIO_OSPEEDR_OSPEED12            GPIO_OSPEEDR_OSPEED12_Msk             
N#define GPIO_OSPEEDR_OSPEED12_0          (0x1UL << GPIO_OSPEEDR_OSPEED12_Pos)   /*!< 0x01000000 */
N#define GPIO_OSPEEDR_OSPEED12_1          (0x2UL << GPIO_OSPEEDR_OSPEED12_Pos)   /*!< 0x02000000 */
N#define GPIO_OSPEEDR_OSPEED13_Pos        (26U)                                 
N#define GPIO_OSPEEDR_OSPEED13_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED13_Pos)   /*!< 0x0C000000 */
N#define GPIO_OSPEEDR_OSPEED13            GPIO_OSPEEDR_OSPEED13_Msk             
N#define GPIO_OSPEEDR_OSPEED13_0          (0x1UL << GPIO_OSPEEDR_OSPEED13_Pos)   /*!< 0x04000000 */
N#define GPIO_OSPEEDR_OSPEED13_1          (0x2UL << GPIO_OSPEEDR_OSPEED13_Pos)   /*!< 0x08000000 */
N#define GPIO_OSPEEDR_OSPEED14_Pos        (28U)                                 
N#define GPIO_OSPEEDR_OSPEED14_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED14_Pos)   /*!< 0x30000000 */
N#define GPIO_OSPEEDR_OSPEED14            GPIO_OSPEEDR_OSPEED14_Msk             
N#define GPIO_OSPEEDR_OSPEED14_0          (0x1UL << GPIO_OSPEEDR_OSPEED14_Pos)   /*!< 0x10000000 */
N#define GPIO_OSPEEDR_OSPEED14_1          (0x2UL << GPIO_OSPEEDR_OSPEED14_Pos)   /*!< 0x20000000 */
N#define GPIO_OSPEEDR_OSPEED15_Pos        (30U)                                 
N#define GPIO_OSPEEDR_OSPEED15_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED15_Pos)   /*!< 0xC0000000 */
N#define GPIO_OSPEEDR_OSPEED15            GPIO_OSPEEDR_OSPEED15_Msk             
N#define GPIO_OSPEEDR_OSPEED15_0          (0x1UL << GPIO_OSPEEDR_OSPEED15_Pos)   /*!< 0x40000000 */
N#define GPIO_OSPEEDR_OSPEED15_1          (0x2UL << GPIO_OSPEEDR_OSPEED15_Pos)   /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_OSPEEDER_OSPEEDR0           GPIO_OSPEEDR_OSPEED0
N#define GPIO_OSPEEDER_OSPEEDR0_0         GPIO_OSPEEDR_OSPEED0_0
N#define GPIO_OSPEEDER_OSPEEDR0_1         GPIO_OSPEEDR_OSPEED0_1
N#define GPIO_OSPEEDER_OSPEEDR1           GPIO_OSPEEDR_OSPEED1
N#define GPIO_OSPEEDER_OSPEEDR1_0         GPIO_OSPEEDR_OSPEED1_0
N#define GPIO_OSPEEDER_OSPEEDR1_1         GPIO_OSPEEDR_OSPEED1_1
N#define GPIO_OSPEEDER_OSPEEDR2           GPIO_OSPEEDR_OSPEED2
N#define GPIO_OSPEEDER_OSPEEDR2_0         GPIO_OSPEEDR_OSPEED2_0
N#define GPIO_OSPEEDER_OSPEEDR2_1         GPIO_OSPEEDR_OSPEED2_1
N#define GPIO_OSPEEDER_OSPEEDR3           GPIO_OSPEEDR_OSPEED3
N#define GPIO_OSPEEDER_OSPEEDR3_0         GPIO_OSPEEDR_OSPEED3_0
N#define GPIO_OSPEEDER_OSPEEDR3_1         GPIO_OSPEEDR_OSPEED3_1
N#define GPIO_OSPEEDER_OSPEEDR4           GPIO_OSPEEDR_OSPEED4
N#define GPIO_OSPEEDER_OSPEEDR4_0         GPIO_OSPEEDR_OSPEED4_0
N#define GPIO_OSPEEDER_OSPEEDR4_1         GPIO_OSPEEDR_OSPEED4_1
N#define GPIO_OSPEEDER_OSPEEDR5           GPIO_OSPEEDR_OSPEED5
N#define GPIO_OSPEEDER_OSPEEDR5_0         GPIO_OSPEEDR_OSPEED5_0
N#define GPIO_OSPEEDER_OSPEEDR5_1         GPIO_OSPEEDR_OSPEED5_1
N#define GPIO_OSPEEDER_OSPEEDR6           GPIO_OSPEEDR_OSPEED6
N#define GPIO_OSPEEDER_OSPEEDR6_0         GPIO_OSPEEDR_OSPEED6_0
N#define GPIO_OSPEEDER_OSPEEDR6_1         GPIO_OSPEEDR_OSPEED6_1
N#define GPIO_OSPEEDER_OSPEEDR7           GPIO_OSPEEDR_OSPEED7
N#define GPIO_OSPEEDER_OSPEEDR7_0         GPIO_OSPEEDR_OSPEED7_0
N#define GPIO_OSPEEDER_OSPEEDR7_1         GPIO_OSPEEDR_OSPEED7_1
N#define GPIO_OSPEEDER_OSPEEDR8           GPIO_OSPEEDR_OSPEED8
N#define GPIO_OSPEEDER_OSPEEDR8_0         GPIO_OSPEEDR_OSPEED8_0
N#define GPIO_OSPEEDER_OSPEEDR8_1         GPIO_OSPEEDR_OSPEED8_1
N#define GPIO_OSPEEDER_OSPEEDR9           GPIO_OSPEEDR_OSPEED9
N#define GPIO_OSPEEDER_OSPEEDR9_0         GPIO_OSPEEDR_OSPEED9_0
N#define GPIO_OSPEEDER_OSPEEDR9_1         GPIO_OSPEEDR_OSPEED9_1
N#define GPIO_OSPEEDER_OSPEEDR10          GPIO_OSPEEDR_OSPEED10
N#define GPIO_OSPEEDER_OSPEEDR10_0        GPIO_OSPEEDR_OSPEED10_0
N#define GPIO_OSPEEDER_OSPEEDR10_1        GPIO_OSPEEDR_OSPEED10_1
N#define GPIO_OSPEEDER_OSPEEDR11          GPIO_OSPEEDR_OSPEED11
N#define GPIO_OSPEEDER_OSPEEDR11_0        GPIO_OSPEEDR_OSPEED11_0
N#define GPIO_OSPEEDER_OSPEEDR11_1        GPIO_OSPEEDR_OSPEED11_1
N#define GPIO_OSPEEDER_OSPEEDR12          GPIO_OSPEEDR_OSPEED12
N#define GPIO_OSPEEDER_OSPEEDR12_0        GPIO_OSPEEDR_OSPEED12_0
N#define GPIO_OSPEEDER_OSPEEDR12_1        GPIO_OSPEEDR_OSPEED12_1
N#define GPIO_OSPEEDER_OSPEEDR13          GPIO_OSPEEDR_OSPEED13
N#define GPIO_OSPEEDER_OSPEEDR13_0        GPIO_OSPEEDR_OSPEED13_0
N#define GPIO_OSPEEDER_OSPEEDR13_1        GPIO_OSPEEDR_OSPEED13_1
N#define GPIO_OSPEEDER_OSPEEDR14          GPIO_OSPEEDR_OSPEED14
N#define GPIO_OSPEEDER_OSPEEDR14_0        GPIO_OSPEEDR_OSPEED14_0
N#define GPIO_OSPEEDER_OSPEEDR14_1        GPIO_OSPEEDR_OSPEED14_1
N#define GPIO_OSPEEDER_OSPEEDR15          GPIO_OSPEEDR_OSPEED15
N#define GPIO_OSPEEDER_OSPEEDR15_0        GPIO_OSPEEDR_OSPEED15_0
N#define GPIO_OSPEEDER_OSPEEDR15_1        GPIO_OSPEEDR_OSPEED15_1
N
N/******************  Bits definition for GPIO_PUPDR register  *****************/
N#define GPIO_PUPDR_PUPD0_Pos             (0U)                                  
N#define GPIO_PUPDR_PUPD0_Msk             (0x3UL << GPIO_PUPDR_PUPD0_Pos)        /*!< 0x00000003 */
N#define GPIO_PUPDR_PUPD0                 GPIO_PUPDR_PUPD0_Msk                  
N#define GPIO_PUPDR_PUPD0_0               (0x1UL << GPIO_PUPDR_PUPD0_Pos)        /*!< 0x00000001 */
N#define GPIO_PUPDR_PUPD0_1               (0x2UL << GPIO_PUPDR_PUPD0_Pos)        /*!< 0x00000002 */
N#define GPIO_PUPDR_PUPD1_Pos             (2U)                                  
N#define GPIO_PUPDR_PUPD1_Msk             (0x3UL << GPIO_PUPDR_PUPD1_Pos)        /*!< 0x0000000C */
N#define GPIO_PUPDR_PUPD1                 GPIO_PUPDR_PUPD1_Msk                  
N#define GPIO_PUPDR_PUPD1_0               (0x1UL << GPIO_PUPDR_PUPD1_Pos)        /*!< 0x00000004 */
N#define GPIO_PUPDR_PUPD1_1               (0x2UL << GPIO_PUPDR_PUPD1_Pos)        /*!< 0x00000008 */
N#define GPIO_PUPDR_PUPD2_Pos             (4U)                                  
N#define GPIO_PUPDR_PUPD2_Msk             (0x3UL << GPIO_PUPDR_PUPD2_Pos)        /*!< 0x00000030 */
N#define GPIO_PUPDR_PUPD2                 GPIO_PUPDR_PUPD2_Msk                  
N#define GPIO_PUPDR_PUPD2_0               (0x1UL << GPIO_PUPDR_PUPD2_Pos)        /*!< 0x00000010 */
N#define GPIO_PUPDR_PUPD2_1               (0x2UL << GPIO_PUPDR_PUPD2_Pos)        /*!< 0x00000020 */
N#define GPIO_PUPDR_PUPD3_Pos             (6U)                                  
N#define GPIO_PUPDR_PUPD3_Msk             (0x3UL << GPIO_PUPDR_PUPD3_Pos)        /*!< 0x000000C0 */
N#define GPIO_PUPDR_PUPD3                 GPIO_PUPDR_PUPD3_Msk                  
N#define GPIO_PUPDR_PUPD3_0               (0x1UL << GPIO_PUPDR_PUPD3_Pos)        /*!< 0x00000040 */
N#define GPIO_PUPDR_PUPD3_1               (0x2UL << GPIO_PUPDR_PUPD3_Pos)        /*!< 0x00000080 */
N#define GPIO_PUPDR_PUPD4_Pos             (8U)                                  
N#define GPIO_PUPDR_PUPD4_Msk             (0x3UL << GPIO_PUPDR_PUPD4_Pos)        /*!< 0x00000300 */
N#define GPIO_PUPDR_PUPD4                 GPIO_PUPDR_PUPD4_Msk                  
N#define GPIO_PUPDR_PUPD4_0               (0x1UL << GPIO_PUPDR_PUPD4_Pos)        /*!< 0x00000100 */
N#define GPIO_PUPDR_PUPD4_1               (0x2UL << GPIO_PUPDR_PUPD4_Pos)        /*!< 0x00000200 */
N#define GPIO_PUPDR_PUPD5_Pos             (10U)                                 
N#define GPIO_PUPDR_PUPD5_Msk             (0x3UL << GPIO_PUPDR_PUPD5_Pos)        /*!< 0x00000C00 */
N#define GPIO_PUPDR_PUPD5                 GPIO_PUPDR_PUPD5_Msk                  
N#define GPIO_PUPDR_PUPD5_0               (0x1UL << GPIO_PUPDR_PUPD5_Pos)        /*!< 0x00000400 */
N#define GPIO_PUPDR_PUPD5_1               (0x2UL << GPIO_PUPDR_PUPD5_Pos)        /*!< 0x00000800 */
N#define GPIO_PUPDR_PUPD6_Pos             (12U)                                 
N#define GPIO_PUPDR_PUPD6_Msk             (0x3UL << GPIO_PUPDR_PUPD6_Pos)        /*!< 0x00003000 */
N#define GPIO_PUPDR_PUPD6                 GPIO_PUPDR_PUPD6_Msk                  
N#define GPIO_PUPDR_PUPD6_0               (0x1UL << GPIO_PUPDR_PUPD6_Pos)        /*!< 0x00001000 */
N#define GPIO_PUPDR_PUPD6_1               (0x2UL << GPIO_PUPDR_PUPD6_Pos)        /*!< 0x00002000 */
N#define GPIO_PUPDR_PUPD7_Pos             (14U)                                 
N#define GPIO_PUPDR_PUPD7_Msk             (0x3UL << GPIO_PUPDR_PUPD7_Pos)        /*!< 0x0000C000 */
N#define GPIO_PUPDR_PUPD7                 GPIO_PUPDR_PUPD7_Msk                  
N#define GPIO_PUPDR_PUPD7_0               (0x1UL << GPIO_PUPDR_PUPD7_Pos)        /*!< 0x00004000 */
N#define GPIO_PUPDR_PUPD7_1               (0x2UL << GPIO_PUPDR_PUPD7_Pos)        /*!< 0x00008000 */
N#define GPIO_PUPDR_PUPD8_Pos             (16U)                                 
N#define GPIO_PUPDR_PUPD8_Msk             (0x3UL << GPIO_PUPDR_PUPD8_Pos)        /*!< 0x00030000 */
N#define GPIO_PUPDR_PUPD8                 GPIO_PUPDR_PUPD8_Msk                  
N#define GPIO_PUPDR_PUPD8_0               (0x1UL << GPIO_PUPDR_PUPD8_Pos)        /*!< 0x00010000 */
N#define GPIO_PUPDR_PUPD8_1               (0x2UL << GPIO_PUPDR_PUPD8_Pos)        /*!< 0x00020000 */
N#define GPIO_PUPDR_PUPD9_Pos             (18U)                                 
N#define GPIO_PUPDR_PUPD9_Msk             (0x3UL << GPIO_PUPDR_PUPD9_Pos)        /*!< 0x000C0000 */
N#define GPIO_PUPDR_PUPD9                 GPIO_PUPDR_PUPD9_Msk                  
N#define GPIO_PUPDR_PUPD9_0               (0x1UL << GPIO_PUPDR_PUPD9_Pos)        /*!< 0x00040000 */
N#define GPIO_PUPDR_PUPD9_1               (0x2UL << GPIO_PUPDR_PUPD9_Pos)        /*!< 0x00080000 */
N#define GPIO_PUPDR_PUPD10_Pos            (20U)                                 
N#define GPIO_PUPDR_PUPD10_Msk            (0x3UL << GPIO_PUPDR_PUPD10_Pos)       /*!< 0x00300000 */
N#define GPIO_PUPDR_PUPD10                GPIO_PUPDR_PUPD10_Msk                 
N#define GPIO_PUPDR_PUPD10_0              (0x1UL << GPIO_PUPDR_PUPD10_Pos)       /*!< 0x00100000 */
N#define GPIO_PUPDR_PUPD10_1              (0x2UL << GPIO_PUPDR_PUPD10_Pos)       /*!< 0x00200000 */
N#define GPIO_PUPDR_PUPD11_Pos            (22U)                                 
N#define GPIO_PUPDR_PUPD11_Msk            (0x3UL << GPIO_PUPDR_PUPD11_Pos)       /*!< 0x00C00000 */
N#define GPIO_PUPDR_PUPD11                GPIO_PUPDR_PUPD11_Msk                 
N#define GPIO_PUPDR_PUPD11_0              (0x1UL << GPIO_PUPDR_PUPD11_Pos)       /*!< 0x00400000 */
N#define GPIO_PUPDR_PUPD11_1              (0x2UL << GPIO_PUPDR_PUPD11_Pos)       /*!< 0x00800000 */
N#define GPIO_PUPDR_PUPD12_Pos            (24U)                                 
N#define GPIO_PUPDR_PUPD12_Msk            (0x3UL << GPIO_PUPDR_PUPD12_Pos)       /*!< 0x03000000 */
N#define GPIO_PUPDR_PUPD12                GPIO_PUPDR_PUPD12_Msk                 
N#define GPIO_PUPDR_PUPD12_0              (0x1UL << GPIO_PUPDR_PUPD12_Pos)       /*!< 0x01000000 */
N#define GPIO_PUPDR_PUPD12_1              (0x2UL << GPIO_PUPDR_PUPD12_Pos)       /*!< 0x02000000 */
N#define GPIO_PUPDR_PUPD13_Pos            (26U)                                 
N#define GPIO_PUPDR_PUPD13_Msk            (0x3UL << GPIO_PUPDR_PUPD13_Pos)       /*!< 0x0C000000 */
N#define GPIO_PUPDR_PUPD13                GPIO_PUPDR_PUPD13_Msk                 
N#define GPIO_PUPDR_PUPD13_0              (0x1UL << GPIO_PUPDR_PUPD13_Pos)       /*!< 0x04000000 */
N#define GPIO_PUPDR_PUPD13_1              (0x2UL << GPIO_PUPDR_PUPD13_Pos)       /*!< 0x08000000 */
N#define GPIO_PUPDR_PUPD14_Pos            (28U)                                 
N#define GPIO_PUPDR_PUPD14_Msk            (0x3UL << GPIO_PUPDR_PUPD14_Pos)       /*!< 0x30000000 */
N#define GPIO_PUPDR_PUPD14                GPIO_PUPDR_PUPD14_Msk                 
N#define GPIO_PUPDR_PUPD14_0              (0x1UL << GPIO_PUPDR_PUPD14_Pos)       /*!< 0x10000000 */
N#define GPIO_PUPDR_PUPD14_1              (0x2UL << GPIO_PUPDR_PUPD14_Pos)       /*!< 0x20000000 */
N#define GPIO_PUPDR_PUPD15_Pos            (30U)                                 
N#define GPIO_PUPDR_PUPD15_Msk            (0x3UL << GPIO_PUPDR_PUPD15_Pos)       /*!< 0xC0000000 */
N#define GPIO_PUPDR_PUPD15                GPIO_PUPDR_PUPD15_Msk                 
N#define GPIO_PUPDR_PUPD15_0              (0x1UL << GPIO_PUPDR_PUPD15_Pos)       /*!< 0x40000000 */
N#define GPIO_PUPDR_PUPD15_1              (0x2UL << GPIO_PUPDR_PUPD15_Pos)       /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_PUPDR_PUPDR0                GPIO_PUPDR_PUPD0
N#define GPIO_PUPDR_PUPDR0_0              GPIO_PUPDR_PUPD0_0
N#define GPIO_PUPDR_PUPDR0_1              GPIO_PUPDR_PUPD0_1
N#define GPIO_PUPDR_PUPDR1                GPIO_PUPDR_PUPD1
N#define GPIO_PUPDR_PUPDR1_0              GPIO_PUPDR_PUPD1_0
N#define GPIO_PUPDR_PUPDR1_1              GPIO_PUPDR_PUPD1_1
N#define GPIO_PUPDR_PUPDR2                GPIO_PUPDR_PUPD2
N#define GPIO_PUPDR_PUPDR2_0              GPIO_PUPDR_PUPD2_0
N#define GPIO_PUPDR_PUPDR2_1              GPIO_PUPDR_PUPD2_1
N#define GPIO_PUPDR_PUPDR3                GPIO_PUPDR_PUPD3
N#define GPIO_PUPDR_PUPDR3_0              GPIO_PUPDR_PUPD3_0
N#define GPIO_PUPDR_PUPDR3_1              GPIO_PUPDR_PUPD3_1
N#define GPIO_PUPDR_PUPDR4                GPIO_PUPDR_PUPD4
N#define GPIO_PUPDR_PUPDR4_0              GPIO_PUPDR_PUPD4_0
N#define GPIO_PUPDR_PUPDR4_1              GPIO_PUPDR_PUPD4_1
N#define GPIO_PUPDR_PUPDR5                GPIO_PUPDR_PUPD5
N#define GPIO_PUPDR_PUPDR5_0              GPIO_PUPDR_PUPD5_0
N#define GPIO_PUPDR_PUPDR5_1              GPIO_PUPDR_PUPD5_1
N#define GPIO_PUPDR_PUPDR6                GPIO_PUPDR_PUPD6
N#define GPIO_PUPDR_PUPDR6_0              GPIO_PUPDR_PUPD6_0
N#define GPIO_PUPDR_PUPDR6_1              GPIO_PUPDR_PUPD6_1
N#define GPIO_PUPDR_PUPDR7                GPIO_PUPDR_PUPD7
N#define GPIO_PUPDR_PUPDR7_0              GPIO_PUPDR_PUPD7_0
N#define GPIO_PUPDR_PUPDR7_1              GPIO_PUPDR_PUPD7_1
N#define GPIO_PUPDR_PUPDR8                GPIO_PUPDR_PUPD8
N#define GPIO_PUPDR_PUPDR8_0              GPIO_PUPDR_PUPD8_0
N#define GPIO_PUPDR_PUPDR8_1              GPIO_PUPDR_PUPD8_1
N#define GPIO_PUPDR_PUPDR9                GPIO_PUPDR_PUPD9
N#define GPIO_PUPDR_PUPDR9_0              GPIO_PUPDR_PUPD9_0
N#define GPIO_PUPDR_PUPDR9_1              GPIO_PUPDR_PUPD9_1
N#define GPIO_PUPDR_PUPDR10               GPIO_PUPDR_PUPD10
N#define GPIO_PUPDR_PUPDR10_0             GPIO_PUPDR_PUPD10_0
N#define GPIO_PUPDR_PUPDR10_1             GPIO_PUPDR_PUPD10_1
N#define GPIO_PUPDR_PUPDR11               GPIO_PUPDR_PUPD11
N#define GPIO_PUPDR_PUPDR11_0             GPIO_PUPDR_PUPD11_0
N#define GPIO_PUPDR_PUPDR11_1             GPIO_PUPDR_PUPD11_1
N#define GPIO_PUPDR_PUPDR12               GPIO_PUPDR_PUPD12
N#define GPIO_PUPDR_PUPDR12_0             GPIO_PUPDR_PUPD12_0
N#define GPIO_PUPDR_PUPDR12_1             GPIO_PUPDR_PUPD12_1
N#define GPIO_PUPDR_PUPDR13               GPIO_PUPDR_PUPD13
N#define GPIO_PUPDR_PUPDR13_0             GPIO_PUPDR_PUPD13_0
N#define GPIO_PUPDR_PUPDR13_1             GPIO_PUPDR_PUPD13_1
N#define GPIO_PUPDR_PUPDR14               GPIO_PUPDR_PUPD14
N#define GPIO_PUPDR_PUPDR14_0             GPIO_PUPDR_PUPD14_0
N#define GPIO_PUPDR_PUPDR14_1             GPIO_PUPDR_PUPD14_1
N#define GPIO_PUPDR_PUPDR15               GPIO_PUPDR_PUPD15
N#define GPIO_PUPDR_PUPDR15_0             GPIO_PUPDR_PUPD15_0
N#define GPIO_PUPDR_PUPDR15_1             GPIO_PUPDR_PUPD15_1
N
N/******************  Bits definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_ID0_Pos                 (0U)                                  
N#define GPIO_IDR_ID0_Msk                 (0x1UL << GPIO_IDR_ID0_Pos)            /*!< 0x00000001 */
N#define GPIO_IDR_ID0                     GPIO_IDR_ID0_Msk                      
N#define GPIO_IDR_ID1_Pos                 (1U)                                  
N#define GPIO_IDR_ID1_Msk                 (0x1UL << GPIO_IDR_ID1_Pos)            /*!< 0x00000002 */
N#define GPIO_IDR_ID1                     GPIO_IDR_ID1_Msk                      
N#define GPIO_IDR_ID2_Pos                 (2U)                                  
N#define GPIO_IDR_ID2_Msk                 (0x1UL << GPIO_IDR_ID2_Pos)            /*!< 0x00000004 */
N#define GPIO_IDR_ID2                     GPIO_IDR_ID2_Msk                      
N#define GPIO_IDR_ID3_Pos                 (3U)                                  
N#define GPIO_IDR_ID3_Msk                 (0x1UL << GPIO_IDR_ID3_Pos)            /*!< 0x00000008 */
N#define GPIO_IDR_ID3                     GPIO_IDR_ID3_Msk                      
N#define GPIO_IDR_ID4_Pos                 (4U)                                  
N#define GPIO_IDR_ID4_Msk                 (0x1UL << GPIO_IDR_ID4_Pos)            /*!< 0x00000010 */
N#define GPIO_IDR_ID4                     GPIO_IDR_ID4_Msk                      
N#define GPIO_IDR_ID5_Pos                 (5U)                                  
N#define GPIO_IDR_ID5_Msk                 (0x1UL << GPIO_IDR_ID5_Pos)            /*!< 0x00000020 */
N#define GPIO_IDR_ID5                     GPIO_IDR_ID5_Msk                      
N#define GPIO_IDR_ID6_Pos                 (6U)                                  
N#define GPIO_IDR_ID6_Msk                 (0x1UL << GPIO_IDR_ID6_Pos)            /*!< 0x00000040 */
N#define GPIO_IDR_ID6                     GPIO_IDR_ID6_Msk                      
N#define GPIO_IDR_ID7_Pos                 (7U)                                  
N#define GPIO_IDR_ID7_Msk                 (0x1UL << GPIO_IDR_ID7_Pos)            /*!< 0x00000080 */
N#define GPIO_IDR_ID7                     GPIO_IDR_ID7_Msk                      
N#define GPIO_IDR_ID8_Pos                 (8U)                                  
N#define GPIO_IDR_ID8_Msk                 (0x1UL << GPIO_IDR_ID8_Pos)            /*!< 0x00000100 */
N#define GPIO_IDR_ID8                     GPIO_IDR_ID8_Msk                      
N#define GPIO_IDR_ID9_Pos                 (9U)                                  
N#define GPIO_IDR_ID9_Msk                 (0x1UL << GPIO_IDR_ID9_Pos)            /*!< 0x00000200 */
N#define GPIO_IDR_ID9                     GPIO_IDR_ID9_Msk                      
N#define GPIO_IDR_ID10_Pos                (10U)                                 
N#define GPIO_IDR_ID10_Msk                (0x1UL << GPIO_IDR_ID10_Pos)           /*!< 0x00000400 */
N#define GPIO_IDR_ID10                    GPIO_IDR_ID10_Msk                     
N#define GPIO_IDR_ID11_Pos                (11U)                                 
N#define GPIO_IDR_ID11_Msk                (0x1UL << GPIO_IDR_ID11_Pos)           /*!< 0x00000800 */
N#define GPIO_IDR_ID11                    GPIO_IDR_ID11_Msk                     
N#define GPIO_IDR_ID12_Pos                (12U)                                 
N#define GPIO_IDR_ID12_Msk                (0x1UL << GPIO_IDR_ID12_Pos)           /*!< 0x00001000 */
N#define GPIO_IDR_ID12                    GPIO_IDR_ID12_Msk                     
N#define GPIO_IDR_ID13_Pos                (13U)                                 
N#define GPIO_IDR_ID13_Msk                (0x1UL << GPIO_IDR_ID13_Pos)           /*!< 0x00002000 */
N#define GPIO_IDR_ID13                    GPIO_IDR_ID13_Msk                     
N#define GPIO_IDR_ID14_Pos                (14U)                                 
N#define GPIO_IDR_ID14_Msk                (0x1UL << GPIO_IDR_ID14_Pos)           /*!< 0x00004000 */
N#define GPIO_IDR_ID14                    GPIO_IDR_ID14_Msk                     
N#define GPIO_IDR_ID15_Pos                (15U)                                 
N#define GPIO_IDR_ID15_Msk                (0x1UL << GPIO_IDR_ID15_Pos)           /*!< 0x00008000 */
N#define GPIO_IDR_ID15                    GPIO_IDR_ID15_Msk                     
N
N/* Legacy defines */
N#define GPIO_IDR_IDR_0                   GPIO_IDR_ID0
N#define GPIO_IDR_IDR_1                   GPIO_IDR_ID1
N#define GPIO_IDR_IDR_2                   GPIO_IDR_ID2
N#define GPIO_IDR_IDR_3                   GPIO_IDR_ID3
N#define GPIO_IDR_IDR_4                   GPIO_IDR_ID4
N#define GPIO_IDR_IDR_5                   GPIO_IDR_ID5
N#define GPIO_IDR_IDR_6                   GPIO_IDR_ID6
N#define GPIO_IDR_IDR_7                   GPIO_IDR_ID7
N#define GPIO_IDR_IDR_8                   GPIO_IDR_ID8
N#define GPIO_IDR_IDR_9                   GPIO_IDR_ID9
N#define GPIO_IDR_IDR_10                  GPIO_IDR_ID10
N#define GPIO_IDR_IDR_11                  GPIO_IDR_ID11
N#define GPIO_IDR_IDR_12                  GPIO_IDR_ID12
N#define GPIO_IDR_IDR_13                  GPIO_IDR_ID13
N#define GPIO_IDR_IDR_14                  GPIO_IDR_ID14
N#define GPIO_IDR_IDR_15                  GPIO_IDR_ID15
N
N/******************  Bits definition for GPIO_ODR register  *******************/
N#define GPIO_ODR_OD0_Pos                 (0U)                                  
N#define GPIO_ODR_OD0_Msk                 (0x1UL << GPIO_ODR_OD0_Pos)            /*!< 0x00000001 */
N#define GPIO_ODR_OD0                     GPIO_ODR_OD0_Msk                      
N#define GPIO_ODR_OD1_Pos                 (1U)                                  
N#define GPIO_ODR_OD1_Msk                 (0x1UL << GPIO_ODR_OD1_Pos)            /*!< 0x00000002 */
N#define GPIO_ODR_OD1                     GPIO_ODR_OD1_Msk                      
N#define GPIO_ODR_OD2_Pos                 (2U)                                  
N#define GPIO_ODR_OD2_Msk                 (0x1UL << GPIO_ODR_OD2_Pos)            /*!< 0x00000004 */
N#define GPIO_ODR_OD2                     GPIO_ODR_OD2_Msk                      
N#define GPIO_ODR_OD3_Pos                 (3U)                                  
N#define GPIO_ODR_OD3_Msk                 (0x1UL << GPIO_ODR_OD3_Pos)            /*!< 0x00000008 */
N#define GPIO_ODR_OD3                     GPIO_ODR_OD3_Msk                      
N#define GPIO_ODR_OD4_Pos                 (4U)                                  
N#define GPIO_ODR_OD4_Msk                 (0x1UL << GPIO_ODR_OD4_Pos)            /*!< 0x00000010 */
N#define GPIO_ODR_OD4                     GPIO_ODR_OD4_Msk                      
N#define GPIO_ODR_OD5_Pos                 (5U)                                  
N#define GPIO_ODR_OD5_Msk                 (0x1UL << GPIO_ODR_OD5_Pos)            /*!< 0x00000020 */
N#define GPIO_ODR_OD5                     GPIO_ODR_OD5_Msk                      
N#define GPIO_ODR_OD6_Pos                 (6U)                                  
N#define GPIO_ODR_OD6_Msk                 (0x1UL << GPIO_ODR_OD6_Pos)            /*!< 0x00000040 */
N#define GPIO_ODR_OD6                     GPIO_ODR_OD6_Msk                      
N#define GPIO_ODR_OD7_Pos                 (7U)                                  
N#define GPIO_ODR_OD7_Msk                 (0x1UL << GPIO_ODR_OD7_Pos)            /*!< 0x00000080 */
N#define GPIO_ODR_OD7                     GPIO_ODR_OD7_Msk                      
N#define GPIO_ODR_OD8_Pos                 (8U)                                  
N#define GPIO_ODR_OD8_Msk                 (0x1UL << GPIO_ODR_OD8_Pos)            /*!< 0x00000100 */
N#define GPIO_ODR_OD8                     GPIO_ODR_OD8_Msk                      
N#define GPIO_ODR_OD9_Pos                 (9U)                                  
N#define GPIO_ODR_OD9_Msk                 (0x1UL << GPIO_ODR_OD9_Pos)            /*!< 0x00000200 */
N#define GPIO_ODR_OD9                     GPIO_ODR_OD9_Msk                      
N#define GPIO_ODR_OD10_Pos                (10U)                                 
N#define GPIO_ODR_OD10_Msk                (0x1UL << GPIO_ODR_OD10_Pos)           /*!< 0x00000400 */
N#define GPIO_ODR_OD10                    GPIO_ODR_OD10_Msk                     
N#define GPIO_ODR_OD11_Pos                (11U)                                 
N#define GPIO_ODR_OD11_Msk                (0x1UL << GPIO_ODR_OD11_Pos)           /*!< 0x00000800 */
N#define GPIO_ODR_OD11                    GPIO_ODR_OD11_Msk                     
N#define GPIO_ODR_OD12_Pos                (12U)                                 
N#define GPIO_ODR_OD12_Msk                (0x1UL << GPIO_ODR_OD12_Pos)           /*!< 0x00001000 */
N#define GPIO_ODR_OD12                    GPIO_ODR_OD12_Msk                     
N#define GPIO_ODR_OD13_Pos                (13U)                                 
N#define GPIO_ODR_OD13_Msk                (0x1UL << GPIO_ODR_OD13_Pos)           /*!< 0x00002000 */
N#define GPIO_ODR_OD13                    GPIO_ODR_OD13_Msk                     
N#define GPIO_ODR_OD14_Pos                (14U)                                 
N#define GPIO_ODR_OD14_Msk                (0x1UL << GPIO_ODR_OD14_Pos)           /*!< 0x00004000 */
N#define GPIO_ODR_OD14                    GPIO_ODR_OD14_Msk                     
N#define GPIO_ODR_OD15_Pos                (15U)                                 
N#define GPIO_ODR_OD15_Msk                (0x1UL << GPIO_ODR_OD15_Pos)           /*!< 0x00008000 */
N#define GPIO_ODR_OD15                    GPIO_ODR_OD15_Msk                     
N/* Legacy defines */
N#define GPIO_ODR_ODR_0                   GPIO_ODR_OD0
N#define GPIO_ODR_ODR_1                   GPIO_ODR_OD1
N#define GPIO_ODR_ODR_2                   GPIO_ODR_OD2
N#define GPIO_ODR_ODR_3                   GPIO_ODR_OD3
N#define GPIO_ODR_ODR_4                   GPIO_ODR_OD4
N#define GPIO_ODR_ODR_5                   GPIO_ODR_OD5
N#define GPIO_ODR_ODR_6                   GPIO_ODR_OD6
N#define GPIO_ODR_ODR_7                   GPIO_ODR_OD7
N#define GPIO_ODR_ODR_8                   GPIO_ODR_OD8
N#define GPIO_ODR_ODR_9                   GPIO_ODR_OD9
N#define GPIO_ODR_ODR_10                  GPIO_ODR_OD10
N#define GPIO_ODR_ODR_11                  GPIO_ODR_OD11
N#define GPIO_ODR_ODR_12                  GPIO_ODR_OD12
N#define GPIO_ODR_ODR_13                  GPIO_ODR_OD13
N#define GPIO_ODR_ODR_14                  GPIO_ODR_OD14
N#define GPIO_ODR_ODR_15                  GPIO_ODR_OD15
N
N/******************  Bits definition for GPIO_BSRR register  ******************/
N#define GPIO_BSRR_BS0_Pos                (0U)                                  
N#define GPIO_BSRR_BS0_Msk                (0x1UL << GPIO_BSRR_BS0_Pos)           /*!< 0x00000001 */
N#define GPIO_BSRR_BS0                    GPIO_BSRR_BS0_Msk                     
N#define GPIO_BSRR_BS1_Pos                (1U)                                  
N#define GPIO_BSRR_BS1_Msk                (0x1UL << GPIO_BSRR_BS1_Pos)           /*!< 0x00000002 */
N#define GPIO_BSRR_BS1                    GPIO_BSRR_BS1_Msk                     
N#define GPIO_BSRR_BS2_Pos                (2U)                                  
N#define GPIO_BSRR_BS2_Msk                (0x1UL << GPIO_BSRR_BS2_Pos)           /*!< 0x00000004 */
N#define GPIO_BSRR_BS2                    GPIO_BSRR_BS2_Msk                     
N#define GPIO_BSRR_BS3_Pos                (3U)                                  
N#define GPIO_BSRR_BS3_Msk                (0x1UL << GPIO_BSRR_BS3_Pos)           /*!< 0x00000008 */
N#define GPIO_BSRR_BS3                    GPIO_BSRR_BS3_Msk                     
N#define GPIO_BSRR_BS4_Pos                (4U)                                  
N#define GPIO_BSRR_BS4_Msk                (0x1UL << GPIO_BSRR_BS4_Pos)           /*!< 0x00000010 */
N#define GPIO_BSRR_BS4                    GPIO_BSRR_BS4_Msk                     
N#define GPIO_BSRR_BS5_Pos                (5U)                                  
N#define GPIO_BSRR_BS5_Msk                (0x1UL << GPIO_BSRR_BS5_Pos)           /*!< 0x00000020 */
N#define GPIO_BSRR_BS5                    GPIO_BSRR_BS5_Msk                     
N#define GPIO_BSRR_BS6_Pos                (6U)                                  
N#define GPIO_BSRR_BS6_Msk                (0x1UL << GPIO_BSRR_BS6_Pos)           /*!< 0x00000040 */
N#define GPIO_BSRR_BS6                    GPIO_BSRR_BS6_Msk                     
N#define GPIO_BSRR_BS7_Pos                (7U)                                  
N#define GPIO_BSRR_BS7_Msk                (0x1UL << GPIO_BSRR_BS7_Pos)           /*!< 0x00000080 */
N#define GPIO_BSRR_BS7                    GPIO_BSRR_BS7_Msk                     
N#define GPIO_BSRR_BS8_Pos                (8U)                                  
N#define GPIO_BSRR_BS8_Msk                (0x1UL << GPIO_BSRR_BS8_Pos)           /*!< 0x00000100 */
N#define GPIO_BSRR_BS8                    GPIO_BSRR_BS8_Msk                     
N#define GPIO_BSRR_BS9_Pos                (9U)                                  
N#define GPIO_BSRR_BS9_Msk                (0x1UL << GPIO_BSRR_BS9_Pos)           /*!< 0x00000200 */
N#define GPIO_BSRR_BS9                    GPIO_BSRR_BS9_Msk                     
N#define GPIO_BSRR_BS10_Pos               (10U)                                 
N#define GPIO_BSRR_BS10_Msk               (0x1UL << GPIO_BSRR_BS10_Pos)          /*!< 0x00000400 */
N#define GPIO_BSRR_BS10                   GPIO_BSRR_BS10_Msk                    
N#define GPIO_BSRR_BS11_Pos               (11U)                                 
N#define GPIO_BSRR_BS11_Msk               (0x1UL << GPIO_BSRR_BS11_Pos)          /*!< 0x00000800 */
N#define GPIO_BSRR_BS11                   GPIO_BSRR_BS11_Msk                    
N#define GPIO_BSRR_BS12_Pos               (12U)                                 
N#define GPIO_BSRR_BS12_Msk               (0x1UL << GPIO_BSRR_BS12_Pos)          /*!< 0x00001000 */
N#define GPIO_BSRR_BS12                   GPIO_BSRR_BS12_Msk                    
N#define GPIO_BSRR_BS13_Pos               (13U)                                 
N#define GPIO_BSRR_BS13_Msk               (0x1UL << GPIO_BSRR_BS13_Pos)          /*!< 0x00002000 */
N#define GPIO_BSRR_BS13                   GPIO_BSRR_BS13_Msk                    
N#define GPIO_BSRR_BS14_Pos               (14U)                                 
N#define GPIO_BSRR_BS14_Msk               (0x1UL << GPIO_BSRR_BS14_Pos)          /*!< 0x00004000 */
N#define GPIO_BSRR_BS14                   GPIO_BSRR_BS14_Msk                    
N#define GPIO_BSRR_BS15_Pos               (15U)                                 
N#define GPIO_BSRR_BS15_Msk               (0x1UL << GPIO_BSRR_BS15_Pos)          /*!< 0x00008000 */
N#define GPIO_BSRR_BS15                   GPIO_BSRR_BS15_Msk                    
N#define GPIO_BSRR_BR0_Pos                (16U)                                 
N#define GPIO_BSRR_BR0_Msk                (0x1UL << GPIO_BSRR_BR0_Pos)           /*!< 0x00010000 */
N#define GPIO_BSRR_BR0                    GPIO_BSRR_BR0_Msk                     
N#define GPIO_BSRR_BR1_Pos                (17U)                                 
N#define GPIO_BSRR_BR1_Msk                (0x1UL << GPIO_BSRR_BR1_Pos)           /*!< 0x00020000 */
N#define GPIO_BSRR_BR1                    GPIO_BSRR_BR1_Msk                     
N#define GPIO_BSRR_BR2_Pos                (18U)                                 
N#define GPIO_BSRR_BR2_Msk                (0x1UL << GPIO_BSRR_BR2_Pos)           /*!< 0x00040000 */
N#define GPIO_BSRR_BR2                    GPIO_BSRR_BR2_Msk                     
N#define GPIO_BSRR_BR3_Pos                (19U)                                 
N#define GPIO_BSRR_BR3_Msk                (0x1UL << GPIO_BSRR_BR3_Pos)           /*!< 0x00080000 */
N#define GPIO_BSRR_BR3                    GPIO_BSRR_BR3_Msk                     
N#define GPIO_BSRR_BR4_Pos                (20U)                                 
N#define GPIO_BSRR_BR4_Msk                (0x1UL << GPIO_BSRR_BR4_Pos)           /*!< 0x00100000 */
N#define GPIO_BSRR_BR4                    GPIO_BSRR_BR4_Msk                     
N#define GPIO_BSRR_BR5_Pos                (21U)                                 
N#define GPIO_BSRR_BR5_Msk                (0x1UL << GPIO_BSRR_BR5_Pos)           /*!< 0x00200000 */
N#define GPIO_BSRR_BR5                    GPIO_BSRR_BR5_Msk                     
N#define GPIO_BSRR_BR6_Pos                (22U)                                 
N#define GPIO_BSRR_BR6_Msk                (0x1UL << GPIO_BSRR_BR6_Pos)           /*!< 0x00400000 */
N#define GPIO_BSRR_BR6                    GPIO_BSRR_BR6_Msk                     
N#define GPIO_BSRR_BR7_Pos                (23U)                                 
N#define GPIO_BSRR_BR7_Msk                (0x1UL << GPIO_BSRR_BR7_Pos)           /*!< 0x00800000 */
N#define GPIO_BSRR_BR7                    GPIO_BSRR_BR7_Msk                     
N#define GPIO_BSRR_BR8_Pos                (24U)                                 
N#define GPIO_BSRR_BR8_Msk                (0x1UL << GPIO_BSRR_BR8_Pos)           /*!< 0x01000000 */
N#define GPIO_BSRR_BR8                    GPIO_BSRR_BR8_Msk                     
N#define GPIO_BSRR_BR9_Pos                (25U)                                 
N#define GPIO_BSRR_BR9_Msk                (0x1UL << GPIO_BSRR_BR9_Pos)           /*!< 0x02000000 */
N#define GPIO_BSRR_BR9                    GPIO_BSRR_BR9_Msk                     
N#define GPIO_BSRR_BR10_Pos               (26U)                                 
N#define GPIO_BSRR_BR10_Msk               (0x1UL << GPIO_BSRR_BR10_Pos)          /*!< 0x04000000 */
N#define GPIO_BSRR_BR10                   GPIO_BSRR_BR10_Msk                    
N#define GPIO_BSRR_BR11_Pos               (27U)                                 
N#define GPIO_BSRR_BR11_Msk               (0x1UL << GPIO_BSRR_BR11_Pos)          /*!< 0x08000000 */
N#define GPIO_BSRR_BR11                   GPIO_BSRR_BR11_Msk                    
N#define GPIO_BSRR_BR12_Pos               (28U)                                 
N#define GPIO_BSRR_BR12_Msk               (0x1UL << GPIO_BSRR_BR12_Pos)          /*!< 0x10000000 */
N#define GPIO_BSRR_BR12                   GPIO_BSRR_BR12_Msk                    
N#define GPIO_BSRR_BR13_Pos               (29U)                                 
N#define GPIO_BSRR_BR13_Msk               (0x1UL << GPIO_BSRR_BR13_Pos)          /*!< 0x20000000 */
N#define GPIO_BSRR_BR13                   GPIO_BSRR_BR13_Msk                    
N#define GPIO_BSRR_BR14_Pos               (30U)                                 
N#define GPIO_BSRR_BR14_Msk               (0x1UL << GPIO_BSRR_BR14_Pos)          /*!< 0x40000000 */
N#define GPIO_BSRR_BR14                   GPIO_BSRR_BR14_Msk                    
N#define GPIO_BSRR_BR15_Pos               (31U)                                 
N#define GPIO_BSRR_BR15_Msk               (0x1UL << GPIO_BSRR_BR15_Pos)          /*!< 0x80000000 */
N#define GPIO_BSRR_BR15                   GPIO_BSRR_BR15_Msk                    
N
N/* Legacy defines */
N#define GPIO_BSRR_BS_0                   GPIO_BSRR_BS0
N#define GPIO_BSRR_BS_1                   GPIO_BSRR_BS1
N#define GPIO_BSRR_BS_2                   GPIO_BSRR_BS2
N#define GPIO_BSRR_BS_3                   GPIO_BSRR_BS3
N#define GPIO_BSRR_BS_4                   GPIO_BSRR_BS4
N#define GPIO_BSRR_BS_5                   GPIO_BSRR_BS5
N#define GPIO_BSRR_BS_6                   GPIO_BSRR_BS6
N#define GPIO_BSRR_BS_7                   GPIO_BSRR_BS7
N#define GPIO_BSRR_BS_8                   GPIO_BSRR_BS8
N#define GPIO_BSRR_BS_9                   GPIO_BSRR_BS9
N#define GPIO_BSRR_BS_10                  GPIO_BSRR_BS10
N#define GPIO_BSRR_BS_11                  GPIO_BSRR_BS11
N#define GPIO_BSRR_BS_12                  GPIO_BSRR_BS12
N#define GPIO_BSRR_BS_13                  GPIO_BSRR_BS13
N#define GPIO_BSRR_BS_14                  GPIO_BSRR_BS14
N#define GPIO_BSRR_BS_15                  GPIO_BSRR_BS15
N#define GPIO_BSRR_BR_0                   GPIO_BSRR_BR0
N#define GPIO_BSRR_BR_1                   GPIO_BSRR_BR1
N#define GPIO_BSRR_BR_2                   GPIO_BSRR_BR2
N#define GPIO_BSRR_BR_3                   GPIO_BSRR_BR3
N#define GPIO_BSRR_BR_4                   GPIO_BSRR_BR4
N#define GPIO_BSRR_BR_5                   GPIO_BSRR_BR5
N#define GPIO_BSRR_BR_6                   GPIO_BSRR_BR6
N#define GPIO_BSRR_BR_7                   GPIO_BSRR_BR7
N#define GPIO_BSRR_BR_8                   GPIO_BSRR_BR8
N#define GPIO_BSRR_BR_9                   GPIO_BSRR_BR9
N#define GPIO_BSRR_BR_10                  GPIO_BSRR_BR10
N#define GPIO_BSRR_BR_11                  GPIO_BSRR_BR11
N#define GPIO_BSRR_BR_12                  GPIO_BSRR_BR12
N#define GPIO_BSRR_BR_13                  GPIO_BSRR_BR13
N#define GPIO_BSRR_BR_14                  GPIO_BSRR_BR14
N#define GPIO_BSRR_BR_15                  GPIO_BSRR_BR15
N#define GPIO_BRR_BR0                     GPIO_BSRR_BR0
N#define GPIO_BRR_BR0_Pos                 GPIO_BSRR_BR0_Pos
N#define GPIO_BRR_BR0_Msk                 GPIO_BSRR_BR0_Msk
N#define GPIO_BRR_BR1                     GPIO_BSRR_BR1
N#define GPIO_BRR_BR1_Pos                 GPIO_BSRR_BR1_Pos
N#define GPIO_BRR_BR1_Msk                 GPIO_BSRR_BR1_Msk
N#define GPIO_BRR_BR2                     GPIO_BSRR_BR2
N#define GPIO_BRR_BR2_Pos                 GPIO_BSRR_BR2_Pos
N#define GPIO_BRR_BR2_Msk                 GPIO_BSRR_BR2_Msk
N#define GPIO_BRR_BR3                     GPIO_BSRR_BR3
N#define GPIO_BRR_BR3_Pos                 GPIO_BSRR_BR3_Pos
N#define GPIO_BRR_BR3_Msk                 GPIO_BSRR_BR3_Msk
N#define GPIO_BRR_BR4                     GPIO_BSRR_BR4
N#define GPIO_BRR_BR4_Pos                 GPIO_BSRR_BR4_Pos
N#define GPIO_BRR_BR4_Msk                 GPIO_BSRR_BR4_Msk
N#define GPIO_BRR_BR5                     GPIO_BSRR_BR5
N#define GPIO_BRR_BR5_Pos                 GPIO_BSRR_BR5_Pos
N#define GPIO_BRR_BR5_Msk                 GPIO_BSRR_BR5_Msk
N#define GPIO_BRR_BR6                     GPIO_BSRR_BR6
N#define GPIO_BRR_BR6_Pos                 GPIO_BSRR_BR6_Pos
N#define GPIO_BRR_BR6_Msk                 GPIO_BSRR_BR6_Msk
N#define GPIO_BRR_BR7                     GPIO_BSRR_BR7
N#define GPIO_BRR_BR7_Pos                 GPIO_BSRR_BR7_Pos
N#define GPIO_BRR_BR7_Msk                 GPIO_BSRR_BR7_Msk
N#define GPIO_BRR_BR8                     GPIO_BSRR_BR8
N#define GPIO_BRR_BR8_Pos                 GPIO_BSRR_BR8_Pos
N#define GPIO_BRR_BR8_Msk                 GPIO_BSRR_BR8_Msk
N#define GPIO_BRR_BR9                     GPIO_BSRR_BR9
N#define GPIO_BRR_BR9_Pos                 GPIO_BSRR_BR9_Pos
N#define GPIO_BRR_BR9_Msk                 GPIO_BSRR_BR9_Msk
N#define GPIO_BRR_BR10                    GPIO_BSRR_BR10
N#define GPIO_BRR_BR10_Pos                GPIO_BSRR_BR10_Pos
N#define GPIO_BRR_BR10_Msk                GPIO_BSRR_BR10_Msk
N#define GPIO_BRR_BR11                    GPIO_BSRR_BR11
N#define GPIO_BRR_BR11_Pos                GPIO_BSRR_BR11_Pos
N#define GPIO_BRR_BR11_Msk                GPIO_BSRR_BR11_Msk
N#define GPIO_BRR_BR12                    GPIO_BSRR_BR12
N#define GPIO_BRR_BR12_Pos                GPIO_BSRR_BR12_Pos
N#define GPIO_BRR_BR12_Msk                GPIO_BSRR_BR12_Msk
N#define GPIO_BRR_BR13                    GPIO_BSRR_BR13
N#define GPIO_BRR_BR13_Pos                GPIO_BSRR_BR13_Pos
N#define GPIO_BRR_BR13_Msk                GPIO_BSRR_BR13_Msk
N#define GPIO_BRR_BR14                    GPIO_BSRR_BR14
N#define GPIO_BRR_BR14_Pos                GPIO_BSRR_BR14_Pos
N#define GPIO_BRR_BR14_Msk                GPIO_BSRR_BR14_Msk
N#define GPIO_BRR_BR15                    GPIO_BSRR_BR15
N#define GPIO_BRR_BR15_Pos                GPIO_BSRR_BR15_Pos
N#define GPIO_BRR_BR15_Msk                GPIO_BSRR_BR15_Msk 
N/****************** Bit definition for GPIO_LCKR register *********************/
N#define GPIO_LCKR_LCK0_Pos               (0U)                                  
N#define GPIO_LCKR_LCK0_Msk               (0x1UL << GPIO_LCKR_LCK0_Pos)          /*!< 0x00000001 */
N#define GPIO_LCKR_LCK0                   GPIO_LCKR_LCK0_Msk                    
N#define GPIO_LCKR_LCK1_Pos               (1U)                                  
N#define GPIO_LCKR_LCK1_Msk               (0x1UL << GPIO_LCKR_LCK1_Pos)          /*!< 0x00000002 */
N#define GPIO_LCKR_LCK1                   GPIO_LCKR_LCK1_Msk                    
N#define GPIO_LCKR_LCK2_Pos               (2U)                                  
N#define GPIO_LCKR_LCK2_Msk               (0x1UL << GPIO_LCKR_LCK2_Pos)          /*!< 0x00000004 */
N#define GPIO_LCKR_LCK2                   GPIO_LCKR_LCK2_Msk                    
N#define GPIO_LCKR_LCK3_Pos               (3U)                                  
N#define GPIO_LCKR_LCK3_Msk               (0x1UL << GPIO_LCKR_LCK3_Pos)          /*!< 0x00000008 */
N#define GPIO_LCKR_LCK3                   GPIO_LCKR_LCK3_Msk                    
N#define GPIO_LCKR_LCK4_Pos               (4U)                                  
N#define GPIO_LCKR_LCK4_Msk               (0x1UL << GPIO_LCKR_LCK4_Pos)          /*!< 0x00000010 */
N#define GPIO_LCKR_LCK4                   GPIO_LCKR_LCK4_Msk                    
N#define GPIO_LCKR_LCK5_Pos               (5U)                                  
N#define GPIO_LCKR_LCK5_Msk               (0x1UL << GPIO_LCKR_LCK5_Pos)          /*!< 0x00000020 */
N#define GPIO_LCKR_LCK5                   GPIO_LCKR_LCK5_Msk                    
N#define GPIO_LCKR_LCK6_Pos               (6U)                                  
N#define GPIO_LCKR_LCK6_Msk               (0x1UL << GPIO_LCKR_LCK6_Pos)          /*!< 0x00000040 */
N#define GPIO_LCKR_LCK6                   GPIO_LCKR_LCK6_Msk                    
N#define GPIO_LCKR_LCK7_Pos               (7U)                                  
N#define GPIO_LCKR_LCK7_Msk               (0x1UL << GPIO_LCKR_LCK7_Pos)          /*!< 0x00000080 */
N#define GPIO_LCKR_LCK7                   GPIO_LCKR_LCK7_Msk                    
N#define GPIO_LCKR_LCK8_Pos               (8U)                                  
N#define GPIO_LCKR_LCK8_Msk               (0x1UL << GPIO_LCKR_LCK8_Pos)          /*!< 0x00000100 */
N#define GPIO_LCKR_LCK8                   GPIO_LCKR_LCK8_Msk                    
N#define GPIO_LCKR_LCK9_Pos               (9U)                                  
N#define GPIO_LCKR_LCK9_Msk               (0x1UL << GPIO_LCKR_LCK9_Pos)          /*!< 0x00000200 */
N#define GPIO_LCKR_LCK9                   GPIO_LCKR_LCK9_Msk                    
N#define GPIO_LCKR_LCK10_Pos              (10U)                                 
N#define GPIO_LCKR_LCK10_Msk              (0x1UL << GPIO_LCKR_LCK10_Pos)         /*!< 0x00000400 */
N#define GPIO_LCKR_LCK10                  GPIO_LCKR_LCK10_Msk                   
N#define GPIO_LCKR_LCK11_Pos              (11U)                                 
N#define GPIO_LCKR_LCK11_Msk              (0x1UL << GPIO_LCKR_LCK11_Pos)         /*!< 0x00000800 */
N#define GPIO_LCKR_LCK11                  GPIO_LCKR_LCK11_Msk                   
N#define GPIO_LCKR_LCK12_Pos              (12U)                                 
N#define GPIO_LCKR_LCK12_Msk              (0x1UL << GPIO_LCKR_LCK12_Pos)         /*!< 0x00001000 */
N#define GPIO_LCKR_LCK12                  GPIO_LCKR_LCK12_Msk                   
N#define GPIO_LCKR_LCK13_Pos              (13U)                                 
N#define GPIO_LCKR_LCK13_Msk              (0x1UL << GPIO_LCKR_LCK13_Pos)         /*!< 0x00002000 */
N#define GPIO_LCKR_LCK13                  GPIO_LCKR_LCK13_Msk                   
N#define GPIO_LCKR_LCK14_Pos              (14U)                                 
N#define GPIO_LCKR_LCK14_Msk              (0x1UL << GPIO_LCKR_LCK14_Pos)         /*!< 0x00004000 */
N#define GPIO_LCKR_LCK14                  GPIO_LCKR_LCK14_Msk                   
N#define GPIO_LCKR_LCK15_Pos              (15U)                                 
N#define GPIO_LCKR_LCK15_Msk              (0x1UL << GPIO_LCKR_LCK15_Pos)         /*!< 0x00008000 */
N#define GPIO_LCKR_LCK15                  GPIO_LCKR_LCK15_Msk                   
N#define GPIO_LCKR_LCKK_Pos               (16U)                                 
N#define GPIO_LCKR_LCKK_Msk               (0x1UL << GPIO_LCKR_LCKK_Pos)          /*!< 0x00010000 */
N#define GPIO_LCKR_LCKK                   GPIO_LCKR_LCKK_Msk                    
N/****************** Bit definition for GPIO_AFRL register *********************/
N#define GPIO_AFRL_AFSEL0_Pos             (0U)                                  
N#define GPIO_AFRL_AFSEL0_Msk             (0xFUL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x0000000F */
N#define GPIO_AFRL_AFSEL0                 GPIO_AFRL_AFSEL0_Msk                  
N#define GPIO_AFRL_AFSEL0_0               (0x1UL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x00000001 */
N#define GPIO_AFRL_AFSEL0_1               (0x2UL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x00000002 */
N#define GPIO_AFRL_AFSEL0_2               (0x4UL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x00000004 */
N#define GPIO_AFRL_AFSEL0_3               (0x8UL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x00000008 */
N#define GPIO_AFRL_AFSEL1_Pos             (4U)                                  
N#define GPIO_AFRL_AFSEL1_Msk             (0xFUL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x000000F0 */
N#define GPIO_AFRL_AFSEL1                 GPIO_AFRL_AFSEL1_Msk                  
N#define GPIO_AFRL_AFSEL1_0               (0x1UL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x00000010 */
N#define GPIO_AFRL_AFSEL1_1               (0x2UL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x00000020 */
N#define GPIO_AFRL_AFSEL1_2               (0x4UL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x00000040 */
N#define GPIO_AFRL_AFSEL1_3               (0x8UL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x00000080 */
N#define GPIO_AFRL_AFSEL2_Pos             (8U)                                  
N#define GPIO_AFRL_AFSEL2_Msk             (0xFUL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000F00 */
N#define GPIO_AFRL_AFSEL2                 GPIO_AFRL_AFSEL2_Msk                  
N#define GPIO_AFRL_AFSEL2_0               (0x1UL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000100 */
N#define GPIO_AFRL_AFSEL2_1               (0x2UL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000200 */
N#define GPIO_AFRL_AFSEL2_2               (0x4UL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000400 */
N#define GPIO_AFRL_AFSEL2_3               (0x8UL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000800 */
N#define GPIO_AFRL_AFSEL3_Pos             (12U)                                 
N#define GPIO_AFRL_AFSEL3_Msk             (0xFUL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x0000F000 */
N#define GPIO_AFRL_AFSEL3                 GPIO_AFRL_AFSEL3_Msk                  
N#define GPIO_AFRL_AFSEL3_0               (0x1UL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x00001000 */
N#define GPIO_AFRL_AFSEL3_1               (0x2UL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x00002000 */
N#define GPIO_AFRL_AFSEL3_2               (0x4UL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x00004000 */
N#define GPIO_AFRL_AFSEL3_3               (0x8UL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x00008000 */
N#define GPIO_AFRL_AFSEL4_Pos             (16U)                                 
N#define GPIO_AFRL_AFSEL4_Msk             (0xFUL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x000F0000 */
N#define GPIO_AFRL_AFSEL4                 GPIO_AFRL_AFSEL4_Msk                  
N#define GPIO_AFRL_AFSEL4_0               (0x1UL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x00010000 */
N#define GPIO_AFRL_AFSEL4_1               (0x2UL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x00020000 */
N#define GPIO_AFRL_AFSEL4_2               (0x4UL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x00040000 */
N#define GPIO_AFRL_AFSEL4_3               (0x8UL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x00080000 */
N#define GPIO_AFRL_AFSEL5_Pos             (20U)                                 
N#define GPIO_AFRL_AFSEL5_Msk             (0xFUL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00F00000 */
N#define GPIO_AFRL_AFSEL5                 GPIO_AFRL_AFSEL5_Msk                  
N#define GPIO_AFRL_AFSEL5_0               (0x1UL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00100000 */
N#define GPIO_AFRL_AFSEL5_1               (0x2UL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00200000 */
N#define GPIO_AFRL_AFSEL5_2               (0x4UL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00400000 */
N#define GPIO_AFRL_AFSEL5_3               (0x8UL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00800000 */
N#define GPIO_AFRL_AFSEL6_Pos             (24U)                                 
N#define GPIO_AFRL_AFSEL6_Msk             (0xFUL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x0F000000 */
N#define GPIO_AFRL_AFSEL6                 GPIO_AFRL_AFSEL6_Msk                  
N#define GPIO_AFRL_AFSEL6_0               (0x1UL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x01000000 */
N#define GPIO_AFRL_AFSEL6_1               (0x2UL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x02000000 */
N#define GPIO_AFRL_AFSEL6_2               (0x4UL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x04000000 */
N#define GPIO_AFRL_AFSEL6_3               (0x8UL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x08000000 */
N#define GPIO_AFRL_AFSEL7_Pos             (28U)                                 
N#define GPIO_AFRL_AFSEL7_Msk             (0xFUL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0xF0000000 */
N#define GPIO_AFRL_AFSEL7                 GPIO_AFRL_AFSEL7_Msk                  
N#define GPIO_AFRL_AFSEL7_0               (0x1UL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0x10000000 */
N#define GPIO_AFRL_AFSEL7_1               (0x2UL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0x20000000 */
N#define GPIO_AFRL_AFSEL7_2               (0x4UL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0x40000000 */
N#define GPIO_AFRL_AFSEL7_3               (0x8UL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_AFRL_AFRL0                  GPIO_AFRL_AFSEL0
N#define GPIO_AFRL_AFRL0_0                GPIO_AFRL_AFSEL0_0
N#define GPIO_AFRL_AFRL0_1                GPIO_AFRL_AFSEL0_1
N#define GPIO_AFRL_AFRL0_2                GPIO_AFRL_AFSEL0_2
N#define GPIO_AFRL_AFRL0_3                GPIO_AFRL_AFSEL0_3
N#define GPIO_AFRL_AFRL1                  GPIO_AFRL_AFSEL1
N#define GPIO_AFRL_AFRL1_0                GPIO_AFRL_AFSEL1_0
N#define GPIO_AFRL_AFRL1_1                GPIO_AFRL_AFSEL1_1
N#define GPIO_AFRL_AFRL1_2                GPIO_AFRL_AFSEL1_2
N#define GPIO_AFRL_AFRL1_3                GPIO_AFRL_AFSEL1_3
N#define GPIO_AFRL_AFRL2                  GPIO_AFRL_AFSEL2
N#define GPIO_AFRL_AFRL2_0                GPIO_AFRL_AFSEL2_0
N#define GPIO_AFRL_AFRL2_1                GPIO_AFRL_AFSEL2_1
N#define GPIO_AFRL_AFRL2_2                GPIO_AFRL_AFSEL2_2
N#define GPIO_AFRL_AFRL2_3                GPIO_AFRL_AFSEL2_3
N#define GPIO_AFRL_AFRL3                  GPIO_AFRL_AFSEL3
N#define GPIO_AFRL_AFRL3_0                GPIO_AFRL_AFSEL3_0
N#define GPIO_AFRL_AFRL3_1                GPIO_AFRL_AFSEL3_1
N#define GPIO_AFRL_AFRL3_2                GPIO_AFRL_AFSEL3_2
N#define GPIO_AFRL_AFRL3_3                GPIO_AFRL_AFSEL3_3
N#define GPIO_AFRL_AFRL4                  GPIO_AFRL_AFSEL4
N#define GPIO_AFRL_AFRL4_0                GPIO_AFRL_AFSEL4_0
N#define GPIO_AFRL_AFRL4_1                GPIO_AFRL_AFSEL4_1
N#define GPIO_AFRL_AFRL4_2                GPIO_AFRL_AFSEL4_2
N#define GPIO_AFRL_AFRL4_3                GPIO_AFRL_AFSEL4_3
N#define GPIO_AFRL_AFRL5                  GPIO_AFRL_AFSEL5
N#define GPIO_AFRL_AFRL5_0                GPIO_AFRL_AFSEL5_0
N#define GPIO_AFRL_AFRL5_1                GPIO_AFRL_AFSEL5_1
N#define GPIO_AFRL_AFRL5_2                GPIO_AFRL_AFSEL5_2
N#define GPIO_AFRL_AFRL5_3                GPIO_AFRL_AFSEL5_3
N#define GPIO_AFRL_AFRL6                  GPIO_AFRL_AFSEL6
N#define GPIO_AFRL_AFRL6_0                GPIO_AFRL_AFSEL6_0
N#define GPIO_AFRL_AFRL6_1                GPIO_AFRL_AFSEL6_1
N#define GPIO_AFRL_AFRL6_2                GPIO_AFRL_AFSEL6_2
N#define GPIO_AFRL_AFRL6_3                GPIO_AFRL_AFSEL6_3
N#define GPIO_AFRL_AFRL7                  GPIO_AFRL_AFSEL7
N#define GPIO_AFRL_AFRL7_0                GPIO_AFRL_AFSEL7_0
N#define GPIO_AFRL_AFRL7_1                GPIO_AFRL_AFSEL7_1
N#define GPIO_AFRL_AFRL7_2                GPIO_AFRL_AFSEL7_2
N#define GPIO_AFRL_AFRL7_3                GPIO_AFRL_AFSEL7_3
N
N/****************** Bit definition for GPIO_AFRH register *********************/
N#define GPIO_AFRH_AFSEL8_Pos             (0U)                                  
N#define GPIO_AFRH_AFSEL8_Msk             (0xFUL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x0000000F */
N#define GPIO_AFRH_AFSEL8                 GPIO_AFRH_AFSEL8_Msk                  
N#define GPIO_AFRH_AFSEL8_0               (0x1UL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x00000001 */
N#define GPIO_AFRH_AFSEL8_1               (0x2UL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x00000002 */
N#define GPIO_AFRH_AFSEL8_2               (0x4UL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x00000004 */
N#define GPIO_AFRH_AFSEL8_3               (0x8UL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x00000008 */
N#define GPIO_AFRH_AFSEL9_Pos             (4U)                                  
N#define GPIO_AFRH_AFSEL9_Msk             (0xFUL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x000000F0 */
N#define GPIO_AFRH_AFSEL9                 GPIO_AFRH_AFSEL9_Msk                  
N#define GPIO_AFRH_AFSEL9_0               (0x1UL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x00000010 */
N#define GPIO_AFRH_AFSEL9_1               (0x2UL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x00000020 */
N#define GPIO_AFRH_AFSEL9_2               (0x4UL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x00000040 */
N#define GPIO_AFRH_AFSEL9_3               (0x8UL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x00000080 */
N#define GPIO_AFRH_AFSEL10_Pos            (8U)                                  
N#define GPIO_AFRH_AFSEL10_Msk            (0xFUL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000F00 */
N#define GPIO_AFRH_AFSEL10                GPIO_AFRH_AFSEL10_Msk                 
N#define GPIO_AFRH_AFSEL10_0              (0x1UL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000100 */
N#define GPIO_AFRH_AFSEL10_1              (0x2UL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000200 */
N#define GPIO_AFRH_AFSEL10_2              (0x4UL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000400 */
N#define GPIO_AFRH_AFSEL10_3              (0x8UL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000800 */
N#define GPIO_AFRH_AFSEL11_Pos            (12U)                                 
N#define GPIO_AFRH_AFSEL11_Msk            (0xFUL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x0000F000 */
N#define GPIO_AFRH_AFSEL11                GPIO_AFRH_AFSEL11_Msk                 
N#define GPIO_AFRH_AFSEL11_0              (0x1UL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x00001000 */
N#define GPIO_AFRH_AFSEL11_1              (0x2UL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x00002000 */
N#define GPIO_AFRH_AFSEL11_2              (0x4UL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x00004000 */
N#define GPIO_AFRH_AFSEL11_3              (0x8UL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x00008000 */
N#define GPIO_AFRH_AFSEL12_Pos            (16U)                                 
N#define GPIO_AFRH_AFSEL12_Msk            (0xFUL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x000F0000 */
N#define GPIO_AFRH_AFSEL12                GPIO_AFRH_AFSEL12_Msk                 
N#define GPIO_AFRH_AFSEL12_0              (0x1UL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x00010000 */
N#define GPIO_AFRH_AFSEL12_1              (0x2UL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x00020000 */
N#define GPIO_AFRH_AFSEL12_2              (0x4UL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x00040000 */
N#define GPIO_AFRH_AFSEL12_3              (0x8UL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x00080000 */
N#define GPIO_AFRH_AFSEL13_Pos            (20U)                                 
N#define GPIO_AFRH_AFSEL13_Msk            (0xFUL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00F00000 */
N#define GPIO_AFRH_AFSEL13                GPIO_AFRH_AFSEL13_Msk                 
N#define GPIO_AFRH_AFSEL13_0              (0x1UL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00100000 */
N#define GPIO_AFRH_AFSEL13_1              (0x2UL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00200000 */
N#define GPIO_AFRH_AFSEL13_2              (0x4UL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00400000 */
N#define GPIO_AFRH_AFSEL13_3              (0x8UL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00800000 */
N#define GPIO_AFRH_AFSEL14_Pos            (24U)                                 
N#define GPIO_AFRH_AFSEL14_Msk            (0xFUL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x0F000000 */
N#define GPIO_AFRH_AFSEL14                GPIO_AFRH_AFSEL14_Msk                 
N#define GPIO_AFRH_AFSEL14_0              (0x1UL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x01000000 */
N#define GPIO_AFRH_AFSEL14_1              (0x2UL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x02000000 */
N#define GPIO_AFRH_AFSEL14_2              (0x4UL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x04000000 */
N#define GPIO_AFRH_AFSEL14_3              (0x8UL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x08000000 */
N#define GPIO_AFRH_AFSEL15_Pos            (28U)                                 
N#define GPIO_AFRH_AFSEL15_Msk            (0xFUL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0xF0000000 */
N#define GPIO_AFRH_AFSEL15                GPIO_AFRH_AFSEL15_Msk                 
N#define GPIO_AFRH_AFSEL15_0              (0x1UL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0x10000000 */
N#define GPIO_AFRH_AFSEL15_1              (0x2UL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0x20000000 */
N#define GPIO_AFRH_AFSEL15_2              (0x4UL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0x40000000 */
N#define GPIO_AFRH_AFSEL15_3              (0x8UL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_AFRH_AFRH0                  GPIO_AFRH_AFSEL8
N#define GPIO_AFRH_AFRH0_0                GPIO_AFRH_AFSEL8_0
N#define GPIO_AFRH_AFRH0_1                GPIO_AFRH_AFSEL8_1
N#define GPIO_AFRH_AFRH0_2                GPIO_AFRH_AFSEL8_2
N#define GPIO_AFRH_AFRH0_3                GPIO_AFRH_AFSEL8_3
N#define GPIO_AFRH_AFRH1                  GPIO_AFRH_AFSEL9
N#define GPIO_AFRH_AFRH1_0                GPIO_AFRH_AFSEL9_0
N#define GPIO_AFRH_AFRH1_1                GPIO_AFRH_AFSEL9_1
N#define GPIO_AFRH_AFRH1_2                GPIO_AFRH_AFSEL9_2
N#define GPIO_AFRH_AFRH1_3                GPIO_AFRH_AFSEL9_3
N#define GPIO_AFRH_AFRH2                  GPIO_AFRH_AFSEL10
N#define GPIO_AFRH_AFRH2_0                GPIO_AFRH_AFSEL10_0
N#define GPIO_AFRH_AFRH2_1                GPIO_AFRH_AFSEL10_1
N#define GPIO_AFRH_AFRH2_2                GPIO_AFRH_AFSEL10_2
N#define GPIO_AFRH_AFRH2_3                GPIO_AFRH_AFSEL10_3
N#define GPIO_AFRH_AFRH3                  GPIO_AFRH_AFSEL11
N#define GPIO_AFRH_AFRH3_0                GPIO_AFRH_AFSEL11_0
N#define GPIO_AFRH_AFRH3_1                GPIO_AFRH_AFSEL11_1
N#define GPIO_AFRH_AFRH3_2                GPIO_AFRH_AFSEL11_2
N#define GPIO_AFRH_AFRH3_3                GPIO_AFRH_AFSEL11_3
N#define GPIO_AFRH_AFRH4                  GPIO_AFRH_AFSEL12
N#define GPIO_AFRH_AFRH4_0                GPIO_AFRH_AFSEL12_0
N#define GPIO_AFRH_AFRH4_1                GPIO_AFRH_AFSEL12_1
N#define GPIO_AFRH_AFRH4_2                GPIO_AFRH_AFSEL12_2
N#define GPIO_AFRH_AFRH4_3                GPIO_AFRH_AFSEL12_3
N#define GPIO_AFRH_AFRH5                  GPIO_AFRH_AFSEL13
N#define GPIO_AFRH_AFRH5_0                GPIO_AFRH_AFSEL13_0
N#define GPIO_AFRH_AFRH5_1                GPIO_AFRH_AFSEL13_1
N#define GPIO_AFRH_AFRH5_2                GPIO_AFRH_AFSEL13_2
N#define GPIO_AFRH_AFRH5_3                GPIO_AFRH_AFSEL13_3
N#define GPIO_AFRH_AFRH6                  GPIO_AFRH_AFSEL14
N#define GPIO_AFRH_AFRH6_0                GPIO_AFRH_AFSEL14_0
N#define GPIO_AFRH_AFRH6_1                GPIO_AFRH_AFSEL14_1
N#define GPIO_AFRH_AFRH6_2                GPIO_AFRH_AFSEL14_2
N#define GPIO_AFRH_AFRH6_3                GPIO_AFRH_AFSEL14_3
N#define GPIO_AFRH_AFRH7                  GPIO_AFRH_AFSEL15
N#define GPIO_AFRH_AFRH7_0                GPIO_AFRH_AFSEL15_0
N#define GPIO_AFRH_AFRH7_1                GPIO_AFRH_AFSEL15_1
N#define GPIO_AFRH_AFRH7_2                GPIO_AFRH_AFSEL15_2
N#define GPIO_AFRH_AFRH7_3                GPIO_AFRH_AFSEL15_3
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Inter-integrated Circuit Interface                    */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for I2C_CR1 register  ********************/
N#define I2C_CR1_PE_Pos            (0U)                                         
N#define I2C_CR1_PE_Msk            (0x1UL << I2C_CR1_PE_Pos)                     /*!< 0x00000001 */
N#define I2C_CR1_PE                I2C_CR1_PE_Msk                               /*!<Peripheral Enable                             */
N#define I2C_CR1_SMBUS_Pos         (1U)                                         
N#define I2C_CR1_SMBUS_Msk         (0x1UL << I2C_CR1_SMBUS_Pos)                  /*!< 0x00000002 */
N#define I2C_CR1_SMBUS             I2C_CR1_SMBUS_Msk                            /*!<SMBus Mode                                    */
N#define I2C_CR1_SMBTYPE_Pos       (3U)                                         
N#define I2C_CR1_SMBTYPE_Msk       (0x1UL << I2C_CR1_SMBTYPE_Pos)                /*!< 0x00000008 */
N#define I2C_CR1_SMBTYPE           I2C_CR1_SMBTYPE_Msk                          /*!<SMBus Type                                    */
N#define I2C_CR1_ENARP_Pos         (4U)                                         
N#define I2C_CR1_ENARP_Msk         (0x1UL << I2C_CR1_ENARP_Pos)                  /*!< 0x00000010 */
N#define I2C_CR1_ENARP             I2C_CR1_ENARP_Msk                            /*!<ARP Enable                                    */
N#define I2C_CR1_ENPEC_Pos         (5U)                                         
N#define I2C_CR1_ENPEC_Msk         (0x1UL << I2C_CR1_ENPEC_Pos)                  /*!< 0x00000020 */
N#define I2C_CR1_ENPEC             I2C_CR1_ENPEC_Msk                            /*!<PEC Enable                                    */
N#define I2C_CR1_ENGC_Pos          (6U)                                         
N#define I2C_CR1_ENGC_Msk          (0x1UL << I2C_CR1_ENGC_Pos)                   /*!< 0x00000040 */
N#define I2C_CR1_ENGC              I2C_CR1_ENGC_Msk                             /*!<General Call Enable                           */
N#define I2C_CR1_NOSTRETCH_Pos     (7U)                                         
N#define I2C_CR1_NOSTRETCH_Msk     (0x1UL << I2C_CR1_NOSTRETCH_Pos)              /*!< 0x00000080 */
N#define I2C_CR1_NOSTRETCH         I2C_CR1_NOSTRETCH_Msk                        /*!<Clock Stretching Disable (Slave mode)         */
N#define I2C_CR1_START_Pos         (8U)                                         
N#define I2C_CR1_START_Msk         (0x1UL << I2C_CR1_START_Pos)                  /*!< 0x00000100 */
N#define I2C_CR1_START             I2C_CR1_START_Msk                            /*!<Start Generation                              */
N#define I2C_CR1_STOP_Pos          (9U)                                         
N#define I2C_CR1_STOP_Msk          (0x1UL << I2C_CR1_STOP_Pos)                   /*!< 0x00000200 */
N#define I2C_CR1_STOP              I2C_CR1_STOP_Msk                             /*!<Stop Generation                               */
N#define I2C_CR1_ACK_Pos           (10U)                                        
N#define I2C_CR1_ACK_Msk           (0x1UL << I2C_CR1_ACK_Pos)                    /*!< 0x00000400 */
N#define I2C_CR1_ACK               I2C_CR1_ACK_Msk                              /*!<Acknowledge Enable                            */
N#define I2C_CR1_POS_Pos           (11U)                                        
N#define I2C_CR1_POS_Msk           (0x1UL << I2C_CR1_POS_Pos)                    /*!< 0x00000800 */
N#define I2C_CR1_POS               I2C_CR1_POS_Msk                              /*!<Acknowledge/PEC Position (for data reception) */
N#define I2C_CR1_PEC_Pos           (12U)                                        
N#define I2C_CR1_PEC_Msk           (0x1UL << I2C_CR1_PEC_Pos)                    /*!< 0x00001000 */
N#define I2C_CR1_PEC               I2C_CR1_PEC_Msk                              /*!<Packet Error Checking                         */
N#define I2C_CR1_ALERT_Pos         (13U)                                        
N#define I2C_CR1_ALERT_Msk         (0x1UL << I2C_CR1_ALERT_Pos)                  /*!< 0x00002000 */
N#define I2C_CR1_ALERT             I2C_CR1_ALERT_Msk                            /*!<SMBus Alert                                   */
N#define I2C_CR1_SWRST_Pos         (15U)                                        
N#define I2C_CR1_SWRST_Msk         (0x1UL << I2C_CR1_SWRST_Pos)                  /*!< 0x00008000 */
N#define I2C_CR1_SWRST             I2C_CR1_SWRST_Msk                            /*!<Software Reset                                */
N
N/*******************  Bit definition for I2C_CR2 register  ********************/
N#define I2C_CR2_FREQ_Pos          (0U)                                         
N#define I2C_CR2_FREQ_Msk          (0x3FUL << I2C_CR2_FREQ_Pos)                  /*!< 0x0000003F */
N#define I2C_CR2_FREQ              I2C_CR2_FREQ_Msk                             /*!<FREQ[5:0] bits (Peripheral Clock Frequency)   */
N#define I2C_CR2_FREQ_0            (0x01UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000001 */
N#define I2C_CR2_FREQ_1            (0x02UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000002 */
N#define I2C_CR2_FREQ_2            (0x04UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000004 */
N#define I2C_CR2_FREQ_3            (0x08UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000008 */
N#define I2C_CR2_FREQ_4            (0x10UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000010 */
N#define I2C_CR2_FREQ_5            (0x20UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000020 */
N
N#define I2C_CR2_ITERREN_Pos       (8U)                                         
N#define I2C_CR2_ITERREN_Msk       (0x1UL << I2C_CR2_ITERREN_Pos)                /*!< 0x00000100 */
N#define I2C_CR2_ITERREN           I2C_CR2_ITERREN_Msk                          /*!<Error Interrupt Enable  */
N#define I2C_CR2_ITEVTEN_Pos       (9U)                                         
N#define I2C_CR2_ITEVTEN_Msk       (0x1UL << I2C_CR2_ITEVTEN_Pos)                /*!< 0x00000200 */
N#define I2C_CR2_ITEVTEN           I2C_CR2_ITEVTEN_Msk                          /*!<Event Interrupt Enable  */
N#define I2C_CR2_ITBUFEN_Pos       (10U)                                        
N#define I2C_CR2_ITBUFEN_Msk       (0x1UL << I2C_CR2_ITBUFEN_Pos)                /*!< 0x00000400 */
N#define I2C_CR2_ITBUFEN           I2C_CR2_ITBUFEN_Msk                          /*!<Buffer Interrupt Enable */
N#define I2C_CR2_DMAEN_Pos         (11U)                                        
N#define I2C_CR2_DMAEN_Msk         (0x1UL << I2C_CR2_DMAEN_Pos)                  /*!< 0x00000800 */
N#define I2C_CR2_DMAEN             I2C_CR2_DMAEN_Msk                            /*!<DMA Requests Enable     */
N#define I2C_CR2_LAST_Pos          (12U)                                        
N#define I2C_CR2_LAST_Msk          (0x1UL << I2C_CR2_LAST_Pos)                   /*!< 0x00001000 */
N#define I2C_CR2_LAST              I2C_CR2_LAST_Msk                             /*!<DMA Last Transfer       */
N
N/*******************  Bit definition for I2C_OAR1 register  *******************/
N#define I2C_OAR1_ADD1_7           0x000000FEU                                  /*!<Interface Address */
N#define I2C_OAR1_ADD8_9           0x00000300U                                  /*!<Interface Address */
N
N#define I2C_OAR1_ADD0_Pos         (0U)                                         
N#define I2C_OAR1_ADD0_Msk         (0x1UL << I2C_OAR1_ADD0_Pos)                  /*!< 0x00000001 */
N#define I2C_OAR1_ADD0             I2C_OAR1_ADD0_Msk                            /*!<Bit 0 */
N#define I2C_OAR1_ADD1_Pos         (1U)                                         
N#define I2C_OAR1_ADD1_Msk         (0x1UL << I2C_OAR1_ADD1_Pos)                  /*!< 0x00000002 */
N#define I2C_OAR1_ADD1             I2C_OAR1_ADD1_Msk                            /*!<Bit 1 */
N#define I2C_OAR1_ADD2_Pos         (2U)                                         
N#define I2C_OAR1_ADD2_Msk         (0x1UL << I2C_OAR1_ADD2_Pos)                  /*!< 0x00000004 */
N#define I2C_OAR1_ADD2             I2C_OAR1_ADD2_Msk                            /*!<Bit 2 */
N#define I2C_OAR1_ADD3_Pos         (3U)                                         
N#define I2C_OAR1_ADD3_Msk         (0x1UL << I2C_OAR1_ADD3_Pos)                  /*!< 0x00000008 */
N#define I2C_OAR1_ADD3             I2C_OAR1_ADD3_Msk                            /*!<Bit 3 */
N#define I2C_OAR1_ADD4_Pos         (4U)                                         
N#define I2C_OAR1_ADD4_Msk         (0x1UL << I2C_OAR1_ADD4_Pos)                  /*!< 0x00000010 */
N#define I2C_OAR1_ADD4             I2C_OAR1_ADD4_Msk                            /*!<Bit 4 */
N#define I2C_OAR1_ADD5_Pos         (5U)                                         
N#define I2C_OAR1_ADD5_Msk         (0x1UL << I2C_OAR1_ADD5_Pos)                  /*!< 0x00000020 */
N#define I2C_OAR1_ADD5             I2C_OAR1_ADD5_Msk                            /*!<Bit 5 */
N#define I2C_OAR1_ADD6_Pos         (6U)                                         
N#define I2C_OAR1_ADD6_Msk         (0x1UL << I2C_OAR1_ADD6_Pos)                  /*!< 0x00000040 */
N#define I2C_OAR1_ADD6             I2C_OAR1_ADD6_Msk                            /*!<Bit 6 */
N#define I2C_OAR1_ADD7_Pos         (7U)                                         
N#define I2C_OAR1_ADD7_Msk         (0x1UL << I2C_OAR1_ADD7_Pos)                  /*!< 0x00000080 */
N#define I2C_OAR1_ADD7             I2C_OAR1_ADD7_Msk                            /*!<Bit 7 */
N#define I2C_OAR1_ADD8_Pos         (8U)                                         
N#define I2C_OAR1_ADD8_Msk         (0x1UL << I2C_OAR1_ADD8_Pos)                  /*!< 0x00000100 */
N#define I2C_OAR1_ADD8             I2C_OAR1_ADD8_Msk                            /*!<Bit 8 */
N#define I2C_OAR1_ADD9_Pos         (9U)                                         
N#define I2C_OAR1_ADD9_Msk         (0x1UL << I2C_OAR1_ADD9_Pos)                  /*!< 0x00000200 */
N#define I2C_OAR1_ADD9             I2C_OAR1_ADD9_Msk                            /*!<Bit 9 */
N
N#define I2C_OAR1_ADDMODE_Pos      (15U)                                        
N#define I2C_OAR1_ADDMODE_Msk      (0x1UL << I2C_OAR1_ADDMODE_Pos)               /*!< 0x00008000 */
N#define I2C_OAR1_ADDMODE          I2C_OAR1_ADDMODE_Msk                         /*!<Addressing Mode (Slave mode) */
N
N/*******************  Bit definition for I2C_OAR2 register  *******************/
N#define I2C_OAR2_ENDUAL_Pos       (0U)                                         
N#define I2C_OAR2_ENDUAL_Msk       (0x1UL << I2C_OAR2_ENDUAL_Pos)                /*!< 0x00000001 */
N#define I2C_OAR2_ENDUAL           I2C_OAR2_ENDUAL_Msk                          /*!<Dual addressing mode enable */
N#define I2C_OAR2_ADD2_Pos         (1U)                                         
N#define I2C_OAR2_ADD2_Msk         (0x7FUL << I2C_OAR2_ADD2_Pos)                 /*!< 0x000000FE */
N#define I2C_OAR2_ADD2             I2C_OAR2_ADD2_Msk                            /*!<Interface address           */
N
N/********************  Bit definition for I2C_DR register  ********************/
N#define I2C_DR_DR_Pos             (0U)                                         
N#define I2C_DR_DR_Msk             (0xFFUL << I2C_DR_DR_Pos)                     /*!< 0x000000FF */
N#define I2C_DR_DR                 I2C_DR_DR_Msk                                /*!<8-bit Data Register         */
N
N/*******************  Bit definition for I2C_SR1 register  ********************/
N#define I2C_SR1_SB_Pos            (0U)                                         
N#define I2C_SR1_SB_Msk            (0x1UL << I2C_SR1_SB_Pos)                     /*!< 0x00000001 */
N#define I2C_SR1_SB                I2C_SR1_SB_Msk                               /*!<Start Bit (Master mode)                         */
N#define I2C_SR1_ADDR_Pos          (1U)                                         
N#define I2C_SR1_ADDR_Msk          (0x1UL << I2C_SR1_ADDR_Pos)                   /*!< 0x00000002 */
N#define I2C_SR1_ADDR              I2C_SR1_ADDR_Msk                             /*!<Address sent (master mode)/matched (slave mode) */
N#define I2C_SR1_BTF_Pos           (2U)                                         
N#define I2C_SR1_BTF_Msk           (0x1UL << I2C_SR1_BTF_Pos)                    /*!< 0x00000004 */
N#define I2C_SR1_BTF               I2C_SR1_BTF_Msk                              /*!<Byte Transfer Finished                          */
N#define I2C_SR1_ADD10_Pos         (3U)                                         
N#define I2C_SR1_ADD10_Msk         (0x1UL << I2C_SR1_ADD10_Pos)                  /*!< 0x00000008 */
N#define I2C_SR1_ADD10             I2C_SR1_ADD10_Msk                            /*!<10-bit header sent (Master mode)                */
N#define I2C_SR1_STOPF_Pos         (4U)                                         
N#define I2C_SR1_STOPF_Msk         (0x1UL << I2C_SR1_STOPF_Pos)                  /*!< 0x00000010 */
N#define I2C_SR1_STOPF             I2C_SR1_STOPF_Msk                            /*!<Stop detection (Slave mode)                     */
N#define I2C_SR1_RXNE_Pos          (6U)                                         
N#define I2C_SR1_RXNE_Msk          (0x1UL << I2C_SR1_RXNE_Pos)                   /*!< 0x00000040 */
N#define I2C_SR1_RXNE              I2C_SR1_RXNE_Msk                             /*!<Data Register not Empty (receivers)             */
N#define I2C_SR1_TXE_Pos           (7U)                                         
N#define I2C_SR1_TXE_Msk           (0x1UL << I2C_SR1_TXE_Pos)                    /*!< 0x00000080 */
N#define I2C_SR1_TXE               I2C_SR1_TXE_Msk                              /*!<Data Register Empty (transmitters)              */
N#define I2C_SR1_BERR_Pos          (8U)                                         
N#define I2C_SR1_BERR_Msk          (0x1UL << I2C_SR1_BERR_Pos)                   /*!< 0x00000100 */
N#define I2C_SR1_BERR              I2C_SR1_BERR_Msk                             /*!<Bus Error                                       */
N#define I2C_SR1_ARLO_Pos          (9U)                                         
N#define I2C_SR1_ARLO_Msk          (0x1UL << I2C_SR1_ARLO_Pos)                   /*!< 0x00000200 */
N#define I2C_SR1_ARLO              I2C_SR1_ARLO_Msk                             /*!<Arbitration Lost (master mode)                  */
N#define I2C_SR1_AF_Pos            (10U)                                        
N#define I2C_SR1_AF_Msk            (0x1UL << I2C_SR1_AF_Pos)                     /*!< 0x00000400 */
N#define I2C_SR1_AF                I2C_SR1_AF_Msk                               /*!<Acknowledge Failure                             */
N#define I2C_SR1_OVR_Pos           (11U)                                        
N#define I2C_SR1_OVR_Msk           (0x1UL << I2C_SR1_OVR_Pos)                    /*!< 0x00000800 */
N#define I2C_SR1_OVR               I2C_SR1_OVR_Msk                              /*!<Overrun/Underrun                                */
N#define I2C_SR1_PECERR_Pos        (12U)                                        
N#define I2C_SR1_PECERR_Msk        (0x1UL << I2C_SR1_PECERR_Pos)                 /*!< 0x00001000 */
N#define I2C_SR1_PECERR            I2C_SR1_PECERR_Msk                           /*!<PEC Error in reception                          */
N#define I2C_SR1_TIMEOUT_Pos       (14U)                                        
N#define I2C_SR1_TIMEOUT_Msk       (0x1UL << I2C_SR1_TIMEOUT_Pos)                /*!< 0x00004000 */
N#define I2C_SR1_TIMEOUT           I2C_SR1_TIMEOUT_Msk                          /*!<Timeout or Tlow Error                           */
N#define I2C_SR1_SMBALERT_Pos      (15U)                                        
N#define I2C_SR1_SMBALERT_Msk      (0x1UL << I2C_SR1_SMBALERT_Pos)               /*!< 0x00008000 */
N#define I2C_SR1_SMBALERT          I2C_SR1_SMBALERT_Msk                         /*!<SMBus Alert                                     */
N
N/*******************  Bit definition for I2C_SR2 register  ********************/
N#define I2C_SR2_MSL_Pos           (0U)                                         
N#define I2C_SR2_MSL_Msk           (0x1UL << I2C_SR2_MSL_Pos)                    /*!< 0x00000001 */
N#define I2C_SR2_MSL               I2C_SR2_MSL_Msk                              /*!<Master/Slave                                    */
N#define I2C_SR2_BUSY_Pos          (1U)                                         
N#define I2C_SR2_BUSY_Msk          (0x1UL << I2C_SR2_BUSY_Pos)                   /*!< 0x00000002 */
N#define I2C_SR2_BUSY              I2C_SR2_BUSY_Msk                             /*!<Bus Busy                                        */
N#define I2C_SR2_TRA_Pos           (2U)                                         
N#define I2C_SR2_TRA_Msk           (0x1UL << I2C_SR2_TRA_Pos)                    /*!< 0x00000004 */
N#define I2C_SR2_TRA               I2C_SR2_TRA_Msk                              /*!<Transmitter/Receiver                            */
N#define I2C_SR2_GENCALL_Pos       (4U)                                         
N#define I2C_SR2_GENCALL_Msk       (0x1UL << I2C_SR2_GENCALL_Pos)                /*!< 0x00000010 */
N#define I2C_SR2_GENCALL           I2C_SR2_GENCALL_Msk                          /*!<General Call Address (Slave mode)               */
N#define I2C_SR2_SMBDEFAULT_Pos    (5U)                                         
N#define I2C_SR2_SMBDEFAULT_Msk    (0x1UL << I2C_SR2_SMBDEFAULT_Pos)             /*!< 0x00000020 */
N#define I2C_SR2_SMBDEFAULT        I2C_SR2_SMBDEFAULT_Msk                       /*!<SMBus Device Default Address (Slave mode)       */
N#define I2C_SR2_SMBHOST_Pos       (6U)                                         
N#define I2C_SR2_SMBHOST_Msk       (0x1UL << I2C_SR2_SMBHOST_Pos)                /*!< 0x00000040 */
N#define I2C_SR2_SMBHOST           I2C_SR2_SMBHOST_Msk                          /*!<SMBus Host Header (Slave mode)                  */
N#define I2C_SR2_DUALF_Pos         (7U)                                         
N#define I2C_SR2_DUALF_Msk         (0x1UL << I2C_SR2_DUALF_Pos)                  /*!< 0x00000080 */
N#define I2C_SR2_DUALF             I2C_SR2_DUALF_Msk                            /*!<Dual Flag (Slave mode)                          */
N#define I2C_SR2_PEC_Pos           (8U)                                         
N#define I2C_SR2_PEC_Msk           (0xFFUL << I2C_SR2_PEC_Pos)                   /*!< 0x0000FF00 */
N#define I2C_SR2_PEC               I2C_SR2_PEC_Msk                              /*!<Packet Error Checking Register                  */
N
N/*******************  Bit definition for I2C_CCR register  ********************/
N#define I2C_CCR_CCR_Pos           (0U)                                         
N#define I2C_CCR_CCR_Msk           (0xFFFUL << I2C_CCR_CCR_Pos)                  /*!< 0x00000FFF */
N#define I2C_CCR_CCR               I2C_CCR_CCR_Msk                              /*!<Clock Control Register in Fast/Standard mode (Master mode) */
N#define I2C_CCR_DUTY_Pos          (14U)                                        
N#define I2C_CCR_DUTY_Msk          (0x1UL << I2C_CCR_DUTY_Pos)                   /*!< 0x00004000 */
N#define I2C_CCR_DUTY              I2C_CCR_DUTY_Msk                             /*!<Fast Mode Duty Cycle                                       */
N#define I2C_CCR_FS_Pos            (15U)                                        
N#define I2C_CCR_FS_Msk            (0x1UL << I2C_CCR_FS_Pos)                     /*!< 0x00008000 */
N#define I2C_CCR_FS                I2C_CCR_FS_Msk                               /*!<I2C Master Mode Selection                                  */
N
N/******************  Bit definition for I2C_TRISE register  *******************/
N#define I2C_TRISE_TRISE_Pos       (0U)                                         
N#define I2C_TRISE_TRISE_Msk       (0x3FUL << I2C_TRISE_TRISE_Pos)               /*!< 0x0000003F */
N#define I2C_TRISE_TRISE           I2C_TRISE_TRISE_Msk                          /*!<Maximum Rise Time in Fast/Standard mode (Master mode) */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Independent WATCHDOG                             */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define IWDG_KR_KEY_Pos     (0U)                                               
N#define IWDG_KR_KEY_Msk     (0xFFFFUL << IWDG_KR_KEY_Pos)                       /*!< 0x0000FFFF */
N#define IWDG_KR_KEY         IWDG_KR_KEY_Msk                                    /*!<Key value (write only, read 0000h)  */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define IWDG_PR_PR_Pos      (0U)                                               
N#define IWDG_PR_PR_Msk      (0x7UL << IWDG_PR_PR_Pos)                           /*!< 0x00000007 */
N#define IWDG_PR_PR          IWDG_PR_PR_Msk                                     /*!<PR[2:0] (Prescaler divider)         */
N#define IWDG_PR_PR_0        (0x1UL << IWDG_PR_PR_Pos)                           /*!< 0x01 */
N#define IWDG_PR_PR_1        (0x2UL << IWDG_PR_PR_Pos)                           /*!< 0x02 */
N#define IWDG_PR_PR_2        (0x4UL << IWDG_PR_PR_Pos)                           /*!< 0x04 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define IWDG_RLR_RL_Pos     (0U)                                               
N#define IWDG_RLR_RL_Msk     (0xFFFUL << IWDG_RLR_RL_Pos)                        /*!< 0x00000FFF */
N#define IWDG_RLR_RL         IWDG_RLR_RL_Msk                                    /*!<Watchdog counter reload value        */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define IWDG_SR_PVU_Pos     (0U)                                               
N#define IWDG_SR_PVU_Msk     (0x1UL << IWDG_SR_PVU_Pos)                          /*!< 0x00000001 */
N#define IWDG_SR_PVU         IWDG_SR_PVU_Msk                                    /*!<Watchdog prescaler value update      */
N#define IWDG_SR_RVU_Pos     (1U)                                               
N#define IWDG_SR_RVU_Msk     (0x1UL << IWDG_SR_RVU_Pos)                          /*!< 0x00000002 */
N#define IWDG_SR_RVU         IWDG_SR_RVU_Msk                                    /*!<Watchdog counter reload value update */
N
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                             Power Control                                  */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for PWR_CR register  ********************/
N#define PWR_CR_LPDS_Pos        (0U)                                            
N#define PWR_CR_LPDS_Msk        (0x1UL << PWR_CR_LPDS_Pos)                       /*!< 0x00000001 */
N#define PWR_CR_LPDS            PWR_CR_LPDS_Msk                                 /*!< Low-Power Deepsleep                 */
N#define PWR_CR_PDDS_Pos        (1U)                                            
N#define PWR_CR_PDDS_Msk        (0x1UL << PWR_CR_PDDS_Pos)                       /*!< 0x00000002 */
N#define PWR_CR_PDDS            PWR_CR_PDDS_Msk                                 /*!< Power Down Deepsleep                */
N#define PWR_CR_CWUF_Pos        (2U)                                            
N#define PWR_CR_CWUF_Msk        (0x1UL << PWR_CR_CWUF_Pos)                       /*!< 0x00000004 */
N#define PWR_CR_CWUF            PWR_CR_CWUF_Msk                                 /*!< Clear Wakeup Flag                   */
N#define PWR_CR_CSBF_Pos        (3U)                                            
N#define PWR_CR_CSBF_Msk        (0x1UL << PWR_CR_CSBF_Pos)                       /*!< 0x00000008 */
N#define PWR_CR_CSBF            PWR_CR_CSBF_Msk                                 /*!< Clear Standby Flag                  */
N#define PWR_CR_PVDE_Pos        (4U)                                            
N#define PWR_CR_PVDE_Msk        (0x1UL << PWR_CR_PVDE_Pos)                       /*!< 0x00000010 */
N#define PWR_CR_PVDE            PWR_CR_PVDE_Msk                                 /*!< Power Voltage Detector Enable       */
N
N#define PWR_CR_PLS_Pos         (5U)                                            
N#define PWR_CR_PLS_Msk         (0x7UL << PWR_CR_PLS_Pos)                        /*!< 0x000000E0 */
N#define PWR_CR_PLS             PWR_CR_PLS_Msk                                  /*!< PLS[2:0] bits (PVD Level Selection) */
N#define PWR_CR_PLS_0           (0x1UL << PWR_CR_PLS_Pos)                        /*!< 0x00000020 */
N#define PWR_CR_PLS_1           (0x2UL << PWR_CR_PLS_Pos)                        /*!< 0x00000040 */
N#define PWR_CR_PLS_2           (0x4UL << PWR_CR_PLS_Pos)                        /*!< 0x00000080 */
N
N/*!< PVD level configuration */
N#define PWR_CR_PLS_LEV0        0x00000000U                                     /*!< PVD level 0 */
N#define PWR_CR_PLS_LEV1        0x00000020U                                     /*!< PVD level 1 */
N#define PWR_CR_PLS_LEV2        0x00000040U                                     /*!< PVD level 2 */
N#define PWR_CR_PLS_LEV3        0x00000060U                                     /*!< PVD level 3 */
N#define PWR_CR_PLS_LEV4        0x00000080U                                     /*!< PVD level 4 */
N#define PWR_CR_PLS_LEV5        0x000000A0U                                     /*!< PVD level 5 */
N#define PWR_CR_PLS_LEV6        0x000000C0U                                     /*!< PVD level 6 */
N#define PWR_CR_PLS_LEV7        0x000000E0U                                     /*!< PVD level 7 */
N#define PWR_CR_DBP_Pos         (8U)                                            
N#define PWR_CR_DBP_Msk         (0x1UL << PWR_CR_DBP_Pos)                        /*!< 0x00000100 */
N#define PWR_CR_DBP             PWR_CR_DBP_Msk                                  /*!< Disable Backup Domain write protection                     */
N#define PWR_CR_FPDS_Pos        (9U)                                            
N#define PWR_CR_FPDS_Msk        (0x1UL << PWR_CR_FPDS_Pos)                       /*!< 0x00000200 */
N#define PWR_CR_FPDS            PWR_CR_FPDS_Msk                                 /*!< Flash power down in Stop mode                              */
N#define PWR_CR_VOS_Pos         (14U)                                           
N#define PWR_CR_VOS_Msk         (0x1UL << PWR_CR_VOS_Pos)                        /*!< 0x00004000 */
N#define PWR_CR_VOS             PWR_CR_VOS_Msk                                  /*!< VOS bit (Regulator voltage scaling output selection) */
N
N/* Legacy define */
N#define  PWR_CR_PMODE                        PWR_CR_VOS
N
N/*******************  Bit definition for PWR_CSR register  ********************/
N#define PWR_CSR_WUF_Pos        (0U)                                            
N#define PWR_CSR_WUF_Msk        (0x1UL << PWR_CSR_WUF_Pos)                       /*!< 0x00000001 */
N#define PWR_CSR_WUF            PWR_CSR_WUF_Msk                                 /*!< Wakeup Flag                                      */
N#define PWR_CSR_SBF_Pos        (1U)                                            
N#define PWR_CSR_SBF_Msk        (0x1UL << PWR_CSR_SBF_Pos)                       /*!< 0x00000002 */
N#define PWR_CSR_SBF            PWR_CSR_SBF_Msk                                 /*!< Standby Flag                                     */
N#define PWR_CSR_PVDO_Pos       (2U)                                            
N#define PWR_CSR_PVDO_Msk       (0x1UL << PWR_CSR_PVDO_Pos)                      /*!< 0x00000004 */
N#define PWR_CSR_PVDO           PWR_CSR_PVDO_Msk                                /*!< PVD Output                                       */
N#define PWR_CSR_BRR_Pos        (3U)                                            
N#define PWR_CSR_BRR_Msk        (0x1UL << PWR_CSR_BRR_Pos)                       /*!< 0x00000008 */
N#define PWR_CSR_BRR            PWR_CSR_BRR_Msk                                 /*!< Backup regulator ready                           */
N#define PWR_CSR_EWUP_Pos       (8U)                                            
N#define PWR_CSR_EWUP_Msk       (0x1UL << PWR_CSR_EWUP_Pos)                      /*!< 0x00000100 */
N#define PWR_CSR_EWUP           PWR_CSR_EWUP_Msk                                /*!< Enable WKUP pin                                  */
N#define PWR_CSR_BRE_Pos        (9U)                                            
N#define PWR_CSR_BRE_Msk        (0x1UL << PWR_CSR_BRE_Pos)                       /*!< 0x00000200 */
N#define PWR_CSR_BRE            PWR_CSR_BRE_Msk                                 /*!< Backup regulator enable                          */
N#define PWR_CSR_VOSRDY_Pos     (14U)                                           
N#define PWR_CSR_VOSRDY_Msk     (0x1UL << PWR_CSR_VOSRDY_Pos)                    /*!< 0x00004000 */
N#define PWR_CSR_VOSRDY         PWR_CSR_VOSRDY_Msk                              /*!< Regulator voltage scaling output selection ready */
N
N/* Legacy define */
N#define  PWR_CSR_REGRDY                      PWR_CSR_VOSRDY
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Reset and Clock Control                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for RCC_CR register  ********************/
N#define RCC_CR_HSION_Pos                   (0U)                                
N#define RCC_CR_HSION_Msk                   (0x1UL << RCC_CR_HSION_Pos)          /*!< 0x00000001 */
N#define RCC_CR_HSION                       RCC_CR_HSION_Msk                    
N#define RCC_CR_HSIRDY_Pos                  (1U)                                
N#define RCC_CR_HSIRDY_Msk                  (0x1UL << RCC_CR_HSIRDY_Pos)         /*!< 0x00000002 */
N#define RCC_CR_HSIRDY                      RCC_CR_HSIRDY_Msk                   
N
N#define RCC_CR_HSITRIM_Pos                 (3U)                                
N#define RCC_CR_HSITRIM_Msk                 (0x1FUL << RCC_CR_HSITRIM_Pos)       /*!< 0x000000F8 */
N#define RCC_CR_HSITRIM                     RCC_CR_HSITRIM_Msk                  
N#define RCC_CR_HSITRIM_0                   (0x01UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000008 */
N#define RCC_CR_HSITRIM_1                   (0x02UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000010 */
N#define RCC_CR_HSITRIM_2                   (0x04UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000020 */
N#define RCC_CR_HSITRIM_3                   (0x08UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000040 */
N#define RCC_CR_HSITRIM_4                   (0x10UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000080 */
N
N#define RCC_CR_HSICAL_Pos                  (8U)                                
N#define RCC_CR_HSICAL_Msk                  (0xFFUL << RCC_CR_HSICAL_Pos)        /*!< 0x0000FF00 */
N#define RCC_CR_HSICAL                      RCC_CR_HSICAL_Msk                   
N#define RCC_CR_HSICAL_0                    (0x01UL << RCC_CR_HSICAL_Pos)        /*!< 0x00000100 */
N#define RCC_CR_HSICAL_1                    (0x02UL << RCC_CR_HSICAL_Pos)        /*!< 0x00000200 */
N#define RCC_CR_HSICAL_2                    (0x04UL << RCC_CR_HSICAL_Pos)        /*!< 0x00000400 */
N#define RCC_CR_HSICAL_3                    (0x08UL << RCC_CR_HSICAL_Pos)        /*!< 0x00000800 */
N#define RCC_CR_HSICAL_4                    (0x10UL << RCC_CR_HSICAL_Pos)        /*!< 0x00001000 */
N#define RCC_CR_HSICAL_5                    (0x20UL << RCC_CR_HSICAL_Pos)        /*!< 0x00002000 */
N#define RCC_CR_HSICAL_6                    (0x40UL << RCC_CR_HSICAL_Pos)        /*!< 0x00004000 */
N#define RCC_CR_HSICAL_7                    (0x80UL << RCC_CR_HSICAL_Pos)        /*!< 0x00008000 */
N
N#define RCC_CR_HSEON_Pos                   (16U)                               
N#define RCC_CR_HSEON_Msk                   (0x1UL << RCC_CR_HSEON_Pos)          /*!< 0x00010000 */
N#define RCC_CR_HSEON                       RCC_CR_HSEON_Msk                    
N#define RCC_CR_HSERDY_Pos                  (17U)                               
N#define RCC_CR_HSERDY_Msk                  (0x1UL << RCC_CR_HSERDY_Pos)         /*!< 0x00020000 */
N#define RCC_CR_HSERDY                      RCC_CR_HSERDY_Msk                   
N#define RCC_CR_HSEBYP_Pos                  (18U)                               
N#define RCC_CR_HSEBYP_Msk                  (0x1UL << RCC_CR_HSEBYP_Pos)         /*!< 0x00040000 */
N#define RCC_CR_HSEBYP                      RCC_CR_HSEBYP_Msk                   
N#define RCC_CR_CSSON_Pos                   (19U)                               
N#define RCC_CR_CSSON_Msk                   (0x1UL << RCC_CR_CSSON_Pos)          /*!< 0x00080000 */
N#define RCC_CR_CSSON                       RCC_CR_CSSON_Msk                    
N#define RCC_CR_PLLON_Pos                   (24U)                               
N#define RCC_CR_PLLON_Msk                   (0x1UL << RCC_CR_PLLON_Pos)          /*!< 0x01000000 */
N#define RCC_CR_PLLON                       RCC_CR_PLLON_Msk                    
N#define RCC_CR_PLLRDY_Pos                  (25U)                               
N#define RCC_CR_PLLRDY_Msk                  (0x1UL << RCC_CR_PLLRDY_Pos)         /*!< 0x02000000 */
N#define RCC_CR_PLLRDY                      RCC_CR_PLLRDY_Msk                   
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F4 serie)
N */
N#define RCC_PLLI2S_SUPPORT                                                     /*!< Support PLLI2S oscillator */
N
N#define RCC_CR_PLLI2SON_Pos                (26U)                               
N#define RCC_CR_PLLI2SON_Msk                (0x1UL << RCC_CR_PLLI2SON_Pos)       /*!< 0x04000000 */
N#define RCC_CR_PLLI2SON                    RCC_CR_PLLI2SON_Msk                 
N#define RCC_CR_PLLI2SRDY_Pos               (27U)                               
N#define RCC_CR_PLLI2SRDY_Msk               (0x1UL << RCC_CR_PLLI2SRDY_Pos)      /*!< 0x08000000 */
N#define RCC_CR_PLLI2SRDY                   RCC_CR_PLLI2SRDY_Msk                
N
N/********************  Bit definition for RCC_PLLCFGR register  ***************/
N#define RCC_PLLCFGR_PLLM_Pos               (0U)                                
N#define RCC_PLLCFGR_PLLM_Msk               (0x3FUL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x0000003F */
N#define RCC_PLLCFGR_PLLM                   RCC_PLLCFGR_PLLM_Msk                
N#define RCC_PLLCFGR_PLLM_0                 (0x01UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000001 */
N#define RCC_PLLCFGR_PLLM_1                 (0x02UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000002 */
N#define RCC_PLLCFGR_PLLM_2                 (0x04UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000004 */
N#define RCC_PLLCFGR_PLLM_3                 (0x08UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000008 */
N#define RCC_PLLCFGR_PLLM_4                 (0x10UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000010 */
N#define RCC_PLLCFGR_PLLM_5                 (0x20UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000020 */
N
N#define RCC_PLLCFGR_PLLN_Pos               (6U)                                
N#define RCC_PLLCFGR_PLLN_Msk               (0x1FFUL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00007FC0 */
N#define RCC_PLLCFGR_PLLN                   RCC_PLLCFGR_PLLN_Msk                
N#define RCC_PLLCFGR_PLLN_0                 (0x001UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000040 */
N#define RCC_PLLCFGR_PLLN_1                 (0x002UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000080 */
N#define RCC_PLLCFGR_PLLN_2                 (0x004UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000100 */
N#define RCC_PLLCFGR_PLLN_3                 (0x008UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000200 */
N#define RCC_PLLCFGR_PLLN_4                 (0x010UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000400 */
N#define RCC_PLLCFGR_PLLN_5                 (0x020UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000800 */
N#define RCC_PLLCFGR_PLLN_6                 (0x040UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00001000 */
N#define RCC_PLLCFGR_PLLN_7                 (0x080UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00002000 */
N#define RCC_PLLCFGR_PLLN_8                 (0x100UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00004000 */
N
N#define RCC_PLLCFGR_PLLP_Pos               (16U)                               
N#define RCC_PLLCFGR_PLLP_Msk               (0x3UL << RCC_PLLCFGR_PLLP_Pos)      /*!< 0x00030000 */
N#define RCC_PLLCFGR_PLLP                   RCC_PLLCFGR_PLLP_Msk                
N#define RCC_PLLCFGR_PLLP_0                 (0x1UL << RCC_PLLCFGR_PLLP_Pos)      /*!< 0x00010000 */
N#define RCC_PLLCFGR_PLLP_1                 (0x2UL << RCC_PLLCFGR_PLLP_Pos)      /*!< 0x00020000 */
N
N#define RCC_PLLCFGR_PLLSRC_Pos             (22U)                               
N#define RCC_PLLCFGR_PLLSRC_Msk             (0x1UL << RCC_PLLCFGR_PLLSRC_Pos)    /*!< 0x00400000 */
N#define RCC_PLLCFGR_PLLSRC                 RCC_PLLCFGR_PLLSRC_Msk              
N#define RCC_PLLCFGR_PLLSRC_HSE_Pos         (22U)                               
N#define RCC_PLLCFGR_PLLSRC_HSE_Msk         (0x1UL << RCC_PLLCFGR_PLLSRC_HSE_Pos) /*!< 0x00400000 */
N#define RCC_PLLCFGR_PLLSRC_HSE             RCC_PLLCFGR_PLLSRC_HSE_Msk          
N#define RCC_PLLCFGR_PLLSRC_HSI             0x00000000U                         
N
N#define RCC_PLLCFGR_PLLQ_Pos               (24U)                               
N#define RCC_PLLCFGR_PLLQ_Msk               (0xFUL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x0F000000 */
N#define RCC_PLLCFGR_PLLQ                   RCC_PLLCFGR_PLLQ_Msk                
N#define RCC_PLLCFGR_PLLQ_0                 (0x1UL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x01000000 */
N#define RCC_PLLCFGR_PLLQ_1                 (0x2UL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x02000000 */
N#define RCC_PLLCFGR_PLLQ_2                 (0x4UL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x04000000 */
N#define RCC_PLLCFGR_PLLQ_3                 (0x8UL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x08000000 */
N
N
N/********************  Bit definition for RCC_CFGR register  ******************/
N/*!< SW configuration */
N#define RCC_CFGR_SW_Pos                    (0U)                                
N#define RCC_CFGR_SW_Msk                    (0x3UL << RCC_CFGR_SW_Pos)           /*!< 0x00000003 */
N#define RCC_CFGR_SW                        RCC_CFGR_SW_Msk                     /*!< SW[1:0] bits (System clock Switch) */
N#define RCC_CFGR_SW_0                      (0x1UL << RCC_CFGR_SW_Pos)           /*!< 0x00000001 */
N#define RCC_CFGR_SW_1                      (0x2UL << RCC_CFGR_SW_Pos)           /*!< 0x00000002 */
N
N#define RCC_CFGR_SW_HSI                    0x00000000U                         /*!< HSI selected as system clock */
N#define RCC_CFGR_SW_HSE                    0x00000001U                         /*!< HSE selected as system clock */
N#define RCC_CFGR_SW_PLL                    0x00000002U                         /*!< PLL selected as system clock */
N
N/*!< SWS configuration */
N#define RCC_CFGR_SWS_Pos                   (2U)                                
N#define RCC_CFGR_SWS_Msk                   (0x3UL << RCC_CFGR_SWS_Pos)          /*!< 0x0000000C */
N#define RCC_CFGR_SWS                       RCC_CFGR_SWS_Msk                    /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define RCC_CFGR_SWS_0                     (0x1UL << RCC_CFGR_SWS_Pos)          /*!< 0x00000004 */
N#define RCC_CFGR_SWS_1                     (0x2UL << RCC_CFGR_SWS_Pos)          /*!< 0x00000008 */
N
N#define RCC_CFGR_SWS_HSI                   0x00000000U                         /*!< HSI oscillator used as system clock        */
N#define RCC_CFGR_SWS_HSE                   0x00000004U                         /*!< HSE oscillator used as system clock        */
N#define RCC_CFGR_SWS_PLL                   0x00000008U                         /*!< PLL used as system clock                   */
N
N/*!< HPRE configuration */
N#define RCC_CFGR_HPRE_Pos                  (4U)                                
N#define RCC_CFGR_HPRE_Msk                  (0xFUL << RCC_CFGR_HPRE_Pos)         /*!< 0x000000F0 */
N#define RCC_CFGR_HPRE                      RCC_CFGR_HPRE_Msk                   /*!< HPRE[3:0] bits (AHB prescaler) */
N#define RCC_CFGR_HPRE_0                    (0x1UL << RCC_CFGR_HPRE_Pos)         /*!< 0x00000010 */
N#define RCC_CFGR_HPRE_1                    (0x2UL << RCC_CFGR_HPRE_Pos)         /*!< 0x00000020 */
N#define RCC_CFGR_HPRE_2                    (0x4UL << RCC_CFGR_HPRE_Pos)         /*!< 0x00000040 */
N#define RCC_CFGR_HPRE_3                    (0x8UL << RCC_CFGR_HPRE_Pos)         /*!< 0x00000080 */
N
N#define RCC_CFGR_HPRE_DIV1                 0x00000000U                         /*!< SYSCLK not divided    */
N#define RCC_CFGR_HPRE_DIV2                 0x00000080U                         /*!< SYSCLK divided by 2   */
N#define RCC_CFGR_HPRE_DIV4                 0x00000090U                         /*!< SYSCLK divided by 4   */
N#define RCC_CFGR_HPRE_DIV8                 0x000000A0U                         /*!< SYSCLK divided by 8   */
N#define RCC_CFGR_HPRE_DIV16                0x000000B0U                         /*!< SYSCLK divided by 16  */
N#define RCC_CFGR_HPRE_DIV64                0x000000C0U                         /*!< SYSCLK divided by 64  */
N#define RCC_CFGR_HPRE_DIV128               0x000000D0U                         /*!< SYSCLK divided by 128 */
N#define RCC_CFGR_HPRE_DIV256               0x000000E0U                         /*!< SYSCLK divided by 256 */
N#define RCC_CFGR_HPRE_DIV512               0x000000F0U                         /*!< SYSCLK divided by 512 */
N
N/*!< PPRE1 configuration */
N#define RCC_CFGR_PPRE1_Pos                 (10U)                               
N#define RCC_CFGR_PPRE1_Msk                 (0x7UL << RCC_CFGR_PPRE1_Pos)        /*!< 0x00001C00 */
N#define RCC_CFGR_PPRE1                     RCC_CFGR_PPRE1_Msk                  /*!< PRE1[2:0] bits (APB1 prescaler) */
N#define RCC_CFGR_PPRE1_0                   (0x1UL << RCC_CFGR_PPRE1_Pos)        /*!< 0x00000400 */
N#define RCC_CFGR_PPRE1_1                   (0x2UL << RCC_CFGR_PPRE1_Pos)        /*!< 0x00000800 */
N#define RCC_CFGR_PPRE1_2                   (0x4UL << RCC_CFGR_PPRE1_Pos)        /*!< 0x00001000 */
N
N#define RCC_CFGR_PPRE1_DIV1                0x00000000U                         /*!< HCLK not divided   */
N#define RCC_CFGR_PPRE1_DIV2                0x00001000U                         /*!< HCLK divided by 2  */
N#define RCC_CFGR_PPRE1_DIV4                0x00001400U                         /*!< HCLK divided by 4  */
N#define RCC_CFGR_PPRE1_DIV8                0x00001800U                         /*!< HCLK divided by 8  */
N#define RCC_CFGR_PPRE1_DIV16               0x00001C00U                         /*!< HCLK divided by 16 */
N
N/*!< PPRE2 configuration */
N#define RCC_CFGR_PPRE2_Pos                 (13U)                               
N#define RCC_CFGR_PPRE2_Msk                 (0x7UL << RCC_CFGR_PPRE2_Pos)        /*!< 0x0000E000 */
N#define RCC_CFGR_PPRE2                     RCC_CFGR_PPRE2_Msk                  /*!< PRE2[2:0] bits (APB2 prescaler) */
N#define RCC_CFGR_PPRE2_0                   (0x1UL << RCC_CFGR_PPRE2_Pos)        /*!< 0x00002000 */
N#define RCC_CFGR_PPRE2_1                   (0x2UL << RCC_CFGR_PPRE2_Pos)        /*!< 0x00004000 */
N#define RCC_CFGR_PPRE2_2                   (0x4UL << RCC_CFGR_PPRE2_Pos)        /*!< 0x00008000 */
N
N#define RCC_CFGR_PPRE2_DIV1                0x00000000U                         /*!< HCLK not divided   */
N#define RCC_CFGR_PPRE2_DIV2                0x00008000U                         /*!< HCLK divided by 2  */
N#define RCC_CFGR_PPRE2_DIV4                0x0000A000U                         /*!< HCLK divided by 4  */
N#define RCC_CFGR_PPRE2_DIV8                0x0000C000U                         /*!< HCLK divided by 8  */
N#define RCC_CFGR_PPRE2_DIV16               0x0000E000U                         /*!< HCLK divided by 16 */
N
N/*!< RTCPRE configuration */
N#define RCC_CFGR_RTCPRE_Pos                (16U)                               
N#define RCC_CFGR_RTCPRE_Msk                (0x1FUL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x001F0000 */
N#define RCC_CFGR_RTCPRE                    RCC_CFGR_RTCPRE_Msk                 
N#define RCC_CFGR_RTCPRE_0                  (0x01UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00010000 */
N#define RCC_CFGR_RTCPRE_1                  (0x02UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00020000 */
N#define RCC_CFGR_RTCPRE_2                  (0x04UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00040000 */
N#define RCC_CFGR_RTCPRE_3                  (0x08UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00080000 */
N#define RCC_CFGR_RTCPRE_4                  (0x10UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00100000 */
N
N/*!< MCO1 configuration */
N#define RCC_CFGR_MCO1_Pos                  (21U)                               
N#define RCC_CFGR_MCO1_Msk                  (0x3UL << RCC_CFGR_MCO1_Pos)         /*!< 0x00600000 */
N#define RCC_CFGR_MCO1                      RCC_CFGR_MCO1_Msk                   
N#define RCC_CFGR_MCO1_0                    (0x1UL << RCC_CFGR_MCO1_Pos)         /*!< 0x00200000 */
N#define RCC_CFGR_MCO1_1                    (0x2UL << RCC_CFGR_MCO1_Pos)         /*!< 0x00400000 */
N
N#define RCC_CFGR_I2SSRC_Pos                (23U)                               
N#define RCC_CFGR_I2SSRC_Msk                (0x1UL << RCC_CFGR_I2SSRC_Pos)       /*!< 0x00800000 */
N#define RCC_CFGR_I2SSRC                    RCC_CFGR_I2SSRC_Msk                 
N
N#define RCC_CFGR_MCO1PRE_Pos               (24U)                               
N#define RCC_CFGR_MCO1PRE_Msk               (0x7UL << RCC_CFGR_MCO1PRE_Pos)      /*!< 0x07000000 */
N#define RCC_CFGR_MCO1PRE                   RCC_CFGR_MCO1PRE_Msk                
N#define RCC_CFGR_MCO1PRE_0                 (0x1UL << RCC_CFGR_MCO1PRE_Pos)      /*!< 0x01000000 */
N#define RCC_CFGR_MCO1PRE_1                 (0x2UL << RCC_CFGR_MCO1PRE_Pos)      /*!< 0x02000000 */
N#define RCC_CFGR_MCO1PRE_2                 (0x4UL << RCC_CFGR_MCO1PRE_Pos)      /*!< 0x04000000 */
N
N#define RCC_CFGR_MCO2PRE_Pos               (27U)                               
N#define RCC_CFGR_MCO2PRE_Msk               (0x7UL << RCC_CFGR_MCO2PRE_Pos)      /*!< 0x38000000 */
N#define RCC_CFGR_MCO2PRE                   RCC_CFGR_MCO2PRE_Msk                
N#define RCC_CFGR_MCO2PRE_0                 (0x1UL << RCC_CFGR_MCO2PRE_Pos)      /*!< 0x08000000 */
N#define RCC_CFGR_MCO2PRE_1                 (0x2UL << RCC_CFGR_MCO2PRE_Pos)      /*!< 0x10000000 */
N#define RCC_CFGR_MCO2PRE_2                 (0x4UL << RCC_CFGR_MCO2PRE_Pos)      /*!< 0x20000000 */
N
N#define RCC_CFGR_MCO2_Pos                  (30U)                               
N#define RCC_CFGR_MCO2_Msk                  (0x3UL << RCC_CFGR_MCO2_Pos)         /*!< 0xC0000000 */
N#define RCC_CFGR_MCO2                      RCC_CFGR_MCO2_Msk                   
N#define RCC_CFGR_MCO2_0                    (0x1UL << RCC_CFGR_MCO2_Pos)         /*!< 0x40000000 */
N#define RCC_CFGR_MCO2_1                    (0x2UL << RCC_CFGR_MCO2_Pos)         /*!< 0x80000000 */
N
N/********************  Bit definition for RCC_CIR register  *******************/
N#define RCC_CIR_LSIRDYF_Pos                (0U)                                
N#define RCC_CIR_LSIRDYF_Msk                (0x1UL << RCC_CIR_LSIRDYF_Pos)       /*!< 0x00000001 */
N#define RCC_CIR_LSIRDYF                    RCC_CIR_LSIRDYF_Msk                 
N#define RCC_CIR_LSERDYF_Pos                (1U)                                
N#define RCC_CIR_LSERDYF_Msk                (0x1UL << RCC_CIR_LSERDYF_Pos)       /*!< 0x00000002 */
N#define RCC_CIR_LSERDYF                    RCC_CIR_LSERDYF_Msk                 
N#define RCC_CIR_HSIRDYF_Pos                (2U)                                
N#define RCC_CIR_HSIRDYF_Msk                (0x1UL << RCC_CIR_HSIRDYF_Pos)       /*!< 0x00000004 */
N#define RCC_CIR_HSIRDYF                    RCC_CIR_HSIRDYF_Msk                 
N#define RCC_CIR_HSERDYF_Pos                (3U)                                
N#define RCC_CIR_HSERDYF_Msk                (0x1UL << RCC_CIR_HSERDYF_Pos)       /*!< 0x00000008 */
N#define RCC_CIR_HSERDYF                    RCC_CIR_HSERDYF_Msk                 
N#define RCC_CIR_PLLRDYF_Pos                (4U)                                
N#define RCC_CIR_PLLRDYF_Msk                (0x1UL << RCC_CIR_PLLRDYF_Pos)       /*!< 0x00000010 */
N#define RCC_CIR_PLLRDYF                    RCC_CIR_PLLRDYF_Msk                 
N#define RCC_CIR_PLLI2SRDYF_Pos             (5U)                                
N#define RCC_CIR_PLLI2SRDYF_Msk             (0x1UL << RCC_CIR_PLLI2SRDYF_Pos)    /*!< 0x00000020 */
N#define RCC_CIR_PLLI2SRDYF                 RCC_CIR_PLLI2SRDYF_Msk              
N
N#define RCC_CIR_CSSF_Pos                   (7U)                                
N#define RCC_CIR_CSSF_Msk                   (0x1UL << RCC_CIR_CSSF_Pos)          /*!< 0x00000080 */
N#define RCC_CIR_CSSF                       RCC_CIR_CSSF_Msk                    
N#define RCC_CIR_LSIRDYIE_Pos               (8U)                                
N#define RCC_CIR_LSIRDYIE_Msk               (0x1UL << RCC_CIR_LSIRDYIE_Pos)      /*!< 0x00000100 */
N#define RCC_CIR_LSIRDYIE                   RCC_CIR_LSIRDYIE_Msk                
N#define RCC_CIR_LSERDYIE_Pos               (9U)                                
N#define RCC_CIR_LSERDYIE_Msk               (0x1UL << RCC_CIR_LSERDYIE_Pos)      /*!< 0x00000200 */
N#define RCC_CIR_LSERDYIE                   RCC_CIR_LSERDYIE_Msk                
N#define RCC_CIR_HSIRDYIE_Pos               (10U)                               
N#define RCC_CIR_HSIRDYIE_Msk               (0x1UL << RCC_CIR_HSIRDYIE_Pos)      /*!< 0x00000400 */
N#define RCC_CIR_HSIRDYIE                   RCC_CIR_HSIRDYIE_Msk                
N#define RCC_CIR_HSERDYIE_Pos               (11U)                               
N#define RCC_CIR_HSERDYIE_Msk               (0x1UL << RCC_CIR_HSERDYIE_Pos)      /*!< 0x00000800 */
N#define RCC_CIR_HSERDYIE                   RCC_CIR_HSERDYIE_Msk                
N#define RCC_CIR_PLLRDYIE_Pos               (12U)                               
N#define RCC_CIR_PLLRDYIE_Msk               (0x1UL << RCC_CIR_PLLRDYIE_Pos)      /*!< 0x00001000 */
N#define RCC_CIR_PLLRDYIE                   RCC_CIR_PLLRDYIE_Msk                
N#define RCC_CIR_PLLI2SRDYIE_Pos            (13U)                               
N#define RCC_CIR_PLLI2SRDYIE_Msk            (0x1UL << RCC_CIR_PLLI2SRDYIE_Pos)   /*!< 0x00002000 */
N#define RCC_CIR_PLLI2SRDYIE                RCC_CIR_PLLI2SRDYIE_Msk             
N
N#define RCC_CIR_LSIRDYC_Pos                (16U)                               
N#define RCC_CIR_LSIRDYC_Msk                (0x1UL << RCC_CIR_LSIRDYC_Pos)       /*!< 0x00010000 */
N#define RCC_CIR_LSIRDYC                    RCC_CIR_LSIRDYC_Msk                 
N#define RCC_CIR_LSERDYC_Pos                (17U)                               
N#define RCC_CIR_LSERDYC_Msk                (0x1UL << RCC_CIR_LSERDYC_Pos)       /*!< 0x00020000 */
N#define RCC_CIR_LSERDYC                    RCC_CIR_LSERDYC_Msk                 
N#define RCC_CIR_HSIRDYC_Pos                (18U)                               
N#define RCC_CIR_HSIRDYC_Msk                (0x1UL << RCC_CIR_HSIRDYC_Pos)       /*!< 0x00040000 */
N#define RCC_CIR_HSIRDYC                    RCC_CIR_HSIRDYC_Msk                 
N#define RCC_CIR_HSERDYC_Pos                (19U)                               
N#define RCC_CIR_HSERDYC_Msk                (0x1UL << RCC_CIR_HSERDYC_Pos)       /*!< 0x00080000 */
N#define RCC_CIR_HSERDYC                    RCC_CIR_HSERDYC_Msk                 
N#define RCC_CIR_PLLRDYC_Pos                (20U)                               
N#define RCC_CIR_PLLRDYC_Msk                (0x1UL << RCC_CIR_PLLRDYC_Pos)       /*!< 0x00100000 */
N#define RCC_CIR_PLLRDYC                    RCC_CIR_PLLRDYC_Msk                 
N#define RCC_CIR_PLLI2SRDYC_Pos             (21U)                               
N#define RCC_CIR_PLLI2SRDYC_Msk             (0x1UL << RCC_CIR_PLLI2SRDYC_Pos)    /*!< 0x00200000 */
N#define RCC_CIR_PLLI2SRDYC                 RCC_CIR_PLLI2SRDYC_Msk              
N
N#define RCC_CIR_CSSC_Pos                   (23U)                               
N#define RCC_CIR_CSSC_Msk                   (0x1UL << RCC_CIR_CSSC_Pos)          /*!< 0x00800000 */
N#define RCC_CIR_CSSC                       RCC_CIR_CSSC_Msk                    
N
N/********************  Bit definition for RCC_AHB1RSTR register  **************/
N#define RCC_AHB1RSTR_GPIOARST_Pos          (0U)                                
N#define RCC_AHB1RSTR_GPIOARST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOARST_Pos) /*!< 0x00000001 */
N#define RCC_AHB1RSTR_GPIOARST              RCC_AHB1RSTR_GPIOARST_Msk           
N#define RCC_AHB1RSTR_GPIOBRST_Pos          (1U)                                
N#define RCC_AHB1RSTR_GPIOBRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOBRST_Pos) /*!< 0x00000002 */
N#define RCC_AHB1RSTR_GPIOBRST              RCC_AHB1RSTR_GPIOBRST_Msk           
N#define RCC_AHB1RSTR_GPIOCRST_Pos          (2U)                                
N#define RCC_AHB1RSTR_GPIOCRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOCRST_Pos) /*!< 0x00000004 */
N#define RCC_AHB1RSTR_GPIOCRST              RCC_AHB1RSTR_GPIOCRST_Msk           
N#define RCC_AHB1RSTR_GPIODRST_Pos          (3U)                                
N#define RCC_AHB1RSTR_GPIODRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIODRST_Pos) /*!< 0x00000008 */
N#define RCC_AHB1RSTR_GPIODRST              RCC_AHB1RSTR_GPIODRST_Msk           
N#define RCC_AHB1RSTR_GPIOERST_Pos          (4U)                                
N#define RCC_AHB1RSTR_GPIOERST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOERST_Pos) /*!< 0x00000010 */
N#define RCC_AHB1RSTR_GPIOERST              RCC_AHB1RSTR_GPIOERST_Msk           
N#define RCC_AHB1RSTR_GPIOFRST_Pos          (5U)                                
N#define RCC_AHB1RSTR_GPIOFRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOFRST_Pos) /*!< 0x00000020 */
N#define RCC_AHB1RSTR_GPIOFRST              RCC_AHB1RSTR_GPIOFRST_Msk           
N#define RCC_AHB1RSTR_GPIOGRST_Pos          (6U)                                
N#define RCC_AHB1RSTR_GPIOGRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOGRST_Pos) /*!< 0x00000040 */
N#define RCC_AHB1RSTR_GPIOGRST              RCC_AHB1RSTR_GPIOGRST_Msk           
N#define RCC_AHB1RSTR_GPIOHRST_Pos          (7U)                                
N#define RCC_AHB1RSTR_GPIOHRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOHRST_Pos) /*!< 0x00000080 */
N#define RCC_AHB1RSTR_GPIOHRST              RCC_AHB1RSTR_GPIOHRST_Msk           
N#define RCC_AHB1RSTR_GPIOIRST_Pos          (8U)                                
N#define RCC_AHB1RSTR_GPIOIRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOIRST_Pos) /*!< 0x00000100 */
N#define RCC_AHB1RSTR_GPIOIRST              RCC_AHB1RSTR_GPIOIRST_Msk           
N#define RCC_AHB1RSTR_CRCRST_Pos            (12U)                               
N#define RCC_AHB1RSTR_CRCRST_Msk            (0x1UL << RCC_AHB1RSTR_CRCRST_Pos)   /*!< 0x00001000 */
N#define RCC_AHB1RSTR_CRCRST                RCC_AHB1RSTR_CRCRST_Msk             
N#define RCC_AHB1RSTR_DMA1RST_Pos           (21U)                               
N#define RCC_AHB1RSTR_DMA1RST_Msk           (0x1UL << RCC_AHB1RSTR_DMA1RST_Pos)  /*!< 0x00200000 */
N#define RCC_AHB1RSTR_DMA1RST               RCC_AHB1RSTR_DMA1RST_Msk            
N#define RCC_AHB1RSTR_DMA2RST_Pos           (22U)                               
N#define RCC_AHB1RSTR_DMA2RST_Msk           (0x1UL << RCC_AHB1RSTR_DMA2RST_Pos)  /*!< 0x00400000 */
N#define RCC_AHB1RSTR_DMA2RST               RCC_AHB1RSTR_DMA2RST_Msk            
N#define RCC_AHB1RSTR_ETHMACRST_Pos         (25U)                               
N#define RCC_AHB1RSTR_ETHMACRST_Msk         (0x1UL << RCC_AHB1RSTR_ETHMACRST_Pos) /*!< 0x02000000 */
N#define RCC_AHB1RSTR_ETHMACRST             RCC_AHB1RSTR_ETHMACRST_Msk          
N#define RCC_AHB1RSTR_OTGHRST_Pos           (29U)                               
N#define RCC_AHB1RSTR_OTGHRST_Msk           (0x1UL << RCC_AHB1RSTR_OTGHRST_Pos)  /*!< 0x20000000 */
N#define RCC_AHB1RSTR_OTGHRST               RCC_AHB1RSTR_OTGHRST_Msk            
N
N/********************  Bit definition for RCC_AHB2RSTR register  **************/
N#define RCC_AHB2RSTR_DCMIRST_Pos           (0U)                                
N#define RCC_AHB2RSTR_DCMIRST_Msk           (0x1UL << RCC_AHB2RSTR_DCMIRST_Pos)  /*!< 0x00000001 */
N#define RCC_AHB2RSTR_DCMIRST               RCC_AHB2RSTR_DCMIRST_Msk            
N#define RCC_AHB2RSTR_RNGRST_Pos            (6U)                                
N#define RCC_AHB2RSTR_RNGRST_Msk            (0x1UL << RCC_AHB2RSTR_RNGRST_Pos)   /*!< 0x00000040 */
N#define RCC_AHB2RSTR_RNGRST                RCC_AHB2RSTR_RNGRST_Msk             
N#define RCC_AHB2RSTR_OTGFSRST_Pos          (7U)                                
N#define RCC_AHB2RSTR_OTGFSRST_Msk          (0x1UL << RCC_AHB2RSTR_OTGFSRST_Pos) /*!< 0x00000080 */
N#define RCC_AHB2RSTR_OTGFSRST              RCC_AHB2RSTR_OTGFSRST_Msk           
N/********************  Bit definition for RCC_AHB3RSTR register  **************/
N#define RCC_AHB3RSTR_FSMCRST_Pos           (0U)                                
N#define RCC_AHB3RSTR_FSMCRST_Msk           (0x1UL << RCC_AHB3RSTR_FSMCRST_Pos)  /*!< 0x00000001 */
N#define RCC_AHB3RSTR_FSMCRST               RCC_AHB3RSTR_FSMCRST_Msk            
N
N
N/********************  Bit definition for RCC_APB1RSTR register  **************/
N#define RCC_APB1RSTR_TIM2RST_Pos           (0U)                                
N#define RCC_APB1RSTR_TIM2RST_Msk           (0x1UL << RCC_APB1RSTR_TIM2RST_Pos)  /*!< 0x00000001 */
N#define RCC_APB1RSTR_TIM2RST               RCC_APB1RSTR_TIM2RST_Msk            
N#define RCC_APB1RSTR_TIM3RST_Pos           (1U)                                
N#define RCC_APB1RSTR_TIM3RST_Msk           (0x1UL << RCC_APB1RSTR_TIM3RST_Pos)  /*!< 0x00000002 */
N#define RCC_APB1RSTR_TIM3RST               RCC_APB1RSTR_TIM3RST_Msk            
N#define RCC_APB1RSTR_TIM4RST_Pos           (2U)                                
N#define RCC_APB1RSTR_TIM4RST_Msk           (0x1UL << RCC_APB1RSTR_TIM4RST_Pos)  /*!< 0x00000004 */
N#define RCC_APB1RSTR_TIM4RST               RCC_APB1RSTR_TIM4RST_Msk            
N#define RCC_APB1RSTR_TIM5RST_Pos           (3U)                                
N#define RCC_APB1RSTR_TIM5RST_Msk           (0x1UL << RCC_APB1RSTR_TIM5RST_Pos)  /*!< 0x00000008 */
N#define RCC_APB1RSTR_TIM5RST               RCC_APB1RSTR_TIM5RST_Msk            
N#define RCC_APB1RSTR_TIM6RST_Pos           (4U)                                
N#define RCC_APB1RSTR_TIM6RST_Msk           (0x1UL << RCC_APB1RSTR_TIM6RST_Pos)  /*!< 0x00000010 */
N#define RCC_APB1RSTR_TIM6RST               RCC_APB1RSTR_TIM6RST_Msk            
N#define RCC_APB1RSTR_TIM7RST_Pos           (5U)                                
N#define RCC_APB1RSTR_TIM7RST_Msk           (0x1UL << RCC_APB1RSTR_TIM7RST_Pos)  /*!< 0x00000020 */
N#define RCC_APB1RSTR_TIM7RST               RCC_APB1RSTR_TIM7RST_Msk            
N#define RCC_APB1RSTR_TIM12RST_Pos          (6U)                                
N#define RCC_APB1RSTR_TIM12RST_Msk          (0x1UL << RCC_APB1RSTR_TIM12RST_Pos) /*!< 0x00000040 */
N#define RCC_APB1RSTR_TIM12RST              RCC_APB1RSTR_TIM12RST_Msk           
N#define RCC_APB1RSTR_TIM13RST_Pos          (7U)                                
N#define RCC_APB1RSTR_TIM13RST_Msk          (0x1UL << RCC_APB1RSTR_TIM13RST_Pos) /*!< 0x00000080 */
N#define RCC_APB1RSTR_TIM13RST              RCC_APB1RSTR_TIM13RST_Msk           
N#define RCC_APB1RSTR_TIM14RST_Pos          (8U)                                
N#define RCC_APB1RSTR_TIM14RST_Msk          (0x1UL << RCC_APB1RSTR_TIM14RST_Pos) /*!< 0x00000100 */
N#define RCC_APB1RSTR_TIM14RST              RCC_APB1RSTR_TIM14RST_Msk           
N#define RCC_APB1RSTR_WWDGRST_Pos           (11U)                               
N#define RCC_APB1RSTR_WWDGRST_Msk           (0x1UL << RCC_APB1RSTR_WWDGRST_Pos)  /*!< 0x00000800 */
N#define RCC_APB1RSTR_WWDGRST               RCC_APB1RSTR_WWDGRST_Msk            
N#define RCC_APB1RSTR_SPI2RST_Pos           (14U)                               
N#define RCC_APB1RSTR_SPI2RST_Msk           (0x1UL << RCC_APB1RSTR_SPI2RST_Pos)  /*!< 0x00004000 */
N#define RCC_APB1RSTR_SPI2RST               RCC_APB1RSTR_SPI2RST_Msk            
N#define RCC_APB1RSTR_SPI3RST_Pos           (15U)                               
N#define RCC_APB1RSTR_SPI3RST_Msk           (0x1UL << RCC_APB1RSTR_SPI3RST_Pos)  /*!< 0x00008000 */
N#define RCC_APB1RSTR_SPI3RST               RCC_APB1RSTR_SPI3RST_Msk            
N#define RCC_APB1RSTR_USART2RST_Pos         (17U)                               
N#define RCC_APB1RSTR_USART2RST_Msk         (0x1UL << RCC_APB1RSTR_USART2RST_Pos) /*!< 0x00020000 */
N#define RCC_APB1RSTR_USART2RST             RCC_APB1RSTR_USART2RST_Msk          
N#define RCC_APB1RSTR_USART3RST_Pos         (18U)                               
N#define RCC_APB1RSTR_USART3RST_Msk         (0x1UL << RCC_APB1RSTR_USART3RST_Pos) /*!< 0x00040000 */
N#define RCC_APB1RSTR_USART3RST             RCC_APB1RSTR_USART3RST_Msk          
N#define RCC_APB1RSTR_UART4RST_Pos          (19U)                               
N#define RCC_APB1RSTR_UART4RST_Msk          (0x1UL << RCC_APB1RSTR_UART4RST_Pos) /*!< 0x00080000 */
N#define RCC_APB1RSTR_UART4RST              RCC_APB1RSTR_UART4RST_Msk           
N#define RCC_APB1RSTR_UART5RST_Pos          (20U)                               
N#define RCC_APB1RSTR_UART5RST_Msk          (0x1UL << RCC_APB1RSTR_UART5RST_Pos) /*!< 0x00100000 */
N#define RCC_APB1RSTR_UART5RST              RCC_APB1RSTR_UART5RST_Msk           
N#define RCC_APB1RSTR_I2C1RST_Pos           (21U)                               
N#define RCC_APB1RSTR_I2C1RST_Msk           (0x1UL << RCC_APB1RSTR_I2C1RST_Pos)  /*!< 0x00200000 */
N#define RCC_APB1RSTR_I2C1RST               RCC_APB1RSTR_I2C1RST_Msk            
N#define RCC_APB1RSTR_I2C2RST_Pos           (22U)                               
N#define RCC_APB1RSTR_I2C2RST_Msk           (0x1UL << RCC_APB1RSTR_I2C2RST_Pos)  /*!< 0x00400000 */
N#define RCC_APB1RSTR_I2C2RST               RCC_APB1RSTR_I2C2RST_Msk            
N#define RCC_APB1RSTR_I2C3RST_Pos           (23U)                               
N#define RCC_APB1RSTR_I2C3RST_Msk           (0x1UL << RCC_APB1RSTR_I2C3RST_Pos)  /*!< 0x00800000 */
N#define RCC_APB1RSTR_I2C3RST               RCC_APB1RSTR_I2C3RST_Msk            
N#define RCC_APB1RSTR_CAN1RST_Pos           (25U)                               
N#define RCC_APB1RSTR_CAN1RST_Msk           (0x1UL << RCC_APB1RSTR_CAN1RST_Pos)  /*!< 0x02000000 */
N#define RCC_APB1RSTR_CAN1RST               RCC_APB1RSTR_CAN1RST_Msk            
N#define RCC_APB1RSTR_CAN2RST_Pos           (26U)                               
N#define RCC_APB1RSTR_CAN2RST_Msk           (0x1UL << RCC_APB1RSTR_CAN2RST_Pos)  /*!< 0x04000000 */
N#define RCC_APB1RSTR_CAN2RST               RCC_APB1RSTR_CAN2RST_Msk            
N#define RCC_APB1RSTR_PWRRST_Pos            (28U)                               
N#define RCC_APB1RSTR_PWRRST_Msk            (0x1UL << RCC_APB1RSTR_PWRRST_Pos)   /*!< 0x10000000 */
N#define RCC_APB1RSTR_PWRRST                RCC_APB1RSTR_PWRRST_Msk             
N#define RCC_APB1RSTR_DACRST_Pos            (29U)                               
N#define RCC_APB1RSTR_DACRST_Msk            (0x1UL << RCC_APB1RSTR_DACRST_Pos)   /*!< 0x20000000 */
N#define RCC_APB1RSTR_DACRST                RCC_APB1RSTR_DACRST_Msk             
N
N/********************  Bit definition for RCC_APB2RSTR register  **************/
N#define RCC_APB2RSTR_TIM1RST_Pos           (0U)                                
N#define RCC_APB2RSTR_TIM1RST_Msk           (0x1UL << RCC_APB2RSTR_TIM1RST_Pos)  /*!< 0x00000001 */
N#define RCC_APB2RSTR_TIM1RST               RCC_APB2RSTR_TIM1RST_Msk            
N#define RCC_APB2RSTR_TIM8RST_Pos           (1U)                                
N#define RCC_APB2RSTR_TIM8RST_Msk           (0x1UL << RCC_APB2RSTR_TIM8RST_Pos)  /*!< 0x00000002 */
N#define RCC_APB2RSTR_TIM8RST               RCC_APB2RSTR_TIM8RST_Msk            
N#define RCC_APB2RSTR_USART1RST_Pos         (4U)                                
N#define RCC_APB2RSTR_USART1RST_Msk         (0x1UL << RCC_APB2RSTR_USART1RST_Pos) /*!< 0x00000010 */
N#define RCC_APB2RSTR_USART1RST             RCC_APB2RSTR_USART1RST_Msk          
N#define RCC_APB2RSTR_USART6RST_Pos         (5U)                                
N#define RCC_APB2RSTR_USART6RST_Msk         (0x1UL << RCC_APB2RSTR_USART6RST_Pos) /*!< 0x00000020 */
N#define RCC_APB2RSTR_USART6RST             RCC_APB2RSTR_USART6RST_Msk          
N#define RCC_APB2RSTR_ADCRST_Pos            (8U)                                
N#define RCC_APB2RSTR_ADCRST_Msk            (0x1UL << RCC_APB2RSTR_ADCRST_Pos)   /*!< 0x00000100 */
N#define RCC_APB2RSTR_ADCRST                RCC_APB2RSTR_ADCRST_Msk             
N#define RCC_APB2RSTR_SDIORST_Pos           (11U)                               
N#define RCC_APB2RSTR_SDIORST_Msk           (0x1UL << RCC_APB2RSTR_SDIORST_Pos)  /*!< 0x00000800 */
N#define RCC_APB2RSTR_SDIORST               RCC_APB2RSTR_SDIORST_Msk            
N#define RCC_APB2RSTR_SPI1RST_Pos           (12U)                               
N#define RCC_APB2RSTR_SPI1RST_Msk           (0x1UL << RCC_APB2RSTR_SPI1RST_Pos)  /*!< 0x00001000 */
N#define RCC_APB2RSTR_SPI1RST               RCC_APB2RSTR_SPI1RST_Msk            
N#define RCC_APB2RSTR_SYSCFGRST_Pos         (14U)                               
N#define RCC_APB2RSTR_SYSCFGRST_Msk         (0x1UL << RCC_APB2RSTR_SYSCFGRST_Pos) /*!< 0x00004000 */
N#define RCC_APB2RSTR_SYSCFGRST             RCC_APB2RSTR_SYSCFGRST_Msk          
N#define RCC_APB2RSTR_TIM9RST_Pos           (16U)                               
N#define RCC_APB2RSTR_TIM9RST_Msk           (0x1UL << RCC_APB2RSTR_TIM9RST_Pos)  /*!< 0x00010000 */
N#define RCC_APB2RSTR_TIM9RST               RCC_APB2RSTR_TIM9RST_Msk            
N#define RCC_APB2RSTR_TIM10RST_Pos          (17U)                               
N#define RCC_APB2RSTR_TIM10RST_Msk          (0x1UL << RCC_APB2RSTR_TIM10RST_Pos) /*!< 0x00020000 */
N#define RCC_APB2RSTR_TIM10RST              RCC_APB2RSTR_TIM10RST_Msk           
N#define RCC_APB2RSTR_TIM11RST_Pos          (18U)                               
N#define RCC_APB2RSTR_TIM11RST_Msk          (0x1UL << RCC_APB2RSTR_TIM11RST_Pos) /*!< 0x00040000 */
N#define RCC_APB2RSTR_TIM11RST              RCC_APB2RSTR_TIM11RST_Msk           
N
N/* Old SPI1RST bit definition, maintained for legacy purpose */
N#define  RCC_APB2RSTR_SPI1                   RCC_APB2RSTR_SPI1RST
N
N/********************  Bit definition for RCC_AHB1ENR register  ***************/
N#define RCC_AHB1ENR_GPIOAEN_Pos            (0U)                                
N#define RCC_AHB1ENR_GPIOAEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOAEN_Pos)   /*!< 0x00000001 */
N#define RCC_AHB1ENR_GPIOAEN                RCC_AHB1ENR_GPIOAEN_Msk             
N#define RCC_AHB1ENR_GPIOBEN_Pos            (1U)                                
N#define RCC_AHB1ENR_GPIOBEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOBEN_Pos)   /*!< 0x00000002 */
N#define RCC_AHB1ENR_GPIOBEN                RCC_AHB1ENR_GPIOBEN_Msk             
N#define RCC_AHB1ENR_GPIOCEN_Pos            (2U)                                
N#define RCC_AHB1ENR_GPIOCEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOCEN_Pos)   /*!< 0x00000004 */
N#define RCC_AHB1ENR_GPIOCEN                RCC_AHB1ENR_GPIOCEN_Msk             
N#define RCC_AHB1ENR_GPIODEN_Pos            (3U)                                
N#define RCC_AHB1ENR_GPIODEN_Msk            (0x1UL << RCC_AHB1ENR_GPIODEN_Pos)   /*!< 0x00000008 */
N#define RCC_AHB1ENR_GPIODEN                RCC_AHB1ENR_GPIODEN_Msk             
N#define RCC_AHB1ENR_GPIOEEN_Pos            (4U)                                
N#define RCC_AHB1ENR_GPIOEEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOEEN_Pos)   /*!< 0x00000010 */
N#define RCC_AHB1ENR_GPIOEEN                RCC_AHB1ENR_GPIOEEN_Msk             
N#define RCC_AHB1ENR_GPIOFEN_Pos            (5U)                                
N#define RCC_AHB1ENR_GPIOFEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOFEN_Pos)   /*!< 0x00000020 */
N#define RCC_AHB1ENR_GPIOFEN                RCC_AHB1ENR_GPIOFEN_Msk             
N#define RCC_AHB1ENR_GPIOGEN_Pos            (6U)                                
N#define RCC_AHB1ENR_GPIOGEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOGEN_Pos)   /*!< 0x00000040 */
N#define RCC_AHB1ENR_GPIOGEN                RCC_AHB1ENR_GPIOGEN_Msk             
N#define RCC_AHB1ENR_GPIOHEN_Pos            (7U)                                
N#define RCC_AHB1ENR_GPIOHEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOHEN_Pos)   /*!< 0x00000080 */
N#define RCC_AHB1ENR_GPIOHEN                RCC_AHB1ENR_GPIOHEN_Msk             
N#define RCC_AHB1ENR_GPIOIEN_Pos            (8U)                                
N#define RCC_AHB1ENR_GPIOIEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOIEN_Pos)   /*!< 0x00000100 */
N#define RCC_AHB1ENR_GPIOIEN                RCC_AHB1ENR_GPIOIEN_Msk             
N#define RCC_AHB1ENR_CRCEN_Pos              (12U)                               
N#define RCC_AHB1ENR_CRCEN_Msk              (0x1UL << RCC_AHB1ENR_CRCEN_Pos)     /*!< 0x00001000 */
N#define RCC_AHB1ENR_CRCEN                  RCC_AHB1ENR_CRCEN_Msk               
N#define RCC_AHB1ENR_BKPSRAMEN_Pos          (18U)                               
N#define RCC_AHB1ENR_BKPSRAMEN_Msk          (0x1UL << RCC_AHB1ENR_BKPSRAMEN_Pos) /*!< 0x00040000 */
N#define RCC_AHB1ENR_BKPSRAMEN              RCC_AHB1ENR_BKPSRAMEN_Msk           
N#define RCC_AHB1ENR_CCMDATARAMEN_Pos       (20U)                               
N#define RCC_AHB1ENR_CCMDATARAMEN_Msk       (0x1UL << RCC_AHB1ENR_CCMDATARAMEN_Pos) /*!< 0x00100000 */
N#define RCC_AHB1ENR_CCMDATARAMEN           RCC_AHB1ENR_CCMDATARAMEN_Msk        
N#define RCC_AHB1ENR_DMA1EN_Pos             (21U)                               
N#define RCC_AHB1ENR_DMA1EN_Msk             (0x1UL << RCC_AHB1ENR_DMA1EN_Pos)    /*!< 0x00200000 */
N#define RCC_AHB1ENR_DMA1EN                 RCC_AHB1ENR_DMA1EN_Msk              
N#define RCC_AHB1ENR_DMA2EN_Pos             (22U)                               
N#define RCC_AHB1ENR_DMA2EN_Msk             (0x1UL << RCC_AHB1ENR_DMA2EN_Pos)    /*!< 0x00400000 */
N#define RCC_AHB1ENR_DMA2EN                 RCC_AHB1ENR_DMA2EN_Msk              
N#define RCC_AHB1ENR_ETHMACEN_Pos           (25U)                               
N#define RCC_AHB1ENR_ETHMACEN_Msk           (0x1UL << RCC_AHB1ENR_ETHMACEN_Pos)  /*!< 0x02000000 */
N#define RCC_AHB1ENR_ETHMACEN               RCC_AHB1ENR_ETHMACEN_Msk            
N#define RCC_AHB1ENR_ETHMACTXEN_Pos         (26U)                               
N#define RCC_AHB1ENR_ETHMACTXEN_Msk         (0x1UL << RCC_AHB1ENR_ETHMACTXEN_Pos) /*!< 0x04000000 */
N#define RCC_AHB1ENR_ETHMACTXEN             RCC_AHB1ENR_ETHMACTXEN_Msk          
N#define RCC_AHB1ENR_ETHMACRXEN_Pos         (27U)                               
N#define RCC_AHB1ENR_ETHMACRXEN_Msk         (0x1UL << RCC_AHB1ENR_ETHMACRXEN_Pos) /*!< 0x08000000 */
N#define RCC_AHB1ENR_ETHMACRXEN             RCC_AHB1ENR_ETHMACRXEN_Msk          
N#define RCC_AHB1ENR_ETHMACPTPEN_Pos        (28U)                               
N#define RCC_AHB1ENR_ETHMACPTPEN_Msk        (0x1UL << RCC_AHB1ENR_ETHMACPTPEN_Pos) /*!< 0x10000000 */
N#define RCC_AHB1ENR_ETHMACPTPEN            RCC_AHB1ENR_ETHMACPTPEN_Msk         
N#define RCC_AHB1ENR_OTGHSEN_Pos            (29U)                               
N#define RCC_AHB1ENR_OTGHSEN_Msk            (0x1UL << RCC_AHB1ENR_OTGHSEN_Pos)   /*!< 0x20000000 */
N#define RCC_AHB1ENR_OTGHSEN                RCC_AHB1ENR_OTGHSEN_Msk             
N#define RCC_AHB1ENR_OTGHSULPIEN_Pos        (30U)                               
N#define RCC_AHB1ENR_OTGHSULPIEN_Msk        (0x1UL << RCC_AHB1ENR_OTGHSULPIEN_Pos) /*!< 0x40000000 */
N#define RCC_AHB1ENR_OTGHSULPIEN            RCC_AHB1ENR_OTGHSULPIEN_Msk         
N/********************  Bit definition for RCC_AHB2ENR register  ***************/
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F4 serie)
N */
N#define RCC_AHB2_SUPPORT                   /*!< AHB2 Bus is supported */
N
N#define RCC_AHB2ENR_DCMIEN_Pos             (0U)                                
N#define RCC_AHB2ENR_DCMIEN_Msk             (0x1UL << RCC_AHB2ENR_DCMIEN_Pos)    /*!< 0x00000001 */
N#define RCC_AHB2ENR_DCMIEN                 RCC_AHB2ENR_DCMIEN_Msk              
N#define RCC_AHB2ENR_RNGEN_Pos              (6U)                                
N#define RCC_AHB2ENR_RNGEN_Msk              (0x1UL << RCC_AHB2ENR_RNGEN_Pos)     /*!< 0x00000040 */
N#define RCC_AHB2ENR_RNGEN                  RCC_AHB2ENR_RNGEN_Msk               
N#define RCC_AHB2ENR_OTGFSEN_Pos            (7U)                                
N#define RCC_AHB2ENR_OTGFSEN_Msk            (0x1UL << RCC_AHB2ENR_OTGFSEN_Pos)   /*!< 0x00000080 */
N#define RCC_AHB2ENR_OTGFSEN                RCC_AHB2ENR_OTGFSEN_Msk             
N
N/********************  Bit definition for RCC_AHB3ENR register  ***************/
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F4 serie)
N */
N#define RCC_AHB3_SUPPORT                   /*!< AHB3 Bus is supported */
N
N#define RCC_AHB3ENR_FSMCEN_Pos             (0U)                                
N#define RCC_AHB3ENR_FSMCEN_Msk             (0x1UL << RCC_AHB3ENR_FSMCEN_Pos)    /*!< 0x00000001 */
N#define RCC_AHB3ENR_FSMCEN                 RCC_AHB3ENR_FSMCEN_Msk              
N
N/********************  Bit definition for RCC_APB1ENR register  ***************/
N#define RCC_APB1ENR_TIM2EN_Pos             (0U)                                
N#define RCC_APB1ENR_TIM2EN_Msk             (0x1UL << RCC_APB1ENR_TIM2EN_Pos)    /*!< 0x00000001 */
N#define RCC_APB1ENR_TIM2EN                 RCC_APB1ENR_TIM2EN_Msk              
N#define RCC_APB1ENR_TIM3EN_Pos             (1U)                                
N#define RCC_APB1ENR_TIM3EN_Msk             (0x1UL << RCC_APB1ENR_TIM3EN_Pos)    /*!< 0x00000002 */
N#define RCC_APB1ENR_TIM3EN                 RCC_APB1ENR_TIM3EN_Msk              
N#define RCC_APB1ENR_TIM4EN_Pos             (2U)                                
N#define RCC_APB1ENR_TIM4EN_Msk             (0x1UL << RCC_APB1ENR_TIM4EN_Pos)    /*!< 0x00000004 */
N#define RCC_APB1ENR_TIM4EN                 RCC_APB1ENR_TIM4EN_Msk              
N#define RCC_APB1ENR_TIM5EN_Pos             (3U)                                
N#define RCC_APB1ENR_TIM5EN_Msk             (0x1UL << RCC_APB1ENR_TIM5EN_Pos)    /*!< 0x00000008 */
N#define RCC_APB1ENR_TIM5EN                 RCC_APB1ENR_TIM5EN_Msk              
N#define RCC_APB1ENR_TIM6EN_Pos             (4U)                                
N#define RCC_APB1ENR_TIM6EN_Msk             (0x1UL << RCC_APB1ENR_TIM6EN_Pos)    /*!< 0x00000010 */
N#define RCC_APB1ENR_TIM6EN                 RCC_APB1ENR_TIM6EN_Msk              
N#define RCC_APB1ENR_TIM7EN_Pos             (5U)                                
N#define RCC_APB1ENR_TIM7EN_Msk             (0x1UL << RCC_APB1ENR_TIM7EN_Pos)    /*!< 0x00000020 */
N#define RCC_APB1ENR_TIM7EN                 RCC_APB1ENR_TIM7EN_Msk              
N#define RCC_APB1ENR_TIM12EN_Pos            (6U)                                
N#define RCC_APB1ENR_TIM12EN_Msk            (0x1UL << RCC_APB1ENR_TIM12EN_Pos)   /*!< 0x00000040 */
N#define RCC_APB1ENR_TIM12EN                RCC_APB1ENR_TIM12EN_Msk             
N#define RCC_APB1ENR_TIM13EN_Pos            (7U)                                
N#define RCC_APB1ENR_TIM13EN_Msk            (0x1UL << RCC_APB1ENR_TIM13EN_Pos)   /*!< 0x00000080 */
N#define RCC_APB1ENR_TIM13EN                RCC_APB1ENR_TIM13EN_Msk             
N#define RCC_APB1ENR_TIM14EN_Pos            (8U)                                
N#define RCC_APB1ENR_TIM14EN_Msk            (0x1UL << RCC_APB1ENR_TIM14EN_Pos)   /*!< 0x00000100 */
N#define RCC_APB1ENR_TIM14EN                RCC_APB1ENR_TIM14EN_Msk             
N#define RCC_APB1ENR_WWDGEN_Pos             (11U)                               
N#define RCC_APB1ENR_WWDGEN_Msk             (0x1UL << RCC_APB1ENR_WWDGEN_Pos)    /*!< 0x00000800 */
N#define RCC_APB1ENR_WWDGEN                 RCC_APB1ENR_WWDGEN_Msk              
N#define RCC_APB1ENR_SPI2EN_Pos             (14U)                               
N#define RCC_APB1ENR_SPI2EN_Msk             (0x1UL << RCC_APB1ENR_SPI2EN_Pos)    /*!< 0x00004000 */
N#define RCC_APB1ENR_SPI2EN                 RCC_APB1ENR_SPI2EN_Msk              
N#define RCC_APB1ENR_SPI3EN_Pos             (15U)                               
N#define RCC_APB1ENR_SPI3EN_Msk             (0x1UL << RCC_APB1ENR_SPI3EN_Pos)    /*!< 0x00008000 */
N#define RCC_APB1ENR_SPI3EN                 RCC_APB1ENR_SPI3EN_Msk              
N#define RCC_APB1ENR_USART2EN_Pos           (17U)                               
N#define RCC_APB1ENR_USART2EN_Msk           (0x1UL << RCC_APB1ENR_USART2EN_Pos)  /*!< 0x00020000 */
N#define RCC_APB1ENR_USART2EN               RCC_APB1ENR_USART2EN_Msk            
N#define RCC_APB1ENR_USART3EN_Pos           (18U)                               
N#define RCC_APB1ENR_USART3EN_Msk           (0x1UL << RCC_APB1ENR_USART3EN_Pos)  /*!< 0x00040000 */
N#define RCC_APB1ENR_USART3EN               RCC_APB1ENR_USART3EN_Msk            
N#define RCC_APB1ENR_UART4EN_Pos            (19U)                               
N#define RCC_APB1ENR_UART4EN_Msk            (0x1UL << RCC_APB1ENR_UART4EN_Pos)   /*!< 0x00080000 */
N#define RCC_APB1ENR_UART4EN                RCC_APB1ENR_UART4EN_Msk             
N#define RCC_APB1ENR_UART5EN_Pos            (20U)                               
N#define RCC_APB1ENR_UART5EN_Msk            (0x1UL << RCC_APB1ENR_UART5EN_Pos)   /*!< 0x00100000 */
N#define RCC_APB1ENR_UART5EN                RCC_APB1ENR_UART5EN_Msk             
N#define RCC_APB1ENR_I2C1EN_Pos             (21U)                               
N#define RCC_APB1ENR_I2C1EN_Msk             (0x1UL << RCC_APB1ENR_I2C1EN_Pos)    /*!< 0x00200000 */
N#define RCC_APB1ENR_I2C1EN                 RCC_APB1ENR_I2C1EN_Msk              
N#define RCC_APB1ENR_I2C2EN_Pos             (22U)                               
N#define RCC_APB1ENR_I2C2EN_Msk             (0x1UL << RCC_APB1ENR_I2C2EN_Pos)    /*!< 0x00400000 */
N#define RCC_APB1ENR_I2C2EN                 RCC_APB1ENR_I2C2EN_Msk              
N#define RCC_APB1ENR_I2C3EN_Pos             (23U)                               
N#define RCC_APB1ENR_I2C3EN_Msk             (0x1UL << RCC_APB1ENR_I2C3EN_Pos)    /*!< 0x00800000 */
N#define RCC_APB1ENR_I2C3EN                 RCC_APB1ENR_I2C3EN_Msk              
N#define RCC_APB1ENR_CAN1EN_Pos             (25U)                               
N#define RCC_APB1ENR_CAN1EN_Msk             (0x1UL << RCC_APB1ENR_CAN1EN_Pos)    /*!< 0x02000000 */
N#define RCC_APB1ENR_CAN1EN                 RCC_APB1ENR_CAN1EN_Msk              
N#define RCC_APB1ENR_CAN2EN_Pos             (26U)                               
N#define RCC_APB1ENR_CAN2EN_Msk             (0x1UL << RCC_APB1ENR_CAN2EN_Pos)    /*!< 0x04000000 */
N#define RCC_APB1ENR_CAN2EN                 RCC_APB1ENR_CAN2EN_Msk              
N#define RCC_APB1ENR_PWREN_Pos              (28U)                               
N#define RCC_APB1ENR_PWREN_Msk              (0x1UL << RCC_APB1ENR_PWREN_Pos)     /*!< 0x10000000 */
N#define RCC_APB1ENR_PWREN                  RCC_APB1ENR_PWREN_Msk               
N#define RCC_APB1ENR_DACEN_Pos              (29U)                               
N#define RCC_APB1ENR_DACEN_Msk              (0x1UL << RCC_APB1ENR_DACEN_Pos)     /*!< 0x20000000 */
N#define RCC_APB1ENR_DACEN                  RCC_APB1ENR_DACEN_Msk               
N
N/********************  Bit definition for RCC_APB2ENR register  ***************/
N#define RCC_APB2ENR_TIM1EN_Pos             (0U)                                
N#define RCC_APB2ENR_TIM1EN_Msk             (0x1UL << RCC_APB2ENR_TIM1EN_Pos)    /*!< 0x00000001 */
N#define RCC_APB2ENR_TIM1EN                 RCC_APB2ENR_TIM1EN_Msk              
N#define RCC_APB2ENR_TIM8EN_Pos             (1U)                                
N#define RCC_APB2ENR_TIM8EN_Msk             (0x1UL << RCC_APB2ENR_TIM8EN_Pos)    /*!< 0x00000002 */
N#define RCC_APB2ENR_TIM8EN                 RCC_APB2ENR_TIM8EN_Msk              
N#define RCC_APB2ENR_USART1EN_Pos           (4U)                                
N#define RCC_APB2ENR_USART1EN_Msk           (0x1UL << RCC_APB2ENR_USART1EN_Pos)  /*!< 0x00000010 */
N#define RCC_APB2ENR_USART1EN               RCC_APB2ENR_USART1EN_Msk            
N#define RCC_APB2ENR_USART6EN_Pos           (5U)                                
N#define RCC_APB2ENR_USART6EN_Msk           (0x1UL << RCC_APB2ENR_USART6EN_Pos)  /*!< 0x00000020 */
N#define RCC_APB2ENR_USART6EN               RCC_APB2ENR_USART6EN_Msk            
N#define RCC_APB2ENR_ADC1EN_Pos             (8U)                                
N#define RCC_APB2ENR_ADC1EN_Msk             (0x1UL << RCC_APB2ENR_ADC1EN_Pos)    /*!< 0x00000100 */
N#define RCC_APB2ENR_ADC1EN                 RCC_APB2ENR_ADC1EN_Msk              
N#define RCC_APB2ENR_ADC2EN_Pos             (9U)                                
N#define RCC_APB2ENR_ADC2EN_Msk             (0x1UL << RCC_APB2ENR_ADC2EN_Pos)    /*!< 0x00000200 */
N#define RCC_APB2ENR_ADC2EN                 RCC_APB2ENR_ADC2EN_Msk              
N#define RCC_APB2ENR_ADC3EN_Pos             (10U)                               
N#define RCC_APB2ENR_ADC3EN_Msk             (0x1UL << RCC_APB2ENR_ADC3EN_Pos)    /*!< 0x00000400 */
N#define RCC_APB2ENR_ADC3EN                 RCC_APB2ENR_ADC3EN_Msk              
N#define RCC_APB2ENR_SDIOEN_Pos             (11U)                               
N#define RCC_APB2ENR_SDIOEN_Msk             (0x1UL << RCC_APB2ENR_SDIOEN_Pos)    /*!< 0x00000800 */
N#define RCC_APB2ENR_SDIOEN                 RCC_APB2ENR_SDIOEN_Msk              
N#define RCC_APB2ENR_SPI1EN_Pos             (12U)                               
N#define RCC_APB2ENR_SPI1EN_Msk             (0x1UL << RCC_APB2ENR_SPI1EN_Pos)    /*!< 0x00001000 */
N#define RCC_APB2ENR_SPI1EN                 RCC_APB2ENR_SPI1EN_Msk              
N#define RCC_APB2ENR_SYSCFGEN_Pos           (14U)                               
N#define RCC_APB2ENR_SYSCFGEN_Msk           (0x1UL << RCC_APB2ENR_SYSCFGEN_Pos)  /*!< 0x00004000 */
N#define RCC_APB2ENR_SYSCFGEN               RCC_APB2ENR_SYSCFGEN_Msk            
N#define RCC_APB2ENR_TIM9EN_Pos             (16U)                               
N#define RCC_APB2ENR_TIM9EN_Msk             (0x1UL << RCC_APB2ENR_TIM9EN_Pos)    /*!< 0x00010000 */
N#define RCC_APB2ENR_TIM9EN                 RCC_APB2ENR_TIM9EN_Msk              
N#define RCC_APB2ENR_TIM10EN_Pos            (17U)                               
N#define RCC_APB2ENR_TIM10EN_Msk            (0x1UL << RCC_APB2ENR_TIM10EN_Pos)   /*!< 0x00020000 */
N#define RCC_APB2ENR_TIM10EN                RCC_APB2ENR_TIM10EN_Msk             
N#define RCC_APB2ENR_TIM11EN_Pos            (18U)                               
N#define RCC_APB2ENR_TIM11EN_Msk            (0x1UL << RCC_APB2ENR_TIM11EN_Pos)   /*!< 0x00040000 */
N#define RCC_APB2ENR_TIM11EN                RCC_APB2ENR_TIM11EN_Msk             
N
N/********************  Bit definition for RCC_AHB1LPENR register  *************/
N#define RCC_AHB1LPENR_GPIOALPEN_Pos        (0U)                                
N#define RCC_AHB1LPENR_GPIOALPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOALPEN_Pos) /*!< 0x00000001 */
N#define RCC_AHB1LPENR_GPIOALPEN            RCC_AHB1LPENR_GPIOALPEN_Msk         
N#define RCC_AHB1LPENR_GPIOBLPEN_Pos        (1U)                                
N#define RCC_AHB1LPENR_GPIOBLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOBLPEN_Pos) /*!< 0x00000002 */
N#define RCC_AHB1LPENR_GPIOBLPEN            RCC_AHB1LPENR_GPIOBLPEN_Msk         
N#define RCC_AHB1LPENR_GPIOCLPEN_Pos        (2U)                                
N#define RCC_AHB1LPENR_GPIOCLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOCLPEN_Pos) /*!< 0x00000004 */
N#define RCC_AHB1LPENR_GPIOCLPEN            RCC_AHB1LPENR_GPIOCLPEN_Msk         
N#define RCC_AHB1LPENR_GPIODLPEN_Pos        (3U)                                
N#define RCC_AHB1LPENR_GPIODLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIODLPEN_Pos) /*!< 0x00000008 */
N#define RCC_AHB1LPENR_GPIODLPEN            RCC_AHB1LPENR_GPIODLPEN_Msk         
N#define RCC_AHB1LPENR_GPIOELPEN_Pos        (4U)                                
N#define RCC_AHB1LPENR_GPIOELPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOELPEN_Pos) /*!< 0x00000010 */
N#define RCC_AHB1LPENR_GPIOELPEN            RCC_AHB1LPENR_GPIOELPEN_Msk         
N#define RCC_AHB1LPENR_GPIOFLPEN_Pos        (5U)                                
N#define RCC_AHB1LPENR_GPIOFLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOFLPEN_Pos) /*!< 0x00000020 */
N#define RCC_AHB1LPENR_GPIOFLPEN            RCC_AHB1LPENR_GPIOFLPEN_Msk         
N#define RCC_AHB1LPENR_GPIOGLPEN_Pos        (6U)                                
N#define RCC_AHB1LPENR_GPIOGLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOGLPEN_Pos) /*!< 0x00000040 */
N#define RCC_AHB1LPENR_GPIOGLPEN            RCC_AHB1LPENR_GPIOGLPEN_Msk         
N#define RCC_AHB1LPENR_GPIOHLPEN_Pos        (7U)                                
N#define RCC_AHB1LPENR_GPIOHLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOHLPEN_Pos) /*!< 0x00000080 */
N#define RCC_AHB1LPENR_GPIOHLPEN            RCC_AHB1LPENR_GPIOHLPEN_Msk         
N#define RCC_AHB1LPENR_GPIOILPEN_Pos        (8U)                                
N#define RCC_AHB1LPENR_GPIOILPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOILPEN_Pos) /*!< 0x00000100 */
N#define RCC_AHB1LPENR_GPIOILPEN            RCC_AHB1LPENR_GPIOILPEN_Msk         
N#define RCC_AHB1LPENR_CRCLPEN_Pos          (12U)                               
N#define RCC_AHB1LPENR_CRCLPEN_Msk          (0x1UL << RCC_AHB1LPENR_CRCLPEN_Pos) /*!< 0x00001000 */
N#define RCC_AHB1LPENR_CRCLPEN              RCC_AHB1LPENR_CRCLPEN_Msk           
N#define RCC_AHB1LPENR_FLITFLPEN_Pos        (15U)                               
N#define RCC_AHB1LPENR_FLITFLPEN_Msk        (0x1UL << RCC_AHB1LPENR_FLITFLPEN_Pos) /*!< 0x00008000 */
N#define RCC_AHB1LPENR_FLITFLPEN            RCC_AHB1LPENR_FLITFLPEN_Msk         
N#define RCC_AHB1LPENR_SRAM1LPEN_Pos        (16U)                               
N#define RCC_AHB1LPENR_SRAM1LPEN_Msk        (0x1UL << RCC_AHB1LPENR_SRAM1LPEN_Pos) /*!< 0x00010000 */
N#define RCC_AHB1LPENR_SRAM1LPEN            RCC_AHB1LPENR_SRAM1LPEN_Msk         
N#define RCC_AHB1LPENR_SRAM2LPEN_Pos        (17U)                               
N#define RCC_AHB1LPENR_SRAM2LPEN_Msk        (0x1UL << RCC_AHB1LPENR_SRAM2LPEN_Pos) /*!< 0x00020000 */
N#define RCC_AHB1LPENR_SRAM2LPEN            RCC_AHB1LPENR_SRAM2LPEN_Msk         
N#define RCC_AHB1LPENR_BKPSRAMLPEN_Pos      (18U)                               
N#define RCC_AHB1LPENR_BKPSRAMLPEN_Msk      (0x1UL << RCC_AHB1LPENR_BKPSRAMLPEN_Pos) /*!< 0x00040000 */
N#define RCC_AHB1LPENR_BKPSRAMLPEN          RCC_AHB1LPENR_BKPSRAMLPEN_Msk       
N#define RCC_AHB1LPENR_DMA1LPEN_Pos         (21U)                               
N#define RCC_AHB1LPENR_DMA1LPEN_Msk         (0x1UL << RCC_AHB1LPENR_DMA1LPEN_Pos) /*!< 0x00200000 */
N#define RCC_AHB1LPENR_DMA1LPEN             RCC_AHB1LPENR_DMA1LPEN_Msk          
N#define RCC_AHB1LPENR_DMA2LPEN_Pos         (22U)                               
N#define RCC_AHB1LPENR_DMA2LPEN_Msk         (0x1UL << RCC_AHB1LPENR_DMA2LPEN_Pos) /*!< 0x00400000 */
N#define RCC_AHB1LPENR_DMA2LPEN             RCC_AHB1LPENR_DMA2LPEN_Msk          
N
N#define RCC_AHB1LPENR_ETHMACLPEN_Pos       (25U)                               
N#define RCC_AHB1LPENR_ETHMACLPEN_Msk       (0x1UL << RCC_AHB1LPENR_ETHMACLPEN_Pos) /*!< 0x02000000 */
N#define RCC_AHB1LPENR_ETHMACLPEN           RCC_AHB1LPENR_ETHMACLPEN_Msk        
N#define RCC_AHB1LPENR_ETHMACTXLPEN_Pos     (26U)                               
N#define RCC_AHB1LPENR_ETHMACTXLPEN_Msk     (0x1UL << RCC_AHB1LPENR_ETHMACTXLPEN_Pos) /*!< 0x04000000 */
N#define RCC_AHB1LPENR_ETHMACTXLPEN         RCC_AHB1LPENR_ETHMACTXLPEN_Msk      
N#define RCC_AHB1LPENR_ETHMACRXLPEN_Pos     (27U)                               
N#define RCC_AHB1LPENR_ETHMACRXLPEN_Msk     (0x1UL << RCC_AHB1LPENR_ETHMACRXLPEN_Pos) /*!< 0x08000000 */
N#define RCC_AHB1LPENR_ETHMACRXLPEN         RCC_AHB1LPENR_ETHMACRXLPEN_Msk      
N#define RCC_AHB1LPENR_ETHMACPTPLPEN_Pos    (28U)                               
N#define RCC_AHB1LPENR_ETHMACPTPLPEN_Msk    (0x1UL << RCC_AHB1LPENR_ETHMACPTPLPEN_Pos) /*!< 0x10000000 */
N#define RCC_AHB1LPENR_ETHMACPTPLPEN        RCC_AHB1LPENR_ETHMACPTPLPEN_Msk     
N#define RCC_AHB1LPENR_OTGHSLPEN_Pos        (29U)                               
N#define RCC_AHB1LPENR_OTGHSLPEN_Msk        (0x1UL << RCC_AHB1LPENR_OTGHSLPEN_Pos) /*!< 0x20000000 */
N#define RCC_AHB1LPENR_OTGHSLPEN            RCC_AHB1LPENR_OTGHSLPEN_Msk         
N#define RCC_AHB1LPENR_OTGHSULPILPEN_Pos    (30U)                               
N#define RCC_AHB1LPENR_OTGHSULPILPEN_Msk    (0x1UL << RCC_AHB1LPENR_OTGHSULPILPEN_Pos) /*!< 0x40000000 */
N#define RCC_AHB1LPENR_OTGHSULPILPEN        RCC_AHB1LPENR_OTGHSULPILPEN_Msk     
N
N/********************  Bit definition for RCC_AHB2LPENR register  *************/
N#define RCC_AHB2LPENR_DCMILPEN_Pos         (0U)                                
N#define RCC_AHB2LPENR_DCMILPEN_Msk         (0x1UL << RCC_AHB2LPENR_DCMILPEN_Pos) /*!< 0x00000001 */
N#define RCC_AHB2LPENR_DCMILPEN             RCC_AHB2LPENR_DCMILPEN_Msk          
N#define RCC_AHB2LPENR_RNGLPEN_Pos          (6U)                                
N#define RCC_AHB2LPENR_RNGLPEN_Msk          (0x1UL << RCC_AHB2LPENR_RNGLPEN_Pos) /*!< 0x00000040 */
N#define RCC_AHB2LPENR_RNGLPEN              RCC_AHB2LPENR_RNGLPEN_Msk           
N#define RCC_AHB2LPENR_OTGFSLPEN_Pos        (7U)                                
N#define RCC_AHB2LPENR_OTGFSLPEN_Msk        (0x1UL << RCC_AHB2LPENR_OTGFSLPEN_Pos) /*!< 0x00000080 */
N#define RCC_AHB2LPENR_OTGFSLPEN            RCC_AHB2LPENR_OTGFSLPEN_Msk         
N
N/********************  Bit definition for RCC_AHB3LPENR register  *************/
N#define RCC_AHB3LPENR_FSMCLPEN_Pos         (0U)                                
N#define RCC_AHB3LPENR_FSMCLPEN_Msk         (0x1UL << RCC_AHB3LPENR_FSMCLPEN_Pos) /*!< 0x00000001 */
N#define RCC_AHB3LPENR_FSMCLPEN             RCC_AHB3LPENR_FSMCLPEN_Msk          
N
N/********************  Bit definition for RCC_APB1LPENR register  *************/
N#define RCC_APB1LPENR_TIM2LPEN_Pos         (0U)                                
N#define RCC_APB1LPENR_TIM2LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM2LPEN_Pos) /*!< 0x00000001 */
N#define RCC_APB1LPENR_TIM2LPEN             RCC_APB1LPENR_TIM2LPEN_Msk          
N#define RCC_APB1LPENR_TIM3LPEN_Pos         (1U)                                
N#define RCC_APB1LPENR_TIM3LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM3LPEN_Pos) /*!< 0x00000002 */
N#define RCC_APB1LPENR_TIM3LPEN             RCC_APB1LPENR_TIM3LPEN_Msk          
N#define RCC_APB1LPENR_TIM4LPEN_Pos         (2U)                                
N#define RCC_APB1LPENR_TIM4LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM4LPEN_Pos) /*!< 0x00000004 */
N#define RCC_APB1LPENR_TIM4LPEN             RCC_APB1LPENR_TIM4LPEN_Msk          
N#define RCC_APB1LPENR_TIM5LPEN_Pos         (3U)                                
N#define RCC_APB1LPENR_TIM5LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM5LPEN_Pos) /*!< 0x00000008 */
N#define RCC_APB1LPENR_TIM5LPEN             RCC_APB1LPENR_TIM5LPEN_Msk          
N#define RCC_APB1LPENR_TIM6LPEN_Pos         (4U)                                
N#define RCC_APB1LPENR_TIM6LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM6LPEN_Pos) /*!< 0x00000010 */
N#define RCC_APB1LPENR_TIM6LPEN             RCC_APB1LPENR_TIM6LPEN_Msk          
N#define RCC_APB1LPENR_TIM7LPEN_Pos         (5U)                                
N#define RCC_APB1LPENR_TIM7LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM7LPEN_Pos) /*!< 0x00000020 */
N#define RCC_APB1LPENR_TIM7LPEN             RCC_APB1LPENR_TIM7LPEN_Msk          
N#define RCC_APB1LPENR_TIM12LPEN_Pos        (6U)                                
N#define RCC_APB1LPENR_TIM12LPEN_Msk        (0x1UL << RCC_APB1LPENR_TIM12LPEN_Pos) /*!< 0x00000040 */
N#define RCC_APB1LPENR_TIM12LPEN            RCC_APB1LPENR_TIM12LPEN_Msk         
N#define RCC_APB1LPENR_TIM13LPEN_Pos        (7U)                                
N#define RCC_APB1LPENR_TIM13LPEN_Msk        (0x1UL << RCC_APB1LPENR_TIM13LPEN_Pos) /*!< 0x00000080 */
N#define RCC_APB1LPENR_TIM13LPEN            RCC_APB1LPENR_TIM13LPEN_Msk         
N#define RCC_APB1LPENR_TIM14LPEN_Pos        (8U)                                
N#define RCC_APB1LPENR_TIM14LPEN_Msk        (0x1UL << RCC_APB1LPENR_TIM14LPEN_Pos) /*!< 0x00000100 */
N#define RCC_APB1LPENR_TIM14LPEN            RCC_APB1LPENR_TIM14LPEN_Msk         
N#define RCC_APB1LPENR_WWDGLPEN_Pos         (11U)                               
N#define RCC_APB1LPENR_WWDGLPEN_Msk         (0x1UL << RCC_APB1LPENR_WWDGLPEN_Pos) /*!< 0x00000800 */
N#define RCC_APB1LPENR_WWDGLPEN             RCC_APB1LPENR_WWDGLPEN_Msk          
N#define RCC_APB1LPENR_SPI2LPEN_Pos         (14U)                               
N#define RCC_APB1LPENR_SPI2LPEN_Msk         (0x1UL << RCC_APB1LPENR_SPI2LPEN_Pos) /*!< 0x00004000 */
N#define RCC_APB1LPENR_SPI2LPEN             RCC_APB1LPENR_SPI2LPEN_Msk          
N#define RCC_APB1LPENR_SPI3LPEN_Pos         (15U)                               
N#define RCC_APB1LPENR_SPI3LPEN_Msk         (0x1UL << RCC_APB1LPENR_SPI3LPEN_Pos) /*!< 0x00008000 */
N#define RCC_APB1LPENR_SPI3LPEN             RCC_APB1LPENR_SPI3LPEN_Msk          
N#define RCC_APB1LPENR_USART2LPEN_Pos       (17U)                               
N#define RCC_APB1LPENR_USART2LPEN_Msk       (0x1UL << RCC_APB1LPENR_USART2LPEN_Pos) /*!< 0x00020000 */
N#define RCC_APB1LPENR_USART2LPEN           RCC_APB1LPENR_USART2LPEN_Msk        
N#define RCC_APB1LPENR_USART3LPEN_Pos       (18U)                               
N#define RCC_APB1LPENR_USART3LPEN_Msk       (0x1UL << RCC_APB1LPENR_USART3LPEN_Pos) /*!< 0x00040000 */
N#define RCC_APB1LPENR_USART3LPEN           RCC_APB1LPENR_USART3LPEN_Msk        
N#define RCC_APB1LPENR_UART4LPEN_Pos        (19U)                               
N#define RCC_APB1LPENR_UART4LPEN_Msk        (0x1UL << RCC_APB1LPENR_UART4LPEN_Pos) /*!< 0x00080000 */
N#define RCC_APB1LPENR_UART4LPEN            RCC_APB1LPENR_UART4LPEN_Msk         
N#define RCC_APB1LPENR_UART5LPEN_Pos        (20U)                               
N#define RCC_APB1LPENR_UART5LPEN_Msk        (0x1UL << RCC_APB1LPENR_UART5LPEN_Pos) /*!< 0x00100000 */
N#define RCC_APB1LPENR_UART5LPEN            RCC_APB1LPENR_UART5LPEN_Msk         
N#define RCC_APB1LPENR_I2C1LPEN_Pos         (21U)                               
N#define RCC_APB1LPENR_I2C1LPEN_Msk         (0x1UL << RCC_APB1LPENR_I2C1LPEN_Pos) /*!< 0x00200000 */
N#define RCC_APB1LPENR_I2C1LPEN             RCC_APB1LPENR_I2C1LPEN_Msk          
N#define RCC_APB1LPENR_I2C2LPEN_Pos         (22U)                               
N#define RCC_APB1LPENR_I2C2LPEN_Msk         (0x1UL << RCC_APB1LPENR_I2C2LPEN_Pos) /*!< 0x00400000 */
N#define RCC_APB1LPENR_I2C2LPEN             RCC_APB1LPENR_I2C2LPEN_Msk          
N#define RCC_APB1LPENR_I2C3LPEN_Pos         (23U)                               
N#define RCC_APB1LPENR_I2C3LPEN_Msk         (0x1UL << RCC_APB1LPENR_I2C3LPEN_Pos) /*!< 0x00800000 */
N#define RCC_APB1LPENR_I2C3LPEN             RCC_APB1LPENR_I2C3LPEN_Msk          
N#define RCC_APB1LPENR_CAN1LPEN_Pos         (25U)                               
N#define RCC_APB1LPENR_CAN1LPEN_Msk         (0x1UL << RCC_APB1LPENR_CAN1LPEN_Pos) /*!< 0x02000000 */
N#define RCC_APB1LPENR_CAN1LPEN             RCC_APB1LPENR_CAN1LPEN_Msk          
N#define RCC_APB1LPENR_CAN2LPEN_Pos         (26U)                               
N#define RCC_APB1LPENR_CAN2LPEN_Msk         (0x1UL << RCC_APB1LPENR_CAN2LPEN_Pos) /*!< 0x04000000 */
N#define RCC_APB1LPENR_CAN2LPEN             RCC_APB1LPENR_CAN2LPEN_Msk          
N#define RCC_APB1LPENR_PWRLPEN_Pos          (28U)                               
N#define RCC_APB1LPENR_PWRLPEN_Msk          (0x1UL << RCC_APB1LPENR_PWRLPEN_Pos) /*!< 0x10000000 */
N#define RCC_APB1LPENR_PWRLPEN              RCC_APB1LPENR_PWRLPEN_Msk           
N#define RCC_APB1LPENR_DACLPEN_Pos          (29U)                               
N#define RCC_APB1LPENR_DACLPEN_Msk          (0x1UL << RCC_APB1LPENR_DACLPEN_Pos) /*!< 0x20000000 */
N#define RCC_APB1LPENR_DACLPEN              RCC_APB1LPENR_DACLPEN_Msk           
N
N/********************  Bit definition for RCC_APB2LPENR register  *************/
N#define RCC_APB2LPENR_TIM1LPEN_Pos         (0U)                                
N#define RCC_APB2LPENR_TIM1LPEN_Msk         (0x1UL << RCC_APB2LPENR_TIM1LPEN_Pos) /*!< 0x00000001 */
N#define RCC_APB2LPENR_TIM1LPEN             RCC_APB2LPENR_TIM1LPEN_Msk          
N#define RCC_APB2LPENR_TIM8LPEN_Pos         (1U)                                
N#define RCC_APB2LPENR_TIM8LPEN_Msk         (0x1UL << RCC_APB2LPENR_TIM8LPEN_Pos) /*!< 0x00000002 */
N#define RCC_APB2LPENR_TIM8LPEN             RCC_APB2LPENR_TIM8LPEN_Msk          
N#define RCC_APB2LPENR_USART1LPEN_Pos       (4U)                                
N#define RCC_APB2LPENR_USART1LPEN_Msk       (0x1UL << RCC_APB2LPENR_USART1LPEN_Pos) /*!< 0x00000010 */
N#define RCC_APB2LPENR_USART1LPEN           RCC_APB2LPENR_USART1LPEN_Msk        
N#define RCC_APB2LPENR_USART6LPEN_Pos       (5U)                                
N#define RCC_APB2LPENR_USART6LPEN_Msk       (0x1UL << RCC_APB2LPENR_USART6LPEN_Pos) /*!< 0x00000020 */
N#define RCC_APB2LPENR_USART6LPEN           RCC_APB2LPENR_USART6LPEN_Msk        
N#define RCC_APB2LPENR_ADC1LPEN_Pos         (8U)                                
N#define RCC_APB2LPENR_ADC1LPEN_Msk         (0x1UL << RCC_APB2LPENR_ADC1LPEN_Pos) /*!< 0x00000100 */
N#define RCC_APB2LPENR_ADC1LPEN             RCC_APB2LPENR_ADC1LPEN_Msk          
N#define RCC_APB2LPENR_ADC2LPEN_Pos         (9U)                                
N#define RCC_APB2LPENR_ADC2LPEN_Msk         (0x1UL << RCC_APB2LPENR_ADC2LPEN_Pos) /*!< 0x00000200 */
N#define RCC_APB2LPENR_ADC2LPEN             RCC_APB2LPENR_ADC2LPEN_Msk          
N#define RCC_APB2LPENR_ADC3LPEN_Pos         (10U)                               
N#define RCC_APB2LPENR_ADC3LPEN_Msk         (0x1UL << RCC_APB2LPENR_ADC3LPEN_Pos) /*!< 0x00000400 */
N#define RCC_APB2LPENR_ADC3LPEN             RCC_APB2LPENR_ADC3LPEN_Msk          
N#define RCC_APB2LPENR_SDIOLPEN_Pos         (11U)                               
N#define RCC_APB2LPENR_SDIOLPEN_Msk         (0x1UL << RCC_APB2LPENR_SDIOLPEN_Pos) /*!< 0x00000800 */
N#define RCC_APB2LPENR_SDIOLPEN             RCC_APB2LPENR_SDIOLPEN_Msk          
N#define RCC_APB2LPENR_SPI1LPEN_Pos         (12U)                               
N#define RCC_APB2LPENR_SPI1LPEN_Msk         (0x1UL << RCC_APB2LPENR_SPI1LPEN_Pos) /*!< 0x00001000 */
N#define RCC_APB2LPENR_SPI1LPEN             RCC_APB2LPENR_SPI1LPEN_Msk          
N#define RCC_APB2LPENR_SYSCFGLPEN_Pos       (14U)                               
N#define RCC_APB2LPENR_SYSCFGLPEN_Msk       (0x1UL << RCC_APB2LPENR_SYSCFGLPEN_Pos) /*!< 0x00004000 */
N#define RCC_APB2LPENR_SYSCFGLPEN           RCC_APB2LPENR_SYSCFGLPEN_Msk        
N#define RCC_APB2LPENR_TIM9LPEN_Pos         (16U)                               
N#define RCC_APB2LPENR_TIM9LPEN_Msk         (0x1UL << RCC_APB2LPENR_TIM9LPEN_Pos) /*!< 0x00010000 */
N#define RCC_APB2LPENR_TIM9LPEN             RCC_APB2LPENR_TIM9LPEN_Msk          
N#define RCC_APB2LPENR_TIM10LPEN_Pos        (17U)                               
N#define RCC_APB2LPENR_TIM10LPEN_Msk        (0x1UL << RCC_APB2LPENR_TIM10LPEN_Pos) /*!< 0x00020000 */
N#define RCC_APB2LPENR_TIM10LPEN            RCC_APB2LPENR_TIM10LPEN_Msk         
N#define RCC_APB2LPENR_TIM11LPEN_Pos        (18U)                               
N#define RCC_APB2LPENR_TIM11LPEN_Msk        (0x1UL << RCC_APB2LPENR_TIM11LPEN_Pos) /*!< 0x00040000 */
N#define RCC_APB2LPENR_TIM11LPEN            RCC_APB2LPENR_TIM11LPEN_Msk         
N
N/********************  Bit definition for RCC_BDCR register  ******************/
N#define RCC_BDCR_LSEON_Pos                 (0U)                                
N#define RCC_BDCR_LSEON_Msk                 (0x1UL << RCC_BDCR_LSEON_Pos)        /*!< 0x00000001 */
N#define RCC_BDCR_LSEON                     RCC_BDCR_LSEON_Msk                  
N#define RCC_BDCR_LSERDY_Pos                (1U)                                
N#define RCC_BDCR_LSERDY_Msk                (0x1UL << RCC_BDCR_LSERDY_Pos)       /*!< 0x00000002 */
N#define RCC_BDCR_LSERDY                    RCC_BDCR_LSERDY_Msk                 
N#define RCC_BDCR_LSEBYP_Pos                (2U)                                
N#define RCC_BDCR_LSEBYP_Msk                (0x1UL << RCC_BDCR_LSEBYP_Pos)       /*!< 0x00000004 */
N#define RCC_BDCR_LSEBYP                    RCC_BDCR_LSEBYP_Msk                 
N
N#define RCC_BDCR_RTCSEL_Pos                (8U)                                
N#define RCC_BDCR_RTCSEL_Msk                (0x3UL << RCC_BDCR_RTCSEL_Pos)       /*!< 0x00000300 */
N#define RCC_BDCR_RTCSEL                    RCC_BDCR_RTCSEL_Msk                 
N#define RCC_BDCR_RTCSEL_0                  (0x1UL << RCC_BDCR_RTCSEL_Pos)       /*!< 0x00000100 */
N#define RCC_BDCR_RTCSEL_1                  (0x2UL << RCC_BDCR_RTCSEL_Pos)       /*!< 0x00000200 */
N
N#define RCC_BDCR_RTCEN_Pos                 (15U)                               
N#define RCC_BDCR_RTCEN_Msk                 (0x1UL << RCC_BDCR_RTCEN_Pos)        /*!< 0x00008000 */
N#define RCC_BDCR_RTCEN                     RCC_BDCR_RTCEN_Msk                  
N#define RCC_BDCR_BDRST_Pos                 (16U)                               
N#define RCC_BDCR_BDRST_Msk                 (0x1UL << RCC_BDCR_BDRST_Pos)        /*!< 0x00010000 */
N#define RCC_BDCR_BDRST                     RCC_BDCR_BDRST_Msk                  
N
N/********************  Bit definition for RCC_CSR register  *******************/
N#define RCC_CSR_LSION_Pos                  (0U)                                
N#define RCC_CSR_LSION_Msk                  (0x1UL << RCC_CSR_LSION_Pos)         /*!< 0x00000001 */
N#define RCC_CSR_LSION                      RCC_CSR_LSION_Msk                   
N#define RCC_CSR_LSIRDY_Pos                 (1U)                                
N#define RCC_CSR_LSIRDY_Msk                 (0x1UL << RCC_CSR_LSIRDY_Pos)        /*!< 0x00000002 */
N#define RCC_CSR_LSIRDY                     RCC_CSR_LSIRDY_Msk                  
N#define RCC_CSR_RMVF_Pos                   (24U)                               
N#define RCC_CSR_RMVF_Msk                   (0x1UL << RCC_CSR_RMVF_Pos)          /*!< 0x01000000 */
N#define RCC_CSR_RMVF                       RCC_CSR_RMVF_Msk                    
N#define RCC_CSR_BORRSTF_Pos                (25U)                               
N#define RCC_CSR_BORRSTF_Msk                (0x1UL << RCC_CSR_BORRSTF_Pos)       /*!< 0x02000000 */
N#define RCC_CSR_BORRSTF                    RCC_CSR_BORRSTF_Msk                 
N#define RCC_CSR_PINRSTF_Pos                (26U)
N#define RCC_CSR_PINRSTF_Msk                (0x1UL << RCC_CSR_PINRSTF_Pos)       /*!< 0x04000000 */
N#define RCC_CSR_PINRSTF                    RCC_CSR_PINRSTF_Msk
N#define RCC_CSR_PORRSTF_Pos                (27U)                               
N#define RCC_CSR_PORRSTF_Msk                (0x1UL << RCC_CSR_PORRSTF_Pos)       /*!< 0x08000000 */
N#define RCC_CSR_PORRSTF                    RCC_CSR_PORRSTF_Msk                 
N#define RCC_CSR_SFTRSTF_Pos                (28U)                               
N#define RCC_CSR_SFTRSTF_Msk                (0x1UL << RCC_CSR_SFTRSTF_Pos)       /*!< 0x10000000 */
N#define RCC_CSR_SFTRSTF                    RCC_CSR_SFTRSTF_Msk                 
N#define RCC_CSR_IWDGRSTF_Pos               (29U)
N#define RCC_CSR_IWDGRSTF_Msk               (0x1UL << RCC_CSR_IWDGRSTF_Pos)      /*!< 0x20000000 */
N#define RCC_CSR_IWDGRSTF                   RCC_CSR_IWDGRSTF_Msk
N#define RCC_CSR_WWDGRSTF_Pos               (30U)                               
N#define RCC_CSR_WWDGRSTF_Msk               (0x1UL << RCC_CSR_WWDGRSTF_Pos)      /*!< 0x40000000 */
N#define RCC_CSR_WWDGRSTF                   RCC_CSR_WWDGRSTF_Msk                
N#define RCC_CSR_LPWRRSTF_Pos               (31U)                               
N#define RCC_CSR_LPWRRSTF_Msk               (0x1UL << RCC_CSR_LPWRRSTF_Pos)      /*!< 0x80000000 */
N#define RCC_CSR_LPWRRSTF                   RCC_CSR_LPWRRSTF_Msk
N/* Legacy defines */
N#define RCC_CSR_PADRSTF                    RCC_CSR_PINRSTF
N#define RCC_CSR_WDGRSTF                    RCC_CSR_IWDGRSTF
N
N/********************  Bit definition for RCC_SSCGR register  *****************/
N#define RCC_SSCGR_MODPER_Pos               (0U)                                
N#define RCC_SSCGR_MODPER_Msk               (0x1FFFUL << RCC_SSCGR_MODPER_Pos)   /*!< 0x00001FFF */
N#define RCC_SSCGR_MODPER                   RCC_SSCGR_MODPER_Msk                
N#define RCC_SSCGR_INCSTEP_Pos              (13U)                               
N#define RCC_SSCGR_INCSTEP_Msk              (0x7FFFUL << RCC_SSCGR_INCSTEP_Pos)  /*!< 0x0FFFE000 */
N#define RCC_SSCGR_INCSTEP                  RCC_SSCGR_INCSTEP_Msk               
N#define RCC_SSCGR_SPREADSEL_Pos            (30U)                               
N#define RCC_SSCGR_SPREADSEL_Msk            (0x1UL << RCC_SSCGR_SPREADSEL_Pos)   /*!< 0x40000000 */
N#define RCC_SSCGR_SPREADSEL                RCC_SSCGR_SPREADSEL_Msk             
N#define RCC_SSCGR_SSCGEN_Pos               (31U)                               
N#define RCC_SSCGR_SSCGEN_Msk               (0x1UL << RCC_SSCGR_SSCGEN_Pos)      /*!< 0x80000000 */
N#define RCC_SSCGR_SSCGEN                   RCC_SSCGR_SSCGEN_Msk                
N
N/********************  Bit definition for RCC_PLLI2SCFGR register  ************/
N#define RCC_PLLI2SCFGR_PLLI2SN_Pos         (6U)                                
N#define RCC_PLLI2SCFGR_PLLI2SN_Msk         (0x1FFUL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00007FC0 */
N#define RCC_PLLI2SCFGR_PLLI2SN             RCC_PLLI2SCFGR_PLLI2SN_Msk          
N#define RCC_PLLI2SCFGR_PLLI2SN_0           (0x001UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000040 */
N#define RCC_PLLI2SCFGR_PLLI2SN_1           (0x002UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000080 */
N#define RCC_PLLI2SCFGR_PLLI2SN_2           (0x004UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000100 */
N#define RCC_PLLI2SCFGR_PLLI2SN_3           (0x008UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000200 */
N#define RCC_PLLI2SCFGR_PLLI2SN_4           (0x010UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000400 */
N#define RCC_PLLI2SCFGR_PLLI2SN_5           (0x020UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000800 */
N#define RCC_PLLI2SCFGR_PLLI2SN_6           (0x040UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00001000 */
N#define RCC_PLLI2SCFGR_PLLI2SN_7           (0x080UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00002000 */
N#define RCC_PLLI2SCFGR_PLLI2SN_8           (0x100UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00004000 */
N
N#define RCC_PLLI2SCFGR_PLLI2SR_Pos         (28U)                               
N#define RCC_PLLI2SCFGR_PLLI2SR_Msk         (0x7UL << RCC_PLLI2SCFGR_PLLI2SR_Pos) /*!< 0x70000000 */
N#define RCC_PLLI2SCFGR_PLLI2SR             RCC_PLLI2SCFGR_PLLI2SR_Msk          
N#define RCC_PLLI2SCFGR_PLLI2SR_0           (0x1UL << RCC_PLLI2SCFGR_PLLI2SR_Pos) /*!< 0x10000000 */
N#define RCC_PLLI2SCFGR_PLLI2SR_1           (0x2UL << RCC_PLLI2SCFGR_PLLI2SR_Pos) /*!< 0x20000000 */
N#define RCC_PLLI2SCFGR_PLLI2SR_2           (0x4UL << RCC_PLLI2SCFGR_PLLI2SR_Pos) /*!< 0x40000000 */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    RNG                                     */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RNG_CR register  *******************/
N#define RNG_CR_RNGEN_Pos    (2U)                                               
N#define RNG_CR_RNGEN_Msk    (0x1UL << RNG_CR_RNGEN_Pos)                         /*!< 0x00000004 */
N#define RNG_CR_RNGEN        RNG_CR_RNGEN_Msk                                   
N#define RNG_CR_IE_Pos       (3U)                                               
N#define RNG_CR_IE_Msk       (0x1UL << RNG_CR_IE_Pos)                            /*!< 0x00000008 */
N#define RNG_CR_IE           RNG_CR_IE_Msk                                      
N
N/********************  Bits definition for RNG_SR register  *******************/
N#define RNG_SR_DRDY_Pos     (0U)                                               
N#define RNG_SR_DRDY_Msk     (0x1UL << RNG_SR_DRDY_Pos)                          /*!< 0x00000001 */
N#define RNG_SR_DRDY         RNG_SR_DRDY_Msk                                    
N#define RNG_SR_CECS_Pos     (1U)                                               
N#define RNG_SR_CECS_Msk     (0x1UL << RNG_SR_CECS_Pos)                          /*!< 0x00000002 */
N#define RNG_SR_CECS         RNG_SR_CECS_Msk                                    
N#define RNG_SR_SECS_Pos     (2U)                                               
N#define RNG_SR_SECS_Msk     (0x1UL << RNG_SR_SECS_Pos)                          /*!< 0x00000004 */
N#define RNG_SR_SECS         RNG_SR_SECS_Msk                                    
N#define RNG_SR_CEIS_Pos     (5U)                                               
N#define RNG_SR_CEIS_Msk     (0x1UL << RNG_SR_CEIS_Pos)                          /*!< 0x00000020 */
N#define RNG_SR_CEIS         RNG_SR_CEIS_Msk                                    
N#define RNG_SR_SEIS_Pos     (6U)                                               
N#define RNG_SR_SEIS_Msk     (0x1UL << RNG_SR_SEIS_Pos)                          /*!< 0x00000040 */
N#define RNG_SR_SEIS         RNG_SR_SEIS_Msk                                    
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Real-Time Clock (RTC)                            */
N/*                                                                            */
N/******************************************************************************/
N/*
N * @brief Specific device feature definitions  (not present on all devices in the STM32F4 serie)
N */
N#define RTC_TAMPER2_SUPPORT  /*!< TAMPER 2 feature support */
N#define RTC_AF2_SUPPORT /*!< RTC Alternate Function 2 mapping support */
N/********************  Bits definition for RTC_TR register  *******************/
N#define RTC_TR_PM_Pos                 (22U)                                    
N#define RTC_TR_PM_Msk                 (0x1UL << RTC_TR_PM_Pos)                  /*!< 0x00400000 */
N#define RTC_TR_PM                     RTC_TR_PM_Msk                            
N#define RTC_TR_HT_Pos                 (20U)                                    
N#define RTC_TR_HT_Msk                 (0x3UL << RTC_TR_HT_Pos)                  /*!< 0x00300000 */
N#define RTC_TR_HT                     RTC_TR_HT_Msk                            
N#define RTC_TR_HT_0                   (0x1UL << RTC_TR_HT_Pos)                  /*!< 0x00100000 */
N#define RTC_TR_HT_1                   (0x2UL << RTC_TR_HT_Pos)                  /*!< 0x00200000 */
N#define RTC_TR_HU_Pos                 (16U)                                    
N#define RTC_TR_HU_Msk                 (0xFUL << RTC_TR_HU_Pos)                  /*!< 0x000F0000 */
N#define RTC_TR_HU                     RTC_TR_HU_Msk                            
N#define RTC_TR_HU_0                   (0x1UL << RTC_TR_HU_Pos)                  /*!< 0x00010000 */
N#define RTC_TR_HU_1                   (0x2UL << RTC_TR_HU_Pos)                  /*!< 0x00020000 */
N#define RTC_TR_HU_2                   (0x4UL << RTC_TR_HU_Pos)                  /*!< 0x00040000 */
N#define RTC_TR_HU_3                   (0x8UL << RTC_TR_HU_Pos)                  /*!< 0x00080000 */
N#define RTC_TR_MNT_Pos                (12U)                                    
N#define RTC_TR_MNT_Msk                (0x7UL << RTC_TR_MNT_Pos)                 /*!< 0x00007000 */
N#define RTC_TR_MNT                    RTC_TR_MNT_Msk                           
N#define RTC_TR_MNT_0                  (0x1UL << RTC_TR_MNT_Pos)                 /*!< 0x00001000 */
N#define RTC_TR_MNT_1                  (0x2UL << RTC_TR_MNT_Pos)                 /*!< 0x00002000 */
N#define RTC_TR_MNT_2                  (0x4UL << RTC_TR_MNT_Pos)                 /*!< 0x00004000 */
N#define RTC_TR_MNU_Pos                (8U)                                     
N#define RTC_TR_MNU_Msk                (0xFUL << RTC_TR_MNU_Pos)                 /*!< 0x00000F00 */
N#define RTC_TR_MNU                    RTC_TR_MNU_Msk                           
N#define RTC_TR_MNU_0                  (0x1UL << RTC_TR_MNU_Pos)                 /*!< 0x00000100 */
N#define RTC_TR_MNU_1                  (0x2UL << RTC_TR_MNU_Pos)                 /*!< 0x00000200 */
N#define RTC_TR_MNU_2                  (0x4UL << RTC_TR_MNU_Pos)                 /*!< 0x00000400 */
N#define RTC_TR_MNU_3                  (0x8UL << RTC_TR_MNU_Pos)                 /*!< 0x00000800 */
N#define RTC_TR_ST_Pos                 (4U)                                     
N#define RTC_TR_ST_Msk                 (0x7UL << RTC_TR_ST_Pos)                  /*!< 0x00000070 */
N#define RTC_TR_ST                     RTC_TR_ST_Msk                            
N#define RTC_TR_ST_0                   (0x1UL << RTC_TR_ST_Pos)                  /*!< 0x00000010 */
N#define RTC_TR_ST_1                   (0x2UL << RTC_TR_ST_Pos)                  /*!< 0x00000020 */
N#define RTC_TR_ST_2                   (0x4UL << RTC_TR_ST_Pos)                  /*!< 0x00000040 */
N#define RTC_TR_SU_Pos                 (0U)                                     
N#define RTC_TR_SU_Msk                 (0xFUL << RTC_TR_SU_Pos)                  /*!< 0x0000000F */
N#define RTC_TR_SU                     RTC_TR_SU_Msk                            
N#define RTC_TR_SU_0                   (0x1UL << RTC_TR_SU_Pos)                  /*!< 0x00000001 */
N#define RTC_TR_SU_1                   (0x2UL << RTC_TR_SU_Pos)                  /*!< 0x00000002 */
N#define RTC_TR_SU_2                   (0x4UL << RTC_TR_SU_Pos)                  /*!< 0x00000004 */
N#define RTC_TR_SU_3                   (0x8UL << RTC_TR_SU_Pos)                  /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_DR register  *******************/
N#define RTC_DR_YT_Pos                 (20U)                                    
N#define RTC_DR_YT_Msk                 (0xFUL << RTC_DR_YT_Pos)                  /*!< 0x00F00000 */
N#define RTC_DR_YT                     RTC_DR_YT_Msk                            
N#define RTC_DR_YT_0                   (0x1UL << RTC_DR_YT_Pos)                  /*!< 0x00100000 */
N#define RTC_DR_YT_1                   (0x2UL << RTC_DR_YT_Pos)                  /*!< 0x00200000 */
N#define RTC_DR_YT_2                   (0x4UL << RTC_DR_YT_Pos)                  /*!< 0x00400000 */
N#define RTC_DR_YT_3                   (0x8UL << RTC_DR_YT_Pos)                  /*!< 0x00800000 */
N#define RTC_DR_YU_Pos                 (16U)                                    
N#define RTC_DR_YU_Msk                 (0xFUL << RTC_DR_YU_Pos)                  /*!< 0x000F0000 */
N#define RTC_DR_YU                     RTC_DR_YU_Msk                            
N#define RTC_DR_YU_0                   (0x1UL << RTC_DR_YU_Pos)                  /*!< 0x00010000 */
N#define RTC_DR_YU_1                   (0x2UL << RTC_DR_YU_Pos)                  /*!< 0x00020000 */
N#define RTC_DR_YU_2                   (0x4UL << RTC_DR_YU_Pos)                  /*!< 0x00040000 */
N#define RTC_DR_YU_3                   (0x8UL << RTC_DR_YU_Pos)                  /*!< 0x00080000 */
N#define RTC_DR_WDU_Pos                (13U)                                    
N#define RTC_DR_WDU_Msk                (0x7UL << RTC_DR_WDU_Pos)                 /*!< 0x0000E000 */
N#define RTC_DR_WDU                    RTC_DR_WDU_Msk                           
N#define RTC_DR_WDU_0                  (0x1UL << RTC_DR_WDU_Pos)                 /*!< 0x00002000 */
N#define RTC_DR_WDU_1                  (0x2UL << RTC_DR_WDU_Pos)                 /*!< 0x00004000 */
N#define RTC_DR_WDU_2                  (0x4UL << RTC_DR_WDU_Pos)                 /*!< 0x00008000 */
N#define RTC_DR_MT_Pos                 (12U)                                    
N#define RTC_DR_MT_Msk                 (0x1UL << RTC_DR_MT_Pos)                  /*!< 0x00001000 */
N#define RTC_DR_MT                     RTC_DR_MT_Msk                            
N#define RTC_DR_MU_Pos                 (8U)                                     
N#define RTC_DR_MU_Msk                 (0xFUL << RTC_DR_MU_Pos)                  /*!< 0x00000F00 */
N#define RTC_DR_MU                     RTC_DR_MU_Msk                            
N#define RTC_DR_MU_0                   (0x1UL << RTC_DR_MU_Pos)                  /*!< 0x00000100 */
N#define RTC_DR_MU_1                   (0x2UL << RTC_DR_MU_Pos)                  /*!< 0x00000200 */
N#define RTC_DR_MU_2                   (0x4UL << RTC_DR_MU_Pos)                  /*!< 0x00000400 */
N#define RTC_DR_MU_3                   (0x8UL << RTC_DR_MU_Pos)                  /*!< 0x00000800 */
N#define RTC_DR_DT_Pos                 (4U)                                     
N#define RTC_DR_DT_Msk                 (0x3UL << RTC_DR_DT_Pos)                  /*!< 0x00000030 */
N#define RTC_DR_DT                     RTC_DR_DT_Msk                            
N#define RTC_DR_DT_0                   (0x1UL << RTC_DR_DT_Pos)                  /*!< 0x00000010 */
N#define RTC_DR_DT_1                   (0x2UL << RTC_DR_DT_Pos)                  /*!< 0x00000020 */
N#define RTC_DR_DU_Pos                 (0U)                                     
N#define RTC_DR_DU_Msk                 (0xFUL << RTC_DR_DU_Pos)                  /*!< 0x0000000F */
N#define RTC_DR_DU                     RTC_DR_DU_Msk                            
N#define RTC_DR_DU_0                   (0x1UL << RTC_DR_DU_Pos)                  /*!< 0x00000001 */
N#define RTC_DR_DU_1                   (0x2UL << RTC_DR_DU_Pos)                  /*!< 0x00000002 */
N#define RTC_DR_DU_2                   (0x4UL << RTC_DR_DU_Pos)                  /*!< 0x00000004 */
N#define RTC_DR_DU_3                   (0x8UL << RTC_DR_DU_Pos)                  /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_CR register  *******************/
N#define RTC_CR_COE_Pos                (23U)                                    
N#define RTC_CR_COE_Msk                (0x1UL << RTC_CR_COE_Pos)                 /*!< 0x00800000 */
N#define RTC_CR_COE                    RTC_CR_COE_Msk                           
N#define RTC_CR_OSEL_Pos               (21U)                                    
N#define RTC_CR_OSEL_Msk               (0x3UL << RTC_CR_OSEL_Pos)                /*!< 0x00600000 */
N#define RTC_CR_OSEL                   RTC_CR_OSEL_Msk                          
N#define RTC_CR_OSEL_0                 (0x1UL << RTC_CR_OSEL_Pos)                /*!< 0x00200000 */
N#define RTC_CR_OSEL_1                 (0x2UL << RTC_CR_OSEL_Pos)                /*!< 0x00400000 */
N#define RTC_CR_POL_Pos                (20U)                                    
N#define RTC_CR_POL_Msk                (0x1UL << RTC_CR_POL_Pos)                 /*!< 0x00100000 */
N#define RTC_CR_POL                    RTC_CR_POL_Msk                           
N#define RTC_CR_COSEL_Pos              (19U)                                    
N#define RTC_CR_COSEL_Msk              (0x1UL << RTC_CR_COSEL_Pos)               /*!< 0x00080000 */
N#define RTC_CR_COSEL                  RTC_CR_COSEL_Msk                         
N#define RTC_CR_BKP_Pos                 (18U)                                   
N#define RTC_CR_BKP_Msk                 (0x1UL << RTC_CR_BKP_Pos)                /*!< 0x00040000 */
N#define RTC_CR_BKP                     RTC_CR_BKP_Msk                          
N#define RTC_CR_SUB1H_Pos              (17U)                                    
N#define RTC_CR_SUB1H_Msk              (0x1UL << RTC_CR_SUB1H_Pos)               /*!< 0x00020000 */
N#define RTC_CR_SUB1H                  RTC_CR_SUB1H_Msk                         
N#define RTC_CR_ADD1H_Pos              (16U)                                    
N#define RTC_CR_ADD1H_Msk              (0x1UL << RTC_CR_ADD1H_Pos)               /*!< 0x00010000 */
N#define RTC_CR_ADD1H                  RTC_CR_ADD1H_Msk                         
N#define RTC_CR_TSIE_Pos               (15U)                                    
N#define RTC_CR_TSIE_Msk               (0x1UL << RTC_CR_TSIE_Pos)                /*!< 0x00008000 */
N#define RTC_CR_TSIE                   RTC_CR_TSIE_Msk                          
N#define RTC_CR_WUTIE_Pos              (14U)                                    
N#define RTC_CR_WUTIE_Msk              (0x1UL << RTC_CR_WUTIE_Pos)               /*!< 0x00004000 */
N#define RTC_CR_WUTIE                  RTC_CR_WUTIE_Msk                         
N#define RTC_CR_ALRBIE_Pos             (13U)                                    
N#define RTC_CR_ALRBIE_Msk             (0x1UL << RTC_CR_ALRBIE_Pos)              /*!< 0x00002000 */
N#define RTC_CR_ALRBIE                 RTC_CR_ALRBIE_Msk                        
N#define RTC_CR_ALRAIE_Pos             (12U)                                    
N#define RTC_CR_ALRAIE_Msk             (0x1UL << RTC_CR_ALRAIE_Pos)              /*!< 0x00001000 */
N#define RTC_CR_ALRAIE                 RTC_CR_ALRAIE_Msk                        
N#define RTC_CR_TSE_Pos                (11U)                                    
N#define RTC_CR_TSE_Msk                (0x1UL << RTC_CR_TSE_Pos)                 /*!< 0x00000800 */
N#define RTC_CR_TSE                    RTC_CR_TSE_Msk                           
N#define RTC_CR_WUTE_Pos               (10U)                                    
N#define RTC_CR_WUTE_Msk               (0x1UL << RTC_CR_WUTE_Pos)                /*!< 0x00000400 */
N#define RTC_CR_WUTE                   RTC_CR_WUTE_Msk                          
N#define RTC_CR_ALRBE_Pos              (9U)                                     
N#define RTC_CR_ALRBE_Msk              (0x1UL << RTC_CR_ALRBE_Pos)               /*!< 0x00000200 */
N#define RTC_CR_ALRBE                  RTC_CR_ALRBE_Msk                         
N#define RTC_CR_ALRAE_Pos              (8U)                                     
N#define RTC_CR_ALRAE_Msk              (0x1UL << RTC_CR_ALRAE_Pos)               /*!< 0x00000100 */
N#define RTC_CR_ALRAE                  RTC_CR_ALRAE_Msk                         
N#define RTC_CR_DCE_Pos                (7U)                                     
N#define RTC_CR_DCE_Msk                (0x1UL << RTC_CR_DCE_Pos)                 /*!< 0x00000080 */
N#define RTC_CR_DCE                    RTC_CR_DCE_Msk                           
N#define RTC_CR_FMT_Pos                (6U)                                     
N#define RTC_CR_FMT_Msk                (0x1UL << RTC_CR_FMT_Pos)                 /*!< 0x00000040 */
N#define RTC_CR_FMT                    RTC_CR_FMT_Msk                           
N#define RTC_CR_BYPSHAD_Pos            (5U)                                     
N#define RTC_CR_BYPSHAD_Msk            (0x1UL << RTC_CR_BYPSHAD_Pos)             /*!< 0x00000020 */
N#define RTC_CR_BYPSHAD                RTC_CR_BYPSHAD_Msk                       
N#define RTC_CR_REFCKON_Pos            (4U)                                     
N#define RTC_CR_REFCKON_Msk            (0x1UL << RTC_CR_REFCKON_Pos)             /*!< 0x00000010 */
N#define RTC_CR_REFCKON                RTC_CR_REFCKON_Msk                       
N#define RTC_CR_TSEDGE_Pos             (3U)                                     
N#define RTC_CR_TSEDGE_Msk             (0x1UL << RTC_CR_TSEDGE_Pos)              /*!< 0x00000008 */
N#define RTC_CR_TSEDGE                 RTC_CR_TSEDGE_Msk                        
N#define RTC_CR_WUCKSEL_Pos            (0U)                                     
N#define RTC_CR_WUCKSEL_Msk            (0x7UL << RTC_CR_WUCKSEL_Pos)             /*!< 0x00000007 */
N#define RTC_CR_WUCKSEL                RTC_CR_WUCKSEL_Msk                       
N#define RTC_CR_WUCKSEL_0              (0x1UL << RTC_CR_WUCKSEL_Pos)             /*!< 0x00000001 */
N#define RTC_CR_WUCKSEL_1              (0x2UL << RTC_CR_WUCKSEL_Pos)             /*!< 0x00000002 */
N#define RTC_CR_WUCKSEL_2              (0x4UL << RTC_CR_WUCKSEL_Pos)             /*!< 0x00000004 */
N
N/* Legacy defines */
N#define RTC_CR_BCK                     RTC_CR_BKP
N
N/********************  Bits definition for RTC_ISR register  ******************/
N#define RTC_ISR_RECALPF_Pos           (16U)                                    
N#define RTC_ISR_RECALPF_Msk           (0x1UL << RTC_ISR_RECALPF_Pos)            /*!< 0x00010000 */
N#define RTC_ISR_RECALPF               RTC_ISR_RECALPF_Msk                      
N#define RTC_ISR_TAMP1F_Pos            (13U)                                    
N#define RTC_ISR_TAMP1F_Msk            (0x1UL << RTC_ISR_TAMP1F_Pos)             /*!< 0x00002000 */
N#define RTC_ISR_TAMP1F                RTC_ISR_TAMP1F_Msk                       
N#define RTC_ISR_TAMP2F_Pos            (14U)                                    
N#define RTC_ISR_TAMP2F_Msk            (0x1UL << RTC_ISR_TAMP2F_Pos)             /*!< 0x00004000 */
N#define RTC_ISR_TAMP2F                RTC_ISR_TAMP2F_Msk                       
N#define RTC_ISR_TSOVF_Pos             (12U)                                    
N#define RTC_ISR_TSOVF_Msk             (0x1UL << RTC_ISR_TSOVF_Pos)              /*!< 0x00001000 */
N#define RTC_ISR_TSOVF                 RTC_ISR_TSOVF_Msk                        
N#define RTC_ISR_TSF_Pos               (11U)                                    
N#define RTC_ISR_TSF_Msk               (0x1UL << RTC_ISR_TSF_Pos)                /*!< 0x00000800 */
N#define RTC_ISR_TSF                   RTC_ISR_TSF_Msk                          
N#define RTC_ISR_WUTF_Pos              (10U)                                    
N#define RTC_ISR_WUTF_Msk              (0x1UL << RTC_ISR_WUTF_Pos)               /*!< 0x00000400 */
N#define RTC_ISR_WUTF                  RTC_ISR_WUTF_Msk                         
N#define RTC_ISR_ALRBF_Pos             (9U)                                     
N#define RTC_ISR_ALRBF_Msk             (0x1UL << RTC_ISR_ALRBF_Pos)              /*!< 0x00000200 */
N#define RTC_ISR_ALRBF                 RTC_ISR_ALRBF_Msk                        
N#define RTC_ISR_ALRAF_Pos             (8U)                                     
N#define RTC_ISR_ALRAF_Msk             (0x1UL << RTC_ISR_ALRAF_Pos)              /*!< 0x00000100 */
N#define RTC_ISR_ALRAF                 RTC_ISR_ALRAF_Msk                        
N#define RTC_ISR_INIT_Pos              (7U)                                     
N#define RTC_ISR_INIT_Msk              (0x1UL << RTC_ISR_INIT_Pos)               /*!< 0x00000080 */
N#define RTC_ISR_INIT                  RTC_ISR_INIT_Msk                         
N#define RTC_ISR_INITF_Pos             (6U)                                     
N#define RTC_ISR_INITF_Msk             (0x1UL << RTC_ISR_INITF_Pos)              /*!< 0x00000040 */
N#define RTC_ISR_INITF                 RTC_ISR_INITF_Msk                        
N#define RTC_ISR_RSF_Pos               (5U)                                     
N#define RTC_ISR_RSF_Msk               (0x1UL << RTC_ISR_RSF_Pos)                /*!< 0x00000020 */
N#define RTC_ISR_RSF                   RTC_ISR_RSF_Msk                          
N#define RTC_ISR_INITS_Pos             (4U)                                     
N#define RTC_ISR_INITS_Msk             (0x1UL << RTC_ISR_INITS_Pos)              /*!< 0x00000010 */
N#define RTC_ISR_INITS                 RTC_ISR_INITS_Msk                        
N#define RTC_ISR_SHPF_Pos              (3U)                                     
N#define RTC_ISR_SHPF_Msk              (0x1UL << RTC_ISR_SHPF_Pos)               /*!< 0x00000008 */
N#define RTC_ISR_SHPF                  RTC_ISR_SHPF_Msk                         
N#define RTC_ISR_WUTWF_Pos             (2U)                                     
N#define RTC_ISR_WUTWF_Msk             (0x1UL << RTC_ISR_WUTWF_Pos)              /*!< 0x00000004 */
N#define RTC_ISR_WUTWF                 RTC_ISR_WUTWF_Msk                        
N#define RTC_ISR_ALRBWF_Pos            (1U)                                     
N#define RTC_ISR_ALRBWF_Msk            (0x1UL << RTC_ISR_ALRBWF_Pos)             /*!< 0x00000002 */
N#define RTC_ISR_ALRBWF                RTC_ISR_ALRBWF_Msk                       
N#define RTC_ISR_ALRAWF_Pos            (0U)                                     
N#define RTC_ISR_ALRAWF_Msk            (0x1UL << RTC_ISR_ALRAWF_Pos)             /*!< 0x00000001 */
N#define RTC_ISR_ALRAWF                RTC_ISR_ALRAWF_Msk                       
N
N/********************  Bits definition for RTC_PRER register  *****************/
N#define RTC_PRER_PREDIV_A_Pos         (16U)                                    
N#define RTC_PRER_PREDIV_A_Msk         (0x7FUL << RTC_PRER_PREDIV_A_Pos)         /*!< 0x007F0000 */
N#define RTC_PRER_PREDIV_A             RTC_PRER_PREDIV_A_Msk                    
N#define RTC_PRER_PREDIV_S_Pos         (0U)                                     
N#define RTC_PRER_PREDIV_S_Msk         (0x7FFFUL << RTC_PRER_PREDIV_S_Pos)       /*!< 0x00007FFF */
N#define RTC_PRER_PREDIV_S             RTC_PRER_PREDIV_S_Msk                    
N
N/********************  Bits definition for RTC_WUTR register  *****************/
N#define RTC_WUTR_WUT_Pos              (0U)                                     
N#define RTC_WUTR_WUT_Msk              (0xFFFFUL << RTC_WUTR_WUT_Pos)            /*!< 0x0000FFFF */
N#define RTC_WUTR_WUT                  RTC_WUTR_WUT_Msk                         
N
N/********************  Bits definition for RTC_CALIBR register  ***************/
N#define RTC_CALIBR_DCS_Pos            (7U)                                     
N#define RTC_CALIBR_DCS_Msk            (0x1UL << RTC_CALIBR_DCS_Pos)             /*!< 0x00000080 */
N#define RTC_CALIBR_DCS                RTC_CALIBR_DCS_Msk                       
N#define RTC_CALIBR_DC_Pos             (0U)                                     
N#define RTC_CALIBR_DC_Msk             (0x1FUL << RTC_CALIBR_DC_Pos)             /*!< 0x0000001F */
N#define RTC_CALIBR_DC                 RTC_CALIBR_DC_Msk                        
N
N/********************  Bits definition for RTC_ALRMAR register  ***************/
N#define RTC_ALRMAR_MSK4_Pos           (31U)                                    
N#define RTC_ALRMAR_MSK4_Msk           (0x1UL << RTC_ALRMAR_MSK4_Pos)            /*!< 0x80000000 */
N#define RTC_ALRMAR_MSK4               RTC_ALRMAR_MSK4_Msk                      
N#define RTC_ALRMAR_WDSEL_Pos          (30U)                                    
N#define RTC_ALRMAR_WDSEL_Msk          (0x1UL << RTC_ALRMAR_WDSEL_Pos)           /*!< 0x40000000 */
N#define RTC_ALRMAR_WDSEL              RTC_ALRMAR_WDSEL_Msk                     
N#define RTC_ALRMAR_DT_Pos             (28U)                                    
N#define RTC_ALRMAR_DT_Msk             (0x3UL << RTC_ALRMAR_DT_Pos)              /*!< 0x30000000 */
N#define RTC_ALRMAR_DT                 RTC_ALRMAR_DT_Msk                        
N#define RTC_ALRMAR_DT_0               (0x1UL << RTC_ALRMAR_DT_Pos)              /*!< 0x10000000 */
N#define RTC_ALRMAR_DT_1               (0x2UL << RTC_ALRMAR_DT_Pos)              /*!< 0x20000000 */
N#define RTC_ALRMAR_DU_Pos             (24U)                                    
N#define RTC_ALRMAR_DU_Msk             (0xFUL << RTC_ALRMAR_DU_Pos)              /*!< 0x0F000000 */
N#define RTC_ALRMAR_DU                 RTC_ALRMAR_DU_Msk                        
N#define RTC_ALRMAR_DU_0               (0x1UL << RTC_ALRMAR_DU_Pos)              /*!< 0x01000000 */
N#define RTC_ALRMAR_DU_1               (0x2UL << RTC_ALRMAR_DU_Pos)              /*!< 0x02000000 */
N#define RTC_ALRMAR_DU_2               (0x4UL << RTC_ALRMAR_DU_Pos)              /*!< 0x04000000 */
N#define RTC_ALRMAR_DU_3               (0x8UL << RTC_ALRMAR_DU_Pos)              /*!< 0x08000000 */
N#define RTC_ALRMAR_MSK3_Pos           (23U)                                    
N#define RTC_ALRMAR_MSK3_Msk           (0x1UL << RTC_ALRMAR_MSK3_Pos)            /*!< 0x00800000 */
N#define RTC_ALRMAR_MSK3               RTC_ALRMAR_MSK3_Msk                      
N#define RTC_ALRMAR_PM_Pos             (22U)                                    
N#define RTC_ALRMAR_PM_Msk             (0x1UL << RTC_ALRMAR_PM_Pos)              /*!< 0x00400000 */
N#define RTC_ALRMAR_PM                 RTC_ALRMAR_PM_Msk                        
N#define RTC_ALRMAR_HT_Pos             (20U)                                    
N#define RTC_ALRMAR_HT_Msk             (0x3UL << RTC_ALRMAR_HT_Pos)              /*!< 0x00300000 */
N#define RTC_ALRMAR_HT                 RTC_ALRMAR_HT_Msk                        
N#define RTC_ALRMAR_HT_0               (0x1UL << RTC_ALRMAR_HT_Pos)              /*!< 0x00100000 */
N#define RTC_ALRMAR_HT_1               (0x2UL << RTC_ALRMAR_HT_Pos)              /*!< 0x00200000 */
N#define RTC_ALRMAR_HU_Pos             (16U)                                    
N#define RTC_ALRMAR_HU_Msk             (0xFUL << RTC_ALRMAR_HU_Pos)              /*!< 0x000F0000 */
N#define RTC_ALRMAR_HU                 RTC_ALRMAR_HU_Msk                        
N#define RTC_ALRMAR_HU_0               (0x1UL << RTC_ALRMAR_HU_Pos)              /*!< 0x00010000 */
N#define RTC_ALRMAR_HU_1               (0x2UL << RTC_ALRMAR_HU_Pos)              /*!< 0x00020000 */
N#define RTC_ALRMAR_HU_2               (0x4UL << RTC_ALRMAR_HU_Pos)              /*!< 0x00040000 */
N#define RTC_ALRMAR_HU_3               (0x8UL << RTC_ALRMAR_HU_Pos)              /*!< 0x00080000 */
N#define RTC_ALRMAR_MSK2_Pos           (15U)                                    
N#define RTC_ALRMAR_MSK2_Msk           (0x1UL << RTC_ALRMAR_MSK2_Pos)            /*!< 0x00008000 */
N#define RTC_ALRMAR_MSK2               RTC_ALRMAR_MSK2_Msk                      
N#define RTC_ALRMAR_MNT_Pos            (12U)                                    
N#define RTC_ALRMAR_MNT_Msk            (0x7UL << RTC_ALRMAR_MNT_Pos)             /*!< 0x00007000 */
N#define RTC_ALRMAR_MNT                RTC_ALRMAR_MNT_Msk                       
N#define RTC_ALRMAR_MNT_0              (0x1UL << RTC_ALRMAR_MNT_Pos)             /*!< 0x00001000 */
N#define RTC_ALRMAR_MNT_1              (0x2UL << RTC_ALRMAR_MNT_Pos)             /*!< 0x00002000 */
N#define RTC_ALRMAR_MNT_2              (0x4UL << RTC_ALRMAR_MNT_Pos)             /*!< 0x00004000 */
N#define RTC_ALRMAR_MNU_Pos            (8U)                                     
N#define RTC_ALRMAR_MNU_Msk            (0xFUL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000F00 */
N#define RTC_ALRMAR_MNU                RTC_ALRMAR_MNU_Msk                       
N#define RTC_ALRMAR_MNU_0              (0x1UL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000100 */
N#define RTC_ALRMAR_MNU_1              (0x2UL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000200 */
N#define RTC_ALRMAR_MNU_2              (0x4UL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000400 */
N#define RTC_ALRMAR_MNU_3              (0x8UL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000800 */
N#define RTC_ALRMAR_MSK1_Pos           (7U)                                     
N#define RTC_ALRMAR_MSK1_Msk           (0x1UL << RTC_ALRMAR_MSK1_Pos)            /*!< 0x00000080 */
N#define RTC_ALRMAR_MSK1               RTC_ALRMAR_MSK1_Msk                      
N#define RTC_ALRMAR_ST_Pos             (4U)                                     
N#define RTC_ALRMAR_ST_Msk             (0x7UL << RTC_ALRMAR_ST_Pos)              /*!< 0x00000070 */
N#define RTC_ALRMAR_ST                 RTC_ALRMAR_ST_Msk                        
N#define RTC_ALRMAR_ST_0               (0x1UL << RTC_ALRMAR_ST_Pos)              /*!< 0x00000010 */
N#define RTC_ALRMAR_ST_1               (0x2UL << RTC_ALRMAR_ST_Pos)              /*!< 0x00000020 */
N#define RTC_ALRMAR_ST_2               (0x4UL << RTC_ALRMAR_ST_Pos)              /*!< 0x00000040 */
N#define RTC_ALRMAR_SU_Pos             (0U)                                     
N#define RTC_ALRMAR_SU_Msk             (0xFUL << RTC_ALRMAR_SU_Pos)              /*!< 0x0000000F */
N#define RTC_ALRMAR_SU                 RTC_ALRMAR_SU_Msk                        
N#define RTC_ALRMAR_SU_0               (0x1UL << RTC_ALRMAR_SU_Pos)              /*!< 0x00000001 */
N#define RTC_ALRMAR_SU_1               (0x2UL << RTC_ALRMAR_SU_Pos)              /*!< 0x00000002 */
N#define RTC_ALRMAR_SU_2               (0x4UL << RTC_ALRMAR_SU_Pos)              /*!< 0x00000004 */
N#define RTC_ALRMAR_SU_3               (0x8UL << RTC_ALRMAR_SU_Pos)              /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_ALRMBR register  ***************/
N#define RTC_ALRMBR_MSK4_Pos           (31U)                                    
N#define RTC_ALRMBR_MSK4_Msk           (0x1UL << RTC_ALRMBR_MSK4_Pos)            /*!< 0x80000000 */
N#define RTC_ALRMBR_MSK4               RTC_ALRMBR_MSK4_Msk                      
N#define RTC_ALRMBR_WDSEL_Pos          (30U)                                    
N#define RTC_ALRMBR_WDSEL_Msk          (0x1UL << RTC_ALRMBR_WDSEL_Pos)           /*!< 0x40000000 */
N#define RTC_ALRMBR_WDSEL              RTC_ALRMBR_WDSEL_Msk                     
N#define RTC_ALRMBR_DT_Pos             (28U)                                    
N#define RTC_ALRMBR_DT_Msk             (0x3UL << RTC_ALRMBR_DT_Pos)              /*!< 0x30000000 */
N#define RTC_ALRMBR_DT                 RTC_ALRMBR_DT_Msk                        
N#define RTC_ALRMBR_DT_0               (0x1UL << RTC_ALRMBR_DT_Pos)              /*!< 0x10000000 */
N#define RTC_ALRMBR_DT_1               (0x2UL << RTC_ALRMBR_DT_Pos)              /*!< 0x20000000 */
N#define RTC_ALRMBR_DU_Pos             (24U)                                    
N#define RTC_ALRMBR_DU_Msk             (0xFUL << RTC_ALRMBR_DU_Pos)              /*!< 0x0F000000 */
N#define RTC_ALRMBR_DU                 RTC_ALRMBR_DU_Msk                        
N#define RTC_ALRMBR_DU_0               (0x1UL << RTC_ALRMBR_DU_Pos)              /*!< 0x01000000 */
N#define RTC_ALRMBR_DU_1               (0x2UL << RTC_ALRMBR_DU_Pos)              /*!< 0x02000000 */
N#define RTC_ALRMBR_DU_2               (0x4UL << RTC_ALRMBR_DU_Pos)              /*!< 0x04000000 */
N#define RTC_ALRMBR_DU_3               (0x8UL << RTC_ALRMBR_DU_Pos)              /*!< 0x08000000 */
N#define RTC_ALRMBR_MSK3_Pos           (23U)                                    
N#define RTC_ALRMBR_MSK3_Msk           (0x1UL << RTC_ALRMBR_MSK3_Pos)            /*!< 0x00800000 */
N#define RTC_ALRMBR_MSK3               RTC_ALRMBR_MSK3_Msk                      
N#define RTC_ALRMBR_PM_Pos             (22U)                                    
N#define RTC_ALRMBR_PM_Msk             (0x1UL << RTC_ALRMBR_PM_Pos)              /*!< 0x00400000 */
N#define RTC_ALRMBR_PM                 RTC_ALRMBR_PM_Msk                        
N#define RTC_ALRMBR_HT_Pos             (20U)                                    
N#define RTC_ALRMBR_HT_Msk             (0x3UL << RTC_ALRMBR_HT_Pos)              /*!< 0x00300000 */
N#define RTC_ALRMBR_HT                 RTC_ALRMBR_HT_Msk                        
N#define RTC_ALRMBR_HT_0               (0x1UL << RTC_ALRMBR_HT_Pos)              /*!< 0x00100000 */
N#define RTC_ALRMBR_HT_1               (0x2UL << RTC_ALRMBR_HT_Pos)              /*!< 0x00200000 */
N#define RTC_ALRMBR_HU_Pos             (16U)                                    
N#define RTC_ALRMBR_HU_Msk             (0xFUL << RTC_ALRMBR_HU_Pos)              /*!< 0x000F0000 */
N#define RTC_ALRMBR_HU                 RTC_ALRMBR_HU_Msk                        
N#define RTC_ALRMBR_HU_0               (0x1UL << RTC_ALRMBR_HU_Pos)              /*!< 0x00010000 */
N#define RTC_ALRMBR_HU_1               (0x2UL << RTC_ALRMBR_HU_Pos)              /*!< 0x00020000 */
N#define RTC_ALRMBR_HU_2               (0x4UL << RTC_ALRMBR_HU_Pos)              /*!< 0x00040000 */
N#define RTC_ALRMBR_HU_3               (0x8UL << RTC_ALRMBR_HU_Pos)              /*!< 0x00080000 */
N#define RTC_ALRMBR_MSK2_Pos           (15U)                                    
N#define RTC_ALRMBR_MSK2_Msk           (0x1UL << RTC_ALRMBR_MSK2_Pos)            /*!< 0x00008000 */
N#define RTC_ALRMBR_MSK2               RTC_ALRMBR_MSK2_Msk                      
N#define RTC_ALRMBR_MNT_Pos            (12U)                                    
N#define RTC_ALRMBR_MNT_Msk            (0x7UL << RTC_ALRMBR_MNT_Pos)             /*!< 0x00007000 */
N#define RTC_ALRMBR_MNT                RTC_ALRMBR_MNT_Msk                       
N#define RTC_ALRMBR_MNT_0              (0x1UL << RTC_ALRMBR_MNT_Pos)             /*!< 0x00001000 */
N#define RTC_ALRMBR_MNT_1              (0x2UL << RTC_ALRMBR_MNT_Pos)             /*!< 0x00002000 */
N#define RTC_ALRMBR_MNT_2              (0x4UL << RTC_ALRMBR_MNT_Pos)             /*!< 0x00004000 */
N#define RTC_ALRMBR_MNU_Pos            (8U)                                     
N#define RTC_ALRMBR_MNU_Msk            (0xFUL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000F00 */
N#define RTC_ALRMBR_MNU                RTC_ALRMBR_MNU_Msk                       
N#define RTC_ALRMBR_MNU_0              (0x1UL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000100 */
N#define RTC_ALRMBR_MNU_1              (0x2UL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000200 */
N#define RTC_ALRMBR_MNU_2              (0x4UL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000400 */
N#define RTC_ALRMBR_MNU_3              (0x8UL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000800 */
N#define RTC_ALRMBR_MSK1_Pos           (7U)                                     
N#define RTC_ALRMBR_MSK1_Msk           (0x1UL << RTC_ALRMBR_MSK1_Pos)            /*!< 0x00000080 */
N#define RTC_ALRMBR_MSK1               RTC_ALRMBR_MSK1_Msk                      
N#define RTC_ALRMBR_ST_Pos             (4U)                                     
N#define RTC_ALRMBR_ST_Msk             (0x7UL << RTC_ALRMBR_ST_Pos)              /*!< 0x00000070 */
N#define RTC_ALRMBR_ST                 RTC_ALRMBR_ST_Msk                        
N#define RTC_ALRMBR_ST_0               (0x1UL << RTC_ALRMBR_ST_Pos)              /*!< 0x00000010 */
N#define RTC_ALRMBR_ST_1               (0x2UL << RTC_ALRMBR_ST_Pos)              /*!< 0x00000020 */
N#define RTC_ALRMBR_ST_2               (0x4UL << RTC_ALRMBR_ST_Pos)              /*!< 0x00000040 */
N#define RTC_ALRMBR_SU_Pos             (0U)                                     
N#define RTC_ALRMBR_SU_Msk             (0xFUL << RTC_ALRMBR_SU_Pos)              /*!< 0x0000000F */
N#define RTC_ALRMBR_SU                 RTC_ALRMBR_SU_Msk                        
N#define RTC_ALRMBR_SU_0               (0x1UL << RTC_ALRMBR_SU_Pos)              /*!< 0x00000001 */
N#define RTC_ALRMBR_SU_1               (0x2UL << RTC_ALRMBR_SU_Pos)              /*!< 0x00000002 */
N#define RTC_ALRMBR_SU_2               (0x4UL << RTC_ALRMBR_SU_Pos)              /*!< 0x00000004 */
N#define RTC_ALRMBR_SU_3               (0x8UL << RTC_ALRMBR_SU_Pos)              /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_WPR register  ******************/
N#define RTC_WPR_KEY_Pos               (0U)                                     
N#define RTC_WPR_KEY_Msk               (0xFFUL << RTC_WPR_KEY_Pos)               /*!< 0x000000FF */
N#define RTC_WPR_KEY                   RTC_WPR_KEY_Msk                          
N
N/********************  Bits definition for RTC_SSR register  ******************/
N#define RTC_SSR_SS_Pos                (0U)                                     
N#define RTC_SSR_SS_Msk                (0xFFFFUL << RTC_SSR_SS_Pos)              /*!< 0x0000FFFF */
N#define RTC_SSR_SS                    RTC_SSR_SS_Msk                           
N
N/********************  Bits definition for RTC_SHIFTR register  ***************/
N#define RTC_SHIFTR_SUBFS_Pos          (0U)                                     
N#define RTC_SHIFTR_SUBFS_Msk          (0x7FFFUL << RTC_SHIFTR_SUBFS_Pos)        /*!< 0x00007FFF */
N#define RTC_SHIFTR_SUBFS              RTC_SHIFTR_SUBFS_Msk                     
N#define RTC_SHIFTR_ADD1S_Pos          (31U)                                    
N#define RTC_SHIFTR_ADD1S_Msk          (0x1UL << RTC_SHIFTR_ADD1S_Pos)           /*!< 0x80000000 */
N#define RTC_SHIFTR_ADD1S              RTC_SHIFTR_ADD1S_Msk                     
N
N/********************  Bits definition for RTC_TSTR register  *****************/
N#define RTC_TSTR_PM_Pos               (22U)                                    
N#define RTC_TSTR_PM_Msk               (0x1UL << RTC_TSTR_PM_Pos)                /*!< 0x00400000 */
N#define RTC_TSTR_PM                   RTC_TSTR_PM_Msk                          
N#define RTC_TSTR_HT_Pos               (20U)                                    
N#define RTC_TSTR_HT_Msk               (0x3UL << RTC_TSTR_HT_Pos)                /*!< 0x00300000 */
N#define RTC_TSTR_HT                   RTC_TSTR_HT_Msk                          
N#define RTC_TSTR_HT_0                 (0x1UL << RTC_TSTR_HT_Pos)                /*!< 0x00100000 */
N#define RTC_TSTR_HT_1                 (0x2UL << RTC_TSTR_HT_Pos)                /*!< 0x00200000 */
N#define RTC_TSTR_HU_Pos               (16U)                                    
N#define RTC_TSTR_HU_Msk               (0xFUL << RTC_TSTR_HU_Pos)                /*!< 0x000F0000 */
N#define RTC_TSTR_HU                   RTC_TSTR_HU_Msk                          
N#define RTC_TSTR_HU_0                 (0x1UL << RTC_TSTR_HU_Pos)                /*!< 0x00010000 */
N#define RTC_TSTR_HU_1                 (0x2UL << RTC_TSTR_HU_Pos)                /*!< 0x00020000 */
N#define RTC_TSTR_HU_2                 (0x4UL << RTC_TSTR_HU_Pos)                /*!< 0x00040000 */
N#define RTC_TSTR_HU_3                 (0x8UL << RTC_TSTR_HU_Pos)                /*!< 0x00080000 */
N#define RTC_TSTR_MNT_Pos              (12U)                                    
N#define RTC_TSTR_MNT_Msk              (0x7UL << RTC_TSTR_MNT_Pos)               /*!< 0x00007000 */
N#define RTC_TSTR_MNT                  RTC_TSTR_MNT_Msk                         
N#define RTC_TSTR_MNT_0                (0x1UL << RTC_TSTR_MNT_Pos)               /*!< 0x00001000 */
N#define RTC_TSTR_MNT_1                (0x2UL << RTC_TSTR_MNT_Pos)               /*!< 0x00002000 */
N#define RTC_TSTR_MNT_2                (0x4UL << RTC_TSTR_MNT_Pos)               /*!< 0x00004000 */
N#define RTC_TSTR_MNU_Pos              (8U)                                     
N#define RTC_TSTR_MNU_Msk              (0xFUL << RTC_TSTR_MNU_Pos)               /*!< 0x00000F00 */
N#define RTC_TSTR_MNU                  RTC_TSTR_MNU_Msk                         
N#define RTC_TSTR_MNU_0                (0x1UL << RTC_TSTR_MNU_Pos)               /*!< 0x00000100 */
N#define RTC_TSTR_MNU_1                (0x2UL << RTC_TSTR_MNU_Pos)               /*!< 0x00000200 */
N#define RTC_TSTR_MNU_2                (0x4UL << RTC_TSTR_MNU_Pos)               /*!< 0x00000400 */
N#define RTC_TSTR_MNU_3                (0x8UL << RTC_TSTR_MNU_Pos)               /*!< 0x00000800 */
N#define RTC_TSTR_ST_Pos               (4U)                                     
N#define RTC_TSTR_ST_Msk               (0x7UL << RTC_TSTR_ST_Pos)                /*!< 0x00000070 */
N#define RTC_TSTR_ST                   RTC_TSTR_ST_Msk                          
N#define RTC_TSTR_ST_0                 (0x1UL << RTC_TSTR_ST_Pos)                /*!< 0x00000010 */
N#define RTC_TSTR_ST_1                 (0x2UL << RTC_TSTR_ST_Pos)                /*!< 0x00000020 */
N#define RTC_TSTR_ST_2                 (0x4UL << RTC_TSTR_ST_Pos)                /*!< 0x00000040 */
N#define RTC_TSTR_SU_Pos               (0U)                                     
N#define RTC_TSTR_SU_Msk               (0xFUL << RTC_TSTR_SU_Pos)                /*!< 0x0000000F */
N#define RTC_TSTR_SU                   RTC_TSTR_SU_Msk                          
N#define RTC_TSTR_SU_0                 (0x1UL << RTC_TSTR_SU_Pos)                /*!< 0x00000001 */
N#define RTC_TSTR_SU_1                 (0x2UL << RTC_TSTR_SU_Pos)                /*!< 0x00000002 */
N#define RTC_TSTR_SU_2                 (0x4UL << RTC_TSTR_SU_Pos)                /*!< 0x00000004 */
N#define RTC_TSTR_SU_3                 (0x8UL << RTC_TSTR_SU_Pos)                /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSDR register  *****************/
N#define RTC_TSDR_WDU_Pos              (13U)                                    
N#define RTC_TSDR_WDU_Msk              (0x7UL << RTC_TSDR_WDU_Pos)               /*!< 0x0000E000 */
N#define RTC_TSDR_WDU                  RTC_TSDR_WDU_Msk                         
N#define RTC_TSDR_WDU_0                (0x1UL << RTC_TSDR_WDU_Pos)               /*!< 0x00002000 */
N#define RTC_TSDR_WDU_1                (0x2UL << RTC_TSDR_WDU_Pos)               /*!< 0x00004000 */
N#define RTC_TSDR_WDU_2                (0x4UL << RTC_TSDR_WDU_Pos)               /*!< 0x00008000 */
N#define RTC_TSDR_MT_Pos               (12U)                                    
N#define RTC_TSDR_MT_Msk               (0x1UL << RTC_TSDR_MT_Pos)                /*!< 0x00001000 */
N#define RTC_TSDR_MT                   RTC_TSDR_MT_Msk                          
N#define RTC_TSDR_MU_Pos               (8U)                                     
N#define RTC_TSDR_MU_Msk               (0xFUL << RTC_TSDR_MU_Pos)                /*!< 0x00000F00 */
N#define RTC_TSDR_MU                   RTC_TSDR_MU_Msk                          
N#define RTC_TSDR_MU_0                 (0x1UL << RTC_TSDR_MU_Pos)                /*!< 0x00000100 */
N#define RTC_TSDR_MU_1                 (0x2UL << RTC_TSDR_MU_Pos)                /*!< 0x00000200 */
N#define RTC_TSDR_MU_2                 (0x4UL << RTC_TSDR_MU_Pos)                /*!< 0x00000400 */
N#define RTC_TSDR_MU_3                 (0x8UL << RTC_TSDR_MU_Pos)                /*!< 0x00000800 */
N#define RTC_TSDR_DT_Pos               (4U)                                     
N#define RTC_TSDR_DT_Msk               (0x3UL << RTC_TSDR_DT_Pos)                /*!< 0x00000030 */
N#define RTC_TSDR_DT                   RTC_TSDR_DT_Msk                          
N#define RTC_TSDR_DT_0                 (0x1UL << RTC_TSDR_DT_Pos)                /*!< 0x00000010 */
N#define RTC_TSDR_DT_1                 (0x2UL << RTC_TSDR_DT_Pos)                /*!< 0x00000020 */
N#define RTC_TSDR_DU_Pos               (0U)                                     
N#define RTC_TSDR_DU_Msk               (0xFUL << RTC_TSDR_DU_Pos)                /*!< 0x0000000F */
N#define RTC_TSDR_DU                   RTC_TSDR_DU_Msk                          
N#define RTC_TSDR_DU_0                 (0x1UL << RTC_TSDR_DU_Pos)                /*!< 0x00000001 */
N#define RTC_TSDR_DU_1                 (0x2UL << RTC_TSDR_DU_Pos)                /*!< 0x00000002 */
N#define RTC_TSDR_DU_2                 (0x4UL << RTC_TSDR_DU_Pos)                /*!< 0x00000004 */
N#define RTC_TSDR_DU_3                 (0x8UL << RTC_TSDR_DU_Pos)                /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSSSR register  ****************/
N#define RTC_TSSSR_SS_Pos              (0U)                                     
N#define RTC_TSSSR_SS_Msk              (0xFFFFUL << RTC_TSSSR_SS_Pos)            /*!< 0x0000FFFF */
N#define RTC_TSSSR_SS                  RTC_TSSSR_SS_Msk                         
N
N/********************  Bits definition for RTC_CAL register  *****************/
N#define RTC_CALR_CALP_Pos             (15U)                                    
N#define RTC_CALR_CALP_Msk             (0x1UL << RTC_CALR_CALP_Pos)              /*!< 0x00008000 */
N#define RTC_CALR_CALP                 RTC_CALR_CALP_Msk                        
N#define RTC_CALR_CALW8_Pos            (14U)                                    
N#define RTC_CALR_CALW8_Msk            (0x1UL << RTC_CALR_CALW8_Pos)             /*!< 0x00004000 */
N#define RTC_CALR_CALW8                RTC_CALR_CALW8_Msk                       
N#define RTC_CALR_CALW16_Pos           (13U)                                    
N#define RTC_CALR_CALW16_Msk           (0x1UL << RTC_CALR_CALW16_Pos)            /*!< 0x00002000 */
N#define RTC_CALR_CALW16               RTC_CALR_CALW16_Msk                      
N#define RTC_CALR_CALM_Pos             (0U)                                     
N#define RTC_CALR_CALM_Msk             (0x1FFUL << RTC_CALR_CALM_Pos)            /*!< 0x000001FF */
N#define RTC_CALR_CALM                 RTC_CALR_CALM_Msk                        
N#define RTC_CALR_CALM_0               (0x001UL << RTC_CALR_CALM_Pos)            /*!< 0x00000001 */
N#define RTC_CALR_CALM_1               (0x002UL << RTC_CALR_CALM_Pos)            /*!< 0x00000002 */
N#define RTC_CALR_CALM_2               (0x004UL << RTC_CALR_CALM_Pos)            /*!< 0x00000004 */
N#define RTC_CALR_CALM_3               (0x008UL << RTC_CALR_CALM_Pos)            /*!< 0x00000008 */
N#define RTC_CALR_CALM_4               (0x010UL << RTC_CALR_CALM_Pos)            /*!< 0x00000010 */
N#define RTC_CALR_CALM_5               (0x020UL << RTC_CALR_CALM_Pos)            /*!< 0x00000020 */
N#define RTC_CALR_CALM_6               (0x040UL << RTC_CALR_CALM_Pos)            /*!< 0x00000040 */
N#define RTC_CALR_CALM_7               (0x080UL << RTC_CALR_CALM_Pos)            /*!< 0x00000080 */
N#define RTC_CALR_CALM_8               (0x100UL << RTC_CALR_CALM_Pos)            /*!< 0x00000100 */
N
N/********************  Bits definition for RTC_TAFCR register  ****************/
N#define RTC_TAFCR_ALARMOUTTYPE_Pos    (18U)                                    
N#define RTC_TAFCR_ALARMOUTTYPE_Msk    (0x1UL << RTC_TAFCR_ALARMOUTTYPE_Pos)     /*!< 0x00040000 */
N#define RTC_TAFCR_ALARMOUTTYPE        RTC_TAFCR_ALARMOUTTYPE_Msk               
N#define RTC_TAFCR_TSINSEL_Pos         (17U)                                    
N#define RTC_TAFCR_TSINSEL_Msk         (0x1UL << RTC_TAFCR_TSINSEL_Pos)          /*!< 0x00020000 */
N#define RTC_TAFCR_TSINSEL             RTC_TAFCR_TSINSEL_Msk                    
N#define RTC_TAFCR_TAMP1INSEL_Pos      (16U)                                    
N#define RTC_TAFCR_TAMP1INSEL_Msk      (0x1UL << RTC_TAFCR_TAMP1INSEL_Pos)        /*!< 0x00010000 */
N#define RTC_TAFCR_TAMP1INSEL          RTC_TAFCR_TAMP1INSEL_Msk                  
N#define RTC_TAFCR_TAMPPUDIS_Pos       (15U)                                    
N#define RTC_TAFCR_TAMPPUDIS_Msk       (0x1UL << RTC_TAFCR_TAMPPUDIS_Pos)        /*!< 0x00008000 */
N#define RTC_TAFCR_TAMPPUDIS           RTC_TAFCR_TAMPPUDIS_Msk                  
N#define RTC_TAFCR_TAMPPRCH_Pos        (13U)                                    
N#define RTC_TAFCR_TAMPPRCH_Msk        (0x3UL << RTC_TAFCR_TAMPPRCH_Pos)         /*!< 0x00006000 */
N#define RTC_TAFCR_TAMPPRCH            RTC_TAFCR_TAMPPRCH_Msk                   
N#define RTC_TAFCR_TAMPPRCH_0          (0x1UL << RTC_TAFCR_TAMPPRCH_Pos)         /*!< 0x00002000 */
N#define RTC_TAFCR_TAMPPRCH_1          (0x2UL << RTC_TAFCR_TAMPPRCH_Pos)         /*!< 0x00004000 */
N#define RTC_TAFCR_TAMPFLT_Pos         (11U)                                    
N#define RTC_TAFCR_TAMPFLT_Msk         (0x3UL << RTC_TAFCR_TAMPFLT_Pos)          /*!< 0x00001800 */
N#define RTC_TAFCR_TAMPFLT             RTC_TAFCR_TAMPFLT_Msk                    
N#define RTC_TAFCR_TAMPFLT_0           (0x1UL << RTC_TAFCR_TAMPFLT_Pos)          /*!< 0x00000800 */
N#define RTC_TAFCR_TAMPFLT_1           (0x2UL << RTC_TAFCR_TAMPFLT_Pos)          /*!< 0x00001000 */
N#define RTC_TAFCR_TAMPFREQ_Pos        (8U)                                     
N#define RTC_TAFCR_TAMPFREQ_Msk        (0x7UL << RTC_TAFCR_TAMPFREQ_Pos)         /*!< 0x00000700 */
N#define RTC_TAFCR_TAMPFREQ            RTC_TAFCR_TAMPFREQ_Msk                   
N#define RTC_TAFCR_TAMPFREQ_0          (0x1UL << RTC_TAFCR_TAMPFREQ_Pos)         /*!< 0x00000100 */
N#define RTC_TAFCR_TAMPFREQ_1          (0x2UL << RTC_TAFCR_TAMPFREQ_Pos)         /*!< 0x00000200 */
N#define RTC_TAFCR_TAMPFREQ_2          (0x4UL << RTC_TAFCR_TAMPFREQ_Pos)         /*!< 0x00000400 */
N#define RTC_TAFCR_TAMPTS_Pos          (7U)                                     
N#define RTC_TAFCR_TAMPTS_Msk          (0x1UL << RTC_TAFCR_TAMPTS_Pos)           /*!< 0x00000080 */
N#define RTC_TAFCR_TAMPTS              RTC_TAFCR_TAMPTS_Msk                     
N#define RTC_TAFCR_TAMP2TRG_Pos        (4U)                                     
N#define RTC_TAFCR_TAMP2TRG_Msk        (0x1UL << RTC_TAFCR_TAMP2TRG_Pos)         /*!< 0x00000010 */
N#define RTC_TAFCR_TAMP2TRG            RTC_TAFCR_TAMP2TRG_Msk                   
N#define RTC_TAFCR_TAMP2E_Pos          (3U)                                     
N#define RTC_TAFCR_TAMP2E_Msk          (0x1UL << RTC_TAFCR_TAMP2E_Pos)           /*!< 0x00000008 */
N#define RTC_TAFCR_TAMP2E              RTC_TAFCR_TAMP2E_Msk                     
N#define RTC_TAFCR_TAMPIE_Pos          (2U)                                     
N#define RTC_TAFCR_TAMPIE_Msk          (0x1UL << RTC_TAFCR_TAMPIE_Pos)           /*!< 0x00000004 */
N#define RTC_TAFCR_TAMPIE              RTC_TAFCR_TAMPIE_Msk                     
N#define RTC_TAFCR_TAMP1TRG_Pos        (1U)                                     
N#define RTC_TAFCR_TAMP1TRG_Msk        (0x1UL << RTC_TAFCR_TAMP1TRG_Pos)         /*!< 0x00000002 */
N#define RTC_TAFCR_TAMP1TRG            RTC_TAFCR_TAMP1TRG_Msk                   
N#define RTC_TAFCR_TAMP1E_Pos          (0U)                                     
N#define RTC_TAFCR_TAMP1E_Msk          (0x1UL << RTC_TAFCR_TAMP1E_Pos)           /*!< 0x00000001 */
N#define RTC_TAFCR_TAMP1E              RTC_TAFCR_TAMP1E_Msk                     
N
N/* Legacy defines */
N#define RTC_TAFCR_TAMPINSEL           RTC_TAFCR_TAMP1INSEL
N
N/********************  Bits definition for RTC_ALRMASSR register  *************/
N#define RTC_ALRMASSR_MASKSS_Pos       (24U)                                    
N#define RTC_ALRMASSR_MASKSS_Msk       (0xFUL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x0F000000 */
N#define RTC_ALRMASSR_MASKSS           RTC_ALRMASSR_MASKSS_Msk                  
N#define RTC_ALRMASSR_MASKSS_0         (0x1UL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x01000000 */
N#define RTC_ALRMASSR_MASKSS_1         (0x2UL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x02000000 */
N#define RTC_ALRMASSR_MASKSS_2         (0x4UL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x04000000 */
N#define RTC_ALRMASSR_MASKSS_3         (0x8UL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x08000000 */
N#define RTC_ALRMASSR_SS_Pos           (0U)                                     
N#define RTC_ALRMASSR_SS_Msk           (0x7FFFUL << RTC_ALRMASSR_SS_Pos)         /*!< 0x00007FFF */
N#define RTC_ALRMASSR_SS               RTC_ALRMASSR_SS_Msk                      
N
N/********************  Bits definition for RTC_ALRMBSSR register  *************/
N#define RTC_ALRMBSSR_MASKSS_Pos       (24U)                                    
N#define RTC_ALRMBSSR_MASKSS_Msk       (0xFUL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x0F000000 */
N#define RTC_ALRMBSSR_MASKSS           RTC_ALRMBSSR_MASKSS_Msk                  
N#define RTC_ALRMBSSR_MASKSS_0         (0x1UL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x01000000 */
N#define RTC_ALRMBSSR_MASKSS_1         (0x2UL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x02000000 */
N#define RTC_ALRMBSSR_MASKSS_2         (0x4UL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x04000000 */
N#define RTC_ALRMBSSR_MASKSS_3         (0x8UL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x08000000 */
N#define RTC_ALRMBSSR_SS_Pos           (0U)                                     
N#define RTC_ALRMBSSR_SS_Msk           (0x7FFFUL << RTC_ALRMBSSR_SS_Pos)         /*!< 0x00007FFF */
N#define RTC_ALRMBSSR_SS               RTC_ALRMBSSR_SS_Msk                      
N
N/********************  Bits definition for RTC_BKP0R register  ****************/
N#define RTC_BKP0R_Pos                 (0U)                                     
N#define RTC_BKP0R_Msk                 (0xFFFFFFFFUL << RTC_BKP0R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP0R                     RTC_BKP0R_Msk                            
N
N/********************  Bits definition for RTC_BKP1R register  ****************/
N#define RTC_BKP1R_Pos                 (0U)                                     
N#define RTC_BKP1R_Msk                 (0xFFFFFFFFUL << RTC_BKP1R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP1R                     RTC_BKP1R_Msk                            
N
N/********************  Bits definition for RTC_BKP2R register  ****************/
N#define RTC_BKP2R_Pos                 (0U)                                     
N#define RTC_BKP2R_Msk                 (0xFFFFFFFFUL << RTC_BKP2R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP2R                     RTC_BKP2R_Msk                            
N
N/********************  Bits definition for RTC_BKP3R register  ****************/
N#define RTC_BKP3R_Pos                 (0U)                                     
N#define RTC_BKP3R_Msk                 (0xFFFFFFFFUL << RTC_BKP3R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP3R                     RTC_BKP3R_Msk                            
N
N/********************  Bits definition for RTC_BKP4R register  ****************/
N#define RTC_BKP4R_Pos                 (0U)                                     
N#define RTC_BKP4R_Msk                 (0xFFFFFFFFUL << RTC_BKP4R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP4R                     RTC_BKP4R_Msk                            
N
N/********************  Bits definition for RTC_BKP5R register  ****************/
N#define RTC_BKP5R_Pos                 (0U)                                     
N#define RTC_BKP5R_Msk                 (0xFFFFFFFFUL << RTC_BKP5R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP5R                     RTC_BKP5R_Msk                            
N
N/********************  Bits definition for RTC_BKP6R register  ****************/
N#define RTC_BKP6R_Pos                 (0U)                                     
N#define RTC_BKP6R_Msk                 (0xFFFFFFFFUL << RTC_BKP6R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP6R                     RTC_BKP6R_Msk                            
N
N/********************  Bits definition for RTC_BKP7R register  ****************/
N#define RTC_BKP7R_Pos                 (0U)                                     
N#define RTC_BKP7R_Msk                 (0xFFFFFFFFUL << RTC_BKP7R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP7R                     RTC_BKP7R_Msk                            
N
N/********************  Bits definition for RTC_BKP8R register  ****************/
N#define RTC_BKP8R_Pos                 (0U)                                     
N#define RTC_BKP8R_Msk                 (0xFFFFFFFFUL << RTC_BKP8R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP8R                     RTC_BKP8R_Msk                            
N
N/********************  Bits definition for RTC_BKP9R register  ****************/
N#define RTC_BKP9R_Pos                 (0U)                                     
N#define RTC_BKP9R_Msk                 (0xFFFFFFFFUL << RTC_BKP9R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP9R                     RTC_BKP9R_Msk                            
N
N/********************  Bits definition for RTC_BKP10R register  ***************/
N#define RTC_BKP10R_Pos                (0U)                                     
N#define RTC_BKP10R_Msk                (0xFFFFFFFFUL << RTC_BKP10R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP10R                    RTC_BKP10R_Msk                           
N
N/********************  Bits definition for RTC_BKP11R register  ***************/
N#define RTC_BKP11R_Pos                (0U)                                     
N#define RTC_BKP11R_Msk                (0xFFFFFFFFUL << RTC_BKP11R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP11R                    RTC_BKP11R_Msk                           
N
N/********************  Bits definition for RTC_BKP12R register  ***************/
N#define RTC_BKP12R_Pos                (0U)                                     
N#define RTC_BKP12R_Msk                (0xFFFFFFFFUL << RTC_BKP12R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP12R                    RTC_BKP12R_Msk                           
N
N/********************  Bits definition for RTC_BKP13R register  ***************/
N#define RTC_BKP13R_Pos                (0U)                                     
N#define RTC_BKP13R_Msk                (0xFFFFFFFFUL << RTC_BKP13R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP13R                    RTC_BKP13R_Msk                           
N
N/********************  Bits definition for RTC_BKP14R register  ***************/
N#define RTC_BKP14R_Pos                (0U)                                     
N#define RTC_BKP14R_Msk                (0xFFFFFFFFUL << RTC_BKP14R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP14R                    RTC_BKP14R_Msk                           
N
N/********************  Bits definition for RTC_BKP15R register  ***************/
N#define RTC_BKP15R_Pos                (0U)                                     
N#define RTC_BKP15R_Msk                (0xFFFFFFFFUL << RTC_BKP15R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP15R                    RTC_BKP15R_Msk                           
N
N/********************  Bits definition for RTC_BKP16R register  ***************/
N#define RTC_BKP16R_Pos                (0U)                                     
N#define RTC_BKP16R_Msk                (0xFFFFFFFFUL << RTC_BKP16R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP16R                    RTC_BKP16R_Msk                           
N
N/********************  Bits definition for RTC_BKP17R register  ***************/
N#define RTC_BKP17R_Pos                (0U)                                     
N#define RTC_BKP17R_Msk                (0xFFFFFFFFUL << RTC_BKP17R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP17R                    RTC_BKP17R_Msk                           
N
N/********************  Bits definition for RTC_BKP18R register  ***************/
N#define RTC_BKP18R_Pos                (0U)                                     
N#define RTC_BKP18R_Msk                (0xFFFFFFFFUL << RTC_BKP18R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP18R                    RTC_BKP18R_Msk                           
N
N/********************  Bits definition for RTC_BKP19R register  ***************/
N#define RTC_BKP19R_Pos                (0U)                                     
N#define RTC_BKP19R_Msk                (0xFFFFFFFFUL << RTC_BKP19R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP19R                    RTC_BKP19R_Msk                           
N
N/******************** Number of backup registers ******************************/
N#define RTC_BKP_NUMBER                       0x000000014U
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                          SD host Interface                                 */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SDIO_POWER register  ******************/
N#define SDIO_POWER_PWRCTRL_Pos         (0U)                                    
N#define SDIO_POWER_PWRCTRL_Msk         (0x3UL << SDIO_POWER_PWRCTRL_Pos)        /*!< 0x00000003 */
N#define SDIO_POWER_PWRCTRL             SDIO_POWER_PWRCTRL_Msk                  /*!<PWRCTRL[1:0] bits (Power supply control bits) */
N#define SDIO_POWER_PWRCTRL_0           (0x1UL << SDIO_POWER_PWRCTRL_Pos)        /*!< 0x01 */
N#define SDIO_POWER_PWRCTRL_1           (0x2UL << SDIO_POWER_PWRCTRL_Pos)        /*!< 0x02 */
N
N/******************  Bit definition for SDIO_CLKCR register  ******************/
N#define SDIO_CLKCR_CLKDIV_Pos          (0U)                                    
N#define SDIO_CLKCR_CLKDIV_Msk          (0xFFUL << SDIO_CLKCR_CLKDIV_Pos)        /*!< 0x000000FF */
N#define SDIO_CLKCR_CLKDIV              SDIO_CLKCR_CLKDIV_Msk                   /*!<Clock divide factor             */
N#define SDIO_CLKCR_CLKEN_Pos           (8U)                                    
N#define SDIO_CLKCR_CLKEN_Msk           (0x1UL << SDIO_CLKCR_CLKEN_Pos)          /*!< 0x00000100 */
N#define SDIO_CLKCR_CLKEN               SDIO_CLKCR_CLKEN_Msk                    /*!<Clock enable bit                */
N#define SDIO_CLKCR_PWRSAV_Pos          (9U)                                    
N#define SDIO_CLKCR_PWRSAV_Msk          (0x1UL << SDIO_CLKCR_PWRSAV_Pos)         /*!< 0x00000200 */
N#define SDIO_CLKCR_PWRSAV              SDIO_CLKCR_PWRSAV_Msk                   /*!<Power saving configuration bit  */
N#define SDIO_CLKCR_BYPASS_Pos          (10U)                                   
N#define SDIO_CLKCR_BYPASS_Msk          (0x1UL << SDIO_CLKCR_BYPASS_Pos)         /*!< 0x00000400 */
N#define SDIO_CLKCR_BYPASS              SDIO_CLKCR_BYPASS_Msk                   /*!<Clock divider bypass enable bit */
N
N#define SDIO_CLKCR_WIDBUS_Pos          (11U)                                   
N#define SDIO_CLKCR_WIDBUS_Msk          (0x3UL << SDIO_CLKCR_WIDBUS_Pos)         /*!< 0x00001800 */
N#define SDIO_CLKCR_WIDBUS              SDIO_CLKCR_WIDBUS_Msk                   /*!<WIDBUS[1:0] bits (Wide bus mode enable bit) */
N#define SDIO_CLKCR_WIDBUS_0            (0x1UL << SDIO_CLKCR_WIDBUS_Pos)         /*!< 0x0800 */
N#define SDIO_CLKCR_WIDBUS_1            (0x2UL << SDIO_CLKCR_WIDBUS_Pos)         /*!< 0x1000 */
N
N#define SDIO_CLKCR_NEGEDGE_Pos         (13U)                                   
N#define SDIO_CLKCR_NEGEDGE_Msk         (0x1UL << SDIO_CLKCR_NEGEDGE_Pos)        /*!< 0x00002000 */
N#define SDIO_CLKCR_NEGEDGE             SDIO_CLKCR_NEGEDGE_Msk                  /*!<SDIO_CK dephasing selection bit */
N#define SDIO_CLKCR_HWFC_EN_Pos         (14U)                                   
N#define SDIO_CLKCR_HWFC_EN_Msk         (0x1UL << SDIO_CLKCR_HWFC_EN_Pos)        /*!< 0x00004000 */
N#define SDIO_CLKCR_HWFC_EN             SDIO_CLKCR_HWFC_EN_Msk                  /*!<HW Flow Control enable          */
N
N/*******************  Bit definition for SDIO_ARG register  *******************/
N#define SDIO_ARG_CMDARG_Pos            (0U)                                    
N#define SDIO_ARG_CMDARG_Msk            (0xFFFFFFFFUL << SDIO_ARG_CMDARG_Pos)    /*!< 0xFFFFFFFF */
N#define SDIO_ARG_CMDARG                SDIO_ARG_CMDARG_Msk                     /*!<Command argument */
N
N/*******************  Bit definition for SDIO_CMD register  *******************/
N#define SDIO_CMD_CMDINDEX_Pos          (0U)                                    
N#define SDIO_CMD_CMDINDEX_Msk          (0x3FUL << SDIO_CMD_CMDINDEX_Pos)        /*!< 0x0000003F */
N#define SDIO_CMD_CMDINDEX              SDIO_CMD_CMDINDEX_Msk                   /*!<Command Index                               */
N
N#define SDIO_CMD_WAITRESP_Pos          (6U)                                    
N#define SDIO_CMD_WAITRESP_Msk          (0x3UL << SDIO_CMD_WAITRESP_Pos)         /*!< 0x000000C0 */
N#define SDIO_CMD_WAITRESP              SDIO_CMD_WAITRESP_Msk                   /*!<WAITRESP[1:0] bits (Wait for response bits) */
N#define SDIO_CMD_WAITRESP_0            (0x1UL << SDIO_CMD_WAITRESP_Pos)         /*!< 0x0040 */
N#define SDIO_CMD_WAITRESP_1            (0x2UL << SDIO_CMD_WAITRESP_Pos)         /*!< 0x0080 */
N
N#define SDIO_CMD_WAITINT_Pos           (8U)                                    
N#define SDIO_CMD_WAITINT_Msk           (0x1UL << SDIO_CMD_WAITINT_Pos)          /*!< 0x00000100 */
N#define SDIO_CMD_WAITINT               SDIO_CMD_WAITINT_Msk                    /*!<CPSM Waits for Interrupt Request                               */
N#define SDIO_CMD_WAITPEND_Pos          (9U)                                    
N#define SDIO_CMD_WAITPEND_Msk          (0x1UL << SDIO_CMD_WAITPEND_Pos)         /*!< 0x00000200 */
N#define SDIO_CMD_WAITPEND              SDIO_CMD_WAITPEND_Msk                   /*!<CPSM Waits for ends of data transfer (CmdPend internal signal) */
N#define SDIO_CMD_CPSMEN_Pos            (10U)                                   
N#define SDIO_CMD_CPSMEN_Msk            (0x1UL << SDIO_CMD_CPSMEN_Pos)           /*!< 0x00000400 */
N#define SDIO_CMD_CPSMEN                SDIO_CMD_CPSMEN_Msk                     /*!<Command path state machine (CPSM) Enable bit                   */
N#define SDIO_CMD_SDIOSUSPEND_Pos       (11U)                                   
N#define SDIO_CMD_SDIOSUSPEND_Msk       (0x1UL << SDIO_CMD_SDIOSUSPEND_Pos)      /*!< 0x00000800 */
N#define SDIO_CMD_SDIOSUSPEND           SDIO_CMD_SDIOSUSPEND_Msk                /*!<SD I/O suspend command                                         */
N#define SDIO_CMD_ENCMDCOMPL_Pos        (12U)                                   
N#define SDIO_CMD_ENCMDCOMPL_Msk        (0x1UL << SDIO_CMD_ENCMDCOMPL_Pos)       /*!< 0x00001000 */
N#define SDIO_CMD_ENCMDCOMPL            SDIO_CMD_ENCMDCOMPL_Msk                 /*!<Enable CMD completion                                          */
N#define SDIO_CMD_NIEN_Pos              (13U)                                   
N#define SDIO_CMD_NIEN_Msk              (0x1UL << SDIO_CMD_NIEN_Pos)             /*!< 0x00002000 */
N#define SDIO_CMD_NIEN                  SDIO_CMD_NIEN_Msk                       /*!<Not Interrupt Enable                                           */
N#define SDIO_CMD_CEATACMD_Pos          (14U)                                   
N#define SDIO_CMD_CEATACMD_Msk          (0x1UL << SDIO_CMD_CEATACMD_Pos)         /*!< 0x00004000 */
N#define SDIO_CMD_CEATACMD              SDIO_CMD_CEATACMD_Msk                   /*!<CE-ATA command                                                 */
N
N/*****************  Bit definition for SDIO_RESPCMD register  *****************/
N#define SDIO_RESPCMD_RESPCMD_Pos       (0U)                                    
N#define SDIO_RESPCMD_RESPCMD_Msk       (0x3FUL << SDIO_RESPCMD_RESPCMD_Pos)     /*!< 0x0000003F */
N#define SDIO_RESPCMD_RESPCMD           SDIO_RESPCMD_RESPCMD_Msk                /*!<Response command index */
N
N/******************  Bit definition for SDIO_RESP0 register  ******************/
N#define SDIO_RESP0_CARDSTATUS0_Pos     (0U)                                    
N#define SDIO_RESP0_CARDSTATUS0_Msk     (0xFFFFFFFFUL << SDIO_RESP0_CARDSTATUS0_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP0_CARDSTATUS0         SDIO_RESP0_CARDSTATUS0_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP1 register  ******************/
N#define SDIO_RESP1_CARDSTATUS1_Pos     (0U)                                    
N#define SDIO_RESP1_CARDSTATUS1_Msk     (0xFFFFFFFFUL << SDIO_RESP1_CARDSTATUS1_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP1_CARDSTATUS1         SDIO_RESP1_CARDSTATUS1_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP2 register  ******************/
N#define SDIO_RESP2_CARDSTATUS2_Pos     (0U)                                    
N#define SDIO_RESP2_CARDSTATUS2_Msk     (0xFFFFFFFFUL << SDIO_RESP2_CARDSTATUS2_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP2_CARDSTATUS2         SDIO_RESP2_CARDSTATUS2_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP3 register  ******************/
N#define SDIO_RESP3_CARDSTATUS3_Pos     (0U)                                    
N#define SDIO_RESP3_CARDSTATUS3_Msk     (0xFFFFFFFFUL << SDIO_RESP3_CARDSTATUS3_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP3_CARDSTATUS3         SDIO_RESP3_CARDSTATUS3_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP4 register  ******************/
N#define SDIO_RESP4_CARDSTATUS4_Pos     (0U)                                    
N#define SDIO_RESP4_CARDSTATUS4_Msk     (0xFFFFFFFFUL << SDIO_RESP4_CARDSTATUS4_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP4_CARDSTATUS4         SDIO_RESP4_CARDSTATUS4_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_DTIMER register  *****************/
N#define SDIO_DTIMER_DATATIME_Pos       (0U)                                    
N#define SDIO_DTIMER_DATATIME_Msk       (0xFFFFFFFFUL << SDIO_DTIMER_DATATIME_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_DTIMER_DATATIME           SDIO_DTIMER_DATATIME_Msk                /*!<Data timeout period. */
N
N/******************  Bit definition for SDIO_DLEN register  *******************/
N#define SDIO_DLEN_DATALENGTH_Pos       (0U)                                    
N#define SDIO_DLEN_DATALENGTH_Msk       (0x1FFFFFFUL << SDIO_DLEN_DATALENGTH_Pos) /*!< 0x01FFFFFF */
N#define SDIO_DLEN_DATALENGTH           SDIO_DLEN_DATALENGTH_Msk                /*!<Data length value    */
N
N/******************  Bit definition for SDIO_DCTRL register  ******************/
N#define SDIO_DCTRL_DTEN_Pos            (0U)                                    
N#define SDIO_DCTRL_DTEN_Msk            (0x1UL << SDIO_DCTRL_DTEN_Pos)           /*!< 0x00000001 */
N#define SDIO_DCTRL_DTEN                SDIO_DCTRL_DTEN_Msk                     /*!<Data transfer enabled bit         */
N#define SDIO_DCTRL_DTDIR_Pos           (1U)                                    
N#define SDIO_DCTRL_DTDIR_Msk           (0x1UL << SDIO_DCTRL_DTDIR_Pos)          /*!< 0x00000002 */
N#define SDIO_DCTRL_DTDIR               SDIO_DCTRL_DTDIR_Msk                    /*!<Data transfer direction selection */
N#define SDIO_DCTRL_DTMODE_Pos          (2U)                                    
N#define SDIO_DCTRL_DTMODE_Msk          (0x1UL << SDIO_DCTRL_DTMODE_Pos)         /*!< 0x00000004 */
N#define SDIO_DCTRL_DTMODE              SDIO_DCTRL_DTMODE_Msk                   /*!<Data transfer mode selection      */
N#define SDIO_DCTRL_DMAEN_Pos           (3U)                                    
N#define SDIO_DCTRL_DMAEN_Msk           (0x1UL << SDIO_DCTRL_DMAEN_Pos)          /*!< 0x00000008 */
N#define SDIO_DCTRL_DMAEN               SDIO_DCTRL_DMAEN_Msk                    /*!<DMA enabled bit                   */
N
N#define SDIO_DCTRL_DBLOCKSIZE_Pos      (4U)                                    
N#define SDIO_DCTRL_DBLOCKSIZE_Msk      (0xFUL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x000000F0 */
N#define SDIO_DCTRL_DBLOCKSIZE          SDIO_DCTRL_DBLOCKSIZE_Msk               /*!<DBLOCKSIZE[3:0] bits (Data block size) */
N#define SDIO_DCTRL_DBLOCKSIZE_0        (0x1UL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x0010 */
N#define SDIO_DCTRL_DBLOCKSIZE_1        (0x2UL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x0020 */
N#define SDIO_DCTRL_DBLOCKSIZE_2        (0x4UL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x0040 */
N#define SDIO_DCTRL_DBLOCKSIZE_3        (0x8UL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x0080 */
N
N#define SDIO_DCTRL_RWSTART_Pos         (8U)                                    
N#define SDIO_DCTRL_RWSTART_Msk         (0x1UL << SDIO_DCTRL_RWSTART_Pos)        /*!< 0x00000100 */
N#define SDIO_DCTRL_RWSTART             SDIO_DCTRL_RWSTART_Msk                  /*!<Read wait start         */
N#define SDIO_DCTRL_RWSTOP_Pos          (9U)                                    
N#define SDIO_DCTRL_RWSTOP_Msk          (0x1UL << SDIO_DCTRL_RWSTOP_Pos)         /*!< 0x00000200 */
N#define SDIO_DCTRL_RWSTOP              SDIO_DCTRL_RWSTOP_Msk                   /*!<Read wait stop          */
N#define SDIO_DCTRL_RWMOD_Pos           (10U)                                   
N#define SDIO_DCTRL_RWMOD_Msk           (0x1UL << SDIO_DCTRL_RWMOD_Pos)          /*!< 0x00000400 */
N#define SDIO_DCTRL_RWMOD               SDIO_DCTRL_RWMOD_Msk                    /*!<Read wait mode          */
N#define SDIO_DCTRL_SDIOEN_Pos          (11U)                                   
N#define SDIO_DCTRL_SDIOEN_Msk          (0x1UL << SDIO_DCTRL_SDIOEN_Pos)         /*!< 0x00000800 */
N#define SDIO_DCTRL_SDIOEN              SDIO_DCTRL_SDIOEN_Msk                   /*!<SD I/O enable functions */
N
N/******************  Bit definition for SDIO_DCOUNT register  *****************/
N#define SDIO_DCOUNT_DATACOUNT_Pos      (0U)                                    
N#define SDIO_DCOUNT_DATACOUNT_Msk      (0x1FFFFFFUL << SDIO_DCOUNT_DATACOUNT_Pos) /*!< 0x01FFFFFF */
N#define SDIO_DCOUNT_DATACOUNT          SDIO_DCOUNT_DATACOUNT_Msk               /*!<Data count value */
N
N/******************  Bit definition for SDIO_STA register  ********************/
N#define SDIO_STA_CCRCFAIL_Pos          (0U)                                    
N#define SDIO_STA_CCRCFAIL_Msk          (0x1UL << SDIO_STA_CCRCFAIL_Pos)         /*!< 0x00000001 */
N#define SDIO_STA_CCRCFAIL              SDIO_STA_CCRCFAIL_Msk                   /*!<Command response received (CRC check failed)  */
N#define SDIO_STA_DCRCFAIL_Pos          (1U)                                    
N#define SDIO_STA_DCRCFAIL_Msk          (0x1UL << SDIO_STA_DCRCFAIL_Pos)         /*!< 0x00000002 */
N#define SDIO_STA_DCRCFAIL              SDIO_STA_DCRCFAIL_Msk                   /*!<Data block sent/received (CRC check failed)   */
N#define SDIO_STA_CTIMEOUT_Pos          (2U)                                    
N#define SDIO_STA_CTIMEOUT_Msk          (0x1UL << SDIO_STA_CTIMEOUT_Pos)         /*!< 0x00000004 */
N#define SDIO_STA_CTIMEOUT              SDIO_STA_CTIMEOUT_Msk                   /*!<Command response timeout                      */
N#define SDIO_STA_DTIMEOUT_Pos          (3U)                                    
N#define SDIO_STA_DTIMEOUT_Msk          (0x1UL << SDIO_STA_DTIMEOUT_Pos)         /*!< 0x00000008 */
N#define SDIO_STA_DTIMEOUT              SDIO_STA_DTIMEOUT_Msk                   /*!<Data timeout                                  */
N#define SDIO_STA_TXUNDERR_Pos          (4U)                                    
N#define SDIO_STA_TXUNDERR_Msk          (0x1UL << SDIO_STA_TXUNDERR_Pos)         /*!< 0x00000010 */
N#define SDIO_STA_TXUNDERR              SDIO_STA_TXUNDERR_Msk                   /*!<Transmit FIFO underrun error                  */
N#define SDIO_STA_RXOVERR_Pos           (5U)                                    
N#define SDIO_STA_RXOVERR_Msk           (0x1UL << SDIO_STA_RXOVERR_Pos)          /*!< 0x00000020 */
N#define SDIO_STA_RXOVERR               SDIO_STA_RXOVERR_Msk                    /*!<Received FIFO overrun error                   */
N#define SDIO_STA_CMDREND_Pos           (6U)                                    
N#define SDIO_STA_CMDREND_Msk           (0x1UL << SDIO_STA_CMDREND_Pos)          /*!< 0x00000040 */
N#define SDIO_STA_CMDREND               SDIO_STA_CMDREND_Msk                    /*!<Command response received (CRC check passed)  */
N#define SDIO_STA_CMDSENT_Pos           (7U)                                    
N#define SDIO_STA_CMDSENT_Msk           (0x1UL << SDIO_STA_CMDSENT_Pos)          /*!< 0x00000080 */
N#define SDIO_STA_CMDSENT               SDIO_STA_CMDSENT_Msk                    /*!<Command sent (no response required)           */
N#define SDIO_STA_DATAEND_Pos           (8U)                                    
N#define SDIO_STA_DATAEND_Msk           (0x1UL << SDIO_STA_DATAEND_Pos)          /*!< 0x00000100 */
N#define SDIO_STA_DATAEND               SDIO_STA_DATAEND_Msk                    /*!<Data end (data counter, SDIDCOUNT, is zero)   */
N#define SDIO_STA_STBITERR_Pos          (9U)                                    
N#define SDIO_STA_STBITERR_Msk          (0x1UL << SDIO_STA_STBITERR_Pos)         /*!< 0x00000200 */
N#define SDIO_STA_STBITERR              SDIO_STA_STBITERR_Msk                   /*!<Start bit not detected on all data signals in wide bus mode */
N#define SDIO_STA_DBCKEND_Pos           (10U)                                   
N#define SDIO_STA_DBCKEND_Msk           (0x1UL << SDIO_STA_DBCKEND_Pos)          /*!< 0x00000400 */
N#define SDIO_STA_DBCKEND               SDIO_STA_DBCKEND_Msk                    /*!<Data block sent/received (CRC check passed)   */
N#define SDIO_STA_CMDACT_Pos            (11U)                                   
N#define SDIO_STA_CMDACT_Msk            (0x1UL << SDIO_STA_CMDACT_Pos)           /*!< 0x00000800 */
N#define SDIO_STA_CMDACT                SDIO_STA_CMDACT_Msk                     /*!<Command transfer in progress                  */
N#define SDIO_STA_TXACT_Pos             (12U)                                   
N#define SDIO_STA_TXACT_Msk             (0x1UL << SDIO_STA_TXACT_Pos)            /*!< 0x00001000 */
N#define SDIO_STA_TXACT                 SDIO_STA_TXACT_Msk                      /*!<Data transmit in progress                     */
N#define SDIO_STA_RXACT_Pos             (13U)                                   
N#define SDIO_STA_RXACT_Msk             (0x1UL << SDIO_STA_RXACT_Pos)            /*!< 0x00002000 */
N#define SDIO_STA_RXACT                 SDIO_STA_RXACT_Msk                      /*!<Data receive in progress                      */
N#define SDIO_STA_TXFIFOHE_Pos          (14U)                                   
N#define SDIO_STA_TXFIFOHE_Msk          (0x1UL << SDIO_STA_TXFIFOHE_Pos)         /*!< 0x00004000 */
N#define SDIO_STA_TXFIFOHE              SDIO_STA_TXFIFOHE_Msk                   /*!<Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
N#define SDIO_STA_RXFIFOHF_Pos          (15U)                                   
N#define SDIO_STA_RXFIFOHF_Msk          (0x1UL << SDIO_STA_RXFIFOHF_Pos)         /*!< 0x00008000 */
N#define SDIO_STA_RXFIFOHF              SDIO_STA_RXFIFOHF_Msk                   /*!<Receive FIFO Half Full: there are at least 8 words in the FIFO */
N#define SDIO_STA_TXFIFOF_Pos           (16U)                                   
N#define SDIO_STA_TXFIFOF_Msk           (0x1UL << SDIO_STA_TXFIFOF_Pos)          /*!< 0x00010000 */
N#define SDIO_STA_TXFIFOF               SDIO_STA_TXFIFOF_Msk                    /*!<Transmit FIFO full                            */
N#define SDIO_STA_RXFIFOF_Pos           (17U)                                   
N#define SDIO_STA_RXFIFOF_Msk           (0x1UL << SDIO_STA_RXFIFOF_Pos)          /*!< 0x00020000 */
N#define SDIO_STA_RXFIFOF               SDIO_STA_RXFIFOF_Msk                    /*!<Receive FIFO full                             */
N#define SDIO_STA_TXFIFOE_Pos           (18U)                                   
N#define SDIO_STA_TXFIFOE_Msk           (0x1UL << SDIO_STA_TXFIFOE_Pos)          /*!< 0x00040000 */
N#define SDIO_STA_TXFIFOE               SDIO_STA_TXFIFOE_Msk                    /*!<Transmit FIFO empty                           */
N#define SDIO_STA_RXFIFOE_Pos           (19U)                                   
N#define SDIO_STA_RXFIFOE_Msk           (0x1UL << SDIO_STA_RXFIFOE_Pos)          /*!< 0x00080000 */
N#define SDIO_STA_RXFIFOE               SDIO_STA_RXFIFOE_Msk                    /*!<Receive FIFO empty                            */
N#define SDIO_STA_TXDAVL_Pos            (20U)                                   
N#define SDIO_STA_TXDAVL_Msk            (0x1UL << SDIO_STA_TXDAVL_Pos)           /*!< 0x00100000 */
N#define SDIO_STA_TXDAVL                SDIO_STA_TXDAVL_Msk                     /*!<Data available in transmit FIFO               */
N#define SDIO_STA_RXDAVL_Pos            (21U)                                   
N#define SDIO_STA_RXDAVL_Msk            (0x1UL << SDIO_STA_RXDAVL_Pos)           /*!< 0x00200000 */
N#define SDIO_STA_RXDAVL                SDIO_STA_RXDAVL_Msk                     /*!<Data available in receive FIFO                */
N#define SDIO_STA_SDIOIT_Pos            (22U)                                   
N#define SDIO_STA_SDIOIT_Msk            (0x1UL << SDIO_STA_SDIOIT_Pos)           /*!< 0x00400000 */
N#define SDIO_STA_SDIOIT                SDIO_STA_SDIOIT_Msk                     /*!<SDIO interrupt received                       */
N#define SDIO_STA_CEATAEND_Pos          (23U)                                   
N#define SDIO_STA_CEATAEND_Msk          (0x1UL << SDIO_STA_CEATAEND_Pos)         /*!< 0x00800000 */
N#define SDIO_STA_CEATAEND              SDIO_STA_CEATAEND_Msk                   /*!<CE-ATA command completion signal received for CMD61 */
N
N/*******************  Bit definition for SDIO_ICR register  *******************/
N#define SDIO_ICR_CCRCFAILC_Pos         (0U)                                    
N#define SDIO_ICR_CCRCFAILC_Msk         (0x1UL << SDIO_ICR_CCRCFAILC_Pos)        /*!< 0x00000001 */
N#define SDIO_ICR_CCRCFAILC             SDIO_ICR_CCRCFAILC_Msk                  /*!<CCRCFAIL flag clear bit */
N#define SDIO_ICR_DCRCFAILC_Pos         (1U)                                    
N#define SDIO_ICR_DCRCFAILC_Msk         (0x1UL << SDIO_ICR_DCRCFAILC_Pos)        /*!< 0x00000002 */
N#define SDIO_ICR_DCRCFAILC             SDIO_ICR_DCRCFAILC_Msk                  /*!<DCRCFAIL flag clear bit */
N#define SDIO_ICR_CTIMEOUTC_Pos         (2U)                                    
N#define SDIO_ICR_CTIMEOUTC_Msk         (0x1UL << SDIO_ICR_CTIMEOUTC_Pos)        /*!< 0x00000004 */
N#define SDIO_ICR_CTIMEOUTC             SDIO_ICR_CTIMEOUTC_Msk                  /*!<CTIMEOUT flag clear bit */
N#define SDIO_ICR_DTIMEOUTC_Pos         (3U)                                    
N#define SDIO_ICR_DTIMEOUTC_Msk         (0x1UL << SDIO_ICR_DTIMEOUTC_Pos)        /*!< 0x00000008 */
N#define SDIO_ICR_DTIMEOUTC             SDIO_ICR_DTIMEOUTC_Msk                  /*!<DTIMEOUT flag clear bit */
N#define SDIO_ICR_TXUNDERRC_Pos         (4U)                                    
N#define SDIO_ICR_TXUNDERRC_Msk         (0x1UL << SDIO_ICR_TXUNDERRC_Pos)        /*!< 0x00000010 */
N#define SDIO_ICR_TXUNDERRC             SDIO_ICR_TXUNDERRC_Msk                  /*!<TXUNDERR flag clear bit */
N#define SDIO_ICR_RXOVERRC_Pos          (5U)                                    
N#define SDIO_ICR_RXOVERRC_Msk          (0x1UL << SDIO_ICR_RXOVERRC_Pos)         /*!< 0x00000020 */
N#define SDIO_ICR_RXOVERRC              SDIO_ICR_RXOVERRC_Msk                   /*!<RXOVERR flag clear bit  */
N#define SDIO_ICR_CMDRENDC_Pos          (6U)                                    
N#define SDIO_ICR_CMDRENDC_Msk          (0x1UL << SDIO_ICR_CMDRENDC_Pos)         /*!< 0x00000040 */
N#define SDIO_ICR_CMDRENDC              SDIO_ICR_CMDRENDC_Msk                   /*!<CMDREND flag clear bit  */
N#define SDIO_ICR_CMDSENTC_Pos          (7U)                                    
N#define SDIO_ICR_CMDSENTC_Msk          (0x1UL << SDIO_ICR_CMDSENTC_Pos)         /*!< 0x00000080 */
N#define SDIO_ICR_CMDSENTC              SDIO_ICR_CMDSENTC_Msk                   /*!<CMDSENT flag clear bit  */
N#define SDIO_ICR_DATAENDC_Pos          (8U)                                    
N#define SDIO_ICR_DATAENDC_Msk          (0x1UL << SDIO_ICR_DATAENDC_Pos)         /*!< 0x00000100 */
N#define SDIO_ICR_DATAENDC              SDIO_ICR_DATAENDC_Msk                   /*!<DATAEND flag clear bit  */
N#define SDIO_ICR_STBITERRC_Pos         (9U)                                    
N#define SDIO_ICR_STBITERRC_Msk         (0x1UL << SDIO_ICR_STBITERRC_Pos)        /*!< 0x00000200 */
N#define SDIO_ICR_STBITERRC             SDIO_ICR_STBITERRC_Msk                  /*!<STBITERR flag clear bit */
N#define SDIO_ICR_DBCKENDC_Pos          (10U)                                   
N#define SDIO_ICR_DBCKENDC_Msk          (0x1UL << SDIO_ICR_DBCKENDC_Pos)         /*!< 0x00000400 */
N#define SDIO_ICR_DBCKENDC              SDIO_ICR_DBCKENDC_Msk                   /*!<DBCKEND flag clear bit  */
N#define SDIO_ICR_SDIOITC_Pos           (22U)                                   
N#define SDIO_ICR_SDIOITC_Msk           (0x1UL << SDIO_ICR_SDIOITC_Pos)          /*!< 0x00400000 */
N#define SDIO_ICR_SDIOITC               SDIO_ICR_SDIOITC_Msk                    /*!<SDIOIT flag clear bit   */
N#define SDIO_ICR_CEATAENDC_Pos         (23U)                                   
N#define SDIO_ICR_CEATAENDC_Msk         (0x1UL << SDIO_ICR_CEATAENDC_Pos)        /*!< 0x00800000 */
N#define SDIO_ICR_CEATAENDC             SDIO_ICR_CEATAENDC_Msk                  /*!<CEATAEND flag clear bit */
N
N/******************  Bit definition for SDIO_MASK register  *******************/
N#define SDIO_MASK_CCRCFAILIE_Pos       (0U)                                    
N#define SDIO_MASK_CCRCFAILIE_Msk       (0x1UL << SDIO_MASK_CCRCFAILIE_Pos)      /*!< 0x00000001 */
N#define SDIO_MASK_CCRCFAILIE           SDIO_MASK_CCRCFAILIE_Msk                /*!<Command CRC Fail Interrupt Enable          */
N#define SDIO_MASK_DCRCFAILIE_Pos       (1U)                                    
N#define SDIO_MASK_DCRCFAILIE_Msk       (0x1UL << SDIO_MASK_DCRCFAILIE_Pos)      /*!< 0x00000002 */
N#define SDIO_MASK_DCRCFAILIE           SDIO_MASK_DCRCFAILIE_Msk                /*!<Data CRC Fail Interrupt Enable             */
N#define SDIO_MASK_CTIMEOUTIE_Pos       (2U)                                    
N#define SDIO_MASK_CTIMEOUTIE_Msk       (0x1UL << SDIO_MASK_CTIMEOUTIE_Pos)      /*!< 0x00000004 */
N#define SDIO_MASK_CTIMEOUTIE           SDIO_MASK_CTIMEOUTIE_Msk                /*!<Command TimeOut Interrupt Enable           */
N#define SDIO_MASK_DTIMEOUTIE_Pos       (3U)                                    
N#define SDIO_MASK_DTIMEOUTIE_Msk       (0x1UL << SDIO_MASK_DTIMEOUTIE_Pos)      /*!< 0x00000008 */
N#define SDIO_MASK_DTIMEOUTIE           SDIO_MASK_DTIMEOUTIE_Msk                /*!<Data TimeOut Interrupt Enable              */
N#define SDIO_MASK_TXUNDERRIE_Pos       (4U)                                    
N#define SDIO_MASK_TXUNDERRIE_Msk       (0x1UL << SDIO_MASK_TXUNDERRIE_Pos)      /*!< 0x00000010 */
N#define SDIO_MASK_TXUNDERRIE           SDIO_MASK_TXUNDERRIE_Msk                /*!<Tx FIFO UnderRun Error Interrupt Enable    */
N#define SDIO_MASK_RXOVERRIE_Pos        (5U)                                    
N#define SDIO_MASK_RXOVERRIE_Msk        (0x1UL << SDIO_MASK_RXOVERRIE_Pos)       /*!< 0x00000020 */
N#define SDIO_MASK_RXOVERRIE            SDIO_MASK_RXOVERRIE_Msk                 /*!<Rx FIFO OverRun Error Interrupt Enable     */
N#define SDIO_MASK_CMDRENDIE_Pos        (6U)                                    
N#define SDIO_MASK_CMDRENDIE_Msk        (0x1UL << SDIO_MASK_CMDRENDIE_Pos)       /*!< 0x00000040 */
N#define SDIO_MASK_CMDRENDIE            SDIO_MASK_CMDRENDIE_Msk                 /*!<Command Response Received Interrupt Enable */
N#define SDIO_MASK_CMDSENTIE_Pos        (7U)                                    
N#define SDIO_MASK_CMDSENTIE_Msk        (0x1UL << SDIO_MASK_CMDSENTIE_Pos)       /*!< 0x00000080 */
N#define SDIO_MASK_CMDSENTIE            SDIO_MASK_CMDSENTIE_Msk                 /*!<Command Sent Interrupt Enable              */
N#define SDIO_MASK_DATAENDIE_Pos        (8U)                                    
N#define SDIO_MASK_DATAENDIE_Msk        (0x1UL << SDIO_MASK_DATAENDIE_Pos)       /*!< 0x00000100 */
N#define SDIO_MASK_DATAENDIE            SDIO_MASK_DATAENDIE_Msk                 /*!<Data End Interrupt Enable                  */
N#define SDIO_MASK_STBITERRIE_Pos       (9U)                                    
N#define SDIO_MASK_STBITERRIE_Msk       (0x1UL << SDIO_MASK_STBITERRIE_Pos)      /*!< 0x00000200 */
N#define SDIO_MASK_STBITERRIE           SDIO_MASK_STBITERRIE_Msk                /*!<Start Bit Error Interrupt Enable           */
N#define SDIO_MASK_DBCKENDIE_Pos        (10U)                                   
N#define SDIO_MASK_DBCKENDIE_Msk        (0x1UL << SDIO_MASK_DBCKENDIE_Pos)       /*!< 0x00000400 */
N#define SDIO_MASK_DBCKENDIE            SDIO_MASK_DBCKENDIE_Msk                 /*!<Data Block End Interrupt Enable            */
N#define SDIO_MASK_CMDACTIE_Pos         (11U)                                   
N#define SDIO_MASK_CMDACTIE_Msk         (0x1UL << SDIO_MASK_CMDACTIE_Pos)        /*!< 0x00000800 */
N#define SDIO_MASK_CMDACTIE             SDIO_MASK_CMDACTIE_Msk                  /*!<CCommand Acting Interrupt Enable           */
N#define SDIO_MASK_TXACTIE_Pos          (12U)                                   
N#define SDIO_MASK_TXACTIE_Msk          (0x1UL << SDIO_MASK_TXACTIE_Pos)         /*!< 0x00001000 */
N#define SDIO_MASK_TXACTIE              SDIO_MASK_TXACTIE_Msk                   /*!<Data Transmit Acting Interrupt Enable      */
N#define SDIO_MASK_RXACTIE_Pos          (13U)                                   
N#define SDIO_MASK_RXACTIE_Msk          (0x1UL << SDIO_MASK_RXACTIE_Pos)         /*!< 0x00002000 */
N#define SDIO_MASK_RXACTIE              SDIO_MASK_RXACTIE_Msk                   /*!<Data receive acting interrupt enabled      */
N#define SDIO_MASK_TXFIFOHEIE_Pos       (14U)                                   
N#define SDIO_MASK_TXFIFOHEIE_Msk       (0x1UL << SDIO_MASK_TXFIFOHEIE_Pos)      /*!< 0x00004000 */
N#define SDIO_MASK_TXFIFOHEIE           SDIO_MASK_TXFIFOHEIE_Msk                /*!<Tx FIFO Half Empty interrupt Enable        */
N#define SDIO_MASK_RXFIFOHFIE_Pos       (15U)                                   
N#define SDIO_MASK_RXFIFOHFIE_Msk       (0x1UL << SDIO_MASK_RXFIFOHFIE_Pos)      /*!< 0x00008000 */
N#define SDIO_MASK_RXFIFOHFIE           SDIO_MASK_RXFIFOHFIE_Msk                /*!<Rx FIFO Half Full interrupt Enable         */
N#define SDIO_MASK_TXFIFOFIE_Pos        (16U)                                   
N#define SDIO_MASK_TXFIFOFIE_Msk        (0x1UL << SDIO_MASK_TXFIFOFIE_Pos)       /*!< 0x00010000 */
N#define SDIO_MASK_TXFIFOFIE            SDIO_MASK_TXFIFOFIE_Msk                 /*!<Tx FIFO Full interrupt Enable              */
N#define SDIO_MASK_RXFIFOFIE_Pos        (17U)                                   
N#define SDIO_MASK_RXFIFOFIE_Msk        (0x1UL << SDIO_MASK_RXFIFOFIE_Pos)       /*!< 0x00020000 */
N#define SDIO_MASK_RXFIFOFIE            SDIO_MASK_RXFIFOFIE_Msk                 /*!<Rx FIFO Full interrupt Enable              */
N#define SDIO_MASK_TXFIFOEIE_Pos        (18U)                                   
N#define SDIO_MASK_TXFIFOEIE_Msk        (0x1UL << SDIO_MASK_TXFIFOEIE_Pos)       /*!< 0x00040000 */
N#define SDIO_MASK_TXFIFOEIE            SDIO_MASK_TXFIFOEIE_Msk                 /*!<Tx FIFO Empty interrupt Enable             */
N#define SDIO_MASK_RXFIFOEIE_Pos        (19U)                                   
N#define SDIO_MASK_RXFIFOEIE_Msk        (0x1UL << SDIO_MASK_RXFIFOEIE_Pos)       /*!< 0x00080000 */
N#define SDIO_MASK_RXFIFOEIE            SDIO_MASK_RXFIFOEIE_Msk                 /*!<Rx FIFO Empty interrupt Enable             */
N#define SDIO_MASK_TXDAVLIE_Pos         (20U)                                   
N#define SDIO_MASK_TXDAVLIE_Msk         (0x1UL << SDIO_MASK_TXDAVLIE_Pos)        /*!< 0x00100000 */
N#define SDIO_MASK_TXDAVLIE             SDIO_MASK_TXDAVLIE_Msk                  /*!<Data available in Tx FIFO interrupt Enable */
N#define SDIO_MASK_RXDAVLIE_Pos         (21U)                                   
N#define SDIO_MASK_RXDAVLIE_Msk         (0x1UL << SDIO_MASK_RXDAVLIE_Pos)        /*!< 0x00200000 */
N#define SDIO_MASK_RXDAVLIE             SDIO_MASK_RXDAVLIE_Msk                  /*!<Data available in Rx FIFO interrupt Enable */
N#define SDIO_MASK_SDIOITIE_Pos         (22U)                                   
N#define SDIO_MASK_SDIOITIE_Msk         (0x1UL << SDIO_MASK_SDIOITIE_Pos)        /*!< 0x00400000 */
N#define SDIO_MASK_SDIOITIE             SDIO_MASK_SDIOITIE_Msk                  /*!<SDIO Mode Interrupt Received interrupt Enable */
N#define SDIO_MASK_CEATAENDIE_Pos       (23U)                                   
N#define SDIO_MASK_CEATAENDIE_Msk       (0x1UL << SDIO_MASK_CEATAENDIE_Pos)      /*!< 0x00800000 */
N#define SDIO_MASK_CEATAENDIE           SDIO_MASK_CEATAENDIE_Msk                /*!<CE-ATA command completion signal received Interrupt Enable */
N
N/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
N#define SDIO_FIFOCNT_FIFOCOUNT_Pos     (0U)                                    
N#define SDIO_FIFOCNT_FIFOCOUNT_Msk     (0xFFFFFFUL << SDIO_FIFOCNT_FIFOCOUNT_Pos) /*!< 0x00FFFFFF */
N#define SDIO_FIFOCNT_FIFOCOUNT         SDIO_FIFOCNT_FIFOCOUNT_Msk              /*!<Remaining number of words to be written to or read from the FIFO */
N
N/******************  Bit definition for SDIO_FIFO register  *******************/
N#define SDIO_FIFO_FIFODATA_Pos         (0U)                                    
N#define SDIO_FIFO_FIFODATA_Msk         (0xFFFFFFFFUL << SDIO_FIFO_FIFODATA_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_FIFO_FIFODATA             SDIO_FIFO_FIFODATA_Msk                  /*!<Receive and transmit FIFO data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Serial Peripheral Interface                         */
N/*                                                                            */
N/******************************************************************************/
N#define SPI_I2S_FULLDUPLEX_SUPPORT                                             /*!< I2S Full-Duplex support */
N
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define SPI_CR1_CPHA_Pos            (0U)                                       
N#define SPI_CR1_CPHA_Msk            (0x1UL << SPI_CR1_CPHA_Pos)                 /*!< 0x00000001 */
N#define SPI_CR1_CPHA                SPI_CR1_CPHA_Msk                           /*!<Clock Phase      */
N#define SPI_CR1_CPOL_Pos            (1U)                                       
N#define SPI_CR1_CPOL_Msk            (0x1UL << SPI_CR1_CPOL_Pos)                 /*!< 0x00000002 */
N#define SPI_CR1_CPOL                SPI_CR1_CPOL_Msk                           /*!<Clock Polarity   */
N#define SPI_CR1_MSTR_Pos            (2U)                                       
N#define SPI_CR1_MSTR_Msk            (0x1UL << SPI_CR1_MSTR_Pos)                 /*!< 0x00000004 */
N#define SPI_CR1_MSTR                SPI_CR1_MSTR_Msk                           /*!<Master Selection */
N
N#define SPI_CR1_BR_Pos              (3U)                                       
N#define SPI_CR1_BR_Msk              (0x7UL << SPI_CR1_BR_Pos)                   /*!< 0x00000038 */
N#define SPI_CR1_BR                  SPI_CR1_BR_Msk                             /*!<BR[2:0] bits (Baud Rate Control) */
N#define SPI_CR1_BR_0                (0x1UL << SPI_CR1_BR_Pos)                   /*!< 0x00000008 */
N#define SPI_CR1_BR_1                (0x2UL << SPI_CR1_BR_Pos)                   /*!< 0x00000010 */
N#define SPI_CR1_BR_2                (0x4UL << SPI_CR1_BR_Pos)                   /*!< 0x00000020 */
N
N#define SPI_CR1_SPE_Pos             (6U)                                       
N#define SPI_CR1_SPE_Msk             (0x1UL << SPI_CR1_SPE_Pos)                  /*!< 0x00000040 */
N#define SPI_CR1_SPE                 SPI_CR1_SPE_Msk                            /*!<SPI Enable                          */
N#define SPI_CR1_LSBFIRST_Pos        (7U)                                       
N#define SPI_CR1_LSBFIRST_Msk        (0x1UL << SPI_CR1_LSBFIRST_Pos)             /*!< 0x00000080 */
N#define SPI_CR1_LSBFIRST            SPI_CR1_LSBFIRST_Msk                       /*!<Frame Format                        */
N#define SPI_CR1_SSI_Pos             (8U)                                       
N#define SPI_CR1_SSI_Msk             (0x1UL << SPI_CR1_SSI_Pos)                  /*!< 0x00000100 */
N#define SPI_CR1_SSI                 SPI_CR1_SSI_Msk                            /*!<Internal slave select               */
N#define SPI_CR1_SSM_Pos             (9U)                                       
N#define SPI_CR1_SSM_Msk             (0x1UL << SPI_CR1_SSM_Pos)                  /*!< 0x00000200 */
N#define SPI_CR1_SSM                 SPI_CR1_SSM_Msk                            /*!<Software slave management           */
N#define SPI_CR1_RXONLY_Pos          (10U)                                      
N#define SPI_CR1_RXONLY_Msk          (0x1UL << SPI_CR1_RXONLY_Pos)               /*!< 0x00000400 */
N#define SPI_CR1_RXONLY              SPI_CR1_RXONLY_Msk                         /*!<Receive only                        */
N#define SPI_CR1_DFF_Pos             (11U)                                      
N#define SPI_CR1_DFF_Msk             (0x1UL << SPI_CR1_DFF_Pos)                  /*!< 0x00000800 */
N#define SPI_CR1_DFF                 SPI_CR1_DFF_Msk                            /*!<Data Frame Format                   */
N#define SPI_CR1_CRCNEXT_Pos         (12U)                                      
N#define SPI_CR1_CRCNEXT_Msk         (0x1UL << SPI_CR1_CRCNEXT_Pos)              /*!< 0x00001000 */
N#define SPI_CR1_CRCNEXT             SPI_CR1_CRCNEXT_Msk                        /*!<Transmit CRC next                   */
N#define SPI_CR1_CRCEN_Pos           (13U)                                      
N#define SPI_CR1_CRCEN_Msk           (0x1UL << SPI_CR1_CRCEN_Pos)                /*!< 0x00002000 */
N#define SPI_CR1_CRCEN               SPI_CR1_CRCEN_Msk                          /*!<Hardware CRC calculation enable     */
N#define SPI_CR1_BIDIOE_Pos          (14U)                                      
N#define SPI_CR1_BIDIOE_Msk          (0x1UL << SPI_CR1_BIDIOE_Pos)               /*!< 0x00004000 */
N#define SPI_CR1_BIDIOE              SPI_CR1_BIDIOE_Msk                         /*!<Output enable in bidirectional mode */
N#define SPI_CR1_BIDIMODE_Pos        (15U)                                      
N#define SPI_CR1_BIDIMODE_Msk        (0x1UL << SPI_CR1_BIDIMODE_Pos)             /*!< 0x00008000 */
N#define SPI_CR1_BIDIMODE            SPI_CR1_BIDIMODE_Msk                       /*!<Bidirectional data mode enable      */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define SPI_CR2_RXDMAEN_Pos         (0U)                                       
N#define SPI_CR2_RXDMAEN_Msk         (0x1UL << SPI_CR2_RXDMAEN_Pos)              /*!< 0x00000001 */
N#define SPI_CR2_RXDMAEN             SPI_CR2_RXDMAEN_Msk                        /*!<Rx Buffer DMA Enable                 */
N#define SPI_CR2_TXDMAEN_Pos         (1U)                                       
N#define SPI_CR2_TXDMAEN_Msk         (0x1UL << SPI_CR2_TXDMAEN_Pos)              /*!< 0x00000002 */
N#define SPI_CR2_TXDMAEN             SPI_CR2_TXDMAEN_Msk                        /*!<Tx Buffer DMA Enable                 */
N#define SPI_CR2_SSOE_Pos            (2U)                                       
N#define SPI_CR2_SSOE_Msk            (0x1UL << SPI_CR2_SSOE_Pos)                 /*!< 0x00000004 */
N#define SPI_CR2_SSOE                SPI_CR2_SSOE_Msk                           /*!<SS Output Enable                     */
N#define SPI_CR2_FRF_Pos             (4U)                                       
N#define SPI_CR2_FRF_Msk             (0x1UL << SPI_CR2_FRF_Pos)                  /*!< 0x00000010 */
N#define SPI_CR2_FRF                 SPI_CR2_FRF_Msk                            /*!<Frame Format                         */
N#define SPI_CR2_ERRIE_Pos           (5U)                                       
N#define SPI_CR2_ERRIE_Msk           (0x1UL << SPI_CR2_ERRIE_Pos)                /*!< 0x00000020 */
N#define SPI_CR2_ERRIE               SPI_CR2_ERRIE_Msk                          /*!<Error Interrupt Enable               */
N#define SPI_CR2_RXNEIE_Pos          (6U)                                       
N#define SPI_CR2_RXNEIE_Msk          (0x1UL << SPI_CR2_RXNEIE_Pos)               /*!< 0x00000040 */
N#define SPI_CR2_RXNEIE              SPI_CR2_RXNEIE_Msk                         /*!<RX buffer Not Empty Interrupt Enable */
N#define SPI_CR2_TXEIE_Pos           (7U)                                       
N#define SPI_CR2_TXEIE_Msk           (0x1UL << SPI_CR2_TXEIE_Pos)                /*!< 0x00000080 */
N#define SPI_CR2_TXEIE               SPI_CR2_TXEIE_Msk                          /*!<Tx buffer Empty Interrupt Enable     */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define SPI_SR_RXNE_Pos             (0U)                                       
N#define SPI_SR_RXNE_Msk             (0x1UL << SPI_SR_RXNE_Pos)                  /*!< 0x00000001 */
N#define SPI_SR_RXNE                 SPI_SR_RXNE_Msk                            /*!<Receive buffer Not Empty */
N#define SPI_SR_TXE_Pos              (1U)                                       
N#define SPI_SR_TXE_Msk              (0x1UL << SPI_SR_TXE_Pos)                   /*!< 0x00000002 */
N#define SPI_SR_TXE                  SPI_SR_TXE_Msk                             /*!<Transmit buffer Empty    */
N#define SPI_SR_CHSIDE_Pos           (2U)                                       
N#define SPI_SR_CHSIDE_Msk           (0x1UL << SPI_SR_CHSIDE_Pos)                /*!< 0x00000004 */
N#define SPI_SR_CHSIDE               SPI_SR_CHSIDE_Msk                          /*!<Channel side             */
N#define SPI_SR_UDR_Pos              (3U)                                       
N#define SPI_SR_UDR_Msk              (0x1UL << SPI_SR_UDR_Pos)                   /*!< 0x00000008 */
N#define SPI_SR_UDR                  SPI_SR_UDR_Msk                             /*!<Underrun flag            */
N#define SPI_SR_CRCERR_Pos           (4U)                                       
N#define SPI_SR_CRCERR_Msk           (0x1UL << SPI_SR_CRCERR_Pos)                /*!< 0x00000010 */
N#define SPI_SR_CRCERR               SPI_SR_CRCERR_Msk                          /*!<CRC Error flag           */
N#define SPI_SR_MODF_Pos             (5U)                                       
N#define SPI_SR_MODF_Msk             (0x1UL << SPI_SR_MODF_Pos)                  /*!< 0x00000020 */
N#define SPI_SR_MODF                 SPI_SR_MODF_Msk                            /*!<Mode fault               */
N#define SPI_SR_OVR_Pos              (6U)                                       
N#define SPI_SR_OVR_Msk              (0x1UL << SPI_SR_OVR_Pos)                   /*!< 0x00000040 */
N#define SPI_SR_OVR                  SPI_SR_OVR_Msk                             /*!<Overrun flag             */
N#define SPI_SR_BSY_Pos              (7U)                                       
N#define SPI_SR_BSY_Msk              (0x1UL << SPI_SR_BSY_Pos)                   /*!< 0x00000080 */
N#define SPI_SR_BSY                  SPI_SR_BSY_Msk                             /*!<Busy flag                */
N#define SPI_SR_FRE_Pos              (8U)                                       
N#define SPI_SR_FRE_Msk              (0x1UL << SPI_SR_FRE_Pos)                   /*!< 0x00000100 */
N#define SPI_SR_FRE                  SPI_SR_FRE_Msk                             /*!<Frame format error flag  */
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define SPI_DR_DR_Pos               (0U)                                       
N#define SPI_DR_DR_Msk               (0xFFFFUL << SPI_DR_DR_Pos)                 /*!< 0x0000FFFF */
N#define SPI_DR_DR                   SPI_DR_DR_Msk                              /*!<Data Register           */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define SPI_CRCPR_CRCPOLY_Pos       (0U)                                       
N#define SPI_CRCPR_CRCPOLY_Msk       (0xFFFFUL << SPI_CRCPR_CRCPOLY_Pos)         /*!< 0x0000FFFF */
N#define SPI_CRCPR_CRCPOLY           SPI_CRCPR_CRCPOLY_Msk                      /*!<CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define SPI_RXCRCR_RXCRC_Pos        (0U)                                       
N#define SPI_RXCRCR_RXCRC_Msk        (0xFFFFUL << SPI_RXCRCR_RXCRC_Pos)          /*!< 0x0000FFFF */
N#define SPI_RXCRCR_RXCRC            SPI_RXCRCR_RXCRC_Msk                       /*!<Rx CRC Register         */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define SPI_TXCRCR_TXCRC_Pos        (0U)                                       
N#define SPI_TXCRCR_TXCRC_Msk        (0xFFFFUL << SPI_TXCRCR_TXCRC_Pos)          /*!< 0x0000FFFF */
N#define SPI_TXCRCR_TXCRC            SPI_TXCRCR_TXCRC_Msk                       /*!<Tx CRC Register         */
N
N/******************  Bit definition for SPI_I2SCFGR register  *****************/
N#define SPI_I2SCFGR_CHLEN_Pos       (0U)                                       
N#define SPI_I2SCFGR_CHLEN_Msk       (0x1UL << SPI_I2SCFGR_CHLEN_Pos)            /*!< 0x00000001 */
N#define SPI_I2SCFGR_CHLEN           SPI_I2SCFGR_CHLEN_Msk                      /*!<Channel length (number of bits per audio channel) */
N
N#define SPI_I2SCFGR_DATLEN_Pos      (1U)                                       
N#define SPI_I2SCFGR_DATLEN_Msk      (0x3UL << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000006 */
N#define SPI_I2SCFGR_DATLEN          SPI_I2SCFGR_DATLEN_Msk                     /*!<DATLEN[1:0] bits (Data length to be transferred)  */
N#define SPI_I2SCFGR_DATLEN_0        (0x1UL << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000002 */
N#define SPI_I2SCFGR_DATLEN_1        (0x2UL << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000004 */
N
N#define SPI_I2SCFGR_CKPOL_Pos       (3U)                                       
N#define SPI_I2SCFGR_CKPOL_Msk       (0x1UL << SPI_I2SCFGR_CKPOL_Pos)            /*!< 0x00000008 */
N#define SPI_I2SCFGR_CKPOL           SPI_I2SCFGR_CKPOL_Msk                      /*!<steady state clock polarity               */
N
N#define SPI_I2SCFGR_I2SSTD_Pos      (4U)                                       
N#define SPI_I2SCFGR_I2SSTD_Msk      (0x3UL << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000030 */
N#define SPI_I2SCFGR_I2SSTD          SPI_I2SCFGR_I2SSTD_Msk                     /*!<I2SSTD[1:0] bits (I2S standard selection) */
N#define SPI_I2SCFGR_I2SSTD_0        (0x1UL << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000010 */
N#define SPI_I2SCFGR_I2SSTD_1        (0x2UL << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000020 */
N
N#define SPI_I2SCFGR_PCMSYNC_Pos     (7U)                                       
N#define SPI_I2SCFGR_PCMSYNC_Msk     (0x1UL << SPI_I2SCFGR_PCMSYNC_Pos)          /*!< 0x00000080 */
N#define SPI_I2SCFGR_PCMSYNC         SPI_I2SCFGR_PCMSYNC_Msk                    /*!<PCM frame synchronization                 */
N
N#define SPI_I2SCFGR_I2SCFG_Pos      (8U)                                       
N#define SPI_I2SCFGR_I2SCFG_Msk      (0x3UL << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000300 */
N#define SPI_I2SCFGR_I2SCFG          SPI_I2SCFGR_I2SCFG_Msk                     /*!<I2SCFG[1:0] bits (I2S configuration mode) */
N#define SPI_I2SCFGR_I2SCFG_0        (0x1UL << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000100 */
N#define SPI_I2SCFGR_I2SCFG_1        (0x2UL << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000200 */
N
N#define SPI_I2SCFGR_I2SE_Pos        (10U)                                      
N#define SPI_I2SCFGR_I2SE_Msk        (0x1UL << SPI_I2SCFGR_I2SE_Pos)             /*!< 0x00000400 */
N#define SPI_I2SCFGR_I2SE            SPI_I2SCFGR_I2SE_Msk                       /*!<I2S Enable         */
N#define SPI_I2SCFGR_I2SMOD_Pos      (11U)                                      
N#define SPI_I2SCFGR_I2SMOD_Msk      (0x1UL << SPI_I2SCFGR_I2SMOD_Pos)           /*!< 0x00000800 */
N#define SPI_I2SCFGR_I2SMOD          SPI_I2SCFGR_I2SMOD_Msk                     /*!<I2S mode selection */
N
N/******************  Bit definition for SPI_I2SPR register  *******************/
N#define SPI_I2SPR_I2SDIV_Pos        (0U)                                       
N#define SPI_I2SPR_I2SDIV_Msk        (0xFFUL << SPI_I2SPR_I2SDIV_Pos)            /*!< 0x000000FF */
N#define SPI_I2SPR_I2SDIV            SPI_I2SPR_I2SDIV_Msk                       /*!<I2S Linear prescaler         */
N#define SPI_I2SPR_ODD_Pos           (8U)                                       
N#define SPI_I2SPR_ODD_Msk           (0x1UL << SPI_I2SPR_ODD_Pos)                /*!< 0x00000100 */
N#define SPI_I2SPR_ODD               SPI_I2SPR_ODD_Msk                          /*!<Odd factor for the prescaler */
N#define SPI_I2SPR_MCKOE_Pos         (9U)                                       
N#define SPI_I2SPR_MCKOE_Msk         (0x1UL << SPI_I2SPR_MCKOE_Pos)              /*!< 0x00000200 */
N#define SPI_I2SPR_MCKOE             SPI_I2SPR_MCKOE_Msk                        /*!<Master Clock Output Enable   */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 SYSCFG                                     */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SYSCFG_MEMRMP register  ***************/
N#define SYSCFG_MEMRMP_MEM_MODE_Pos           (0U)                              
N#define SYSCFG_MEMRMP_MEM_MODE_Msk           (0x3UL << SYSCFG_MEMRMP_MEM_MODE_Pos) /*!< 0x00000003 */
N#define SYSCFG_MEMRMP_MEM_MODE               SYSCFG_MEMRMP_MEM_MODE_Msk        /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_MEMRMP_MEM_MODE_0             (0x1UL << SYSCFG_MEMRMP_MEM_MODE_Pos) /*!< 0x00000001 */
N#define SYSCFG_MEMRMP_MEM_MODE_1             (0x2UL << SYSCFG_MEMRMP_MEM_MODE_Pos) /*!< 0x00000002 */
N/******************  Bit definition for SYSCFG_PMC register  ******************/
N#define SYSCFG_PMC_MII_RMII_SEL_Pos          (23U)                             
N#define SYSCFG_PMC_MII_RMII_SEL_Msk          (0x1UL << SYSCFG_PMC_MII_RMII_SEL_Pos) /*!< 0x00800000 */
N#define SYSCFG_PMC_MII_RMII_SEL              SYSCFG_PMC_MII_RMII_SEL_Msk       /*!<Ethernet PHY interface selection */
N/* Old MII_RMII_SEL bit definition, maintained for legacy purpose */
N#define SYSCFG_PMC_MII_RMII             SYSCFG_PMC_MII_RMII_SEL    
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
N#define SYSCFG_EXTICR1_EXTI0_Pos             (0U)                              
N#define SYSCFG_EXTICR1_EXTI0_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI0_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR1_EXTI0                 SYSCFG_EXTICR1_EXTI0_Msk          /*!<EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1_Pos             (4U)                              
N#define SYSCFG_EXTICR1_EXTI1_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI1_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR1_EXTI1                 SYSCFG_EXTICR1_EXTI1_Msk          /*!<EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2_Pos             (8U)                              
N#define SYSCFG_EXTICR1_EXTI2_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI2_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR1_EXTI2                 SYSCFG_EXTICR1_EXTI2_Msk          /*!<EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3_Pos             (12U)                             
N#define SYSCFG_EXTICR1_EXTI3_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI3_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR1_EXTI3                 SYSCFG_EXTICR1_EXTI3_Msk          /*!<EXTI 3 configuration */
N/**
N  * @brief   EXTI0 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI0_PA              0x0000U                           /*!<PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB              0x0001U                           /*!<PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC              0x0002U                           /*!<PC[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PD              0x0003U                           /*!<PD[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PE              0x0004U                           /*!<PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PF              0x0005U                           /*!<PF[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PG              0x0006U                           /*!<PG[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PH              0x0007U                           /*!<PH[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PI              0x0008U                           /*!<PI[0] pin */
N
N/**
N  * @brief   EXTI1 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI1_PA              0x0000U                           /*!<PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB              0x0010U                           /*!<PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC              0x0020U                           /*!<PC[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PD              0x0030U                           /*!<PD[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PE              0x0040U                           /*!<PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PF              0x0050U                           /*!<PF[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PG              0x0060U                           /*!<PG[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PH              0x0070U                           /*!<PH[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PI              0x0080U                           /*!<PI[1] pin */
N
N/**
N  * @brief   EXTI2 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI2_PA              0x0000U                           /*!<PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB              0x0100U                           /*!<PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC              0x0200U                           /*!<PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD              0x0300U                           /*!<PD[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PE              0x0400U                           /*!<PE[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PF              0x0500U                           /*!<PF[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PG              0x0600U                           /*!<PG[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PH              0x0700U                           /*!<PH[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PI              0x0800U                           /*!<PI[2] pin */
N
N/**
N  * @brief   EXTI3 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI3_PA              0x0000U                           /*!<PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB              0x1000U                           /*!<PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC              0x2000U                           /*!<PC[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PD              0x3000U                           /*!<PD[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PE              0x4000U                           /*!<PE[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PF              0x5000U                           /*!<PF[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PG              0x6000U                           /*!<PG[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PH              0x7000U                           /*!<PH[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PI              0x8000U                           /*!<PI[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  ***************/
N#define SYSCFG_EXTICR2_EXTI4_Pos             (0U)                              
N#define SYSCFG_EXTICR2_EXTI4_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI4_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR2_EXTI4                 SYSCFG_EXTICR2_EXTI4_Msk          /*!<EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5_Pos             (4U)                              
N#define SYSCFG_EXTICR2_EXTI5_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI5_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR2_EXTI5                 SYSCFG_EXTICR2_EXTI5_Msk          /*!<EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6_Pos             (8U)                              
N#define SYSCFG_EXTICR2_EXTI6_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI6_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR2_EXTI6                 SYSCFG_EXTICR2_EXTI6_Msk          /*!<EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7_Pos             (12U)                             
N#define SYSCFG_EXTICR2_EXTI7_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI7_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR2_EXTI7                 SYSCFG_EXTICR2_EXTI7_Msk          /*!<EXTI 7 configuration */
N
N/**
N  * @brief   EXTI4 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI4_PA              0x0000U                           /*!<PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB              0x0001U                           /*!<PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC              0x0002U                           /*!<PC[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PD              0x0003U                           /*!<PD[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PE              0x0004U                           /*!<PE[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PF              0x0005U                           /*!<PF[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PG              0x0006U                           /*!<PG[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PH              0x0007U                           /*!<PH[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PI              0x0008U                           /*!<PI[4] pin */
N
N/**
N  * @brief   EXTI5 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI5_PA              0x0000U                           /*!<PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB              0x0010U                           /*!<PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC              0x0020U                           /*!<PC[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PD              0x0030U                           /*!<PD[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PE              0x0040U                           /*!<PE[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PF              0x0050U                           /*!<PF[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PG              0x0060U                           /*!<PG[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PH              0x0070U                           /*!<PH[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PI              0x0080U                           /*!<PI[5] pin */
N
N/**
N  * @brief   EXTI6 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI6_PA              0x0000U                           /*!<PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB              0x0100U                           /*!<PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC              0x0200U                           /*!<PC[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PD              0x0300U                           /*!<PD[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PE              0x0400U                           /*!<PE[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PF              0x0500U                           /*!<PF[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PG              0x0600U                           /*!<PG[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PH              0x0700U                           /*!<PH[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PI              0x0800U                           /*!<PI[6] pin */
N
N/**
N  * @brief   EXTI7 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI7_PA              0x0000U                           /*!<PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB              0x1000U                           /*!<PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC              0x2000U                           /*!<PC[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PD              0x3000U                           /*!<PD[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PE              0x4000U                           /*!<PE[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PF              0x5000U                           /*!<PF[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PG              0x6000U                           /*!<PG[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PH              0x7000U                           /*!<PH[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PI              0x8000U                           /*!<PI[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  ***************/
N#define SYSCFG_EXTICR3_EXTI8_Pos             (0U)                              
N#define SYSCFG_EXTICR3_EXTI8_Msk             (0xFUL << SYSCFG_EXTICR3_EXTI8_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR3_EXTI8                 SYSCFG_EXTICR3_EXTI8_Msk          /*!<EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9_Pos             (4U)                              
N#define SYSCFG_EXTICR3_EXTI9_Msk             (0xFUL << SYSCFG_EXTICR3_EXTI9_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR3_EXTI9                 SYSCFG_EXTICR3_EXTI9_Msk          /*!<EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10_Pos            (8U)                              
N#define SYSCFG_EXTICR3_EXTI10_Msk            (0xFUL << SYSCFG_EXTICR3_EXTI10_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR3_EXTI10                SYSCFG_EXTICR3_EXTI10_Msk         /*!<EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11_Pos            (12U)                             
N#define SYSCFG_EXTICR3_EXTI11_Msk            (0xFUL << SYSCFG_EXTICR3_EXTI11_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR3_EXTI11                SYSCFG_EXTICR3_EXTI11_Msk         /*!<EXTI 11 configuration */
N
N/**
N  * @brief   EXTI8 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI8_PA              0x0000U                           /*!<PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB              0x0001U                           /*!<PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC              0x0002U                           /*!<PC[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PD              0x0003U                           /*!<PD[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PE              0x0004U                           /*!<PE[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PF              0x0005U                           /*!<PF[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PG              0x0006U                           /*!<PG[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PH              0x0007U                           /*!<PH[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PI              0x0008U                           /*!<PI[8] pin */
N
N/**
N  * @brief   EXTI9 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI9_PA              0x0000U                           /*!<PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB              0x0010U                           /*!<PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC              0x0020U                           /*!<PC[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PD              0x0030U                           /*!<PD[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PE              0x0040U                           /*!<PE[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PF              0x0050U                           /*!<PF[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PG              0x0060U                           /*!<PG[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PH              0x0070U                           /*!<PH[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PI              0x0080U                           /*!<PI[9] pin */
N
N/**
N  * @brief   EXTI10 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI10_PA             0x0000U                           /*!<PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB             0x0100U                           /*!<PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC             0x0200U                           /*!<PC[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PD             0x0300U                           /*!<PD[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PE             0x0400U                           /*!<PE[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PF             0x0500U                           /*!<PF[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PG             0x0600U                           /*!<PG[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PH             0x0700U                           /*!<PH[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PI             0x0800U                           /*!<PI[10] pin */
N
N/**
N  * @brief   EXTI11 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI11_PA             0x0000U                           /*!<PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB             0x1000U                           /*!<PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC             0x2000U                           /*!<PC[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PD             0x3000U                           /*!<PD[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PE             0x4000U                           /*!<PE[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PF             0x5000U                           /*!<PF[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PG             0x6000U                           /*!<PG[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PH             0x7000U                           /*!<PH[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PI             0x8000U                           /*!<PI[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  ***************/
N#define SYSCFG_EXTICR4_EXTI12_Pos            (0U)                              
N#define SYSCFG_EXTICR4_EXTI12_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI12_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR4_EXTI12                SYSCFG_EXTICR4_EXTI12_Msk         /*!<EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13_Pos            (4U)                              
N#define SYSCFG_EXTICR4_EXTI13_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI13_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR4_EXTI13                SYSCFG_EXTICR4_EXTI13_Msk         /*!<EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14_Pos            (8U)                              
N#define SYSCFG_EXTICR4_EXTI14_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI14_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR4_EXTI14                SYSCFG_EXTICR4_EXTI14_Msk         /*!<EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15_Pos            (12U)                             
N#define SYSCFG_EXTICR4_EXTI15_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI15_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR4_EXTI15                SYSCFG_EXTICR4_EXTI15_Msk         /*!<EXTI 15 configuration */
N
N/**
N  * @brief   EXTI12 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI12_PA             0x0000U                           /*!<PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB             0x0001U                           /*!<PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC             0x0002U                           /*!<PC[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PD             0x0003U                           /*!<PD[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PE             0x0004U                           /*!<PE[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PF             0x0005U                           /*!<PF[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PG             0x0006U                           /*!<PG[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PH             0x0007U                           /*!<PH[12] pin */
N
N/**
N  * @brief   EXTI13 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI13_PA             0x0000U                           /*!<PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB             0x0010U                           /*!<PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC             0x0020U                           /*!<PC[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PD             0x0030U                           /*!<PD[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PE             0x0040U                           /*!<PE[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PF             0x0050U                           /*!<PF[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PG             0x0060U                           /*!<PG[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PH             0x0070U                           /*!<PH[13] pin */
N
N/**
N  * @brief   EXTI14 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI14_PA             0x0000U                           /*!<PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB             0x0100U                           /*!<PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC             0x0200U                           /*!<PC[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PD             0x0300U                           /*!<PD[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PE             0x0400U                           /*!<PE[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PF             0x0500U                           /*!<PF[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PG             0x0600U                           /*!<PG[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PH             0x0700U                           /*!<PH[14] pin */
N
N/**
N  * @brief   EXTI15 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI15_PA             0x0000U                           /*!<PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB             0x1000U                           /*!<PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC             0x2000U                           /*!<PC[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PD             0x3000U                           /*!<PD[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PE             0x4000U                           /*!<PE[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PF             0x5000U                           /*!<PF[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PG             0x6000U                           /*!<PG[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PH             0x7000U                           /*!<PH[15] pin */
N
N/******************  Bit definition for SYSCFG_CMPCR register  ****************/
N#define SYSCFG_CMPCR_CMP_PD_Pos              (0U)                              
N#define SYSCFG_CMPCR_CMP_PD_Msk              (0x1UL << SYSCFG_CMPCR_CMP_PD_Pos) /*!< 0x00000001 */
N#define SYSCFG_CMPCR_CMP_PD                  SYSCFG_CMPCR_CMP_PD_Msk           /*!<Compensation cell ready flag */
N#define SYSCFG_CMPCR_READY_Pos               (8U)                              
N#define SYSCFG_CMPCR_READY_Msk               (0x1UL << SYSCFG_CMPCR_READY_Pos)  /*!< 0x00000100 */
N#define SYSCFG_CMPCR_READY                   SYSCFG_CMPCR_READY_Msk            /*!<Compensation cell power-down */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    TIM                                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define TIM_CR1_CEN_Pos           (0U)                                         
N#define TIM_CR1_CEN_Msk           (0x1UL << TIM_CR1_CEN_Pos)                    /*!< 0x00000001 */
N#define TIM_CR1_CEN               TIM_CR1_CEN_Msk                              /*!<Counter enable        */
N#define TIM_CR1_UDIS_Pos          (1U)                                         
N#define TIM_CR1_UDIS_Msk          (0x1UL << TIM_CR1_UDIS_Pos)                   /*!< 0x00000002 */
N#define TIM_CR1_UDIS              TIM_CR1_UDIS_Msk                             /*!<Update disable        */
N#define TIM_CR1_URS_Pos           (2U)                                         
N#define TIM_CR1_URS_Msk           (0x1UL << TIM_CR1_URS_Pos)                    /*!< 0x00000004 */
N#define TIM_CR1_URS               TIM_CR1_URS_Msk                              /*!<Update request source */
N#define TIM_CR1_OPM_Pos           (3U)                                         
N#define TIM_CR1_OPM_Msk           (0x1UL << TIM_CR1_OPM_Pos)                    /*!< 0x00000008 */
N#define TIM_CR1_OPM               TIM_CR1_OPM_Msk                              /*!<One pulse mode        */
N#define TIM_CR1_DIR_Pos           (4U)                                         
N#define TIM_CR1_DIR_Msk           (0x1UL << TIM_CR1_DIR_Pos)                    /*!< 0x00000010 */
N#define TIM_CR1_DIR               TIM_CR1_DIR_Msk                              /*!<Direction             */
N
N#define TIM_CR1_CMS_Pos           (5U)                                         
N#define TIM_CR1_CMS_Msk           (0x3UL << TIM_CR1_CMS_Pos)                    /*!< 0x00000060 */
N#define TIM_CR1_CMS               TIM_CR1_CMS_Msk                              /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define TIM_CR1_CMS_0             (0x1UL << TIM_CR1_CMS_Pos)                    /*!< 0x0020 */
N#define TIM_CR1_CMS_1             (0x2UL << TIM_CR1_CMS_Pos)                    /*!< 0x0040 */
N
N#define TIM_CR1_ARPE_Pos          (7U)                                         
N#define TIM_CR1_ARPE_Msk          (0x1UL << TIM_CR1_ARPE_Pos)                   /*!< 0x00000080 */
N#define TIM_CR1_ARPE              TIM_CR1_ARPE_Msk                             /*!<Auto-reload preload enable     */
N
N#define TIM_CR1_CKD_Pos           (8U)                                         
N#define TIM_CR1_CKD_Msk           (0x3UL << TIM_CR1_CKD_Pos)                    /*!< 0x00000300 */
N#define TIM_CR1_CKD               TIM_CR1_CKD_Msk                              /*!<CKD[1:0] bits (clock division) */
N#define TIM_CR1_CKD_0             (0x1UL << TIM_CR1_CKD_Pos)                    /*!< 0x0100 */
N#define TIM_CR1_CKD_1             (0x2UL << TIM_CR1_CKD_Pos)                    /*!< 0x0200 */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define TIM_CR2_CCPC_Pos          (0U)                                         
N#define TIM_CR2_CCPC_Msk          (0x1UL << TIM_CR2_CCPC_Pos)                   /*!< 0x00000001 */
N#define TIM_CR2_CCPC              TIM_CR2_CCPC_Msk                             /*!<Capture/Compare Preloaded Control        */
N#define TIM_CR2_CCUS_Pos          (2U)                                         
N#define TIM_CR2_CCUS_Msk          (0x1UL << TIM_CR2_CCUS_Pos)                   /*!< 0x00000004 */
N#define TIM_CR2_CCUS              TIM_CR2_CCUS_Msk                             /*!<Capture/Compare Control Update Selection */
N#define TIM_CR2_CCDS_Pos          (3U)                                         
N#define TIM_CR2_CCDS_Msk          (0x1UL << TIM_CR2_CCDS_Pos)                   /*!< 0x00000008 */
N#define TIM_CR2_CCDS              TIM_CR2_CCDS_Msk                             /*!<Capture/Compare DMA Selection            */
N
N#define TIM_CR2_MMS_Pos           (4U)                                         
N#define TIM_CR2_MMS_Msk           (0x7UL << TIM_CR2_MMS_Pos)                    /*!< 0x00000070 */
N#define TIM_CR2_MMS               TIM_CR2_MMS_Msk                              /*!<MMS[2:0] bits (Master Mode Selection) */
N#define TIM_CR2_MMS_0             (0x1UL << TIM_CR2_MMS_Pos)                    /*!< 0x0010 */
N#define TIM_CR2_MMS_1             (0x2UL << TIM_CR2_MMS_Pos)                    /*!< 0x0020 */
N#define TIM_CR2_MMS_2             (0x4UL << TIM_CR2_MMS_Pos)                    /*!< 0x0040 */
N
N#define TIM_CR2_TI1S_Pos          (7U)                                         
N#define TIM_CR2_TI1S_Msk          (0x1UL << TIM_CR2_TI1S_Pos)                   /*!< 0x00000080 */
N#define TIM_CR2_TI1S              TIM_CR2_TI1S_Msk                             /*!<TI1 Selection */
N#define TIM_CR2_OIS1_Pos          (8U)                                         
N#define TIM_CR2_OIS1_Msk          (0x1UL << TIM_CR2_OIS1_Pos)                   /*!< 0x00000100 */
N#define TIM_CR2_OIS1              TIM_CR2_OIS1_Msk                             /*!<Output Idle state 1 (OC1 output)  */
N#define TIM_CR2_OIS1N_Pos         (9U)                                         
N#define TIM_CR2_OIS1N_Msk         (0x1UL << TIM_CR2_OIS1N_Pos)                  /*!< 0x00000200 */
N#define TIM_CR2_OIS1N             TIM_CR2_OIS1N_Msk                            /*!<Output Idle state 1 (OC1N output) */
N#define TIM_CR2_OIS2_Pos          (10U)                                        
N#define TIM_CR2_OIS2_Msk          (0x1UL << TIM_CR2_OIS2_Pos)                   /*!< 0x00000400 */
N#define TIM_CR2_OIS2              TIM_CR2_OIS2_Msk                             /*!<Output Idle state 2 (OC2 output)  */
N#define TIM_CR2_OIS2N_Pos         (11U)                                        
N#define TIM_CR2_OIS2N_Msk         (0x1UL << TIM_CR2_OIS2N_Pos)                  /*!< 0x00000800 */
N#define TIM_CR2_OIS2N             TIM_CR2_OIS2N_Msk                            /*!<Output Idle state 2 (OC2N output) */
N#define TIM_CR2_OIS3_Pos          (12U)                                        
N#define TIM_CR2_OIS3_Msk          (0x1UL << TIM_CR2_OIS3_Pos)                   /*!< 0x00001000 */
N#define TIM_CR2_OIS3              TIM_CR2_OIS3_Msk                             /*!<Output Idle state 3 (OC3 output)  */
N#define TIM_CR2_OIS3N_Pos         (13U)                                        
N#define TIM_CR2_OIS3N_Msk         (0x1UL << TIM_CR2_OIS3N_Pos)                  /*!< 0x00002000 */
N#define TIM_CR2_OIS3N             TIM_CR2_OIS3N_Msk                            /*!<Output Idle state 3 (OC3N output) */
N#define TIM_CR2_OIS4_Pos          (14U)                                        
N#define TIM_CR2_OIS4_Msk          (0x1UL << TIM_CR2_OIS4_Pos)                   /*!< 0x00004000 */
N#define TIM_CR2_OIS4              TIM_CR2_OIS4_Msk                             /*!<Output Idle state 4 (OC4 output)  */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define TIM_SMCR_SMS_Pos          (0U)                                         
N#define TIM_SMCR_SMS_Msk          (0x7UL << TIM_SMCR_SMS_Pos)                   /*!< 0x00000007 */
N#define TIM_SMCR_SMS              TIM_SMCR_SMS_Msk                             /*!<SMS[2:0] bits (Slave mode selection)    */
N#define TIM_SMCR_SMS_0            (0x1UL << TIM_SMCR_SMS_Pos)                   /*!< 0x0001 */
N#define TIM_SMCR_SMS_1            (0x2UL << TIM_SMCR_SMS_Pos)                   /*!< 0x0002 */
N#define TIM_SMCR_SMS_2            (0x4UL << TIM_SMCR_SMS_Pos)                   /*!< 0x0004 */
N
N#define TIM_SMCR_TS_Pos           (4U)                                         
N#define TIM_SMCR_TS_Msk           (0x7UL << TIM_SMCR_TS_Pos)                    /*!< 0x00000070 */
N#define TIM_SMCR_TS               TIM_SMCR_TS_Msk                              /*!<TS[2:0] bits (Trigger selection)        */
N#define TIM_SMCR_TS_0             (0x1UL << TIM_SMCR_TS_Pos)                    /*!< 0x0010 */
N#define TIM_SMCR_TS_1             (0x2UL << TIM_SMCR_TS_Pos)                    /*!< 0x0020 */
N#define TIM_SMCR_TS_2             (0x4UL << TIM_SMCR_TS_Pos)                    /*!< 0x0040 */
N
N#define TIM_SMCR_MSM_Pos          (7U)                                         
N#define TIM_SMCR_MSM_Msk          (0x1UL << TIM_SMCR_MSM_Pos)                   /*!< 0x00000080 */
N#define TIM_SMCR_MSM              TIM_SMCR_MSM_Msk                             /*!<Master/slave mode                       */
N
N#define TIM_SMCR_ETF_Pos          (8U)                                         
N#define TIM_SMCR_ETF_Msk          (0xFUL << TIM_SMCR_ETF_Pos)                   /*!< 0x00000F00 */
N#define TIM_SMCR_ETF              TIM_SMCR_ETF_Msk                             /*!<ETF[3:0] bits (External trigger filter) */
N#define TIM_SMCR_ETF_0            (0x1UL << TIM_SMCR_ETF_Pos)                   /*!< 0x0100 */
N#define TIM_SMCR_ETF_1            (0x2UL << TIM_SMCR_ETF_Pos)                   /*!< 0x0200 */
N#define TIM_SMCR_ETF_2            (0x4UL << TIM_SMCR_ETF_Pos)                   /*!< 0x0400 */
N#define TIM_SMCR_ETF_3            (0x8UL << TIM_SMCR_ETF_Pos)                   /*!< 0x0800 */
N
N#define TIM_SMCR_ETPS_Pos         (12U)                                        
N#define TIM_SMCR_ETPS_Msk         (0x3UL << TIM_SMCR_ETPS_Pos)                  /*!< 0x00003000 */
N#define TIM_SMCR_ETPS             TIM_SMCR_ETPS_Msk                            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define TIM_SMCR_ETPS_0           (0x1UL << TIM_SMCR_ETPS_Pos)                  /*!< 0x1000 */
N#define TIM_SMCR_ETPS_1           (0x2UL << TIM_SMCR_ETPS_Pos)                  /*!< 0x2000 */
N
N#define TIM_SMCR_ECE_Pos          (14U)                                        
N#define TIM_SMCR_ECE_Msk          (0x1UL << TIM_SMCR_ECE_Pos)                   /*!< 0x00004000 */
N#define TIM_SMCR_ECE              TIM_SMCR_ECE_Msk                             /*!<External clock enable     */
N#define TIM_SMCR_ETP_Pos          (15U)                                        
N#define TIM_SMCR_ETP_Msk          (0x1UL << TIM_SMCR_ETP_Pos)                   /*!< 0x00008000 */
N#define TIM_SMCR_ETP              TIM_SMCR_ETP_Msk                             /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define TIM_DIER_UIE_Pos          (0U)                                         
N#define TIM_DIER_UIE_Msk          (0x1UL << TIM_DIER_UIE_Pos)                   /*!< 0x00000001 */
N#define TIM_DIER_UIE              TIM_DIER_UIE_Msk                             /*!<Update interrupt enable */
N#define TIM_DIER_CC1IE_Pos        (1U)                                         
N#define TIM_DIER_CC1IE_Msk        (0x1UL << TIM_DIER_CC1IE_Pos)                 /*!< 0x00000002 */
N#define TIM_DIER_CC1IE            TIM_DIER_CC1IE_Msk                           /*!<Capture/Compare 1 interrupt enable   */
N#define TIM_DIER_CC2IE_Pos        (2U)                                         
N#define TIM_DIER_CC2IE_Msk        (0x1UL << TIM_DIER_CC2IE_Pos)                 /*!< 0x00000004 */
N#define TIM_DIER_CC2IE            TIM_DIER_CC2IE_Msk                           /*!<Capture/Compare 2 interrupt enable   */
N#define TIM_DIER_CC3IE_Pos        (3U)                                         
N#define TIM_DIER_CC3IE_Msk        (0x1UL << TIM_DIER_CC3IE_Pos)                 /*!< 0x00000008 */
N#define TIM_DIER_CC3IE            TIM_DIER_CC3IE_Msk                           /*!<Capture/Compare 3 interrupt enable   */
N#define TIM_DIER_CC4IE_Pos        (4U)                                         
N#define TIM_DIER_CC4IE_Msk        (0x1UL << TIM_DIER_CC4IE_Pos)                 /*!< 0x00000010 */
N#define TIM_DIER_CC4IE            TIM_DIER_CC4IE_Msk                           /*!<Capture/Compare 4 interrupt enable   */
N#define TIM_DIER_COMIE_Pos        (5U)                                         
N#define TIM_DIER_COMIE_Msk        (0x1UL << TIM_DIER_COMIE_Pos)                 /*!< 0x00000020 */
N#define TIM_DIER_COMIE            TIM_DIER_COMIE_Msk                           /*!<COM interrupt enable                 */
N#define TIM_DIER_TIE_Pos          (6U)                                         
N#define TIM_DIER_TIE_Msk          (0x1UL << TIM_DIER_TIE_Pos)                   /*!< 0x00000040 */
N#define TIM_DIER_TIE              TIM_DIER_TIE_Msk                             /*!<Trigger interrupt enable             */
N#define TIM_DIER_BIE_Pos          (7U)                                         
N#define TIM_DIER_BIE_Msk          (0x1UL << TIM_DIER_BIE_Pos)                   /*!< 0x00000080 */
N#define TIM_DIER_BIE              TIM_DIER_BIE_Msk                             /*!<Break interrupt enable               */
N#define TIM_DIER_UDE_Pos          (8U)                                         
N#define TIM_DIER_UDE_Msk          (0x1UL << TIM_DIER_UDE_Pos)                   /*!< 0x00000100 */
N#define TIM_DIER_UDE              TIM_DIER_UDE_Msk                             /*!<Update DMA request enable            */
N#define TIM_DIER_CC1DE_Pos        (9U)                                         
N#define TIM_DIER_CC1DE_Msk        (0x1UL << TIM_DIER_CC1DE_Pos)                 /*!< 0x00000200 */
N#define TIM_DIER_CC1DE            TIM_DIER_CC1DE_Msk                           /*!<Capture/Compare 1 DMA request enable */
N#define TIM_DIER_CC2DE_Pos        (10U)                                        
N#define TIM_DIER_CC2DE_Msk        (0x1UL << TIM_DIER_CC2DE_Pos)                 /*!< 0x00000400 */
N#define TIM_DIER_CC2DE            TIM_DIER_CC2DE_Msk                           /*!<Capture/Compare 2 DMA request enable */
N#define TIM_DIER_CC3DE_Pos        (11U)                                        
N#define TIM_DIER_CC3DE_Msk        (0x1UL << TIM_DIER_CC3DE_Pos)                 /*!< 0x00000800 */
N#define TIM_DIER_CC3DE            TIM_DIER_CC3DE_Msk                           /*!<Capture/Compare 3 DMA request enable */
N#define TIM_DIER_CC4DE_Pos        (12U)                                        
N#define TIM_DIER_CC4DE_Msk        (0x1UL << TIM_DIER_CC4DE_Pos)                 /*!< 0x00001000 */
N#define TIM_DIER_CC4DE            TIM_DIER_CC4DE_Msk                           /*!<Capture/Compare 4 DMA request enable */
N#define TIM_DIER_COMDE_Pos        (13U)                                        
N#define TIM_DIER_COMDE_Msk        (0x1UL << TIM_DIER_COMDE_Pos)                 /*!< 0x00002000 */
N#define TIM_DIER_COMDE            TIM_DIER_COMDE_Msk                           /*!<COM DMA request enable               */
N#define TIM_DIER_TDE_Pos          (14U)                                        
N#define TIM_DIER_TDE_Msk          (0x1UL << TIM_DIER_TDE_Pos)                   /*!< 0x00004000 */
N#define TIM_DIER_TDE              TIM_DIER_TDE_Msk                             /*!<Trigger DMA request enable           */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define TIM_SR_UIF_Pos            (0U)                                         
N#define TIM_SR_UIF_Msk            (0x1UL << TIM_SR_UIF_Pos)                     /*!< 0x00000001 */
N#define TIM_SR_UIF                TIM_SR_UIF_Msk                               /*!<Update interrupt Flag              */
N#define TIM_SR_CC1IF_Pos          (1U)                                         
N#define TIM_SR_CC1IF_Msk          (0x1UL << TIM_SR_CC1IF_Pos)                   /*!< 0x00000002 */
N#define TIM_SR_CC1IF              TIM_SR_CC1IF_Msk                             /*!<Capture/Compare 1 interrupt Flag   */
N#define TIM_SR_CC2IF_Pos          (2U)                                         
N#define TIM_SR_CC2IF_Msk          (0x1UL << TIM_SR_CC2IF_Pos)                   /*!< 0x00000004 */
N#define TIM_SR_CC2IF              TIM_SR_CC2IF_Msk                             /*!<Capture/Compare 2 interrupt Flag   */
N#define TIM_SR_CC3IF_Pos          (3U)                                         
N#define TIM_SR_CC3IF_Msk          (0x1UL << TIM_SR_CC3IF_Pos)                   /*!< 0x00000008 */
N#define TIM_SR_CC3IF              TIM_SR_CC3IF_Msk                             /*!<Capture/Compare 3 interrupt Flag   */
N#define TIM_SR_CC4IF_Pos          (4U)                                         
N#define TIM_SR_CC4IF_Msk          (0x1UL << TIM_SR_CC4IF_Pos)                   /*!< 0x00000010 */
N#define TIM_SR_CC4IF              TIM_SR_CC4IF_Msk                             /*!<Capture/Compare 4 interrupt Flag   */
N#define TIM_SR_COMIF_Pos          (5U)                                         
N#define TIM_SR_COMIF_Msk          (0x1UL << TIM_SR_COMIF_Pos)                   /*!< 0x00000020 */
N#define TIM_SR_COMIF              TIM_SR_COMIF_Msk                             /*!<COM interrupt Flag                 */
N#define TIM_SR_TIF_Pos            (6U)                                         
N#define TIM_SR_TIF_Msk            (0x1UL << TIM_SR_TIF_Pos)                     /*!< 0x00000040 */
N#define TIM_SR_TIF                TIM_SR_TIF_Msk                               /*!<Trigger interrupt Flag             */
N#define TIM_SR_BIF_Pos            (7U)                                         
N#define TIM_SR_BIF_Msk            (0x1UL << TIM_SR_BIF_Pos)                     /*!< 0x00000080 */
N#define TIM_SR_BIF                TIM_SR_BIF_Msk                               /*!<Break interrupt Flag               */
N#define TIM_SR_CC1OF_Pos          (9U)                                         
N#define TIM_SR_CC1OF_Msk          (0x1UL << TIM_SR_CC1OF_Pos)                   /*!< 0x00000200 */
N#define TIM_SR_CC1OF              TIM_SR_CC1OF_Msk                             /*!<Capture/Compare 1 Overcapture Flag */
N#define TIM_SR_CC2OF_Pos          (10U)                                        
N#define TIM_SR_CC2OF_Msk          (0x1UL << TIM_SR_CC2OF_Pos)                   /*!< 0x00000400 */
N#define TIM_SR_CC2OF              TIM_SR_CC2OF_Msk                             /*!<Capture/Compare 2 Overcapture Flag */
N#define TIM_SR_CC3OF_Pos          (11U)                                        
N#define TIM_SR_CC3OF_Msk          (0x1UL << TIM_SR_CC3OF_Pos)                   /*!< 0x00000800 */
N#define TIM_SR_CC3OF              TIM_SR_CC3OF_Msk                             /*!<Capture/Compare 3 Overcapture Flag */
N#define TIM_SR_CC4OF_Pos          (12U)                                        
N#define TIM_SR_CC4OF_Msk          (0x1UL << TIM_SR_CC4OF_Pos)                   /*!< 0x00001000 */
N#define TIM_SR_CC4OF              TIM_SR_CC4OF_Msk                             /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define TIM_EGR_UG_Pos            (0U)                                         
N#define TIM_EGR_UG_Msk            (0x1UL << TIM_EGR_UG_Pos)                     /*!< 0x00000001 */
N#define TIM_EGR_UG                TIM_EGR_UG_Msk                               /*!<Update Generation                         */
N#define TIM_EGR_CC1G_Pos          (1U)                                         
N#define TIM_EGR_CC1G_Msk          (0x1UL << TIM_EGR_CC1G_Pos)                   /*!< 0x00000002 */
N#define TIM_EGR_CC1G              TIM_EGR_CC1G_Msk                             /*!<Capture/Compare 1 Generation              */
N#define TIM_EGR_CC2G_Pos          (2U)                                         
N#define TIM_EGR_CC2G_Msk          (0x1UL << TIM_EGR_CC2G_Pos)                   /*!< 0x00000004 */
N#define TIM_EGR_CC2G              TIM_EGR_CC2G_Msk                             /*!<Capture/Compare 2 Generation              */
N#define TIM_EGR_CC3G_Pos          (3U)                                         
N#define TIM_EGR_CC3G_Msk          (0x1UL << TIM_EGR_CC3G_Pos)                   /*!< 0x00000008 */
N#define TIM_EGR_CC3G              TIM_EGR_CC3G_Msk                             /*!<Capture/Compare 3 Generation              */
N#define TIM_EGR_CC4G_Pos          (4U)                                         
N#define TIM_EGR_CC4G_Msk          (0x1UL << TIM_EGR_CC4G_Pos)                   /*!< 0x00000010 */
N#define TIM_EGR_CC4G              TIM_EGR_CC4G_Msk                             /*!<Capture/Compare 4 Generation              */
N#define TIM_EGR_COMG_Pos          (5U)                                         
N#define TIM_EGR_COMG_Msk          (0x1UL << TIM_EGR_COMG_Pos)                   /*!< 0x00000020 */
N#define TIM_EGR_COMG              TIM_EGR_COMG_Msk                             /*!<Capture/Compare Control Update Generation */
N#define TIM_EGR_TG_Pos            (6U)                                         
N#define TIM_EGR_TG_Msk            (0x1UL << TIM_EGR_TG_Pos)                     /*!< 0x00000040 */
N#define TIM_EGR_TG                TIM_EGR_TG_Msk                               /*!<Trigger Generation                        */
N#define TIM_EGR_BG_Pos            (7U)                                         
N#define TIM_EGR_BG_Msk            (0x1UL << TIM_EGR_BG_Pos)                     /*!< 0x00000080 */
N#define TIM_EGR_BG                TIM_EGR_BG_Msk                               /*!<Break Generation                          */
N
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define TIM_CCMR1_CC1S_Pos        (0U)                                         
N#define TIM_CCMR1_CC1S_Msk        (0x3UL << TIM_CCMR1_CC1S_Pos)                 /*!< 0x00000003 */
N#define TIM_CCMR1_CC1S            TIM_CCMR1_CC1S_Msk                           /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define TIM_CCMR1_CC1S_0          (0x1UL << TIM_CCMR1_CC1S_Pos)                 /*!< 0x0001 */
N#define TIM_CCMR1_CC1S_1          (0x2UL << TIM_CCMR1_CC1S_Pos)                 /*!< 0x0002 */
N
N#define TIM_CCMR1_OC1FE_Pos       (2U)                                         
N#define TIM_CCMR1_OC1FE_Msk       (0x1UL << TIM_CCMR1_OC1FE_Pos)                /*!< 0x00000004 */
N#define TIM_CCMR1_OC1FE           TIM_CCMR1_OC1FE_Msk                          /*!<Output Compare 1 Fast enable                 */
N#define TIM_CCMR1_OC1PE_Pos       (3U)                                         
N#define TIM_CCMR1_OC1PE_Msk       (0x1UL << TIM_CCMR1_OC1PE_Pos)                /*!< 0x00000008 */
N#define TIM_CCMR1_OC1PE           TIM_CCMR1_OC1PE_Msk                          /*!<Output Compare 1 Preload enable              */
N
N#define TIM_CCMR1_OC1M_Pos        (4U)                                         
N#define TIM_CCMR1_OC1M_Msk        (0x7UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000070 */
N#define TIM_CCMR1_OC1M            TIM_CCMR1_OC1M_Msk                           /*!<OC1M[2:0] bits (Output Compare 1 Mode)       */
N#define TIM_CCMR1_OC1M_0          (0x1UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x0010 */
N#define TIM_CCMR1_OC1M_1          (0x2UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x0020 */
N#define TIM_CCMR1_OC1M_2          (0x4UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x0040 */
N
N#define TIM_CCMR1_OC1CE_Pos       (7U)                                         
N#define TIM_CCMR1_OC1CE_Msk       (0x1UL << TIM_CCMR1_OC1CE_Pos)                /*!< 0x00000080 */
N#define TIM_CCMR1_OC1CE           TIM_CCMR1_OC1CE_Msk                          /*!<Output Compare 1Clear Enable                 */
N
N#define TIM_CCMR1_CC2S_Pos        (8U)                                         
N#define TIM_CCMR1_CC2S_Msk        (0x3UL << TIM_CCMR1_CC2S_Pos)                 /*!< 0x00000300 */
N#define TIM_CCMR1_CC2S            TIM_CCMR1_CC2S_Msk                           /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define TIM_CCMR1_CC2S_0          (0x1UL << TIM_CCMR1_CC2S_Pos)                 /*!< 0x0100 */
N#define TIM_CCMR1_CC2S_1          (0x2UL << TIM_CCMR1_CC2S_Pos)                 /*!< 0x0200 */
N
N#define TIM_CCMR1_OC2FE_Pos       (10U)                                        
N#define TIM_CCMR1_OC2FE_Msk       (0x1UL << TIM_CCMR1_OC2FE_Pos)                /*!< 0x00000400 */
N#define TIM_CCMR1_OC2FE           TIM_CCMR1_OC2FE_Msk                          /*!<Output Compare 2 Fast enable                 */
N#define TIM_CCMR1_OC2PE_Pos       (11U)                                        
N#define TIM_CCMR1_OC2PE_Msk       (0x1UL << TIM_CCMR1_OC2PE_Pos)                /*!< 0x00000800 */
N#define TIM_CCMR1_OC2PE           TIM_CCMR1_OC2PE_Msk                          /*!<Output Compare 2 Preload enable              */
N
N#define TIM_CCMR1_OC2M_Pos        (12U)                                        
N#define TIM_CCMR1_OC2M_Msk        (0x7UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00007000 */
N#define TIM_CCMR1_OC2M            TIM_CCMR1_OC2M_Msk                           /*!<OC2M[2:0] bits (Output Compare 2 Mode)       */
N#define TIM_CCMR1_OC2M_0          (0x1UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x1000 */
N#define TIM_CCMR1_OC2M_1          (0x2UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x2000 */
N#define TIM_CCMR1_OC2M_2          (0x4UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x4000 */
N
N#define TIM_CCMR1_OC2CE_Pos       (15U)                                        
N#define TIM_CCMR1_OC2CE_Msk       (0x1UL << TIM_CCMR1_OC2CE_Pos)                /*!< 0x00008000 */
N#define TIM_CCMR1_OC2CE           TIM_CCMR1_OC2CE_Msk                          /*!<Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define TIM_CCMR1_IC1PSC_Pos      (2U)                                         
N#define TIM_CCMR1_IC1PSC_Msk      (0x3UL << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x0000000C */
N#define TIM_CCMR1_IC1PSC          TIM_CCMR1_IC1PSC_Msk                         /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define TIM_CCMR1_IC1PSC_0        (0x1UL << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x0004 */
N#define TIM_CCMR1_IC1PSC_1        (0x2UL << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x0008 */
N
N#define TIM_CCMR1_IC1F_Pos        (4U)                                         
N#define TIM_CCMR1_IC1F_Msk        (0xFUL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x000000F0 */
N#define TIM_CCMR1_IC1F            TIM_CCMR1_IC1F_Msk                           /*!<IC1F[3:0] bits (Input Capture 1 Filter)      */
N#define TIM_CCMR1_IC1F_0          (0x1UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x0010 */
N#define TIM_CCMR1_IC1F_1          (0x2UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x0020 */
N#define TIM_CCMR1_IC1F_2          (0x4UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x0040 */
N#define TIM_CCMR1_IC1F_3          (0x8UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x0080 */
N
N#define TIM_CCMR1_IC2PSC_Pos      (10U)                                        
N#define TIM_CCMR1_IC2PSC_Msk      (0x3UL << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x00000C00 */
N#define TIM_CCMR1_IC2PSC          TIM_CCMR1_IC2PSC_Msk                         /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler)  */
N#define TIM_CCMR1_IC2PSC_0        (0x1UL << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x0400 */
N#define TIM_CCMR1_IC2PSC_1        (0x2UL << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x0800 */
N
N#define TIM_CCMR1_IC2F_Pos        (12U)                                        
N#define TIM_CCMR1_IC2F_Msk        (0xFUL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x0000F000 */
N#define TIM_CCMR1_IC2F            TIM_CCMR1_IC2F_Msk                           /*!<IC2F[3:0] bits (Input Capture 2 Filter)       */
N#define TIM_CCMR1_IC2F_0          (0x1UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x1000 */
N#define TIM_CCMR1_IC2F_1          (0x2UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x2000 */
N#define TIM_CCMR1_IC2F_2          (0x4UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x4000 */
N#define TIM_CCMR1_IC2F_3          (0x8UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x8000 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define TIM_CCMR2_CC3S_Pos        (0U)                                         
N#define TIM_CCMR2_CC3S_Msk        (0x3UL << TIM_CCMR2_CC3S_Pos)                 /*!< 0x00000003 */
N#define TIM_CCMR2_CC3S            TIM_CCMR2_CC3S_Msk                           /*!<CC3S[1:0] bits (Capture/Compare 3 Selection)  */
N#define TIM_CCMR2_CC3S_0          (0x1UL << TIM_CCMR2_CC3S_Pos)                 /*!< 0x0001 */
N#define TIM_CCMR2_CC3S_1          (0x2UL << TIM_CCMR2_CC3S_Pos)                 /*!< 0x0002 */
N
N#define TIM_CCMR2_OC3FE_Pos       (2U)                                         
N#define TIM_CCMR2_OC3FE_Msk       (0x1UL << TIM_CCMR2_OC3FE_Pos)                /*!< 0x00000004 */
N#define TIM_CCMR2_OC3FE           TIM_CCMR2_OC3FE_Msk                          /*!<Output Compare 3 Fast enable           */
N#define TIM_CCMR2_OC3PE_Pos       (3U)                                         
N#define TIM_CCMR2_OC3PE_Msk       (0x1UL << TIM_CCMR2_OC3PE_Pos)                /*!< 0x00000008 */
N#define TIM_CCMR2_OC3PE           TIM_CCMR2_OC3PE_Msk                          /*!<Output Compare 3 Preload enable        */
N
N#define TIM_CCMR2_OC3M_Pos        (4U)                                         
N#define TIM_CCMR2_OC3M_Msk        (0x7UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000070 */
N#define TIM_CCMR2_OC3M            TIM_CCMR2_OC3M_Msk                           /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define TIM_CCMR2_OC3M_0          (0x1UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x0010 */
N#define TIM_CCMR2_OC3M_1          (0x2UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x0020 */
N#define TIM_CCMR2_OC3M_2          (0x4UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x0040 */
N
N#define TIM_CCMR2_OC3CE_Pos       (7U)                                         
N#define TIM_CCMR2_OC3CE_Msk       (0x1UL << TIM_CCMR2_OC3CE_Pos)                /*!< 0x00000080 */
N#define TIM_CCMR2_OC3CE           TIM_CCMR2_OC3CE_Msk                          /*!<Output Compare 3 Clear Enable */
N
N#define TIM_CCMR2_CC4S_Pos        (8U)                                         
N#define TIM_CCMR2_CC4S_Msk        (0x3UL << TIM_CCMR2_CC4S_Pos)                 /*!< 0x00000300 */
N#define TIM_CCMR2_CC4S            TIM_CCMR2_CC4S_Msk                           /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define TIM_CCMR2_CC4S_0          (0x1UL << TIM_CCMR2_CC4S_Pos)                 /*!< 0x0100 */
N#define TIM_CCMR2_CC4S_1          (0x2UL << TIM_CCMR2_CC4S_Pos)                 /*!< 0x0200 */
N
N#define TIM_CCMR2_OC4FE_Pos       (10U)                                        
N#define TIM_CCMR2_OC4FE_Msk       (0x1UL << TIM_CCMR2_OC4FE_Pos)                /*!< 0x00000400 */
N#define TIM_CCMR2_OC4FE           TIM_CCMR2_OC4FE_Msk                          /*!<Output Compare 4 Fast enable    */
N#define TIM_CCMR2_OC4PE_Pos       (11U)                                        
N#define TIM_CCMR2_OC4PE_Msk       (0x1UL << TIM_CCMR2_OC4PE_Pos)                /*!< 0x00000800 */
N#define TIM_CCMR2_OC4PE           TIM_CCMR2_OC4PE_Msk                          /*!<Output Compare 4 Preload enable */
N
N#define TIM_CCMR2_OC4M_Pos        (12U)                                        
N#define TIM_CCMR2_OC4M_Msk        (0x7UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00007000 */
N#define TIM_CCMR2_OC4M            TIM_CCMR2_OC4M_Msk                           /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define TIM_CCMR2_OC4M_0          (0x1UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x1000 */
N#define TIM_CCMR2_OC4M_1          (0x2UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x2000 */
N#define TIM_CCMR2_OC4M_2          (0x4UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x4000 */
N
N#define TIM_CCMR2_OC4CE_Pos       (15U)                                        
N#define TIM_CCMR2_OC4CE_Msk       (0x1UL << TIM_CCMR2_OC4CE_Pos)                /*!< 0x00008000 */
N#define TIM_CCMR2_OC4CE           TIM_CCMR2_OC4CE_Msk                          /*!<Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define TIM_CCMR2_IC3PSC_Pos      (2U)                                         
N#define TIM_CCMR2_IC3PSC_Msk      (0x3UL << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x0000000C */
N#define TIM_CCMR2_IC3PSC          TIM_CCMR2_IC3PSC_Msk                         /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define TIM_CCMR2_IC3PSC_0        (0x1UL << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x0004 */
N#define TIM_CCMR2_IC3PSC_1        (0x2UL << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x0008 */
N
N#define TIM_CCMR2_IC3F_Pos        (4U)                                         
N#define TIM_CCMR2_IC3F_Msk        (0xFUL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x000000F0 */
N#define TIM_CCMR2_IC3F            TIM_CCMR2_IC3F_Msk                           /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define TIM_CCMR2_IC3F_0          (0x1UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x0010 */
N#define TIM_CCMR2_IC3F_1          (0x2UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x0020 */
N#define TIM_CCMR2_IC3F_2          (0x4UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x0040 */
N#define TIM_CCMR2_IC3F_3          (0x8UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x0080 */
N
N#define TIM_CCMR2_IC4PSC_Pos      (10U)                                        
N#define TIM_CCMR2_IC4PSC_Msk      (0x3UL << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x00000C00 */
N#define TIM_CCMR2_IC4PSC          TIM_CCMR2_IC4PSC_Msk                         /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define TIM_CCMR2_IC4PSC_0        (0x1UL << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x0400 */
N#define TIM_CCMR2_IC4PSC_1        (0x2UL << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x0800 */
N
N#define TIM_CCMR2_IC4F_Pos        (12U)                                        
N#define TIM_CCMR2_IC4F_Msk        (0xFUL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x0000F000 */
N#define TIM_CCMR2_IC4F            TIM_CCMR2_IC4F_Msk                           /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define TIM_CCMR2_IC4F_0          (0x1UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x1000 */
N#define TIM_CCMR2_IC4F_1          (0x2UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x2000 */
N#define TIM_CCMR2_IC4F_2          (0x4UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x4000 */
N#define TIM_CCMR2_IC4F_3          (0x8UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x8000 */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define TIM_CCER_CC1E_Pos         (0U)                                         
N#define TIM_CCER_CC1E_Msk         (0x1UL << TIM_CCER_CC1E_Pos)                  /*!< 0x00000001 */
N#define TIM_CCER_CC1E             TIM_CCER_CC1E_Msk                            /*!<Capture/Compare 1 output enable                 */
N#define TIM_CCER_CC1P_Pos         (1U)                                         
N#define TIM_CCER_CC1P_Msk         (0x1UL << TIM_CCER_CC1P_Pos)                  /*!< 0x00000002 */
N#define TIM_CCER_CC1P             TIM_CCER_CC1P_Msk                            /*!<Capture/Compare 1 output Polarity               */
N#define TIM_CCER_CC1NE_Pos        (2U)                                         
N#define TIM_CCER_CC1NE_Msk        (0x1UL << TIM_CCER_CC1NE_Pos)                 /*!< 0x00000004 */
N#define TIM_CCER_CC1NE            TIM_CCER_CC1NE_Msk                           /*!<Capture/Compare 1 Complementary output enable   */
N#define TIM_CCER_CC1NP_Pos        (3U)                                         
N#define TIM_CCER_CC1NP_Msk        (0x1UL << TIM_CCER_CC1NP_Pos)                 /*!< 0x00000008 */
N#define TIM_CCER_CC1NP            TIM_CCER_CC1NP_Msk                           /*!<Capture/Compare 1 Complementary output Polarity */
N#define TIM_CCER_CC2E_Pos         (4U)                                         
N#define TIM_CCER_CC2E_Msk         (0x1UL << TIM_CCER_CC2E_Pos)                  /*!< 0x00000010 */
N#define TIM_CCER_CC2E             TIM_CCER_CC2E_Msk                            /*!<Capture/Compare 2 output enable                 */
N#define TIM_CCER_CC2P_Pos         (5U)                                         
N#define TIM_CCER_CC2P_Msk         (0x1UL << TIM_CCER_CC2P_Pos)                  /*!< 0x00000020 */
N#define TIM_CCER_CC2P             TIM_CCER_CC2P_Msk                            /*!<Capture/Compare 2 output Polarity               */
N#define TIM_CCER_CC2NE_Pos        (6U)                                         
N#define TIM_CCER_CC2NE_Msk        (0x1UL << TIM_CCER_CC2NE_Pos)                 /*!< 0x00000040 */
N#define TIM_CCER_CC2NE            TIM_CCER_CC2NE_Msk                           /*!<Capture/Compare 2 Complementary output enable   */
N#define TIM_CCER_CC2NP_Pos        (7U)                                         
N#define TIM_CCER_CC2NP_Msk        (0x1UL << TIM_CCER_CC2NP_Pos)                 /*!< 0x00000080 */
N#define TIM_CCER_CC2NP            TIM_CCER_CC2NP_Msk                           /*!<Capture/Compare 2 Complementary output Polarity */
N#define TIM_CCER_CC3E_Pos         (8U)                                         
N#define TIM_CCER_CC3E_Msk         (0x1UL << TIM_CCER_CC3E_Pos)                  /*!< 0x00000100 */
N#define TIM_CCER_CC3E             TIM_CCER_CC3E_Msk                            /*!<Capture/Compare 3 output enable                 */
N#define TIM_CCER_CC3P_Pos         (9U)                                         
N#define TIM_CCER_CC3P_Msk         (0x1UL << TIM_CCER_CC3P_Pos)                  /*!< 0x00000200 */
N#define TIM_CCER_CC3P             TIM_CCER_CC3P_Msk                            /*!<Capture/Compare 3 output Polarity               */
N#define TIM_CCER_CC3NE_Pos        (10U)                                        
N#define TIM_CCER_CC3NE_Msk        (0x1UL << TIM_CCER_CC3NE_Pos)                 /*!< 0x00000400 */
N#define TIM_CCER_CC3NE            TIM_CCER_CC3NE_Msk                           /*!<Capture/Compare 3 Complementary output enable   */
N#define TIM_CCER_CC3NP_Pos        (11U)                                        
N#define TIM_CCER_CC3NP_Msk        (0x1UL << TIM_CCER_CC3NP_Pos)                 /*!< 0x00000800 */
N#define TIM_CCER_CC3NP            TIM_CCER_CC3NP_Msk                           /*!<Capture/Compare 3 Complementary output Polarity */
N#define TIM_CCER_CC4E_Pos         (12U)                                        
N#define TIM_CCER_CC4E_Msk         (0x1UL << TIM_CCER_CC4E_Pos)                  /*!< 0x00001000 */
N#define TIM_CCER_CC4E             TIM_CCER_CC4E_Msk                            /*!<Capture/Compare 4 output enable                 */
N#define TIM_CCER_CC4P_Pos         (13U)                                        
N#define TIM_CCER_CC4P_Msk         (0x1UL << TIM_CCER_CC4P_Pos)                  /*!< 0x00002000 */
N#define TIM_CCER_CC4P             TIM_CCER_CC4P_Msk                            /*!<Capture/Compare 4 output Polarity               */
N#define TIM_CCER_CC4NP_Pos        (15U)                                        
N#define TIM_CCER_CC4NP_Msk        (0x1UL << TIM_CCER_CC4NP_Pos)                 /*!< 0x00008000 */
N#define TIM_CCER_CC4NP            TIM_CCER_CC4NP_Msk                           /*!<Capture/Compare 4 Complementary output Polarity */
N
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define TIM_CNT_CNT_Pos           (0U)                                             
N#define TIM_CNT_CNT_Msk           (0xFFFFFFFFUL << TIM_CNT_CNT_Pos)                 /*!< 0xFFFFFFFF */
N#define TIM_CNT_CNT               TIM_CNT_CNT_Msk                                  /*!<Counter Value            */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define TIM_PSC_PSC_Pos           (0U)                                         
N#define TIM_PSC_PSC_Msk           (0xFFFFUL << TIM_PSC_PSC_Pos)                 /*!< 0x0000FFFF */
N#define TIM_PSC_PSC               TIM_PSC_PSC_Msk                              /*!<Prescaler Value          */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define TIM_ARR_ARR_Pos           (0U)                                         
N#define TIM_ARR_ARR_Msk           (0xFFFFFFFFUL << TIM_ARR_ARR_Pos)             /*!< 0xFFFFFFFF */
N#define TIM_ARR_ARR               TIM_ARR_ARR_Msk                              /*!<actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  ********************/
N#define TIM_RCR_REP_Pos           (0U)                                         
N#define TIM_RCR_REP_Msk           (0xFFUL << TIM_RCR_REP_Pos)                   /*!< 0x000000FF */
N#define TIM_RCR_REP               TIM_RCR_REP_Msk                              /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define TIM_CCR1_CCR1_Pos         (0U)                                         
N#define TIM_CCR1_CCR1_Msk         (0xFFFFUL << TIM_CCR1_CCR1_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR1_CCR1             TIM_CCR1_CCR1_Msk                            /*!<Capture/Compare 1 Value  */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define TIM_CCR2_CCR2_Pos         (0U)                                         
N#define TIM_CCR2_CCR2_Msk         (0xFFFFUL << TIM_CCR2_CCR2_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR2_CCR2             TIM_CCR2_CCR2_Msk                            /*!<Capture/Compare 2 Value  */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define TIM_CCR3_CCR3_Pos         (0U)                                         
N#define TIM_CCR3_CCR3_Msk         (0xFFFFUL << TIM_CCR3_CCR3_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR3_CCR3             TIM_CCR3_CCR3_Msk                            /*!<Capture/Compare 3 Value  */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define TIM_CCR4_CCR4_Pos         (0U)                                         
N#define TIM_CCR4_CCR4_Msk         (0xFFFFUL << TIM_CCR4_CCR4_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR4_CCR4             TIM_CCR4_CCR4_Msk                            /*!<Capture/Compare 4 Value  */
N
N/*******************  Bit definition for TIM_BDTR register  *******************/
N#define TIM_BDTR_DTG_Pos          (0U)                                         
N#define TIM_BDTR_DTG_Msk          (0xFFUL << TIM_BDTR_DTG_Pos)                  /*!< 0x000000FF */
N#define TIM_BDTR_DTG              TIM_BDTR_DTG_Msk                             /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define TIM_BDTR_DTG_0            (0x01UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0001 */
N#define TIM_BDTR_DTG_1            (0x02UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0002 */
N#define TIM_BDTR_DTG_2            (0x04UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0004 */
N#define TIM_BDTR_DTG_3            (0x08UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0008 */
N#define TIM_BDTR_DTG_4            (0x10UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0010 */
N#define TIM_BDTR_DTG_5            (0x20UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0020 */
N#define TIM_BDTR_DTG_6            (0x40UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0040 */
N#define TIM_BDTR_DTG_7            (0x80UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0080 */
N
N#define TIM_BDTR_LOCK_Pos         (8U)                                         
N#define TIM_BDTR_LOCK_Msk         (0x3UL << TIM_BDTR_LOCK_Pos)                  /*!< 0x00000300 */
N#define TIM_BDTR_LOCK             TIM_BDTR_LOCK_Msk                            /*!<LOCK[1:0] bits (Lock Configuration) */
N#define TIM_BDTR_LOCK_0           (0x1UL << TIM_BDTR_LOCK_Pos)                  /*!< 0x0100 */
N#define TIM_BDTR_LOCK_1           (0x2UL << TIM_BDTR_LOCK_Pos)                  /*!< 0x0200 */
N
N#define TIM_BDTR_OSSI_Pos         (10U)                                        
N#define TIM_BDTR_OSSI_Msk         (0x1UL << TIM_BDTR_OSSI_Pos)                  /*!< 0x00000400 */
N#define TIM_BDTR_OSSI             TIM_BDTR_OSSI_Msk                            /*!<Off-State Selection for Idle mode */
N#define TIM_BDTR_OSSR_Pos         (11U)                                        
N#define TIM_BDTR_OSSR_Msk         (0x1UL << TIM_BDTR_OSSR_Pos)                  /*!< 0x00000800 */
N#define TIM_BDTR_OSSR             TIM_BDTR_OSSR_Msk                            /*!<Off-State Selection for Run mode  */
N#define TIM_BDTR_BKE_Pos          (12U)                                        
N#define TIM_BDTR_BKE_Msk          (0x1UL << TIM_BDTR_BKE_Pos)                   /*!< 0x00001000 */
N#define TIM_BDTR_BKE              TIM_BDTR_BKE_Msk                             /*!<Break enable                      */
N#define TIM_BDTR_BKP_Pos          (13U)                                        
N#define TIM_BDTR_BKP_Msk          (0x1UL << TIM_BDTR_BKP_Pos)                   /*!< 0x00002000 */
N#define TIM_BDTR_BKP              TIM_BDTR_BKP_Msk                             /*!<Break Polarity                    */
N#define TIM_BDTR_AOE_Pos          (14U)                                        
N#define TIM_BDTR_AOE_Msk          (0x1UL << TIM_BDTR_AOE_Pos)                   /*!< 0x00004000 */
N#define TIM_BDTR_AOE              TIM_BDTR_AOE_Msk                             /*!<Automatic Output enable           */
N#define TIM_BDTR_MOE_Pos          (15U)                                        
N#define TIM_BDTR_MOE_Msk          (0x1UL << TIM_BDTR_MOE_Pos)                   /*!< 0x00008000 */
N#define TIM_BDTR_MOE              TIM_BDTR_MOE_Msk                             /*!<Main Output enable                */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define TIM_DCR_DBA_Pos           (0U)                                         
N#define TIM_DCR_DBA_Msk           (0x1FUL << TIM_DCR_DBA_Pos)                   /*!< 0x0000001F */
N#define TIM_DCR_DBA               TIM_DCR_DBA_Msk                              /*!<DBA[4:0] bits (DMA Base Address) */
N#define TIM_DCR_DBA_0             (0x01UL << TIM_DCR_DBA_Pos)                   /*!< 0x0001 */
N#define TIM_DCR_DBA_1             (0x02UL << TIM_DCR_DBA_Pos)                   /*!< 0x0002 */
N#define TIM_DCR_DBA_2             (0x04UL << TIM_DCR_DBA_Pos)                   /*!< 0x0004 */
N#define TIM_DCR_DBA_3             (0x08UL << TIM_DCR_DBA_Pos)                   /*!< 0x0008 */
N#define TIM_DCR_DBA_4             (0x10UL << TIM_DCR_DBA_Pos)                   /*!< 0x0010 */
N
N#define TIM_DCR_DBL_Pos           (8U)                                         
N#define TIM_DCR_DBL_Msk           (0x1FUL << TIM_DCR_DBL_Pos)                   /*!< 0x00001F00 */
N#define TIM_DCR_DBL               TIM_DCR_DBL_Msk                              /*!<DBL[4:0] bits (DMA Burst Length) */
N#define TIM_DCR_DBL_0             (0x01UL << TIM_DCR_DBL_Pos)                   /*!< 0x0100 */
N#define TIM_DCR_DBL_1             (0x02UL << TIM_DCR_DBL_Pos)                   /*!< 0x0200 */
N#define TIM_DCR_DBL_2             (0x04UL << TIM_DCR_DBL_Pos)                   /*!< 0x0400 */
N#define TIM_DCR_DBL_3             (0x08UL << TIM_DCR_DBL_Pos)                   /*!< 0x0800 */
N#define TIM_DCR_DBL_4             (0x10UL << TIM_DCR_DBL_Pos)                   /*!< 0x1000 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define TIM_DMAR_DMAB_Pos         (0U)                                         
N#define TIM_DMAR_DMAB_Msk         (0xFFFFUL << TIM_DMAR_DMAB_Pos)               /*!< 0x0000FFFF */
N#define TIM_DMAR_DMAB             TIM_DMAR_DMAB_Msk                            /*!<DMA register for burst accesses                    */
N
N/*******************  Bit definition for TIM_OR register  *********************/
N#define TIM_OR_TI1_RMP_Pos        (0U)                                          
N#define TIM_OR_TI1_RMP_Msk        (0x3UL << TIM_OR_TI1_RMP_Pos)                 /*!< 0x00000003 */
N#define TIM_OR_TI1_RMP            TIM_OR_TI1_RMP_Msk                           /*!< TI1_RMP[1:0] bits (TIM11 Input Capture 1 remap) */
N#define TIM_OR_TI1_RMP_0          (0x1UL << TIM_OR_TI1_RMP_Pos)                 /*!< 0x00000001 */
N#define TIM_OR_TI1_RMP_1          (0x2UL << TIM_OR_TI1_RMP_Pos)                 /*!< 0x00000002 */
N
N#define TIM_OR_TI4_RMP_Pos        (6U)                                         
N#define TIM_OR_TI4_RMP_Msk        (0x3UL << TIM_OR_TI4_RMP_Pos)                 /*!< 0x000000C0 */
N#define TIM_OR_TI4_RMP            TIM_OR_TI4_RMP_Msk                           /*!<TI4_RMP[1:0] bits (TIM5 Input 4 remap)             */
N#define TIM_OR_TI4_RMP_0          (0x1UL << TIM_OR_TI4_RMP_Pos)                 /*!< 0x0040 */
N#define TIM_OR_TI4_RMP_1          (0x2UL << TIM_OR_TI4_RMP_Pos)                 /*!< 0x0080 */
N#define TIM_OR_ITR1_RMP_Pos       (10U)                                        
N#define TIM_OR_ITR1_RMP_Msk       (0x3UL << TIM_OR_ITR1_RMP_Pos)                /*!< 0x00000C00 */
N#define TIM_OR_ITR1_RMP           TIM_OR_ITR1_RMP_Msk                          /*!<ITR1_RMP[1:0] bits (TIM2 Internal trigger 1 remap) */
N#define TIM_OR_ITR1_RMP_0         (0x1UL << TIM_OR_ITR1_RMP_Pos)                /*!< 0x0400 */
N#define TIM_OR_ITR1_RMP_1         (0x2UL << TIM_OR_ITR1_RMP_Pos)                /*!< 0x0800 */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*         Universal Synchronous Asynchronous Receiver Transmitter            */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for USART_SR register  *******************/
N#define USART_SR_PE_Pos               (0U)                                     
N#define USART_SR_PE_Msk               (0x1UL << USART_SR_PE_Pos)                /*!< 0x00000001 */
N#define USART_SR_PE                   USART_SR_PE_Msk                          /*!<Parity Error                 */
N#define USART_SR_FE_Pos               (1U)                                     
N#define USART_SR_FE_Msk               (0x1UL << USART_SR_FE_Pos)                /*!< 0x00000002 */
N#define USART_SR_FE                   USART_SR_FE_Msk                          /*!<Framing Error                */
N#define USART_SR_NE_Pos               (2U)                                     
N#define USART_SR_NE_Msk               (0x1UL << USART_SR_NE_Pos)                /*!< 0x00000004 */
N#define USART_SR_NE                   USART_SR_NE_Msk                          /*!<Noise Error Flag             */
N#define USART_SR_ORE_Pos              (3U)                                     
N#define USART_SR_ORE_Msk              (0x1UL << USART_SR_ORE_Pos)               /*!< 0x00000008 */
N#define USART_SR_ORE                  USART_SR_ORE_Msk                         /*!<OverRun Error                */
N#define USART_SR_IDLE_Pos             (4U)                                     
N#define USART_SR_IDLE_Msk             (0x1UL << USART_SR_IDLE_Pos)              /*!< 0x00000010 */
N#define USART_SR_IDLE                 USART_SR_IDLE_Msk                        /*!<IDLE line detected           */
N#define USART_SR_RXNE_Pos             (5U)                                     
N#define USART_SR_RXNE_Msk             (0x1UL << USART_SR_RXNE_Pos)              /*!< 0x00000020 */
N#define USART_SR_RXNE                 USART_SR_RXNE_Msk                        /*!<Read Data Register Not Empty */
N#define USART_SR_TC_Pos               (6U)                                     
N#define USART_SR_TC_Msk               (0x1UL << USART_SR_TC_Pos)                /*!< 0x00000040 */
N#define USART_SR_TC                   USART_SR_TC_Msk                          /*!<Transmission Complete        */
N#define USART_SR_TXE_Pos              (7U)                                     
N#define USART_SR_TXE_Msk              (0x1UL << USART_SR_TXE_Pos)               /*!< 0x00000080 */
N#define USART_SR_TXE                  USART_SR_TXE_Msk                         /*!<Transmit Data Register Empty */
N#define USART_SR_LBD_Pos              (8U)                                     
N#define USART_SR_LBD_Msk              (0x1UL << USART_SR_LBD_Pos)               /*!< 0x00000100 */
N#define USART_SR_LBD                  USART_SR_LBD_Msk                         /*!<LIN Break Detection Flag     */
N#define USART_SR_CTS_Pos              (9U)                                     
N#define USART_SR_CTS_Msk              (0x1UL << USART_SR_CTS_Pos)               /*!< 0x00000200 */
N#define USART_SR_CTS                  USART_SR_CTS_Msk                         /*!<CTS Flag                     */
N
N/*******************  Bit definition for USART_DR register  *******************/
N#define USART_DR_DR_Pos               (0U)                                     
N#define USART_DR_DR_Msk               (0x1FFUL << USART_DR_DR_Pos)              /*!< 0x000001FF */
N#define USART_DR_DR                   USART_DR_DR_Msk                          /*!<Data value */
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define USART_BRR_DIV_Fraction_Pos    (0U)                                     
N#define USART_BRR_DIV_Fraction_Msk    (0xFUL << USART_BRR_DIV_Fraction_Pos)     /*!< 0x0000000F */
N#define USART_BRR_DIV_Fraction        USART_BRR_DIV_Fraction_Msk               /*!<Fraction of USARTDIV */
N#define USART_BRR_DIV_Mantissa_Pos    (4U)                                     
N#define USART_BRR_DIV_Mantissa_Msk    (0xFFFUL << USART_BRR_DIV_Mantissa_Pos)   /*!< 0x0000FFF0 */
N#define USART_BRR_DIV_Mantissa        USART_BRR_DIV_Mantissa_Msk               /*!<Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_CR1 register  *******************/
N#define USART_CR1_SBK_Pos             (0U)                                     
N#define USART_CR1_SBK_Msk             (0x1UL << USART_CR1_SBK_Pos)              /*!< 0x00000001 */
N#define USART_CR1_SBK                 USART_CR1_SBK_Msk                        /*!<Send Break                             */
N#define USART_CR1_RWU_Pos             (1U)                                     
N#define USART_CR1_RWU_Msk             (0x1UL << USART_CR1_RWU_Pos)              /*!< 0x00000002 */
N#define USART_CR1_RWU                 USART_CR1_RWU_Msk                        /*!<Receiver wakeup                        */
N#define USART_CR1_RE_Pos              (2U)                                     
N#define USART_CR1_RE_Msk              (0x1UL << USART_CR1_RE_Pos)               /*!< 0x00000004 */
N#define USART_CR1_RE                  USART_CR1_RE_Msk                         /*!<Receiver Enable                        */
N#define USART_CR1_TE_Pos              (3U)                                     
N#define USART_CR1_TE_Msk              (0x1UL << USART_CR1_TE_Pos)               /*!< 0x00000008 */
N#define USART_CR1_TE                  USART_CR1_TE_Msk                         /*!<Transmitter Enable                     */
N#define USART_CR1_IDLEIE_Pos          (4U)                                     
N#define USART_CR1_IDLEIE_Msk          (0x1UL << USART_CR1_IDLEIE_Pos)           /*!< 0x00000010 */
N#define USART_CR1_IDLEIE              USART_CR1_IDLEIE_Msk                     /*!<IDLE Interrupt Enable                  */
N#define USART_CR1_RXNEIE_Pos          (5U)                                     
N#define USART_CR1_RXNEIE_Msk          (0x1UL << USART_CR1_RXNEIE_Pos)           /*!< 0x00000020 */
N#define USART_CR1_RXNEIE              USART_CR1_RXNEIE_Msk                     /*!<RXNE Interrupt Enable                  */
N#define USART_CR1_TCIE_Pos            (6U)                                     
N#define USART_CR1_TCIE_Msk            (0x1UL << USART_CR1_TCIE_Pos)             /*!< 0x00000040 */
N#define USART_CR1_TCIE                USART_CR1_TCIE_Msk                       /*!<Transmission Complete Interrupt Enable */
N#define USART_CR1_TXEIE_Pos           (7U)                                     
N#define USART_CR1_TXEIE_Msk           (0x1UL << USART_CR1_TXEIE_Pos)            /*!< 0x00000080 */
N#define USART_CR1_TXEIE               USART_CR1_TXEIE_Msk                      /*!<TXE Interrupt Enable                   */
N#define USART_CR1_PEIE_Pos            (8U)                                     
N#define USART_CR1_PEIE_Msk            (0x1UL << USART_CR1_PEIE_Pos)             /*!< 0x00000100 */
N#define USART_CR1_PEIE                USART_CR1_PEIE_Msk                       /*!<PE Interrupt Enable                    */
N#define USART_CR1_PS_Pos              (9U)                                     
N#define USART_CR1_PS_Msk              (0x1UL << USART_CR1_PS_Pos)               /*!< 0x00000200 */
N#define USART_CR1_PS                  USART_CR1_PS_Msk                         /*!<Parity Selection                       */
N#define USART_CR1_PCE_Pos             (10U)                                    
N#define USART_CR1_PCE_Msk             (0x1UL << USART_CR1_PCE_Pos)              /*!< 0x00000400 */
N#define USART_CR1_PCE                 USART_CR1_PCE_Msk                        /*!<Parity Control Enable                  */
N#define USART_CR1_WAKE_Pos            (11U)                                    
N#define USART_CR1_WAKE_Msk            (0x1UL << USART_CR1_WAKE_Pos)             /*!< 0x00000800 */
N#define USART_CR1_WAKE                USART_CR1_WAKE_Msk                       /*!<Wakeup method                          */
N#define USART_CR1_M_Pos               (12U)                                    
N#define USART_CR1_M_Msk               (0x1UL << USART_CR1_M_Pos)                /*!< 0x00001000 */
N#define USART_CR1_M                   USART_CR1_M_Msk                          /*!<Word length                            */
N#define USART_CR1_UE_Pos              (13U)                                    
N#define USART_CR1_UE_Msk              (0x1UL << USART_CR1_UE_Pos)               /*!< 0x00002000 */
N#define USART_CR1_UE                  USART_CR1_UE_Msk                         /*!<USART Enable                           */
N#define USART_CR1_OVER8_Pos           (15U)                                    
N#define USART_CR1_OVER8_Msk           (0x1UL << USART_CR1_OVER8_Pos)            /*!< 0x00008000 */
N#define USART_CR1_OVER8               USART_CR1_OVER8_Msk                      /*!<USART Oversampling by 8 enable         */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define USART_CR2_ADD_Pos             (0U)                                     
N#define USART_CR2_ADD_Msk             (0xFUL << USART_CR2_ADD_Pos)              /*!< 0x0000000F */
N#define USART_CR2_ADD                 USART_CR2_ADD_Msk                        /*!<Address of the USART node            */
N#define USART_CR2_LBDL_Pos            (5U)                                     
N#define USART_CR2_LBDL_Msk            (0x1UL << USART_CR2_LBDL_Pos)             /*!< 0x00000020 */
N#define USART_CR2_LBDL                USART_CR2_LBDL_Msk                       /*!<LIN Break Detection Length           */
N#define USART_CR2_LBDIE_Pos           (6U)                                     
N#define USART_CR2_LBDIE_Msk           (0x1UL << USART_CR2_LBDIE_Pos)            /*!< 0x00000040 */
N#define USART_CR2_LBDIE               USART_CR2_LBDIE_Msk                      /*!<LIN Break Detection Interrupt Enable */
N#define USART_CR2_LBCL_Pos            (8U)                                     
N#define USART_CR2_LBCL_Msk            (0x1UL << USART_CR2_LBCL_Pos)             /*!< 0x00000100 */
N#define USART_CR2_LBCL                USART_CR2_LBCL_Msk                       /*!<Last Bit Clock pulse                 */
N#define USART_CR2_CPHA_Pos            (9U)                                     
N#define USART_CR2_CPHA_Msk            (0x1UL << USART_CR2_CPHA_Pos)             /*!< 0x00000200 */
N#define USART_CR2_CPHA                USART_CR2_CPHA_Msk                       /*!<Clock Phase                          */
N#define USART_CR2_CPOL_Pos            (10U)                                    
N#define USART_CR2_CPOL_Msk            (0x1UL << USART_CR2_CPOL_Pos)             /*!< 0x00000400 */
N#define USART_CR2_CPOL                USART_CR2_CPOL_Msk                       /*!<Clock Polarity                       */
N#define USART_CR2_CLKEN_Pos           (11U)                                    
N#define USART_CR2_CLKEN_Msk           (0x1UL << USART_CR2_CLKEN_Pos)            /*!< 0x00000800 */
N#define USART_CR2_CLKEN               USART_CR2_CLKEN_Msk                      /*!<Clock Enable                         */
N
N#define USART_CR2_STOP_Pos            (12U)                                    
N#define USART_CR2_STOP_Msk            (0x3UL << USART_CR2_STOP_Pos)             /*!< 0x00003000 */
N#define USART_CR2_STOP                USART_CR2_STOP_Msk                       /*!<STOP[1:0] bits (STOP bits) */
N#define USART_CR2_STOP_0              (0x1UL << USART_CR2_STOP_Pos)             /*!< 0x1000 */
N#define USART_CR2_STOP_1              (0x2UL << USART_CR2_STOP_Pos)             /*!< 0x2000 */
N
N#define USART_CR2_LINEN_Pos           (14U)                                    
N#define USART_CR2_LINEN_Msk           (0x1UL << USART_CR2_LINEN_Pos)            /*!< 0x00004000 */
N#define USART_CR2_LINEN               USART_CR2_LINEN_Msk                      /*!<LIN mode enable */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define USART_CR3_EIE_Pos             (0U)                                     
N#define USART_CR3_EIE_Msk             (0x1UL << USART_CR3_EIE_Pos)              /*!< 0x00000001 */
N#define USART_CR3_EIE                 USART_CR3_EIE_Msk                        /*!<Error Interrupt Enable      */
N#define USART_CR3_IREN_Pos            (1U)                                     
N#define USART_CR3_IREN_Msk            (0x1UL << USART_CR3_IREN_Pos)             /*!< 0x00000002 */
N#define USART_CR3_IREN                USART_CR3_IREN_Msk                       /*!<IrDA mode Enable            */
N#define USART_CR3_IRLP_Pos            (2U)                                     
N#define USART_CR3_IRLP_Msk            (0x1UL << USART_CR3_IRLP_Pos)             /*!< 0x00000004 */
N#define USART_CR3_IRLP                USART_CR3_IRLP_Msk                       /*!<IrDA Low-Power              */
N#define USART_CR3_HDSEL_Pos           (3U)                                     
N#define USART_CR3_HDSEL_Msk           (0x1UL << USART_CR3_HDSEL_Pos)            /*!< 0x00000008 */
N#define USART_CR3_HDSEL               USART_CR3_HDSEL_Msk                      /*!<Half-Duplex Selection       */
N#define USART_CR3_NACK_Pos            (4U)                                     
N#define USART_CR3_NACK_Msk            (0x1UL << USART_CR3_NACK_Pos)             /*!< 0x00000010 */
N#define USART_CR3_NACK                USART_CR3_NACK_Msk                       /*!<Smartcard NACK enable       */
N#define USART_CR3_SCEN_Pos            (5U)                                     
N#define USART_CR3_SCEN_Msk            (0x1UL << USART_CR3_SCEN_Pos)             /*!< 0x00000020 */
N#define USART_CR3_SCEN                USART_CR3_SCEN_Msk                       /*!<Smartcard mode enable       */
N#define USART_CR3_DMAR_Pos            (6U)                                     
N#define USART_CR3_DMAR_Msk            (0x1UL << USART_CR3_DMAR_Pos)             /*!< 0x00000040 */
N#define USART_CR3_DMAR                USART_CR3_DMAR_Msk                       /*!<DMA Enable Receiver         */
N#define USART_CR3_DMAT_Pos            (7U)                                     
N#define USART_CR3_DMAT_Msk            (0x1UL << USART_CR3_DMAT_Pos)             /*!< 0x00000080 */
N#define USART_CR3_DMAT                USART_CR3_DMAT_Msk                       /*!<DMA Enable Transmitter      */
N#define USART_CR3_RTSE_Pos            (8U)                                     
N#define USART_CR3_RTSE_Msk            (0x1UL << USART_CR3_RTSE_Pos)             /*!< 0x00000100 */
N#define USART_CR3_RTSE                USART_CR3_RTSE_Msk                       /*!<RTS Enable                  */
N#define USART_CR3_CTSE_Pos            (9U)                                     
N#define USART_CR3_CTSE_Msk            (0x1UL << USART_CR3_CTSE_Pos)             /*!< 0x00000200 */
N#define USART_CR3_CTSE                USART_CR3_CTSE_Msk                       /*!<CTS Enable                  */
N#define USART_CR3_CTSIE_Pos           (10U)                                    
N#define USART_CR3_CTSIE_Msk           (0x1UL << USART_CR3_CTSIE_Pos)            /*!< 0x00000400 */
N#define USART_CR3_CTSIE               USART_CR3_CTSIE_Msk                      /*!<CTS Interrupt Enable        */
N#define USART_CR3_ONEBIT_Pos          (11U)                                    
N#define USART_CR3_ONEBIT_Msk          (0x1UL << USART_CR3_ONEBIT_Pos)           /*!< 0x00000800 */
N#define USART_CR3_ONEBIT              USART_CR3_ONEBIT_Msk                     /*!<USART One bit method enable */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define USART_GTPR_PSC_Pos            (0U)                                     
N#define USART_GTPR_PSC_Msk            (0xFFUL << USART_GTPR_PSC_Pos)            /*!< 0x000000FF */
N#define USART_GTPR_PSC                USART_GTPR_PSC_Msk                       /*!<PSC[7:0] bits (Prescaler value) */
N#define USART_GTPR_PSC_0              (0x01UL << USART_GTPR_PSC_Pos)            /*!< 0x0001 */
N#define USART_GTPR_PSC_1              (0x02UL << USART_GTPR_PSC_Pos)            /*!< 0x0002 */
N#define USART_GTPR_PSC_2              (0x04UL << USART_GTPR_PSC_Pos)            /*!< 0x0004 */
N#define USART_GTPR_PSC_3              (0x08UL << USART_GTPR_PSC_Pos)            /*!< 0x0008 */
N#define USART_GTPR_PSC_4              (0x10UL << USART_GTPR_PSC_Pos)            /*!< 0x0010 */
N#define USART_GTPR_PSC_5              (0x20UL << USART_GTPR_PSC_Pos)            /*!< 0x0020 */
N#define USART_GTPR_PSC_6              (0x40UL << USART_GTPR_PSC_Pos)            /*!< 0x0040 */
N#define USART_GTPR_PSC_7              (0x80UL << USART_GTPR_PSC_Pos)            /*!< 0x0080 */
N
N#define USART_GTPR_GT_Pos             (8U)                                     
N#define USART_GTPR_GT_Msk             (0xFFUL << USART_GTPR_GT_Pos)             /*!< 0x0000FF00 */
N#define USART_GTPR_GT                 USART_GTPR_GT_Msk                        /*!<Guard time value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            Window WATCHDOG                                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define WWDG_CR_T_Pos           (0U)                                           
N#define WWDG_CR_T_Msk           (0x7FUL << WWDG_CR_T_Pos)                       /*!< 0x0000007F */
N#define WWDG_CR_T               WWDG_CR_T_Msk                                  /*!<T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define WWDG_CR_T_0             (0x01UL << WWDG_CR_T_Pos)                       /*!< 0x01 */
N#define WWDG_CR_T_1             (0x02UL << WWDG_CR_T_Pos)                       /*!< 0x02 */
N#define WWDG_CR_T_2             (0x04UL << WWDG_CR_T_Pos)                       /*!< 0x04 */
N#define WWDG_CR_T_3             (0x08UL << WWDG_CR_T_Pos)                       /*!< 0x08 */
N#define WWDG_CR_T_4             (0x10UL << WWDG_CR_T_Pos)                       /*!< 0x10 */
N#define WWDG_CR_T_5             (0x20UL << WWDG_CR_T_Pos)                       /*!< 0x20 */
N#define WWDG_CR_T_6             (0x40UL << WWDG_CR_T_Pos)                       /*!< 0x40 */
N/* Legacy defines */
N#define  WWDG_CR_T0                          WWDG_CR_T_0
N#define  WWDG_CR_T1                          WWDG_CR_T_1
N#define  WWDG_CR_T2                          WWDG_CR_T_2
N#define  WWDG_CR_T3                          WWDG_CR_T_3
N#define  WWDG_CR_T4                          WWDG_CR_T_4
N#define  WWDG_CR_T5                          WWDG_CR_T_5
N#define  WWDG_CR_T6                          WWDG_CR_T_6
N
N#define WWDG_CR_WDGA_Pos        (7U)                                           
N#define WWDG_CR_WDGA_Msk        (0x1UL << WWDG_CR_WDGA_Pos)                     /*!< 0x00000080 */
N#define WWDG_CR_WDGA            WWDG_CR_WDGA_Msk                               /*!<Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define WWDG_CFR_W_Pos          (0U)                                           
N#define WWDG_CFR_W_Msk          (0x7FUL << WWDG_CFR_W_Pos)                      /*!< 0x0000007F */
N#define WWDG_CFR_W              WWDG_CFR_W_Msk                                 /*!<W[6:0] bits (7-bit window value) */
N#define WWDG_CFR_W_0            (0x01UL << WWDG_CFR_W_Pos)                      /*!< 0x0001 */
N#define WWDG_CFR_W_1            (0x02UL << WWDG_CFR_W_Pos)                      /*!< 0x0002 */
N#define WWDG_CFR_W_2            (0x04UL << WWDG_CFR_W_Pos)                      /*!< 0x0004 */
N#define WWDG_CFR_W_3            (0x08UL << WWDG_CFR_W_Pos)                      /*!< 0x0008 */
N#define WWDG_CFR_W_4            (0x10UL << WWDG_CFR_W_Pos)                      /*!< 0x0010 */
N#define WWDG_CFR_W_5            (0x20UL << WWDG_CFR_W_Pos)                      /*!< 0x0020 */
N#define WWDG_CFR_W_6            (0x40UL << WWDG_CFR_W_Pos)                      /*!< 0x0040 */
N/* Legacy defines */
N#define  WWDG_CFR_W0                         WWDG_CFR_W_0
N#define  WWDG_CFR_W1                         WWDG_CFR_W_1
N#define  WWDG_CFR_W2                         WWDG_CFR_W_2
N#define  WWDG_CFR_W3                         WWDG_CFR_W_3
N#define  WWDG_CFR_W4                         WWDG_CFR_W_4
N#define  WWDG_CFR_W5                         WWDG_CFR_W_5
N#define  WWDG_CFR_W6                         WWDG_CFR_W_6
N
N#define WWDG_CFR_WDGTB_Pos      (7U)                                           
N#define WWDG_CFR_WDGTB_Msk      (0x3UL << WWDG_CFR_WDGTB_Pos)                   /*!< 0x00000180 */
N#define WWDG_CFR_WDGTB          WWDG_CFR_WDGTB_Msk                             /*!<WDGTB[1:0] bits (Timer Base) */
N#define WWDG_CFR_WDGTB_0        (0x1UL << WWDG_CFR_WDGTB_Pos)                   /*!< 0x0080 */
N#define WWDG_CFR_WDGTB_1        (0x2UL << WWDG_CFR_WDGTB_Pos)                   /*!< 0x0100 */
N/* Legacy defines */
N#define  WWDG_CFR_WDGTB0                     WWDG_CFR_WDGTB_0
N#define  WWDG_CFR_WDGTB1                     WWDG_CFR_WDGTB_1
N
N#define WWDG_CFR_EWI_Pos        (9U)                                           
N#define WWDG_CFR_EWI_Msk        (0x1UL << WWDG_CFR_EWI_Pos)                     /*!< 0x00000200 */
N#define WWDG_CFR_EWI            WWDG_CFR_EWI_Msk                               /*!<Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define WWDG_SR_EWIF_Pos        (0U)                                           
N#define WWDG_SR_EWIF_Msk        (0x1UL << WWDG_SR_EWIF_Pos)                     /*!< 0x00000001 */
N#define WWDG_SR_EWIF            WWDG_SR_EWIF_Msk                               /*!<Early Wakeup Interrupt Flag */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                                DBG                                         */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DBGMCU_IDCODE register  *************/
N#define DBGMCU_IDCODE_DEV_ID_Pos                     (0U)                      
N#define DBGMCU_IDCODE_DEV_ID_Msk                     (0xFFFUL << DBGMCU_IDCODE_DEV_ID_Pos) /*!< 0x00000FFF */
N#define DBGMCU_IDCODE_DEV_ID                         DBGMCU_IDCODE_DEV_ID_Msk  
N#define DBGMCU_IDCODE_REV_ID_Pos                     (16U)                     
N#define DBGMCU_IDCODE_REV_ID_Msk                     (0xFFFFUL << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0xFFFF0000 */
N#define DBGMCU_IDCODE_REV_ID                         DBGMCU_IDCODE_REV_ID_Msk  
N
N/********************  Bit definition for DBGMCU_CR register  *****************/
N#define DBGMCU_CR_DBG_SLEEP_Pos                      (0U)                      
N#define DBGMCU_CR_DBG_SLEEP_Msk                      (0x1UL << DBGMCU_CR_DBG_SLEEP_Pos) /*!< 0x00000001 */
N#define DBGMCU_CR_DBG_SLEEP                          DBGMCU_CR_DBG_SLEEP_Msk   
N#define DBGMCU_CR_DBG_STOP_Pos                       (1U)                      
N#define DBGMCU_CR_DBG_STOP_Msk                       (0x1UL << DBGMCU_CR_DBG_STOP_Pos) /*!< 0x00000002 */
N#define DBGMCU_CR_DBG_STOP                           DBGMCU_CR_DBG_STOP_Msk    
N#define DBGMCU_CR_DBG_STANDBY_Pos                    (2U)                      
N#define DBGMCU_CR_DBG_STANDBY_Msk                    (0x1UL << DBGMCU_CR_DBG_STANDBY_Pos) /*!< 0x00000004 */
N#define DBGMCU_CR_DBG_STANDBY                        DBGMCU_CR_DBG_STANDBY_Msk 
N#define DBGMCU_CR_TRACE_IOEN_Pos                     (5U)                      
N#define DBGMCU_CR_TRACE_IOEN_Msk                     (0x1UL << DBGMCU_CR_TRACE_IOEN_Pos) /*!< 0x00000020 */
N#define DBGMCU_CR_TRACE_IOEN                         DBGMCU_CR_TRACE_IOEN_Msk  
N
N#define DBGMCU_CR_TRACE_MODE_Pos                     (6U)                      
N#define DBGMCU_CR_TRACE_MODE_Msk                     (0x3UL << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x000000C0 */
N#define DBGMCU_CR_TRACE_MODE                         DBGMCU_CR_TRACE_MODE_Msk  
N#define DBGMCU_CR_TRACE_MODE_0                       (0x1UL << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x00000040 */
N#define DBGMCU_CR_TRACE_MODE_1                       (0x2UL << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x00000080 */
N
N/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP_Pos             (0U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM2_STOP_Pos) /*!< 0x00000001 */
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP                 DBGMCU_APB1_FZ_DBG_TIM2_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP_Pos             (1U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM3_STOP_Pos) /*!< 0x00000002 */
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP                 DBGMCU_APB1_FZ_DBG_TIM3_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM4_STOP_Pos             (2U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM4_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM4_STOP_Pos) /*!< 0x00000004 */
N#define DBGMCU_APB1_FZ_DBG_TIM4_STOP                 DBGMCU_APB1_FZ_DBG_TIM4_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM5_STOP_Pos             (3U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM5_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM5_STOP_Pos) /*!< 0x00000008 */
N#define DBGMCU_APB1_FZ_DBG_TIM5_STOP                 DBGMCU_APB1_FZ_DBG_TIM5_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM6_STOP_Pos             (4U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM6_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM6_STOP_Pos) /*!< 0x00000010 */
N#define DBGMCU_APB1_FZ_DBG_TIM6_STOP                 DBGMCU_APB1_FZ_DBG_TIM6_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM7_STOP_Pos             (5U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM7_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM7_STOP_Pos) /*!< 0x00000020 */
N#define DBGMCU_APB1_FZ_DBG_TIM7_STOP                 DBGMCU_APB1_FZ_DBG_TIM7_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM12_STOP_Pos            (6U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM12_STOP_Msk            (0x1UL << DBGMCU_APB1_FZ_DBG_TIM12_STOP_Pos) /*!< 0x00000040 */
N#define DBGMCU_APB1_FZ_DBG_TIM12_STOP                DBGMCU_APB1_FZ_DBG_TIM12_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM13_STOP_Pos            (7U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM13_STOP_Msk            (0x1UL << DBGMCU_APB1_FZ_DBG_TIM13_STOP_Pos) /*!< 0x00000080 */
N#define DBGMCU_APB1_FZ_DBG_TIM13_STOP                DBGMCU_APB1_FZ_DBG_TIM13_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM14_STOP_Pos            (8U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM14_STOP_Msk            (0x1UL << DBGMCU_APB1_FZ_DBG_TIM14_STOP_Pos) /*!< 0x00000100 */
N#define DBGMCU_APB1_FZ_DBG_TIM14_STOP                DBGMCU_APB1_FZ_DBG_TIM14_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP_Pos              (10U)                     
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP_Msk              (0x1UL << DBGMCU_APB1_FZ_DBG_RTC_STOP_Pos) /*!< 0x00000400 */
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP                  DBGMCU_APB1_FZ_DBG_RTC_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP_Pos             (11U)                     
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_WWDG_STOP_Pos) /*!< 0x00000800 */
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP                 DBGMCU_APB1_FZ_DBG_WWDG_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP_Pos             (12U)                     
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_IWDG_STOP_Pos) /*!< 0x00001000 */
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP                 DBGMCU_APB1_FZ_DBG_IWDG_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Pos    (21U)                     
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Msk    (0x1UL << DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Pos) /*!< 0x00200000 */
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT        DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Msk 
N#define DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Pos    (22U)                     
N#define DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Msk    (0x1UL << DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Pos) /*!< 0x00400000 */
N#define DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT        DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Msk 
N#define DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Pos    (23U)                     
N#define DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Msk    (0x1UL << DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Pos) /*!< 0x00800000 */
N#define DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT        DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Msk 
N#define DBGMCU_APB1_FZ_DBG_CAN1_STOP_Pos             (25U)                     
N#define DBGMCU_APB1_FZ_DBG_CAN1_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_CAN1_STOP_Pos) /*!< 0x02000000 */
N#define DBGMCU_APB1_FZ_DBG_CAN1_STOP                 DBGMCU_APB1_FZ_DBG_CAN1_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_CAN2_STOP_Pos             (26U)                     
N#define DBGMCU_APB1_FZ_DBG_CAN2_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_CAN2_STOP_Pos) /*!< 0x04000000 */
N#define DBGMCU_APB1_FZ_DBG_CAN2_STOP                 DBGMCU_APB1_FZ_DBG_CAN2_STOP_Msk 
N/* Old IWDGSTOP bit definition, maintained for legacy purpose */
N#define  DBGMCU_APB1_FZ_DBG_IWDEG_STOP           DBGMCU_APB1_FZ_DBG_IWDG_STOP
N
N/********************  Bit definition for DBGMCU_APB2_FZ register  ************/
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP_Pos             (0U)                      
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP_Msk             (0x1UL << DBGMCU_APB2_FZ_DBG_TIM1_STOP_Pos) /*!< 0x00000001 */
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP                 DBGMCU_APB2_FZ_DBG_TIM1_STOP_Msk 
N#define DBGMCU_APB2_FZ_DBG_TIM8_STOP_Pos             (1U)                      
N#define DBGMCU_APB2_FZ_DBG_TIM8_STOP_Msk             (0x1UL << DBGMCU_APB2_FZ_DBG_TIM8_STOP_Pos) /*!< 0x00000002 */
N#define DBGMCU_APB2_FZ_DBG_TIM8_STOP                 DBGMCU_APB2_FZ_DBG_TIM8_STOP_Msk 
N#define DBGMCU_APB2_FZ_DBG_TIM9_STOP_Pos             (16U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM9_STOP_Msk             (0x1UL << DBGMCU_APB2_FZ_DBG_TIM9_STOP_Pos) /*!< 0x00010000 */
N#define DBGMCU_APB2_FZ_DBG_TIM9_STOP                 DBGMCU_APB2_FZ_DBG_TIM9_STOP_Msk 
N#define DBGMCU_APB2_FZ_DBG_TIM10_STOP_Pos            (17U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM10_STOP_Msk            (0x1UL << DBGMCU_APB2_FZ_DBG_TIM10_STOP_Pos) /*!< 0x00020000 */
N#define DBGMCU_APB2_FZ_DBG_TIM10_STOP                DBGMCU_APB2_FZ_DBG_TIM10_STOP_Msk 
N#define DBGMCU_APB2_FZ_DBG_TIM11_STOP_Pos            (18U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM11_STOP_Msk            (0x1UL << DBGMCU_APB2_FZ_DBG_TIM11_STOP_Pos) /*!< 0x00040000 */
N#define DBGMCU_APB2_FZ_DBG_TIM11_STOP                DBGMCU_APB2_FZ_DBG_TIM11_STOP_Msk 
N
N/******************************************************************************/
N/*                                                                            */
N/*                Ethernet MAC Registers bits definitions                     */
N/*                                                                            */
N/******************************************************************************/
N/* Bit definition for Ethernet MAC Control Register register */
N#define ETH_MACCR_WD_Pos                              (23U)                    
N#define ETH_MACCR_WD_Msk                              (0x1UL << ETH_MACCR_WD_Pos) /*!< 0x00800000 */
N#define ETH_MACCR_WD                                  ETH_MACCR_WD_Msk         /* Watchdog disable */
N#define ETH_MACCR_JD_Pos                              (22U)                    
N#define ETH_MACCR_JD_Msk                              (0x1UL << ETH_MACCR_JD_Pos) /*!< 0x00400000 */
N#define ETH_MACCR_JD                                  ETH_MACCR_JD_Msk         /* Jabber disable */
N#define ETH_MACCR_IFG_Pos                             (17U)                    
N#define ETH_MACCR_IFG_Msk                             (0x7UL << ETH_MACCR_IFG_Pos) /*!< 0x000E0000 */
N#define ETH_MACCR_IFG                                 ETH_MACCR_IFG_Msk        /* Inter-frame gap */
N#define ETH_MACCR_IFG_96Bit                           0x00000000U              /* Minimum IFG between frames during transmission is 96Bit */
N#define ETH_MACCR_IFG_88Bit                           0x00020000U              /* Minimum IFG between frames during transmission is 88Bit */
N#define ETH_MACCR_IFG_80Bit                           0x00040000U              /* Minimum IFG between frames during transmission is 80Bit */
N#define ETH_MACCR_IFG_72Bit                           0x00060000U              /* Minimum IFG between frames during transmission is 72Bit */
N#define ETH_MACCR_IFG_64Bit                           0x00080000U              /* Minimum IFG between frames during transmission is 64Bit */
N#define ETH_MACCR_IFG_56Bit                           0x000A0000U              /* Minimum IFG between frames during transmission is 56Bit */
N#define ETH_MACCR_IFG_48Bit                           0x000C0000U              /* Minimum IFG between frames during transmission is 48Bit */
N#define ETH_MACCR_IFG_40Bit                           0x000E0000U              /* Minimum IFG between frames during transmission is 40Bit */
N#define ETH_MACCR_CSD_Pos                             (16U)                    
N#define ETH_MACCR_CSD_Msk                             (0x1UL << ETH_MACCR_CSD_Pos) /*!< 0x00010000 */
N#define ETH_MACCR_CSD                                 ETH_MACCR_CSD_Msk        /* Carrier sense disable (during transmission) */
N#define ETH_MACCR_FES_Pos                             (14U)                    
N#define ETH_MACCR_FES_Msk                             (0x1UL << ETH_MACCR_FES_Pos) /*!< 0x00004000 */
N#define ETH_MACCR_FES                                 ETH_MACCR_FES_Msk        /* Fast ethernet speed */
N#define ETH_MACCR_ROD_Pos                             (13U)                    
N#define ETH_MACCR_ROD_Msk                             (0x1UL << ETH_MACCR_ROD_Pos) /*!< 0x00002000 */
N#define ETH_MACCR_ROD                                 ETH_MACCR_ROD_Msk        /* Receive own disable */
N#define ETH_MACCR_LM_Pos                              (12U)                    
N#define ETH_MACCR_LM_Msk                              (0x1UL << ETH_MACCR_LM_Pos) /*!< 0x00001000 */
N#define ETH_MACCR_LM                                  ETH_MACCR_LM_Msk         /* loopback mode */
N#define ETH_MACCR_DM_Pos                              (11U)                    
N#define ETH_MACCR_DM_Msk                              (0x1UL << ETH_MACCR_DM_Pos) /*!< 0x00000800 */
N#define ETH_MACCR_DM                                  ETH_MACCR_DM_Msk         /* Duplex mode */
N#define ETH_MACCR_IPCO_Pos                            (10U)                    
N#define ETH_MACCR_IPCO_Msk                            (0x1UL << ETH_MACCR_IPCO_Pos) /*!< 0x00000400 */
N#define ETH_MACCR_IPCO                                ETH_MACCR_IPCO_Msk       /* IP Checksum offload */
N#define ETH_MACCR_RD_Pos                              (9U)                     
N#define ETH_MACCR_RD_Msk                              (0x1UL << ETH_MACCR_RD_Pos) /*!< 0x00000200 */
N#define ETH_MACCR_RD                                  ETH_MACCR_RD_Msk         /* Retry disable */
N#define ETH_MACCR_APCS_Pos                            (7U)                     
N#define ETH_MACCR_APCS_Msk                            (0x1UL << ETH_MACCR_APCS_Pos) /*!< 0x00000080 */
N#define ETH_MACCR_APCS                                ETH_MACCR_APCS_Msk       /* Automatic Pad/CRC stripping */
N#define ETH_MACCR_BL_Pos                              (5U)                     
N#define ETH_MACCR_BL_Msk                              (0x3UL << ETH_MACCR_BL_Pos) /*!< 0x00000060 */
N#define ETH_MACCR_BL                                  ETH_MACCR_BL_Msk         /* Back-off limit: random integer number (r) of slot time delays before rescheduling
N                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */
N#define ETH_MACCR_BL_10                               0x00000000U              /* k = min (n, 10) */
N#define ETH_MACCR_BL_8                                0x00000020U              /* k = min (n, 8) */
N#define ETH_MACCR_BL_4                                0x00000040U              /* k = min (n, 4) */
N#define ETH_MACCR_BL_1                                0x00000060U              /* k = min (n, 1) */ 
N#define ETH_MACCR_DC_Pos                              (4U)                     
N#define ETH_MACCR_DC_Msk                              (0x1UL << ETH_MACCR_DC_Pos) /*!< 0x00000010 */
N#define ETH_MACCR_DC                                  ETH_MACCR_DC_Msk         /* Defferal check */
N#define ETH_MACCR_TE_Pos                              (3U)                     
N#define ETH_MACCR_TE_Msk                              (0x1UL << ETH_MACCR_TE_Pos) /*!< 0x00000008 */
N#define ETH_MACCR_TE                                  ETH_MACCR_TE_Msk         /* Transmitter enable */
N#define ETH_MACCR_RE_Pos                              (2U)                     
N#define ETH_MACCR_RE_Msk                              (0x1UL << ETH_MACCR_RE_Pos) /*!< 0x00000004 */
N#define ETH_MACCR_RE                                  ETH_MACCR_RE_Msk         /* Receiver enable */
N
N/* Bit definition for Ethernet MAC Frame Filter Register */
N#define ETH_MACFFR_RA_Pos                             (31U)                    
N#define ETH_MACFFR_RA_Msk                             (0x1UL << ETH_MACFFR_RA_Pos) /*!< 0x80000000 */
N#define ETH_MACFFR_RA                                 ETH_MACFFR_RA_Msk        /* Receive all */
N#define ETH_MACFFR_HPF_Pos                            (10U)                    
N#define ETH_MACFFR_HPF_Msk                            (0x1UL << ETH_MACFFR_HPF_Pos) /*!< 0x00000400 */
N#define ETH_MACFFR_HPF                                ETH_MACFFR_HPF_Msk       /* Hash or perfect filter */
N#define ETH_MACFFR_SAF_Pos                            (9U)                     
N#define ETH_MACFFR_SAF_Msk                            (0x1UL << ETH_MACFFR_SAF_Pos) /*!< 0x00000200 */
N#define ETH_MACFFR_SAF                                ETH_MACFFR_SAF_Msk       /* Source address filter enable */
N#define ETH_MACFFR_SAIF_Pos                           (8U)                     
N#define ETH_MACFFR_SAIF_Msk                           (0x1UL << ETH_MACFFR_SAIF_Pos) /*!< 0x00000100 */
N#define ETH_MACFFR_SAIF                               ETH_MACFFR_SAIF_Msk      /* SA inverse filtering */ 
N#define ETH_MACFFR_PCF_Pos                            (6U)                     
N#define ETH_MACFFR_PCF_Msk                            (0x3UL << ETH_MACFFR_PCF_Pos) /*!< 0x000000C0 */
N#define ETH_MACFFR_PCF                                ETH_MACFFR_PCF_Msk       /* Pass control frames: 3 cases */
N#define ETH_MACFFR_PCF_BlockAll_Pos                   (6U)                     
N#define ETH_MACFFR_PCF_BlockAll_Msk                   (0x1UL << ETH_MACFFR_PCF_BlockAll_Pos) /*!< 0x00000040 */
N#define ETH_MACFFR_PCF_BlockAll                       ETH_MACFFR_PCF_BlockAll_Msk /* MAC filters all control frames from reaching the application */
N#define ETH_MACFFR_PCF_ForwardAll_Pos                 (7U)                     
N#define ETH_MACFFR_PCF_ForwardAll_Msk                 (0x1UL << ETH_MACFFR_PCF_ForwardAll_Pos) /*!< 0x00000080 */
N#define ETH_MACFFR_PCF_ForwardAll                     ETH_MACFFR_PCF_ForwardAll_Msk /* MAC forwards all control frames to application even if they fail the Address Filter */
N#define ETH_MACFFR_PCF_ForwardPassedAddrFilter_Pos    (6U)                     
N#define ETH_MACFFR_PCF_ForwardPassedAddrFilter_Msk    (0x3UL << ETH_MACFFR_PCF_ForwardPassedAddrFilter_Pos) /*!< 0x000000C0 */
N#define ETH_MACFFR_PCF_ForwardPassedAddrFilter        ETH_MACFFR_PCF_ForwardPassedAddrFilter_Msk /* MAC forwards control frames that pass the Address Filter. */ 
N#define ETH_MACFFR_BFD_Pos                            (5U)                     
N#define ETH_MACFFR_BFD_Msk                            (0x1UL << ETH_MACFFR_BFD_Pos) /*!< 0x00000020 */
N#define ETH_MACFFR_BFD                                ETH_MACFFR_BFD_Msk       /* Broadcast frame disable */ 
N#define ETH_MACFFR_PAM_Pos                            (4U)                     
N#define ETH_MACFFR_PAM_Msk                            (0x1UL << ETH_MACFFR_PAM_Pos) /*!< 0x00000010 */
N#define ETH_MACFFR_PAM                                ETH_MACFFR_PAM_Msk       /* Pass all mutlicast */
N#define ETH_MACFFR_DAIF_Pos                           (3U)                     
N#define ETH_MACFFR_DAIF_Msk                           (0x1UL << ETH_MACFFR_DAIF_Pos) /*!< 0x00000008 */
N#define ETH_MACFFR_DAIF                               ETH_MACFFR_DAIF_Msk      /* DA Inverse filtering */
N#define ETH_MACFFR_HM_Pos                             (2U)                     
N#define ETH_MACFFR_HM_Msk                             (0x1UL << ETH_MACFFR_HM_Pos) /*!< 0x00000004 */
N#define ETH_MACFFR_HM                                 ETH_MACFFR_HM_Msk        /* Hash multicast */ 
N#define ETH_MACFFR_HU_Pos                             (1U)                     
N#define ETH_MACFFR_HU_Msk                             (0x1UL << ETH_MACFFR_HU_Pos) /*!< 0x00000002 */
N#define ETH_MACFFR_HU                                 ETH_MACFFR_HU_Msk        /* Hash unicast */
N#define ETH_MACFFR_PM_Pos                             (0U)                     
N#define ETH_MACFFR_PM_Msk                             (0x1UL << ETH_MACFFR_PM_Pos) /*!< 0x00000001 */
N#define ETH_MACFFR_PM                                 ETH_MACFFR_PM_Msk        /* Promiscuous mode */
N
N/* Bit definition for Ethernet MAC Hash Table High Register */
N#define ETH_MACHTHR_HTH_Pos                           (0U)                     
N#define ETH_MACHTHR_HTH_Msk                           (0xFFFFFFFFUL << ETH_MACHTHR_HTH_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MACHTHR_HTH                               ETH_MACHTHR_HTH_Msk      /* Hash table high */
N
N/* Bit definition for Ethernet MAC Hash Table Low Register */
N#define ETH_MACHTLR_HTL_Pos                           (0U)                     
N#define ETH_MACHTLR_HTL_Msk                           (0xFFFFFFFFUL << ETH_MACHTLR_HTL_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MACHTLR_HTL                               ETH_MACHTLR_HTL_Msk      /* Hash table low */
N
N/* Bit definition for Ethernet MAC MII Address Register */
N#define ETH_MACMIIAR_PA_Pos                           (11U)                    
N#define ETH_MACMIIAR_PA_Msk                           (0x1FUL << ETH_MACMIIAR_PA_Pos) /*!< 0x0000F800 */
N#define ETH_MACMIIAR_PA                               ETH_MACMIIAR_PA_Msk      /* Physical layer address */
N#define ETH_MACMIIAR_MR_Pos                           (6U)                     
N#define ETH_MACMIIAR_MR_Msk                           (0x1FUL << ETH_MACMIIAR_MR_Pos) /*!< 0x000007C0 */
N#define ETH_MACMIIAR_MR                               ETH_MACMIIAR_MR_Msk      /* MII register in the selected PHY */
N#define ETH_MACMIIAR_CR_Pos                           (2U)                     
N#define ETH_MACMIIAR_CR_Msk                           (0x7UL << ETH_MACMIIAR_CR_Pos) /*!< 0x0000001C */
N#define ETH_MACMIIAR_CR                               ETH_MACMIIAR_CR_Msk      /* CR clock range: 6 cases */
N#define ETH_MACMIIAR_CR_Div42                         0x00000000U              /* HCLK:60-100 MHz; MDC clock= HCLK/42   */
N#define ETH_MACMIIAR_CR_Div62_Pos                     (2U)                     
N#define ETH_MACMIIAR_CR_Div62_Msk                     (0x1UL << ETH_MACMIIAR_CR_Div62_Pos) /*!< 0x00000004 */
N#define ETH_MACMIIAR_CR_Div62                         ETH_MACMIIAR_CR_Div62_Msk /* HCLK:100-150 MHz; MDC clock= HCLK/62  */
N#define ETH_MACMIIAR_CR_Div16_Pos                     (3U)                     
N#define ETH_MACMIIAR_CR_Div16_Msk                     (0x1UL << ETH_MACMIIAR_CR_Div16_Pos) /*!< 0x00000008 */
N#define ETH_MACMIIAR_CR_Div16                         ETH_MACMIIAR_CR_Div16_Msk /* HCLK:20-35 MHz; MDC clock= HCLK/16    */
N#define ETH_MACMIIAR_CR_Div26_Pos                     (2U)                     
N#define ETH_MACMIIAR_CR_Div26_Msk                     (0x3UL << ETH_MACMIIAR_CR_Div26_Pos) /*!< 0x0000000C */
N#define ETH_MACMIIAR_CR_Div26                         ETH_MACMIIAR_CR_Div26_Msk /* HCLK:35-60 MHz; MDC clock= HCLK/26    */
N#define ETH_MACMIIAR_CR_Div102_Pos                    (4U)                     
N#define ETH_MACMIIAR_CR_Div102_Msk                    (0x1UL << ETH_MACMIIAR_CR_Div102_Pos) /*!< 0x00000010 */
N#define ETH_MACMIIAR_CR_Div102                        ETH_MACMIIAR_CR_Div102_Msk /* HCLK:150-168 MHz; MDC clock= HCLK/102 */
N#define ETH_MACMIIAR_MW_Pos                           (1U)                     
N#define ETH_MACMIIAR_MW_Msk                           (0x1UL << ETH_MACMIIAR_MW_Pos) /*!< 0x00000002 */
N#define ETH_MACMIIAR_MW                               ETH_MACMIIAR_MW_Msk      /* MII write */
N#define ETH_MACMIIAR_MB_Pos                           (0U)                     
N#define ETH_MACMIIAR_MB_Msk                           (0x1UL << ETH_MACMIIAR_MB_Pos) /*!< 0x00000001 */
N#define ETH_MACMIIAR_MB                               ETH_MACMIIAR_MB_Msk      /* MII busy  */
N
N/* Bit definition for Ethernet MAC MII Data Register */
N#define ETH_MACMIIDR_MD_Pos                           (0U)                     
N#define ETH_MACMIIDR_MD_Msk                           (0xFFFFUL << ETH_MACMIIDR_MD_Pos) /*!< 0x0000FFFF */
N#define ETH_MACMIIDR_MD                               ETH_MACMIIDR_MD_Msk      /* MII data: read/write data from/to PHY */
N
N/* Bit definition for Ethernet MAC Flow Control Register */
N#define ETH_MACFCR_PT_Pos                             (16U)                    
N#define ETH_MACFCR_PT_Msk                             (0xFFFFUL << ETH_MACFCR_PT_Pos) /*!< 0xFFFF0000 */
N#define ETH_MACFCR_PT                                 ETH_MACFCR_PT_Msk        /* Pause time */
N#define ETH_MACFCR_ZQPD_Pos                           (7U)                     
N#define ETH_MACFCR_ZQPD_Msk                           (0x1UL << ETH_MACFCR_ZQPD_Pos) /*!< 0x00000080 */
N#define ETH_MACFCR_ZQPD                               ETH_MACFCR_ZQPD_Msk      /* Zero-quanta pause disable */
N#define ETH_MACFCR_PLT_Pos                            (4U)                     
N#define ETH_MACFCR_PLT_Msk                            (0x3UL << ETH_MACFCR_PLT_Pos) /*!< 0x00000030 */
N#define ETH_MACFCR_PLT                                ETH_MACFCR_PLT_Msk       /* Pause low threshold: 4 cases */
N#define ETH_MACFCR_PLT_Minus4                         0x00000000U              /* Pause time minus 4 slot times   */
N#define ETH_MACFCR_PLT_Minus28_Pos                    (4U)                     
N#define ETH_MACFCR_PLT_Minus28_Msk                    (0x1UL << ETH_MACFCR_PLT_Minus28_Pos) /*!< 0x00000010 */
N#define ETH_MACFCR_PLT_Minus28                        ETH_MACFCR_PLT_Minus28_Msk /* Pause time minus 28 slot times  */
N#define ETH_MACFCR_PLT_Minus144_Pos                   (5U)                     
N#define ETH_MACFCR_PLT_Minus144_Msk                   (0x1UL << ETH_MACFCR_PLT_Minus144_Pos) /*!< 0x00000020 */
N#define ETH_MACFCR_PLT_Minus144                       ETH_MACFCR_PLT_Minus144_Msk /* Pause time minus 144 slot times */
N#define ETH_MACFCR_PLT_Minus256_Pos                   (4U)                     
N#define ETH_MACFCR_PLT_Minus256_Msk                   (0x3UL << ETH_MACFCR_PLT_Minus256_Pos) /*!< 0x00000030 */
N#define ETH_MACFCR_PLT_Minus256                       ETH_MACFCR_PLT_Minus256_Msk /* Pause time minus 256 slot times */
N#define ETH_MACFCR_UPFD_Pos                           (3U)                     
N#define ETH_MACFCR_UPFD_Msk                           (0x1UL << ETH_MACFCR_UPFD_Pos) /*!< 0x00000008 */
N#define ETH_MACFCR_UPFD                               ETH_MACFCR_UPFD_Msk      /* Unicast pause frame detect */
N#define ETH_MACFCR_RFCE_Pos                           (2U)                     
N#define ETH_MACFCR_RFCE_Msk                           (0x1UL << ETH_MACFCR_RFCE_Pos) /*!< 0x00000004 */
N#define ETH_MACFCR_RFCE                               ETH_MACFCR_RFCE_Msk      /* Receive flow control enable */
N#define ETH_MACFCR_TFCE_Pos                           (1U)                     
N#define ETH_MACFCR_TFCE_Msk                           (0x1UL << ETH_MACFCR_TFCE_Pos) /*!< 0x00000002 */
N#define ETH_MACFCR_TFCE                               ETH_MACFCR_TFCE_Msk      /* Transmit flow control enable */
N#define ETH_MACFCR_FCBBPA_Pos                         (0U)                     
N#define ETH_MACFCR_FCBBPA_Msk                         (0x1UL << ETH_MACFCR_FCBBPA_Pos) /*!< 0x00000001 */
N#define ETH_MACFCR_FCBBPA                             ETH_MACFCR_FCBBPA_Msk    /* Flow control busy/backpressure activate */
N
N/* Bit definition for Ethernet MAC VLAN Tag Register */
N#define ETH_MACVLANTR_VLANTC_Pos                      (16U)                    
N#define ETH_MACVLANTR_VLANTC_Msk                      (0x1UL << ETH_MACVLANTR_VLANTC_Pos) /*!< 0x00010000 */
N#define ETH_MACVLANTR_VLANTC                          ETH_MACVLANTR_VLANTC_Msk /* 12-bit VLAN tag comparison */
N#define ETH_MACVLANTR_VLANTI_Pos                      (0U)                     
N#define ETH_MACVLANTR_VLANTI_Msk                      (0xFFFFUL << ETH_MACVLANTR_VLANTI_Pos) /*!< 0x0000FFFF */
N#define ETH_MACVLANTR_VLANTI                          ETH_MACVLANTR_VLANTI_Msk /* VLAN tag identifier (for receive frames) */
N
N/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */ 
N#define ETH_MACRWUFFR_D_Pos                           (0U)                     
N#define ETH_MACRWUFFR_D_Msk                           (0xFFFFFFFFUL << ETH_MACRWUFFR_D_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MACRWUFFR_D                               ETH_MACRWUFFR_D_Msk      /* Wake-up frame filter register data */
N/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.
N   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */
N/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask
N   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
N   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask
N   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask
N   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command - 
N                              RSVD - Filter1 Command - RSVD - Filter0 Command
N   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset
N   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16
N   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */
N
N/* Bit definition for Ethernet MAC PMT Control and Status Register */ 
N#define ETH_MACPMTCSR_WFFRPR_Pos                      (31U)                    
N#define ETH_MACPMTCSR_WFFRPR_Msk                      (0x1UL << ETH_MACPMTCSR_WFFRPR_Pos) /*!< 0x80000000 */
N#define ETH_MACPMTCSR_WFFRPR                          ETH_MACPMTCSR_WFFRPR_Msk /* Wake-Up Frame Filter Register Pointer Reset */
N#define ETH_MACPMTCSR_GU_Pos                          (9U)                     
N#define ETH_MACPMTCSR_GU_Msk                          (0x1UL << ETH_MACPMTCSR_GU_Pos) /*!< 0x00000200 */
N#define ETH_MACPMTCSR_GU                              ETH_MACPMTCSR_GU_Msk     /* Global Unicast                              */
N#define ETH_MACPMTCSR_WFR_Pos                         (6U)                     
N#define ETH_MACPMTCSR_WFR_Msk                         (0x1UL << ETH_MACPMTCSR_WFR_Pos) /*!< 0x00000040 */
N#define ETH_MACPMTCSR_WFR                             ETH_MACPMTCSR_WFR_Msk    /* Wake-Up Frame Received                      */
N#define ETH_MACPMTCSR_MPR_Pos                         (5U)                     
N#define ETH_MACPMTCSR_MPR_Msk                         (0x1UL << ETH_MACPMTCSR_MPR_Pos) /*!< 0x00000020 */
N#define ETH_MACPMTCSR_MPR                             ETH_MACPMTCSR_MPR_Msk    /* Magic Packet Received                       */
N#define ETH_MACPMTCSR_WFE_Pos                         (2U)                     
N#define ETH_MACPMTCSR_WFE_Msk                         (0x1UL << ETH_MACPMTCSR_WFE_Pos) /*!< 0x00000004 */
N#define ETH_MACPMTCSR_WFE                             ETH_MACPMTCSR_WFE_Msk    /* Wake-Up Frame Enable                        */
N#define ETH_MACPMTCSR_MPE_Pos                         (1U)                     
N#define ETH_MACPMTCSR_MPE_Msk                         (0x1UL << ETH_MACPMTCSR_MPE_Pos) /*!< 0x00000002 */
N#define ETH_MACPMTCSR_MPE                             ETH_MACPMTCSR_MPE_Msk    /* Magic Packet Enable                         */
N#define ETH_MACPMTCSR_PD_Pos                          (0U)                     
N#define ETH_MACPMTCSR_PD_Msk                          (0x1UL << ETH_MACPMTCSR_PD_Pos) /*!< 0x00000001 */
N#define ETH_MACPMTCSR_PD                              ETH_MACPMTCSR_PD_Msk     /* Power Down                                  */
N
N/* Bit definition for Ethernet MAC debug Register */
N#define ETH_MACDBGR_TFF_Pos                           (25U)                    
N#define ETH_MACDBGR_TFF_Msk                           (0x1UL << ETH_MACDBGR_TFF_Pos) /*!< 0x02000000 */
N#define ETH_MACDBGR_TFF                               ETH_MACDBGR_TFF_Msk      /* Tx FIFO full                                                            */
N#define ETH_MACDBGR_TFNE_Pos                          (24U)                    
N#define ETH_MACDBGR_TFNE_Msk                          (0x1UL << ETH_MACDBGR_TFNE_Pos) /*!< 0x01000000 */
N#define ETH_MACDBGR_TFNE                              ETH_MACDBGR_TFNE_Msk     /* Tx FIFO not empty                                                       */
N#define ETH_MACDBGR_TFWA_Pos                          (22U)                    
N#define ETH_MACDBGR_TFWA_Msk                          (0x1UL << ETH_MACDBGR_TFWA_Pos) /*!< 0x00400000 */
N#define ETH_MACDBGR_TFWA                              ETH_MACDBGR_TFWA_Msk     /* Tx FIFO write active                                                    */
N#define ETH_MACDBGR_TFRS_Pos                          (20U)                    
N#define ETH_MACDBGR_TFRS_Msk                          (0x3UL << ETH_MACDBGR_TFRS_Pos) /*!< 0x00300000 */
N#define ETH_MACDBGR_TFRS                              ETH_MACDBGR_TFRS_Msk     /* Tx FIFO read status mask                                                */
N#define ETH_MACDBGR_TFRS_WRITING_Pos                  (20U)                    
N#define ETH_MACDBGR_TFRS_WRITING_Msk                  (0x3UL << ETH_MACDBGR_TFRS_WRITING_Pos) /*!< 0x00300000 */
N#define ETH_MACDBGR_TFRS_WRITING                      ETH_MACDBGR_TFRS_WRITING_Msk /* Writing the received TxStatus or flushing the TxFIFO                    */
N#define ETH_MACDBGR_TFRS_WAITING_Pos                  (21U)                    
N#define ETH_MACDBGR_TFRS_WAITING_Msk                  (0x1UL << ETH_MACDBGR_TFRS_WAITING_Pos) /*!< 0x00200000 */
N#define ETH_MACDBGR_TFRS_WAITING                      ETH_MACDBGR_TFRS_WAITING_Msk /* Waiting for TxStatus from MAC transmitter                               */
N#define ETH_MACDBGR_TFRS_READ_Pos                     (20U)                    
N#define ETH_MACDBGR_TFRS_READ_Msk                     (0x1UL << ETH_MACDBGR_TFRS_READ_Pos) /*!< 0x00100000 */
N#define ETH_MACDBGR_TFRS_READ                         ETH_MACDBGR_TFRS_READ_Msk /* Read state (transferring data to the MAC transmitter)                   */
N#define ETH_MACDBGR_TFRS_IDLE                         0x00000000U              /* Idle state                                                              */
N#define ETH_MACDBGR_MTP_Pos                           (19U)                    
N#define ETH_MACDBGR_MTP_Msk                           (0x1UL << ETH_MACDBGR_MTP_Pos) /*!< 0x00080000 */
N#define ETH_MACDBGR_MTP                               ETH_MACDBGR_MTP_Msk      /* MAC transmitter in pause                                                */
N#define ETH_MACDBGR_MTFCS_Pos                         (17U)                    
N#define ETH_MACDBGR_MTFCS_Msk                         (0x3UL << ETH_MACDBGR_MTFCS_Pos) /*!< 0x00060000 */
N#define ETH_MACDBGR_MTFCS                             ETH_MACDBGR_MTFCS_Msk    /* MAC transmit frame controller status mask                               */
N#define ETH_MACDBGR_MTFCS_TRANSFERRING_Pos            (17U)                    
N#define ETH_MACDBGR_MTFCS_TRANSFERRING_Msk            (0x3UL << ETH_MACDBGR_MTFCS_TRANSFERRING_Pos) /*!< 0x00060000 */
N#define ETH_MACDBGR_MTFCS_TRANSFERRING                ETH_MACDBGR_MTFCS_TRANSFERRING_Msk /* Transferring input frame for transmission                               */
N#define ETH_MACDBGR_MTFCS_GENERATINGPCF_Pos           (18U)                    
N#define ETH_MACDBGR_MTFCS_GENERATINGPCF_Msk           (0x1UL << ETH_MACDBGR_MTFCS_GENERATINGPCF_Pos) /*!< 0x00040000 */
N#define ETH_MACDBGR_MTFCS_GENERATINGPCF               ETH_MACDBGR_MTFCS_GENERATINGPCF_Msk /* Generating and transmitting a Pause control frame (in full duplex mode) */
N#define ETH_MACDBGR_MTFCS_WAITING_Pos                 (17U)                    
N#define ETH_MACDBGR_MTFCS_WAITING_Msk                 (0x1UL << ETH_MACDBGR_MTFCS_WAITING_Pos) /*!< 0x00020000 */
N#define ETH_MACDBGR_MTFCS_WAITING                     ETH_MACDBGR_MTFCS_WAITING_Msk /* Waiting for Status of previous frame or IFG/backoff period to be over   */
N#define ETH_MACDBGR_MTFCS_IDLE                        0x00000000U              /* Idle                                                                    */
N#define ETH_MACDBGR_MMTEA_Pos                         (16U)                    
N#define ETH_MACDBGR_MMTEA_Msk                         (0x1UL << ETH_MACDBGR_MMTEA_Pos) /*!< 0x00010000 */
N#define ETH_MACDBGR_MMTEA                             ETH_MACDBGR_MMTEA_Msk    /* MAC MII transmit engine active                                          */
N#define ETH_MACDBGR_RFFL_Pos                          (8U)                     
N#define ETH_MACDBGR_RFFL_Msk                          (0x3UL << ETH_MACDBGR_RFFL_Pos) /*!< 0x00000300 */
N#define ETH_MACDBGR_RFFL                              ETH_MACDBGR_RFFL_Msk     /* Rx FIFO fill level mask                                                 */
N#define ETH_MACDBGR_RFFL_FULL_Pos                     (8U)                     
N#define ETH_MACDBGR_RFFL_FULL_Msk                     (0x3UL << ETH_MACDBGR_RFFL_FULL_Pos) /*!< 0x00000300 */
N#define ETH_MACDBGR_RFFL_FULL                         ETH_MACDBGR_RFFL_FULL_Msk /* RxFIFO full                                                             */
N#define ETH_MACDBGR_RFFL_ABOVEFCT_Pos                 (9U)                     
N#define ETH_MACDBGR_RFFL_ABOVEFCT_Msk                 (0x1UL << ETH_MACDBGR_RFFL_ABOVEFCT_Pos) /*!< 0x00000200 */
N#define ETH_MACDBGR_RFFL_ABOVEFCT                     ETH_MACDBGR_RFFL_ABOVEFCT_Msk /* RxFIFO fill-level above flow-control activate threshold                 */
N#define ETH_MACDBGR_RFFL_BELOWFCT_Pos                 (8U)                     
N#define ETH_MACDBGR_RFFL_BELOWFCT_Msk                 (0x1UL << ETH_MACDBGR_RFFL_BELOWFCT_Pos) /*!< 0x00000100 */
N#define ETH_MACDBGR_RFFL_BELOWFCT                     ETH_MACDBGR_RFFL_BELOWFCT_Msk /* RxFIFO fill-level below flow-control de-activate threshold              */
N#define ETH_MACDBGR_RFFL_EMPTY                        0x00000000U              /* RxFIFO empty                                                            */
N#define ETH_MACDBGR_RFRCS_Pos                         (5U)                     
N#define ETH_MACDBGR_RFRCS_Msk                         (0x3UL << ETH_MACDBGR_RFRCS_Pos) /*!< 0x00000060 */
N#define ETH_MACDBGR_RFRCS                             ETH_MACDBGR_RFRCS_Msk    /* Rx FIFO read controller status mask                                     */
N#define ETH_MACDBGR_RFRCS_FLUSHING_Pos                (5U)                     
N#define ETH_MACDBGR_RFRCS_FLUSHING_Msk                (0x3UL << ETH_MACDBGR_RFRCS_FLUSHING_Pos) /*!< 0x00000060 */
N#define ETH_MACDBGR_RFRCS_FLUSHING                    ETH_MACDBGR_RFRCS_FLUSHING_Msk /* Flushing the frame data and status                                      */
N#define ETH_MACDBGR_RFRCS_STATUSREADING_Pos           (6U)                     
N#define ETH_MACDBGR_RFRCS_STATUSREADING_Msk           (0x1UL << ETH_MACDBGR_RFRCS_STATUSREADING_Pos) /*!< 0x00000040 */
N#define ETH_MACDBGR_RFRCS_STATUSREADING               ETH_MACDBGR_RFRCS_STATUSREADING_Msk /* Reading frame status (or time-stamp)                                    */
N#define ETH_MACDBGR_RFRCS_DATAREADING_Pos             (5U)                     
N#define ETH_MACDBGR_RFRCS_DATAREADING_Msk             (0x1UL << ETH_MACDBGR_RFRCS_DATAREADING_Pos) /*!< 0x00000020 */
N#define ETH_MACDBGR_RFRCS_DATAREADING                 ETH_MACDBGR_RFRCS_DATAREADING_Msk /* Reading frame data                                                      */
N#define ETH_MACDBGR_RFRCS_IDLE                        0x00000000U              /* IDLE state                                                              */
N#define ETH_MACDBGR_RFWRA_Pos                         (4U)                     
N#define ETH_MACDBGR_RFWRA_Msk                         (0x1UL << ETH_MACDBGR_RFWRA_Pos) /*!< 0x00000010 */
N#define ETH_MACDBGR_RFWRA                             ETH_MACDBGR_RFWRA_Msk    /* Rx FIFO write controller active                                         */
N#define ETH_MACDBGR_MSFRWCS_Pos                       (1U)                     
N#define ETH_MACDBGR_MSFRWCS_Msk                       (0x3UL << ETH_MACDBGR_MSFRWCS_Pos) /*!< 0x00000006 */
N#define ETH_MACDBGR_MSFRWCS                           ETH_MACDBGR_MSFRWCS_Msk  /* MAC small FIFO read / write controllers status  mask                    */
N#define ETH_MACDBGR_MSFRWCS_1                         (0x2UL << ETH_MACDBGR_MSFRWCS_Pos) /*!< 0x00000004 */
N#define ETH_MACDBGR_MSFRWCS_0                         (0x1UL << ETH_MACDBGR_MSFRWCS_Pos) /*!< 0x00000002 */
N#define ETH_MACDBGR_MMRPEA_Pos                        (0U)                     
N#define ETH_MACDBGR_MMRPEA_Msk                        (0x1UL << ETH_MACDBGR_MMRPEA_Pos) /*!< 0x00000001 */
N#define ETH_MACDBGR_MMRPEA                            ETH_MACDBGR_MMRPEA_Msk   /* MAC MII receive protocol engine active                                  */
N
N/* Bit definition for Ethernet MAC Status Register */
N#define ETH_MACSR_TSTS_Pos                            (9U)                     
N#define ETH_MACSR_TSTS_Msk                            (0x1UL << ETH_MACSR_TSTS_Pos) /*!< 0x00000200 */
N#define ETH_MACSR_TSTS                                ETH_MACSR_TSTS_Msk       /* Time stamp trigger status */
N#define ETH_MACSR_MMCTS_Pos                           (6U)                     
N#define ETH_MACSR_MMCTS_Msk                           (0x1UL << ETH_MACSR_MMCTS_Pos) /*!< 0x00000040 */
N#define ETH_MACSR_MMCTS                               ETH_MACSR_MMCTS_Msk      /* MMC transmit status       */
N#define ETH_MACSR_MMMCRS_Pos                          (5U)                     
N#define ETH_MACSR_MMMCRS_Msk                          (0x1UL << ETH_MACSR_MMMCRS_Pos) /*!< 0x00000020 */
N#define ETH_MACSR_MMMCRS                              ETH_MACSR_MMMCRS_Msk     /* MMC receive status        */
N#define ETH_MACSR_MMCS_Pos                            (4U)                     
N#define ETH_MACSR_MMCS_Msk                            (0x1UL << ETH_MACSR_MMCS_Pos) /*!< 0x00000010 */
N#define ETH_MACSR_MMCS                                ETH_MACSR_MMCS_Msk       /* MMC status                */
N#define ETH_MACSR_PMTS_Pos                            (3U)                     
N#define ETH_MACSR_PMTS_Msk                            (0x1UL << ETH_MACSR_PMTS_Pos) /*!< 0x00000008 */
N#define ETH_MACSR_PMTS                                ETH_MACSR_PMTS_Msk       /* PMT status                */
N
N/* Bit definition for Ethernet MAC Interrupt Mask Register */
N#define ETH_MACIMR_TSTIM_Pos                          (9U)                     
N#define ETH_MACIMR_TSTIM_Msk                          (0x1UL << ETH_MACIMR_TSTIM_Pos) /*!< 0x00000200 */
N#define ETH_MACIMR_TSTIM                              ETH_MACIMR_TSTIM_Msk     /* Time stamp trigger interrupt mask */
N#define ETH_MACIMR_PMTIM_Pos                          (3U)                     
N#define ETH_MACIMR_PMTIM_Msk                          (0x1UL << ETH_MACIMR_PMTIM_Pos) /*!< 0x00000008 */
N#define ETH_MACIMR_PMTIM                              ETH_MACIMR_PMTIM_Msk     /* PMT interrupt mask                */
N
N/* Bit definition for Ethernet MAC Address0 High Register */
N#define ETH_MACA0HR_MACA0H_Pos                        (0U)                     
N#define ETH_MACA0HR_MACA0H_Msk                        (0xFFFFUL << ETH_MACA0HR_MACA0H_Pos) /*!< 0x0000FFFF */
N#define ETH_MACA0HR_MACA0H                            ETH_MACA0HR_MACA0H_Msk   /* MAC address0 high */
N
N/* Bit definition for Ethernet MAC Address0 Low Register */
N#define ETH_MACA0LR_MACA0L_Pos                        (0U)                     
N#define ETH_MACA0LR_MACA0L_Msk                        (0xFFFFFFFFUL << ETH_MACA0LR_MACA0L_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MACA0LR_MACA0L                            ETH_MACA0LR_MACA0L_Msk   /* MAC address0 low */
N
N/* Bit definition for Ethernet MAC Address1 High Register */
N#define ETH_MACA1HR_AE_Pos                            (31U)                    
N#define ETH_MACA1HR_AE_Msk                            (0x1UL << ETH_MACA1HR_AE_Pos) /*!< 0x80000000 */
N#define ETH_MACA1HR_AE                                ETH_MACA1HR_AE_Msk       /* Address enable */
N#define ETH_MACA1HR_SA_Pos                            (30U)                    
N#define ETH_MACA1HR_SA_Msk                            (0x1UL << ETH_MACA1HR_SA_Pos) /*!< 0x40000000 */
N#define ETH_MACA1HR_SA                                ETH_MACA1HR_SA_Msk       /* Source address */
N#define ETH_MACA1HR_MBC_Pos                           (24U)                    
N#define ETH_MACA1HR_MBC_Msk                           (0x3FUL << ETH_MACA1HR_MBC_Pos) /*!< 0x3F000000 */
N#define ETH_MACA1HR_MBC                               ETH_MACA1HR_MBC_Msk      /* Mask byte control: bits to mask for comparison of the MAC Address bytes */
N#define ETH_MACA1HR_MBC_HBits15_8                     0x20000000U              /* Mask MAC Address high reg bits [15:8] */
N#define ETH_MACA1HR_MBC_HBits7_0                      0x10000000U              /* Mask MAC Address high reg bits [7:0]  */
N#define ETH_MACA1HR_MBC_LBits31_24                    0x08000000U              /* Mask MAC Address low reg bits [31:24] */
N#define ETH_MACA1HR_MBC_LBits23_16                    0x04000000U              /* Mask MAC Address low reg bits [23:16] */
N#define ETH_MACA1HR_MBC_LBits15_8                     0x02000000U              /* Mask MAC Address low reg bits [15:8]  */
N#define ETH_MACA1HR_MBC_LBits7_0                      0x01000000U              /* Mask MAC Address low reg bits [7:0]   */
N#define ETH_MACA1HR_MACA1H_Pos                        (0U)                     
N#define ETH_MACA1HR_MACA1H_Msk                        (0xFFFFUL << ETH_MACA1HR_MACA1H_Pos) /*!< 0x0000FFFF */
N#define ETH_MACA1HR_MACA1H                            ETH_MACA1HR_MACA1H_Msk   /* MAC address1 high */
N
N/* Bit definition for Ethernet MAC Address1 Low Register */
N#define ETH_MACA1LR_MACA1L_Pos                        (0U)                     
N#define ETH_MACA1LR_MACA1L_Msk                        (0xFFFFFFFFUL << ETH_MACA1LR_MACA1L_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MACA1LR_MACA1L                            ETH_MACA1LR_MACA1L_Msk   /* MAC address1 low */
N
N/* Bit definition for Ethernet MAC Address2 High Register */
N#define ETH_MACA2HR_AE_Pos                            (31U)                    
N#define ETH_MACA2HR_AE_Msk                            (0x1UL << ETH_MACA2HR_AE_Pos) /*!< 0x80000000 */
N#define ETH_MACA2HR_AE                                ETH_MACA2HR_AE_Msk       /* Address enable */
N#define ETH_MACA2HR_SA_Pos                            (30U)                    
N#define ETH_MACA2HR_SA_Msk                            (0x1UL << ETH_MACA2HR_SA_Pos) /*!< 0x40000000 */
N#define ETH_MACA2HR_SA                                ETH_MACA2HR_SA_Msk       /* Source address */
N#define ETH_MACA2HR_MBC_Pos                           (24U)                    
N#define ETH_MACA2HR_MBC_Msk                           (0x3FUL << ETH_MACA2HR_MBC_Pos) /*!< 0x3F000000 */
N#define ETH_MACA2HR_MBC                               ETH_MACA2HR_MBC_Msk      /* Mask byte control */
N#define ETH_MACA2HR_MBC_HBits15_8                     0x20000000U              /* Mask MAC Address high reg bits [15:8] */
N#define ETH_MACA2HR_MBC_HBits7_0                      0x10000000U              /* Mask MAC Address high reg bits [7:0]  */
N#define ETH_MACA2HR_MBC_LBits31_24                    0x08000000U              /* Mask MAC Address low reg bits [31:24] */
N#define ETH_MACA2HR_MBC_LBits23_16                    0x04000000U              /* Mask MAC Address low reg bits [23:16] */
N#define ETH_MACA2HR_MBC_LBits15_8                     0x02000000U              /* Mask MAC Address low reg bits [15:8]  */
N#define ETH_MACA2HR_MBC_LBits7_0                      0x01000000U              /* Mask MAC Address low reg bits [70]    */
N#define ETH_MACA2HR_MACA2H_Pos                        (0U)                     
N#define ETH_MACA2HR_MACA2H_Msk                        (0xFFFFUL << ETH_MACA2HR_MACA2H_Pos) /*!< 0x0000FFFF */
N#define ETH_MACA2HR_MACA2H                            ETH_MACA2HR_MACA2H_Msk   /* MAC address1 high */
N
N/* Bit definition for Ethernet MAC Address2 Low Register */
N#define ETH_MACA2LR_MACA2L_Pos                        (0U)                     
N#define ETH_MACA2LR_MACA2L_Msk                        (0xFFFFFFFFUL << ETH_MACA2LR_MACA2L_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MACA2LR_MACA2L                            ETH_MACA2LR_MACA2L_Msk   /* MAC address2 low */
N
N/* Bit definition for Ethernet MAC Address3 High Register */
N#define ETH_MACA3HR_AE_Pos                            (31U)                    
N#define ETH_MACA3HR_AE_Msk                            (0x1UL << ETH_MACA3HR_AE_Pos) /*!< 0x80000000 */
N#define ETH_MACA3HR_AE                                ETH_MACA3HR_AE_Msk       /* Address enable */
N#define ETH_MACA3HR_SA_Pos                            (30U)                    
N#define ETH_MACA3HR_SA_Msk                            (0x1UL << ETH_MACA3HR_SA_Pos) /*!< 0x40000000 */
N#define ETH_MACA3HR_SA                                ETH_MACA3HR_SA_Msk       /* Source address */
N#define ETH_MACA3HR_MBC_Pos                           (24U)                    
N#define ETH_MACA3HR_MBC_Msk                           (0x3FUL << ETH_MACA3HR_MBC_Pos) /*!< 0x3F000000 */
N#define ETH_MACA3HR_MBC                               ETH_MACA3HR_MBC_Msk      /* Mask byte control */
N#define ETH_MACA3HR_MBC_HBits15_8                     0x20000000U              /* Mask MAC Address high reg bits [15:8] */
N#define ETH_MACA3HR_MBC_HBits7_0                      0x10000000U              /* Mask MAC Address high reg bits [7:0]  */
N#define ETH_MACA3HR_MBC_LBits31_24                    0x08000000U              /* Mask MAC Address low reg bits [31:24] */
N#define ETH_MACA3HR_MBC_LBits23_16                    0x04000000U              /* Mask MAC Address low reg bits [23:16] */
N#define ETH_MACA3HR_MBC_LBits15_8                     0x02000000U              /* Mask MAC Address low reg bits [15:8]  */
N#define ETH_MACA3HR_MBC_LBits7_0                      0x01000000U              /* Mask MAC Address low reg bits [70]    */
N#define ETH_MACA3HR_MACA3H_Pos                        (0U)                     
N#define ETH_MACA3HR_MACA3H_Msk                        (0xFFFFUL << ETH_MACA3HR_MACA3H_Pos) /*!< 0x0000FFFF */
N#define ETH_MACA3HR_MACA3H                            ETH_MACA3HR_MACA3H_Msk   /* MAC address3 high */
N
N/* Bit definition for Ethernet MAC Address3 Low Register */
N#define ETH_MACA3LR_MACA3L_Pos                        (0U)                     
N#define ETH_MACA3LR_MACA3L_Msk                        (0xFFFFFFFFUL << ETH_MACA3LR_MACA3L_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MACA3LR_MACA3L                            ETH_MACA3LR_MACA3L_Msk   /* MAC address3 low */
N
N/******************************************************************************/
N/*                Ethernet MMC Registers bits definition                      */
N/******************************************************************************/
N
N/* Bit definition for Ethernet MMC Contol Register */
N#define ETH_MMCCR_MCFHP_Pos                           (5U)                     
N#define ETH_MMCCR_MCFHP_Msk                           (0x1UL << ETH_MMCCR_MCFHP_Pos) /*!< 0x00000020 */
N#define ETH_MMCCR_MCFHP                               ETH_MMCCR_MCFHP_Msk      /* MMC counter Full-Half preset */
N#define ETH_MMCCR_MCP_Pos                             (4U)                     
N#define ETH_MMCCR_MCP_Msk                             (0x1UL << ETH_MMCCR_MCP_Pos) /*!< 0x00000010 */
N#define ETH_MMCCR_MCP                                 ETH_MMCCR_MCP_Msk        /* MMC counter preset           */
N#define ETH_MMCCR_MCF_Pos                             (3U)                     
N#define ETH_MMCCR_MCF_Msk                             (0x1UL << ETH_MMCCR_MCF_Pos) /*!< 0x00000008 */
N#define ETH_MMCCR_MCF                                 ETH_MMCCR_MCF_Msk        /* MMC Counter Freeze           */
N#define ETH_MMCCR_ROR_Pos                             (2U)                     
N#define ETH_MMCCR_ROR_Msk                             (0x1UL << ETH_MMCCR_ROR_Pos) /*!< 0x00000004 */
N#define ETH_MMCCR_ROR                                 ETH_MMCCR_ROR_Msk        /* Reset on Read                */
N#define ETH_MMCCR_CSR_Pos                             (1U)                     
N#define ETH_MMCCR_CSR_Msk                             (0x1UL << ETH_MMCCR_CSR_Pos) /*!< 0x00000002 */
N#define ETH_MMCCR_CSR                                 ETH_MMCCR_CSR_Msk        /* Counter Stop Rollover        */
N#define ETH_MMCCR_CR_Pos                              (0U)                     
N#define ETH_MMCCR_CR_Msk                              (0x1UL << ETH_MMCCR_CR_Pos) /*!< 0x00000001 */
N#define ETH_MMCCR_CR                                  ETH_MMCCR_CR_Msk         /* Counters Reset               */
N
N/* Bit definition for Ethernet MMC Receive Interrupt Register */
N#define ETH_MMCRIR_RGUFS_Pos                          (17U)                    
N#define ETH_MMCRIR_RGUFS_Msk                          (0x1UL << ETH_MMCRIR_RGUFS_Pos) /*!< 0x00020000 */
N#define ETH_MMCRIR_RGUFS                              ETH_MMCRIR_RGUFS_Msk     /* Set when Rx good unicast frames counter reaches half the maximum value */
N#define ETH_MMCRIR_RFAES_Pos                          (6U)                     
N#define ETH_MMCRIR_RFAES_Msk                          (0x1UL << ETH_MMCRIR_RFAES_Pos) /*!< 0x00000040 */
N#define ETH_MMCRIR_RFAES                              ETH_MMCRIR_RFAES_Msk     /* Set when Rx alignment error counter reaches half the maximum value */
N#define ETH_MMCRIR_RFCES_Pos                          (5U)                     
N#define ETH_MMCRIR_RFCES_Msk                          (0x1UL << ETH_MMCRIR_RFCES_Pos) /*!< 0x00000020 */
N#define ETH_MMCRIR_RFCES                              ETH_MMCRIR_RFCES_Msk     /* Set when Rx crc error counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Transmit Interrupt Register */
N#define ETH_MMCTIR_TGFS_Pos                           (21U)                    
N#define ETH_MMCTIR_TGFS_Msk                           (0x1UL << ETH_MMCTIR_TGFS_Pos) /*!< 0x00200000 */
N#define ETH_MMCTIR_TGFS                               ETH_MMCTIR_TGFS_Msk      /* Set when Tx good frame count counter reaches half the maximum value */
N#define ETH_MMCTIR_TGFMSCS_Pos                        (15U)                    
N#define ETH_MMCTIR_TGFMSCS_Msk                        (0x1UL << ETH_MMCTIR_TGFMSCS_Pos) /*!< 0x00008000 */
N#define ETH_MMCTIR_TGFMSCS                            ETH_MMCTIR_TGFMSCS_Msk   /* Set when Tx good multi col counter reaches half the maximum value */
N#define ETH_MMCTIR_TGFSCS_Pos                         (14U)                    
N#define ETH_MMCTIR_TGFSCS_Msk                         (0x1UL << ETH_MMCTIR_TGFSCS_Pos) /*!< 0x00004000 */
N#define ETH_MMCTIR_TGFSCS                             ETH_MMCTIR_TGFSCS_Msk    /* Set when Tx good single col counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */
N#define ETH_MMCRIMR_RGUFM_Pos                         (17U)                    
N#define ETH_MMCRIMR_RGUFM_Msk                         (0x1UL << ETH_MMCRIMR_RGUFM_Pos) /*!< 0x00020000 */
N#define ETH_MMCRIMR_RGUFM                             ETH_MMCRIMR_RGUFM_Msk    /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */
N#define ETH_MMCRIMR_RFAEM_Pos                         (6U)                     
N#define ETH_MMCRIMR_RFAEM_Msk                         (0x1UL << ETH_MMCRIMR_RFAEM_Pos) /*!< 0x00000040 */
N#define ETH_MMCRIMR_RFAEM                             ETH_MMCRIMR_RFAEM_Msk    /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */
N#define ETH_MMCRIMR_RFCEM_Pos                         (5U)                     
N#define ETH_MMCRIMR_RFCEM_Msk                         (0x1UL << ETH_MMCRIMR_RFCEM_Pos) /*!< 0x00000020 */
N#define ETH_MMCRIMR_RFCEM                             ETH_MMCRIMR_RFCEM_Msk    /* Mask the interrupt when Rx crc error counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */
N#define ETH_MMCTIMR_TGFM_Pos                          (21U)                    
N#define ETH_MMCTIMR_TGFM_Msk                          (0x1UL << ETH_MMCTIMR_TGFM_Pos) /*!< 0x00200000 */
N#define ETH_MMCTIMR_TGFM                              ETH_MMCTIMR_TGFM_Msk     /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */
N#define ETH_MMCTIMR_TGFMSCM_Pos                       (15U)                    
N#define ETH_MMCTIMR_TGFMSCM_Msk                       (0x1UL << ETH_MMCTIMR_TGFMSCM_Pos) /*!< 0x00008000 */
N#define ETH_MMCTIMR_TGFMSCM                           ETH_MMCTIMR_TGFMSCM_Msk  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */
N#define ETH_MMCTIMR_TGFSCM_Pos                        (14U)                    
N#define ETH_MMCTIMR_TGFSCM_Msk                        (0x1UL << ETH_MMCTIMR_TGFSCM_Pos) /*!< 0x00004000 */
N#define ETH_MMCTIMR_TGFSCM                            ETH_MMCTIMR_TGFSCM_Msk   /* Mask the interrupt when Tx good single col counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */
N#define ETH_MMCTGFSCCR_TGFSCC_Pos                     (0U)                     
N#define ETH_MMCTGFSCCR_TGFSCC_Msk                     (0xFFFFFFFFUL << ETH_MMCTGFSCCR_TGFSCC_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MMCTGFSCCR_TGFSCC                         ETH_MMCTGFSCCR_TGFSCC_Msk /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */
N
N/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */
N#define ETH_MMCTGFMSCCR_TGFMSCC_Pos                   (0U)                     
N#define ETH_MMCTGFMSCCR_TGFMSCC_Msk                   (0xFFFFFFFFUL << ETH_MMCTGFMSCCR_TGFMSCC_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MMCTGFMSCCR_TGFMSCC                       ETH_MMCTGFMSCCR_TGFMSCC_Msk /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */
N
N/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */
N#define ETH_MMCTGFCR_TGFC_Pos                         (0U)                     
N#define ETH_MMCTGFCR_TGFC_Msk                         (0xFFFFFFFFUL << ETH_MMCTGFCR_TGFC_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MMCTGFCR_TGFC                             ETH_MMCTGFCR_TGFC_Msk    /* Number of good frames transmitted. */
N
N/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */
N#define ETH_MMCRFCECR_RFCEC_Pos                       (0U)                     
N#define ETH_MMCRFCECR_RFCEC_Msk                       (0xFFFFFFFFUL << ETH_MMCRFCECR_RFCEC_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MMCRFCECR_RFCEC                           ETH_MMCRFCECR_RFCEC_Msk  /* Number of frames received with CRC error. */
N
N/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */
N#define ETH_MMCRFAECR_RFAEC_Pos                       (0U)                     
N#define ETH_MMCRFAECR_RFAEC_Msk                       (0xFFFFFFFFUL << ETH_MMCRFAECR_RFAEC_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MMCRFAECR_RFAEC                           ETH_MMCRFAECR_RFAEC_Msk  /* Number of frames received with alignment (dribble) error */
N
N/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */
N#define ETH_MMCRGUFCR_RGUFC_Pos                       (0U)                     
N#define ETH_MMCRGUFCR_RGUFC_Msk                       (0xFFFFFFFFUL << ETH_MMCRGUFCR_RGUFC_Pos) /*!< 0xFFFFFFFF */
N#define ETH_MMCRGUFCR_RGUFC                           ETH_MMCRGUFCR_RGUFC_Msk  /* Number of good unicast frames received. */
N
N/******************************************************************************/
N/*               Ethernet PTP Registers bits definition                       */
N/******************************************************************************/
N
N/* Bit definition for Ethernet PTP Time Stamp Contol Register */
N#define ETH_PTPTSCR_TSCNT_Pos                         (16U)                    
N#define ETH_PTPTSCR_TSCNT_Msk                         (0x3UL << ETH_PTPTSCR_TSCNT_Pos) /*!< 0x00030000 */
N#define ETH_PTPTSCR_TSCNT                             ETH_PTPTSCR_TSCNT_Msk    /* Time stamp clock node type */
N#define ETH_PTPTSSR_TSSMRME_Pos                       (15U)                    
N#define ETH_PTPTSSR_TSSMRME_Msk                       (0x1UL << ETH_PTPTSSR_TSSMRME_Pos) /*!< 0x00008000 */
N#define ETH_PTPTSSR_TSSMRME                           ETH_PTPTSSR_TSSMRME_Msk  /* Time stamp snapshot for message relevant to master enable */
N#define ETH_PTPTSSR_TSSEME_Pos                        (14U)                    
N#define ETH_PTPTSSR_TSSEME_Msk                        (0x1UL << ETH_PTPTSSR_TSSEME_Pos) /*!< 0x00004000 */
N#define ETH_PTPTSSR_TSSEME                            ETH_PTPTSSR_TSSEME_Msk   /* Time stamp snapshot for event message enable */
N#define ETH_PTPTSSR_TSSIPV4FE_Pos                     (13U)                    
N#define ETH_PTPTSSR_TSSIPV4FE_Msk                     (0x1UL << ETH_PTPTSSR_TSSIPV4FE_Pos) /*!< 0x00002000 */
N#define ETH_PTPTSSR_TSSIPV4FE                         ETH_PTPTSSR_TSSIPV4FE_Msk /* Time stamp snapshot for IPv4 frames enable */
N#define ETH_PTPTSSR_TSSIPV6FE_Pos                     (12U)                    
N#define ETH_PTPTSSR_TSSIPV6FE_Msk                     (0x1UL << ETH_PTPTSSR_TSSIPV6FE_Pos) /*!< 0x00001000 */
N#define ETH_PTPTSSR_TSSIPV6FE                         ETH_PTPTSSR_TSSIPV6FE_Msk /* Time stamp snapshot for IPv6 frames enable */
N#define ETH_PTPTSSR_TSSPTPOEFE_Pos                    (11U)                    
N#define ETH_PTPTSSR_TSSPTPOEFE_Msk                    (0x1UL << ETH_PTPTSSR_TSSPTPOEFE_Pos) /*!< 0x00000800 */
N#define ETH_PTPTSSR_TSSPTPOEFE                        ETH_PTPTSSR_TSSPTPOEFE_Msk /* Time stamp snapshot for PTP over ethernet frames enable */
N#define ETH_PTPTSSR_TSPTPPSV2E_Pos                    (10U)                    
N#define ETH_PTPTSSR_TSPTPPSV2E_Msk                    (0x1UL << ETH_PTPTSSR_TSPTPPSV2E_Pos) /*!< 0x00000400 */
N#define ETH_PTPTSSR_TSPTPPSV2E                        ETH_PTPTSSR_TSPTPPSV2E_Msk /* Time stamp PTP packet snooping for version2 format enable */
N#define ETH_PTPTSSR_TSSSR_Pos                         (9U)                     
N#define ETH_PTPTSSR_TSSSR_Msk                         (0x1UL << ETH_PTPTSSR_TSSSR_Pos) /*!< 0x00000200 */
N#define ETH_PTPTSSR_TSSSR                             ETH_PTPTSSR_TSSSR_Msk    /* Time stamp Sub-seconds rollover */
N#define ETH_PTPTSSR_TSSARFE_Pos                       (8U)                     
N#define ETH_PTPTSSR_TSSARFE_Msk                       (0x1UL << ETH_PTPTSSR_TSSARFE_Pos) /*!< 0x00000100 */
N#define ETH_PTPTSSR_TSSARFE                           ETH_PTPTSSR_TSSARFE_Msk  /* Time stamp snapshot for all received frames enable */
N
N#define ETH_PTPTSCR_TSARU_Pos                         (5U)                     
N#define ETH_PTPTSCR_TSARU_Msk                         (0x1UL << ETH_PTPTSCR_TSARU_Pos) /*!< 0x00000020 */
N#define ETH_PTPTSCR_TSARU                             ETH_PTPTSCR_TSARU_Msk    /* Addend register update */
N#define ETH_PTPTSCR_TSITE_Pos                         (4U)                     
N#define ETH_PTPTSCR_TSITE_Msk                         (0x1UL << ETH_PTPTSCR_TSITE_Pos) /*!< 0x00000010 */
N#define ETH_PTPTSCR_TSITE                             ETH_PTPTSCR_TSITE_Msk    /* Time stamp interrupt trigger enable */
N#define ETH_PTPTSCR_TSSTU_Pos                         (3U)                     
N#define ETH_PTPTSCR_TSSTU_Msk                         (0x1UL << ETH_PTPTSCR_TSSTU_Pos) /*!< 0x00000008 */
N#define ETH_PTPTSCR_TSSTU                             ETH_PTPTSCR_TSSTU_Msk    /* Time stamp update */
N#define ETH_PTPTSCR_TSSTI_Pos                         (2U)                     
N#define ETH_PTPTSCR_TSSTI_Msk                         (0x1UL << ETH_PTPTSCR_TSSTI_Pos) /*!< 0x00000004 */
N#define ETH_PTPTSCR_TSSTI                             ETH_PTPTSCR_TSSTI_Msk    /* Time stamp initialize */
N#define ETH_PTPTSCR_TSFCU_Pos                         (1U)                     
N#define ETH_PTPTSCR_TSFCU_Msk                         (0x1UL << ETH_PTPTSCR_TSFCU_Pos) /*!< 0x00000002 */
N#define ETH_PTPTSCR_TSFCU                             ETH_PTPTSCR_TSFCU_Msk    /* Time stamp fine or coarse update */
N#define ETH_PTPTSCR_TSE_Pos                           (0U)                     
N#define ETH_PTPTSCR_TSE_Msk                           (0x1UL << ETH_PTPTSCR_TSE_Pos) /*!< 0x00000001 */
N#define ETH_PTPTSCR_TSE                               ETH_PTPTSCR_TSE_Msk      /* Time stamp enable */
N
N/* Bit definition for Ethernet PTP Sub-Second Increment Register */
N#define ETH_PTPSSIR_STSSI_Pos                         (0U)                     
N#define ETH_PTPSSIR_STSSI_Msk                         (0xFFUL << ETH_PTPSSIR_STSSI_Pos) /*!< 0x000000FF */
N#define ETH_PTPSSIR_STSSI                             ETH_PTPSSIR_STSSI_Msk    /* System time Sub-second increment value */
N
N/* Bit definition for Ethernet PTP Time Stamp High Register */
N#define ETH_PTPTSHR_STS_Pos                           (0U)                     
N#define ETH_PTPTSHR_STS_Msk                           (0xFFFFFFFFUL << ETH_PTPTSHR_STS_Pos) /*!< 0xFFFFFFFF */
N#define ETH_PTPTSHR_STS                               ETH_PTPTSHR_STS_Msk      /* System Time second */
N
N/* Bit definition for Ethernet PTP Time Stamp Low Register */
N#define ETH_PTPTSLR_STPNS_Pos                         (31U)                    
N#define ETH_PTPTSLR_STPNS_Msk                         (0x1UL << ETH_PTPTSLR_STPNS_Pos) /*!< 0x80000000 */
N#define ETH_PTPTSLR_STPNS                             ETH_PTPTSLR_STPNS_Msk    /* System Time Positive or negative time */
N#define ETH_PTPTSLR_STSS_Pos                          (0U)                     
N#define ETH_PTPTSLR_STSS_Msk                          (0x7FFFFFFFUL << ETH_PTPTSLR_STSS_Pos) /*!< 0x7FFFFFFF */
N#define ETH_PTPTSLR_STSS                              ETH_PTPTSLR_STSS_Msk     /* System Time sub-seconds */
N
N/* Bit definition for Ethernet PTP Time Stamp High Update Register */
N#define ETH_PTPTSHUR_TSUS_Pos                         (0U)                     
N#define ETH_PTPTSHUR_TSUS_Msk                         (0xFFFFFFFFUL << ETH_PTPTSHUR_TSUS_Pos) /*!< 0xFFFFFFFF */
N#define ETH_PTPTSHUR_TSUS                             ETH_PTPTSHUR_TSUS_Msk    /* Time stamp update seconds */
N
N/* Bit definition for Ethernet PTP Time Stamp Low Update Register */
N#define ETH_PTPTSLUR_TSUPNS_Pos                       (31U)                    
N#define ETH_PTPTSLUR_TSUPNS_Msk                       (0x1UL << ETH_PTPTSLUR_TSUPNS_Pos) /*!< 0x80000000 */
N#define ETH_PTPTSLUR_TSUPNS                           ETH_PTPTSLUR_TSUPNS_Msk  /* Time stamp update Positive or negative time */
N#define ETH_PTPTSLUR_TSUSS_Pos                        (0U)                     
N#define ETH_PTPTSLUR_TSUSS_Msk                        (0x7FFFFFFFUL << ETH_PTPTSLUR_TSUSS_Pos) /*!< 0x7FFFFFFF */
N#define ETH_PTPTSLUR_TSUSS                            ETH_PTPTSLUR_TSUSS_Msk   /* Time stamp update sub-seconds */
N
N/* Bit definition for Ethernet PTP Time Stamp Addend Register */
N#define ETH_PTPTSAR_TSA_Pos                           (0U)                     
N#define ETH_PTPTSAR_TSA_Msk                           (0xFFFFFFFFUL << ETH_PTPTSAR_TSA_Pos) /*!< 0xFFFFFFFF */
N#define ETH_PTPTSAR_TSA                               ETH_PTPTSAR_TSA_Msk      /* Time stamp addend */
N
N/* Bit definition for Ethernet PTP Target Time High Register */
N#define ETH_PTPTTHR_TTSH_Pos                          (0U)                     
N#define ETH_PTPTTHR_TTSH_Msk                          (0xFFFFFFFFUL << ETH_PTPTTHR_TTSH_Pos) /*!< 0xFFFFFFFF */
N#define ETH_PTPTTHR_TTSH                              ETH_PTPTTHR_TTSH_Msk     /* Target time stamp high */
N
N/* Bit definition for Ethernet PTP Target Time Low Register */
N#define ETH_PTPTTLR_TTSL_Pos                          (0U)                     
N#define ETH_PTPTTLR_TTSL_Msk                          (0xFFFFFFFFUL << ETH_PTPTTLR_TTSL_Pos) /*!< 0xFFFFFFFF */
N#define ETH_PTPTTLR_TTSL                              ETH_PTPTTLR_TTSL_Msk     /* Target time stamp low */
N
N/* Bit definition for Ethernet PTP Time Stamp Status Register */
N#define ETH_PTPTSSR_TSTTR_Pos                         (5U)                     
N#define ETH_PTPTSSR_TSTTR_Msk                         (0x1UL << ETH_PTPTSSR_TSTTR_Pos) /*!< 0x00000020 */
N#define ETH_PTPTSSR_TSTTR                             ETH_PTPTSSR_TSTTR_Msk    /* Time stamp target time reached */
N#define ETH_PTPTSSR_TSSO_Pos                          (4U)                     
N#define ETH_PTPTSSR_TSSO_Msk                          (0x1UL << ETH_PTPTSSR_TSSO_Pos) /*!< 0x00000010 */
N#define ETH_PTPTSSR_TSSO                              ETH_PTPTSSR_TSSO_Msk     /* Time stamp seconds overflow */
N
N/******************************************************************************/
N/*                 Ethernet DMA Registers bits definition                     */
N/******************************************************************************/
N
N/* Bit definition for Ethernet DMA Bus Mode Register */
N#define ETH_DMABMR_AAB_Pos                            (25U)                    
N#define ETH_DMABMR_AAB_Msk                            (0x1UL << ETH_DMABMR_AAB_Pos) /*!< 0x02000000 */
N#define ETH_DMABMR_AAB                                ETH_DMABMR_AAB_Msk       /* Address-Aligned beats */
N#define ETH_DMABMR_FPM_Pos                            (24U)                    
N#define ETH_DMABMR_FPM_Msk                            (0x1UL << ETH_DMABMR_FPM_Pos) /*!< 0x01000000 */
N#define ETH_DMABMR_FPM                                ETH_DMABMR_FPM_Msk       /* 4xPBL mode */
N#define ETH_DMABMR_USP_Pos                            (23U)                    
N#define ETH_DMABMR_USP_Msk                            (0x1UL << ETH_DMABMR_USP_Pos) /*!< 0x00800000 */
N#define ETH_DMABMR_USP                                ETH_DMABMR_USP_Msk       /* Use separate PBL */
N#define ETH_DMABMR_RDP_Pos                            (17U)                    
N#define ETH_DMABMR_RDP_Msk                            (0x3FUL << ETH_DMABMR_RDP_Pos) /*!< 0x007E0000 */
N#define ETH_DMABMR_RDP                                ETH_DMABMR_RDP_Msk       /* RxDMA PBL */
N#define ETH_DMABMR_RDP_1Beat                          0x00020000U              /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
N#define ETH_DMABMR_RDP_2Beat                          0x00040000U              /* maximum number of beats to be transferred in one RxDMA transaction is 2 */
N#define ETH_DMABMR_RDP_4Beat                          0x00080000U              /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
N#define ETH_DMABMR_RDP_8Beat                          0x00100000U              /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
N#define ETH_DMABMR_RDP_16Beat                         0x00200000U              /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
N#define ETH_DMABMR_RDP_32Beat                         0x00400000U              /* maximum number of beats to be transferred in one RxDMA transaction is 32 */                
N#define ETH_DMABMR_RDP_4xPBL_4Beat                    0x01020000U              /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
N#define ETH_DMABMR_RDP_4xPBL_8Beat                    0x01040000U              /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
N#define ETH_DMABMR_RDP_4xPBL_16Beat                   0x01080000U              /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
N#define ETH_DMABMR_RDP_4xPBL_32Beat                   0x01100000U              /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
N#define ETH_DMABMR_RDP_4xPBL_64Beat                   0x01200000U              /* maximum number of beats to be transferred in one RxDMA transaction is 64 */
N#define ETH_DMABMR_RDP_4xPBL_128Beat                  0x01400000U              /* maximum number of beats to be transferred in one RxDMA transaction is 128 */  
N#define ETH_DMABMR_FB_Pos                             (16U)                    
N#define ETH_DMABMR_FB_Msk                             (0x1UL << ETH_DMABMR_FB_Pos) /*!< 0x00010000 */
N#define ETH_DMABMR_FB                                 ETH_DMABMR_FB_Msk        /* Fixed Burst */
N#define ETH_DMABMR_RTPR_Pos                           (14U)                    
N#define ETH_DMABMR_RTPR_Msk                           (0x3UL << ETH_DMABMR_RTPR_Pos) /*!< 0x0000C000 */
N#define ETH_DMABMR_RTPR                               ETH_DMABMR_RTPR_Msk      /* Rx Tx priority ratio */
N#define ETH_DMABMR_RTPR_1_1                           0x00000000U              /* Rx Tx priority ratio */
N#define ETH_DMABMR_RTPR_2_1                           0x00004000U              /* Rx Tx priority ratio */
N#define ETH_DMABMR_RTPR_3_1                           0x00008000U              /* Rx Tx priority ratio */
N#define ETH_DMABMR_RTPR_4_1                           0x0000C000U              /* Rx Tx priority ratio */  
N#define ETH_DMABMR_PBL_Pos                            (8U)                     
N#define ETH_DMABMR_PBL_Msk                            (0x3FUL << ETH_DMABMR_PBL_Pos) /*!< 0x00003F00 */
N#define ETH_DMABMR_PBL                                ETH_DMABMR_PBL_Msk       /* Programmable burst length */
N#define ETH_DMABMR_PBL_1Beat                          0x00000100U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
N#define ETH_DMABMR_PBL_2Beat                          0x00000200U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
N#define ETH_DMABMR_PBL_4Beat                          0x00000400U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N#define ETH_DMABMR_PBL_8Beat                          0x00000800U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N#define ETH_DMABMR_PBL_16Beat                         0x00001000U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N#define ETH_DMABMR_PBL_32Beat                         0x00002000U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
N#define ETH_DMABMR_PBL_4xPBL_4Beat                    0x01000100U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N#define ETH_DMABMR_PBL_4xPBL_8Beat                    0x01000200U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N#define ETH_DMABMR_PBL_4xPBL_16Beat                   0x01000400U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N#define ETH_DMABMR_PBL_4xPBL_32Beat                   0x01000800U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
N#define ETH_DMABMR_PBL_4xPBL_64Beat                   0x01001000U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
N#define ETH_DMABMR_PBL_4xPBL_128Beat                  0x01002000U              /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
N#define ETH_DMABMR_EDE_Pos                            (7U)                     
N#define ETH_DMABMR_EDE_Msk                            (0x1UL << ETH_DMABMR_EDE_Pos) /*!< 0x00000080 */
N#define ETH_DMABMR_EDE                                ETH_DMABMR_EDE_Msk       /* Enhanced Descriptor Enable */
N#define ETH_DMABMR_DSL_Pos                            (2U)                     
N#define ETH_DMABMR_DSL_Msk                            (0x1FUL << ETH_DMABMR_DSL_Pos) /*!< 0x0000007C */
N#define ETH_DMABMR_DSL                                ETH_DMABMR_DSL_Msk       /* Descriptor Skip Length */
N#define ETH_DMABMR_DA_Pos                             (1U)                     
N#define ETH_DMABMR_DA_Msk                             (0x1UL << ETH_DMABMR_DA_Pos) /*!< 0x00000002 */
N#define ETH_DMABMR_DA                                 ETH_DMABMR_DA_Msk        /* DMA arbitration scheme */
N#define ETH_DMABMR_SR_Pos                             (0U)                     
N#define ETH_DMABMR_SR_Msk                             (0x1UL << ETH_DMABMR_SR_Pos) /*!< 0x00000001 */
N#define ETH_DMABMR_SR                                 ETH_DMABMR_SR_Msk        /* Software reset */
N
N/* Bit definition for Ethernet DMA Transmit Poll Demand Register */
N#define ETH_DMATPDR_TPD_Pos                           (0U)                     
N#define ETH_DMATPDR_TPD_Msk                           (0xFFFFFFFFUL << ETH_DMATPDR_TPD_Pos) /*!< 0xFFFFFFFF */
N#define ETH_DMATPDR_TPD                               ETH_DMATPDR_TPD_Msk      /* Transmit poll demand */
N
N/* Bit definition for Ethernet DMA Receive Poll Demand Register */
N#define ETH_DMARPDR_RPD_Pos                           (0U)                     
N#define ETH_DMARPDR_RPD_Msk                           (0xFFFFFFFFUL << ETH_DMARPDR_RPD_Pos) /*!< 0xFFFFFFFF */
N#define ETH_DMARPDR_RPD                               ETH_DMARPDR_RPD_Msk      /* Receive poll demand  */
N
N/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */
N#define ETH_DMARDLAR_SRL_Pos                          (0U)                     
N#define ETH_DMARDLAR_SRL_Msk                          (0xFFFFFFFFUL << ETH_DMARDLAR_SRL_Pos) /*!< 0xFFFFFFFF */
N#define ETH_DMARDLAR_SRL                              ETH_DMARDLAR_SRL_Msk     /* Start of receive list */
N
N/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */
N#define ETH_DMATDLAR_STL_Pos                          (0U)                     
N#define ETH_DMATDLAR_STL_Msk                          (0xFFFFFFFFUL << ETH_DMATDLAR_STL_Pos) /*!< 0xFFFFFFFF */
N#define ETH_DMATDLAR_STL                              ETH_DMATDLAR_STL_Msk     /* Start of transmit list */
N
N/* Bit definition for Ethernet DMA Status Register */
N#define ETH_DMASR_TSTS_Pos                            (29U)                    
N#define ETH_DMASR_TSTS_Msk                            (0x1UL << ETH_DMASR_TSTS_Pos) /*!< 0x20000000 */
N#define ETH_DMASR_TSTS                                ETH_DMASR_TSTS_Msk       /* Time-stamp trigger status */
N#define ETH_DMASR_PMTS_Pos                            (28U)                    
N#define ETH_DMASR_PMTS_Msk                            (0x1UL << ETH_DMASR_PMTS_Pos) /*!< 0x10000000 */
N#define ETH_DMASR_PMTS                                ETH_DMASR_PMTS_Msk       /* PMT status */
N#define ETH_DMASR_MMCS_Pos                            (27U)                    
N#define ETH_DMASR_MMCS_Msk                            (0x1UL << ETH_DMASR_MMCS_Pos) /*!< 0x08000000 */
N#define ETH_DMASR_MMCS                                ETH_DMASR_MMCS_Msk       /* MMC status */
N#define ETH_DMASR_EBS_Pos                             (23U)                    
N#define ETH_DMASR_EBS_Msk                             (0x7UL << ETH_DMASR_EBS_Pos) /*!< 0x03800000 */
N#define ETH_DMASR_EBS                                 ETH_DMASR_EBS_Msk        /* Error bits status */
N  /* combination with EBS[2:0] for GetFlagStatus function */
N#define ETH_DMASR_EBS_DescAccess_Pos                  (25U)                    
N#define ETH_DMASR_EBS_DescAccess_Msk                  (0x1UL << ETH_DMASR_EBS_DescAccess_Pos) /*!< 0x02000000 */
N#define ETH_DMASR_EBS_DescAccess                      ETH_DMASR_EBS_DescAccess_Msk /* Error bits 0-data buffer, 1-desc. access */
N#define ETH_DMASR_EBS_ReadTransf_Pos                  (24U)                    
N#define ETH_DMASR_EBS_ReadTransf_Msk                  (0x1UL << ETH_DMASR_EBS_ReadTransf_Pos) /*!< 0x01000000 */
N#define ETH_DMASR_EBS_ReadTransf                      ETH_DMASR_EBS_ReadTransf_Msk /* Error bits 0-write trnsf, 1-read transfr */
N#define ETH_DMASR_EBS_DataTransfTx_Pos                (23U)                    
N#define ETH_DMASR_EBS_DataTransfTx_Msk                (0x1UL << ETH_DMASR_EBS_DataTransfTx_Pos) /*!< 0x00800000 */
N#define ETH_DMASR_EBS_DataTransfTx                    ETH_DMASR_EBS_DataTransfTx_Msk /* Error bits 0-Rx DMA, 1-Tx DMA */
N#define ETH_DMASR_TPS_Pos                             (20U)                    
N#define ETH_DMASR_TPS_Msk                             (0x7UL << ETH_DMASR_TPS_Pos) /*!< 0x00700000 */
N#define ETH_DMASR_TPS                                 ETH_DMASR_TPS_Msk        /* Transmit process state */
N#define ETH_DMASR_TPS_Stopped                         0x00000000U              /* Stopped - Reset or Stop Tx Command issued  */
N#define ETH_DMASR_TPS_Fetching_Pos                    (20U)                    
N#define ETH_DMASR_TPS_Fetching_Msk                    (0x1UL << ETH_DMASR_TPS_Fetching_Pos) /*!< 0x00100000 */
N#define ETH_DMASR_TPS_Fetching                        ETH_DMASR_TPS_Fetching_Msk /* Running - fetching the Tx descriptor */
N#define ETH_DMASR_TPS_Waiting_Pos                     (21U)                    
N#define ETH_DMASR_TPS_Waiting_Msk                     (0x1UL << ETH_DMASR_TPS_Waiting_Pos) /*!< 0x00200000 */
N#define ETH_DMASR_TPS_Waiting                         ETH_DMASR_TPS_Waiting_Msk /* Running - waiting for status */
N#define ETH_DMASR_TPS_Reading_Pos                     (20U)                    
N#define ETH_DMASR_TPS_Reading_Msk                     (0x3UL << ETH_DMASR_TPS_Reading_Pos) /*!< 0x00300000 */
N#define ETH_DMASR_TPS_Reading                         ETH_DMASR_TPS_Reading_Msk /* Running - reading the data from host memory */
N#define ETH_DMASR_TPS_Suspended_Pos                   (21U)                    
N#define ETH_DMASR_TPS_Suspended_Msk                   (0x3UL << ETH_DMASR_TPS_Suspended_Pos) /*!< 0x00600000 */
N#define ETH_DMASR_TPS_Suspended                       ETH_DMASR_TPS_Suspended_Msk /* Suspended - Tx Descriptor unavailable */
N#define ETH_DMASR_TPS_Closing_Pos                     (20U)                    
N#define ETH_DMASR_TPS_Closing_Msk                     (0x7UL << ETH_DMASR_TPS_Closing_Pos) /*!< 0x00700000 */
N#define ETH_DMASR_TPS_Closing                         ETH_DMASR_TPS_Closing_Msk /* Running - closing Rx descriptor */
N#define ETH_DMASR_RPS_Pos                             (17U)                    
N#define ETH_DMASR_RPS_Msk                             (0x7UL << ETH_DMASR_RPS_Pos) /*!< 0x000E0000 */
N#define ETH_DMASR_RPS                                 ETH_DMASR_RPS_Msk        /* Receive process state */
N#define ETH_DMASR_RPS_Stopped                         0x00000000U              /* Stopped - Reset or Stop Rx Command issued */
N#define ETH_DMASR_RPS_Fetching_Pos                    (17U)                    
N#define ETH_DMASR_RPS_Fetching_Msk                    (0x1UL << ETH_DMASR_RPS_Fetching_Pos) /*!< 0x00020000 */
N#define ETH_DMASR_RPS_Fetching                        ETH_DMASR_RPS_Fetching_Msk /* Running - fetching the Rx descriptor */
N#define ETH_DMASR_RPS_Waiting_Pos                     (17U)                    
N#define ETH_DMASR_RPS_Waiting_Msk                     (0x3UL << ETH_DMASR_RPS_Waiting_Pos) /*!< 0x00060000 */
N#define ETH_DMASR_RPS_Waiting                         ETH_DMASR_RPS_Waiting_Msk /* Running - waiting for packet */
N#define ETH_DMASR_RPS_Suspended_Pos                   (19U)                    
N#define ETH_DMASR_RPS_Suspended_Msk                   (0x1UL << ETH_DMASR_RPS_Suspended_Pos) /*!< 0x00080000 */
N#define ETH_DMASR_RPS_Suspended                       ETH_DMASR_RPS_Suspended_Msk /* Suspended - Rx Descriptor unavailable */
N#define ETH_DMASR_RPS_Closing_Pos                     (17U)                    
N#define ETH_DMASR_RPS_Closing_Msk                     (0x5UL << ETH_DMASR_RPS_Closing_Pos) /*!< 0x000A0000 */
N#define ETH_DMASR_RPS_Closing                         ETH_DMASR_RPS_Closing_Msk /* Running - closing descriptor */
N#define ETH_DMASR_RPS_Queuing_Pos                     (17U)                    
N#define ETH_DMASR_RPS_Queuing_Msk                     (0x7UL << ETH_DMASR_RPS_Queuing_Pos) /*!< 0x000E0000 */
N#define ETH_DMASR_RPS_Queuing                         ETH_DMASR_RPS_Queuing_Msk /* Running - queuing the receive frame into host memory */
N#define ETH_DMASR_NIS_Pos                             (16U)                    
N#define ETH_DMASR_NIS_Msk                             (0x1UL << ETH_DMASR_NIS_Pos) /*!< 0x00010000 */
N#define ETH_DMASR_NIS                                 ETH_DMASR_NIS_Msk        /* Normal interrupt summary */
N#define ETH_DMASR_AIS_Pos                             (15U)                    
N#define ETH_DMASR_AIS_Msk                             (0x1UL << ETH_DMASR_AIS_Pos) /*!< 0x00008000 */
N#define ETH_DMASR_AIS                                 ETH_DMASR_AIS_Msk        /* Abnormal interrupt summary */
N#define ETH_DMASR_ERS_Pos                             (14U)                    
N#define ETH_DMASR_ERS_Msk                             (0x1UL << ETH_DMASR_ERS_Pos) /*!< 0x00004000 */
N#define ETH_DMASR_ERS                                 ETH_DMASR_ERS_Msk        /* Early receive status */
N#define ETH_DMASR_FBES_Pos                            (13U)                    
N#define ETH_DMASR_FBES_Msk                            (0x1UL << ETH_DMASR_FBES_Pos) /*!< 0x00002000 */
N#define ETH_DMASR_FBES                                ETH_DMASR_FBES_Msk       /* Fatal bus error status */
N#define ETH_DMASR_ETS_Pos                             (10U)                    
N#define ETH_DMASR_ETS_Msk                             (0x1UL << ETH_DMASR_ETS_Pos) /*!< 0x00000400 */
N#define ETH_DMASR_ETS                                 ETH_DMASR_ETS_Msk        /* Early transmit status */
N#define ETH_DMASR_RWTS_Pos                            (9U)                     
N#define ETH_DMASR_RWTS_Msk                            (0x1UL << ETH_DMASR_RWTS_Pos) /*!< 0x00000200 */
N#define ETH_DMASR_RWTS                                ETH_DMASR_RWTS_Msk       /* Receive watchdog timeout status */
N#define ETH_DMASR_RPSS_Pos                            (8U)                     
N#define ETH_DMASR_RPSS_Msk                            (0x1UL << ETH_DMASR_RPSS_Pos) /*!< 0x00000100 */
N#define ETH_DMASR_RPSS                                ETH_DMASR_RPSS_Msk       /* Receive process stopped status */
N#define ETH_DMASR_RBUS_Pos                            (7U)                     
N#define ETH_DMASR_RBUS_Msk                            (0x1UL << ETH_DMASR_RBUS_Pos) /*!< 0x00000080 */
N#define ETH_DMASR_RBUS                                ETH_DMASR_RBUS_Msk       /* Receive buffer unavailable status */
N#define ETH_DMASR_RS_Pos                              (6U)                     
N#define ETH_DMASR_RS_Msk                              (0x1UL << ETH_DMASR_RS_Pos) /*!< 0x00000040 */
N#define ETH_DMASR_RS                                  ETH_DMASR_RS_Msk         /* Receive status */
N#define ETH_DMASR_TUS_Pos                             (5U)                     
N#define ETH_DMASR_TUS_Msk                             (0x1UL << ETH_DMASR_TUS_Pos) /*!< 0x00000020 */
N#define ETH_DMASR_TUS                                 ETH_DMASR_TUS_Msk        /* Transmit underflow status */
N#define ETH_DMASR_ROS_Pos                             (4U)                     
N#define ETH_DMASR_ROS_Msk                             (0x1UL << ETH_DMASR_ROS_Pos) /*!< 0x00000010 */
N#define ETH_DMASR_ROS                                 ETH_DMASR_ROS_Msk        /* Receive overflow status */
N#define ETH_DMASR_TJTS_Pos                            (3U)                     
N#define ETH_DMASR_TJTS_Msk                            (0x1UL << ETH_DMASR_TJTS_Pos) /*!< 0x00000008 */
N#define ETH_DMASR_TJTS                                ETH_DMASR_TJTS_Msk       /* Transmit jabber timeout status */
N#define ETH_DMASR_TBUS_Pos                            (2U)                     
N#define ETH_DMASR_TBUS_Msk                            (0x1UL << ETH_DMASR_TBUS_Pos) /*!< 0x00000004 */
N#define ETH_DMASR_TBUS                                ETH_DMASR_TBUS_Msk       /* Transmit buffer unavailable status */
N#define ETH_DMASR_TPSS_Pos                            (1U)                     
N#define ETH_DMASR_TPSS_Msk                            (0x1UL << ETH_DMASR_TPSS_Pos) /*!< 0x00000002 */
N#define ETH_DMASR_TPSS                                ETH_DMASR_TPSS_Msk       /* Transmit process stopped status */
N#define ETH_DMASR_TS_Pos                              (0U)                     
N#define ETH_DMASR_TS_Msk                              (0x1UL << ETH_DMASR_TS_Pos) /*!< 0x00000001 */
N#define ETH_DMASR_TS                                  ETH_DMASR_TS_Msk         /* Transmit status */
N
N/* Bit definition for Ethernet DMA Operation Mode Register */
N#define ETH_DMAOMR_DTCEFD_Pos                         (26U)                    
N#define ETH_DMAOMR_DTCEFD_Msk                         (0x1UL << ETH_DMAOMR_DTCEFD_Pos) /*!< 0x04000000 */
N#define ETH_DMAOMR_DTCEFD                             ETH_DMAOMR_DTCEFD_Msk    /* Disable Dropping of TCP/IP checksum error frames */
N#define ETH_DMAOMR_RSF_Pos                            (25U)                    
N#define ETH_DMAOMR_RSF_Msk                            (0x1UL << ETH_DMAOMR_RSF_Pos) /*!< 0x02000000 */
N#define ETH_DMAOMR_RSF                                ETH_DMAOMR_RSF_Msk       /* Receive store and forward */
N#define ETH_DMAOMR_DFRF_Pos                           (24U)                    
N#define ETH_DMAOMR_DFRF_Msk                           (0x1UL << ETH_DMAOMR_DFRF_Pos) /*!< 0x01000000 */
N#define ETH_DMAOMR_DFRF                               ETH_DMAOMR_DFRF_Msk      /* Disable flushing of received frames */
N#define ETH_DMAOMR_TSF_Pos                            (21U)                    
N#define ETH_DMAOMR_TSF_Msk                            (0x1UL << ETH_DMAOMR_TSF_Pos) /*!< 0x00200000 */
N#define ETH_DMAOMR_TSF                                ETH_DMAOMR_TSF_Msk       /* Transmit store and forward */
N#define ETH_DMAOMR_FTF_Pos                            (20U)                    
N#define ETH_DMAOMR_FTF_Msk                            (0x1UL << ETH_DMAOMR_FTF_Pos) /*!< 0x00100000 */
N#define ETH_DMAOMR_FTF                                ETH_DMAOMR_FTF_Msk       /* Flush transmit FIFO */
N#define ETH_DMAOMR_TTC_Pos                            (14U)                    
N#define ETH_DMAOMR_TTC_Msk                            (0x7UL << ETH_DMAOMR_TTC_Pos) /*!< 0x0001C000 */
N#define ETH_DMAOMR_TTC                                ETH_DMAOMR_TTC_Msk       /* Transmit threshold control */
N#define ETH_DMAOMR_TTC_64Bytes                        0x00000000U              /* threshold level of the MTL Transmit FIFO is 64 Bytes */
N#define ETH_DMAOMR_TTC_128Bytes                       0x00004000U              /* threshold level of the MTL Transmit FIFO is 128 Bytes */
N#define ETH_DMAOMR_TTC_192Bytes                       0x00008000U              /* threshold level of the MTL Transmit FIFO is 192 Bytes */
N#define ETH_DMAOMR_TTC_256Bytes                       0x0000C000U              /* threshold level of the MTL Transmit FIFO is 256 Bytes */
N#define ETH_DMAOMR_TTC_40Bytes                        0x00010000U              /* threshold level of the MTL Transmit FIFO is 40 Bytes */
N#define ETH_DMAOMR_TTC_32Bytes                        0x00014000U              /* threshold level of the MTL Transmit FIFO is 32 Bytes */
N#define ETH_DMAOMR_TTC_24Bytes                        0x00018000U              /* threshold level of the MTL Transmit FIFO is 24 Bytes */
N#define ETH_DMAOMR_TTC_16Bytes                        0x0001C000U              /* threshold level of the MTL Transmit FIFO is 16 Bytes */
N#define ETH_DMAOMR_ST_Pos                             (13U)                    
N#define ETH_DMAOMR_ST_Msk                             (0x1UL << ETH_DMAOMR_ST_Pos) /*!< 0x00002000 */
N#define ETH_DMAOMR_ST                                 ETH_DMAOMR_ST_Msk        /* Start/stop transmission command */
N#define ETH_DMAOMR_FEF_Pos                            (7U)                     
N#define ETH_DMAOMR_FEF_Msk                            (0x1UL << ETH_DMAOMR_FEF_Pos) /*!< 0x00000080 */
N#define ETH_DMAOMR_FEF                                ETH_DMAOMR_FEF_Msk       /* Forward error frames */
N#define ETH_DMAOMR_FUGF_Pos                           (6U)                     
N#define ETH_DMAOMR_FUGF_Msk                           (0x1UL << ETH_DMAOMR_FUGF_Pos) /*!< 0x00000040 */
N#define ETH_DMAOMR_FUGF                               ETH_DMAOMR_FUGF_Msk      /* Forward undersized good frames */
N#define ETH_DMAOMR_RTC_Pos                            (3U)                     
N#define ETH_DMAOMR_RTC_Msk                            (0x3UL << ETH_DMAOMR_RTC_Pos) /*!< 0x00000018 */
N#define ETH_DMAOMR_RTC                                ETH_DMAOMR_RTC_Msk       /* receive threshold control */
N#define ETH_DMAOMR_RTC_64Bytes                        0x00000000U              /* threshold level of the MTL Receive FIFO is 64 Bytes */
N#define ETH_DMAOMR_RTC_32Bytes                        0x00000008U              /* threshold level of the MTL Receive FIFO is 32 Bytes */
N#define ETH_DMAOMR_RTC_96Bytes                        0x00000010U              /* threshold level of the MTL Receive FIFO is 96 Bytes */
N#define ETH_DMAOMR_RTC_128Bytes                       0x00000018U              /* threshold level of the MTL Receive FIFO is 128 Bytes */
N#define ETH_DMAOMR_OSF_Pos                            (2U)                     
N#define ETH_DMAOMR_OSF_Msk                            (0x1UL << ETH_DMAOMR_OSF_Pos) /*!< 0x00000004 */
N#define ETH_DMAOMR_OSF                                ETH_DMAOMR_OSF_Msk       /* operate on second frame */
N#define ETH_DMAOMR_SR_Pos                             (1U)                     
N#define ETH_DMAOMR_SR_Msk                             (0x1UL << ETH_DMAOMR_SR_Pos) /*!< 0x00000002 */
N#define ETH_DMAOMR_SR                                 ETH_DMAOMR_SR_Msk        /* Start/stop receive */
N
N/* Bit definition for Ethernet DMA Interrupt Enable Register */
N#define ETH_DMAIER_NISE_Pos                           (16U)                    
N#define ETH_DMAIER_NISE_Msk                           (0x1UL << ETH_DMAIER_NISE_Pos) /*!< 0x00010000 */
N#define ETH_DMAIER_NISE                               ETH_DMAIER_NISE_Msk      /* Normal interrupt summary enable */
N#define ETH_DMAIER_AISE_Pos                           (15U)                    
N#define ETH_DMAIER_AISE_Msk                           (0x1UL << ETH_DMAIER_AISE_Pos) /*!< 0x00008000 */
N#define ETH_DMAIER_AISE                               ETH_DMAIER_AISE_Msk      /* Abnormal interrupt summary enable */
N#define ETH_DMAIER_ERIE_Pos                           (14U)                    
N#define ETH_DMAIER_ERIE_Msk                           (0x1UL << ETH_DMAIER_ERIE_Pos) /*!< 0x00004000 */
N#define ETH_DMAIER_ERIE                               ETH_DMAIER_ERIE_Msk      /* Early receive interrupt enable */
N#define ETH_DMAIER_FBEIE_Pos                          (13U)                    
N#define ETH_DMAIER_FBEIE_Msk                          (0x1UL << ETH_DMAIER_FBEIE_Pos) /*!< 0x00002000 */
N#define ETH_DMAIER_FBEIE                              ETH_DMAIER_FBEIE_Msk     /* Fatal bus error interrupt enable */
N#define ETH_DMAIER_ETIE_Pos                           (10U)                    
N#define ETH_DMAIER_ETIE_Msk                           (0x1UL << ETH_DMAIER_ETIE_Pos) /*!< 0x00000400 */
N#define ETH_DMAIER_ETIE                               ETH_DMAIER_ETIE_Msk      /* Early transmit interrupt enable */
N#define ETH_DMAIER_RWTIE_Pos                          (9U)                     
N#define ETH_DMAIER_RWTIE_Msk                          (0x1UL << ETH_DMAIER_RWTIE_Pos) /*!< 0x00000200 */
N#define ETH_DMAIER_RWTIE                              ETH_DMAIER_RWTIE_Msk     /* Receive watchdog timeout interrupt enable */
N#define ETH_DMAIER_RPSIE_Pos                          (8U)                     
N#define ETH_DMAIER_RPSIE_Msk                          (0x1UL << ETH_DMAIER_RPSIE_Pos) /*!< 0x00000100 */
N#define ETH_DMAIER_RPSIE                              ETH_DMAIER_RPSIE_Msk     /* Receive process stopped interrupt enable */
N#define ETH_DMAIER_RBUIE_Pos                          (7U)                     
N#define ETH_DMAIER_RBUIE_Msk                          (0x1UL << ETH_DMAIER_RBUIE_Pos) /*!< 0x00000080 */
N#define ETH_DMAIER_RBUIE                              ETH_DMAIER_RBUIE_Msk     /* Receive buffer unavailable interrupt enable */
N#define ETH_DMAIER_RIE_Pos                            (6U)                     
N#define ETH_DMAIER_RIE_Msk                            (0x1UL << ETH_DMAIER_RIE_Pos) /*!< 0x00000040 */
N#define ETH_DMAIER_RIE                                ETH_DMAIER_RIE_Msk       /* Receive interrupt enable */
N#define ETH_DMAIER_TUIE_Pos                           (5U)                     
N#define ETH_DMAIER_TUIE_Msk                           (0x1UL << ETH_DMAIER_TUIE_Pos) /*!< 0x00000020 */
N#define ETH_DMAIER_TUIE                               ETH_DMAIER_TUIE_Msk      /* Transmit Underflow interrupt enable */
N#define ETH_DMAIER_ROIE_Pos                           (4U)                     
N#define ETH_DMAIER_ROIE_Msk                           (0x1UL << ETH_DMAIER_ROIE_Pos) /*!< 0x00000010 */
N#define ETH_DMAIER_ROIE                               ETH_DMAIER_ROIE_Msk      /* Receive Overflow interrupt enable */
N#define ETH_DMAIER_TJTIE_Pos                          (3U)                     
N#define ETH_DMAIER_TJTIE_Msk                          (0x1UL << ETH_DMAIER_TJTIE_Pos) /*!< 0x00000008 */
N#define ETH_DMAIER_TJTIE                              ETH_DMAIER_TJTIE_Msk     /* Transmit jabber timeout interrupt enable */
N#define ETH_DMAIER_TBUIE_Pos                          (2U)                     
N#define ETH_DMAIER_TBUIE_Msk                          (0x1UL << ETH_DMAIER_TBUIE_Pos) /*!< 0x00000004 */
N#define ETH_DMAIER_TBUIE                              ETH_DMAIER_TBUIE_Msk     /* Transmit buffer unavailable interrupt enable */
N#define ETH_DMAIER_TPSIE_Pos                          (1U)                     
N#define ETH_DMAIER_TPSIE_Msk                          (0x1UL << ETH_DMAIER_TPSIE_Pos) /*!< 0x00000002 */
N#define ETH_DMAIER_TPSIE                              ETH_DMAIER_TPSIE_Msk     /* Transmit process stopped interrupt enable */
N#define ETH_DMAIER_TIE_Pos                            (0U)                     
N#define ETH_DMAIER_TIE_Msk                            (0x1UL << ETH_DMAIER_TIE_Pos) /*!< 0x00000001 */
N#define ETH_DMAIER_TIE                                ETH_DMAIER_TIE_Msk       /* Transmit interrupt enable */
N
N/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */
N#define ETH_DMAMFBOCR_OFOC_Pos                        (28U)                    
N#define ETH_DMAMFBOCR_OFOC_Msk                        (0x1UL << ETH_DMAMFBOCR_OFOC_Pos) /*!< 0x10000000 */
N#define ETH_DMAMFBOCR_OFOC                            ETH_DMAMFBOCR_OFOC_Msk   /* Overflow bit for FIFO overflow counter */
N#define ETH_DMAMFBOCR_MFA_Pos                         (17U)                    
N#define ETH_DMAMFBOCR_MFA_Msk                         (0x7FFUL << ETH_DMAMFBOCR_MFA_Pos) /*!< 0x0FFE0000 */
N#define ETH_DMAMFBOCR_MFA                             ETH_DMAMFBOCR_MFA_Msk    /* Number of frames missed by the application */
N#define ETH_DMAMFBOCR_OMFC_Pos                        (16U)                    
N#define ETH_DMAMFBOCR_OMFC_Msk                        (0x1UL << ETH_DMAMFBOCR_OMFC_Pos) /*!< 0x00010000 */
N#define ETH_DMAMFBOCR_OMFC                            ETH_DMAMFBOCR_OMFC_Msk   /* Overflow bit for missed frame counter */
N#define ETH_DMAMFBOCR_MFC_Pos                         (0U)                     
N#define ETH_DMAMFBOCR_MFC_Msk                         (0xFFFFUL << ETH_DMAMFBOCR_MFC_Pos) /*!< 0x0000FFFF */
N#define ETH_DMAMFBOCR_MFC                             ETH_DMAMFBOCR_MFC_Msk    /* Number of frames missed by the controller */
N
N/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */
N#define ETH_DMACHTDR_HTDAP_Pos                        (0U)                     
N#define ETH_DMACHTDR_HTDAP_Msk                        (0xFFFFFFFFUL << ETH_DMACHTDR_HTDAP_Pos) /*!< 0xFFFFFFFF */
N#define ETH_DMACHTDR_HTDAP                            ETH_DMACHTDR_HTDAP_Msk   /* Host transmit descriptor address pointer */
N
N/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */
N#define ETH_DMACHRDR_HRDAP_Pos                        (0U)                     
N#define ETH_DMACHRDR_HRDAP_Msk                        (0xFFFFFFFFUL << ETH_DMACHRDR_HRDAP_Pos) /*!< 0xFFFFFFFF */
N#define ETH_DMACHRDR_HRDAP                            ETH_DMACHRDR_HRDAP_Msk   /* Host receive descriptor address pointer */
N
N/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */
N#define ETH_DMACHTBAR_HTBAP_Pos                       (0U)                     
N#define ETH_DMACHTBAR_HTBAP_Msk                       (0xFFFFFFFFUL << ETH_DMACHTBAR_HTBAP_Pos) /*!< 0xFFFFFFFF */
N#define ETH_DMACHTBAR_HTBAP                           ETH_DMACHTBAR_HTBAP_Msk  /* Host transmit buffer address pointer */
N
N/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */
N#define ETH_DMACHRBAR_HRBAP_Pos                       (0U)                     
N#define ETH_DMACHRBAR_HRBAP_Msk                       (0xFFFFFFFFUL << ETH_DMACHRBAR_HRBAP_Pos) /*!< 0xFFFFFFFF */
N#define ETH_DMACHRBAR_HRBAP                           ETH_DMACHRBAR_HRBAP_Msk  /* Host receive buffer address pointer */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                       USB_OTG                              */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for USB_OTG_GOTGCTL register  ***********/
N#define USB_OTG_GOTGCTL_SRQSCS_Pos               (0U)                          
N#define USB_OTG_GOTGCTL_SRQSCS_Msk               (0x1UL << USB_OTG_GOTGCTL_SRQSCS_Pos) /*!< 0x00000001 */
N#define USB_OTG_GOTGCTL_SRQSCS                   USB_OTG_GOTGCTL_SRQSCS_Msk    /*!< Session request success */
N#define USB_OTG_GOTGCTL_SRQ_Pos                  (1U)                          
N#define USB_OTG_GOTGCTL_SRQ_Msk                  (0x1UL << USB_OTG_GOTGCTL_SRQ_Pos) /*!< 0x00000002 */
N#define USB_OTG_GOTGCTL_SRQ                      USB_OTG_GOTGCTL_SRQ_Msk       /*!< Session request */
N#define USB_OTG_GOTGCTL_HNGSCS_Pos               (8U)                          
N#define USB_OTG_GOTGCTL_HNGSCS_Msk               (0x1UL << USB_OTG_GOTGCTL_HNGSCS_Pos) /*!< 0x00000100 */
N#define USB_OTG_GOTGCTL_HNGSCS                   USB_OTG_GOTGCTL_HNGSCS_Msk    /*!< Host set HNP enable */
N#define USB_OTG_GOTGCTL_HNPRQ_Pos                (9U)                          
N#define USB_OTG_GOTGCTL_HNPRQ_Msk                (0x1UL << USB_OTG_GOTGCTL_HNPRQ_Pos) /*!< 0x00000200 */
N#define USB_OTG_GOTGCTL_HNPRQ                    USB_OTG_GOTGCTL_HNPRQ_Msk     /*!< HNP request */
N#define USB_OTG_GOTGCTL_HSHNPEN_Pos              (10U)                         
N#define USB_OTG_GOTGCTL_HSHNPEN_Msk              (0x1UL << USB_OTG_GOTGCTL_HSHNPEN_Pos) /*!< 0x00000400 */
N#define USB_OTG_GOTGCTL_HSHNPEN                  USB_OTG_GOTGCTL_HSHNPEN_Msk   /*!< Host set HNP enable */
N#define USB_OTG_GOTGCTL_DHNPEN_Pos               (11U)                         
N#define USB_OTG_GOTGCTL_DHNPEN_Msk               (0x1UL << USB_OTG_GOTGCTL_DHNPEN_Pos) /*!< 0x00000800 */
N#define USB_OTG_GOTGCTL_DHNPEN                   USB_OTG_GOTGCTL_DHNPEN_Msk    /*!< Device HNP enabled */
N#define USB_OTG_GOTGCTL_CIDSTS_Pos               (16U)                         
N#define USB_OTG_GOTGCTL_CIDSTS_Msk               (0x1UL << USB_OTG_GOTGCTL_CIDSTS_Pos) /*!< 0x00010000 */
N#define USB_OTG_GOTGCTL_CIDSTS                   USB_OTG_GOTGCTL_CIDSTS_Msk    /*!< Connector ID status */
N#define USB_OTG_GOTGCTL_DBCT_Pos                 (17U)                         
N#define USB_OTG_GOTGCTL_DBCT_Msk                 (0x1UL << USB_OTG_GOTGCTL_DBCT_Pos) /*!< 0x00020000 */
N#define USB_OTG_GOTGCTL_DBCT                     USB_OTG_GOTGCTL_DBCT_Msk      /*!< Long/short debounce time */
N#define USB_OTG_GOTGCTL_ASVLD_Pos                (18U)                         
N#define USB_OTG_GOTGCTL_ASVLD_Msk                (0x1UL << USB_OTG_GOTGCTL_ASVLD_Pos) /*!< 0x00040000 */
N#define USB_OTG_GOTGCTL_ASVLD                    USB_OTG_GOTGCTL_ASVLD_Msk     /*!< A-session valid  */
N#define USB_OTG_GOTGCTL_BSVLD_Pos                (19U)                         
N#define USB_OTG_GOTGCTL_BSVLD_Msk                (0x1UL << USB_OTG_GOTGCTL_BSVLD_Pos) /*!< 0x00080000 */
N#define USB_OTG_GOTGCTL_BSVLD                    USB_OTG_GOTGCTL_BSVLD_Msk     /*!< B-session valid */
N
N/********************  Bit definition forUSB_OTG_HCFG register  ********************/
N
N#define USB_OTG_HCFG_FSLSPCS_Pos                 (0U)                          
N#define USB_OTG_HCFG_FSLSPCS_Msk                 (0x3UL << USB_OTG_HCFG_FSLSPCS_Pos) /*!< 0x00000003 */
N#define USB_OTG_HCFG_FSLSPCS                     USB_OTG_HCFG_FSLSPCS_Msk      /*!< FS/LS PHY clock select  */
N#define USB_OTG_HCFG_FSLSPCS_0                   (0x1UL << USB_OTG_HCFG_FSLSPCS_Pos) /*!< 0x00000001 */
N#define USB_OTG_HCFG_FSLSPCS_1                   (0x2UL << USB_OTG_HCFG_FSLSPCS_Pos) /*!< 0x00000002 */
N#define USB_OTG_HCFG_FSLSS_Pos                   (2U)                          
N#define USB_OTG_HCFG_FSLSS_Msk                   (0x1UL << USB_OTG_HCFG_FSLSS_Pos) /*!< 0x00000004 */
N#define USB_OTG_HCFG_FSLSS                       USB_OTG_HCFG_FSLSS_Msk        /*!< FS- and LS-only support */
N
N/********************  Bit definition for USB_OTG_DCFG register  ********************/
N
N#define USB_OTG_DCFG_DSPD_Pos                    (0U)                          
N#define USB_OTG_DCFG_DSPD_Msk                    (0x3UL << USB_OTG_DCFG_DSPD_Pos) /*!< 0x00000003 */
N#define USB_OTG_DCFG_DSPD                        USB_OTG_DCFG_DSPD_Msk         /*!< Device speed */
N#define USB_OTG_DCFG_DSPD_0                      (0x1UL << USB_OTG_DCFG_DSPD_Pos) /*!< 0x00000001 */
N#define USB_OTG_DCFG_DSPD_1                      (0x2UL << USB_OTG_DCFG_DSPD_Pos) /*!< 0x00000002 */
N#define USB_OTG_DCFG_NZLSOHSK_Pos                (2U)                          
N#define USB_OTG_DCFG_NZLSOHSK_Msk                (0x1UL << USB_OTG_DCFG_NZLSOHSK_Pos) /*!< 0x00000004 */
N#define USB_OTG_DCFG_NZLSOHSK                    USB_OTG_DCFG_NZLSOHSK_Msk     /*!< Nonzero-length status OUT handshake */
N
N#define USB_OTG_DCFG_DAD_Pos                     (4U)                          
N#define USB_OTG_DCFG_DAD_Msk                     (0x7FUL << USB_OTG_DCFG_DAD_Pos) /*!< 0x000007F0 */
N#define USB_OTG_DCFG_DAD                         USB_OTG_DCFG_DAD_Msk          /*!< Device address */
N#define USB_OTG_DCFG_DAD_0                       (0x01UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000010 */
N#define USB_OTG_DCFG_DAD_1                       (0x02UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000020 */
N#define USB_OTG_DCFG_DAD_2                       (0x04UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000040 */
N#define USB_OTG_DCFG_DAD_3                       (0x08UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000080 */
N#define USB_OTG_DCFG_DAD_4                       (0x10UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000100 */
N#define USB_OTG_DCFG_DAD_5                       (0x20UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000200 */
N#define USB_OTG_DCFG_DAD_6                       (0x40UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000400 */
N
N#define USB_OTG_DCFG_PFIVL_Pos                   (11U)                         
N#define USB_OTG_DCFG_PFIVL_Msk                   (0x3UL << USB_OTG_DCFG_PFIVL_Pos) /*!< 0x00001800 */
N#define USB_OTG_DCFG_PFIVL                       USB_OTG_DCFG_PFIVL_Msk        /*!< Periodic (micro)frame interval */
N#define USB_OTG_DCFG_PFIVL_0                     (0x1UL << USB_OTG_DCFG_PFIVL_Pos) /*!< 0x00000800 */
N#define USB_OTG_DCFG_PFIVL_1                     (0x2UL << USB_OTG_DCFG_PFIVL_Pos) /*!< 0x00001000 */
N
N#define USB_OTG_DCFG_XCVRDLY_Pos                 (14U)                         
N#define USB_OTG_DCFG_XCVRDLY_Msk                 (0x1UL << USB_OTG_DCFG_XCVRDLY_Pos) /*!< 0x00004000 */
N#define USB_OTG_DCFG_XCVRDLY                     USB_OTG_DCFG_XCVRDLY_Msk        /*!< Transceiver delay */
N
N#define USB_OTG_DCFG_ERRATIM_Pos                 (15U)                         
N#define USB_OTG_DCFG_ERRATIM_Msk                 (0x1UL << USB_OTG_DCFG_ERRATIM_Pos) /*!< 0x00008000 */
N#define USB_OTG_DCFG_ERRATIM                     USB_OTG_DCFG_ERRATIM_Msk        /*!< Erratic error interrupt mask */
N
N#define USB_OTG_DCFG_PERSCHIVL_Pos               (24U)                         
N#define USB_OTG_DCFG_PERSCHIVL_Msk               (0x3UL << USB_OTG_DCFG_PERSCHIVL_Pos) /*!< 0x03000000 */
N#define USB_OTG_DCFG_PERSCHIVL                   USB_OTG_DCFG_PERSCHIVL_Msk    /*!< Periodic scheduling interval */
N#define USB_OTG_DCFG_PERSCHIVL_0                 (0x1UL << USB_OTG_DCFG_PERSCHIVL_Pos) /*!< 0x01000000 */
N#define USB_OTG_DCFG_PERSCHIVL_1                 (0x2UL << USB_OTG_DCFG_PERSCHIVL_Pos) /*!< 0x02000000 */
N
N/********************  Bit definition for USB_OTG_PCGCR register  ********************/
N#define USB_OTG_PCGCR_STPPCLK_Pos                (0U)                          
N#define USB_OTG_PCGCR_STPPCLK_Msk                (0x1UL << USB_OTG_PCGCR_STPPCLK_Pos) /*!< 0x00000001 */
N#define USB_OTG_PCGCR_STPPCLK                    USB_OTG_PCGCR_STPPCLK_Msk     /*!< Stop PHY clock */
N#define USB_OTG_PCGCR_GATEHCLK_Pos               (1U)                          
N#define USB_OTG_PCGCR_GATEHCLK_Msk               (0x1UL << USB_OTG_PCGCR_GATEHCLK_Pos) /*!< 0x00000002 */
N#define USB_OTG_PCGCR_GATEHCLK                   USB_OTG_PCGCR_GATEHCLK_Msk    /*!< Gate HCLK */
N#define USB_OTG_PCGCR_PHYSUSP_Pos                (4U)                          
N#define USB_OTG_PCGCR_PHYSUSP_Msk                (0x1UL << USB_OTG_PCGCR_PHYSUSP_Pos) /*!< 0x00000010 */
N#define USB_OTG_PCGCR_PHYSUSP                    USB_OTG_PCGCR_PHYSUSP_Msk     /*!< PHY suspended */
N
N/********************  Bit definition for USB_OTG_GOTGINT register  ********************/
N#define USB_OTG_GOTGINT_SEDET_Pos                (2U)                          
N#define USB_OTG_GOTGINT_SEDET_Msk                (0x1UL << USB_OTG_GOTGINT_SEDET_Pos) /*!< 0x00000004 */
N#define USB_OTG_GOTGINT_SEDET                    USB_OTG_GOTGINT_SEDET_Msk     /*!< Session end detected                   */
N#define USB_OTG_GOTGINT_SRSSCHG_Pos              (8U)                          
N#define USB_OTG_GOTGINT_SRSSCHG_Msk              (0x1UL << USB_OTG_GOTGINT_SRSSCHG_Pos) /*!< 0x00000100 */
N#define USB_OTG_GOTGINT_SRSSCHG                  USB_OTG_GOTGINT_SRSSCHG_Msk   /*!< Session request success status change  */
N#define USB_OTG_GOTGINT_HNSSCHG_Pos              (9U)                          
N#define USB_OTG_GOTGINT_HNSSCHG_Msk              (0x1UL << USB_OTG_GOTGINT_HNSSCHG_Pos) /*!< 0x00000200 */
N#define USB_OTG_GOTGINT_HNSSCHG                  USB_OTG_GOTGINT_HNSSCHG_Msk   /*!< Host negotiation success status change */
N#define USB_OTG_GOTGINT_HNGDET_Pos               (17U)                         
N#define USB_OTG_GOTGINT_HNGDET_Msk               (0x1UL << USB_OTG_GOTGINT_HNGDET_Pos) /*!< 0x00020000 */
N#define USB_OTG_GOTGINT_HNGDET                   USB_OTG_GOTGINT_HNGDET_Msk    /*!< Host negotiation detected              */
N#define USB_OTG_GOTGINT_ADTOCHG_Pos              (18U)                         
N#define USB_OTG_GOTGINT_ADTOCHG_Msk              (0x1UL << USB_OTG_GOTGINT_ADTOCHG_Pos) /*!< 0x00040000 */
N#define USB_OTG_GOTGINT_ADTOCHG                  USB_OTG_GOTGINT_ADTOCHG_Msk   /*!< A-device timeout change                */
N#define USB_OTG_GOTGINT_DBCDNE_Pos               (19U)                         
N#define USB_OTG_GOTGINT_DBCDNE_Msk               (0x1UL << USB_OTG_GOTGINT_DBCDNE_Pos) /*!< 0x00080000 */
N#define USB_OTG_GOTGINT_DBCDNE                   USB_OTG_GOTGINT_DBCDNE_Msk    /*!< Debounce done                          */
N
N/********************  Bit definition for USB_OTG_DCTL register  ********************/
N#define USB_OTG_DCTL_RWUSIG_Pos                  (0U)                          
N#define USB_OTG_DCTL_RWUSIG_Msk                  (0x1UL << USB_OTG_DCTL_RWUSIG_Pos) /*!< 0x00000001 */
N#define USB_OTG_DCTL_RWUSIG                      USB_OTG_DCTL_RWUSIG_Msk       /*!< Remote wakeup signaling */
N#define USB_OTG_DCTL_SDIS_Pos                    (1U)                          
N#define USB_OTG_DCTL_SDIS_Msk                    (0x1UL << USB_OTG_DCTL_SDIS_Pos) /*!< 0x00000002 */
N#define USB_OTG_DCTL_SDIS                        USB_OTG_DCTL_SDIS_Msk         /*!< Soft disconnect         */
N#define USB_OTG_DCTL_GINSTS_Pos                  (2U)                          
N#define USB_OTG_DCTL_GINSTS_Msk                  (0x1UL << USB_OTG_DCTL_GINSTS_Pos) /*!< 0x00000004 */
N#define USB_OTG_DCTL_GINSTS                      USB_OTG_DCTL_GINSTS_Msk       /*!< Global IN NAK status    */
N#define USB_OTG_DCTL_GONSTS_Pos                  (3U)                          
N#define USB_OTG_DCTL_GONSTS_Msk                  (0x1UL << USB_OTG_DCTL_GONSTS_Pos) /*!< 0x00000008 */
N#define USB_OTG_DCTL_GONSTS                      USB_OTG_DCTL_GONSTS_Msk       /*!< Global OUT NAK status   */
N
N#define USB_OTG_DCTL_TCTL_Pos                    (4U)                          
N#define USB_OTG_DCTL_TCTL_Msk                    (0x7UL << USB_OTG_DCTL_TCTL_Pos) /*!< 0x00000070 */
N#define USB_OTG_DCTL_TCTL                        USB_OTG_DCTL_TCTL_Msk         /*!< Test control */
N#define USB_OTG_DCTL_TCTL_0                      (0x1UL << USB_OTG_DCTL_TCTL_Pos) /*!< 0x00000010 */
N#define USB_OTG_DCTL_TCTL_1                      (0x2UL << USB_OTG_DCTL_TCTL_Pos) /*!< 0x00000020 */
N#define USB_OTG_DCTL_TCTL_2                      (0x4UL << USB_OTG_DCTL_TCTL_Pos) /*!< 0x00000040 */
N#define USB_OTG_DCTL_SGINAK_Pos                  (7U)                          
N#define USB_OTG_DCTL_SGINAK_Msk                  (0x1UL << USB_OTG_DCTL_SGINAK_Pos) /*!< 0x00000080 */
N#define USB_OTG_DCTL_SGINAK                      USB_OTG_DCTL_SGINAK_Msk       /*!< Set global IN NAK         */
N#define USB_OTG_DCTL_CGINAK_Pos                  (8U)                          
N#define USB_OTG_DCTL_CGINAK_Msk                  (0x1UL << USB_OTG_DCTL_CGINAK_Pos) /*!< 0x00000100 */
N#define USB_OTG_DCTL_CGINAK                      USB_OTG_DCTL_CGINAK_Msk       /*!< Clear global IN NAK       */
N#define USB_OTG_DCTL_SGONAK_Pos                  (9U)                          
N#define USB_OTG_DCTL_SGONAK_Msk                  (0x1UL << USB_OTG_DCTL_SGONAK_Pos) /*!< 0x00000200 */
N#define USB_OTG_DCTL_SGONAK                      USB_OTG_DCTL_SGONAK_Msk       /*!< Set global OUT NAK        */
N#define USB_OTG_DCTL_CGONAK_Pos                  (10U)                         
N#define USB_OTG_DCTL_CGONAK_Msk                  (0x1UL << USB_OTG_DCTL_CGONAK_Pos) /*!< 0x00000400 */
N#define USB_OTG_DCTL_CGONAK                      USB_OTG_DCTL_CGONAK_Msk       /*!< Clear global OUT NAK      */
N#define USB_OTG_DCTL_POPRGDNE_Pos                (11U)                         
N#define USB_OTG_DCTL_POPRGDNE_Msk                (0x1UL << USB_OTG_DCTL_POPRGDNE_Pos) /*!< 0x00000800 */
N#define USB_OTG_DCTL_POPRGDNE                    USB_OTG_DCTL_POPRGDNE_Msk     /*!< Power-on programming done */
N
N/********************  Bit definition for USB_OTG_HFIR register  ********************/
N#define USB_OTG_HFIR_FRIVL_Pos                   (0U)                          
N#define USB_OTG_HFIR_FRIVL_Msk                   (0xFFFFUL << USB_OTG_HFIR_FRIVL_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HFIR_FRIVL                       USB_OTG_HFIR_FRIVL_Msk        /*!< Frame interval */
N
N/********************  Bit definition for USB_OTG_HFNUM register  ********************/
N#define USB_OTG_HFNUM_FRNUM_Pos                  (0U)                          
N#define USB_OTG_HFNUM_FRNUM_Msk                  (0xFFFFUL << USB_OTG_HFNUM_FRNUM_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HFNUM_FRNUM                      USB_OTG_HFNUM_FRNUM_Msk       /*!< Frame number         */
N#define USB_OTG_HFNUM_FTREM_Pos                  (16U)                         
N#define USB_OTG_HFNUM_FTREM_Msk                  (0xFFFFUL << USB_OTG_HFNUM_FTREM_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_HFNUM_FTREM                      USB_OTG_HFNUM_FTREM_Msk       /*!< Frame time remaining */
N
N/********************  Bit definition for USB_OTG_DSTS register  ********************/
N#define USB_OTG_DSTS_SUSPSTS_Pos                 (0U)                          
N#define USB_OTG_DSTS_SUSPSTS_Msk                 (0x1UL << USB_OTG_DSTS_SUSPSTS_Pos) /*!< 0x00000001 */
N#define USB_OTG_DSTS_SUSPSTS                     USB_OTG_DSTS_SUSPSTS_Msk      /*!< Suspend status   */
N
N#define USB_OTG_DSTS_ENUMSPD_Pos                 (1U)                          
N#define USB_OTG_DSTS_ENUMSPD_Msk                 (0x3UL << USB_OTG_DSTS_ENUMSPD_Pos) /*!< 0x00000006 */
N#define USB_OTG_DSTS_ENUMSPD                     USB_OTG_DSTS_ENUMSPD_Msk      /*!< Enumerated speed */
N#define USB_OTG_DSTS_ENUMSPD_0                   (0x1UL << USB_OTG_DSTS_ENUMSPD_Pos) /*!< 0x00000002 */
N#define USB_OTG_DSTS_ENUMSPD_1                   (0x2UL << USB_OTG_DSTS_ENUMSPD_Pos) /*!< 0x00000004 */
N#define USB_OTG_DSTS_EERR_Pos                    (3U)                          
N#define USB_OTG_DSTS_EERR_Msk                    (0x1UL << USB_OTG_DSTS_EERR_Pos) /*!< 0x00000008 */
N#define USB_OTG_DSTS_EERR                        USB_OTG_DSTS_EERR_Msk         /*!< Erratic error     */
N#define USB_OTG_DSTS_FNSOF_Pos                   (8U)                          
N#define USB_OTG_DSTS_FNSOF_Msk                   (0x3FFFUL << USB_OTG_DSTS_FNSOF_Pos) /*!< 0x003FFF00 */
N#define USB_OTG_DSTS_FNSOF                       USB_OTG_DSTS_FNSOF_Msk        /*!< Frame number of the received SOF */
N
N/********************  Bit definition for USB_OTG_GAHBCFG register  ********************/
N#define USB_OTG_GAHBCFG_GINT_Pos                 (0U)                          
N#define USB_OTG_GAHBCFG_GINT_Msk                 (0x1UL << USB_OTG_GAHBCFG_GINT_Pos) /*!< 0x00000001 */
N#define USB_OTG_GAHBCFG_GINT                     USB_OTG_GAHBCFG_GINT_Msk      /*!< Global interrupt mask */
N#define USB_OTG_GAHBCFG_HBSTLEN_Pos              (1U)                          
N#define USB_OTG_GAHBCFG_HBSTLEN_Msk              (0xFUL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< 0x0000001E */
N#define USB_OTG_GAHBCFG_HBSTLEN                  USB_OTG_GAHBCFG_HBSTLEN_Msk   /*!< Burst length/type */
N#define USB_OTG_GAHBCFG_HBSTLEN_0                (0x0UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< Single */
N#define USB_OTG_GAHBCFG_HBSTLEN_1                (0x1UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< INCR */
N#define USB_OTG_GAHBCFG_HBSTLEN_2                (0x3UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< INCR4 */
N#define USB_OTG_GAHBCFG_HBSTLEN_3                (0x5UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< INCR8 */
N#define USB_OTG_GAHBCFG_HBSTLEN_4                (0x7UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< INCR16 */
N#define USB_OTG_GAHBCFG_DMAEN_Pos                (5U)                          
N#define USB_OTG_GAHBCFG_DMAEN_Msk                (0x1UL << USB_OTG_GAHBCFG_DMAEN_Pos) /*!< 0x00000020 */
N#define USB_OTG_GAHBCFG_DMAEN                    USB_OTG_GAHBCFG_DMAEN_Msk     /*!< DMA enable */
N#define USB_OTG_GAHBCFG_TXFELVL_Pos              (7U)                          
N#define USB_OTG_GAHBCFG_TXFELVL_Msk              (0x1UL << USB_OTG_GAHBCFG_TXFELVL_Pos) /*!< 0x00000080 */
N#define USB_OTG_GAHBCFG_TXFELVL                  USB_OTG_GAHBCFG_TXFELVL_Msk   /*!< TxFIFO empty level */
N#define USB_OTG_GAHBCFG_PTXFELVL_Pos             (8U)                          
N#define USB_OTG_GAHBCFG_PTXFELVL_Msk             (0x1UL << USB_OTG_GAHBCFG_PTXFELVL_Pos) /*!< 0x00000100 */
N#define USB_OTG_GAHBCFG_PTXFELVL                 USB_OTG_GAHBCFG_PTXFELVL_Msk  /*!< Periodic TxFIFO empty level */
N
N/********************  Bit definition for USB_OTG_GUSBCFG register  ********************/
N
N#define USB_OTG_GUSBCFG_TOCAL_Pos                (0U)                          
N#define USB_OTG_GUSBCFG_TOCAL_Msk                (0x7UL << USB_OTG_GUSBCFG_TOCAL_Pos) /*!< 0x00000007 */
N#define USB_OTG_GUSBCFG_TOCAL                    USB_OTG_GUSBCFG_TOCAL_Msk     /*!< FS timeout calibration */
N#define USB_OTG_GUSBCFG_TOCAL_0                  (0x1UL << USB_OTG_GUSBCFG_TOCAL_Pos) /*!< 0x00000001 */
N#define USB_OTG_GUSBCFG_TOCAL_1                  (0x2UL << USB_OTG_GUSBCFG_TOCAL_Pos) /*!< 0x00000002 */
N#define USB_OTG_GUSBCFG_TOCAL_2                  (0x4UL << USB_OTG_GUSBCFG_TOCAL_Pos) /*!< 0x00000004 */
N#define USB_OTG_GUSBCFG_PHYSEL_Pos               (6U)                          
N#define USB_OTG_GUSBCFG_PHYSEL_Msk               (0x1UL << USB_OTG_GUSBCFG_PHYSEL_Pos) /*!< 0x00000040 */
N#define USB_OTG_GUSBCFG_PHYSEL                   USB_OTG_GUSBCFG_PHYSEL_Msk    /*!< USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
N#define USB_OTG_GUSBCFG_SRPCAP_Pos               (8U)                          
N#define USB_OTG_GUSBCFG_SRPCAP_Msk               (0x1UL << USB_OTG_GUSBCFG_SRPCAP_Pos) /*!< 0x00000100 */
N#define USB_OTG_GUSBCFG_SRPCAP                   USB_OTG_GUSBCFG_SRPCAP_Msk    /*!< SRP-capable */
N#define USB_OTG_GUSBCFG_HNPCAP_Pos               (9U)                          
N#define USB_OTG_GUSBCFG_HNPCAP_Msk               (0x1UL << USB_OTG_GUSBCFG_HNPCAP_Pos) /*!< 0x00000200 */
N#define USB_OTG_GUSBCFG_HNPCAP                   USB_OTG_GUSBCFG_HNPCAP_Msk    /*!< HNP-capable */
N#define USB_OTG_GUSBCFG_TRDT_Pos                 (10U)                         
N#define USB_OTG_GUSBCFG_TRDT_Msk                 (0xFUL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00003C00 */
N#define USB_OTG_GUSBCFG_TRDT                     USB_OTG_GUSBCFG_TRDT_Msk      /*!< USB turnaround time */
N#define USB_OTG_GUSBCFG_TRDT_0                   (0x1UL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00000400 */
N#define USB_OTG_GUSBCFG_TRDT_1                   (0x2UL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00000800 */
N#define USB_OTG_GUSBCFG_TRDT_2                   (0x4UL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00001000 */
N#define USB_OTG_GUSBCFG_TRDT_3                   (0x8UL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00002000 */
N#define USB_OTG_GUSBCFG_PHYLPCS_Pos              (15U)                         
N#define USB_OTG_GUSBCFG_PHYLPCS_Msk              (0x1UL << USB_OTG_GUSBCFG_PHYLPCS_Pos) /*!< 0x00008000 */
N#define USB_OTG_GUSBCFG_PHYLPCS                  USB_OTG_GUSBCFG_PHYLPCS_Msk   /*!< PHY Low-power clock select */
N#define USB_OTG_GUSBCFG_ULPIFSLS_Pos             (17U)                         
N#define USB_OTG_GUSBCFG_ULPIFSLS_Msk             (0x1UL << USB_OTG_GUSBCFG_ULPIFSLS_Pos) /*!< 0x00020000 */
N#define USB_OTG_GUSBCFG_ULPIFSLS                 USB_OTG_GUSBCFG_ULPIFSLS_Msk  /*!< ULPI FS/LS select               */
N#define USB_OTG_GUSBCFG_ULPIAR_Pos               (18U)                         
N#define USB_OTG_GUSBCFG_ULPIAR_Msk               (0x1UL << USB_OTG_GUSBCFG_ULPIAR_Pos) /*!< 0x00040000 */
N#define USB_OTG_GUSBCFG_ULPIAR                   USB_OTG_GUSBCFG_ULPIAR_Msk    /*!< ULPI Auto-resume                */
N#define USB_OTG_GUSBCFG_ULPICSM_Pos              (19U)                         
N#define USB_OTG_GUSBCFG_ULPICSM_Msk              (0x1UL << USB_OTG_GUSBCFG_ULPICSM_Pos) /*!< 0x00080000 */
N#define USB_OTG_GUSBCFG_ULPICSM                  USB_OTG_GUSBCFG_ULPICSM_Msk   /*!< ULPI Clock SuspendM             */
N#define USB_OTG_GUSBCFG_ULPIEVBUSD_Pos           (20U)                         
N#define USB_OTG_GUSBCFG_ULPIEVBUSD_Msk           (0x1UL << USB_OTG_GUSBCFG_ULPIEVBUSD_Pos) /*!< 0x00100000 */
N#define USB_OTG_GUSBCFG_ULPIEVBUSD               USB_OTG_GUSBCFG_ULPIEVBUSD_Msk /*!< ULPI External VBUS Drive        */
N#define USB_OTG_GUSBCFG_ULPIEVBUSI_Pos           (21U)                         
N#define USB_OTG_GUSBCFG_ULPIEVBUSI_Msk           (0x1UL << USB_OTG_GUSBCFG_ULPIEVBUSI_Pos) /*!< 0x00200000 */
N#define USB_OTG_GUSBCFG_ULPIEVBUSI               USB_OTG_GUSBCFG_ULPIEVBUSI_Msk /*!< ULPI external VBUS indicator    */
N#define USB_OTG_GUSBCFG_TSDPS_Pos                (22U)                         
N#define USB_OTG_GUSBCFG_TSDPS_Msk                (0x1UL << USB_OTG_GUSBCFG_TSDPS_Pos) /*!< 0x00400000 */
N#define USB_OTG_GUSBCFG_TSDPS                    USB_OTG_GUSBCFG_TSDPS_Msk     /*!< TermSel DLine pulsing selection */
N#define USB_OTG_GUSBCFG_PCCI_Pos                 (23U)                         
N#define USB_OTG_GUSBCFG_PCCI_Msk                 (0x1UL << USB_OTG_GUSBCFG_PCCI_Pos) /*!< 0x00800000 */
N#define USB_OTG_GUSBCFG_PCCI                     USB_OTG_GUSBCFG_PCCI_Msk      /*!< Indicator complement            */
N#define USB_OTG_GUSBCFG_PTCI_Pos                 (24U)                         
N#define USB_OTG_GUSBCFG_PTCI_Msk                 (0x1UL << USB_OTG_GUSBCFG_PTCI_Pos) /*!< 0x01000000 */
N#define USB_OTG_GUSBCFG_PTCI                     USB_OTG_GUSBCFG_PTCI_Msk      /*!< Indicator pass through          */
N#define USB_OTG_GUSBCFG_ULPIIPD_Pos              (25U)                         
N#define USB_OTG_GUSBCFG_ULPIIPD_Msk              (0x1UL << USB_OTG_GUSBCFG_ULPIIPD_Pos) /*!< 0x02000000 */
N#define USB_OTG_GUSBCFG_ULPIIPD                  USB_OTG_GUSBCFG_ULPIIPD_Msk   /*!< ULPI interface protect disable  */
N#define USB_OTG_GUSBCFG_FHMOD_Pos                (29U)                         
N#define USB_OTG_GUSBCFG_FHMOD_Msk                (0x1UL << USB_OTG_GUSBCFG_FHMOD_Pos) /*!< 0x20000000 */
N#define USB_OTG_GUSBCFG_FHMOD                    USB_OTG_GUSBCFG_FHMOD_Msk     /*!< Forced host mode                */
N#define USB_OTG_GUSBCFG_FDMOD_Pos                (30U)                         
N#define USB_OTG_GUSBCFG_FDMOD_Msk                (0x1UL << USB_OTG_GUSBCFG_FDMOD_Pos) /*!< 0x40000000 */
N#define USB_OTG_GUSBCFG_FDMOD                    USB_OTG_GUSBCFG_FDMOD_Msk     /*!< Forced peripheral mode          */
N#define USB_OTG_GUSBCFG_CTXPKT_Pos               (31U)                         
N#define USB_OTG_GUSBCFG_CTXPKT_Msk               (0x1UL << USB_OTG_GUSBCFG_CTXPKT_Pos) /*!< 0x80000000 */
N#define USB_OTG_GUSBCFG_CTXPKT                   USB_OTG_GUSBCFG_CTXPKT_Msk    /*!< Corrupt Tx packet               */
N
N/********************  Bit definition for USB_OTG_GRSTCTL register  ********************/
N#define USB_OTG_GRSTCTL_CSRST_Pos                (0U)                          
N#define USB_OTG_GRSTCTL_CSRST_Msk                (0x1UL << USB_OTG_GRSTCTL_CSRST_Pos) /*!< 0x00000001 */
N#define USB_OTG_GRSTCTL_CSRST                    USB_OTG_GRSTCTL_CSRST_Msk     /*!< Core soft reset          */
N#define USB_OTG_GRSTCTL_HSRST_Pos                (1U)                          
N#define USB_OTG_GRSTCTL_HSRST_Msk                (0x1UL << USB_OTG_GRSTCTL_HSRST_Pos) /*!< 0x00000002 */
N#define USB_OTG_GRSTCTL_HSRST                    USB_OTG_GRSTCTL_HSRST_Msk     /*!< HCLK soft reset          */
N#define USB_OTG_GRSTCTL_FCRST_Pos                (2U)                          
N#define USB_OTG_GRSTCTL_FCRST_Msk                (0x1UL << USB_OTG_GRSTCTL_FCRST_Pos) /*!< 0x00000004 */
N#define USB_OTG_GRSTCTL_FCRST                    USB_OTG_GRSTCTL_FCRST_Msk     /*!< Host frame counter reset */
N#define USB_OTG_GRSTCTL_RXFFLSH_Pos              (4U)                          
N#define USB_OTG_GRSTCTL_RXFFLSH_Msk              (0x1UL << USB_OTG_GRSTCTL_RXFFLSH_Pos) /*!< 0x00000010 */
N#define USB_OTG_GRSTCTL_RXFFLSH                  USB_OTG_GRSTCTL_RXFFLSH_Msk   /*!< RxFIFO flush             */
N#define USB_OTG_GRSTCTL_TXFFLSH_Pos              (5U)                          
N#define USB_OTG_GRSTCTL_TXFFLSH_Msk              (0x1UL << USB_OTG_GRSTCTL_TXFFLSH_Pos) /*!< 0x00000020 */
N#define USB_OTG_GRSTCTL_TXFFLSH                  USB_OTG_GRSTCTL_TXFFLSH_Msk   /*!< TxFIFO flush             */
N
N
N#define USB_OTG_GRSTCTL_TXFNUM_Pos               (6U)                          
N#define USB_OTG_GRSTCTL_TXFNUM_Msk               (0x1FUL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x000007C0 */
N#define USB_OTG_GRSTCTL_TXFNUM                   USB_OTG_GRSTCTL_TXFNUM_Msk    /*!< TxFIFO number */
N#define USB_OTG_GRSTCTL_TXFNUM_0                 (0x01UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000040 */
N#define USB_OTG_GRSTCTL_TXFNUM_1                 (0x02UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000080 */
N#define USB_OTG_GRSTCTL_TXFNUM_2                 (0x04UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000100 */
N#define USB_OTG_GRSTCTL_TXFNUM_3                 (0x08UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000200 */
N#define USB_OTG_GRSTCTL_TXFNUM_4                 (0x10UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000400 */
N#define USB_OTG_GRSTCTL_DMAREQ_Pos               (30U)                         
N#define USB_OTG_GRSTCTL_DMAREQ_Msk               (0x1UL << USB_OTG_GRSTCTL_DMAREQ_Pos) /*!< 0x40000000 */
N#define USB_OTG_GRSTCTL_DMAREQ                   USB_OTG_GRSTCTL_DMAREQ_Msk    /*!< DMA request signal */
N#define USB_OTG_GRSTCTL_AHBIDL_Pos               (31U)                         
N#define USB_OTG_GRSTCTL_AHBIDL_Msk               (0x1UL << USB_OTG_GRSTCTL_AHBIDL_Pos) /*!< 0x80000000 */
N#define USB_OTG_GRSTCTL_AHBIDL                   USB_OTG_GRSTCTL_AHBIDL_Msk    /*!< AHB master idle */
N
N/********************  Bit definition for USB_OTG_DIEPMSK register  ********************/
N#define USB_OTG_DIEPMSK_XFRCM_Pos                (0U)                          
N#define USB_OTG_DIEPMSK_XFRCM_Msk                (0x1UL << USB_OTG_DIEPMSK_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_DIEPMSK_XFRCM                    USB_OTG_DIEPMSK_XFRCM_Msk     /*!< Transfer completed interrupt mask                 */
N#define USB_OTG_DIEPMSK_EPDM_Pos                 (1U)                          
N#define USB_OTG_DIEPMSK_EPDM_Msk                 (0x1UL << USB_OTG_DIEPMSK_EPDM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DIEPMSK_EPDM                     USB_OTG_DIEPMSK_EPDM_Msk      /*!< Endpoint disabled interrupt mask                  */
N#define USB_OTG_DIEPMSK_TOM_Pos                  (3U)                          
N#define USB_OTG_DIEPMSK_TOM_Msk                  (0x1UL << USB_OTG_DIEPMSK_TOM_Pos) /*!< 0x00000008 */
N#define USB_OTG_DIEPMSK_TOM                      USB_OTG_DIEPMSK_TOM_Msk       /*!< Timeout condition mask (nonisochronous endpoints) */
N#define USB_OTG_DIEPMSK_ITTXFEMSK_Pos            (4U)                          
N#define USB_OTG_DIEPMSK_ITTXFEMSK_Msk            (0x1UL << USB_OTG_DIEPMSK_ITTXFEMSK_Pos) /*!< 0x00000010 */
N#define USB_OTG_DIEPMSK_ITTXFEMSK                USB_OTG_DIEPMSK_ITTXFEMSK_Msk /*!< IN token received when TxFIFO empty mask          */
N#define USB_OTG_DIEPMSK_INEPNMM_Pos              (5U)                          
N#define USB_OTG_DIEPMSK_INEPNMM_Msk              (0x1UL << USB_OTG_DIEPMSK_INEPNMM_Pos) /*!< 0x00000020 */
N#define USB_OTG_DIEPMSK_INEPNMM                  USB_OTG_DIEPMSK_INEPNMM_Msk   /*!< IN token received with EP mismatch mask           */
N#define USB_OTG_DIEPMSK_INEPNEM_Pos              (6U)                          
N#define USB_OTG_DIEPMSK_INEPNEM_Msk              (0x1UL << USB_OTG_DIEPMSK_INEPNEM_Pos) /*!< 0x00000040 */
N#define USB_OTG_DIEPMSK_INEPNEM                  USB_OTG_DIEPMSK_INEPNEM_Msk   /*!< IN endpoint NAK effective mask                    */
N#define USB_OTG_DIEPMSK_TXFURM_Pos               (8U)                          
N#define USB_OTG_DIEPMSK_TXFURM_Msk               (0x1UL << USB_OTG_DIEPMSK_TXFURM_Pos) /*!< 0x00000100 */
N#define USB_OTG_DIEPMSK_TXFURM                   USB_OTG_DIEPMSK_TXFURM_Msk    /*!< FIFO underrun mask                                */
N#define USB_OTG_DIEPMSK_BIM_Pos                  (9U)                          
N#define USB_OTG_DIEPMSK_BIM_Msk                  (0x1UL << USB_OTG_DIEPMSK_BIM_Pos) /*!< 0x00000200 */
N#define USB_OTG_DIEPMSK_BIM                      USB_OTG_DIEPMSK_BIM_Msk       /*!< BNA interrupt mask                                */
N
N/********************  Bit definition for USB_OTG_HPTXSTS register  ********************/
N#define USB_OTG_HPTXSTS_PTXFSAVL_Pos             (0U)                          
N#define USB_OTG_HPTXSTS_PTXFSAVL_Msk             (0xFFFFUL << USB_OTG_HPTXSTS_PTXFSAVL_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HPTXSTS_PTXFSAVL                 USB_OTG_HPTXSTS_PTXFSAVL_Msk  /*!< Periodic transmit data FIFO space available     */
N#define USB_OTG_HPTXSTS_PTXQSAV_Pos              (16U)                         
N#define USB_OTG_HPTXSTS_PTXQSAV_Msk              (0xFFUL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00FF0000 */
N#define USB_OTG_HPTXSTS_PTXQSAV                  USB_OTG_HPTXSTS_PTXQSAV_Msk   /*!< Periodic transmit request queue space available */
N#define USB_OTG_HPTXSTS_PTXQSAV_0                (0x01UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00010000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_1                (0x02UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00020000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_2                (0x04UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00040000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_3                (0x08UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00080000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_4                (0x10UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00100000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_5                (0x20UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00200000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_6                (0x40UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00400000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_7                (0x80UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00800000 */
N
N#define USB_OTG_HPTXSTS_PTXQTOP_Pos              (24U)                         
N#define USB_OTG_HPTXSTS_PTXQTOP_Msk              (0xFFUL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0xFF000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP                  USB_OTG_HPTXSTS_PTXQTOP_Msk   /*!< Top of the periodic transmit request queue */
N#define USB_OTG_HPTXSTS_PTXQTOP_0                (0x01UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x01000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_1                (0x02UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x02000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_2                (0x04UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x04000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_3                (0x08UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x08000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_4                (0x10UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x10000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_5                (0x20UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x20000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_6                (0x40UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x40000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_7                (0x80UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x80000000 */
N
N/********************  Bit definition for USB_OTG_HAINT register  ********************/
N#define USB_OTG_HAINT_HAINT_Pos                  (0U)                          
N#define USB_OTG_HAINT_HAINT_Msk                  (0xFFFFUL << USB_OTG_HAINT_HAINT_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HAINT_HAINT                      USB_OTG_HAINT_HAINT_Msk       /*!< Channel interrupts */
N
N/********************  Bit definition for USB_OTG_DOEPMSK register  ********************/
N#define USB_OTG_DOEPMSK_XFRCM_Pos                (0U)                          
N#define USB_OTG_DOEPMSK_XFRCM_Msk                (0x1UL << USB_OTG_DOEPMSK_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_DOEPMSK_XFRCM                    USB_OTG_DOEPMSK_XFRCM_Msk     /*!< Transfer completed interrupt mask              */
N#define USB_OTG_DOEPMSK_EPDM_Pos                 (1U)                          
N#define USB_OTG_DOEPMSK_EPDM_Msk                 (0x1UL << USB_OTG_DOEPMSK_EPDM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DOEPMSK_EPDM                     USB_OTG_DOEPMSK_EPDM_Msk      /*!< Endpoint disabled interrupt mask               */
N#define USB_OTG_DOEPMSK_AHBERRM_Pos              (2U)
N#define USB_OTG_DOEPMSK_AHBERRM_Msk              (0x1UL << USB_OTG_DOEPMSK_AHBERRM_Pos) /*!< 0x00000004 */
N#define USB_OTG_DOEPMSK_AHBERRM                  USB_OTG_DOEPMSK_AHBERRM_Msk   /*!< OUT transaction AHB Error interrupt mask       */
N#define USB_OTG_DOEPMSK_STUPM_Pos                (3U)                          
N#define USB_OTG_DOEPMSK_STUPM_Msk                (0x1UL << USB_OTG_DOEPMSK_STUPM_Pos) /*!< 0x00000008 */
N#define USB_OTG_DOEPMSK_STUPM                    USB_OTG_DOEPMSK_STUPM_Msk     /*!< SETUP phase done mask                          */
N#define USB_OTG_DOEPMSK_OTEPDM_Pos               (4U)                          
N#define USB_OTG_DOEPMSK_OTEPDM_Msk               (0x1UL << USB_OTG_DOEPMSK_OTEPDM_Pos) /*!< 0x00000010 */
N#define USB_OTG_DOEPMSK_OTEPDM                   USB_OTG_DOEPMSK_OTEPDM_Msk    /*!< OUT token received when endpoint disabled mask */
N#define USB_OTG_DOEPMSK_OTEPSPRM_Pos             (5U)                          
N#define USB_OTG_DOEPMSK_OTEPSPRM_Msk             (0x1UL << USB_OTG_DOEPMSK_OTEPSPRM_Pos) /*!< 0x00000020 */
N#define USB_OTG_DOEPMSK_OTEPSPRM                 USB_OTG_DOEPMSK_OTEPSPRM_Msk  /*!< Status Phase Received mask                     */
N#define USB_OTG_DOEPMSK_B2BSTUP_Pos              (6U)                          
N#define USB_OTG_DOEPMSK_B2BSTUP_Msk              (0x1UL << USB_OTG_DOEPMSK_B2BSTUP_Pos) /*!< 0x00000040 */
N#define USB_OTG_DOEPMSK_B2BSTUP                  USB_OTG_DOEPMSK_B2BSTUP_Msk   /*!< Back-to-back SETUP packets received mask       */
N#define USB_OTG_DOEPMSK_OPEM_Pos                 (8U)                          
N#define USB_OTG_DOEPMSK_OPEM_Msk                 (0x1UL << USB_OTG_DOEPMSK_OPEM_Pos) /*!< 0x00000100 */
N#define USB_OTG_DOEPMSK_OPEM                     USB_OTG_DOEPMSK_OPEM_Msk      /*!< OUT packet error mask                          */
N#define USB_OTG_DOEPMSK_BOIM_Pos                 (9U)                          
N#define USB_OTG_DOEPMSK_BOIM_Msk                 (0x1UL << USB_OTG_DOEPMSK_BOIM_Pos) /*!< 0x00000200 */
N#define USB_OTG_DOEPMSK_BOIM                     USB_OTG_DOEPMSK_BOIM_Msk      /*!< BNA interrupt mask                             */
N#define USB_OTG_DOEPMSK_BERRM_Pos                (12U)
N#define USB_OTG_DOEPMSK_BERRM_Msk                (0x1UL << USB_OTG_DOEPMSK_BERRM_Pos) /*!< 0x00001000 */
N#define USB_OTG_DOEPMSK_BERRM                    USB_OTG_DOEPMSK_BERRM_Msk      /*!< Babble error interrupt mask                   */
N#define USB_OTG_DOEPMSK_NAKM_Pos                 (13U)
N#define USB_OTG_DOEPMSK_NAKM_Msk                 (0x1UL << USB_OTG_DOEPMSK_NAKM_Pos) /*!< 0x00002000 */
N#define USB_OTG_DOEPMSK_NAKM                     USB_OTG_DOEPMSK_NAKM_Msk      /*!< OUT Packet NAK interrupt mask                  */
N#define USB_OTG_DOEPMSK_NYETM_Pos                (14U)
N#define USB_OTG_DOEPMSK_NYETM_Msk                (0x1UL << USB_OTG_DOEPMSK_NYETM_Pos) /*!< 0x00004000 */
N#define USB_OTG_DOEPMSK_NYETM                    USB_OTG_DOEPMSK_NYETM_Msk     /*!< NYET interrupt mask                            */
N/********************  Bit definition for USB_OTG_GINTSTS register  ********************/
N#define USB_OTG_GINTSTS_CMOD_Pos                 (0U)                          
N#define USB_OTG_GINTSTS_CMOD_Msk                 (0x1UL << USB_OTG_GINTSTS_CMOD_Pos) /*!< 0x00000001 */
N#define USB_OTG_GINTSTS_CMOD                     USB_OTG_GINTSTS_CMOD_Msk      /*!< Current mode of operation                      */
N#define USB_OTG_GINTSTS_MMIS_Pos                 (1U)                          
N#define USB_OTG_GINTSTS_MMIS_Msk                 (0x1UL << USB_OTG_GINTSTS_MMIS_Pos) /*!< 0x00000002 */
N#define USB_OTG_GINTSTS_MMIS                     USB_OTG_GINTSTS_MMIS_Msk      /*!< Mode mismatch interrupt                        */
N#define USB_OTG_GINTSTS_OTGINT_Pos               (2U)                          
N#define USB_OTG_GINTSTS_OTGINT_Msk               (0x1UL << USB_OTG_GINTSTS_OTGINT_Pos) /*!< 0x00000004 */
N#define USB_OTG_GINTSTS_OTGINT                   USB_OTG_GINTSTS_OTGINT_Msk    /*!< OTG interrupt                                  */
N#define USB_OTG_GINTSTS_SOF_Pos                  (3U)                          
N#define USB_OTG_GINTSTS_SOF_Msk                  (0x1UL << USB_OTG_GINTSTS_SOF_Pos) /*!< 0x00000008 */
N#define USB_OTG_GINTSTS_SOF                      USB_OTG_GINTSTS_SOF_Msk       /*!< Start of frame                                 */
N#define USB_OTG_GINTSTS_RXFLVL_Pos               (4U)                          
N#define USB_OTG_GINTSTS_RXFLVL_Msk               (0x1UL << USB_OTG_GINTSTS_RXFLVL_Pos) /*!< 0x00000010 */
N#define USB_OTG_GINTSTS_RXFLVL                   USB_OTG_GINTSTS_RXFLVL_Msk    /*!< RxFIFO nonempty                                */
N#define USB_OTG_GINTSTS_NPTXFE_Pos               (5U)                          
N#define USB_OTG_GINTSTS_NPTXFE_Msk               (0x1UL << USB_OTG_GINTSTS_NPTXFE_Pos) /*!< 0x00000020 */
N#define USB_OTG_GINTSTS_NPTXFE                   USB_OTG_GINTSTS_NPTXFE_Msk    /*!< Nonperiodic TxFIFO empty                       */
N#define USB_OTG_GINTSTS_GINAKEFF_Pos             (6U)                          
N#define USB_OTG_GINTSTS_GINAKEFF_Msk             (0x1UL << USB_OTG_GINTSTS_GINAKEFF_Pos) /*!< 0x00000040 */
N#define USB_OTG_GINTSTS_GINAKEFF                 USB_OTG_GINTSTS_GINAKEFF_Msk  /*!< Global IN nonperiodic NAK effective            */
N#define USB_OTG_GINTSTS_BOUTNAKEFF_Pos           (7U)                          
N#define USB_OTG_GINTSTS_BOUTNAKEFF_Msk           (0x1UL << USB_OTG_GINTSTS_BOUTNAKEFF_Pos) /*!< 0x00000080 */
N#define USB_OTG_GINTSTS_BOUTNAKEFF               USB_OTG_GINTSTS_BOUTNAKEFF_Msk /*!< Global OUT NAK effective                       */
N#define USB_OTG_GINTSTS_ESUSP_Pos                (10U)                         
N#define USB_OTG_GINTSTS_ESUSP_Msk                (0x1UL << USB_OTG_GINTSTS_ESUSP_Pos) /*!< 0x00000400 */
N#define USB_OTG_GINTSTS_ESUSP                    USB_OTG_GINTSTS_ESUSP_Msk     /*!< Early suspend                                  */
N#define USB_OTG_GINTSTS_USBSUSP_Pos              (11U)                         
N#define USB_OTG_GINTSTS_USBSUSP_Msk              (0x1UL << USB_OTG_GINTSTS_USBSUSP_Pos) /*!< 0x00000800 */
N#define USB_OTG_GINTSTS_USBSUSP                  USB_OTG_GINTSTS_USBSUSP_Msk   /*!< USB suspend                                    */
N#define USB_OTG_GINTSTS_USBRST_Pos               (12U)                         
N#define USB_OTG_GINTSTS_USBRST_Msk               (0x1UL << USB_OTG_GINTSTS_USBRST_Pos) /*!< 0x00001000 */
N#define USB_OTG_GINTSTS_USBRST                   USB_OTG_GINTSTS_USBRST_Msk    /*!< USB reset                                      */
N#define USB_OTG_GINTSTS_ENUMDNE_Pos              (13U)                         
N#define USB_OTG_GINTSTS_ENUMDNE_Msk              (0x1UL << USB_OTG_GINTSTS_ENUMDNE_Pos) /*!< 0x00002000 */
N#define USB_OTG_GINTSTS_ENUMDNE                  USB_OTG_GINTSTS_ENUMDNE_Msk   /*!< Enumeration done                               */
N#define USB_OTG_GINTSTS_ISOODRP_Pos              (14U)                         
N#define USB_OTG_GINTSTS_ISOODRP_Msk              (0x1UL << USB_OTG_GINTSTS_ISOODRP_Pos) /*!< 0x00004000 */
N#define USB_OTG_GINTSTS_ISOODRP                  USB_OTG_GINTSTS_ISOODRP_Msk   /*!< Isochronous OUT packet dropped interrupt       */
N#define USB_OTG_GINTSTS_EOPF_Pos                 (15U)                         
N#define USB_OTG_GINTSTS_EOPF_Msk                 (0x1UL << USB_OTG_GINTSTS_EOPF_Pos) /*!< 0x00008000 */
N#define USB_OTG_GINTSTS_EOPF                     USB_OTG_GINTSTS_EOPF_Msk      /*!< End of periodic frame interrupt                */
N#define USB_OTG_GINTSTS_IEPINT_Pos               (18U)                         
N#define USB_OTG_GINTSTS_IEPINT_Msk               (0x1UL << USB_OTG_GINTSTS_IEPINT_Pos) /*!< 0x00040000 */
N#define USB_OTG_GINTSTS_IEPINT                   USB_OTG_GINTSTS_IEPINT_Msk    /*!< IN endpoint interrupt                          */
N#define USB_OTG_GINTSTS_OEPINT_Pos               (19U)                         
N#define USB_OTG_GINTSTS_OEPINT_Msk               (0x1UL << USB_OTG_GINTSTS_OEPINT_Pos) /*!< 0x00080000 */
N#define USB_OTG_GINTSTS_OEPINT                   USB_OTG_GINTSTS_OEPINT_Msk    /*!< OUT endpoint interrupt                         */
N#define USB_OTG_GINTSTS_IISOIXFR_Pos             (20U)                         
N#define USB_OTG_GINTSTS_IISOIXFR_Msk             (0x1UL << USB_OTG_GINTSTS_IISOIXFR_Pos) /*!< 0x00100000 */
N#define USB_OTG_GINTSTS_IISOIXFR                 USB_OTG_GINTSTS_IISOIXFR_Msk  /*!< Incomplete isochronous IN transfer             */
N#define USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Pos    (21U)                         
N#define USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Msk    (0x1UL << USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Pos) /*!< 0x00200000 */
N#define USB_OTG_GINTSTS_PXFR_INCOMPISOOUT        USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Msk /*!< Incomplete periodic transfer                   */
N#define USB_OTG_GINTSTS_DATAFSUSP_Pos            (22U)                         
N#define USB_OTG_GINTSTS_DATAFSUSP_Msk            (0x1UL << USB_OTG_GINTSTS_DATAFSUSP_Pos) /*!< 0x00400000 */
N#define USB_OTG_GINTSTS_DATAFSUSP                USB_OTG_GINTSTS_DATAFSUSP_Msk /*!< Data fetch suspended                           */
N#define USB_OTG_GINTSTS_HPRTINT_Pos              (24U)                         
N#define USB_OTG_GINTSTS_HPRTINT_Msk              (0x1UL << USB_OTG_GINTSTS_HPRTINT_Pos) /*!< 0x01000000 */
N#define USB_OTG_GINTSTS_HPRTINT                  USB_OTG_GINTSTS_HPRTINT_Msk   /*!< Host port interrupt                            */
N#define USB_OTG_GINTSTS_HCINT_Pos                (25U)                         
N#define USB_OTG_GINTSTS_HCINT_Msk                (0x1UL << USB_OTG_GINTSTS_HCINT_Pos) /*!< 0x02000000 */
N#define USB_OTG_GINTSTS_HCINT                    USB_OTG_GINTSTS_HCINT_Msk     /*!< Host channels interrupt                        */
N#define USB_OTG_GINTSTS_PTXFE_Pos                (26U)                         
N#define USB_OTG_GINTSTS_PTXFE_Msk                (0x1UL << USB_OTG_GINTSTS_PTXFE_Pos) /*!< 0x04000000 */
N#define USB_OTG_GINTSTS_PTXFE                    USB_OTG_GINTSTS_PTXFE_Msk     /*!< Periodic TxFIFO empty                          */
N#define USB_OTG_GINTSTS_CIDSCHG_Pos              (28U)                         
N#define USB_OTG_GINTSTS_CIDSCHG_Msk              (0x1UL << USB_OTG_GINTSTS_CIDSCHG_Pos) /*!< 0x10000000 */
N#define USB_OTG_GINTSTS_CIDSCHG                  USB_OTG_GINTSTS_CIDSCHG_Msk   /*!< Connector ID status change                     */
N#define USB_OTG_GINTSTS_DISCINT_Pos              (29U)                         
N#define USB_OTG_GINTSTS_DISCINT_Msk              (0x1UL << USB_OTG_GINTSTS_DISCINT_Pos) /*!< 0x20000000 */
N#define USB_OTG_GINTSTS_DISCINT                  USB_OTG_GINTSTS_DISCINT_Msk   /*!< Disconnect detected interrupt                  */
N#define USB_OTG_GINTSTS_SRQINT_Pos               (30U)                         
N#define USB_OTG_GINTSTS_SRQINT_Msk               (0x1UL << USB_OTG_GINTSTS_SRQINT_Pos) /*!< 0x40000000 */
N#define USB_OTG_GINTSTS_SRQINT                   USB_OTG_GINTSTS_SRQINT_Msk    /*!< Session request/new session detected interrupt */
N#define USB_OTG_GINTSTS_WKUINT_Pos               (31U)                         
N#define USB_OTG_GINTSTS_WKUINT_Msk               (0x1UL << USB_OTG_GINTSTS_WKUINT_Pos) /*!< 0x80000000 */
N#define USB_OTG_GINTSTS_WKUINT                   USB_OTG_GINTSTS_WKUINT_Msk    /*!< Resume/remote wakeup detected interrupt        */
N
N/********************  Bit definition for USB_OTG_GINTMSK register  ********************/
N#define USB_OTG_GINTMSK_MMISM_Pos                (1U)                          
N#define USB_OTG_GINTMSK_MMISM_Msk                (0x1UL << USB_OTG_GINTMSK_MMISM_Pos) /*!< 0x00000002 */
N#define USB_OTG_GINTMSK_MMISM                    USB_OTG_GINTMSK_MMISM_Msk     /*!< Mode mismatch interrupt mask                        */
N#define USB_OTG_GINTMSK_OTGINT_Pos               (2U)                          
N#define USB_OTG_GINTMSK_OTGINT_Msk               (0x1UL << USB_OTG_GINTMSK_OTGINT_Pos) /*!< 0x00000004 */
N#define USB_OTG_GINTMSK_OTGINT                   USB_OTG_GINTMSK_OTGINT_Msk    /*!< OTG interrupt mask                                  */
N#define USB_OTG_GINTMSK_SOFM_Pos                 (3U)                          
N#define USB_OTG_GINTMSK_SOFM_Msk                 (0x1UL << USB_OTG_GINTMSK_SOFM_Pos) /*!< 0x00000008 */
N#define USB_OTG_GINTMSK_SOFM                     USB_OTG_GINTMSK_SOFM_Msk      /*!< Start of frame mask                                 */
N#define USB_OTG_GINTMSK_RXFLVLM_Pos              (4U)                          
N#define USB_OTG_GINTMSK_RXFLVLM_Msk              (0x1UL << USB_OTG_GINTMSK_RXFLVLM_Pos) /*!< 0x00000010 */
N#define USB_OTG_GINTMSK_RXFLVLM                  USB_OTG_GINTMSK_RXFLVLM_Msk   /*!< Receive FIFO nonempty mask                          */
N#define USB_OTG_GINTMSK_NPTXFEM_Pos              (5U)                          
N#define USB_OTG_GINTMSK_NPTXFEM_Msk              (0x1UL << USB_OTG_GINTMSK_NPTXFEM_Pos) /*!< 0x00000020 */
N#define USB_OTG_GINTMSK_NPTXFEM                  USB_OTG_GINTMSK_NPTXFEM_Msk   /*!< Nonperiodic TxFIFO empty mask                       */
N#define USB_OTG_GINTMSK_GINAKEFFM_Pos            (6U)                          
N#define USB_OTG_GINTMSK_GINAKEFFM_Msk            (0x1UL << USB_OTG_GINTMSK_GINAKEFFM_Pos) /*!< 0x00000040 */
N#define USB_OTG_GINTMSK_GINAKEFFM                USB_OTG_GINTMSK_GINAKEFFM_Msk /*!< Global nonperiodic IN NAK effective mask            */
N#define USB_OTG_GINTMSK_GONAKEFFM_Pos            (7U)                          
N#define USB_OTG_GINTMSK_GONAKEFFM_Msk            (0x1UL << USB_OTG_GINTMSK_GONAKEFFM_Pos) /*!< 0x00000080 */
N#define USB_OTG_GINTMSK_GONAKEFFM                USB_OTG_GINTMSK_GONAKEFFM_Msk /*!< Global OUT NAK effective mask                       */
N#define USB_OTG_GINTMSK_ESUSPM_Pos               (10U)                         
N#define USB_OTG_GINTMSK_ESUSPM_Msk               (0x1UL << USB_OTG_GINTMSK_ESUSPM_Pos) /*!< 0x00000400 */
N#define USB_OTG_GINTMSK_ESUSPM                   USB_OTG_GINTMSK_ESUSPM_Msk    /*!< Early suspend mask                                  */
N#define USB_OTG_GINTMSK_USBSUSPM_Pos             (11U)                         
N#define USB_OTG_GINTMSK_USBSUSPM_Msk             (0x1UL << USB_OTG_GINTMSK_USBSUSPM_Pos) /*!< 0x00000800 */
N#define USB_OTG_GINTMSK_USBSUSPM                 USB_OTG_GINTMSK_USBSUSPM_Msk  /*!< USB suspend mask                                    */
N#define USB_OTG_GINTMSK_USBRST_Pos               (12U)                         
N#define USB_OTG_GINTMSK_USBRST_Msk               (0x1UL << USB_OTG_GINTMSK_USBRST_Pos) /*!< 0x00001000 */
N#define USB_OTG_GINTMSK_USBRST                   USB_OTG_GINTMSK_USBRST_Msk    /*!< USB reset mask                                      */
N#define USB_OTG_GINTMSK_ENUMDNEM_Pos             (13U)                         
N#define USB_OTG_GINTMSK_ENUMDNEM_Msk             (0x1UL << USB_OTG_GINTMSK_ENUMDNEM_Pos) /*!< 0x00002000 */
N#define USB_OTG_GINTMSK_ENUMDNEM                 USB_OTG_GINTMSK_ENUMDNEM_Msk  /*!< Enumeration done mask                               */
N#define USB_OTG_GINTMSK_ISOODRPM_Pos             (14U)                         
N#define USB_OTG_GINTMSK_ISOODRPM_Msk             (0x1UL << USB_OTG_GINTMSK_ISOODRPM_Pos) /*!< 0x00004000 */
N#define USB_OTG_GINTMSK_ISOODRPM                 USB_OTG_GINTMSK_ISOODRPM_Msk  /*!< Isochronous OUT packet dropped interrupt mask       */
N#define USB_OTG_GINTMSK_EOPFM_Pos                (15U)                         
N#define USB_OTG_GINTMSK_EOPFM_Msk                (0x1UL << USB_OTG_GINTMSK_EOPFM_Pos) /*!< 0x00008000 */
N#define USB_OTG_GINTMSK_EOPFM                    USB_OTG_GINTMSK_EOPFM_Msk     /*!< End of periodic frame interrupt mask                */
N#define USB_OTG_GINTMSK_EPMISM_Pos               (17U)                         
N#define USB_OTG_GINTMSK_EPMISM_Msk               (0x1UL << USB_OTG_GINTMSK_EPMISM_Pos) /*!< 0x00020000 */
N#define USB_OTG_GINTMSK_EPMISM                   USB_OTG_GINTMSK_EPMISM_Msk    /*!< Endpoint mismatch interrupt mask                    */
N#define USB_OTG_GINTMSK_IEPINT_Pos               (18U)                         
N#define USB_OTG_GINTMSK_IEPINT_Msk               (0x1UL << USB_OTG_GINTMSK_IEPINT_Pos) /*!< 0x00040000 */
N#define USB_OTG_GINTMSK_IEPINT                   USB_OTG_GINTMSK_IEPINT_Msk    /*!< IN endpoints interrupt mask                         */
N#define USB_OTG_GINTMSK_OEPINT_Pos               (19U)                         
N#define USB_OTG_GINTMSK_OEPINT_Msk               (0x1UL << USB_OTG_GINTMSK_OEPINT_Pos) /*!< 0x00080000 */
N#define USB_OTG_GINTMSK_OEPINT                   USB_OTG_GINTMSK_OEPINT_Msk    /*!< OUT endpoints interrupt mask                        */
N#define USB_OTG_GINTMSK_IISOIXFRM_Pos            (20U)                         
N#define USB_OTG_GINTMSK_IISOIXFRM_Msk            (0x1UL << USB_OTG_GINTMSK_IISOIXFRM_Pos) /*!< 0x00100000 */
N#define USB_OTG_GINTMSK_IISOIXFRM                USB_OTG_GINTMSK_IISOIXFRM_Msk /*!< Incomplete isochronous IN transfer mask             */
N#define USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Pos      (21U)                         
N#define USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Msk      (0x1UL << USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Pos) /*!< 0x00200000 */
N#define USB_OTG_GINTMSK_PXFRM_IISOOXFRM          USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Msk /*!< Incomplete periodic transfer mask                   */
N#define USB_OTG_GINTMSK_FSUSPM_Pos               (22U)                         
N#define USB_OTG_GINTMSK_FSUSPM_Msk               (0x1UL << USB_OTG_GINTMSK_FSUSPM_Pos) /*!< 0x00400000 */
N#define USB_OTG_GINTMSK_FSUSPM                   USB_OTG_GINTMSK_FSUSPM_Msk    /*!< Data fetch suspended mask                           */
N#define USB_OTG_GINTMSK_PRTIM_Pos                (24U)                         
N#define USB_OTG_GINTMSK_PRTIM_Msk                (0x1UL << USB_OTG_GINTMSK_PRTIM_Pos) /*!< 0x01000000 */
N#define USB_OTG_GINTMSK_PRTIM                    USB_OTG_GINTMSK_PRTIM_Msk     /*!< Host port interrupt mask                            */
N#define USB_OTG_GINTMSK_HCIM_Pos                 (25U)                         
N#define USB_OTG_GINTMSK_HCIM_Msk                 (0x1UL << USB_OTG_GINTMSK_HCIM_Pos) /*!< 0x02000000 */
N#define USB_OTG_GINTMSK_HCIM                     USB_OTG_GINTMSK_HCIM_Msk      /*!< Host channels interrupt mask                        */
N#define USB_OTG_GINTMSK_PTXFEM_Pos               (26U)                         
N#define USB_OTG_GINTMSK_PTXFEM_Msk               (0x1UL << USB_OTG_GINTMSK_PTXFEM_Pos) /*!< 0x04000000 */
N#define USB_OTG_GINTMSK_PTXFEM                   USB_OTG_GINTMSK_PTXFEM_Msk    /*!< Periodic TxFIFO empty mask                          */
N#define USB_OTG_GINTMSK_CIDSCHGM_Pos             (28U)                         
N#define USB_OTG_GINTMSK_CIDSCHGM_Msk             (0x1UL << USB_OTG_GINTMSK_CIDSCHGM_Pos) /*!< 0x10000000 */
N#define USB_OTG_GINTMSK_CIDSCHGM                 USB_OTG_GINTMSK_CIDSCHGM_Msk  /*!< Connector ID status change mask                     */
N#define USB_OTG_GINTMSK_DISCINT_Pos              (29U)                         
N#define USB_OTG_GINTMSK_DISCINT_Msk              (0x1UL << USB_OTG_GINTMSK_DISCINT_Pos) /*!< 0x20000000 */
N#define USB_OTG_GINTMSK_DISCINT                  USB_OTG_GINTMSK_DISCINT_Msk   /*!< Disconnect detected interrupt mask                  */
N#define USB_OTG_GINTMSK_SRQIM_Pos                (30U)                         
N#define USB_OTG_GINTMSK_SRQIM_Msk                (0x1UL << USB_OTG_GINTMSK_SRQIM_Pos) /*!< 0x40000000 */
N#define USB_OTG_GINTMSK_SRQIM                    USB_OTG_GINTMSK_SRQIM_Msk     /*!< Session request/new session detected interrupt mask */
N#define USB_OTG_GINTMSK_WUIM_Pos                 (31U)                         
N#define USB_OTG_GINTMSK_WUIM_Msk                 (0x1UL << USB_OTG_GINTMSK_WUIM_Pos) /*!< 0x80000000 */
N#define USB_OTG_GINTMSK_WUIM                     USB_OTG_GINTMSK_WUIM_Msk      /*!< Resume/remote wakeup detected interrupt mask        */
N
N/********************  Bit definition for USB_OTG_DAINT register  ********************/
N#define USB_OTG_DAINT_IEPINT_Pos                 (0U)                          
N#define USB_OTG_DAINT_IEPINT_Msk                 (0xFFFFUL << USB_OTG_DAINT_IEPINT_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DAINT_IEPINT                     USB_OTG_DAINT_IEPINT_Msk      /*!< IN endpoint interrupt bits  */
N#define USB_OTG_DAINT_OEPINT_Pos                 (16U)                         
N#define USB_OTG_DAINT_OEPINT_Msk                 (0xFFFFUL << USB_OTG_DAINT_OEPINT_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_DAINT_OEPINT                     USB_OTG_DAINT_OEPINT_Msk      /*!< OUT endpoint interrupt bits */
N
N/********************  Bit definition for USB_OTG_HAINTMSK register  ********************/
N#define USB_OTG_HAINTMSK_HAINTM_Pos              (0U)                          
N#define USB_OTG_HAINTMSK_HAINTM_Msk              (0xFFFFUL << USB_OTG_HAINTMSK_HAINTM_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HAINTMSK_HAINTM                  USB_OTG_HAINTMSK_HAINTM_Msk   /*!< Channel interrupt mask */
N
N/********************  Bit definition for USB_OTG_GRXSTSP register  ********************/
N#define USB_OTG_GRXSTSP_EPNUM_Pos                (0U)                          
N#define USB_OTG_GRXSTSP_EPNUM_Msk                (0xFUL << USB_OTG_GRXSTSP_EPNUM_Pos) /*!< 0x0000000F */
N#define USB_OTG_GRXSTSP_EPNUM                    USB_OTG_GRXSTSP_EPNUM_Msk     /*!< IN EP interrupt mask bits  */
N#define USB_OTG_GRXSTSP_BCNT_Pos                 (4U)                          
N#define USB_OTG_GRXSTSP_BCNT_Msk                 (0x7FFUL << USB_OTG_GRXSTSP_BCNT_Pos) /*!< 0x00007FF0 */
N#define USB_OTG_GRXSTSP_BCNT                     USB_OTG_GRXSTSP_BCNT_Msk      /*!< OUT EP interrupt mask bits */
N#define USB_OTG_GRXSTSP_DPID_Pos                 (15U)                         
N#define USB_OTG_GRXSTSP_DPID_Msk                 (0x3UL << USB_OTG_GRXSTSP_DPID_Pos) /*!< 0x00018000 */
N#define USB_OTG_GRXSTSP_DPID                     USB_OTG_GRXSTSP_DPID_Msk      /*!< OUT EP interrupt mask bits */
N#define USB_OTG_GRXSTSP_PKTSTS_Pos               (17U)                         
N#define USB_OTG_GRXSTSP_PKTSTS_Msk               (0xFUL << USB_OTG_GRXSTSP_PKTSTS_Pos) /*!< 0x001E0000 */
N#define USB_OTG_GRXSTSP_PKTSTS                   USB_OTG_GRXSTSP_PKTSTS_Msk    /*!< OUT EP interrupt mask bits */
N
N/********************  Bit definition for USB_OTG_DAINTMSK register  ********************/
N#define USB_OTG_DAINTMSK_IEPM_Pos                (0U)                          
N#define USB_OTG_DAINTMSK_IEPM_Msk                (0xFFFFUL << USB_OTG_DAINTMSK_IEPM_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DAINTMSK_IEPM                    USB_OTG_DAINTMSK_IEPM_Msk     /*!< IN EP interrupt mask bits */
N#define USB_OTG_DAINTMSK_OEPM_Pos                (16U)                         
N#define USB_OTG_DAINTMSK_OEPM_Msk                (0xFFFFUL << USB_OTG_DAINTMSK_OEPM_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_DAINTMSK_OEPM                    USB_OTG_DAINTMSK_OEPM_Msk     /*!< OUT EP interrupt mask bits */
N
N/********************  Bit definition for USB_OTG_GRXFSIZ register  ********************/
N#define USB_OTG_GRXFSIZ_RXFD_Pos                 (0U)                          
N#define USB_OTG_GRXFSIZ_RXFD_Msk                 (0xFFFFUL << USB_OTG_GRXFSIZ_RXFD_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_GRXFSIZ_RXFD                     USB_OTG_GRXFSIZ_RXFD_Msk      /*!< RxFIFO depth */
N
N/********************  Bit definition for USB_OTG_DVBUSDIS register  ********************/
N#define USB_OTG_DVBUSDIS_VBUSDT_Pos              (0U)                          
N#define USB_OTG_DVBUSDIS_VBUSDT_Msk              (0xFFFFUL << USB_OTG_DVBUSDIS_VBUSDT_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DVBUSDIS_VBUSDT                  USB_OTG_DVBUSDIS_VBUSDT_Msk   /*!< Device VBUS discharge time */
N
N/********************  Bit definition for OTG register  ********************/
N#define USB_OTG_NPTXFSA_Pos                      (0U)                          
N#define USB_OTG_NPTXFSA_Msk                      (0xFFFFUL << USB_OTG_NPTXFSA_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_NPTXFSA                          USB_OTG_NPTXFSA_Msk           /*!< Nonperiodic transmit RAM start address */
N#define USB_OTG_NPTXFD_Pos                       (16U)                         
N#define USB_OTG_NPTXFD_Msk                       (0xFFFFUL << USB_OTG_NPTXFD_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_NPTXFD                           USB_OTG_NPTXFD_Msk            /*!< Nonperiodic TxFIFO depth               */
N#define USB_OTG_TX0FSA_Pos                       (0U)                          
N#define USB_OTG_TX0FSA_Msk                       (0xFFFFUL << USB_OTG_TX0FSA_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_TX0FSA                           USB_OTG_TX0FSA_Msk            /*!< Endpoint 0 transmit RAM start address  */
N#define USB_OTG_TX0FD_Pos                        (16U)                         
N#define USB_OTG_TX0FD_Msk                        (0xFFFFUL << USB_OTG_TX0FD_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_TX0FD                            USB_OTG_TX0FD_Msk             /*!< Endpoint 0 TxFIFO depth                */
N
N/********************  Bit definition forUSB_OTG_DVBUSPULSE register  ********************/
N#define USB_OTG_DVBUSPULSE_DVBUSP_Pos            (0U)                          
N#define USB_OTG_DVBUSPULSE_DVBUSP_Msk            (0xFFFUL << USB_OTG_DVBUSPULSE_DVBUSP_Pos) /*!< 0x00000FFF */
N#define USB_OTG_DVBUSPULSE_DVBUSP                USB_OTG_DVBUSPULSE_DVBUSP_Msk /*!< Device VBUS pulsing time */
N
N/********************  Bit definition for USB_OTG_GNPTXSTS register  ********************/
N#define USB_OTG_GNPTXSTS_NPTXFSAV_Pos            (0U)                          
N#define USB_OTG_GNPTXSTS_NPTXFSAV_Msk            (0xFFFFUL << USB_OTG_GNPTXSTS_NPTXFSAV_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_GNPTXSTS_NPTXFSAV                USB_OTG_GNPTXSTS_NPTXFSAV_Msk /*!< Nonperiodic TxFIFO space available */
N
N#define USB_OTG_GNPTXSTS_NPTQXSAV_Pos            (16U)                         
N#define USB_OTG_GNPTXSTS_NPTQXSAV_Msk            (0xFFUL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00FF0000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV                USB_OTG_GNPTXSTS_NPTQXSAV_Msk /*!< Nonperiodic transmit request queue space available */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_0              (0x01UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00010000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_1              (0x02UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00020000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_2              (0x04UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00040000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_3              (0x08UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00080000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_4              (0x10UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00100000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_5              (0x20UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00200000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_6              (0x40UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00400000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_7              (0x80UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00800000 */
N
N#define USB_OTG_GNPTXSTS_NPTXQTOP_Pos            (24U)                         
N#define USB_OTG_GNPTXSTS_NPTXQTOP_Msk            (0x7FUL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x7F000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP                USB_OTG_GNPTXSTS_NPTXQTOP_Msk /*!< Top of the nonperiodic transmit request queue */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_0              (0x01UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x01000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_1              (0x02UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x02000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_2              (0x04UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x04000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_3              (0x08UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x08000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_4              (0x10UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x10000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_5              (0x20UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x20000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_6              (0x40UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x40000000 */
N
N/********************  Bit definition for USB_OTG_DTHRCTL register  ********************/
N#define USB_OTG_DTHRCTL_NONISOTHREN_Pos          (0U)                          
N#define USB_OTG_DTHRCTL_NONISOTHREN_Msk          (0x1UL << USB_OTG_DTHRCTL_NONISOTHREN_Pos) /*!< 0x00000001 */
N#define USB_OTG_DTHRCTL_NONISOTHREN              USB_OTG_DTHRCTL_NONISOTHREN_Msk /*!< Nonisochronous IN endpoints threshold enable */
N#define USB_OTG_DTHRCTL_ISOTHREN_Pos             (1U)                          
N#define USB_OTG_DTHRCTL_ISOTHREN_Msk             (0x1UL << USB_OTG_DTHRCTL_ISOTHREN_Pos) /*!< 0x00000002 */
N#define USB_OTG_DTHRCTL_ISOTHREN                 USB_OTG_DTHRCTL_ISOTHREN_Msk  /*!< ISO IN endpoint threshold enable */
N
N#define USB_OTG_DTHRCTL_TXTHRLEN_Pos             (2U)                          
N#define USB_OTG_DTHRCTL_TXTHRLEN_Msk             (0x1FFUL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x000007FC */
N#define USB_OTG_DTHRCTL_TXTHRLEN                 USB_OTG_DTHRCTL_TXTHRLEN_Msk  /*!< Transmit threshold length */
N#define USB_OTG_DTHRCTL_TXTHRLEN_0               (0x001UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000004 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_1               (0x002UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000008 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_2               (0x004UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000010 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_3               (0x008UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000020 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_4               (0x010UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000040 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_5               (0x020UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000080 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_6               (0x040UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000100 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_7               (0x080UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000200 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_8               (0x100UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000400 */
N#define USB_OTG_DTHRCTL_RXTHREN_Pos              (16U)                         
N#define USB_OTG_DTHRCTL_RXTHREN_Msk              (0x1UL << USB_OTG_DTHRCTL_RXTHREN_Pos) /*!< 0x00010000 */
N#define USB_OTG_DTHRCTL_RXTHREN                  USB_OTG_DTHRCTL_RXTHREN_Msk   /*!< Receive threshold enable */
N
N#define USB_OTG_DTHRCTL_RXTHRLEN_Pos             (17U)                         
N#define USB_OTG_DTHRCTL_RXTHRLEN_Msk             (0x1FFUL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x03FE0000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN                 USB_OTG_DTHRCTL_RXTHRLEN_Msk  /*!< Receive threshold length */
N#define USB_OTG_DTHRCTL_RXTHRLEN_0               (0x001UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00020000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_1               (0x002UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00040000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_2               (0x004UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00080000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_3               (0x008UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00100000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_4               (0x010UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00200000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_5               (0x020UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00400000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_6               (0x040UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00800000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_7               (0x080UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x01000000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_8               (0x100UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x02000000 */
N#define USB_OTG_DTHRCTL_ARPEN_Pos                (27U)                         
N#define USB_OTG_DTHRCTL_ARPEN_Msk                (0x1UL << USB_OTG_DTHRCTL_ARPEN_Pos) /*!< 0x08000000 */
N#define USB_OTG_DTHRCTL_ARPEN                    USB_OTG_DTHRCTL_ARPEN_Msk     /*!< Arbiter parking enable */
N
N/********************  Bit definition for USB_OTG_DIEPEMPMSK register  ********************/
N#define USB_OTG_DIEPEMPMSK_INEPTXFEM_Pos         (0U)                          
N#define USB_OTG_DIEPEMPMSK_INEPTXFEM_Msk         (0xFFFFUL << USB_OTG_DIEPEMPMSK_INEPTXFEM_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DIEPEMPMSK_INEPTXFEM             USB_OTG_DIEPEMPMSK_INEPTXFEM_Msk /*!< IN EP Tx FIFO empty interrupt mask bits */
N
N/********************  Bit definition for USB_OTG_DEACHINT register  ********************/
N#define USB_OTG_DEACHINT_IEP1INT_Pos             (1U)                          
N#define USB_OTG_DEACHINT_IEP1INT_Msk             (0x1UL << USB_OTG_DEACHINT_IEP1INT_Pos) /*!< 0x00000002 */
N#define USB_OTG_DEACHINT_IEP1INT                 USB_OTG_DEACHINT_IEP1INT_Msk  /*!< IN endpoint 1interrupt bit   */
N#define USB_OTG_DEACHINT_OEP1INT_Pos             (17U)                         
N#define USB_OTG_DEACHINT_OEP1INT_Msk             (0x1UL << USB_OTG_DEACHINT_OEP1INT_Pos) /*!< 0x00020000 */
N#define USB_OTG_DEACHINT_OEP1INT                 USB_OTG_DEACHINT_OEP1INT_Msk  /*!< OUT endpoint 1 interrupt bit */
N
N/********************  Bit definition for USB_OTG_GCCFG register  ********************/
N#define USB_OTG_GCCFG_PWRDWN_Pos                 (16U)                         
N#define USB_OTG_GCCFG_PWRDWN_Msk                 (0x1UL << USB_OTG_GCCFG_PWRDWN_Pos) /*!< 0x00010000 */
N#define USB_OTG_GCCFG_PWRDWN                     USB_OTG_GCCFG_PWRDWN_Msk      /*!< Power down */
N#define USB_OTG_GCCFG_I2CPADEN_Pos               (17U)                         
N#define USB_OTG_GCCFG_I2CPADEN_Msk               (0x1UL << USB_OTG_GCCFG_I2CPADEN_Pos) /*!< 0x00020000 */
N#define USB_OTG_GCCFG_I2CPADEN                   USB_OTG_GCCFG_I2CPADEN_Msk    /*!< Enable I2C bus connection for the external I2C PHY interface*/ 
N#define USB_OTG_GCCFG_VBUSASEN_Pos               (18U)                         
N#define USB_OTG_GCCFG_VBUSASEN_Msk               (0x1UL << USB_OTG_GCCFG_VBUSASEN_Pos) /*!< 0x00040000 */
N#define USB_OTG_GCCFG_VBUSASEN                   USB_OTG_GCCFG_VBUSASEN_Msk    /*!< Enable the VBUS sensing device */
N#define USB_OTG_GCCFG_VBUSBSEN_Pos               (19U)                         
N#define USB_OTG_GCCFG_VBUSBSEN_Msk               (0x1UL << USB_OTG_GCCFG_VBUSBSEN_Pos) /*!< 0x00080000 */
N#define USB_OTG_GCCFG_VBUSBSEN                   USB_OTG_GCCFG_VBUSBSEN_Msk    /*!< Enable the VBUS sensing device */
N#define USB_OTG_GCCFG_SOFOUTEN_Pos               (20U)                         
N#define USB_OTG_GCCFG_SOFOUTEN_Msk               (0x1UL << USB_OTG_GCCFG_SOFOUTEN_Pos) /*!< 0x00100000 */
N#define USB_OTG_GCCFG_SOFOUTEN                   USB_OTG_GCCFG_SOFOUTEN_Msk    /*!< SOF output enable */
N#define USB_OTG_GCCFG_NOVBUSSENS_Pos             (21U)                         
N#define USB_OTG_GCCFG_NOVBUSSENS_Msk             (0x1UL << USB_OTG_GCCFG_NOVBUSSENS_Pos) /*!< 0x00200000 */
N#define USB_OTG_GCCFG_NOVBUSSENS                 USB_OTG_GCCFG_NOVBUSSENS_Msk  /*!< VBUS sensing disable option*/ 
N
N/********************  Bit definition forUSB_OTG_DEACHINTMSK register  ********************/
N#define USB_OTG_DEACHINTMSK_IEP1INTM_Pos         (1U)                          
N#define USB_OTG_DEACHINTMSK_IEP1INTM_Msk         (0x1UL << USB_OTG_DEACHINTMSK_IEP1INTM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DEACHINTMSK_IEP1INTM             USB_OTG_DEACHINTMSK_IEP1INTM_Msk /*!< IN Endpoint 1 interrupt mask bit  */
N#define USB_OTG_DEACHINTMSK_OEP1INTM_Pos         (17U)                         
N#define USB_OTG_DEACHINTMSK_OEP1INTM_Msk         (0x1UL << USB_OTG_DEACHINTMSK_OEP1INTM_Pos) /*!< 0x00020000 */
N#define USB_OTG_DEACHINTMSK_OEP1INTM             USB_OTG_DEACHINTMSK_OEP1INTM_Msk /*!< OUT Endpoint 1 interrupt mask bit */
N
N/********************  Bit definition for USB_OTG_CID register  ********************/
N#define USB_OTG_CID_PRODUCT_ID_Pos               (0U)                          
N#define USB_OTG_CID_PRODUCT_ID_Msk               (0xFFFFFFFFUL << USB_OTG_CID_PRODUCT_ID_Pos) /*!< 0xFFFFFFFF */
N#define USB_OTG_CID_PRODUCT_ID                   USB_OTG_CID_PRODUCT_ID_Msk    /*!< Product ID field */
N
N/********************  Bit definition for USB_OTG_DIEPEACHMSK1 register  ********************/
N#define USB_OTG_DIEPEACHMSK1_XFRCM_Pos           (0U)                          
N#define USB_OTG_DIEPEACHMSK1_XFRCM_Msk           (0x1UL << USB_OTG_DIEPEACHMSK1_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_DIEPEACHMSK1_XFRCM               USB_OTG_DIEPEACHMSK1_XFRCM_Msk /*!< Transfer completed interrupt mask                 */
N#define USB_OTG_DIEPEACHMSK1_EPDM_Pos            (1U)                          
N#define USB_OTG_DIEPEACHMSK1_EPDM_Msk            (0x1UL << USB_OTG_DIEPEACHMSK1_EPDM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DIEPEACHMSK1_EPDM                USB_OTG_DIEPEACHMSK1_EPDM_Msk /*!< Endpoint disabled interrupt mask                  */
N#define USB_OTG_DIEPEACHMSK1_TOM_Pos             (3U)                          
N#define USB_OTG_DIEPEACHMSK1_TOM_Msk             (0x1UL << USB_OTG_DIEPEACHMSK1_TOM_Pos) /*!< 0x00000008 */
N#define USB_OTG_DIEPEACHMSK1_TOM                 USB_OTG_DIEPEACHMSK1_TOM_Msk  /*!< Timeout condition mask (nonisochronous endpoints) */
N#define USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Pos       (4U)                          
N#define USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Msk       (0x1UL << USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Pos) /*!< 0x00000010 */
N#define USB_OTG_DIEPEACHMSK1_ITTXFEMSK           USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Msk /*!< IN token received when TxFIFO empty mask          */
N#define USB_OTG_DIEPEACHMSK1_INEPNMM_Pos         (5U)                          
N#define USB_OTG_DIEPEACHMSK1_INEPNMM_Msk         (0x1UL << USB_OTG_DIEPEACHMSK1_INEPNMM_Pos) /*!< 0x00000020 */
N#define USB_OTG_DIEPEACHMSK1_INEPNMM             USB_OTG_DIEPEACHMSK1_INEPNMM_Msk /*!< IN token received with EP mismatch mask           */
N#define USB_OTG_DIEPEACHMSK1_INEPNEM_Pos         (6U)                          
N#define USB_OTG_DIEPEACHMSK1_INEPNEM_Msk         (0x1UL << USB_OTG_DIEPEACHMSK1_INEPNEM_Pos) /*!< 0x00000040 */
N#define USB_OTG_DIEPEACHMSK1_INEPNEM             USB_OTG_DIEPEACHMSK1_INEPNEM_Msk /*!< IN endpoint NAK effective mask                    */
N#define USB_OTG_DIEPEACHMSK1_TXFURM_Pos          (8U)                          
N#define USB_OTG_DIEPEACHMSK1_TXFURM_Msk          (0x1UL << USB_OTG_DIEPEACHMSK1_TXFURM_Pos) /*!< 0x00000100 */
N#define USB_OTG_DIEPEACHMSK1_TXFURM              USB_OTG_DIEPEACHMSK1_TXFURM_Msk /*!< FIFO underrun mask                                */
N#define USB_OTG_DIEPEACHMSK1_BIM_Pos             (9U)                          
N#define USB_OTG_DIEPEACHMSK1_BIM_Msk             (0x1UL << USB_OTG_DIEPEACHMSK1_BIM_Pos) /*!< 0x00000200 */
N#define USB_OTG_DIEPEACHMSK1_BIM                 USB_OTG_DIEPEACHMSK1_BIM_Msk  /*!< BNA interrupt mask                                */
N#define USB_OTG_DIEPEACHMSK1_NAKM_Pos            (13U)                         
N#define USB_OTG_DIEPEACHMSK1_NAKM_Msk            (0x1UL << USB_OTG_DIEPEACHMSK1_NAKM_Pos) /*!< 0x00002000 */
N#define USB_OTG_DIEPEACHMSK1_NAKM                USB_OTG_DIEPEACHMSK1_NAKM_Msk /*!< NAK interrupt mask                                */
N
N/********************  Bit definition for USB_OTG_HPRT register  ********************/
N#define USB_OTG_HPRT_PCSTS_Pos                   (0U)                          
N#define USB_OTG_HPRT_PCSTS_Msk                   (0x1UL << USB_OTG_HPRT_PCSTS_Pos) /*!< 0x00000001 */
N#define USB_OTG_HPRT_PCSTS                       USB_OTG_HPRT_PCSTS_Msk        /*!< Port connect status        */
N#define USB_OTG_HPRT_PCDET_Pos                   (1U)                          
N#define USB_OTG_HPRT_PCDET_Msk                   (0x1UL << USB_OTG_HPRT_PCDET_Pos) /*!< 0x00000002 */
N#define USB_OTG_HPRT_PCDET                       USB_OTG_HPRT_PCDET_Msk        /*!< Port connect detected      */
N#define USB_OTG_HPRT_PENA_Pos                    (2U)                          
N#define USB_OTG_HPRT_PENA_Msk                    (0x1UL << USB_OTG_HPRT_PENA_Pos) /*!< 0x00000004 */
N#define USB_OTG_HPRT_PENA                        USB_OTG_HPRT_PENA_Msk         /*!< Port enable                */
N#define USB_OTG_HPRT_PENCHNG_Pos                 (3U)                          
N#define USB_OTG_HPRT_PENCHNG_Msk                 (0x1UL << USB_OTG_HPRT_PENCHNG_Pos) /*!< 0x00000008 */
N#define USB_OTG_HPRT_PENCHNG                     USB_OTG_HPRT_PENCHNG_Msk      /*!< Port enable/disable change */
N#define USB_OTG_HPRT_POCA_Pos                    (4U)                          
N#define USB_OTG_HPRT_POCA_Msk                    (0x1UL << USB_OTG_HPRT_POCA_Pos) /*!< 0x00000010 */
N#define USB_OTG_HPRT_POCA                        USB_OTG_HPRT_POCA_Msk         /*!< Port overcurrent active    */
N#define USB_OTG_HPRT_POCCHNG_Pos                 (5U)                          
N#define USB_OTG_HPRT_POCCHNG_Msk                 (0x1UL << USB_OTG_HPRT_POCCHNG_Pos) /*!< 0x00000020 */
N#define USB_OTG_HPRT_POCCHNG                     USB_OTG_HPRT_POCCHNG_Msk      /*!< Port overcurrent change    */
N#define USB_OTG_HPRT_PRES_Pos                    (6U)                          
N#define USB_OTG_HPRT_PRES_Msk                    (0x1UL << USB_OTG_HPRT_PRES_Pos) /*!< 0x00000040 */
N#define USB_OTG_HPRT_PRES                        USB_OTG_HPRT_PRES_Msk         /*!< Port resume                */
N#define USB_OTG_HPRT_PSUSP_Pos                   (7U)                          
N#define USB_OTG_HPRT_PSUSP_Msk                   (0x1UL << USB_OTG_HPRT_PSUSP_Pos) /*!< 0x00000080 */
N#define USB_OTG_HPRT_PSUSP                       USB_OTG_HPRT_PSUSP_Msk        /*!< Port suspend               */
N#define USB_OTG_HPRT_PRST_Pos                    (8U)                          
N#define USB_OTG_HPRT_PRST_Msk                    (0x1UL << USB_OTG_HPRT_PRST_Pos) /*!< 0x00000100 */
N#define USB_OTG_HPRT_PRST                        USB_OTG_HPRT_PRST_Msk         /*!< Port reset                 */
N
N#define USB_OTG_HPRT_PLSTS_Pos                   (10U)                         
N#define USB_OTG_HPRT_PLSTS_Msk                   (0x3UL << USB_OTG_HPRT_PLSTS_Pos) /*!< 0x00000C00 */
N#define USB_OTG_HPRT_PLSTS                       USB_OTG_HPRT_PLSTS_Msk        /*!< Port line status           */
N#define USB_OTG_HPRT_PLSTS_0                     (0x1UL << USB_OTG_HPRT_PLSTS_Pos) /*!< 0x00000400 */
N#define USB_OTG_HPRT_PLSTS_1                     (0x2UL << USB_OTG_HPRT_PLSTS_Pos) /*!< 0x00000800 */
N#define USB_OTG_HPRT_PPWR_Pos                    (12U)                         
N#define USB_OTG_HPRT_PPWR_Msk                    (0x1UL << USB_OTG_HPRT_PPWR_Pos) /*!< 0x00001000 */
N#define USB_OTG_HPRT_PPWR                        USB_OTG_HPRT_PPWR_Msk         /*!< Port power                 */
N
N#define USB_OTG_HPRT_PTCTL_Pos                   (13U)                         
N#define USB_OTG_HPRT_PTCTL_Msk                   (0xFUL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x0001E000 */
N#define USB_OTG_HPRT_PTCTL                       USB_OTG_HPRT_PTCTL_Msk        /*!< Port test control          */
N#define USB_OTG_HPRT_PTCTL_0                     (0x1UL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x00002000 */
N#define USB_OTG_HPRT_PTCTL_1                     (0x2UL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x00004000 */
N#define USB_OTG_HPRT_PTCTL_2                     (0x4UL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x00008000 */
N#define USB_OTG_HPRT_PTCTL_3                     (0x8UL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x00010000 */
N
N#define USB_OTG_HPRT_PSPD_Pos                    (17U)                         
N#define USB_OTG_HPRT_PSPD_Msk                    (0x3UL << USB_OTG_HPRT_PSPD_Pos) /*!< 0x00060000 */
N#define USB_OTG_HPRT_PSPD                        USB_OTG_HPRT_PSPD_Msk         /*!< Port speed                 */
N#define USB_OTG_HPRT_PSPD_0                      (0x1UL << USB_OTG_HPRT_PSPD_Pos) /*!< 0x00020000 */
N#define USB_OTG_HPRT_PSPD_1                      (0x2UL << USB_OTG_HPRT_PSPD_Pos) /*!< 0x00040000 */
N
N/********************  Bit definition for USB_OTG_DOEPEACHMSK1 register  ********************/
N#define USB_OTG_DOEPEACHMSK1_XFRCM_Pos           (0U)                          
N#define USB_OTG_DOEPEACHMSK1_XFRCM_Msk           (0x1UL << USB_OTG_DOEPEACHMSK1_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_DOEPEACHMSK1_XFRCM               USB_OTG_DOEPEACHMSK1_XFRCM_Msk /*!< Transfer completed interrupt mask         */
N#define USB_OTG_DOEPEACHMSK1_EPDM_Pos            (1U)                          
N#define USB_OTG_DOEPEACHMSK1_EPDM_Msk            (0x1UL << USB_OTG_DOEPEACHMSK1_EPDM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DOEPEACHMSK1_EPDM                USB_OTG_DOEPEACHMSK1_EPDM_Msk /*!< Endpoint disabled interrupt mask          */
N#define USB_OTG_DOEPEACHMSK1_TOM_Pos             (3U)                          
N#define USB_OTG_DOEPEACHMSK1_TOM_Msk             (0x1UL << USB_OTG_DOEPEACHMSK1_TOM_Pos) /*!< 0x00000008 */
N#define USB_OTG_DOEPEACHMSK1_TOM                 USB_OTG_DOEPEACHMSK1_TOM_Msk  /*!< Timeout condition mask                    */
N#define USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Pos       (4U)                          
N#define USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Msk       (0x1UL << USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Pos) /*!< 0x00000010 */
N#define USB_OTG_DOEPEACHMSK1_ITTXFEMSK           USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Msk /*!< IN token received when TxFIFO empty mask  */
N#define USB_OTG_DOEPEACHMSK1_INEPNMM_Pos         (5U)                          
N#define USB_OTG_DOEPEACHMSK1_INEPNMM_Msk         (0x1UL << USB_OTG_DOEPEACHMSK1_INEPNMM_Pos) /*!< 0x00000020 */
N#define USB_OTG_DOEPEACHMSK1_INEPNMM             USB_OTG_DOEPEACHMSK1_INEPNMM_Msk /*!< IN token received with EP mismatch mask   */
N#define USB_OTG_DOEPEACHMSK1_INEPNEM_Pos         (6U)                          
N#define USB_OTG_DOEPEACHMSK1_INEPNEM_Msk         (0x1UL << USB_OTG_DOEPEACHMSK1_INEPNEM_Pos) /*!< 0x00000040 */
N#define USB_OTG_DOEPEACHMSK1_INEPNEM             USB_OTG_DOEPEACHMSK1_INEPNEM_Msk /*!< IN endpoint NAK effective mask            */
N#define USB_OTG_DOEPEACHMSK1_TXFURM_Pos          (8U)                          
N#define USB_OTG_DOEPEACHMSK1_TXFURM_Msk          (0x1UL << USB_OTG_DOEPEACHMSK1_TXFURM_Pos) /*!< 0x00000100 */
N#define USB_OTG_DOEPEACHMSK1_TXFURM              USB_OTG_DOEPEACHMSK1_TXFURM_Msk /*!< OUT packet error mask                     */
N#define USB_OTG_DOEPEACHMSK1_BIM_Pos             (9U)                          
N#define USB_OTG_DOEPEACHMSK1_BIM_Msk             (0x1UL << USB_OTG_DOEPEACHMSK1_BIM_Pos) /*!< 0x00000200 */
N#define USB_OTG_DOEPEACHMSK1_BIM                 USB_OTG_DOEPEACHMSK1_BIM_Msk  /*!< BNA interrupt mask                        */
N#define USB_OTG_DOEPEACHMSK1_BERRM_Pos           (12U)                         
N#define USB_OTG_DOEPEACHMSK1_BERRM_Msk           (0x1UL << USB_OTG_DOEPEACHMSK1_BERRM_Pos) /*!< 0x00001000 */
N#define USB_OTG_DOEPEACHMSK1_BERRM               USB_OTG_DOEPEACHMSK1_BERRM_Msk /*!< Bubble error interrupt mask               */
N#define USB_OTG_DOEPEACHMSK1_NAKM_Pos            (13U)                         
N#define USB_OTG_DOEPEACHMSK1_NAKM_Msk            (0x1UL << USB_OTG_DOEPEACHMSK1_NAKM_Pos) /*!< 0x00002000 */
N#define USB_OTG_DOEPEACHMSK1_NAKM                USB_OTG_DOEPEACHMSK1_NAKM_Msk /*!< NAK interrupt mask                        */
N#define USB_OTG_DOEPEACHMSK1_NYETM_Pos           (14U)                         
N#define USB_OTG_DOEPEACHMSK1_NYETM_Msk           (0x1UL << USB_OTG_DOEPEACHMSK1_NYETM_Pos) /*!< 0x00004000 */
N#define USB_OTG_DOEPEACHMSK1_NYETM               USB_OTG_DOEPEACHMSK1_NYETM_Msk /*!< NYET interrupt mask                       */
N
N/********************  Bit definition for USB_OTG_HPTXFSIZ register  ********************/
N#define USB_OTG_HPTXFSIZ_PTXSA_Pos               (0U)                          
N#define USB_OTG_HPTXFSIZ_PTXSA_Msk               (0xFFFFUL << USB_OTG_HPTXFSIZ_PTXSA_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HPTXFSIZ_PTXSA                   USB_OTG_HPTXFSIZ_PTXSA_Msk    /*!< Host periodic TxFIFO start address            */
N#define USB_OTG_HPTXFSIZ_PTXFD_Pos               (16U)                         
N#define USB_OTG_HPTXFSIZ_PTXFD_Msk               (0xFFFFUL << USB_OTG_HPTXFSIZ_PTXFD_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_HPTXFSIZ_PTXFD                   USB_OTG_HPTXFSIZ_PTXFD_Msk    /*!< Host periodic TxFIFO depth                    */
N
N/********************  Bit definition for USB_OTG_DIEPCTL register  ********************/
N#define USB_OTG_DIEPCTL_MPSIZ_Pos                (0U)                          
N#define USB_OTG_DIEPCTL_MPSIZ_Msk                (0x7FFUL << USB_OTG_DIEPCTL_MPSIZ_Pos) /*!< 0x000007FF */
N#define USB_OTG_DIEPCTL_MPSIZ                    USB_OTG_DIEPCTL_MPSIZ_Msk     /*!< Maximum packet size              */
N#define USB_OTG_DIEPCTL_USBAEP_Pos               (15U)                         
N#define USB_OTG_DIEPCTL_USBAEP_Msk               (0x1UL << USB_OTG_DIEPCTL_USBAEP_Pos) /*!< 0x00008000 */
N#define USB_OTG_DIEPCTL_USBAEP                   USB_OTG_DIEPCTL_USBAEP_Msk    /*!< USB active endpoint              */
N#define USB_OTG_DIEPCTL_EONUM_DPID_Pos           (16U)                         
N#define USB_OTG_DIEPCTL_EONUM_DPID_Msk           (0x1UL << USB_OTG_DIEPCTL_EONUM_DPID_Pos) /*!< 0x00010000 */
N#define USB_OTG_DIEPCTL_EONUM_DPID               USB_OTG_DIEPCTL_EONUM_DPID_Msk /*!< Even/odd frame                   */
N#define USB_OTG_DIEPCTL_NAKSTS_Pos               (17U)                         
N#define USB_OTG_DIEPCTL_NAKSTS_Msk               (0x1UL << USB_OTG_DIEPCTL_NAKSTS_Pos) /*!< 0x00020000 */
N#define USB_OTG_DIEPCTL_NAKSTS                   USB_OTG_DIEPCTL_NAKSTS_Msk    /*!< NAK status                       */
N
N#define USB_OTG_DIEPCTL_EPTYP_Pos                (18U)                         
N#define USB_OTG_DIEPCTL_EPTYP_Msk                (0x3UL << USB_OTG_DIEPCTL_EPTYP_Pos) /*!< 0x000C0000 */
N#define USB_OTG_DIEPCTL_EPTYP                    USB_OTG_DIEPCTL_EPTYP_Msk     /*!< Endpoint type                    */
N#define USB_OTG_DIEPCTL_EPTYP_0                  (0x1UL << USB_OTG_DIEPCTL_EPTYP_Pos) /*!< 0x00040000 */
N#define USB_OTG_DIEPCTL_EPTYP_1                  (0x2UL << USB_OTG_DIEPCTL_EPTYP_Pos) /*!< 0x00080000 */
N#define USB_OTG_DIEPCTL_STALL_Pos                (21U)                         
N#define USB_OTG_DIEPCTL_STALL_Msk                (0x1UL << USB_OTG_DIEPCTL_STALL_Pos) /*!< 0x00200000 */
N#define USB_OTG_DIEPCTL_STALL                    USB_OTG_DIEPCTL_STALL_Msk     /*!< STALL handshake                  */
N
N#define USB_OTG_DIEPCTL_TXFNUM_Pos               (22U)                         
N#define USB_OTG_DIEPCTL_TXFNUM_Msk               (0xFUL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x03C00000 */
N#define USB_OTG_DIEPCTL_TXFNUM                   USB_OTG_DIEPCTL_TXFNUM_Msk    /*!< TxFIFO number                    */
N#define USB_OTG_DIEPCTL_TXFNUM_0                 (0x1UL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x00400000 */
N#define USB_OTG_DIEPCTL_TXFNUM_1                 (0x2UL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x00800000 */
N#define USB_OTG_DIEPCTL_TXFNUM_2                 (0x4UL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x01000000 */
N#define USB_OTG_DIEPCTL_TXFNUM_3                 (0x8UL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x02000000 */
N#define USB_OTG_DIEPCTL_CNAK_Pos                 (26U)                         
N#define USB_OTG_DIEPCTL_CNAK_Msk                 (0x1UL << USB_OTG_DIEPCTL_CNAK_Pos) /*!< 0x04000000 */
N#define USB_OTG_DIEPCTL_CNAK                     USB_OTG_DIEPCTL_CNAK_Msk      /*!< Clear NAK                        */
N#define USB_OTG_DIEPCTL_SNAK_Pos                 (27U)                         
N#define USB_OTG_DIEPCTL_SNAK_Msk                 (0x1UL << USB_OTG_DIEPCTL_SNAK_Pos) /*!< 0x08000000 */
N#define USB_OTG_DIEPCTL_SNAK                     USB_OTG_DIEPCTL_SNAK_Msk      /*!< Set NAK */
N#define USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Pos       (28U)                         
N#define USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Msk       (0x1UL << USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Pos) /*!< 0x10000000 */
N#define USB_OTG_DIEPCTL_SD0PID_SEVNFRM           USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Msk /*!< Set DATA0 PID                    */
N#define USB_OTG_DIEPCTL_SODDFRM_Pos              (29U)                         
N#define USB_OTG_DIEPCTL_SODDFRM_Msk              (0x1UL << USB_OTG_DIEPCTL_SODDFRM_Pos) /*!< 0x20000000 */
N#define USB_OTG_DIEPCTL_SODDFRM                  USB_OTG_DIEPCTL_SODDFRM_Msk   /*!< Set odd frame                    */
N#define USB_OTG_DIEPCTL_EPDIS_Pos                (30U)                         
N#define USB_OTG_DIEPCTL_EPDIS_Msk                (0x1UL << USB_OTG_DIEPCTL_EPDIS_Pos) /*!< 0x40000000 */
N#define USB_OTG_DIEPCTL_EPDIS                    USB_OTG_DIEPCTL_EPDIS_Msk     /*!< Endpoint disable                 */
N#define USB_OTG_DIEPCTL_EPENA_Pos                (31U)                         
N#define USB_OTG_DIEPCTL_EPENA_Msk                (0x1UL << USB_OTG_DIEPCTL_EPENA_Pos) /*!< 0x80000000 */
N#define USB_OTG_DIEPCTL_EPENA                    USB_OTG_DIEPCTL_EPENA_Msk     /*!< Endpoint enable                  */
N
N/********************  Bit definition for USB_OTG_HCCHAR register  ********************/
N#define USB_OTG_HCCHAR_MPSIZ_Pos                 (0U)                          
N#define USB_OTG_HCCHAR_MPSIZ_Msk                 (0x7FFUL << USB_OTG_HCCHAR_MPSIZ_Pos) /*!< 0x000007FF */
N#define USB_OTG_HCCHAR_MPSIZ                     USB_OTG_HCCHAR_MPSIZ_Msk      /*!< Maximum packet size */
N
N#define USB_OTG_HCCHAR_EPNUM_Pos                 (11U)                         
N#define USB_OTG_HCCHAR_EPNUM_Msk                 (0xFUL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00007800 */
N#define USB_OTG_HCCHAR_EPNUM                     USB_OTG_HCCHAR_EPNUM_Msk      /*!< Endpoint number */
N#define USB_OTG_HCCHAR_EPNUM_0                   (0x1UL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00000800 */
N#define USB_OTG_HCCHAR_EPNUM_1                   (0x2UL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00001000 */
N#define USB_OTG_HCCHAR_EPNUM_2                   (0x4UL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00002000 */
N#define USB_OTG_HCCHAR_EPNUM_3                   (0x8UL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00004000 */
N#define USB_OTG_HCCHAR_EPDIR_Pos                 (15U)                         
N#define USB_OTG_HCCHAR_EPDIR_Msk                 (0x1UL << USB_OTG_HCCHAR_EPDIR_Pos) /*!< 0x00008000 */
N#define USB_OTG_HCCHAR_EPDIR                     USB_OTG_HCCHAR_EPDIR_Msk      /*!< Endpoint direction */
N#define USB_OTG_HCCHAR_LSDEV_Pos                 (17U)                         
N#define USB_OTG_HCCHAR_LSDEV_Msk                 (0x1UL << USB_OTG_HCCHAR_LSDEV_Pos) /*!< 0x00020000 */
N#define USB_OTG_HCCHAR_LSDEV                     USB_OTG_HCCHAR_LSDEV_Msk      /*!< Low-speed device */
N
N#define USB_OTG_HCCHAR_EPTYP_Pos                 (18U)                         
N#define USB_OTG_HCCHAR_EPTYP_Msk                 (0x3UL << USB_OTG_HCCHAR_EPTYP_Pos) /*!< 0x000C0000 */
N#define USB_OTG_HCCHAR_EPTYP                     USB_OTG_HCCHAR_EPTYP_Msk      /*!< Endpoint type */
N#define USB_OTG_HCCHAR_EPTYP_0                   (0x1UL << USB_OTG_HCCHAR_EPTYP_Pos) /*!< 0x00040000 */
N#define USB_OTG_HCCHAR_EPTYP_1                   (0x2UL << USB_OTG_HCCHAR_EPTYP_Pos) /*!< 0x00080000 */
N
N#define USB_OTG_HCCHAR_MC_Pos                    (20U)                         
N#define USB_OTG_HCCHAR_MC_Msk                    (0x3UL << USB_OTG_HCCHAR_MC_Pos) /*!< 0x00300000 */
N#define USB_OTG_HCCHAR_MC                        USB_OTG_HCCHAR_MC_Msk         /*!< Multi Count (MC) / Error Count (EC) */
N#define USB_OTG_HCCHAR_MC_0                      (0x1UL << USB_OTG_HCCHAR_MC_Pos) /*!< 0x00100000 */
N#define USB_OTG_HCCHAR_MC_1                      (0x2UL << USB_OTG_HCCHAR_MC_Pos) /*!< 0x00200000 */
N
N#define USB_OTG_HCCHAR_DAD_Pos                   (22U)                         
N#define USB_OTG_HCCHAR_DAD_Msk                   (0x7FUL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x1FC00000 */
N#define USB_OTG_HCCHAR_DAD                       USB_OTG_HCCHAR_DAD_Msk        /*!< Device address */
N#define USB_OTG_HCCHAR_DAD_0                     (0x01UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x00400000 */
N#define USB_OTG_HCCHAR_DAD_1                     (0x02UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x00800000 */
N#define USB_OTG_HCCHAR_DAD_2                     (0x04UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x01000000 */
N#define USB_OTG_HCCHAR_DAD_3                     (0x08UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x02000000 */
N#define USB_OTG_HCCHAR_DAD_4                     (0x10UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x04000000 */
N#define USB_OTG_HCCHAR_DAD_5                     (0x20UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x08000000 */
N#define USB_OTG_HCCHAR_DAD_6                     (0x40UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x10000000 */
N#define USB_OTG_HCCHAR_ODDFRM_Pos                (29U)                         
N#define USB_OTG_HCCHAR_ODDFRM_Msk                (0x1UL << USB_OTG_HCCHAR_ODDFRM_Pos) /*!< 0x20000000 */
N#define USB_OTG_HCCHAR_ODDFRM                    USB_OTG_HCCHAR_ODDFRM_Msk     /*!< Odd frame */
N#define USB_OTG_HCCHAR_CHDIS_Pos                 (30U)                         
N#define USB_OTG_HCCHAR_CHDIS_Msk                 (0x1UL << USB_OTG_HCCHAR_CHDIS_Pos) /*!< 0x40000000 */
N#define USB_OTG_HCCHAR_CHDIS                     USB_OTG_HCCHAR_CHDIS_Msk      /*!< Channel disable */
N#define USB_OTG_HCCHAR_CHENA_Pos                 (31U)                         
N#define USB_OTG_HCCHAR_CHENA_Msk                 (0x1UL << USB_OTG_HCCHAR_CHENA_Pos) /*!< 0x80000000 */
N#define USB_OTG_HCCHAR_CHENA                     USB_OTG_HCCHAR_CHENA_Msk      /*!< Channel enable */
N
N/********************  Bit definition for USB_OTG_HCSPLT register  ********************/
N
N#define USB_OTG_HCSPLT_PRTADDR_Pos               (0U)                          
N#define USB_OTG_HCSPLT_PRTADDR_Msk               (0x7FUL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x0000007F */
N#define USB_OTG_HCSPLT_PRTADDR                   USB_OTG_HCSPLT_PRTADDR_Msk    /*!< Port address */
N#define USB_OTG_HCSPLT_PRTADDR_0                 (0x01UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000001 */
N#define USB_OTG_HCSPLT_PRTADDR_1                 (0x02UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000002 */
N#define USB_OTG_HCSPLT_PRTADDR_2                 (0x04UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000004 */
N#define USB_OTG_HCSPLT_PRTADDR_3                 (0x08UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000008 */
N#define USB_OTG_HCSPLT_PRTADDR_4                 (0x10UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000010 */
N#define USB_OTG_HCSPLT_PRTADDR_5                 (0x20UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000020 */
N#define USB_OTG_HCSPLT_PRTADDR_6                 (0x40UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000040 */
N
N#define USB_OTG_HCSPLT_HUBADDR_Pos               (7U)                          
N#define USB_OTG_HCSPLT_HUBADDR_Msk               (0x7FUL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00003F80 */
N#define USB_OTG_HCSPLT_HUBADDR                   USB_OTG_HCSPLT_HUBADDR_Msk    /*!< Hub address */
N#define USB_OTG_HCSPLT_HUBADDR_0                 (0x01UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000080 */
N#define USB_OTG_HCSPLT_HUBADDR_1                 (0x02UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000100 */
N#define USB_OTG_HCSPLT_HUBADDR_2                 (0x04UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000200 */
N#define USB_OTG_HCSPLT_HUBADDR_3                 (0x08UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000400 */
N#define USB_OTG_HCSPLT_HUBADDR_4                 (0x10UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000800 */
N#define USB_OTG_HCSPLT_HUBADDR_5                 (0x20UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00001000 */
N#define USB_OTG_HCSPLT_HUBADDR_6                 (0x40UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00002000 */
N
N#define USB_OTG_HCSPLT_XACTPOS_Pos               (14U)                         
N#define USB_OTG_HCSPLT_XACTPOS_Msk               (0x3UL << USB_OTG_HCSPLT_XACTPOS_Pos) /*!< 0x0000C000 */
N#define USB_OTG_HCSPLT_XACTPOS                   USB_OTG_HCSPLT_XACTPOS_Msk    /*!< XACTPOS */
N#define USB_OTG_HCSPLT_XACTPOS_0                 (0x1UL << USB_OTG_HCSPLT_XACTPOS_Pos) /*!< 0x00004000 */
N#define USB_OTG_HCSPLT_XACTPOS_1                 (0x2UL << USB_OTG_HCSPLT_XACTPOS_Pos) /*!< 0x00008000 */
N#define USB_OTG_HCSPLT_COMPLSPLT_Pos             (16U)                         
N#define USB_OTG_HCSPLT_COMPLSPLT_Msk             (0x1UL << USB_OTG_HCSPLT_COMPLSPLT_Pos) /*!< 0x00010000 */
N#define USB_OTG_HCSPLT_COMPLSPLT                 USB_OTG_HCSPLT_COMPLSPLT_Msk  /*!< Do complete split */
N#define USB_OTG_HCSPLT_SPLITEN_Pos               (31U)                         
N#define USB_OTG_HCSPLT_SPLITEN_Msk               (0x1UL << USB_OTG_HCSPLT_SPLITEN_Pos) /*!< 0x80000000 */
N#define USB_OTG_HCSPLT_SPLITEN                   USB_OTG_HCSPLT_SPLITEN_Msk    /*!< Split enable */
N
N/********************  Bit definition for USB_OTG_HCINT register  ********************/
N#define USB_OTG_HCINT_XFRC_Pos                   (0U)                          
N#define USB_OTG_HCINT_XFRC_Msk                   (0x1UL << USB_OTG_HCINT_XFRC_Pos) /*!< 0x00000001 */
N#define USB_OTG_HCINT_XFRC                       USB_OTG_HCINT_XFRC_Msk        /*!< Transfer completed */
N#define USB_OTG_HCINT_CHH_Pos                    (1U)                          
N#define USB_OTG_HCINT_CHH_Msk                    (0x1UL << USB_OTG_HCINT_CHH_Pos) /*!< 0x00000002 */
N#define USB_OTG_HCINT_CHH                        USB_OTG_HCINT_CHH_Msk         /*!< Channel halted */
N#define USB_OTG_HCINT_AHBERR_Pos                 (2U)                          
N#define USB_OTG_HCINT_AHBERR_Msk                 (0x1UL << USB_OTG_HCINT_AHBERR_Pos) /*!< 0x00000004 */
N#define USB_OTG_HCINT_AHBERR                     USB_OTG_HCINT_AHBERR_Msk      /*!< AHB error */
N#define USB_OTG_HCINT_STALL_Pos                  (3U)                          
N#define USB_OTG_HCINT_STALL_Msk                  (0x1UL << USB_OTG_HCINT_STALL_Pos) /*!< 0x00000008 */
N#define USB_OTG_HCINT_STALL                      USB_OTG_HCINT_STALL_Msk       /*!< STALL response received interrupt */
N#define USB_OTG_HCINT_NAK_Pos                    (4U)                          
N#define USB_OTG_HCINT_NAK_Msk                    (0x1UL << USB_OTG_HCINT_NAK_Pos) /*!< 0x00000010 */
N#define USB_OTG_HCINT_NAK                        USB_OTG_HCINT_NAK_Msk         /*!< NAK response received interrupt */
N#define USB_OTG_HCINT_ACK_Pos                    (5U)                          
N#define USB_OTG_HCINT_ACK_Msk                    (0x1UL << USB_OTG_HCINT_ACK_Pos) /*!< 0x00000020 */
N#define USB_OTG_HCINT_ACK                        USB_OTG_HCINT_ACK_Msk         /*!< ACK response received/transmitted interrupt */
N#define USB_OTG_HCINT_NYET_Pos                   (6U)                          
N#define USB_OTG_HCINT_NYET_Msk                   (0x1UL << USB_OTG_HCINT_NYET_Pos) /*!< 0x00000040 */
N#define USB_OTG_HCINT_NYET                       USB_OTG_HCINT_NYET_Msk        /*!< Response received interrupt */
N#define USB_OTG_HCINT_TXERR_Pos                  (7U)                          
N#define USB_OTG_HCINT_TXERR_Msk                  (0x1UL << USB_OTG_HCINT_TXERR_Pos) /*!< 0x00000080 */
N#define USB_OTG_HCINT_TXERR                      USB_OTG_HCINT_TXERR_Msk       /*!< Transaction error */
N#define USB_OTG_HCINT_BBERR_Pos                  (8U)                          
N#define USB_OTG_HCINT_BBERR_Msk                  (0x1UL << USB_OTG_HCINT_BBERR_Pos) /*!< 0x00000100 */
N#define USB_OTG_HCINT_BBERR                      USB_OTG_HCINT_BBERR_Msk       /*!< Babble error */
N#define USB_OTG_HCINT_FRMOR_Pos                  (9U)                          
N#define USB_OTG_HCINT_FRMOR_Msk                  (0x1UL << USB_OTG_HCINT_FRMOR_Pos) /*!< 0x00000200 */
N#define USB_OTG_HCINT_FRMOR                      USB_OTG_HCINT_FRMOR_Msk       /*!< Frame overrun */
N#define USB_OTG_HCINT_DTERR_Pos                  (10U)                         
N#define USB_OTG_HCINT_DTERR_Msk                  (0x1UL << USB_OTG_HCINT_DTERR_Pos) /*!< 0x00000400 */
N#define USB_OTG_HCINT_DTERR                      USB_OTG_HCINT_DTERR_Msk       /*!< Data toggle error */
N
N/********************  Bit definition for USB_OTG_DIEPINT register  ********************/
N#define USB_OTG_DIEPINT_XFRC_Pos                 (0U)                          
N#define USB_OTG_DIEPINT_XFRC_Msk                 (0x1UL << USB_OTG_DIEPINT_XFRC_Pos) /*!< 0x00000001 */
N#define USB_OTG_DIEPINT_XFRC                     USB_OTG_DIEPINT_XFRC_Msk      /*!< Transfer completed interrupt */
N#define USB_OTG_DIEPINT_EPDISD_Pos               (1U)                          
N#define USB_OTG_DIEPINT_EPDISD_Msk               (0x1UL << USB_OTG_DIEPINT_EPDISD_Pos) /*!< 0x00000002 */
N#define USB_OTG_DIEPINT_EPDISD                   USB_OTG_DIEPINT_EPDISD_Msk    /*!< Endpoint disabled interrupt */
N#define USB_OTG_DIEPINT_AHBERR_Pos               (2U)
N#define USB_OTG_DIEPINT_AHBERR_Msk               (0x1UL << USB_OTG_DIEPINT_AHBERR_Pos) /*!< 0x00000004 */
N#define USB_OTG_DIEPINT_AHBERR                   USB_OTG_DIEPINT_AHBERR_Msk   /*!< AHB Error (AHBErr) during an IN transaction */
N#define USB_OTG_DIEPINT_TOC_Pos                  (3U)                          
N#define USB_OTG_DIEPINT_TOC_Msk                  (0x1UL << USB_OTG_DIEPINT_TOC_Pos) /*!< 0x00000008 */
N#define USB_OTG_DIEPINT_TOC                      USB_OTG_DIEPINT_TOC_Msk       /*!< Timeout condition */
N#define USB_OTG_DIEPINT_ITTXFE_Pos               (4U)                          
N#define USB_OTG_DIEPINT_ITTXFE_Msk               (0x1UL << USB_OTG_DIEPINT_ITTXFE_Pos) /*!< 0x00000010 */
N#define USB_OTG_DIEPINT_ITTXFE                   USB_OTG_DIEPINT_ITTXFE_Msk    /*!< IN token received when TxFIFO is empty */
N#define USB_OTG_DIEPINT_INEPNM_Pos               (5U)
N#define USB_OTG_DIEPINT_INEPNM_Msk               (0x1UL << USB_OTG_DIEPINT_INEPNM_Pos) /*!< 0x00000004 */
N#define USB_OTG_DIEPINT_INEPNM                   USB_OTG_DIEPINT_INEPNM_Msk   /*!< IN token received with EP mismatch */
N#define USB_OTG_DIEPINT_INEPNE_Pos               (6U)                          
N#define USB_OTG_DIEPINT_INEPNE_Msk               (0x1UL << USB_OTG_DIEPINT_INEPNE_Pos) /*!< 0x00000040 */
N#define USB_OTG_DIEPINT_INEPNE                   USB_OTG_DIEPINT_INEPNE_Msk    /*!< IN endpoint NAK effective */
N#define USB_OTG_DIEPINT_TXFE_Pos                 (7U)                          
N#define USB_OTG_DIEPINT_TXFE_Msk                 (0x1UL << USB_OTG_DIEPINT_TXFE_Pos) /*!< 0x00000080 */
N#define USB_OTG_DIEPINT_TXFE                     USB_OTG_DIEPINT_TXFE_Msk      /*!< Transmit FIFO empty */
N#define USB_OTG_DIEPINT_TXFIFOUDRN_Pos           (8U)                          
N#define USB_OTG_DIEPINT_TXFIFOUDRN_Msk           (0x1UL << USB_OTG_DIEPINT_TXFIFOUDRN_Pos) /*!< 0x00000100 */
N#define USB_OTG_DIEPINT_TXFIFOUDRN               USB_OTG_DIEPINT_TXFIFOUDRN_Msk /*!< Transmit Fifo Underrun */
N#define USB_OTG_DIEPINT_BNA_Pos                  (9U)                          
N#define USB_OTG_DIEPINT_BNA_Msk                  (0x1UL << USB_OTG_DIEPINT_BNA_Pos) /*!< 0x00000200 */
N#define USB_OTG_DIEPINT_BNA                      USB_OTG_DIEPINT_BNA_Msk       /*!< Buffer not available interrupt */
N#define USB_OTG_DIEPINT_PKTDRPSTS_Pos            (11U)                         
N#define USB_OTG_DIEPINT_PKTDRPSTS_Msk            (0x1UL << USB_OTG_DIEPINT_PKTDRPSTS_Pos) /*!< 0x00000800 */
N#define USB_OTG_DIEPINT_PKTDRPSTS                USB_OTG_DIEPINT_PKTDRPSTS_Msk /*!< Packet dropped status */
N#define USB_OTG_DIEPINT_BERR_Pos                 (12U)                         
N#define USB_OTG_DIEPINT_BERR_Msk                 (0x1UL << USB_OTG_DIEPINT_BERR_Pos) /*!< 0x00001000 */
N#define USB_OTG_DIEPINT_BERR                     USB_OTG_DIEPINT_BERR_Msk      /*!< Babble error interrupt */
N#define USB_OTG_DIEPINT_NAK_Pos                  (13U)                         
N#define USB_OTG_DIEPINT_NAK_Msk                  (0x1UL << USB_OTG_DIEPINT_NAK_Pos) /*!< 0x00002000 */
N#define USB_OTG_DIEPINT_NAK                      USB_OTG_DIEPINT_NAK_Msk       /*!< NAK interrupt */
N
N/********************  Bit definition forUSB_OTG_HCINTMSK register  ********************/
N#define USB_OTG_HCINTMSK_XFRCM_Pos               (0U)                          
N#define USB_OTG_HCINTMSK_XFRCM_Msk               (0x1UL << USB_OTG_HCINTMSK_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_HCINTMSK_XFRCM                   USB_OTG_HCINTMSK_XFRCM_Msk    /*!< Transfer completed mask */
N#define USB_OTG_HCINTMSK_CHHM_Pos                (1U)                          
N#define USB_OTG_HCINTMSK_CHHM_Msk                (0x1UL << USB_OTG_HCINTMSK_CHHM_Pos) /*!< 0x00000002 */
N#define USB_OTG_HCINTMSK_CHHM                    USB_OTG_HCINTMSK_CHHM_Msk     /*!< Channel halted mask */
N#define USB_OTG_HCINTMSK_AHBERR_Pos              (2U)                          
N#define USB_OTG_HCINTMSK_AHBERR_Msk              (0x1UL << USB_OTG_HCINTMSK_AHBERR_Pos) /*!< 0x00000004 */
N#define USB_OTG_HCINTMSK_AHBERR                  USB_OTG_HCINTMSK_AHBERR_Msk   /*!< AHB error */
N#define USB_OTG_HCINTMSK_STALLM_Pos              (3U)                          
N#define USB_OTG_HCINTMSK_STALLM_Msk              (0x1UL << USB_OTG_HCINTMSK_STALLM_Pos) /*!< 0x00000008 */
N#define USB_OTG_HCINTMSK_STALLM                  USB_OTG_HCINTMSK_STALLM_Msk   /*!< STALL response received interrupt mask */
N#define USB_OTG_HCINTMSK_NAKM_Pos                (4U)                          
N#define USB_OTG_HCINTMSK_NAKM_Msk                (0x1UL << USB_OTG_HCINTMSK_NAKM_Pos) /*!< 0x00000010 */
N#define USB_OTG_HCINTMSK_NAKM                    USB_OTG_HCINTMSK_NAKM_Msk     /*!< NAK response received interrupt mask */
N#define USB_OTG_HCINTMSK_ACKM_Pos                (5U)                          
N#define USB_OTG_HCINTMSK_ACKM_Msk                (0x1UL << USB_OTG_HCINTMSK_ACKM_Pos) /*!< 0x00000020 */
N#define USB_OTG_HCINTMSK_ACKM                    USB_OTG_HCINTMSK_ACKM_Msk     /*!< ACK response received/transmitted interrupt mask */
N#define USB_OTG_HCINTMSK_NYET_Pos                (6U)                          
N#define USB_OTG_HCINTMSK_NYET_Msk                (0x1UL << USB_OTG_HCINTMSK_NYET_Pos) /*!< 0x00000040 */
N#define USB_OTG_HCINTMSK_NYET                    USB_OTG_HCINTMSK_NYET_Msk     /*!< response received interrupt mask */
N#define USB_OTG_HCINTMSK_TXERRM_Pos              (7U)                          
N#define USB_OTG_HCINTMSK_TXERRM_Msk              (0x1UL << USB_OTG_HCINTMSK_TXERRM_Pos) /*!< 0x00000080 */
N#define USB_OTG_HCINTMSK_TXERRM                  USB_OTG_HCINTMSK_TXERRM_Msk   /*!< Transaction error mask */
N#define USB_OTG_HCINTMSK_BBERRM_Pos              (8U)                          
N#define USB_OTG_HCINTMSK_BBERRM_Msk              (0x1UL << USB_OTG_HCINTMSK_BBERRM_Pos) /*!< 0x00000100 */
N#define USB_OTG_HCINTMSK_BBERRM                  USB_OTG_HCINTMSK_BBERRM_Msk   /*!< Babble error mask */
N#define USB_OTG_HCINTMSK_FRMORM_Pos              (9U)                          
N#define USB_OTG_HCINTMSK_FRMORM_Msk              (0x1UL << USB_OTG_HCINTMSK_FRMORM_Pos) /*!< 0x00000200 */
N#define USB_OTG_HCINTMSK_FRMORM                  USB_OTG_HCINTMSK_FRMORM_Msk   /*!< Frame overrun mask */
N#define USB_OTG_HCINTMSK_DTERRM_Pos              (10U)                         
N#define USB_OTG_HCINTMSK_DTERRM_Msk              (0x1UL << USB_OTG_HCINTMSK_DTERRM_Pos) /*!< 0x00000400 */
N#define USB_OTG_HCINTMSK_DTERRM                  USB_OTG_HCINTMSK_DTERRM_Msk   /*!< Data toggle error mask */
N
N/********************  Bit definition for USB_OTG_DIEPTSIZ register  ********************/
N
N#define USB_OTG_DIEPTSIZ_XFRSIZ_Pos              (0U)                          
N#define USB_OTG_DIEPTSIZ_XFRSIZ_Msk              (0x7FFFFUL << USB_OTG_DIEPTSIZ_XFRSIZ_Pos) /*!< 0x0007FFFF */
N#define USB_OTG_DIEPTSIZ_XFRSIZ                  USB_OTG_DIEPTSIZ_XFRSIZ_Msk   /*!< Transfer size */
N#define USB_OTG_DIEPTSIZ_PKTCNT_Pos              (19U)                         
N#define USB_OTG_DIEPTSIZ_PKTCNT_Msk              (0x3FFUL << USB_OTG_DIEPTSIZ_PKTCNT_Pos) /*!< 0x1FF80000 */
N#define USB_OTG_DIEPTSIZ_PKTCNT                  USB_OTG_DIEPTSIZ_PKTCNT_Msk   /*!< Packet count */
N#define USB_OTG_DIEPTSIZ_MULCNT_Pos              (29U)                         
N#define USB_OTG_DIEPTSIZ_MULCNT_Msk              (0x3UL << USB_OTG_DIEPTSIZ_MULCNT_Pos) /*!< 0x60000000 */
N#define USB_OTG_DIEPTSIZ_MULCNT                  USB_OTG_DIEPTSIZ_MULCNT_Msk   /*!< Packet count */
N/********************  Bit definition for USB_OTG_HCTSIZ register  ********************/
N#define USB_OTG_HCTSIZ_XFRSIZ_Pos                (0U)                          
N#define USB_OTG_HCTSIZ_XFRSIZ_Msk                (0x7FFFFUL << USB_OTG_HCTSIZ_XFRSIZ_Pos) /*!< 0x0007FFFF */
N#define USB_OTG_HCTSIZ_XFRSIZ                    USB_OTG_HCTSIZ_XFRSIZ_Msk     /*!< Transfer size */
N#define USB_OTG_HCTSIZ_PKTCNT_Pos                (19U)                         
N#define USB_OTG_HCTSIZ_PKTCNT_Msk                (0x3FFUL << USB_OTG_HCTSIZ_PKTCNT_Pos) /*!< 0x1FF80000 */
N#define USB_OTG_HCTSIZ_PKTCNT                    USB_OTG_HCTSIZ_PKTCNT_Msk     /*!< Packet count */
N#define USB_OTG_HCTSIZ_DOPING_Pos                (31U)                         
N#define USB_OTG_HCTSIZ_DOPING_Msk                (0x1UL << USB_OTG_HCTSIZ_DOPING_Pos) /*!< 0x80000000 */
N#define USB_OTG_HCTSIZ_DOPING                    USB_OTG_HCTSIZ_DOPING_Msk     /*!< Do PING */
N#define USB_OTG_HCTSIZ_DPID_Pos                  (29U)                         
N#define USB_OTG_HCTSIZ_DPID_Msk                  (0x3UL << USB_OTG_HCTSIZ_DPID_Pos) /*!< 0x60000000 */
N#define USB_OTG_HCTSIZ_DPID                      USB_OTG_HCTSIZ_DPID_Msk       /*!< Data PID */
N#define USB_OTG_HCTSIZ_DPID_0                    (0x1UL << USB_OTG_HCTSIZ_DPID_Pos) /*!< 0x20000000 */
N#define USB_OTG_HCTSIZ_DPID_1                    (0x2UL << USB_OTG_HCTSIZ_DPID_Pos) /*!< 0x40000000 */
N
N/********************  Bit definition for USB_OTG_DIEPDMA register  ********************/
N#define USB_OTG_DIEPDMA_DMAADDR_Pos              (0U)                          
N#define USB_OTG_DIEPDMA_DMAADDR_Msk              (0xFFFFFFFFUL << USB_OTG_DIEPDMA_DMAADDR_Pos) /*!< 0xFFFFFFFF */
N#define USB_OTG_DIEPDMA_DMAADDR                  USB_OTG_DIEPDMA_DMAADDR_Msk   /*!< DMA address */
N
N/********************  Bit definition for USB_OTG_HCDMA register  ********************/
N#define USB_OTG_HCDMA_DMAADDR_Pos                (0U)                          
N#define USB_OTG_HCDMA_DMAADDR_Msk                (0xFFFFFFFFUL << USB_OTG_HCDMA_DMAADDR_Pos) /*!< 0xFFFFFFFF */
N#define USB_OTG_HCDMA_DMAADDR                    USB_OTG_HCDMA_DMAADDR_Msk     /*!< DMA address */
N
N/********************  Bit definition for USB_OTG_DTXFSTS register  ********************/
N#define USB_OTG_DTXFSTS_INEPTFSAV_Pos            (0U)                          
N#define USB_OTG_DTXFSTS_INEPTFSAV_Msk            (0xFFFFUL << USB_OTG_DTXFSTS_INEPTFSAV_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DTXFSTS_INEPTFSAV                USB_OTG_DTXFSTS_INEPTFSAV_Msk /*!< IN endpoint TxFIFO space available */
N
N/********************  Bit definition for USB_OTG_DIEPTXF register  ********************/
N#define USB_OTG_DIEPTXF_INEPTXSA_Pos             (0U)                          
N#define USB_OTG_DIEPTXF_INEPTXSA_Msk             (0xFFFFUL << USB_OTG_DIEPTXF_INEPTXSA_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DIEPTXF_INEPTXSA                 USB_OTG_DIEPTXF_INEPTXSA_Msk  /*!< IN endpoint FIFOx transmit RAM start address */
N#define USB_OTG_DIEPTXF_INEPTXFD_Pos             (16U)                         
N#define USB_OTG_DIEPTXF_INEPTXFD_Msk             (0xFFFFUL << USB_OTG_DIEPTXF_INEPTXFD_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_DIEPTXF_INEPTXFD                 USB_OTG_DIEPTXF_INEPTXFD_Msk  /*!< IN endpoint TxFIFO depth */
N
N/********************  Bit definition for USB_OTG_DOEPCTL register  ********************/
N
N#define USB_OTG_DOEPCTL_MPSIZ_Pos                (0U)                          
N#define USB_OTG_DOEPCTL_MPSIZ_Msk                (0x7FFUL << USB_OTG_DOEPCTL_MPSIZ_Pos) /*!< 0x000007FF */
N#define USB_OTG_DOEPCTL_MPSIZ                    USB_OTG_DOEPCTL_MPSIZ_Msk     /*!< Maximum packet size */          /*!<Bit 1 */
N#define USB_OTG_DOEPCTL_USBAEP_Pos               (15U)                         
N#define USB_OTG_DOEPCTL_USBAEP_Msk               (0x1UL << USB_OTG_DOEPCTL_USBAEP_Pos) /*!< 0x00008000 */
N#define USB_OTG_DOEPCTL_USBAEP                   USB_OTG_DOEPCTL_USBAEP_Msk    /*!< USB active endpoint */
N#define USB_OTG_DOEPCTL_NAKSTS_Pos               (17U)                         
N#define USB_OTG_DOEPCTL_NAKSTS_Msk               (0x1UL << USB_OTG_DOEPCTL_NAKSTS_Pos) /*!< 0x00020000 */
N#define USB_OTG_DOEPCTL_NAKSTS                   USB_OTG_DOEPCTL_NAKSTS_Msk    /*!< NAK status */
N#define USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Pos       (28U)                         
N#define USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Msk       (0x1UL << USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Pos) /*!< 0x10000000 */
N#define USB_OTG_DOEPCTL_SD0PID_SEVNFRM           USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Msk /*!< Set DATA0 PID */
N#define USB_OTG_DOEPCTL_SODDFRM_Pos              (29U)                         
N#define USB_OTG_DOEPCTL_SODDFRM_Msk              (0x1UL << USB_OTG_DOEPCTL_SODDFRM_Pos) /*!< 0x20000000 */
N#define USB_OTG_DOEPCTL_SODDFRM                  USB_OTG_DOEPCTL_SODDFRM_Msk   /*!< Set odd frame */
N#define USB_OTG_DOEPCTL_EPTYP_Pos                (18U)                         
N#define USB_OTG_DOEPCTL_EPTYP_Msk                (0x3UL << USB_OTG_DOEPCTL_EPTYP_Pos) /*!< 0x000C0000 */
N#define USB_OTG_DOEPCTL_EPTYP                    USB_OTG_DOEPCTL_EPTYP_Msk     /*!< Endpoint type */
N#define USB_OTG_DOEPCTL_EPTYP_0                  (0x1UL << USB_OTG_DOEPCTL_EPTYP_Pos) /*!< 0x00040000 */
N#define USB_OTG_DOEPCTL_EPTYP_1                  (0x2UL << USB_OTG_DOEPCTL_EPTYP_Pos) /*!< 0x00080000 */
N#define USB_OTG_DOEPCTL_SNPM_Pos                 (20U)                         
N#define USB_OTG_DOEPCTL_SNPM_Msk                 (0x1UL << USB_OTG_DOEPCTL_SNPM_Pos) /*!< 0x00100000 */
N#define USB_OTG_DOEPCTL_SNPM                     USB_OTG_DOEPCTL_SNPM_Msk      /*!< Snoop mode */
N#define USB_OTG_DOEPCTL_STALL_Pos                (21U)                         
N#define USB_OTG_DOEPCTL_STALL_Msk                (0x1UL << USB_OTG_DOEPCTL_STALL_Pos) /*!< 0x00200000 */
N#define USB_OTG_DOEPCTL_STALL                    USB_OTG_DOEPCTL_STALL_Msk     /*!< STALL handshake */
N#define USB_OTG_DOEPCTL_CNAK_Pos                 (26U)                         
N#define USB_OTG_DOEPCTL_CNAK_Msk                 (0x1UL << USB_OTG_DOEPCTL_CNAK_Pos) /*!< 0x04000000 */
N#define USB_OTG_DOEPCTL_CNAK                     USB_OTG_DOEPCTL_CNAK_Msk      /*!< Clear NAK */
N#define USB_OTG_DOEPCTL_SNAK_Pos                 (27U)                         
N#define USB_OTG_DOEPCTL_SNAK_Msk                 (0x1UL << USB_OTG_DOEPCTL_SNAK_Pos) /*!< 0x08000000 */
N#define USB_OTG_DOEPCTL_SNAK                     USB_OTG_DOEPCTL_SNAK_Msk      /*!< Set NAK */
N#define USB_OTG_DOEPCTL_EPDIS_Pos                (30U)                         
N#define USB_OTG_DOEPCTL_EPDIS_Msk                (0x1UL << USB_OTG_DOEPCTL_EPDIS_Pos) /*!< 0x40000000 */
N#define USB_OTG_DOEPCTL_EPDIS                    USB_OTG_DOEPCTL_EPDIS_Msk     /*!< Endpoint disable */
N#define USB_OTG_DOEPCTL_EPENA_Pos                (31U)                         
N#define USB_OTG_DOEPCTL_EPENA_Msk                (0x1UL << USB_OTG_DOEPCTL_EPENA_Pos) /*!< 0x80000000 */
N#define USB_OTG_DOEPCTL_EPENA                    USB_OTG_DOEPCTL_EPENA_Msk     /*!< Endpoint enable */
N
N/********************  Bit definition for USB_OTG_DOEPINT register  ********************/
N#define USB_OTG_DOEPINT_XFRC_Pos                 (0U)                          
N#define USB_OTG_DOEPINT_XFRC_Msk                 (0x1UL << USB_OTG_DOEPINT_XFRC_Pos) /*!< 0x00000001 */
N#define USB_OTG_DOEPINT_XFRC                     USB_OTG_DOEPINT_XFRC_Msk      /*!< Transfer completed interrupt */
N#define USB_OTG_DOEPINT_EPDISD_Pos               (1U)                          
N#define USB_OTG_DOEPINT_EPDISD_Msk               (0x1UL << USB_OTG_DOEPINT_EPDISD_Pos) /*!< 0x00000002 */
N#define USB_OTG_DOEPINT_EPDISD                   USB_OTG_DOEPINT_EPDISD_Msk    /*!< Endpoint disabled interrupt */
N#define USB_OTG_DOEPINT_AHBERR_Pos               (2U)
N#define USB_OTG_DOEPINT_AHBERR_Msk               (0x1UL << USB_OTG_DOEPINT_AHBERR_Pos) /*!< 0x00000004 */
N#define USB_OTG_DOEPINT_AHBERR                   USB_OTG_DOEPINT_AHBERR_Msk   /*!< AHB Error (AHBErr) during an OUT transaction */
N#define USB_OTG_DOEPINT_STUP_Pos                 (3U)                          
N#define USB_OTG_DOEPINT_STUP_Msk                 (0x1UL << USB_OTG_DOEPINT_STUP_Pos) /*!< 0x00000008 */
N#define USB_OTG_DOEPINT_STUP                     USB_OTG_DOEPINT_STUP_Msk      /*!< SETUP phase done */
N#define USB_OTG_DOEPINT_OTEPDIS_Pos              (4U)                          
N#define USB_OTG_DOEPINT_OTEPDIS_Msk              (0x1UL << USB_OTG_DOEPINT_OTEPDIS_Pos) /*!< 0x00000010 */
N#define USB_OTG_DOEPINT_OTEPDIS                  USB_OTG_DOEPINT_OTEPDIS_Msk   /*!< OUT token received when endpoint disabled */
N#define USB_OTG_DOEPINT_OTEPSPR_Pos              (5U)                          
N#define USB_OTG_DOEPINT_OTEPSPR_Msk              (0x1UL << USB_OTG_DOEPINT_OTEPSPR_Pos) /*!< 0x00000020 */
N#define USB_OTG_DOEPINT_OTEPSPR                  USB_OTG_DOEPINT_OTEPSPR_Msk   /*!< Status Phase Received For Control Write */
N#define USB_OTG_DOEPINT_B2BSTUP_Pos              (6U)                          
N#define USB_OTG_DOEPINT_B2BSTUP_Msk              (0x1UL << USB_OTG_DOEPINT_B2BSTUP_Pos) /*!< 0x00000040 */
N#define USB_OTG_DOEPINT_B2BSTUP                  USB_OTG_DOEPINT_B2BSTUP_Msk   /*!< Back-to-back SETUP packets received */
N#define USB_OTG_DOEPINT_OUTPKTERR_Pos            (8U)
N#define USB_OTG_DOEPINT_OUTPKTERR_Msk            (0x1UL << USB_OTG_DOEPINT_OUTPKTERR_Pos) /*!< 0x00000100 */
N#define USB_OTG_DOEPINT_OUTPKTERR                USB_OTG_DOEPINT_OUTPKTERR_Msk   /*!< OUT packet error */
N#define USB_OTG_DOEPINT_NAK_Pos                  (13U)
N#define USB_OTG_DOEPINT_NAK_Msk                  (0x1UL << USB_OTG_DOEPINT_NAK_Pos) /*!< 0x00002000 */
N#define USB_OTG_DOEPINT_NAK                      USB_OTG_DOEPINT_NAK_Msk   /*!< NAK Packet is transmitted by the device */
N#define USB_OTG_DOEPINT_NYET_Pos                 (14U)                         
N#define USB_OTG_DOEPINT_NYET_Msk                 (0x1UL << USB_OTG_DOEPINT_NYET_Pos) /*!< 0x00004000 */
N#define USB_OTG_DOEPINT_NYET                     USB_OTG_DOEPINT_NYET_Msk      /*!< NYET interrupt */
N#define USB_OTG_DOEPINT_STPKTRX_Pos              (15U)
N#define USB_OTG_DOEPINT_STPKTRX_Msk              (0x1UL << USB_OTG_DOEPINT_STPKTRX_Pos) /*!< 0x00008000 */
N#define USB_OTG_DOEPINT_STPKTRX                  USB_OTG_DOEPINT_STPKTRX_Msk   /*!< Setup Packet Received */
N/********************  Bit definition for USB_OTG_DOEPTSIZ register  ********************/
N
N#define USB_OTG_DOEPTSIZ_XFRSIZ_Pos              (0U)                          
N#define USB_OTG_DOEPTSIZ_XFRSIZ_Msk              (0x7FFFFUL << USB_OTG_DOEPTSIZ_XFRSIZ_Pos) /*!< 0x0007FFFF */
N#define USB_OTG_DOEPTSIZ_XFRSIZ                  USB_OTG_DOEPTSIZ_XFRSIZ_Msk   /*!< Transfer size */
N#define USB_OTG_DOEPTSIZ_PKTCNT_Pos              (19U)                         
N#define USB_OTG_DOEPTSIZ_PKTCNT_Msk              (0x3FFUL << USB_OTG_DOEPTSIZ_PKTCNT_Pos) /*!< 0x1FF80000 */
N#define USB_OTG_DOEPTSIZ_PKTCNT                  USB_OTG_DOEPTSIZ_PKTCNT_Msk   /*!< Packet count */
N
N#define USB_OTG_DOEPTSIZ_STUPCNT_Pos             (29U)                         
N#define USB_OTG_DOEPTSIZ_STUPCNT_Msk             (0x3UL << USB_OTG_DOEPTSIZ_STUPCNT_Pos) /*!< 0x60000000 */
N#define USB_OTG_DOEPTSIZ_STUPCNT                 USB_OTG_DOEPTSIZ_STUPCNT_Msk  /*!< SETUP packet count */
N#define USB_OTG_DOEPTSIZ_STUPCNT_0               (0x1UL << USB_OTG_DOEPTSIZ_STUPCNT_Pos) /*!< 0x20000000 */
N#define USB_OTG_DOEPTSIZ_STUPCNT_1               (0x2UL << USB_OTG_DOEPTSIZ_STUPCNT_Pos) /*!< 0x40000000 */
N
N/********************  Bit definition for PCGCCTL register  ********************/
N#define USB_OTG_PCGCCTL_STOPCLK_Pos              (0U)                          
N#define USB_OTG_PCGCCTL_STOPCLK_Msk              (0x1UL << USB_OTG_PCGCCTL_STOPCLK_Pos) /*!< 0x00000001 */
N#define USB_OTG_PCGCCTL_STOPCLK                  USB_OTG_PCGCCTL_STOPCLK_Msk   /*!< SETUP packet count */
N#define USB_OTG_PCGCCTL_GATECLK_Pos              (1U)                          
N#define USB_OTG_PCGCCTL_GATECLK_Msk              (0x1UL << USB_OTG_PCGCCTL_GATECLK_Pos) /*!< 0x00000002 */
N#define USB_OTG_PCGCCTL_GATECLK                  USB_OTG_PCGCCTL_GATECLK_Msk   /*!<Bit 0 */
N#define USB_OTG_PCGCCTL_PHYSUSP_Pos              (4U)                          
N#define USB_OTG_PCGCCTL_PHYSUSP_Msk              (0x1UL << USB_OTG_PCGCCTL_PHYSUSP_Pos) /*!< 0x00000010 */
N#define USB_OTG_PCGCCTL_PHYSUSP                  USB_OTG_PCGCCTL_PHYSUSP_Msk   /*!<Bit 1 */
N
N/* Legacy define */
N/********************  Bit definition for OTG register  ********************/
N#define USB_OTG_CHNUM_Pos                        (0U)                          
N#define USB_OTG_CHNUM_Msk                        (0xFUL << USB_OTG_CHNUM_Pos)   /*!< 0x0000000F */
N#define USB_OTG_CHNUM                            USB_OTG_CHNUM_Msk             /*!< Channel number */
N#define USB_OTG_CHNUM_0                          (0x1UL << USB_OTG_CHNUM_Pos)   /*!< 0x00000001 */
N#define USB_OTG_CHNUM_1                          (0x2UL << USB_OTG_CHNUM_Pos)   /*!< 0x00000002 */
N#define USB_OTG_CHNUM_2                          (0x4UL << USB_OTG_CHNUM_Pos)   /*!< 0x00000004 */
N#define USB_OTG_CHNUM_3                          (0x8UL << USB_OTG_CHNUM_Pos)   /*!< 0x00000008 */
N#define USB_OTG_BCNT_Pos                         (4U)                          
N#define USB_OTG_BCNT_Msk                         (0x7FFUL << USB_OTG_BCNT_Pos)  /*!< 0x00007FF0 */
N#define USB_OTG_BCNT                             USB_OTG_BCNT_Msk              /*!< Byte count */
N
N#define USB_OTG_DPID_Pos                         (15U)                         
N#define USB_OTG_DPID_Msk                         (0x3UL << USB_OTG_DPID_Pos)    /*!< 0x00018000 */
N#define USB_OTG_DPID                             USB_OTG_DPID_Msk              /*!< Data PID */
N#define USB_OTG_DPID_0                           (0x1UL << USB_OTG_DPID_Pos)    /*!< 0x00008000 */
N#define USB_OTG_DPID_1                           (0x2UL << USB_OTG_DPID_Pos)    /*!< 0x00010000 */
N
N#define USB_OTG_PKTSTS_Pos                       (17U)                         
N#define USB_OTG_PKTSTS_Msk                       (0xFUL << USB_OTG_PKTSTS_Pos)  /*!< 0x001E0000 */
N#define USB_OTG_PKTSTS                           USB_OTG_PKTSTS_Msk            /*!< Packet status */
N#define USB_OTG_PKTSTS_0                         (0x1UL << USB_OTG_PKTSTS_Pos)  /*!< 0x00020000 */
N#define USB_OTG_PKTSTS_1                         (0x2UL << USB_OTG_PKTSTS_Pos)  /*!< 0x00040000 */
N#define USB_OTG_PKTSTS_2                         (0x4UL << USB_OTG_PKTSTS_Pos)  /*!< 0x00080000 */
N#define USB_OTG_PKTSTS_3                         (0x8UL << USB_OTG_PKTSTS_Pos)  /*!< 0x00100000 */
N
N#define USB_OTG_EPNUM_Pos                        (0U)                          
N#define USB_OTG_EPNUM_Msk                        (0xFUL << USB_OTG_EPNUM_Pos)   /*!< 0x0000000F */
N#define USB_OTG_EPNUM                            USB_OTG_EPNUM_Msk             /*!< Endpoint number */
N#define USB_OTG_EPNUM_0                          (0x1UL << USB_OTG_EPNUM_Pos)   /*!< 0x00000001 */
N#define USB_OTG_EPNUM_1                          (0x2UL << USB_OTG_EPNUM_Pos)   /*!< 0x00000002 */
N#define USB_OTG_EPNUM_2                          (0x4UL << USB_OTG_EPNUM_Pos)   /*!< 0x00000004 */
N#define USB_OTG_EPNUM_3                          (0x8UL << USB_OTG_EPNUM_Pos)   /*!< 0x00000008 */
N
N#define USB_OTG_FRMNUM_Pos                       (21U)                         
N#define USB_OTG_FRMNUM_Msk                       (0xFUL << USB_OTG_FRMNUM_Pos)  /*!< 0x01E00000 */
N#define USB_OTG_FRMNUM                           USB_OTG_FRMNUM_Msk            /*!< Frame number */
N#define USB_OTG_FRMNUM_0                         (0x1UL << USB_OTG_FRMNUM_Pos)  /*!< 0x00200000 */
N#define USB_OTG_FRMNUM_1                         (0x2UL << USB_OTG_FRMNUM_Pos)  /*!< 0x00400000 */
N#define USB_OTG_FRMNUM_2                         (0x4UL << USB_OTG_FRMNUM_Pos)  /*!< 0x00800000 */
N#define USB_OTG_FRMNUM_3                         (0x8UL << USB_OTG_FRMNUM_Pos)  /*!< 0x01000000 */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N
N/******************************* ADC Instances ********************************/
N#define IS_ADC_ALL_INSTANCE(INSTANCE) (((INSTANCE) == ADC1) || \
N                                       ((INSTANCE) == ADC2) || \
N                                       ((INSTANCE) == ADC3))
X#define IS_ADC_ALL_INSTANCE(INSTANCE) (((INSTANCE) == ADC1) ||                                        ((INSTANCE) == ADC2) ||                                        ((INSTANCE) == ADC3))
N
N#define IS_ADC_MULTIMODE_MASTER_INSTANCE(INSTANCE) ((INSTANCE) == ADC1)
N
N#define IS_ADC_COMMON_INSTANCE(INSTANCE) ((INSTANCE) == ADC123_COMMON)
N
N/******************************* CAN Instances ********************************/
N#define IS_CAN_ALL_INSTANCE(INSTANCE) (((INSTANCE) == CAN1) || \
N                                       ((INSTANCE) == CAN2))
X#define IS_CAN_ALL_INSTANCE(INSTANCE) (((INSTANCE) == CAN1) ||                                        ((INSTANCE) == CAN2))
N/******************************* CRC Instances ********************************/
N#define IS_CRC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CRC)
N
N/******************************* DAC Instances ********************************/
N#define IS_DAC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == DAC1)
N
N/******************************* DCMI Instances *******************************/
N#define IS_DCMI_ALL_INSTANCE(INSTANCE) ((INSTANCE) == DCMI)
N
N/******************************** DMA Instances *******************************/
N#define IS_DMA_STREAM_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Stream0) || \
N                                              ((INSTANCE) == DMA1_Stream1) || \
N                                              ((INSTANCE) == DMA1_Stream2) || \
N                                              ((INSTANCE) == DMA1_Stream3) || \
N                                              ((INSTANCE) == DMA1_Stream4) || \
N                                              ((INSTANCE) == DMA1_Stream5) || \
N                                              ((INSTANCE) == DMA1_Stream6) || \
N                                              ((INSTANCE) == DMA1_Stream7) || \
N                                              ((INSTANCE) == DMA2_Stream0) || \
N                                              ((INSTANCE) == DMA2_Stream1) || \
N                                              ((INSTANCE) == DMA2_Stream2) || \
N                                              ((INSTANCE) == DMA2_Stream3) || \
N                                              ((INSTANCE) == DMA2_Stream4) || \
N                                              ((INSTANCE) == DMA2_Stream5) || \
N                                              ((INSTANCE) == DMA2_Stream6) || \
N                                              ((INSTANCE) == DMA2_Stream7))
X#define IS_DMA_STREAM_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Stream0) ||                                               ((INSTANCE) == DMA1_Stream1) ||                                               ((INSTANCE) == DMA1_Stream2) ||                                               ((INSTANCE) == DMA1_Stream3) ||                                               ((INSTANCE) == DMA1_Stream4) ||                                               ((INSTANCE) == DMA1_Stream5) ||                                               ((INSTANCE) == DMA1_Stream6) ||                                               ((INSTANCE) == DMA1_Stream7) ||                                               ((INSTANCE) == DMA2_Stream0) ||                                               ((INSTANCE) == DMA2_Stream1) ||                                               ((INSTANCE) == DMA2_Stream2) ||                                               ((INSTANCE) == DMA2_Stream3) ||                                               ((INSTANCE) == DMA2_Stream4) ||                                               ((INSTANCE) == DMA2_Stream5) ||                                               ((INSTANCE) == DMA2_Stream6) ||                                               ((INSTANCE) == DMA2_Stream7))
N
N/******************************* GPIO Instances *******************************/
N#define IS_GPIO_ALL_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) || \
N                                        ((INSTANCE) == GPIOB) || \
N                                        ((INSTANCE) == GPIOC) || \
N                                        ((INSTANCE) == GPIOD) || \
N                                        ((INSTANCE) == GPIOE) || \
N                                        ((INSTANCE) == GPIOF) || \
N                                        ((INSTANCE) == GPIOG) || \
N                                        ((INSTANCE) == GPIOH) || \
N                                        ((INSTANCE) == GPIOI))
X#define IS_GPIO_ALL_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) ||                                         ((INSTANCE) == GPIOB) ||                                         ((INSTANCE) == GPIOC) ||                                         ((INSTANCE) == GPIOD) ||                                         ((INSTANCE) == GPIOE) ||                                         ((INSTANCE) == GPIOF) ||                                         ((INSTANCE) == GPIOG) ||                                         ((INSTANCE) == GPIOH) ||                                         ((INSTANCE) == GPIOI))
N
N/******************************** I2C Instances *******************************/
N#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) || \
N                                       ((INSTANCE) == I2C2) || \
N                                       ((INSTANCE) == I2C3))
X#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) ||                                        ((INSTANCE) == I2C2) ||                                        ((INSTANCE) == I2C3))
N
N/******************************* SMBUS Instances ******************************/
N#define IS_SMBUS_ALL_INSTANCE         IS_I2C_ALL_INSTANCE
N
N/******************************** I2S Instances *******************************/
N
N#define IS_I2S_ALL_INSTANCE(INSTANCE)  (((INSTANCE) == SPI2) || \
N                                       ((INSTANCE) == SPI3))
X#define IS_I2S_ALL_INSTANCE(INSTANCE)  (((INSTANCE) == SPI2) ||                                        ((INSTANCE) == SPI3))
N
N/*************************** I2S Extended Instances ***************************/
N#define IS_I2S_EXT_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2S2ext)|| \
N                                           ((INSTANCE) == I2S3ext))
X#define IS_I2S_EXT_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2S2ext)||                                            ((INSTANCE) == I2S3ext))
N/* Legacy Defines */
N#define IS_I2S_ALL_INSTANCE_EXT    IS_I2S_EXT_ALL_INSTANCE
N
N/******************************* RNG Instances ********************************/
N#define IS_RNG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == RNG)
N
N/****************************** RTC Instances *********************************/
N#define IS_RTC_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == RTC)
N
N
N/******************************** SPI Instances *******************************/
N#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) || \
N                                       ((INSTANCE) == SPI2) || \
N                                       ((INSTANCE) == SPI3))
X#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) ||                                        ((INSTANCE) == SPI2) ||                                        ((INSTANCE) == SPI3))
N
N
N/****************** TIM Instances : All supported instances *******************/
N#define IS_TIM_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)  || \
N                                    ((INSTANCE) == TIM2) || \
N                                    ((INSTANCE) == TIM3) || \
N                                    ((INSTANCE) == TIM4) || \
N                                    ((INSTANCE) == TIM5) || \
N                                    ((INSTANCE) == TIM6) || \
N                                    ((INSTANCE) == TIM7) || \
N                                    ((INSTANCE) == TIM8) || \
N                                    ((INSTANCE) == TIM9) || \
N                                    ((INSTANCE) == TIM10)|| \
N                                    ((INSTANCE) == TIM11)|| \
N                                    ((INSTANCE) == TIM12)|| \
N                                    ((INSTANCE) == TIM13)|| \
N                                    ((INSTANCE) == TIM14))
X#define IS_TIM_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)  ||                                     ((INSTANCE) == TIM2) ||                                     ((INSTANCE) == TIM3) ||                                     ((INSTANCE) == TIM4) ||                                     ((INSTANCE) == TIM5) ||                                     ((INSTANCE) == TIM6) ||                                     ((INSTANCE) == TIM7) ||                                     ((INSTANCE) == TIM8) ||                                     ((INSTANCE) == TIM9) ||                                     ((INSTANCE) == TIM10)||                                     ((INSTANCE) == TIM11)||                                     ((INSTANCE) == TIM12)||                                     ((INSTANCE) == TIM13)||                                     ((INSTANCE) == TIM14))
N
N/************* TIM Instances : at least 1 capture/compare channel *************/
N#define IS_TIM_CC1_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)  || \
N                                         ((INSTANCE) == TIM2)  || \
N                                         ((INSTANCE) == TIM3)  || \
N                                         ((INSTANCE) == TIM4)  || \
N                                         ((INSTANCE) == TIM5)  || \
N                                         ((INSTANCE) == TIM8)  || \
N                                         ((INSTANCE) == TIM9)  || \
N                                         ((INSTANCE) == TIM10) || \
N                                         ((INSTANCE) == TIM11) || \
N                                         ((INSTANCE) == TIM12) || \
N                                         ((INSTANCE) == TIM13) || \
N                                         ((INSTANCE) == TIM14))
X#define IS_TIM_CC1_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)  ||                                          ((INSTANCE) == TIM2)  ||                                          ((INSTANCE) == TIM3)  ||                                          ((INSTANCE) == TIM4)  ||                                          ((INSTANCE) == TIM5)  ||                                          ((INSTANCE) == TIM8)  ||                                          ((INSTANCE) == TIM9)  ||                                          ((INSTANCE) == TIM10) ||                                          ((INSTANCE) == TIM11) ||                                          ((INSTANCE) == TIM12) ||                                          ((INSTANCE) == TIM13) ||                                          ((INSTANCE) == TIM14))
N
N/************ TIM Instances : at least 2 capture/compare channels *************/
N#define IS_TIM_CC2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                       ((INSTANCE) == TIM2) || \
N                                       ((INSTANCE) == TIM3) || \
N                                       ((INSTANCE) == TIM4) || \
N                                       ((INSTANCE) == TIM5) || \
N                                       ((INSTANCE) == TIM8) || \
N                                       ((INSTANCE) == TIM9) || \
N                                       ((INSTANCE) == TIM12)) 
X#define IS_TIM_CC2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                        ((INSTANCE) == TIM2) ||                                        ((INSTANCE) == TIM3) ||                                        ((INSTANCE) == TIM4) ||                                        ((INSTANCE) == TIM5) ||                                        ((INSTANCE) == TIM8) ||                                        ((INSTANCE) == TIM9) ||                                        ((INSTANCE) == TIM12)) 
N
N/************ TIM Instances : at least 3 capture/compare channels *************/
N#define IS_TIM_CC3_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1) || \
N                                         ((INSTANCE) == TIM2) || \
N                                         ((INSTANCE) == TIM3) || \
N                                         ((INSTANCE) == TIM4) || \
N                                         ((INSTANCE) == TIM5) || \
N                                         ((INSTANCE) == TIM8))
X#define IS_TIM_CC3_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1) ||                                          ((INSTANCE) == TIM2) ||                                          ((INSTANCE) == TIM3) ||                                          ((INSTANCE) == TIM4) ||                                          ((INSTANCE) == TIM5) ||                                          ((INSTANCE) == TIM8))
N
N/************ TIM Instances : at least 4 capture/compare channels *************/
N#define IS_TIM_CC4_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                       ((INSTANCE) == TIM2) || \
N                                       ((INSTANCE) == TIM3) || \
N                                       ((INSTANCE) == TIM4) || \
N                                       ((INSTANCE) == TIM5) || \
N                                       ((INSTANCE) == TIM8))
X#define IS_TIM_CC4_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                        ((INSTANCE) == TIM2) ||                                        ((INSTANCE) == TIM3) ||                                        ((INSTANCE) == TIM4) ||                                        ((INSTANCE) == TIM5) ||                                        ((INSTANCE) == TIM8))
N
N/******************** TIM Instances : Advanced-control timers *****************/
N#define IS_TIM_ADVANCED_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                           ((INSTANCE) == TIM8))
X#define IS_TIM_ADVANCED_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                            ((INSTANCE) == TIM8))
N
N/******************* TIM Instances : Timer input XOR function *****************/
N#define IS_TIM_XOR_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1) || \
N                                         ((INSTANCE) == TIM2) || \
N                                         ((INSTANCE) == TIM3) || \
N                                         ((INSTANCE) == TIM4) || \
N                                         ((INSTANCE) == TIM5) || \
N                                         ((INSTANCE) == TIM8))
X#define IS_TIM_XOR_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1) ||                                          ((INSTANCE) == TIM2) ||                                          ((INSTANCE) == TIM3) ||                                          ((INSTANCE) == TIM4) ||                                          ((INSTANCE) == TIM5) ||                                          ((INSTANCE) == TIM8))
N
N/****************** TIM Instances : DMA requests generation (UDE) *************/
N#define IS_TIM_DMA_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                       ((INSTANCE) == TIM2) || \
N                                       ((INSTANCE) == TIM3) || \
N                                       ((INSTANCE) == TIM4) || \
N                                       ((INSTANCE) == TIM5) || \
N                                       ((INSTANCE) == TIM6) || \
N                                       ((INSTANCE) == TIM7) || \
N                                       ((INSTANCE) == TIM8))
X#define IS_TIM_DMA_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                        ((INSTANCE) == TIM2) ||                                        ((INSTANCE) == TIM3) ||                                        ((INSTANCE) == TIM4) ||                                        ((INSTANCE) == TIM5) ||                                        ((INSTANCE) == TIM6) ||                                        ((INSTANCE) == TIM7) ||                                        ((INSTANCE) == TIM8))
N
N/************ TIM Instances : DMA requests generation (CCxDE) *****************/
N#define IS_TIM_DMA_CC_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                          ((INSTANCE) == TIM2) || \
N                                          ((INSTANCE) == TIM3) || \
N                                          ((INSTANCE) == TIM4) || \
N                                          ((INSTANCE) == TIM5) || \
N                                          ((INSTANCE) == TIM8))
X#define IS_TIM_DMA_CC_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                           ((INSTANCE) == TIM2) ||                                           ((INSTANCE) == TIM3) ||                                           ((INSTANCE) == TIM4) ||                                           ((INSTANCE) == TIM5) ||                                           ((INSTANCE) == TIM8))
N
N/************ TIM Instances : DMA requests generation (COMDE) *****************/
N#define IS_TIM_CCDMA_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                          ((INSTANCE) == TIM2) || \
N                                          ((INSTANCE) == TIM3) || \
N                                          ((INSTANCE) == TIM4) || \
N                                          ((INSTANCE) == TIM5) || \
N                                          ((INSTANCE) == TIM8))
X#define IS_TIM_CCDMA_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                           ((INSTANCE) == TIM2) ||                                           ((INSTANCE) == TIM3) ||                                           ((INSTANCE) == TIM4) ||                                           ((INSTANCE) == TIM5) ||                                           ((INSTANCE) == TIM8))
N
N/******************** TIM Instances : DMA burst feature ***********************/
N#define IS_TIM_DMABURST_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                             ((INSTANCE) == TIM2) || \
N                                             ((INSTANCE) == TIM3) || \
N                                             ((INSTANCE) == TIM4) || \
N                                             ((INSTANCE) == TIM5) || \
N                                             ((INSTANCE) == TIM8))
X#define IS_TIM_DMABURST_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                              ((INSTANCE) == TIM2) ||                                              ((INSTANCE) == TIM3) ||                                              ((INSTANCE) == TIM4) ||                                              ((INSTANCE) == TIM5) ||                                              ((INSTANCE) == TIM8))
N
N/****** TIM Instances : master mode available (TIMx_CR2.MMS available )********/
N#define IS_TIM_MASTER_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)  || \
N                                          ((INSTANCE) == TIM2)  || \
N                                          ((INSTANCE) == TIM3)  || \
N                                          ((INSTANCE) == TIM4)  || \
N                                          ((INSTANCE) == TIM5)  || \
N                                          ((INSTANCE) == TIM6)  || \
N                                          ((INSTANCE) == TIM7)  || \
N                                          ((INSTANCE) == TIM8))
X#define IS_TIM_MASTER_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)  ||                                           ((INSTANCE) == TIM2)  ||                                           ((INSTANCE) == TIM3)  ||                                           ((INSTANCE) == TIM4)  ||                                           ((INSTANCE) == TIM5)  ||                                           ((INSTANCE) == TIM6)  ||                                           ((INSTANCE) == TIM7)  ||                                           ((INSTANCE) == TIM8))
N
N/*********** TIM Instances : Slave mode available (TIMx_SMCR available )*******/
N#define IS_TIM_SLAVE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                         ((INSTANCE) == TIM2) || \
N                                         ((INSTANCE) == TIM3) || \
N                                         ((INSTANCE) == TIM4) || \
N                                         ((INSTANCE) == TIM5) || \
N                                         ((INSTANCE) == TIM8) || \
N                                         ((INSTANCE) == TIM9) || \
N                                         ((INSTANCE) == TIM12))
X#define IS_TIM_SLAVE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                          ((INSTANCE) == TIM2) ||                                          ((INSTANCE) == TIM3) ||                                          ((INSTANCE) == TIM4) ||                                          ((INSTANCE) == TIM5) ||                                          ((INSTANCE) == TIM8) ||                                          ((INSTANCE) == TIM9) ||                                          ((INSTANCE) == TIM12))
N/********************** TIM Instances : 32 bit Counter ************************/
N#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE)(((INSTANCE) == TIM2) || \
N                                              ((INSTANCE) == TIM5))
X#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE)(((INSTANCE) == TIM2) ||                                               ((INSTANCE) == TIM5))
N
N/***************** TIM Instances : external trigger input availabe ************/
N#define IS_TIM_ETR_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                        ((INSTANCE) == TIM2) || \
N                                        ((INSTANCE) == TIM3) || \
N                                        ((INSTANCE) == TIM4) || \
N                                        ((INSTANCE) == TIM5) || \
N                                        ((INSTANCE) == TIM8))
X#define IS_TIM_ETR_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                         ((INSTANCE) == TIM2) ||                                         ((INSTANCE) == TIM3) ||                                         ((INSTANCE) == TIM4) ||                                         ((INSTANCE) == TIM5) ||                                         ((INSTANCE) == TIM8))
N
N/****************** TIM Instances : remapping capability **********************/
N#define IS_TIM_REMAP_INSTANCE(INSTANCE) (((INSTANCE) == TIM2)  || \
N                                         ((INSTANCE) == TIM5)  || \
N                                         ((INSTANCE) == TIM11))
X#define IS_TIM_REMAP_INSTANCE(INSTANCE) (((INSTANCE) == TIM2)  ||                                          ((INSTANCE) == TIM5)  ||                                          ((INSTANCE) == TIM11))
N
N/******************* TIM Instances : output(s) available **********************/
N#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL) \
N    ((((INSTANCE) == TIM1) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM2) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM3) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM4) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM5) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM8) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM9) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2)))           \
N    ||                                         \
N    (((INSTANCE) == TIM10) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((INSTANCE) == TIM11) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((INSTANCE) == TIM12) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2)))           \
N    ||                                         \
N    (((INSTANCE) == TIM13) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((INSTANCE) == TIM14) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1))))
X#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL)     ((((INSTANCE) == TIM1) &&                       (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM2) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM3) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM4) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM5) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM8) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM9) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2)))               ||                                             (((INSTANCE) == TIM10) &&                       (((CHANNEL) == TIM_CHANNEL_1)))               ||                                             (((INSTANCE) == TIM11) &&                       (((CHANNEL) == TIM_CHANNEL_1)))               ||                                             (((INSTANCE) == TIM12) &&                       (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2)))               ||                                             (((INSTANCE) == TIM13) &&                       (((CHANNEL) == TIM_CHANNEL_1)))               ||                                             (((INSTANCE) == TIM14) &&                       (((CHANNEL) == TIM_CHANNEL_1))))
N
N/************ TIM Instances : complementary output(s) available ***************/
N#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL) \
N   ((((INSTANCE) == TIM1) &&                    \
N     (((CHANNEL) == TIM_CHANNEL_1) ||           \
N      ((CHANNEL) == TIM_CHANNEL_2) ||           \
N      ((CHANNEL) == TIM_CHANNEL_3)))            \
N    ||                                          \
N    (((INSTANCE) == TIM8) &&                    \
N     (((CHANNEL) == TIM_CHANNEL_1) ||           \
N      ((CHANNEL) == TIM_CHANNEL_2) ||           \
N      ((CHANNEL) == TIM_CHANNEL_3))))
X#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL)    ((((INSTANCE) == TIM1) &&                         (((CHANNEL) == TIM_CHANNEL_1) ||                 ((CHANNEL) == TIM_CHANNEL_2) ||                 ((CHANNEL) == TIM_CHANNEL_3)))                ||                                              (((INSTANCE) == TIM8) &&                         (((CHANNEL) == TIM_CHANNEL_1) ||                 ((CHANNEL) == TIM_CHANNEL_2) ||                 ((CHANNEL) == TIM_CHANNEL_3))))
N
N/****************** TIM Instances : supporting counting mode selection ********/
N#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5) || \
N                                                        ((INSTANCE) == TIM8))
X#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5) ||                                                         ((INSTANCE) == TIM8))
N
N/****************** TIM Instances : supporting clock division *****************/
N#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)  || \
N                                                  ((INSTANCE) == TIM2) || \
N                                                  ((INSTANCE) == TIM3) || \
N                                                  ((INSTANCE) == TIM4) || \
N                                                  ((INSTANCE) == TIM5) || \
N                                                  ((INSTANCE) == TIM8) || \
N                                                  ((INSTANCE) == TIM9) || \
N                                                  ((INSTANCE) == TIM10)|| \
N                                                  ((INSTANCE) == TIM11)|| \
N                                                  ((INSTANCE) == TIM12)|| \
N                                                  ((INSTANCE) == TIM13)|| \
N                                                  ((INSTANCE) == TIM14))
X#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)  ||                                                   ((INSTANCE) == TIM2) ||                                                   ((INSTANCE) == TIM3) ||                                                   ((INSTANCE) == TIM4) ||                                                   ((INSTANCE) == TIM5) ||                                                   ((INSTANCE) == TIM8) ||                                                   ((INSTANCE) == TIM9) ||                                                   ((INSTANCE) == TIM10)||                                                   ((INSTANCE) == TIM11)||                                                   ((INSTANCE) == TIM12)||                                                   ((INSTANCE) == TIM13)||                                                   ((INSTANCE) == TIM14))
N
N/****************** TIM Instances : supporting commutation event generation ***/
N#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)|| \
N                                                     ((INSTANCE) == TIM8))
X#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)||                                                      ((INSTANCE) == TIM8))
N
N
N/****************** TIM Instances : supporting OCxREF clear *******************/
N#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)        (((INSTANCE) == TIM1) || \
N                                                       ((INSTANCE) == TIM2) || \
N                                                       ((INSTANCE) == TIM3) || \
N                                                       ((INSTANCE) == TIM4) || \
N                                                       ((INSTANCE) == TIM5) || \
N                                                       ((INSTANCE) == TIM8))
X#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)        (((INSTANCE) == TIM1) ||                                                        ((INSTANCE) == TIM2) ||                                                        ((INSTANCE) == TIM3) ||                                                        ((INSTANCE) == TIM4) ||                                                        ((INSTANCE) == TIM5) ||                                                        ((INSTANCE) == TIM8))
N
N/****** TIM Instances : supporting external clock mode 1 for ETRF input *******/
N#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5) || \
N                                                        ((INSTANCE) == TIM8) || \
N                                                        ((INSTANCE) == TIM9) || \
N                                                        ((INSTANCE) == TIM12))
X#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5) ||                                                         ((INSTANCE) == TIM8) ||                                                         ((INSTANCE) == TIM9) ||                                                         ((INSTANCE) == TIM12))
N
N/****** TIM Instances : supporting external clock mode 2 for ETRF input *******/
N#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5) || \
N                                                        ((INSTANCE) == TIM8))
X#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5) ||                                                         ((INSTANCE) == TIM8))
N
N/****** TIM Instances : supporting external clock mode 1 for TIX inputs ******/
N#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5) || \
N                                                        ((INSTANCE) == TIM8) || \
N                                                        ((INSTANCE) == TIM9) || \
N                                                        ((INSTANCE) == TIM12))
X#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5) ||                                                         ((INSTANCE) == TIM8) ||                                                         ((INSTANCE) == TIM9) ||                                                         ((INSTANCE) == TIM12))
N
N/********** TIM Instances : supporting internal trigger inputs(ITRX) *********/
N#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)     (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5) || \
N                                                        ((INSTANCE) == TIM8) || \
N                                                        ((INSTANCE) == TIM9) || \
N                                                        ((INSTANCE) == TIM12))
X#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)     (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5) ||                                                         ((INSTANCE) == TIM8) ||                                                         ((INSTANCE) == TIM9) ||                                                         ((INSTANCE) == TIM12))
N
N/****************** TIM Instances : supporting repetition counter *************/
N#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                                       ((INSTANCE) == TIM8))
X#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                                        ((INSTANCE) == TIM8))
N
N/****************** TIM Instances : supporting encoder interface **************/
N#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                                      ((INSTANCE) == TIM2) || \
N                                                      ((INSTANCE) == TIM3) || \
N                                                      ((INSTANCE) == TIM4) || \
N                                                      ((INSTANCE) == TIM5) || \
N                                                      ((INSTANCE) == TIM8) || \
N                                                      ((INSTANCE) == TIM9) || \
N                                                      ((INSTANCE) == TIM12))
X#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                                       ((INSTANCE) == TIM2) ||                                                       ((INSTANCE) == TIM3) ||                                                       ((INSTANCE) == TIM4) ||                                                       ((INSTANCE) == TIM5) ||                                                       ((INSTANCE) == TIM8) ||                                                       ((INSTANCE) == TIM9) ||                                                       ((INSTANCE) == TIM12))
N/****************** TIM Instances : supporting Hall sensor interface **********/
N#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                                          ((INSTANCE) == TIM2) || \
N                                                          ((INSTANCE) == TIM3) || \
N                                                          ((INSTANCE) == TIM4) || \
N                                                          ((INSTANCE) == TIM5) || \
N                                                          ((INSTANCE) == TIM8))
X#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                                           ((INSTANCE) == TIM2) ||                                                           ((INSTANCE) == TIM3) ||                                                           ((INSTANCE) == TIM4) ||                                                           ((INSTANCE) == TIM5) ||                                                           ((INSTANCE) == TIM8))
N/****************** TIM Instances : supporting the break function *************/
N#define IS_TIM_BREAK_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                          ((INSTANCE) == TIM8))
X#define IS_TIM_BREAK_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                           ((INSTANCE) == TIM8))
N
N/******************** USART Instances : Synchronous mode **********************/
N#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                     ((INSTANCE) == USART2) || \
N                                     ((INSTANCE) == USART3) || \
N                                     ((INSTANCE) == USART6))
X#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                      ((INSTANCE) == USART2) ||                                      ((INSTANCE) == USART3) ||                                      ((INSTANCE) == USART6))
N
N/******************** UART Instances : Half-Duplex mode **********************/
N#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                               ((INSTANCE) == USART2) || \
N                                               ((INSTANCE) == USART3) || \
N                                               ((INSTANCE) == UART4)  || \
N                                               ((INSTANCE) == UART5)  || \
N                                               ((INSTANCE) == USART6))
X#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                                ((INSTANCE) == USART2) ||                                                ((INSTANCE) == USART3) ||                                                ((INSTANCE) == UART4)  ||                                                ((INSTANCE) == UART5)  ||                                                ((INSTANCE) == USART6))
N
N/* Legacy defines */
N#define IS_UART_INSTANCE          IS_UART_HALFDUPLEX_INSTANCE
N
N/****************** UART Instances : Hardware Flow control ********************/
N#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                           ((INSTANCE) == USART2) || \
N                                           ((INSTANCE) == USART3) || \
N                                           ((INSTANCE) == USART6))
X#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                            ((INSTANCE) == USART2) ||                                            ((INSTANCE) == USART3) ||                                            ((INSTANCE) == USART6))
N/******************** UART Instances : LIN mode **********************/
N#define IS_UART_LIN_INSTANCE          IS_UART_HALFDUPLEX_INSTANCE
N
N/********************* UART Instances : Smart card mode ***********************/
N#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                         ((INSTANCE) == USART2) || \
N                                         ((INSTANCE) == USART3) || \
N                                         ((INSTANCE) == USART6))
X#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                          ((INSTANCE) == USART2) ||                                          ((INSTANCE) == USART3) ||                                          ((INSTANCE) == USART6))
N
N/*********************** UART Instances : IRDA mode ***************************/
N#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                    ((INSTANCE) == USART2) || \
N                                    ((INSTANCE) == USART3) || \
N                                    ((INSTANCE) == UART4)  || \
N                                    ((INSTANCE) == UART5)  || \
N                                    ((INSTANCE) == USART6))
X#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                     ((INSTANCE) == USART2) ||                                     ((INSTANCE) == USART3) ||                                     ((INSTANCE) == UART4)  ||                                     ((INSTANCE) == UART5)  ||                                     ((INSTANCE) == USART6))
N
N
N/*********************** PCD Instances ****************************************/
N#define IS_PCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS) || \
N                                       ((INSTANCE) == USB_OTG_HS))
X#define IS_PCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS) ||                                        ((INSTANCE) == USB_OTG_HS))
N
N/*********************** HCD Instances ****************************************/
N#define IS_HCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS) || \
N                                       ((INSTANCE) == USB_OTG_HS))
X#define IS_HCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS) ||                                        ((INSTANCE) == USB_OTG_HS))
N
N/****************************** SDIO Instances ********************************/
N#define IS_SDIO_ALL_INSTANCE(INSTANCE) ((INSTANCE) == SDIO)
N
N/****************************** IWDG Instances ********************************/
N#define IS_IWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == IWDG)
N
N/****************************** WWDG Instances ********************************/
N#define IS_WWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == WWDG)
N
N/****************************** USB Exported Constants ************************/
N#define USB_OTG_FS_HOST_MAX_CHANNEL_NBR                8U
N#define USB_OTG_FS_MAX_IN_ENDPOINTS                    4U    /* Including EP0 */
N#define USB_OTG_FS_MAX_OUT_ENDPOINTS                   4U    /* Including EP0 */
N#define USB_OTG_FS_TOTAL_FIFO_SIZE                     1280U /* in Bytes */
N
N/*
N * @brief Specific devices reset values definitions
N */
N#define RCC_PLLCFGR_RST_VALUE              0x24003010U
N#define RCC_PLLI2SCFGR_RST_VALUE           0x20003000U
N
N#define RCC_MAX_FREQUENCY           168000000U         /*!< Max frequency of family in Hz*/
N#define RCC_MAX_FREQUENCY_SCALE1    RCC_MAX_FREQUENCY  /*!< Maximum frequency for system clock at power scale1, in Hz */
N#define RCC_MAX_FREQUENCY_SCALE2    144000000U         /*!< Maximum frequency for system clock at power scale2, in Hz */
N#define RCC_PLLVCO_OUTPUT_MIN       100000000U       /*!< Frequency min for PLLVCO output, in Hz */
N#define RCC_PLLVCO_INPUT_MIN           950000U       /*!< Frequency min for PLLVCO input, in Hz  */
N#define RCC_PLLVCO_INPUT_MAX          2100000U       /*!< Frequency max for PLLVCO input, in Hz  */
N#define RCC_PLLVCO_OUTPUT_MAX       432000000U       /*!< Frequency max for PLLVCO output, in Hz */
N
N#define RCC_PLLN_MIN_VALUE                 50U
N#define RCC_PLLN_MAX_VALUE                432U
N
N#define FLASH_SCALE1_LATENCY1_FREQ   30000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 1  */
N#define FLASH_SCALE1_LATENCY2_FREQ   60000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 1  */
N#define FLASH_SCALE1_LATENCY3_FREQ   90000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 1  */
N#define FLASH_SCALE1_LATENCY4_FREQ   120000000U     /*!< HCLK frequency to set FLASH latency 4 in power scale 1  */
N#define FLASH_SCALE1_LATENCY5_FREQ   150000000U     /*!< HCLK frequency to set FLASH latency 5 in power scale 1  */
N
N#define FLASH_SCALE2_LATENCY1_FREQ   30000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 2  */
N#define FLASH_SCALE2_LATENCY2_FREQ   60000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 2  */
N#define FLASH_SCALE2_LATENCY3_FREQ   90000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 2  */
N#define FLASH_SCALE2_LATENCY4_FREQ   12000000U      /*!< HCLK frequency to set FLASH latency 4 in power scale 2  */
N
N#define USB_OTG_HS_HOST_MAX_CHANNEL_NBR                12U
N#define USB_OTG_HS_MAX_IN_ENDPOINTS                    6U    /* Including EP0 */
N#define USB_OTG_HS_MAX_OUT_ENDPOINTS                   6U    /* Including EP0 */
N#define USB_OTG_HS_TOTAL_FIFO_SIZE                     4096U /* in Bytes */
N/******************************************************************************/
N/*  For a painless codes migration between the STM32F4xx device product       */
N/*  lines, the aliases defined below are put in place to overcome the         */
N/*  differences in the interrupt handlers and IRQn definitions.               */
N/*  No need to update developed interrupt code when moving across             */
N/*  product lines within the same STM32F4 Family                              */
N/******************************************************************************/
N/* Aliases for __IRQn */
N#define FMC_IRQn              FSMC_IRQn
N
N/* Aliases for __IRQHandler */
N#define FMC_IRQHandler        FSMC_IRQHandler
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F407xx_H */
N
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 134 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 2
N#elif defined(STM32F417xx)
S  #include "stm32f417xx.h"
S#elif defined(STM32F427xx)
S  #include "stm32f427xx.h"
S#elif defined(STM32F437xx)
S  #include "stm32f437xx.h"
S#elif defined(STM32F429xx)
S  #include "stm32f429xx.h"
S#elif defined(STM32F439xx)
S  #include "stm32f439xx.h"
S#elif defined(STM32F401xC)
S  #include "stm32f401xc.h"
S#elif defined(STM32F401xE)
S  #include "stm32f401xe.h"
S#elif defined(STM32F410Tx)
S  #include "stm32f410tx.h"
S#elif defined(STM32F410Cx)
S  #include "stm32f410cx.h"
S#elif defined(STM32F410Rx)
S  #include "stm32f410rx.h"
S#elif defined(STM32F411xE)
S  #include "stm32f411xe.h"
S#elif defined(STM32F446xx)
S  #include "stm32f446xx.h"
S#elif defined(STM32F469xx)
S  #include "stm32f469xx.h"
S#elif defined(STM32F479xx)
S  #include "stm32f479xx.h"
S#elif defined(STM32F412Cx)
S  #include "stm32f412cx.h"
S#elif defined(STM32F412Zx)
S  #include "stm32f412zx.h"
S#elif defined(STM32F412Rx)
S  #include "stm32f412rx.h"
S#elif defined(STM32F412Vx)
S  #include "stm32f412vx.h"
S#elif defined(STM32F413xx)
S  #include "stm32f413xx.h"
S#elif defined(STM32F423xx)
S  #include "stm32f423xx.h"
S#else
S #error "Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)"
N#endif
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_types
N  * @{
N  */ 
Ntypedef enum 
N{
N  RESET = 0U, 
N  SET = !RESET
N} FlagStatus, ITStatus;
N
Ntypedef enum 
N{
N  DISABLE = 0U, 
N  ENABLE = !DISABLE
N} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum
N{
N  SUCCESS = 0U,
N  ERROR = !SUCCESS
N} ErrorStatus;
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N#define POSITION_VAL(VAL)     (__CLZ(__RBIT(VAL))) 
N
N/* Use of CMSIS compiler intrinsics for register exclusive access */
N/* Atomic 32-bit register access macro to set one or several bits */
N#define ATOMIC_SET_BIT(REG, BIT)                             \
N  do {                                                       \
N    uint32_t val;                                            \
N    do {                                                     \
N      val = __LDREXW((__IO uint32_t *)&(REG)) | (BIT);       \
N    } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U); \
N  } while(0)
X#define ATOMIC_SET_BIT(REG, BIT)                               do {                                                           uint32_t val;                                                do {                                                           val = __LDREXW((__IO uint32_t *)&(REG)) | (BIT);           } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U);   } while(0)
N
N/* Atomic 32-bit register access macro to clear one or several bits */
N#define ATOMIC_CLEAR_BIT(REG, BIT)                           \
N  do {                                                       \
N    uint32_t val;                                            \
N    do {                                                     \
N      val = __LDREXW((__IO uint32_t *)&(REG)) & ~(BIT);      \
N    } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U); \
N  } while(0)
X#define ATOMIC_CLEAR_BIT(REG, BIT)                             do {                                                           uint32_t val;                                                do {                                                           val = __LDREXW((__IO uint32_t *)&(REG)) & ~(BIT);          } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U);   } while(0)
N
N/* Atomic 32-bit register access macro to clear and set one or several bits */
N#define ATOMIC_MODIFY_REG(REG, CLEARMSK, SETMASK)                          \
N  do {                                                                     \
N    uint32_t val;                                                          \
N    do {                                                                   \
N      val = (__LDREXW((__IO uint32_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK); \
N    } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U);               \
N  } while(0)
X#define ATOMIC_MODIFY_REG(REG, CLEARMSK, SETMASK)                            do {                                                                         uint32_t val;                                                              do {                                                                         val = (__LDREXW((__IO uint32_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK);     } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U);                 } while(0)
N
N/* Atomic 16-bit register access macro to set one or several bits */
N#define ATOMIC_SETH_BIT(REG, BIT)                            \
N  do {                                                       \
N    uint16_t val;                                            \
N    do {                                                     \
N      val = __LDREXH((__IO uint16_t *)&(REG)) | (BIT);       \
N    } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U); \
N  } while(0)
X#define ATOMIC_SETH_BIT(REG, BIT)                              do {                                                           uint16_t val;                                                do {                                                           val = __LDREXH((__IO uint16_t *)&(REG)) | (BIT);           } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U);   } while(0)
N
N/* Atomic 16-bit register access macro to clear one or several bits */
N#define ATOMIC_CLEARH_BIT(REG, BIT)                          \
N  do {                                                       \
N    uint16_t val;                                            \
N    do {                                                     \
N      val = __LDREXH((__IO uint16_t *)&(REG)) & ~(BIT);      \
N    } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U); \
N  } while(0)
X#define ATOMIC_CLEARH_BIT(REG, BIT)                            do {                                                           uint16_t val;                                                do {                                                           val = __LDREXH((__IO uint16_t *)&(REG)) & ~(BIT);          } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U);   } while(0)
N
N/* Atomic 16-bit register access macro to clear and set one or several bits */
N#define ATOMIC_MODIFYH_REG(REG, CLEARMSK, SETMASK)                         \
N  do {                                                                     \
N    uint16_t val;                                                          \
N    do {                                                                   \
N      val = (__LDREXH((__IO uint16_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK); \
N    } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U);               \
N  } while(0)
X#define ATOMIC_MODIFYH_REG(REG, CLEARMSK, SETMASK)                           do {                                                                         uint16_t val;                                                              do {                                                                         val = (__LDREXH((__IO uint16_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK);     } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U);                 } while(0)
N
N/**
N  * @}
N  */
N
N#if defined (USE_HAL_DRIVER)
X#if 0L
S #include "stm32f4xx_hal.h"
N#endif /* USE_HAL_DRIVER */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F4xx_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 34 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h" 2
N#include "Legacy/stm32_hal_legacy.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32_hal_legacy.h
N  * @author  MCD Application Team
N  * @brief   This file contains aliases definition for the STM32Cube HAL constants
N  *          macros and functions maintained for legacy purpose.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32_HAL_LEGACY
N#define STM32_HAL_LEGACY
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup HAL_AES_Aliased_Defines HAL CRYP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define AES_FLAG_RDERR                  CRYP_FLAG_RDERR
N#define AES_FLAG_WRERR                  CRYP_FLAG_WRERR
N#define AES_CLEARFLAG_CCF               CRYP_CLEARFLAG_CCF
N#define AES_CLEARFLAG_RDERR             CRYP_CLEARFLAG_RDERR
N#define AES_CLEARFLAG_WRERR             CRYP_CLEARFLAG_WRERR
N#if defined(STM32U5)
X#if 0L
S#define CRYP_DATATYPE_32B               CRYP_NO_SWAP
S#define CRYP_DATATYPE_16B               CRYP_HALFWORD_SWAP
S#define CRYP_DATATYPE_8B                CRYP_BYTE_SWAP
S#define CRYP_DATATYPE_1B                CRYP_BIT_SWAP
S#define CRYP_CCF_CLEAR                  CRYP_CLEAR_CCF
S#define CRYP_ERR_CLEAR                  CRYP_CLEAR_RWEIF
N#endif /* STM32U5 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_ADC_Aliased_Defines HAL ADC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define ADC_RESOLUTION12b               ADC_RESOLUTION_12B
N#define ADC_RESOLUTION10b               ADC_RESOLUTION_10B
N#define ADC_RESOLUTION8b                ADC_RESOLUTION_8B
N#define ADC_RESOLUTION6b                ADC_RESOLUTION_6B
N#define OVR_DATA_OVERWRITTEN            ADC_OVR_DATA_OVERWRITTEN
N#define OVR_DATA_PRESERVED              ADC_OVR_DATA_PRESERVED
N#define EOC_SINGLE_CONV                 ADC_EOC_SINGLE_CONV
N#define EOC_SEQ_CONV                    ADC_EOC_SEQ_CONV
N#define EOC_SINGLE_SEQ_CONV             ADC_EOC_SINGLE_SEQ_CONV
N#define REGULAR_GROUP                   ADC_REGULAR_GROUP
N#define INJECTED_GROUP                  ADC_INJECTED_GROUP
N#define REGULAR_INJECTED_GROUP          ADC_REGULAR_INJECTED_GROUP
N#define AWD_EVENT                       ADC_AWD_EVENT
N#define AWD1_EVENT                      ADC_AWD1_EVENT
N#define AWD2_EVENT                      ADC_AWD2_EVENT
N#define AWD3_EVENT                      ADC_AWD3_EVENT
N#define OVR_EVENT                       ADC_OVR_EVENT
N#define JQOVF_EVENT                     ADC_JQOVF_EVENT
N#define ALL_CHANNELS                    ADC_ALL_CHANNELS
N#define REGULAR_CHANNELS                ADC_REGULAR_CHANNELS
N#define INJECTED_CHANNELS               ADC_INJECTED_CHANNELS
N#define SYSCFG_FLAG_SENSOR_ADC          ADC_FLAG_SENSOR
N#define SYSCFG_FLAG_VREF_ADC            ADC_FLAG_VREFINT
N#define ADC_CLOCKPRESCALER_PCLK_DIV1    ADC_CLOCK_SYNC_PCLK_DIV1
N#define ADC_CLOCKPRESCALER_PCLK_DIV2    ADC_CLOCK_SYNC_PCLK_DIV2
N#define ADC_CLOCKPRESCALER_PCLK_DIV4    ADC_CLOCK_SYNC_PCLK_DIV4
N#define ADC_CLOCKPRESCALER_PCLK_DIV6    ADC_CLOCK_SYNC_PCLK_DIV6
N#define ADC_CLOCKPRESCALER_PCLK_DIV8    ADC_CLOCK_SYNC_PCLK_DIV8
N#define ADC_EXTERNALTRIG0_T6_TRGO       ADC_EXTERNALTRIGCONV_T6_TRGO
N#define ADC_EXTERNALTRIG1_T21_CC2       ADC_EXTERNALTRIGCONV_T21_CC2
N#define ADC_EXTERNALTRIG2_T2_TRGO       ADC_EXTERNALTRIGCONV_T2_TRGO
N#define ADC_EXTERNALTRIG3_T2_CC4        ADC_EXTERNALTRIGCONV_T2_CC4
N#define ADC_EXTERNALTRIG4_T22_TRGO      ADC_EXTERNALTRIGCONV_T22_TRGO
N#define ADC_EXTERNALTRIG7_EXT_IT11      ADC_EXTERNALTRIGCONV_EXT_IT11
N#define ADC_CLOCK_ASYNC                 ADC_CLOCK_ASYNC_DIV1
N#define ADC_EXTERNALTRIG_EDGE_NONE      ADC_EXTERNALTRIGCONVEDGE_NONE
N#define ADC_EXTERNALTRIG_EDGE_RISING    ADC_EXTERNALTRIGCONVEDGE_RISING
N#define ADC_EXTERNALTRIG_EDGE_FALLING   ADC_EXTERNALTRIGCONVEDGE_FALLING
N#define ADC_EXTERNALTRIG_EDGE_RISINGFALLING ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING
N#define ADC_SAMPLETIME_2CYCLE_5         ADC_SAMPLETIME_2CYCLES_5
N
N#define HAL_ADC_STATE_BUSY_REG          HAL_ADC_STATE_REG_BUSY
N#define HAL_ADC_STATE_BUSY_INJ          HAL_ADC_STATE_INJ_BUSY
N#define HAL_ADC_STATE_EOC_REG           HAL_ADC_STATE_REG_EOC
N#define HAL_ADC_STATE_EOC_INJ           HAL_ADC_STATE_INJ_EOC
N#define HAL_ADC_STATE_ERROR             HAL_ADC_STATE_ERROR_INTERNAL
N#define HAL_ADC_STATE_BUSY              HAL_ADC_STATE_BUSY_INTERNAL
N#define HAL_ADC_STATE_AWD               HAL_ADC_STATE_AWD1
N
N#if defined(STM32H7)
X#if 0L
S#define ADC_CHANNEL_VBAT_DIV4           ADC_CHANNEL_VBAT
N#endif /* STM32H7 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CEC_Aliased_Defines HAL CEC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_CEC_GET_IT __HAL_CEC_GET_FLAG
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_COMP_Aliased_Defines HAL COMP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define COMP_WINDOWMODE_DISABLED       COMP_WINDOWMODE_DISABLE
N#define COMP_WINDOWMODE_ENABLED        COMP_WINDOWMODE_ENABLE
N#define COMP_EXTI_LINE_COMP1_EVENT     COMP_EXTI_LINE_COMP1
N#define COMP_EXTI_LINE_COMP2_EVENT     COMP_EXTI_LINE_COMP2
N#define COMP_EXTI_LINE_COMP3_EVENT     COMP_EXTI_LINE_COMP3
N#define COMP_EXTI_LINE_COMP4_EVENT     COMP_EXTI_LINE_COMP4
N#define COMP_EXTI_LINE_COMP5_EVENT     COMP_EXTI_LINE_COMP5
N#define COMP_EXTI_LINE_COMP6_EVENT     COMP_EXTI_LINE_COMP6
N#define COMP_EXTI_LINE_COMP7_EVENT     COMP_EXTI_LINE_COMP7
N#if defined(STM32L0)
X#if 0L
S#define COMP_LPTIMCONNECTION_ENABLED   ((uint32_t)0x00000003U)    /*!< COMPX output generic naming: connected to LPTIM input 1 for COMP1, LPTIM input 2 for COMP2 */
N#endif
N#define COMP_OUTPUT_COMP6TIM2OCREFCLR  COMP_OUTPUT_COMP6_TIM2OCREFCLR
N#if defined(STM32F373xC) || defined(STM32F378xx)
X#if 0L || 0L
S#define COMP_OUTPUT_TIM3IC1            COMP_OUTPUT_COMP1_TIM3IC1
S#define COMP_OUTPUT_TIM3OCREFCLR       COMP_OUTPUT_COMP1_TIM3OCREFCLR
N#endif /* STM32F373xC || STM32F378xx */
N
N#if defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L
S#define COMP_WINDOWMODE_ENABLE         COMP_WINDOWMODE_COMP1_INPUT_PLUS_COMMON
S
S#define COMP_NONINVERTINGINPUT_IO1      COMP_INPUT_PLUS_IO1
S#define COMP_NONINVERTINGINPUT_IO2      COMP_INPUT_PLUS_IO2
S#define COMP_NONINVERTINGINPUT_IO3      COMP_INPUT_PLUS_IO3
S#define COMP_NONINVERTINGINPUT_IO4      COMP_INPUT_PLUS_IO4
S#define COMP_NONINVERTINGINPUT_IO5      COMP_INPUT_PLUS_IO5
S#define COMP_NONINVERTINGINPUT_IO6      COMP_INPUT_PLUS_IO6
S
S#define COMP_INVERTINGINPUT_1_4VREFINT  COMP_INPUT_MINUS_1_4VREFINT
S#define COMP_INVERTINGINPUT_1_2VREFINT  COMP_INPUT_MINUS_1_2VREFINT
S#define COMP_INVERTINGINPUT_3_4VREFINT  COMP_INPUT_MINUS_3_4VREFINT
S#define COMP_INVERTINGINPUT_VREFINT     COMP_INPUT_MINUS_VREFINT
S#define COMP_INVERTINGINPUT_DAC1_CH1    COMP_INPUT_MINUS_DAC1_CH1
S#define COMP_INVERTINGINPUT_DAC1_CH2    COMP_INPUT_MINUS_DAC1_CH2
S#define COMP_INVERTINGINPUT_DAC1        COMP_INPUT_MINUS_DAC1_CH1
S#define COMP_INVERTINGINPUT_DAC2        COMP_INPUT_MINUS_DAC1_CH2
S#define COMP_INVERTINGINPUT_IO1         COMP_INPUT_MINUS_IO1
S#if defined(STM32L0)
S/* Issue fixed on STM32L0 COMP driver: only 2 dedicated IO (IO1 and IO2),     */
S/* IO2 was wrongly assigned to IO shared with DAC and IO3 was corresponding   */
S/* to the second dedicated IO (only for COMP2).                               */
S#define COMP_INVERTINGINPUT_IO2         COMP_INPUT_MINUS_DAC1_CH2
S#define COMP_INVERTINGINPUT_IO3         COMP_INPUT_MINUS_IO2
S#else
S#define COMP_INVERTINGINPUT_IO2         COMP_INPUT_MINUS_IO2
S#define COMP_INVERTINGINPUT_IO3         COMP_INPUT_MINUS_IO3
S#endif
S#define COMP_INVERTINGINPUT_IO4         COMP_INPUT_MINUS_IO4
S#define COMP_INVERTINGINPUT_IO5         COMP_INPUT_MINUS_IO5
S
S#define COMP_OUTPUTLEVEL_LOW            COMP_OUTPUT_LEVEL_LOW
S#define COMP_OUTPUTLEVEL_HIGH           COMP_OUTPUT_LEVEL_HIGH
S
S/* Note: Literal "COMP_FLAG_LOCK" kept for legacy purpose.                    */
S/*       To check COMP lock state, use macro "__HAL_COMP_IS_LOCKED()".        */
S#if defined(COMP_CSR_LOCK)
S#define COMP_FLAG_LOCK                 COMP_CSR_LOCK
S#elif defined(COMP_CSR_COMP1LOCK)
S#define COMP_FLAG_LOCK                 COMP_CSR_COMP1LOCK
S#elif defined(COMP_CSR_COMPxLOCK)
S#define COMP_FLAG_LOCK                 COMP_CSR_COMPxLOCK
S#endif
S
S#if defined(STM32L4)
S#define COMP_BLANKINGSRCE_TIM1OC5        COMP_BLANKINGSRC_TIM1_OC5_COMP1
S#define COMP_BLANKINGSRCE_TIM2OC3        COMP_BLANKINGSRC_TIM2_OC3_COMP1
S#define COMP_BLANKINGSRCE_TIM3OC3        COMP_BLANKINGSRC_TIM3_OC3_COMP1
S#define COMP_BLANKINGSRCE_TIM3OC4        COMP_BLANKINGSRC_TIM3_OC4_COMP2
S#define COMP_BLANKINGSRCE_TIM8OC5        COMP_BLANKINGSRC_TIM8_OC5_COMP2
S#define COMP_BLANKINGSRCE_TIM15OC1       COMP_BLANKINGSRC_TIM15_OC1_COMP2
S#define COMP_BLANKINGSRCE_NONE           COMP_BLANKINGSRC_NONE
S#endif
S
S#if defined(STM32L0)
S#define COMP_MODE_HIGHSPEED              COMP_POWERMODE_MEDIUMSPEED
S#define COMP_MODE_LOWSPEED               COMP_POWERMODE_ULTRALOWPOWER
S#else
S#define COMP_MODE_HIGHSPEED              COMP_POWERMODE_HIGHSPEED
S#define COMP_MODE_MEDIUMSPEED            COMP_POWERMODE_MEDIUMSPEED
S#define COMP_MODE_LOWPOWER               COMP_POWERMODE_LOWPOWER
S#define COMP_MODE_ULTRALOWPOWER          COMP_POWERMODE_ULTRALOWPOWER
S#endif
S
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CORTEX_Aliased_Defines HAL CORTEX Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define __HAL_CORTEX_SYSTICKCLK_CONFIG HAL_SYSTICK_CLKSourceConfig
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CRC_Aliased_Defines HAL CRC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define CRC_OUTPUTDATA_INVERSION_DISABLED    CRC_OUTPUTDATA_INVERSION_DISABLE
N#define CRC_OUTPUTDATA_INVERSION_ENABLED     CRC_OUTPUTDATA_INVERSION_ENABLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DAC_Aliased_Defines HAL DAC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define DAC1_CHANNEL_1                                  DAC_CHANNEL_1
N#define DAC1_CHANNEL_2                                  DAC_CHANNEL_2
N#define DAC2_CHANNEL_1                                  DAC_CHANNEL_1
N#define DAC_WAVE_NONE                                   0x00000000U
N#define DAC_WAVE_NOISE                                  DAC_CR_WAVE1_0
N#define DAC_WAVE_TRIANGLE                               DAC_CR_WAVE1_1
N#define DAC_WAVEGENERATION_NONE                         DAC_WAVE_NONE
N#define DAC_WAVEGENERATION_NOISE                        DAC_WAVE_NOISE
N#define DAC_WAVEGENERATION_TRIANGLE                     DAC_WAVE_TRIANGLE
N
N#if defined(STM32G4) || defined(STM32H7) || defined (STM32U5)
X#if 0L || 0L || 0L
S#define DAC_CHIPCONNECT_DISABLE       DAC_CHIPCONNECT_EXTERNAL
S#define DAC_CHIPCONNECT_ENABLE        DAC_CHIPCONNECT_INTERNAL
N#endif
N
N#if defined(STM32L1) || defined(STM32L4) || defined(STM32G0) || defined(STM32L5) || defined(STM32H7) || defined(STM32F4) || defined(STM32G4)
X#if 0L || 0L || 0L || 0L || 0L || 1L || 0L
N#define HAL_DAC_MSP_INIT_CB_ID       HAL_DAC_MSPINIT_CB_ID
N#define HAL_DAC_MSP_DEINIT_CB_ID     HAL_DAC_MSPDEINIT_CB_ID
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DMA_Aliased_Defines HAL DMA Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define HAL_REMAPDMA_ADC_DMA_CH2                DMA_REMAP_ADC_DMA_CH2
N#define HAL_REMAPDMA_USART1_TX_DMA_CH4          DMA_REMAP_USART1_TX_DMA_CH4
N#define HAL_REMAPDMA_USART1_RX_DMA_CH5          DMA_REMAP_USART1_RX_DMA_CH5
N#define HAL_REMAPDMA_TIM16_DMA_CH4              DMA_REMAP_TIM16_DMA_CH4
N#define HAL_REMAPDMA_TIM17_DMA_CH2              DMA_REMAP_TIM17_DMA_CH2
N#define HAL_REMAPDMA_USART3_DMA_CH32            DMA_REMAP_USART3_DMA_CH32
N#define HAL_REMAPDMA_TIM16_DMA_CH6              DMA_REMAP_TIM16_DMA_CH6
N#define HAL_REMAPDMA_TIM17_DMA_CH7              DMA_REMAP_TIM17_DMA_CH7
N#define HAL_REMAPDMA_SPI2_DMA_CH67              DMA_REMAP_SPI2_DMA_CH67
N#define HAL_REMAPDMA_USART2_DMA_CH67            DMA_REMAP_USART2_DMA_CH67
N#define HAL_REMAPDMA_I2C1_DMA_CH76              DMA_REMAP_I2C1_DMA_CH76
N#define HAL_REMAPDMA_TIM1_DMA_CH6               DMA_REMAP_TIM1_DMA_CH6
N#define HAL_REMAPDMA_TIM2_DMA_CH7               DMA_REMAP_TIM2_DMA_CH7
N#define HAL_REMAPDMA_TIM3_DMA_CH6               DMA_REMAP_TIM3_DMA_CH6
N
N#define IS_HAL_REMAPDMA                          IS_DMA_REMAP
N#define __HAL_REMAPDMA_CHANNEL_ENABLE            __HAL_DMA_REMAP_CHANNEL_ENABLE
N#define __HAL_REMAPDMA_CHANNEL_DISABLE           __HAL_DMA_REMAP_CHANNEL_DISABLE
N
N#if defined(STM32L4)
X#if 0L
S
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI0            HAL_DMAMUX1_REQ_GEN_EXTI0
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI1            HAL_DMAMUX1_REQ_GEN_EXTI1
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI2            HAL_DMAMUX1_REQ_GEN_EXTI2
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI3            HAL_DMAMUX1_REQ_GEN_EXTI3
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI4            HAL_DMAMUX1_REQ_GEN_EXTI4
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI5            HAL_DMAMUX1_REQ_GEN_EXTI5
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI6            HAL_DMAMUX1_REQ_GEN_EXTI6
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI7            HAL_DMAMUX1_REQ_GEN_EXTI7
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI8            HAL_DMAMUX1_REQ_GEN_EXTI8
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI9            HAL_DMAMUX1_REQ_GEN_EXTI9
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI10           HAL_DMAMUX1_REQ_GEN_EXTI10
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI11           HAL_DMAMUX1_REQ_GEN_EXTI11
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI12           HAL_DMAMUX1_REQ_GEN_EXTI12
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI13           HAL_DMAMUX1_REQ_GEN_EXTI13
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI14           HAL_DMAMUX1_REQ_GEN_EXTI14
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI15           HAL_DMAMUX1_REQ_GEN_EXTI15
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH0_EVT  HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH0_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH1_EVT  HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH1_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH2_EVT  HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH2_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH3_EVT  HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH3_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM1_OUT       HAL_DMAMUX1_REQ_GEN_LPTIM1_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM2_OUT       HAL_DMAMUX1_REQ_GEN_LPTIM2_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_DSI_TE           HAL_DMAMUX1_REQ_GEN_DSI_TE
S#define HAL_DMAMUX1_REQUEST_GEN_DSI_EOT          HAL_DMAMUX1_REQ_GEN_DSI_EOT
S#define HAL_DMAMUX1_REQUEST_GEN_DMA2D_EOT        HAL_DMAMUX1_REQ_GEN_DMA2D_EOT
S#define HAL_DMAMUX1_REQUEST_GEN_LTDC_IT          HAL_DMAMUX1_REQ_GEN_LTDC_IT
S
S#define HAL_DMAMUX_REQUEST_GEN_NO_EVENT          HAL_DMAMUX_REQ_GEN_NO_EVENT
S#define HAL_DMAMUX_REQUEST_GEN_RISING            HAL_DMAMUX_REQ_GEN_RISING
S#define HAL_DMAMUX_REQUEST_GEN_FALLING           HAL_DMAMUX_REQ_GEN_FALLING
S#define HAL_DMAMUX_REQUEST_GEN_RISING_FALLING    HAL_DMAMUX_REQ_GEN_RISING_FALLING
S
S#if defined(STM32L4R5xx) || defined(STM32L4R9xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
S#define DMA_REQUEST_DCMI_PSSI                    DMA_REQUEST_DCMI
S#endif
S
N#endif /* STM32L4 */
N
N#if defined(STM32G0)
X#if 0L
S#define DMA_REQUEST_DAC1_CHANNEL1                DMA_REQUEST_DAC1_CH1
S#define DMA_REQUEST_DAC1_CHANNEL2                DMA_REQUEST_DAC1_CH2
S#define DMA_REQUEST_TIM16_TRIG_COM               DMA_REQUEST_TIM16_COM
S#define DMA_REQUEST_TIM17_TRIG_COM               DMA_REQUEST_TIM17_COM
S
S#define LL_DMAMUX_REQ_TIM16_TRIG_COM             LL_DMAMUX_REQ_TIM16_COM
S#define LL_DMAMUX_REQ_TIM17_TRIG_COM             LL_DMAMUX_REQ_TIM17_COM
N#endif
N
N#if defined(STM32H7)
X#if 0L
S
S#define DMA_REQUEST_DAC1 DMA_REQUEST_DAC1_CH1
S#define DMA_REQUEST_DAC2 DMA_REQUEST_DAC1_CH2
S
S#define BDMA_REQUEST_LP_UART1_RX BDMA_REQUEST_LPUART1_RX
S#define BDMA_REQUEST_LP_UART1_TX BDMA_REQUEST_LPUART1_TX
S
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH0_EVT    HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH0_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH1_EVT    HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH1_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH2_EVT    HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH2_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM1_OUT         HAL_DMAMUX1_REQ_GEN_LPTIM1_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM2_OUT         HAL_DMAMUX1_REQ_GEN_LPTIM2_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM3_OUT         HAL_DMAMUX1_REQ_GEN_LPTIM3_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI0              HAL_DMAMUX1_REQ_GEN_EXTI0
S#define HAL_DMAMUX1_REQUEST_GEN_TIM12_TRGO         HAL_DMAMUX1_REQ_GEN_TIM12_TRGO
S
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH0_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH0_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH1_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH1_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH2_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH2_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH3_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH3_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH4_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH4_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH5_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH5_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH6_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH6_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_LPUART1_RX_WKUP    HAL_DMAMUX2_REQ_GEN_LPUART1_RX_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPUART1_TX_WKUP    HAL_DMAMUX2_REQ_GEN_LPUART1_TX_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM2_WKUP        HAL_DMAMUX2_REQ_GEN_LPTIM2_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM2_OUT         HAL_DMAMUX2_REQ_GEN_LPTIM2_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM3_WKUP        HAL_DMAMUX2_REQ_GEN_LPTIM3_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM3_OUT         HAL_DMAMUX2_REQ_GEN_LPTIM3_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM4_WKUP        HAL_DMAMUX2_REQ_GEN_LPTIM4_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM5_WKUP        HAL_DMAMUX2_REQ_GEN_LPTIM5_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_I2C4_WKUP          HAL_DMAMUX2_REQ_GEN_I2C4_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_SPI6_WKUP          HAL_DMAMUX2_REQ_GEN_SPI6_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_COMP1_OUT          HAL_DMAMUX2_REQ_GEN_COMP1_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_COMP2_OUT          HAL_DMAMUX2_REQ_GEN_COMP2_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_RTC_WKUP           HAL_DMAMUX2_REQ_GEN_RTC_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_EXTI0              HAL_DMAMUX2_REQ_GEN_EXTI0
S#define HAL_DMAMUX2_REQUEST_GEN_EXTI2              HAL_DMAMUX2_REQ_GEN_EXTI2
S#define HAL_DMAMUX2_REQUEST_GEN_I2C4_IT_EVT        HAL_DMAMUX2_REQ_GEN_I2C4_IT_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_SPI6_IT            HAL_DMAMUX2_REQ_GEN_SPI6_IT
S#define HAL_DMAMUX2_REQUEST_GEN_LPUART1_TX_IT      HAL_DMAMUX2_REQ_GEN_LPUART1_TX_IT
S#define HAL_DMAMUX2_REQUEST_GEN_LPUART1_RX_IT      HAL_DMAMUX2_REQ_GEN_LPUART1_RX_IT
S#define HAL_DMAMUX2_REQUEST_GEN_ADC3_IT            HAL_DMAMUX2_REQ_GEN_ADC3_IT
S#define HAL_DMAMUX2_REQUEST_GEN_ADC3_AWD1_OUT      HAL_DMAMUX2_REQ_GEN_ADC3_AWD1_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_BDMA_CH0_IT        HAL_DMAMUX2_REQ_GEN_BDMA_CH0_IT
S#define HAL_DMAMUX2_REQUEST_GEN_BDMA_CH1_IT        HAL_DMAMUX2_REQ_GEN_BDMA_CH1_IT
S
S#define HAL_DMAMUX_REQUEST_GEN_NO_EVENT            HAL_DMAMUX_REQ_GEN_NO_EVENT
S#define HAL_DMAMUX_REQUEST_GEN_RISING              HAL_DMAMUX_REQ_GEN_RISING
S#define HAL_DMAMUX_REQUEST_GEN_FALLING             HAL_DMAMUX_REQ_GEN_FALLING
S#define HAL_DMAMUX_REQUEST_GEN_RISING_FALLING      HAL_DMAMUX_REQ_GEN_RISING_FALLING
S
S#define DFSDM_FILTER_EXT_TRIG_LPTIM1               DFSDM_FILTER_EXT_TRIG_LPTIM1_OUT
S#define DFSDM_FILTER_EXT_TRIG_LPTIM2               DFSDM_FILTER_EXT_TRIG_LPTIM2_OUT
S#define DFSDM_FILTER_EXT_TRIG_LPTIM3               DFSDM_FILTER_EXT_TRIG_LPTIM3_OUT
S
S#define DAC_TRIGGER_LP1_OUT                        DAC_TRIGGER_LPTIM1_OUT
S#define DAC_TRIGGER_LP2_OUT                        DAC_TRIGGER_LPTIM2_OUT
S
N#endif /* STM32H7 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_FLASH_Aliased_Defines HAL FLASH Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define TYPEPROGRAM_BYTE              FLASH_TYPEPROGRAM_BYTE
N#define TYPEPROGRAM_HALFWORD          FLASH_TYPEPROGRAM_HALFWORD
N#define TYPEPROGRAM_WORD              FLASH_TYPEPROGRAM_WORD
N#define TYPEPROGRAM_DOUBLEWORD        FLASH_TYPEPROGRAM_DOUBLEWORD
N#define TYPEERASE_SECTORS             FLASH_TYPEERASE_SECTORS
N#define TYPEERASE_PAGES               FLASH_TYPEERASE_PAGES
N#define TYPEERASE_PAGEERASE           FLASH_TYPEERASE_PAGES
N#define TYPEERASE_MASSERASE           FLASH_TYPEERASE_MASSERASE
N#define WRPSTATE_DISABLE              OB_WRPSTATE_DISABLE
N#define WRPSTATE_ENABLE               OB_WRPSTATE_ENABLE
N#define HAL_FLASH_TIMEOUT_VALUE       FLASH_TIMEOUT_VALUE
N#define OBEX_PCROP                    OPTIONBYTE_PCROP
N#define OBEX_BOOTCONFIG               OPTIONBYTE_BOOTCONFIG
N#define PCROPSTATE_DISABLE            OB_PCROP_STATE_DISABLE
N#define PCROPSTATE_ENABLE             OB_PCROP_STATE_ENABLE
N#define TYPEERASEDATA_BYTE            FLASH_TYPEERASEDATA_BYTE
N#define TYPEERASEDATA_HALFWORD        FLASH_TYPEERASEDATA_HALFWORD
N#define TYPEERASEDATA_WORD            FLASH_TYPEERASEDATA_WORD
N#define TYPEPROGRAMDATA_BYTE          FLASH_TYPEPROGRAMDATA_BYTE
N#define TYPEPROGRAMDATA_HALFWORD      FLASH_TYPEPROGRAMDATA_HALFWORD
N#define TYPEPROGRAMDATA_WORD          FLASH_TYPEPROGRAMDATA_WORD
N#define TYPEPROGRAMDATA_FASTBYTE      FLASH_TYPEPROGRAMDATA_FASTBYTE
N#define TYPEPROGRAMDATA_FASTHALFWORD  FLASH_TYPEPROGRAMDATA_FASTHALFWORD
N#define TYPEPROGRAMDATA_FASTWORD      FLASH_TYPEPROGRAMDATA_FASTWORD
N#define PAGESIZE                      FLASH_PAGE_SIZE
N#define TYPEPROGRAM_FASTBYTE          FLASH_TYPEPROGRAM_BYTE
N#define TYPEPROGRAM_FASTHALFWORD      FLASH_TYPEPROGRAM_HALFWORD
N#define TYPEPROGRAM_FASTWORD          FLASH_TYPEPROGRAM_WORD
N#define VOLTAGE_RANGE_1               FLASH_VOLTAGE_RANGE_1
N#define VOLTAGE_RANGE_2               FLASH_VOLTAGE_RANGE_2
N#define VOLTAGE_RANGE_3               FLASH_VOLTAGE_RANGE_3
N#define VOLTAGE_RANGE_4               FLASH_VOLTAGE_RANGE_4
N#define TYPEPROGRAM_FAST              FLASH_TYPEPROGRAM_FAST
N#define TYPEPROGRAM_FAST_AND_LAST     FLASH_TYPEPROGRAM_FAST_AND_LAST
N#define WRPAREA_BANK1_AREAA           OB_WRPAREA_BANK1_AREAA
N#define WRPAREA_BANK1_AREAB           OB_WRPAREA_BANK1_AREAB
N#define WRPAREA_BANK2_AREAA           OB_WRPAREA_BANK2_AREAA
N#define WRPAREA_BANK2_AREAB           OB_WRPAREA_BANK2_AREAB
N#define IWDG_STDBY_FREEZE             OB_IWDG_STDBY_FREEZE
N#define IWDG_STDBY_ACTIVE             OB_IWDG_STDBY_RUN
N#define IWDG_STOP_FREEZE              OB_IWDG_STOP_FREEZE
N#define IWDG_STOP_ACTIVE              OB_IWDG_STOP_RUN
N#define FLASH_ERROR_NONE              HAL_FLASH_ERROR_NONE
N#define FLASH_ERROR_RD                HAL_FLASH_ERROR_RD
N#define FLASH_ERROR_PG                HAL_FLASH_ERROR_PROG
N#define FLASH_ERROR_PGP               HAL_FLASH_ERROR_PGS
N#define FLASH_ERROR_WRP               HAL_FLASH_ERROR_WRP
N#define FLASH_ERROR_OPTV              HAL_FLASH_ERROR_OPTV
N#define FLASH_ERROR_OPTVUSR           HAL_FLASH_ERROR_OPTVUSR
N#define FLASH_ERROR_PROG              HAL_FLASH_ERROR_PROG
N#define FLASH_ERROR_OP                HAL_FLASH_ERROR_OPERATION
N#define FLASH_ERROR_PGA               HAL_FLASH_ERROR_PGA
N#define FLASH_ERROR_SIZE              HAL_FLASH_ERROR_SIZE
N#define FLASH_ERROR_SIZ               HAL_FLASH_ERROR_SIZE
N#define FLASH_ERROR_PGS               HAL_FLASH_ERROR_PGS
N#define FLASH_ERROR_MIS               HAL_FLASH_ERROR_MIS
N#define FLASH_ERROR_FAST              HAL_FLASH_ERROR_FAST
N#define FLASH_ERROR_FWWERR            HAL_FLASH_ERROR_FWWERR
N#define FLASH_ERROR_NOTZERO           HAL_FLASH_ERROR_NOTZERO
N#define FLASH_ERROR_OPERATION         HAL_FLASH_ERROR_OPERATION
N#define FLASH_ERROR_ERS               HAL_FLASH_ERROR_ERS
N#define OB_WDG_SW                     OB_IWDG_SW
N#define OB_WDG_HW                     OB_IWDG_HW
N#define OB_SDADC12_VDD_MONITOR_SET    OB_SDACD_VDD_MONITOR_SET
N#define OB_SDADC12_VDD_MONITOR_RESET  OB_SDACD_VDD_MONITOR_RESET
N#define OB_RAM_PARITY_CHECK_SET       OB_SRAM_PARITY_SET
N#define OB_RAM_PARITY_CHECK_RESET     OB_SRAM_PARITY_RESET
N#define IS_OB_SDADC12_VDD_MONITOR     IS_OB_SDACD_VDD_MONITOR
N#define OB_RDP_LEVEL0                 OB_RDP_LEVEL_0
N#define OB_RDP_LEVEL1                 OB_RDP_LEVEL_1
N#define OB_RDP_LEVEL2                 OB_RDP_LEVEL_2
N#if defined(STM32G0)
X#if 0L
S#define OB_BOOT_LOCK_DISABLE          OB_BOOT_ENTRY_FORCED_NONE
S#define OB_BOOT_LOCK_ENABLE           OB_BOOT_ENTRY_FORCED_FLASH
N#else
N#define OB_BOOT_ENTRY_FORCED_NONE     OB_BOOT_LOCK_DISABLE
N#define OB_BOOT_ENTRY_FORCED_FLASH    OB_BOOT_LOCK_ENABLE
N#endif
N#if defined(STM32H7)
X#if 0L
S#define FLASH_FLAG_SNECCE_BANK1RR     FLASH_FLAG_SNECCERR_BANK1
S#define FLASH_FLAG_DBECCE_BANK1RR     FLASH_FLAG_DBECCERR_BANK1
S#define FLASH_FLAG_STRBER_BANK1R      FLASH_FLAG_STRBERR_BANK1
S#define FLASH_FLAG_SNECCE_BANK2RR     FLASH_FLAG_SNECCERR_BANK2
S#define FLASH_FLAG_DBECCE_BANK2RR     FLASH_FLAG_DBECCERR_BANK2
S#define FLASH_FLAG_STRBER_BANK2R      FLASH_FLAG_STRBERR_BANK2
S#define FLASH_FLAG_WDW                FLASH_FLAG_WBNE
S#define OB_WRP_SECTOR_All             OB_WRP_SECTOR_ALL
N#endif /* STM32H7 */
N#if defined(STM32U5)
X#if 0L
S#define OB_USER_nRST_STOP             OB_USER_NRST_STOP
S#define OB_USER_nRST_STDBY            OB_USER_NRST_STDBY
S#define OB_USER_nRST_SHDW             OB_USER_NRST_SHDW
S#define OB_USER_nSWBOOT0              OB_USER_NSWBOOT0
S#define OB_USER_nBOOT0                OB_USER_NBOOT0
S#define OB_nBOOT0_RESET               OB_NBOOT0_RESET
S#define OB_nBOOT0_SET                 OB_NBOOT0_SET
N#endif /* STM32U5 */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_JPEG_Aliased_Macros HAL JPEG Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#if defined(STM32H7)
X#if 0L
S#define __HAL_RCC_JPEG_CLK_ENABLE               __HAL_RCC_JPGDECEN_CLK_ENABLE
S#define __HAL_RCC_JPEG_CLK_DISABLE              __HAL_RCC_JPGDECEN_CLK_DISABLE
S#define __HAL_RCC_JPEG_FORCE_RESET              __HAL_RCC_JPGDECRST_FORCE_RESET
S#define __HAL_RCC_JPEG_RELEASE_RESET            __HAL_RCC_JPGDECRST_RELEASE_RESET
S#define __HAL_RCC_JPEG_CLK_SLEEP_ENABLE         __HAL_RCC_JPGDEC_CLK_SLEEP_ENABLE
S#define __HAL_RCC_JPEG_CLK_SLEEP_DISABLE        __HAL_RCC_JPGDEC_CLK_SLEEP_DISABLE
N#endif /* STM32H7 */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SYSCFG_Aliased_Defines HAL SYSCFG Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PA9    I2C_FASTMODEPLUS_PA9
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PA10   I2C_FASTMODEPLUS_PA10
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB6    I2C_FASTMODEPLUS_PB6
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB7    I2C_FASTMODEPLUS_PB7
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB8    I2C_FASTMODEPLUS_PB8
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB9    I2C_FASTMODEPLUS_PB9
N#define HAL_SYSCFG_FASTMODEPLUS_I2C1       I2C_FASTMODEPLUS_I2C1
N#define HAL_SYSCFG_FASTMODEPLUS_I2C2       I2C_FASTMODEPLUS_I2C2
N#define HAL_SYSCFG_FASTMODEPLUS_I2C3       I2C_FASTMODEPLUS_I2C3
N#if defined(STM32G4)
X#if 0L
S
S#define HAL_SYSCFG_EnableIOAnalogSwitchBooster    HAL_SYSCFG_EnableIOSwitchBooster
S#define HAL_SYSCFG_DisableIOAnalogSwitchBooster   HAL_SYSCFG_DisableIOSwitchBooster
S#define HAL_SYSCFG_EnableIOAnalogSwitchVDD        HAL_SYSCFG_EnableIOSwitchVDD
S#define HAL_SYSCFG_DisableIOAnalogSwitchVDD       HAL_SYSCFG_DisableIOSwitchVDD
N#endif /* STM32G4 */
N
N/**
N  * @}
N  */
N
N
N/** @defgroup LL_FMC_Aliased_Defines LL FMC Aliased Defines maintained for compatibility purpose
N  * @{
N  */
N#if defined(STM32L4) || defined(STM32F7) || defined(STM32H7) || defined(STM32G4)
X#if 0L || 0L || 0L || 0L
S#define FMC_NAND_PCC_WAIT_FEATURE_DISABLE       FMC_NAND_WAIT_FEATURE_DISABLE
S#define FMC_NAND_PCC_WAIT_FEATURE_ENABLE        FMC_NAND_WAIT_FEATURE_ENABLE
S#define FMC_NAND_PCC_MEM_BUS_WIDTH_8            FMC_NAND_MEM_BUS_WIDTH_8
S#define FMC_NAND_PCC_MEM_BUS_WIDTH_16           FMC_NAND_MEM_BUS_WIDTH_16
N#elif defined(STM32F1) || defined(STM32F2) || defined(STM32F3) || defined(STM32F4)
X#elif 0L || 0L || 0L || 1L
N#define FMC_NAND_WAIT_FEATURE_DISABLE           FMC_NAND_PCC_WAIT_FEATURE_DISABLE
N#define FMC_NAND_WAIT_FEATURE_ENABLE            FMC_NAND_PCC_WAIT_FEATURE_ENABLE
N#define FMC_NAND_MEM_BUS_WIDTH_8                FMC_NAND_PCC_MEM_BUS_WIDTH_8
N#define FMC_NAND_MEM_BUS_WIDTH_16               FMC_NAND_PCC_MEM_BUS_WIDTH_16
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup LL_FSMC_Aliased_Defines LL FSMC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define FSMC_NORSRAM_TYPEDEF                      FSMC_NORSRAM_TypeDef
N#define FSMC_NORSRAM_EXTENDED_TYPEDEF             FSMC_NORSRAM_EXTENDED_TypeDef
N/**
N  * @}
N  */
N
N/** @defgroup HAL_GPIO_Aliased_Macros HAL GPIO Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define GET_GPIO_SOURCE                           GPIO_GET_INDEX
N#define GET_GPIO_INDEX                            GPIO_GET_INDEX
N
N#if defined(STM32F4)
X#if 1L
N#define GPIO_AF12_SDMMC                           GPIO_AF12_SDIO
N#define GPIO_AF12_SDMMC1                          GPIO_AF12_SDIO
N#endif
N
N#if defined(STM32F7)
X#if 0L
S#define GPIO_AF12_SDIO                            GPIO_AF12_SDMMC1
S#define GPIO_AF12_SDMMC                           GPIO_AF12_SDMMC1
N#endif
N
N#if defined(STM32L4)
X#if 0L
S#define GPIO_AF12_SDIO                            GPIO_AF12_SDMMC1
S#define GPIO_AF12_SDMMC                           GPIO_AF12_SDMMC1
N#endif
N
N#if defined(STM32H7)
X#if 0L
S#define GPIO_AF7_SDIO1                            GPIO_AF7_SDMMC1
S#define GPIO_AF8_SDIO1                            GPIO_AF8_SDMMC1
S#define GPIO_AF12_SDIO1                           GPIO_AF12_SDMMC1
S#define GPIO_AF9_SDIO2                            GPIO_AF9_SDMMC2
S#define GPIO_AF10_SDIO2                           GPIO_AF10_SDMMC2
S#define GPIO_AF11_SDIO2                           GPIO_AF11_SDMMC2
S
S#if defined (STM32H743xx) || defined (STM32H753xx)  || defined (STM32H750xx) || defined (STM32H742xx) || \
S    defined (STM32H745xx) || defined (STM32H755xx)  || defined (STM32H747xx) || defined (STM32H757xx)
X#if defined (STM32H743xx) || defined (STM32H753xx)  || defined (STM32H750xx) || defined (STM32H742xx) ||     defined (STM32H745xx) || defined (STM32H755xx)  || defined (STM32H747xx) || defined (STM32H757xx)
S#define GPIO_AF10_OTG2_HS  GPIO_AF10_OTG2_FS
S#define GPIO_AF10_OTG1_FS  GPIO_AF10_OTG1_HS
S#define GPIO_AF12_OTG2_FS  GPIO_AF12_OTG1_FS
S#endif /*STM32H743xx || STM32H753xx || STM32H750xx || STM32H742xx || STM32H745xx || STM32H755xx || STM32H747xx || STM32H757xx */
N#endif /* STM32H7 */
N
N#define GPIO_AF0_LPTIM                            GPIO_AF0_LPTIM1
N#define GPIO_AF1_LPTIM                            GPIO_AF1_LPTIM1
N#define GPIO_AF2_LPTIM                            GPIO_AF2_LPTIM1
N
N#if defined(STM32L0) || defined(STM32L4) || defined(STM32F4) || defined(STM32F2) || defined(STM32F7) || defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32U5)
X#if 0L || 0L || 1L || 0L || 0L || 0L || 0L || 0L || 0L
N#define  GPIO_SPEED_LOW                           GPIO_SPEED_FREQ_LOW
N#define  GPIO_SPEED_MEDIUM                        GPIO_SPEED_FREQ_MEDIUM
N#define  GPIO_SPEED_FAST                          GPIO_SPEED_FREQ_HIGH
N#define  GPIO_SPEED_HIGH                          GPIO_SPEED_FREQ_VERY_HIGH
N#endif /* STM32L0 || STM32L4 || STM32F4 || STM32F2 || STM32F7 || STM32G4 || STM32H7 || STM32WB || STM32U5*/
N
N#if defined(STM32L1)
X#if 0L
S#define  GPIO_SPEED_VERY_LOW    GPIO_SPEED_FREQ_LOW
S#define  GPIO_SPEED_LOW         GPIO_SPEED_FREQ_MEDIUM
S#define  GPIO_SPEED_MEDIUM      GPIO_SPEED_FREQ_HIGH
S#define  GPIO_SPEED_HIGH        GPIO_SPEED_FREQ_VERY_HIGH
N#endif /* STM32L1 */
N
N#if defined(STM32F0) || defined(STM32F3) || defined(STM32F1)
X#if 0L || 0L || 0L
S#define  GPIO_SPEED_LOW    GPIO_SPEED_FREQ_LOW
S#define  GPIO_SPEED_MEDIUM GPIO_SPEED_FREQ_MEDIUM
S#define  GPIO_SPEED_HIGH   GPIO_SPEED_FREQ_HIGH
N#endif /* STM32F0 || STM32F3 || STM32F1 */
N
N#define GPIO_AF6_DFSDM                            GPIO_AF6_DFSDM1
N/**
N  * @}
N  */
N
N/** @defgroup HAL_HRTIM_Aliased_Macros HAL HRTIM Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define HRTIM_TIMDELAYEDPROTECTION_DISABLED           HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DISABLED
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_EEV68  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_EEV68  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV68  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV68     HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_DEEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_DEEV7
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_DEEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_DEEV7
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV79  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV7
N#define HRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV79     HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV7
N
N#define __HAL_HRTIM_SetCounter        __HAL_HRTIM_SETCOUNTER
N#define __HAL_HRTIM_GetCounter        __HAL_HRTIM_GETCOUNTER
N#define __HAL_HRTIM_SetPeriod         __HAL_HRTIM_SETPERIOD
N#define __HAL_HRTIM_GetPeriod         __HAL_HRTIM_GETPERIOD
N#define __HAL_HRTIM_SetClockPrescaler __HAL_HRTIM_SETCLOCKPRESCALER
N#define __HAL_HRTIM_GetClockPrescaler __HAL_HRTIM_GETCLOCKPRESCALER
N#define __HAL_HRTIM_SetCompare        __HAL_HRTIM_SETCOMPARE
N#define __HAL_HRTIM_GetCompare        __HAL_HRTIM_GETCOMPARE
N
N#if defined(STM32G4)
X#if 0L
S#define HAL_HRTIM_ExternalEventCounterConfig    HAL_HRTIM_ExtEventCounterConfig
S#define HAL_HRTIM_ExternalEventCounterEnable    HAL_HRTIM_ExtEventCounterEnable
S#define HAL_HRTIM_ExternalEventCounterDisable   HAL_HRTIM_ExtEventCounterDisable
S#define HAL_HRTIM_ExternalEventCounterReset     HAL_HRTIM_ExtEventCounterReset
S#define HRTIM_TIMEEVENT_A                       HRTIM_EVENTCOUNTER_A
S#define HRTIM_TIMEEVENT_B                       HRTIM_EVENTCOUNTER_B
S#define HRTIM_TIMEEVENTRESETMODE_UNCONDITIONAL  HRTIM_EVENTCOUNTER_RSTMODE_UNCONDITIONAL
S#define HRTIM_TIMEEVENTRESETMODE_CONDITIONAL    HRTIM_EVENTCOUNTER_RSTMODE_CONDITIONAL
N#endif /* STM32G4 */
N
N#if defined(STM32H7)
X#if 0L
S#define HRTIM_OUTPUTSET_TIMAEV1_TIMBCMP1 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTSET_TIMAEV2_TIMBCMP2 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTSET_TIMAEV3_TIMCCMP2 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTSET_TIMAEV4_TIMCCMP3 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTSET_TIMAEV5_TIMDCMP1 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTSET_TIMAEV6_TIMDCMP2 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTSET_TIMAEV7_TIMECMP3 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTSET_TIMAEV8_TIMECMP4 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTSET_TIMAEV9_TIMFCMP4 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTSET_TIMBEV1_TIMACMP1 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTSET_TIMBEV2_TIMACMP2 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTSET_TIMBEV3_TIMCCMP3 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTSET_TIMBEV4_TIMCCMP4 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTSET_TIMBEV5_TIMDCMP3 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTSET_TIMBEV6_TIMDCMP4 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTSET_TIMBEV7_TIMECMP1 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTSET_TIMBEV8_TIMECMP2 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTSET_TIMBEV9_TIMFCMP3 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTSET_TIMCEV1_TIMACMP1 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTSET_TIMCEV2_TIMACMP2 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTSET_TIMCEV3_TIMBCMP2 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTSET_TIMCEV4_TIMBCMP3 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTSET_TIMCEV5_TIMDCMP2 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTSET_TIMCEV6_TIMDCMP4 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTSET_TIMCEV7_TIMECMP3 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTSET_TIMCEV8_TIMECMP4 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTSET_TIMCEV9_TIMFCMP2 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTSET_TIMDEV1_TIMACMP1 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTSET_TIMDEV2_TIMACMP4 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTSET_TIMDEV3_TIMBCMP2 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTSET_TIMDEV4_TIMBCMP4 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTSET_TIMDEV5_TIMCCMP4 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTSET_TIMDEV6_TIMECMP1 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTSET_TIMDEV7_TIMECMP4 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTSET_TIMDEV8_TIMFCMP1 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTSET_TIMDEV9_TIMFCMP3 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTSET_TIMEEV1_TIMACMP4 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTSET_TIMEEV2_TIMBCMP3 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTSET_TIMEEV3_TIMBCMP4 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTSET_TIMEEV4_TIMCCMP1 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTSET_TIMEEV5_TIMDCMP2 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTSET_TIMEEV6_TIMDCMP1 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTSET_TIMEEV7_TIMDCMP2 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTSET_TIMEEV8_TIMFCMP3 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTSET_TIMEEV9_TIMFCMP4 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTSET_TIMFEV1_TIMACMP3 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTSET_TIMFEV2_TIMBCMP1 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTSET_TIMFEV3_TIMBCMP4 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTSET_TIMFEV4_TIMCCMP1 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTSET_TIMFEV5_TIMCCMP4 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTSET_TIMFEV6_TIMDCMP3 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTSET_TIMFEV7_TIMDCMP4 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTSET_TIMFEV8_TIMECMP2 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTSET_TIMFEV9_TIMECMP3 HRTIM_OUTPUTSET_TIMEV_9
S
S#define HRTIM_OUTPUTRESET_TIMAEV1_TIMBCMP1 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTRESET_TIMAEV2_TIMBCMP2 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTRESET_TIMAEV3_TIMCCMP2 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTRESET_TIMAEV4_TIMCCMP3 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTRESET_TIMAEV5_TIMDCMP1 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTRESET_TIMAEV6_TIMDCMP2 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTRESET_TIMAEV7_TIMECMP3 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTRESET_TIMAEV8_TIMECMP4 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTRESET_TIMAEV9_TIMFCMP4 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTRESET_TIMBEV1_TIMACMP1 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTRESET_TIMBEV2_TIMACMP2 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTRESET_TIMBEV3_TIMCCMP3 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTRESET_TIMBEV4_TIMCCMP4 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTRESET_TIMBEV5_TIMDCMP3 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTRESET_TIMBEV6_TIMDCMP4 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTRESET_TIMBEV7_TIMECMP1 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTRESET_TIMBEV8_TIMECMP2 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTRESET_TIMBEV9_TIMFCMP3 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTRESET_TIMCEV1_TIMACMP1 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTRESET_TIMCEV2_TIMACMP2 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTRESET_TIMCEV3_TIMBCMP2 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTRESET_TIMCEV4_TIMBCMP3 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTRESET_TIMCEV5_TIMDCMP2 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTRESET_TIMCEV6_TIMDCMP4 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTRESET_TIMCEV7_TIMECMP3 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTRESET_TIMCEV8_TIMECMP4 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTRESET_TIMCEV9_TIMFCMP2 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTRESET_TIMDEV1_TIMACMP1 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTRESET_TIMDEV2_TIMACMP4 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTRESET_TIMDEV3_TIMBCMP2 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTRESET_TIMDEV4_TIMBCMP4 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTRESET_TIMDEV5_TIMCCMP4 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTRESET_TIMDEV6_TIMECMP1 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTRESET_TIMDEV7_TIMECMP4 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTRESET_TIMDEV8_TIMFCMP1 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTRESET_TIMDEV9_TIMFCMP3 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTRESET_TIMEEV1_TIMACMP4 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTRESET_TIMEEV2_TIMBCMP3 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTRESET_TIMEEV3_TIMBCMP4 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTRESET_TIMEEV4_TIMCCMP1 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTRESET_TIMEEV5_TIMDCMP2 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTRESET_TIMEEV6_TIMDCMP1 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTRESET_TIMEEV7_TIMDCMP2 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTRESET_TIMEEV8_TIMFCMP3 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTRESET_TIMEEV9_TIMFCMP4 HRTIM_OUTPUTSET_TIMEV_9
S#define HRTIM_OUTPUTRESET_TIMFEV1_TIMACMP3 HRTIM_OUTPUTSET_TIMEV_1
S#define HRTIM_OUTPUTRESET_TIMFEV2_TIMBCMP1 HRTIM_OUTPUTSET_TIMEV_2
S#define HRTIM_OUTPUTRESET_TIMFEV3_TIMBCMP4 HRTIM_OUTPUTSET_TIMEV_3
S#define HRTIM_OUTPUTRESET_TIMFEV4_TIMCCMP1 HRTIM_OUTPUTSET_TIMEV_4
S#define HRTIM_OUTPUTRESET_TIMFEV5_TIMCCMP4 HRTIM_OUTPUTSET_TIMEV_5
S#define HRTIM_OUTPUTRESET_TIMFEV6_TIMDCMP3 HRTIM_OUTPUTSET_TIMEV_6
S#define HRTIM_OUTPUTRESET_TIMFEV7_TIMDCMP4 HRTIM_OUTPUTSET_TIMEV_7
S#define HRTIM_OUTPUTRESET_TIMFEV8_TIMECMP2 HRTIM_OUTPUTSET_TIMEV_8
S#define HRTIM_OUTPUTRESET_TIMFEV9_TIMECMP3 HRTIM_OUTPUTSET_TIMEV_9
N#endif /* STM32H7 */
N
N#if defined(STM32F3)
X#if 0L
S/** @brief Constants defining available sources associated to external events.
S  */
S#define HRTIM_EVENTSRC_1              (0x00000000U)
S#define HRTIM_EVENTSRC_2              (HRTIM_EECR1_EE1SRC_0)
S#define HRTIM_EVENTSRC_3              (HRTIM_EECR1_EE1SRC_1)
S#define HRTIM_EVENTSRC_4              (HRTIM_EECR1_EE1SRC_1 | HRTIM_EECR1_EE1SRC_0)
S
S/** @brief Constants defining the DLL calibration periods (in micro seconds)
S  */
S#define HRTIM_CALIBRATIONRATE_7300             0x00000000U
S#define HRTIM_CALIBRATIONRATE_910              (HRTIM_DLLCR_CALRTE_0)
S#define HRTIM_CALIBRATIONRATE_114              (HRTIM_DLLCR_CALRTE_1)
S#define HRTIM_CALIBRATIONRATE_14               (HRTIM_DLLCR_CALRTE_1 | HRTIM_DLLCR_CALRTE_0)
S
N#endif /* STM32F3 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2C_Aliased_Defines HAL I2C Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define I2C_DUALADDRESS_DISABLED                I2C_DUALADDRESS_DISABLE
N#define I2C_DUALADDRESS_ENABLED                 I2C_DUALADDRESS_ENABLE
N#define I2C_GENERALCALL_DISABLED                I2C_GENERALCALL_DISABLE
N#define I2C_GENERALCALL_ENABLED                 I2C_GENERALCALL_ENABLE
N#define I2C_NOSTRETCH_DISABLED                  I2C_NOSTRETCH_DISABLE
N#define I2C_NOSTRETCH_ENABLED                   I2C_NOSTRETCH_ENABLE
N#define I2C_ANALOGFILTER_ENABLED                I2C_ANALOGFILTER_ENABLE
N#define I2C_ANALOGFILTER_DISABLED               I2C_ANALOGFILTER_DISABLE
N#if defined(STM32F0) || defined(STM32F1) || defined(STM32F3) || defined(STM32G0) || defined(STM32L4) || defined(STM32L1) || defined(STM32F7)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L
S#define HAL_I2C_STATE_MEM_BUSY_TX               HAL_I2C_STATE_BUSY_TX
S#define HAL_I2C_STATE_MEM_BUSY_RX               HAL_I2C_STATE_BUSY_RX
S#define HAL_I2C_STATE_MASTER_BUSY_TX            HAL_I2C_STATE_BUSY_TX
S#define HAL_I2C_STATE_MASTER_BUSY_RX            HAL_I2C_STATE_BUSY_RX
S#define HAL_I2C_STATE_SLAVE_BUSY_TX             HAL_I2C_STATE_BUSY_TX
S#define HAL_I2C_STATE_SLAVE_BUSY_RX             HAL_I2C_STATE_BUSY_RX
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_IRDA_Aliased_Defines HAL IRDA Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define IRDA_ONE_BIT_SAMPLE_DISABLED            IRDA_ONE_BIT_SAMPLE_DISABLE
N#define IRDA_ONE_BIT_SAMPLE_ENABLED             IRDA_ONE_BIT_SAMPLE_ENABLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_IWDG_Aliased_Defines HAL IWDG Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define KR_KEY_RELOAD                   IWDG_KEY_RELOAD
N#define KR_KEY_ENABLE                   IWDG_KEY_ENABLE
N#define KR_KEY_EWA                      IWDG_KEY_WRITE_ACCESS_ENABLE
N#define KR_KEY_DWA                      IWDG_KEY_WRITE_ACCESS_DISABLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_LPTIM_Aliased_Defines HAL LPTIM Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define LPTIM_CLOCKSAMPLETIME_DIRECTTRANSISTION LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION
N#define LPTIM_CLOCKSAMPLETIME_2TRANSISTIONS     LPTIM_CLOCKSAMPLETIME_2TRANSITIONS
N#define LPTIM_CLOCKSAMPLETIME_4TRANSISTIONS     LPTIM_CLOCKSAMPLETIME_4TRANSITIONS
N#define LPTIM_CLOCKSAMPLETIME_8TRANSISTIONS     LPTIM_CLOCKSAMPLETIME_8TRANSITIONS
N
N#define LPTIM_CLOCKPOLARITY_RISINGEDGE          LPTIM_CLOCKPOLARITY_RISING
N#define LPTIM_CLOCKPOLARITY_FALLINGEDGE         LPTIM_CLOCKPOLARITY_FALLING
N#define LPTIM_CLOCKPOLARITY_BOTHEDGES           LPTIM_CLOCKPOLARITY_RISING_FALLING
N
N#define LPTIM_TRIGSAMPLETIME_DIRECTTRANSISTION  LPTIM_TRIGSAMPLETIME_DIRECTTRANSITION
N#define LPTIM_TRIGSAMPLETIME_2TRANSISTIONS      LPTIM_TRIGSAMPLETIME_2TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_4TRANSISTIONS      LPTIM_TRIGSAMPLETIME_4TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_8TRANSISTIONS      LPTIM_TRIGSAMPLETIME_8TRANSITIONS
N
N/* The following 3 definition have also been present in a temporary version of lptim.h */
N/* They need to be renamed also to the right name, just in case */
N#define LPTIM_TRIGSAMPLETIME_2TRANSITION        LPTIM_TRIGSAMPLETIME_2TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_4TRANSITION        LPTIM_TRIGSAMPLETIME_4TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_8TRANSITION        LPTIM_TRIGSAMPLETIME_8TRANSITIONS
N
N#if defined(STM32U5)
X#if 0L
S#define LPTIM_ISR_CC1        LPTIM_ISR_CC1IF
S#define LPTIM_ISR_CC2        LPTIM_ISR_CC2IF
N#endif /* STM32U5 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_NAND_Aliased_Defines HAL NAND Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define HAL_NAND_Read_Page              HAL_NAND_Read_Page_8b
N#define HAL_NAND_Write_Page             HAL_NAND_Write_Page_8b
N#define HAL_NAND_Read_SpareArea         HAL_NAND_Read_SpareArea_8b
N#define HAL_NAND_Write_SpareArea        HAL_NAND_Write_SpareArea_8b
N
N#define NAND_AddressTypedef             NAND_AddressTypeDef
N
N#define __ARRAY_ADDRESS                 ARRAY_ADDRESS
N#define __ADDR_1st_CYCLE                ADDR_1ST_CYCLE
N#define __ADDR_2nd_CYCLE                ADDR_2ND_CYCLE
N#define __ADDR_3rd_CYCLE                ADDR_3RD_CYCLE
N#define __ADDR_4th_CYCLE                ADDR_4TH_CYCLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_NOR_Aliased_Defines HAL NOR Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define NOR_StatusTypedef              HAL_NOR_StatusTypeDef
N#define NOR_SUCCESS                    HAL_NOR_STATUS_SUCCESS
N#define NOR_ONGOING                    HAL_NOR_STATUS_ONGOING
N#define NOR_ERROR                      HAL_NOR_STATUS_ERROR
N#define NOR_TIMEOUT                    HAL_NOR_STATUS_TIMEOUT
N
N#define __NOR_WRITE                    NOR_WRITE
N#define __NOR_ADDR_SHIFT               NOR_ADDR_SHIFT
N/**
N  * @}
N  */
N
N/** @defgroup HAL_OPAMP_Aliased_Defines HAL OPAMP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define OPAMP_NONINVERTINGINPUT_VP0           OPAMP_NONINVERTINGINPUT_IO0
N#define OPAMP_NONINVERTINGINPUT_VP1           OPAMP_NONINVERTINGINPUT_IO1
N#define OPAMP_NONINVERTINGINPUT_VP2           OPAMP_NONINVERTINGINPUT_IO2
N#define OPAMP_NONINVERTINGINPUT_VP3           OPAMP_NONINVERTINGINPUT_IO3
N
N#define OPAMP_SEC_NONINVERTINGINPUT_VP0       OPAMP_SEC_NONINVERTINGINPUT_IO0
N#define OPAMP_SEC_NONINVERTINGINPUT_VP1       OPAMP_SEC_NONINVERTINGINPUT_IO1
N#define OPAMP_SEC_NONINVERTINGINPUT_VP2       OPAMP_SEC_NONINVERTINGINPUT_IO2
N#define OPAMP_SEC_NONINVERTINGINPUT_VP3       OPAMP_SEC_NONINVERTINGINPUT_IO3
N
N#define OPAMP_INVERTINGINPUT_VM0              OPAMP_INVERTINGINPUT_IO0
N#define OPAMP_INVERTINGINPUT_VM1              OPAMP_INVERTINGINPUT_IO1
N
N#define IOPAMP_INVERTINGINPUT_VM0             OPAMP_INVERTINGINPUT_IO0
N#define IOPAMP_INVERTINGINPUT_VM1             OPAMP_INVERTINGINPUT_IO1
N
N#define OPAMP_SEC_INVERTINGINPUT_VM0          OPAMP_SEC_INVERTINGINPUT_IO0
N#define OPAMP_SEC_INVERTINGINPUT_VM1          OPAMP_SEC_INVERTINGINPUT_IO1
N
N#define OPAMP_INVERTINGINPUT_VINM             OPAMP_SEC_INVERTINGINPUT_IO1
N
N#define OPAMP_PGACONNECT_NO                   OPAMP_PGA_CONNECT_INVERTINGINPUT_NO
N#define OPAMP_PGACONNECT_VM0                  OPAMP_PGA_CONNECT_INVERTINGINPUT_IO0
N#define OPAMP_PGACONNECT_VM1                  OPAMP_PGA_CONNECT_INVERTINGINPUT_IO1
N
N#if defined(STM32L1) || defined(STM32L4) || defined(STM32L5) || defined(STM32H7) || defined(STM32G4)
X#if 0L || 0L || 0L || 0L || 0L
S#define HAL_OPAMP_MSP_INIT_CB_ID       HAL_OPAMP_MSPINIT_CB_ID
S#define HAL_OPAMP_MSP_DEINIT_CB_ID     HAL_OPAMP_MSPDEINIT_CB_ID
N#endif
N
N#if defined(STM32L4) || defined(STM32L5)
X#if 0L || 0L
S#define OPAMP_POWERMODE_NORMAL                OPAMP_POWERMODE_NORMALPOWER
S#elif defined(STM32G4)
X#elif 0L
S#define OPAMP_POWERMODE_NORMAL                OPAMP_POWERMODE_NORMALSPEED
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2S_Aliased_Defines HAL I2S Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define I2S_STANDARD_PHILLIPS      I2S_STANDARD_PHILIPS
N
N#if defined(STM32H7)
X#if 0L
S#define I2S_IT_TXE               I2S_IT_TXP
S#define I2S_IT_RXNE              I2S_IT_RXP
S
S#define I2S_FLAG_TXE             I2S_FLAG_TXP
S#define I2S_FLAG_RXNE            I2S_FLAG_RXP
N#endif
N
N#if defined(STM32F7)
X#if 0L
S#define I2S_CLOCK_SYSCLK           I2S_CLOCK_PLL
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_PCCARD_Aliased_Defines HAL PCCARD Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N/* Compact Flash-ATA registers description */
N#define CF_DATA                       ATA_DATA
N#define CF_SECTOR_COUNT               ATA_SECTOR_COUNT
N#define CF_SECTOR_NUMBER              ATA_SECTOR_NUMBER
N#define CF_CYLINDER_LOW               ATA_CYLINDER_LOW
N#define CF_CYLINDER_HIGH              ATA_CYLINDER_HIGH
N#define CF_CARD_HEAD                  ATA_CARD_HEAD
N#define CF_STATUS_CMD                 ATA_STATUS_CMD
N#define CF_STATUS_CMD_ALTERNATE       ATA_STATUS_CMD_ALTERNATE
N#define CF_COMMON_DATA_AREA           ATA_COMMON_DATA_AREA
N
N/* Compact Flash-ATA commands */
N#define CF_READ_SECTOR_CMD            ATA_READ_SECTOR_CMD
N#define CF_WRITE_SECTOR_CMD           ATA_WRITE_SECTOR_CMD
N#define CF_ERASE_SECTOR_CMD           ATA_ERASE_SECTOR_CMD
N#define CF_IDENTIFY_CMD               ATA_IDENTIFY_CMD
N
N#define PCCARD_StatusTypedef          HAL_PCCARD_StatusTypeDef
N#define PCCARD_SUCCESS                HAL_PCCARD_STATUS_SUCCESS
N#define PCCARD_ONGOING                HAL_PCCARD_STATUS_ONGOING
N#define PCCARD_ERROR                  HAL_PCCARD_STATUS_ERROR
N#define PCCARD_TIMEOUT                HAL_PCCARD_STATUS_TIMEOUT
N/**
N  * @}
N  */
N
N/** @defgroup HAL_RTC_Aliased_Defines HAL RTC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define FORMAT_BIN                  RTC_FORMAT_BIN
N#define FORMAT_BCD                  RTC_FORMAT_BCD
N
N#define RTC_ALARMSUBSECONDMASK_None     RTC_ALARMSUBSECONDMASK_NONE
N#define RTC_TAMPERERASEBACKUP_DISABLED  RTC_TAMPER_ERASE_BACKUP_DISABLE
N#define RTC_TAMPERMASK_FLAG_DISABLED    RTC_TAMPERMASK_FLAG_DISABLE
N#define RTC_TAMPERMASK_FLAG_ENABLED     RTC_TAMPERMASK_FLAG_ENABLE
N
N#define RTC_MASKTAMPERFLAG_DISABLED     RTC_TAMPERMASK_FLAG_DISABLE
N#define RTC_MASKTAMPERFLAG_ENABLED      RTC_TAMPERMASK_FLAG_ENABLE
N#define RTC_TAMPERERASEBACKUP_ENABLED   RTC_TAMPER_ERASE_BACKUP_ENABLE
N#define RTC_TAMPER1_2_INTERRUPT         RTC_ALL_TAMPER_INTERRUPT
N#define RTC_TAMPER1_2_3_INTERRUPT       RTC_ALL_TAMPER_INTERRUPT
N
N#define RTC_TIMESTAMPPIN_PC13  RTC_TIMESTAMPPIN_DEFAULT
N#define RTC_TIMESTAMPPIN_PA0 RTC_TIMESTAMPPIN_POS1
N#define RTC_TIMESTAMPPIN_PI8 RTC_TIMESTAMPPIN_POS1
N#define RTC_TIMESTAMPPIN_PC1   RTC_TIMESTAMPPIN_POS2
N
N#define RTC_OUTPUT_REMAP_PC13  RTC_OUTPUT_REMAP_NONE
N#define RTC_OUTPUT_REMAP_PB14  RTC_OUTPUT_REMAP_POS1
N#define RTC_OUTPUT_REMAP_PB2   RTC_OUTPUT_REMAP_POS1
N
N#define RTC_TAMPERPIN_PC13 RTC_TAMPERPIN_DEFAULT
N#define RTC_TAMPERPIN_PA0  RTC_TAMPERPIN_POS1
N#define RTC_TAMPERPIN_PI8  RTC_TAMPERPIN_POS1
N
N#if defined(STM32H7)
X#if 0L
S#define RTC_TAMPCR_TAMPXE          RTC_TAMPER_X
S#define RTC_TAMPCR_TAMPXIE         RTC_TAMPER_X_INTERRUPT
S
S#define RTC_TAMPER1_INTERRUPT      RTC_IT_TAMP1
S#define RTC_TAMPER2_INTERRUPT      RTC_IT_TAMP2
S#define RTC_TAMPER3_INTERRUPT      RTC_IT_TAMP3
S#define RTC_ALL_TAMPER_INTERRUPT   RTC_IT_TAMPALL
N#endif /* STM32H7 */
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_SMARTCARD_Aliased_Defines HAL SMARTCARD Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define SMARTCARD_NACK_ENABLED                  SMARTCARD_NACK_ENABLE
N#define SMARTCARD_NACK_DISABLED                 SMARTCARD_NACK_DISABLE
N
N#define SMARTCARD_ONEBIT_SAMPLING_DISABLED      SMARTCARD_ONE_BIT_SAMPLE_DISABLE
N#define SMARTCARD_ONEBIT_SAMPLING_ENABLED       SMARTCARD_ONE_BIT_SAMPLE_ENABLE
N#define SMARTCARD_ONEBIT_SAMPLING_DISABLE       SMARTCARD_ONE_BIT_SAMPLE_DISABLE
N#define SMARTCARD_ONEBIT_SAMPLING_ENABLE        SMARTCARD_ONE_BIT_SAMPLE_ENABLE
N
N#define SMARTCARD_TIMEOUT_DISABLED              SMARTCARD_TIMEOUT_DISABLE
N#define SMARTCARD_TIMEOUT_ENABLED               SMARTCARD_TIMEOUT_ENABLE
N
N#define SMARTCARD_LASTBIT_DISABLED              SMARTCARD_LASTBIT_DISABLE
N#define SMARTCARD_LASTBIT_ENABLED               SMARTCARD_LASTBIT_ENABLE
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_SMBUS_Aliased_Defines HAL SMBUS Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define SMBUS_DUALADDRESS_DISABLED      SMBUS_DUALADDRESS_DISABLE
N#define SMBUS_DUALADDRESS_ENABLED       SMBUS_DUALADDRESS_ENABLE
N#define SMBUS_GENERALCALL_DISABLED      SMBUS_GENERALCALL_DISABLE
N#define SMBUS_GENERALCALL_ENABLED       SMBUS_GENERALCALL_ENABLE
N#define SMBUS_NOSTRETCH_DISABLED        SMBUS_NOSTRETCH_DISABLE
N#define SMBUS_NOSTRETCH_ENABLED         SMBUS_NOSTRETCH_ENABLE
N#define SMBUS_ANALOGFILTER_ENABLED      SMBUS_ANALOGFILTER_ENABLE
N#define SMBUS_ANALOGFILTER_DISABLED     SMBUS_ANALOGFILTER_DISABLE
N#define SMBUS_PEC_DISABLED              SMBUS_PEC_DISABLE
N#define SMBUS_PEC_ENABLED               SMBUS_PEC_ENABLE
N#define HAL_SMBUS_STATE_SLAVE_LISTEN    HAL_SMBUS_STATE_LISTEN
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPI_Aliased_Defines HAL SPI Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define SPI_TIMODE_DISABLED             SPI_TIMODE_DISABLE
N#define SPI_TIMODE_ENABLED              SPI_TIMODE_ENABLE
N
N#define SPI_CRCCALCULATION_DISABLED     SPI_CRCCALCULATION_DISABLE
N#define SPI_CRCCALCULATION_ENABLED      SPI_CRCCALCULATION_ENABLE
N
N#define SPI_NSS_PULSE_DISABLED          SPI_NSS_PULSE_DISABLE
N#define SPI_NSS_PULSE_ENABLED           SPI_NSS_PULSE_ENABLE
N
N#if defined(STM32H7)
X#if 0L
S
S#define SPI_FLAG_TXE                    SPI_FLAG_TXP
S#define SPI_FLAG_RXNE                   SPI_FLAG_RXP
S
S#define SPI_IT_TXE                      SPI_IT_TXP
S#define SPI_IT_RXNE                     SPI_IT_RXP
S
S#define SPI_FRLVL_EMPTY                 SPI_RX_FIFO_0PACKET
S#define SPI_FRLVL_QUARTER_FULL          SPI_RX_FIFO_1PACKET
S#define SPI_FRLVL_HALF_FULL             SPI_RX_FIFO_2PACKET
S#define SPI_FRLVL_FULL                  SPI_RX_FIFO_3PACKET
S
N#endif /* STM32H7 */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TIM_Aliased_Defines HAL TIM Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define CCER_CCxE_MASK                   TIM_CCER_CCxE_MASK
N#define CCER_CCxNE_MASK                  TIM_CCER_CCxNE_MASK
N
N#define TIM_DMABase_CR1                  TIM_DMABASE_CR1
N#define TIM_DMABase_CR2                  TIM_DMABASE_CR2
N#define TIM_DMABase_SMCR                 TIM_DMABASE_SMCR
N#define TIM_DMABase_DIER                 TIM_DMABASE_DIER
N#define TIM_DMABase_SR                   TIM_DMABASE_SR
N#define TIM_DMABase_EGR                  TIM_DMABASE_EGR
N#define TIM_DMABase_CCMR1                TIM_DMABASE_CCMR1
N#define TIM_DMABase_CCMR2                TIM_DMABASE_CCMR2
N#define TIM_DMABase_CCER                 TIM_DMABASE_CCER
N#define TIM_DMABase_CNT                  TIM_DMABASE_CNT
N#define TIM_DMABase_PSC                  TIM_DMABASE_PSC
N#define TIM_DMABase_ARR                  TIM_DMABASE_ARR
N#define TIM_DMABase_RCR                  TIM_DMABASE_RCR
N#define TIM_DMABase_CCR1                 TIM_DMABASE_CCR1
N#define TIM_DMABase_CCR2                 TIM_DMABASE_CCR2
N#define TIM_DMABase_CCR3                 TIM_DMABASE_CCR3
N#define TIM_DMABase_CCR4                 TIM_DMABASE_CCR4
N#define TIM_DMABase_BDTR                 TIM_DMABASE_BDTR
N#define TIM_DMABase_DCR                  TIM_DMABASE_DCR
N#define TIM_DMABase_DMAR                 TIM_DMABASE_DMAR
N#define TIM_DMABase_OR1                  TIM_DMABASE_OR1
N#define TIM_DMABase_CCMR3                TIM_DMABASE_CCMR3
N#define TIM_DMABase_CCR5                 TIM_DMABASE_CCR5
N#define TIM_DMABase_CCR6                 TIM_DMABASE_CCR6
N#define TIM_DMABase_OR2                  TIM_DMABASE_OR2
N#define TIM_DMABase_OR3                  TIM_DMABASE_OR3
N#define TIM_DMABase_OR                   TIM_DMABASE_OR
N
N#define TIM_EventSource_Update           TIM_EVENTSOURCE_UPDATE
N#define TIM_EventSource_CC1              TIM_EVENTSOURCE_CC1
N#define TIM_EventSource_CC2              TIM_EVENTSOURCE_CC2
N#define TIM_EventSource_CC3              TIM_EVENTSOURCE_CC3
N#define TIM_EventSource_CC4              TIM_EVENTSOURCE_CC4
N#define TIM_EventSource_COM              TIM_EVENTSOURCE_COM
N#define TIM_EventSource_Trigger          TIM_EVENTSOURCE_TRIGGER
N#define TIM_EventSource_Break            TIM_EVENTSOURCE_BREAK
N#define TIM_EventSource_Break2           TIM_EVENTSOURCE_BREAK2
N
N#define TIM_DMABurstLength_1Transfer     TIM_DMABURSTLENGTH_1TRANSFER
N#define TIM_DMABurstLength_2Transfers    TIM_DMABURSTLENGTH_2TRANSFERS
N#define TIM_DMABurstLength_3Transfers    TIM_DMABURSTLENGTH_3TRANSFERS
N#define TIM_DMABurstLength_4Transfers    TIM_DMABURSTLENGTH_4TRANSFERS
N#define TIM_DMABurstLength_5Transfers    TIM_DMABURSTLENGTH_5TRANSFERS
N#define TIM_DMABurstLength_6Transfers    TIM_DMABURSTLENGTH_6TRANSFERS
N#define TIM_DMABurstLength_7Transfers    TIM_DMABURSTLENGTH_7TRANSFERS
N#define TIM_DMABurstLength_8Transfers    TIM_DMABURSTLENGTH_8TRANSFERS
N#define TIM_DMABurstLength_9Transfers    TIM_DMABURSTLENGTH_9TRANSFERS
N#define TIM_DMABurstLength_10Transfers   TIM_DMABURSTLENGTH_10TRANSFERS
N#define TIM_DMABurstLength_11Transfers   TIM_DMABURSTLENGTH_11TRANSFERS
N#define TIM_DMABurstLength_12Transfers   TIM_DMABURSTLENGTH_12TRANSFERS
N#define TIM_DMABurstLength_13Transfers   TIM_DMABURSTLENGTH_13TRANSFERS
N#define TIM_DMABurstLength_14Transfers   TIM_DMABURSTLENGTH_14TRANSFERS
N#define TIM_DMABurstLength_15Transfers   TIM_DMABURSTLENGTH_15TRANSFERS
N#define TIM_DMABurstLength_16Transfers   TIM_DMABURSTLENGTH_16TRANSFERS
N#define TIM_DMABurstLength_17Transfers   TIM_DMABURSTLENGTH_17TRANSFERS
N#define TIM_DMABurstLength_18Transfers   TIM_DMABURSTLENGTH_18TRANSFERS
N
N#if defined(STM32L0)
X#if 0L
S#define TIM22_TI1_GPIO1   TIM22_TI1_GPIO
S#define TIM22_TI1_GPIO2   TIM22_TI1_GPIO
N#endif
N
N#if defined(STM32F3)
X#if 0L
S#define IS_TIM_HALL_INTERFACE_INSTANCE   IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE
N#endif
N
N#if defined(STM32H7)
X#if 0L
S#define TIM_TIM1_ETR_COMP1_OUT        TIM_TIM1_ETR_COMP1
S#define TIM_TIM1_ETR_COMP2_OUT        TIM_TIM1_ETR_COMP2
S#define TIM_TIM8_ETR_COMP1_OUT        TIM_TIM8_ETR_COMP1
S#define TIM_TIM8_ETR_COMP2_OUT        TIM_TIM8_ETR_COMP2
S#define TIM_TIM2_ETR_COMP1_OUT        TIM_TIM2_ETR_COMP1
S#define TIM_TIM2_ETR_COMP2_OUT        TIM_TIM2_ETR_COMP2
S#define TIM_TIM3_ETR_COMP1_OUT        TIM_TIM3_ETR_COMP1
S#define TIM_TIM1_TI1_COMP1_OUT        TIM_TIM1_TI1_COMP1
S#define TIM_TIM8_TI1_COMP2_OUT        TIM_TIM8_TI1_COMP2
S#define TIM_TIM2_TI4_COMP1_OUT        TIM_TIM2_TI4_COMP1
S#define TIM_TIM2_TI4_COMP2_OUT        TIM_TIM2_TI4_COMP2
S#define TIM_TIM2_TI4_COMP1COMP2_OUT   TIM_TIM2_TI4_COMP1_COMP2
S#define TIM_TIM3_TI1_COMP1_OUT        TIM_TIM3_TI1_COMP1
S#define TIM_TIM3_TI1_COMP2_OUT        TIM_TIM3_TI1_COMP2
S#define TIM_TIM3_TI1_COMP1COMP2_OUT   TIM_TIM3_TI1_COMP1_COMP2
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TSC_Aliased_Defines HAL TSC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define TSC_SYNC_POL_FALL        TSC_SYNC_POLARITY_FALLING
N#define TSC_SYNC_POL_RISE_HIGH   TSC_SYNC_POLARITY_RISING
N/**
N  * @}
N  */
N
N/** @defgroup HAL_UART_Aliased_Defines HAL UART Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define UART_ONEBIT_SAMPLING_DISABLED   UART_ONE_BIT_SAMPLE_DISABLE
N#define UART_ONEBIT_SAMPLING_ENABLED    UART_ONE_BIT_SAMPLE_ENABLE
N#define UART_ONE_BIT_SAMPLE_DISABLED    UART_ONE_BIT_SAMPLE_DISABLE
N#define UART_ONE_BIT_SAMPLE_ENABLED     UART_ONE_BIT_SAMPLE_ENABLE
N
N#define __HAL_UART_ONEBIT_ENABLE        __HAL_UART_ONE_BIT_SAMPLE_ENABLE
N#define __HAL_UART_ONEBIT_DISABLE       __HAL_UART_ONE_BIT_SAMPLE_DISABLE
N
N#define __DIV_SAMPLING16                UART_DIV_SAMPLING16
N#define __DIVMANT_SAMPLING16            UART_DIVMANT_SAMPLING16
N#define __DIVFRAQ_SAMPLING16            UART_DIVFRAQ_SAMPLING16
N#define __UART_BRR_SAMPLING16           UART_BRR_SAMPLING16
N
N#define __DIV_SAMPLING8                 UART_DIV_SAMPLING8
N#define __DIVMANT_SAMPLING8             UART_DIVMANT_SAMPLING8
N#define __DIVFRAQ_SAMPLING8             UART_DIVFRAQ_SAMPLING8
N#define __UART_BRR_SAMPLING8            UART_BRR_SAMPLING8
N
N#define __DIV_LPUART                    UART_DIV_LPUART
N
N#define UART_WAKEUPMETHODE_IDLELINE     UART_WAKEUPMETHOD_IDLELINE
N#define UART_WAKEUPMETHODE_ADDRESSMARK  UART_WAKEUPMETHOD_ADDRESSMARK
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_USART_Aliased_Defines HAL USART Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define USART_CLOCK_DISABLED            USART_CLOCK_DISABLE
N#define USART_CLOCK_ENABLED             USART_CLOCK_ENABLE
N
N#define USARTNACK_ENABLED               USART_NACK_ENABLE
N#define USARTNACK_DISABLED              USART_NACK_DISABLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_WWDG_Aliased_Defines HAL WWDG Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define CFR_BASE                    WWDG_CFR_BASE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CAN_Aliased_Defines HAL CAN Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define CAN_FilterFIFO0             CAN_FILTER_FIFO0
N#define CAN_FilterFIFO1             CAN_FILTER_FIFO1
N#define CAN_IT_RQCP0                CAN_IT_TME
N#define CAN_IT_RQCP1                CAN_IT_TME
N#define CAN_IT_RQCP2                CAN_IT_TME
N#define INAK_TIMEOUT                CAN_TIMEOUT_VALUE
N#define SLAK_TIMEOUT                CAN_TIMEOUT_VALUE
N#define CAN_TXSTATUS_FAILED         ((uint8_t)0x00U)
N#define CAN_TXSTATUS_OK             ((uint8_t)0x01U)
N#define CAN_TXSTATUS_PENDING        ((uint8_t)0x02U)
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_ETH_Aliased_Defines HAL ETH Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define VLAN_TAG                ETH_VLAN_TAG
N#define MIN_ETH_PAYLOAD         ETH_MIN_ETH_PAYLOAD
N#define MAX_ETH_PAYLOAD         ETH_MAX_ETH_PAYLOAD
N#define JUMBO_FRAME_PAYLOAD     ETH_JUMBO_FRAME_PAYLOAD
N#define MACMIIAR_CR_MASK        ETH_MACMIIAR_CR_MASK
N#define MACCR_CLEAR_MASK        ETH_MACCR_CLEAR_MASK
N#define MACFCR_CLEAR_MASK       ETH_MACFCR_CLEAR_MASK
N#define DMAOMR_CLEAR_MASK       ETH_DMAOMR_CLEAR_MASK
N
N#define ETH_MMCCR              0x00000100U
N#define ETH_MMCRIR             0x00000104U
N#define ETH_MMCTIR             0x00000108U
N#define ETH_MMCRIMR            0x0000010CU
N#define ETH_MMCTIMR            0x00000110U
N#define ETH_MMCTGFSCCR         0x0000014CU
N#define ETH_MMCTGFMSCCR        0x00000150U
N#define ETH_MMCTGFCR           0x00000168U
N#define ETH_MMCRFCECR          0x00000194U
N#define ETH_MMCRFAECR          0x00000198U
N#define ETH_MMCRGUFCR          0x000001C4U
N
N#define ETH_MAC_TXFIFO_FULL                             0x02000000U  /* Tx FIFO full */
N#define ETH_MAC_TXFIFONOT_EMPTY                         0x01000000U  /* Tx FIFO not empty */
N#define ETH_MAC_TXFIFO_WRITE_ACTIVE                     0x00400000U  /* Tx FIFO write active */
N#define ETH_MAC_TXFIFO_IDLE                             0x00000000U  /* Tx FIFO read status: Idle */
N#define ETH_MAC_TXFIFO_READ                             0x00100000U  /* Tx FIFO read status: Read (transferring data to the MAC transmitter) */
N#define ETH_MAC_TXFIFO_WAITING                          0x00200000U  /* Tx FIFO read status: Waiting for TxStatus from MAC transmitter */
N#define ETH_MAC_TXFIFO_WRITING                          0x00300000U  /* Tx FIFO read status: Writing the received TxStatus or flushing the TxFIFO */
N#define ETH_MAC_TRANSMISSION_PAUSE                      0x00080000U  /* MAC transmitter in pause */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_IDLE            0x00000000U  /* MAC transmit frame controller: Idle */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_WAITING         0x00020000U  /* MAC transmit frame controller: Waiting for Status of previous frame or IFG/backoff period to be over */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_GENRATING_PCF   0x00040000U  /* MAC transmit frame controller: Generating and transmitting a Pause control frame (in full duplex mode) */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_TRANSFERRING    0x00060000U  /* MAC transmit frame controller: Transferring input frame for transmission */
N#define ETH_MAC_MII_TRANSMIT_ACTIVE           0x00010000U  /* MAC MII transmit engine active */
N#define ETH_MAC_RXFIFO_EMPTY                  0x00000000U  /* Rx FIFO fill level: empty */
N#define ETH_MAC_RXFIFO_BELOW_THRESHOLD        0x00000100U  /* Rx FIFO fill level: fill-level below flow-control de-activate threshold */
N#define ETH_MAC_RXFIFO_ABOVE_THRESHOLD        0x00000200U  /* Rx FIFO fill level: fill-level above flow-control activate threshold */
N#define ETH_MAC_RXFIFO_FULL                   0x00000300U  /* Rx FIFO fill level: full */
N#if defined(STM32F1)
X#if 0L
N#else
N#define ETH_MAC_READCONTROLLER_IDLE           0x00000000U  /* Rx FIFO read controller IDLE state */
N#define ETH_MAC_READCONTROLLER_READING_DATA   0x00000020U  /* Rx FIFO read controller Reading frame data */
N#define ETH_MAC_READCONTROLLER_READING_STATUS 0x00000040U  /* Rx FIFO read controller Reading frame status (or time-stamp) */
N#endif
N#define ETH_MAC_READCONTROLLER_FLUSHING       0x00000060U  /* Rx FIFO read controller Flushing the frame data and status */
N#define ETH_MAC_RXFIFO_WRITE_ACTIVE           0x00000010U  /* Rx FIFO write controller active */
N#define ETH_MAC_SMALL_FIFO_NOTACTIVE          0x00000000U  /* MAC small FIFO read / write controllers not active */
N#define ETH_MAC_SMALL_FIFO_READ_ACTIVE        0x00000002U  /* MAC small FIFO read controller active */
N#define ETH_MAC_SMALL_FIFO_WRITE_ACTIVE       0x00000004U  /* MAC small FIFO write controller active */
N#define ETH_MAC_SMALL_FIFO_RW_ACTIVE          0x00000006U  /* MAC small FIFO read / write controllers active */
N#define ETH_MAC_MII_RECEIVE_PROTOCOL_ACTIVE   0x00000001U  /* MAC MII receive protocol engine active */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DCMI_Aliased_Defines HAL DCMI Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define HAL_DCMI_ERROR_OVF      HAL_DCMI_ERROR_OVR
N#define DCMI_IT_OVF             DCMI_IT_OVR
N#define DCMI_FLAG_OVFRI         DCMI_FLAG_OVRRI
N#define DCMI_FLAG_OVFMI         DCMI_FLAG_OVRMI
N
N#define HAL_DCMI_ConfigCROP     HAL_DCMI_ConfigCrop
N#define HAL_DCMI_EnableCROP     HAL_DCMI_EnableCrop
N#define HAL_DCMI_DisableCROP    HAL_DCMI_DisableCrop
N
N/**
N  * @}
N  */
N
N#if defined(STM32L4) || defined(STM32F7) || defined(STM32F427xx) || defined(STM32F437xx) \
N  || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx) \
N  || defined(STM32H7)
X#if 0L || 0L || 0L || 0L   || 0L || 0L || 0L || 0L   || 0L
S/** @defgroup HAL_DMA2D_Aliased_Defines HAL DMA2D Aliased Defines maintained for legacy purpose
S  * @{
S  */
S#define DMA2D_ARGB8888          DMA2D_OUTPUT_ARGB8888
S#define DMA2D_RGB888            DMA2D_OUTPUT_RGB888
S#define DMA2D_RGB565            DMA2D_OUTPUT_RGB565
S#define DMA2D_ARGB1555          DMA2D_OUTPUT_ARGB1555
S#define DMA2D_ARGB4444          DMA2D_OUTPUT_ARGB4444
S
S#define CM_ARGB8888             DMA2D_INPUT_ARGB8888
S#define CM_RGB888               DMA2D_INPUT_RGB888
S#define CM_RGB565               DMA2D_INPUT_RGB565
S#define CM_ARGB1555             DMA2D_INPUT_ARGB1555
S#define CM_ARGB4444             DMA2D_INPUT_ARGB4444
S#define CM_L8                   DMA2D_INPUT_L8
S#define CM_AL44                 DMA2D_INPUT_AL44
S#define CM_AL88                 DMA2D_INPUT_AL88
S#define CM_L4                   DMA2D_INPUT_L4
S#define CM_A8                   DMA2D_INPUT_A8
S#define CM_A4                   DMA2D_INPUT_A4
S/**
S  * @}
S  */
N#endif  /* STM32L4 ||  STM32F7 ||  STM32F4 ||  STM32H7 */
N
N#if defined(STM32L4) || defined(STM32F7) || defined(STM32F427xx) || defined(STM32F437xx) \
N  || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx) \
N  || defined(STM32H7) || defined(STM32U5)
X#if 0L || 0L || 0L || 0L   || 0L || 0L || 0L || 0L   || 0L || 0L
S/** @defgroup DMA2D_Aliases DMA2D API Aliases
S  * @{
S  */
S#define HAL_DMA2D_DisableCLUT       HAL_DMA2D_CLUTLoading_Abort    /*!< Aliased to HAL_DMA2D_CLUTLoading_Abort
S                                                                        for compatibility with legacy code */
S/**
S  * @}
S  */
S
N#endif  /* STM32L4 ||  STM32F7 ||  STM32F4 ||  STM32H7 || STM32U5 */
N
N/** @defgroup HAL_PPP_Aliased_Defines HAL PPP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @defgroup HAL_CRYP_Aliased_Functions HAL CRYP Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_CRYP_ComputationCpltCallback     HAL_CRYPEx_ComputationCpltCallback
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DCACHE_Aliased_Functions HAL DCACHE Aliased Functions maintained for legacy purpose
N  * @{
N  */
N
N#if defined(STM32U5)
X#if 0L
S#define HAL_DCACHE_CleanInvalidateByAddr     HAL_DCACHE_CleanInvalidByAddr
S#define HAL_DCACHE_CleanInvalidateByAddr_IT  HAL_DCACHE_CleanInvalidByAddr_IT
N#endif /* STM32U5 */
N
N/**
N  * @}
N  */
N
N#if !defined(STM32F2)
X#if !0L
N/** @defgroup HASH_alias HASH API alias
N  * @{
N  */
N#define HAL_HASHEx_IRQHandler   HAL_HASH_IRQHandler  /*!< Redirection for compatibility with legacy code */
N/**
N  *
N  * @}
N  */
N#endif /* STM32F2 */
N/** @defgroup HAL_HASH_Aliased_Functions HAL HASH Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_HASH_STATETypeDef        HAL_HASH_StateTypeDef
N#define HAL_HASHPhaseTypeDef         HAL_HASH_PhaseTypeDef
N#define HAL_HMAC_MD5_Finish          HAL_HASH_MD5_Finish
N#define HAL_HMAC_SHA1_Finish         HAL_HASH_SHA1_Finish
N#define HAL_HMAC_SHA224_Finish       HAL_HASH_SHA224_Finish
N#define HAL_HMAC_SHA256_Finish       HAL_HASH_SHA256_Finish
N
N/*HASH Algorithm Selection*/
N
N#define HASH_AlgoSelection_SHA1      HASH_ALGOSELECTION_SHA1
N#define HASH_AlgoSelection_SHA224    HASH_ALGOSELECTION_SHA224
N#define HASH_AlgoSelection_SHA256    HASH_ALGOSELECTION_SHA256
N#define HASH_AlgoSelection_MD5       HASH_ALGOSELECTION_MD5
N
N#define HASH_AlgoMode_HASH         HASH_ALGOMODE_HASH
N#define HASH_AlgoMode_HMAC         HASH_ALGOMODE_HMAC
N
N#define HASH_HMACKeyType_ShortKey  HASH_HMAC_KEYTYPE_SHORTKEY
N#define HASH_HMACKeyType_LongKey   HASH_HMAC_KEYTYPE_LONGKEY
N
N#if defined(STM32L4) || defined(STM32L5) || defined(STM32F2) || defined(STM32F4) || defined(STM32F7) || defined(STM32H7)
X#if 0L || 0L || 0L || 1L || 0L || 0L
N
N#define HAL_HASH_MD5_Accumulate                HAL_HASH_MD5_Accmlt
N#define HAL_HASH_MD5_Accumulate_End            HAL_HASH_MD5_Accmlt_End
N#define HAL_HASH_MD5_Accumulate_IT             HAL_HASH_MD5_Accmlt_IT
N#define HAL_HASH_MD5_Accumulate_End_IT         HAL_HASH_MD5_Accmlt_End_IT
N
N#define HAL_HASH_SHA1_Accumulate               HAL_HASH_SHA1_Accmlt
N#define HAL_HASH_SHA1_Accumulate_End           HAL_HASH_SHA1_Accmlt_End
N#define HAL_HASH_SHA1_Accumulate_IT            HAL_HASH_SHA1_Accmlt_IT
N#define HAL_HASH_SHA1_Accumulate_End_IT        HAL_HASH_SHA1_Accmlt_End_IT
N
N#define HAL_HASHEx_SHA224_Accumulate           HAL_HASHEx_SHA224_Accmlt
N#define HAL_HASHEx_SHA224_Accumulate_End       HAL_HASHEx_SHA224_Accmlt_End
N#define HAL_HASHEx_SHA224_Accumulate_IT        HAL_HASHEx_SHA224_Accmlt_IT
N#define HAL_HASHEx_SHA224_Accumulate_End_IT    HAL_HASHEx_SHA224_Accmlt_End_IT
N
N#define HAL_HASHEx_SHA256_Accumulate           HAL_HASHEx_SHA256_Accmlt
N#define HAL_HASHEx_SHA256_Accumulate_End       HAL_HASHEx_SHA256_Accmlt_End
N#define HAL_HASHEx_SHA256_Accumulate_IT        HAL_HASHEx_SHA256_Accmlt_IT
N#define HAL_HASHEx_SHA256_Accumulate_End_IT    HAL_HASHEx_SHA256_Accmlt_End_IT
N
N#endif  /* STM32L4 || STM32L5 || STM32F2 || STM32F4 || STM32F7 || STM32H7 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_Aliased_Functions HAL Generic Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_EnableDBGSleepMode HAL_DBGMCU_EnableDBGSleepMode
N#define HAL_DisableDBGSleepMode HAL_DBGMCU_DisableDBGSleepMode
N#define HAL_EnableDBGStopMode HAL_DBGMCU_EnableDBGStopMode
N#define HAL_DisableDBGStopMode HAL_DBGMCU_DisableDBGStopMode
N#define HAL_EnableDBGStandbyMode HAL_DBGMCU_EnableDBGStandbyMode
N#define HAL_DisableDBGStandbyMode HAL_DBGMCU_DisableDBGStandbyMode
N#define HAL_DBG_LowPowerConfig(Periph, cmd) (((cmd\
N                                              )==ENABLE)? HAL_DBGMCU_DBG_EnableLowPowerConfig(Periph) : HAL_DBGMCU_DBG_DisableLowPowerConfig(Periph))
X#define HAL_DBG_LowPowerConfig(Periph, cmd) (((cmd                                              )==ENABLE)? HAL_DBGMCU_DBG_EnableLowPowerConfig(Periph) : HAL_DBGMCU_DBG_DisableLowPowerConfig(Periph))
N#define HAL_VREFINT_OutputSelect  HAL_SYSCFG_VREFINT_OutputSelect
N#define HAL_Lock_Cmd(cmd) (((cmd)==ENABLE) ? HAL_SYSCFG_Enable_Lock_VREFINT() : HAL_SYSCFG_Disable_Lock_VREFINT())
N#if defined(STM32L0)
X#if 0L
N#else
N#define HAL_VREFINT_Cmd(cmd) (((cmd)==ENABLE)? HAL_SYSCFG_EnableVREFINT() : HAL_SYSCFG_DisableVREFINT())
N#endif
N#define HAL_ADC_EnableBuffer_Cmd(cmd)  (((cmd)==ENABLE) ? HAL_ADCEx_EnableVREFINT() : HAL_ADCEx_DisableVREFINT())
N#define HAL_ADC_EnableBufferSensor_Cmd(cmd) (((cmd\
N                                              )==ENABLE) ?  HAL_ADCEx_EnableVREFINTTempSensor() : HAL_ADCEx_DisableVREFINTTempSensor())
X#define HAL_ADC_EnableBufferSensor_Cmd(cmd) (((cmd                                              )==ENABLE) ?  HAL_ADCEx_EnableVREFINTTempSensor() : HAL_ADCEx_DisableVREFINTTempSensor())
N#if defined(STM32H7A3xx) || defined(STM32H7B3xx) || defined(STM32H7B0xx) || defined(STM32H7A3xxQ) || defined(STM32H7B3xxQ) || defined(STM32H7B0xxQ)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define HAL_EnableSRDomainDBGStopMode      HAL_EnableDomain3DBGStopMode
S#define HAL_DisableSRDomainDBGStopMode     HAL_DisableDomain3DBGStopMode
S#define HAL_EnableSRDomainDBGStandbyMode   HAL_EnableDomain3DBGStandbyMode
S#define HAL_DisableSRDomainDBGStandbyMode  HAL_DisableDomain3DBGStandbyMode
N#endif /* STM32H7A3xx || STM32H7B3xx || STM32H7B0xx || STM32H7A3xxQ || STM32H7B3xxQ  || STM32H7B0xxQ */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_FLASH_Aliased_Functions HAL FLASH Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define FLASH_HalfPageProgram      HAL_FLASHEx_HalfPageProgram
N#define FLASH_EnableRunPowerDown   HAL_FLASHEx_EnableRunPowerDown
N#define FLASH_DisableRunPowerDown  HAL_FLASHEx_DisableRunPowerDown
N#define HAL_DATA_EEPROMEx_Unlock   HAL_FLASHEx_DATAEEPROM_Unlock
N#define HAL_DATA_EEPROMEx_Lock     HAL_FLASHEx_DATAEEPROM_Lock
N#define HAL_DATA_EEPROMEx_Erase    HAL_FLASHEx_DATAEEPROM_Erase
N#define HAL_DATA_EEPROMEx_Program  HAL_FLASHEx_DATAEEPROM_Program
N
N/**
N  * @}
N */
N
N/** @defgroup HAL_I2C_Aliased_Functions HAL I2C Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_I2CEx_AnalogFilter_Config         HAL_I2CEx_ConfigAnalogFilter
N#define HAL_I2CEx_DigitalFilter_Config        HAL_I2CEx_ConfigDigitalFilter
N#define HAL_FMPI2CEx_AnalogFilter_Config      HAL_FMPI2CEx_ConfigAnalogFilter
N#define HAL_FMPI2CEx_DigitalFilter_Config     HAL_FMPI2CEx_ConfigDigitalFilter
N
N#define HAL_I2CFastModePlusConfig(SYSCFG_I2CFastModePlus, cmd) (((cmd\
N                                                                 )==ENABLE)? HAL_I2CEx_EnableFastModePlus(SYSCFG_I2CFastModePlus): HAL_I2CEx_DisableFastModePlus(SYSCFG_I2CFastModePlus))
X#define HAL_I2CFastModePlusConfig(SYSCFG_I2CFastModePlus, cmd) (((cmd                                                                 )==ENABLE)? HAL_I2CEx_EnableFastModePlus(SYSCFG_I2CFastModePlus): HAL_I2CEx_DisableFastModePlus(SYSCFG_I2CFastModePlus))
N
N#if defined(STM32H7) || defined(STM32WB) || defined(STM32G0) || defined(STM32F0) || defined(STM32F1) || defined(STM32F2) || defined(STM32F3) || defined(STM32F4) || defined(STM32F7) || defined(STM32L0) || defined(STM32L4) || defined(STM32L5) || defined(STM32G4) || defined(STM32L1)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L || 0L || 0L || 0L || 0L
N#define HAL_I2C_Master_Sequential_Transmit_IT  HAL_I2C_Master_Seq_Transmit_IT
N#define HAL_I2C_Master_Sequential_Receive_IT   HAL_I2C_Master_Seq_Receive_IT
N#define HAL_I2C_Slave_Sequential_Transmit_IT   HAL_I2C_Slave_Seq_Transmit_IT
N#define HAL_I2C_Slave_Sequential_Receive_IT    HAL_I2C_Slave_Seq_Receive_IT
N#endif /* STM32H7 || STM32WB  || STM32G0 || STM32F0 || STM32F1 || STM32F2 || STM32F3 || STM32F4 || STM32F7 || STM32L0 || STM32L4 || STM32L5 || STM32G4 || STM32L1 */
N#if defined(STM32H7) || defined(STM32WB) || defined(STM32G0) || defined(STM32F4) || defined(STM32F7) || defined(STM32L0) || defined(STM32L4) || defined(STM32L5) || defined(STM32G4)|| defined(STM32L1)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L || 0L || 0L|| 0L
N#define HAL_I2C_Master_Sequential_Transmit_DMA HAL_I2C_Master_Seq_Transmit_DMA
N#define HAL_I2C_Master_Sequential_Receive_DMA  HAL_I2C_Master_Seq_Receive_DMA
N#define HAL_I2C_Slave_Sequential_Transmit_DMA  HAL_I2C_Slave_Seq_Transmit_DMA
N#define HAL_I2C_Slave_Sequential_Receive_DMA   HAL_I2C_Slave_Seq_Receive_DMA
N#endif /* STM32H7 || STM32WB  || STM32G0 || STM32F4 || STM32F7 || STM32L0 || STM32L4 || STM32L5 || STM32G4 || STM32L1 */
N
N#if defined(STM32F4)
X#if 1L
N#define HAL_FMPI2C_Master_Sequential_Transmit_IT  HAL_FMPI2C_Master_Seq_Transmit_IT
N#define HAL_FMPI2C_Master_Sequential_Receive_IT   HAL_FMPI2C_Master_Seq_Receive_IT
N#define HAL_FMPI2C_Slave_Sequential_Transmit_IT   HAL_FMPI2C_Slave_Seq_Transmit_IT
N#define HAL_FMPI2C_Slave_Sequential_Receive_IT    HAL_FMPI2C_Slave_Seq_Receive_IT
N#define HAL_FMPI2C_Master_Sequential_Transmit_DMA HAL_FMPI2C_Master_Seq_Transmit_DMA
N#define HAL_FMPI2C_Master_Sequential_Receive_DMA  HAL_FMPI2C_Master_Seq_Receive_DMA
N#define HAL_FMPI2C_Slave_Sequential_Transmit_DMA  HAL_FMPI2C_Slave_Seq_Transmit_DMA
N#define HAL_FMPI2C_Slave_Sequential_Receive_DMA   HAL_FMPI2C_Slave_Seq_Receive_DMA
N#endif /* STM32F4 */
N/**
N  * @}
N */
N
N/** @defgroup HAL_PWR_Aliased HAL PWR Aliased maintained for legacy purpose
N  * @{
N  */
N
N#if defined(STM32G0)
X#if 0L
S#define HAL_PWR_ConfigPVD                             HAL_PWREx_ConfigPVD
S#define HAL_PWR_EnablePVD                             HAL_PWREx_EnablePVD
S#define HAL_PWR_DisablePVD                            HAL_PWREx_DisablePVD
S#define HAL_PWR_PVD_IRQHandler                        HAL_PWREx_PVD_IRQHandler
N#endif
N#define HAL_PWR_PVDConfig                             HAL_PWR_ConfigPVD
N#define HAL_PWR_DisableBkUpReg                        HAL_PWREx_DisableBkUpReg
N#define HAL_PWR_DisableFlashPowerDown                 HAL_PWREx_DisableFlashPowerDown
N#define HAL_PWR_DisableVddio2Monitor                  HAL_PWREx_DisableVddio2Monitor
N#define HAL_PWR_EnableBkUpReg                         HAL_PWREx_EnableBkUpReg
N#define HAL_PWR_EnableFlashPowerDown                  HAL_PWREx_EnableFlashPowerDown
N#define HAL_PWR_EnableVddio2Monitor                   HAL_PWREx_EnableVddio2Monitor
N#define HAL_PWR_PVD_PVM_IRQHandler                    HAL_PWREx_PVD_PVM_IRQHandler
N#define HAL_PWR_PVDLevelConfig                        HAL_PWR_ConfigPVD
N#define HAL_PWR_Vddio2Monitor_IRQHandler              HAL_PWREx_Vddio2Monitor_IRQHandler
N#define HAL_PWR_Vddio2MonitorCallback                 HAL_PWREx_Vddio2MonitorCallback
N#define HAL_PWREx_ActivateOverDrive                   HAL_PWREx_EnableOverDrive
N#define HAL_PWREx_DeactivateOverDrive                 HAL_PWREx_DisableOverDrive
N#define HAL_PWREx_DisableSDADCAnalog                  HAL_PWREx_DisableSDADC
N#define HAL_PWREx_EnableSDADCAnalog                   HAL_PWREx_EnableSDADC
N#define HAL_PWREx_PVMConfig                           HAL_PWREx_ConfigPVM
N
N#define PWR_MODE_NORMAL                               PWR_PVD_MODE_NORMAL
N#define PWR_MODE_IT_RISING                            PWR_PVD_MODE_IT_RISING
N#define PWR_MODE_IT_FALLING                           PWR_PVD_MODE_IT_FALLING
N#define PWR_MODE_IT_RISING_FALLING                    PWR_PVD_MODE_IT_RISING_FALLING
N#define PWR_MODE_EVENT_RISING                         PWR_PVD_MODE_EVENT_RISING
N#define PWR_MODE_EVENT_FALLING                        PWR_PVD_MODE_EVENT_FALLING
N#define PWR_MODE_EVENT_RISING_FALLING                 PWR_PVD_MODE_EVENT_RISING_FALLING
N
N#define CR_OFFSET_BB                                  PWR_CR_OFFSET_BB
N#define CSR_OFFSET_BB                                 PWR_CSR_OFFSET_BB
N#define PMODE_BIT_NUMBER                              VOS_BIT_NUMBER
N#define CR_PMODE_BB                                   CR_VOS_BB
N
N#define DBP_BitNumber                                 DBP_BIT_NUMBER
N#define PVDE_BitNumber                                PVDE_BIT_NUMBER
N#define PMODE_BitNumber                               PMODE_BIT_NUMBER
N#define EWUP_BitNumber                                EWUP_BIT_NUMBER
N#define FPDS_BitNumber                                FPDS_BIT_NUMBER
N#define ODEN_BitNumber                                ODEN_BIT_NUMBER
N#define ODSWEN_BitNumber                              ODSWEN_BIT_NUMBER
N#define MRLVDS_BitNumber                              MRLVDS_BIT_NUMBER
N#define LPLVDS_BitNumber                              LPLVDS_BIT_NUMBER
N#define BRE_BitNumber                                 BRE_BIT_NUMBER
N
N#define PWR_MODE_EVT                                  PWR_PVD_MODE_NORMAL
N
N/**
N  * @}
N */
N
N/** @defgroup HAL_SMBUS_Aliased_Functions HAL SMBUS Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_SMBUS_Slave_Listen_IT          HAL_SMBUS_EnableListen_IT
N#define HAL_SMBUS_SlaveAddrCallback        HAL_SMBUS_AddrCallback
N#define HAL_SMBUS_SlaveListenCpltCallback  HAL_SMBUS_ListenCpltCallback
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPI_Aliased_Functions HAL SPI Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_SPI_FlushRxFifo                HAL_SPIEx_FlushRxFifo
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TIM_Aliased_Functions HAL TIM Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_TIM_DMADelayPulseCplt                       TIM_DMADelayPulseCplt
N#define HAL_TIM_DMAError                                TIM_DMAError
N#define HAL_TIM_DMACaptureCplt                          TIM_DMACaptureCplt
N#define HAL_TIMEx_DMACommutationCplt                    TIMEx_DMACommutationCplt
N#if defined(STM32H7) || defined(STM32G0) || defined(STM32F0) || defined(STM32F1) || defined(STM32F2) || defined(STM32F3) || defined(STM32F4) || defined(STM32F7) || defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L || 0L
N#define HAL_TIM_SlaveConfigSynchronization              HAL_TIM_SlaveConfigSynchro
N#define HAL_TIM_SlaveConfigSynchronization_IT           HAL_TIM_SlaveConfigSynchro_IT
N#define HAL_TIMEx_CommutationCallback                   HAL_TIMEx_CommutCallback
N#define HAL_TIMEx_ConfigCommutationEvent                HAL_TIMEx_ConfigCommutEvent
N#define HAL_TIMEx_ConfigCommutationEvent_IT             HAL_TIMEx_ConfigCommutEvent_IT
N#define HAL_TIMEx_ConfigCommutationEvent_DMA            HAL_TIMEx_ConfigCommutEvent_DMA
N#endif /* STM32H7 || STM32G0 || STM32F0 || STM32F1 || STM32F2 || STM32F3 || STM32F4 || STM32F7 || STM32L0 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_UART_Aliased_Functions HAL UART Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_UART_WakeupCallback HAL_UARTEx_WakeupCallback
N/**
N  * @}
N  */
N
N/** @defgroup HAL_LTDC_Aliased_Functions HAL LTDC Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_LTDC_LineEvenCallback HAL_LTDC_LineEventCallback
N#define HAL_LTDC_Relaod           HAL_LTDC_Reload
N#define HAL_LTDC_StructInitFromVideoConfig  HAL_LTDCEx_StructInitFromVideoConfig
N#define HAL_LTDC_StructInitFromAdaptedCommandConfig  HAL_LTDCEx_StructInitFromAdaptedCommandConfig
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_PPP_Aliased_Functions HAL PPP Aliased Functions maintained for legacy purpose
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros ------------------------------------------------------------*/
N
N/** @defgroup HAL_AES_Aliased_Macros HAL CRYP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define AES_IT_CC                      CRYP_IT_CC
N#define AES_IT_ERR                     CRYP_IT_ERR
N#define AES_FLAG_CCF                   CRYP_FLAG_CCF
N/**
N  * @}
N  */
N
N/** @defgroup HAL_Aliased_Macros HAL Generic Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_GET_BOOT_MODE                   __HAL_SYSCFG_GET_BOOT_MODE
N#define __HAL_REMAPMEMORY_FLASH               __HAL_SYSCFG_REMAPMEMORY_FLASH
N#define __HAL_REMAPMEMORY_SYSTEMFLASH         __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH
N#define __HAL_REMAPMEMORY_SRAM                __HAL_SYSCFG_REMAPMEMORY_SRAM
N#define __HAL_REMAPMEMORY_FMC                 __HAL_SYSCFG_REMAPMEMORY_FMC
N#define __HAL_REMAPMEMORY_FMC_SDRAM           __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM
N#define __HAL_REMAPMEMORY_FSMC                __HAL_SYSCFG_REMAPMEMORY_FSMC
N#define __HAL_REMAPMEMORY_QUADSPI             __HAL_SYSCFG_REMAPMEMORY_QUADSPI
N#define __HAL_FMC_BANK                        __HAL_SYSCFG_FMC_BANK
N#define __HAL_GET_FLAG                        __HAL_SYSCFG_GET_FLAG
N#define __HAL_CLEAR_FLAG                      __HAL_SYSCFG_CLEAR_FLAG
N#define __HAL_VREFINT_OUT_ENABLE              __HAL_SYSCFG_VREFINT_OUT_ENABLE
N#define __HAL_VREFINT_OUT_DISABLE             __HAL_SYSCFG_VREFINT_OUT_DISABLE
N#define __HAL_SYSCFG_SRAM2_WRP_ENABLE         __HAL_SYSCFG_SRAM2_WRP_0_31_ENABLE
N
N#define SYSCFG_FLAG_VREF_READY                SYSCFG_FLAG_VREFINT_READY
N#define SYSCFG_FLAG_RC48                      RCC_FLAG_HSI48
N#define IS_SYSCFG_FASTMODEPLUS_CONFIG         IS_I2C_FASTMODEPLUS
N#define UFB_MODE_BitNumber                    UFB_MODE_BIT_NUMBER
N#define CMP_PD_BitNumber                      CMP_PD_BIT_NUMBER
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_ADC_Aliased_Macros HAL ADC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __ADC_ENABLE                                     __HAL_ADC_ENABLE
N#define __ADC_DISABLE                                    __HAL_ADC_DISABLE
N#define __HAL_ADC_ENABLING_CONDITIONS                    ADC_ENABLING_CONDITIONS
N#define __HAL_ADC_DISABLING_CONDITIONS                   ADC_DISABLING_CONDITIONS
N#define __HAL_ADC_IS_ENABLED                             ADC_IS_ENABLE
N#define __ADC_IS_ENABLED                                 ADC_IS_ENABLE
N#define __HAL_ADC_IS_SOFTWARE_START_REGULAR              ADC_IS_SOFTWARE_START_REGULAR
N#define __HAL_ADC_IS_SOFTWARE_START_INJECTED             ADC_IS_SOFTWARE_START_INJECTED
N#define __HAL_ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED
N#define __HAL_ADC_IS_CONVERSION_ONGOING_REGULAR          ADC_IS_CONVERSION_ONGOING_REGULAR
N#define __HAL_ADC_IS_CONVERSION_ONGOING_INJECTED         ADC_IS_CONVERSION_ONGOING_INJECTED
N#define __HAL_ADC_IS_CONVERSION_ONGOING                  ADC_IS_CONVERSION_ONGOING
N#define __HAL_ADC_CLEAR_ERRORCODE                        ADC_CLEAR_ERRORCODE
N
N#define __HAL_ADC_GET_RESOLUTION                         ADC_GET_RESOLUTION
N#define __HAL_ADC_JSQR_RK                                ADC_JSQR_RK
N#define __HAL_ADC_CFGR_AWD1CH                            ADC_CFGR_AWD1CH_SHIFT
N#define __HAL_ADC_CFGR_AWD23CR                           ADC_CFGR_AWD23CR
N#define __HAL_ADC_CFGR_INJECT_AUTO_CONVERSION            ADC_CFGR_INJECT_AUTO_CONVERSION
N#define __HAL_ADC_CFGR_INJECT_CONTEXT_QUEUE              ADC_CFGR_INJECT_CONTEXT_QUEUE
N#define __HAL_ADC_CFGR_INJECT_DISCCONTINUOUS             ADC_CFGR_INJECT_DISCCONTINUOUS
N#define __HAL_ADC_CFGR_REG_DISCCONTINUOUS                ADC_CFGR_REG_DISCCONTINUOUS
N#define __HAL_ADC_CFGR_DISCONTINUOUS_NUM                 ADC_CFGR_DISCONTINUOUS_NUM
N#define __HAL_ADC_CFGR_AUTOWAIT                          ADC_CFGR_AUTOWAIT
N#define __HAL_ADC_CFGR_CONTINUOUS                        ADC_CFGR_CONTINUOUS
N#define __HAL_ADC_CFGR_OVERRUN                           ADC_CFGR_OVERRUN
N#define __HAL_ADC_CFGR_DMACONTREQ                        ADC_CFGR_DMACONTREQ
N#define __HAL_ADC_CFGR_EXTSEL                            ADC_CFGR_EXTSEL_SET
N#define __HAL_ADC_JSQR_JEXTSEL                           ADC_JSQR_JEXTSEL_SET
N#define __HAL_ADC_OFR_CHANNEL                            ADC_OFR_CHANNEL
N#define __HAL_ADC_DIFSEL_CHANNEL                         ADC_DIFSEL_CHANNEL
N#define __HAL_ADC_CALFACT_DIFF_SET                       ADC_CALFACT_DIFF_SET
N#define __HAL_ADC_CALFACT_DIFF_GET                       ADC_CALFACT_DIFF_GET
N#define __HAL_ADC_TRX_HIGHTHRESHOLD                      ADC_TRX_HIGHTHRESHOLD
N
N#define __HAL_ADC_OFFSET_SHIFT_RESOLUTION                ADC_OFFSET_SHIFT_RESOLUTION
N#define __HAL_ADC_AWD1THRESHOLD_SHIFT_RESOLUTION         ADC_AWD1THRESHOLD_SHIFT_RESOLUTION
N#define __HAL_ADC_AWD23THRESHOLD_SHIFT_RESOLUTION        ADC_AWD23THRESHOLD_SHIFT_RESOLUTION
N#define __HAL_ADC_COMMON_REGISTER                        ADC_COMMON_REGISTER
N#define __HAL_ADC_COMMON_CCR_MULTI                       ADC_COMMON_CCR_MULTI
N#define __HAL_ADC_MULTIMODE_IS_ENABLED                   ADC_MULTIMODE_IS_ENABLE
N#define __ADC_MULTIMODE_IS_ENABLED                       ADC_MULTIMODE_IS_ENABLE
N#define __HAL_ADC_NONMULTIMODE_OR_MULTIMODEMASTER        ADC_NONMULTIMODE_OR_MULTIMODEMASTER
N#define __HAL_ADC_COMMON_ADC_OTHER                       ADC_COMMON_ADC_OTHER
N#define __HAL_ADC_MULTI_SLAVE                            ADC_MULTI_SLAVE
N
N#define __HAL_ADC_SQR1_L                                 ADC_SQR1_L_SHIFT
N#define __HAL_ADC_JSQR_JL                                ADC_JSQR_JL_SHIFT
N#define __HAL_ADC_JSQR_RK_JL                             ADC_JSQR_RK_JL
N#define __HAL_ADC_CR1_DISCONTINUOUS_NUM                  ADC_CR1_DISCONTINUOUS_NUM
N#define __HAL_ADC_CR1_SCAN                               ADC_CR1_SCAN_SET
N#define __HAL_ADC_CONVCYCLES_MAX_RANGE                   ADC_CONVCYCLES_MAX_RANGE
N#define __HAL_ADC_CLOCK_PRESCALER_RANGE                  ADC_CLOCK_PRESCALER_RANGE
N#define __HAL_ADC_GET_CLOCK_PRESCALER                    ADC_GET_CLOCK_PRESCALER
N
N#define __HAL_ADC_SQR1                                   ADC_SQR1
N#define __HAL_ADC_SMPR1                                  ADC_SMPR1
N#define __HAL_ADC_SMPR2                                  ADC_SMPR2
N#define __HAL_ADC_SQR3_RK                                ADC_SQR3_RK
N#define __HAL_ADC_SQR2_RK                                ADC_SQR2_RK
N#define __HAL_ADC_SQR1_RK                                ADC_SQR1_RK
N#define __HAL_ADC_CR2_CONTINUOUS                         ADC_CR2_CONTINUOUS
N#define __HAL_ADC_CR1_DISCONTINUOUS                      ADC_CR1_DISCONTINUOUS
N#define __HAL_ADC_CR1_SCANCONV                           ADC_CR1_SCANCONV
N#define __HAL_ADC_CR2_EOCSelection                       ADC_CR2_EOCSelection
N#define __HAL_ADC_CR2_DMAContReq                         ADC_CR2_DMAContReq
N#define __HAL_ADC_JSQR                                   ADC_JSQR
N
N#define __HAL_ADC_CHSELR_CHANNEL                         ADC_CHSELR_CHANNEL
N#define __HAL_ADC_CFGR1_REG_DISCCONTINUOUS               ADC_CFGR1_REG_DISCCONTINUOUS
N#define __HAL_ADC_CFGR1_AUTOOFF                          ADC_CFGR1_AUTOOFF
N#define __HAL_ADC_CFGR1_AUTOWAIT                         ADC_CFGR1_AUTOWAIT
N#define __HAL_ADC_CFGR1_CONTINUOUS                       ADC_CFGR1_CONTINUOUS
N#define __HAL_ADC_CFGR1_OVERRUN                          ADC_CFGR1_OVERRUN
N#define __HAL_ADC_CFGR1_SCANDIR                          ADC_CFGR1_SCANDIR
N#define __HAL_ADC_CFGR1_DMACONTREQ                       ADC_CFGR1_DMACONTREQ
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DAC_Aliased_Macros HAL DAC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_DHR12R1_ALIGNEMENT                        DAC_DHR12R1_ALIGNMENT
N#define __HAL_DHR12R2_ALIGNEMENT                        DAC_DHR12R2_ALIGNMENT
N#define __HAL_DHR12RD_ALIGNEMENT                        DAC_DHR12RD_ALIGNMENT
N#define IS_DAC_GENERATE_WAVE                            IS_DAC_WAVE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DBGMCU_Aliased_Macros HAL DBGMCU Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_FREEZE_TIM1_DBGMCU __HAL_DBGMCU_FREEZE_TIM1
N#define __HAL_UNFREEZE_TIM1_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM1
N#define __HAL_FREEZE_TIM2_DBGMCU __HAL_DBGMCU_FREEZE_TIM2
N#define __HAL_UNFREEZE_TIM2_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM2
N#define __HAL_FREEZE_TIM3_DBGMCU __HAL_DBGMCU_FREEZE_TIM3
N#define __HAL_UNFREEZE_TIM3_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM3
N#define __HAL_FREEZE_TIM4_DBGMCU __HAL_DBGMCU_FREEZE_TIM4
N#define __HAL_UNFREEZE_TIM4_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM4
N#define __HAL_FREEZE_TIM5_DBGMCU __HAL_DBGMCU_FREEZE_TIM5
N#define __HAL_UNFREEZE_TIM5_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM5
N#define __HAL_FREEZE_TIM6_DBGMCU __HAL_DBGMCU_FREEZE_TIM6
N#define __HAL_UNFREEZE_TIM6_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM6
N#define __HAL_FREEZE_TIM7_DBGMCU __HAL_DBGMCU_FREEZE_TIM7
N#define __HAL_UNFREEZE_TIM7_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM7
N#define __HAL_FREEZE_TIM8_DBGMCU __HAL_DBGMCU_FREEZE_TIM8
N#define __HAL_UNFREEZE_TIM8_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM8
N
N#define __HAL_FREEZE_TIM9_DBGMCU __HAL_DBGMCU_FREEZE_TIM9
N#define __HAL_UNFREEZE_TIM9_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM9
N#define __HAL_FREEZE_TIM10_DBGMCU __HAL_DBGMCU_FREEZE_TIM10
N#define __HAL_UNFREEZE_TIM10_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM10
N#define __HAL_FREEZE_TIM11_DBGMCU __HAL_DBGMCU_FREEZE_TIM11
N#define __HAL_UNFREEZE_TIM11_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM11
N#define __HAL_FREEZE_TIM12_DBGMCU __HAL_DBGMCU_FREEZE_TIM12
N#define __HAL_UNFREEZE_TIM12_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM12
N#define __HAL_FREEZE_TIM13_DBGMCU __HAL_DBGMCU_FREEZE_TIM13
N#define __HAL_UNFREEZE_TIM13_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM13
N#define __HAL_FREEZE_TIM14_DBGMCU __HAL_DBGMCU_FREEZE_TIM14
N#define __HAL_UNFREEZE_TIM14_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM14
N#define __HAL_FREEZE_CAN2_DBGMCU __HAL_DBGMCU_FREEZE_CAN2
N#define __HAL_UNFREEZE_CAN2_DBGMCU __HAL_DBGMCU_UNFREEZE_CAN2
N
N
N#define __HAL_FREEZE_TIM15_DBGMCU __HAL_DBGMCU_FREEZE_TIM15
N#define __HAL_UNFREEZE_TIM15_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM15
N#define __HAL_FREEZE_TIM16_DBGMCU __HAL_DBGMCU_FREEZE_TIM16
N#define __HAL_UNFREEZE_TIM16_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM16
N#define __HAL_FREEZE_TIM17_DBGMCU __HAL_DBGMCU_FREEZE_TIM17
N#define __HAL_UNFREEZE_TIM17_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM17
N#define __HAL_FREEZE_RTC_DBGMCU __HAL_DBGMCU_FREEZE_RTC
N#define __HAL_UNFREEZE_RTC_DBGMCU __HAL_DBGMCU_UNFREEZE_RTC
N#if defined(STM32H7)
X#if 0L
S#define __HAL_FREEZE_WWDG_DBGMCU __HAL_DBGMCU_FREEZE_WWDG1
S#define __HAL_UNFREEZE_WWDG_DBGMCU __HAL_DBGMCU_UnFreeze_WWDG1
S#define __HAL_FREEZE_IWDG_DBGMCU __HAL_DBGMCU_FREEZE_IWDG1
S#define __HAL_UNFREEZE_IWDG_DBGMCU __HAL_DBGMCU_UnFreeze_IWDG1
N#else
N#define __HAL_FREEZE_WWDG_DBGMCU __HAL_DBGMCU_FREEZE_WWDG
N#define __HAL_UNFREEZE_WWDG_DBGMCU __HAL_DBGMCU_UNFREEZE_WWDG
N#define __HAL_FREEZE_IWDG_DBGMCU __HAL_DBGMCU_FREEZE_IWDG
N#define __HAL_UNFREEZE_IWDG_DBGMCU __HAL_DBGMCU_UNFREEZE_IWDG
N#endif /* STM32H7 */
N#define __HAL_FREEZE_I2C1_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT
N#define __HAL_UNFREEZE_I2C1_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT
N#define __HAL_FREEZE_I2C2_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C2_TIMEOUT
N#define __HAL_UNFREEZE_I2C2_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT
N#define __HAL_FREEZE_I2C3_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C3_TIMEOUT
N#define __HAL_UNFREEZE_I2C3_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT
N#define __HAL_FREEZE_CAN1_DBGMCU __HAL_DBGMCU_FREEZE_CAN1
N#define __HAL_UNFREEZE_CAN1_DBGMCU __HAL_DBGMCU_UNFREEZE_CAN1
N#define __HAL_FREEZE_LPTIM1_DBGMCU __HAL_DBGMCU_FREEZE_LPTIM1
N#define __HAL_UNFREEZE_LPTIM1_DBGMCU __HAL_DBGMCU_UNFREEZE_LPTIM1
N#define __HAL_FREEZE_LPTIM2_DBGMCU __HAL_DBGMCU_FREEZE_LPTIM2
N#define __HAL_UNFREEZE_LPTIM2_DBGMCU __HAL_DBGMCU_UNFREEZE_LPTIM2
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_COMP_Aliased_Macros HAL COMP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#if defined(STM32F3)
X#if 0L
S#define COMP_START                                       __HAL_COMP_ENABLE
S#define COMP_STOP                                        __HAL_COMP_DISABLE
S#define COMP_LOCK                                        __HAL_COMP_LOCK
S
S#if defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx) || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
S# endif
S# if defined(STM32F302xE) || defined(STM32F302xC)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
S# endif
S# if defined(STM32F303xE) || defined(STM32F398xx) || defined(STM32F303xC) || defined(STM32F358xx)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP7_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP7_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP7_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP7_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP7_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP7_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP7_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP7_EXTI_CLEAR_FLAG())
S# endif
S# if defined(STM32F373xC) ||defined(STM32F378xx)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP2_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP2_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP2_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
S# endif
N#else
N#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
N#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
N#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
N#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
N#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
N                                                          __HAL_COMP_COMP2_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_IT())
N#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
N                                                          __HAL_COMP_COMP2_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_IT())
N#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
N                                                          __HAL_COMP_COMP2_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_GET_FLAG())
N#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
N                                                          __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
N#endif
N
N#define __HAL_COMP_GET_EXTI_LINE  COMP_GET_EXTI_LINE
N
N#if defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L
S/* Note: On these STM32 families, the only argument of this macro             */
S/*       is COMP_FLAG_LOCK.                                                   */
S/*       This macro is replaced by __HAL_COMP_IS_LOCKED with only HAL handle  */
S/*       argument.                                                            */
S#define __HAL_COMP_GET_FLAG(__HANDLE__, __FLAG__)  (__HAL_COMP_IS_LOCKED(__HANDLE__))
N#endif
N/**
N  * @}
N  */
N
N#if defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L
S/** @defgroup HAL_COMP_Aliased_Functions HAL COMP Aliased Functions maintained for legacy purpose
S  * @{
S  */
S#define HAL_COMP_Start_IT       HAL_COMP_Start /* Function considered as legacy as EXTI event or IT configuration is done into HAL_COMP_Init() */
S#define HAL_COMP_Stop_IT        HAL_COMP_Stop  /* Function considered as legacy as EXTI event or IT configuration is done into HAL_COMP_Init() */
S/**
S  * @}
S  */
N#endif
N
N/** @defgroup HAL_DAC_Aliased_Macros HAL DAC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_WAVE_NONE) || \
N                           ((WAVE) == DAC_WAVE_NOISE)|| \
N                           ((WAVE) == DAC_WAVE_TRIANGLE))
X#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_WAVE_NONE) ||                            ((WAVE) == DAC_WAVE_NOISE)||                            ((WAVE) == DAC_WAVE_TRIANGLE))
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_FLASH_Aliased_Macros HAL FLASH Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define IS_WRPAREA          IS_OB_WRPAREA
N#define IS_TYPEPROGRAM      IS_FLASH_TYPEPROGRAM
N#define IS_TYPEPROGRAMFLASH IS_FLASH_TYPEPROGRAM
N#define IS_TYPEERASE        IS_FLASH_TYPEERASE
N#define IS_NBSECTORS        IS_FLASH_NBSECTORS
N#define IS_OB_WDG_SOURCE    IS_OB_IWDG_SOURCE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2C_Aliased_Macros HAL I2C Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_I2C_RESET_CR2             I2C_RESET_CR2
N#define __HAL_I2C_GENERATE_START        I2C_GENERATE_START
N#if defined(STM32F1)
X#if 0L
S#define __HAL_I2C_FREQ_RANGE            I2C_FREQRANGE
N#else
N#define __HAL_I2C_FREQ_RANGE            I2C_FREQ_RANGE
N#endif /* STM32F1 */
N#define __HAL_I2C_RISE_TIME             I2C_RISE_TIME
N#define __HAL_I2C_SPEED_STANDARD        I2C_SPEED_STANDARD
N#define __HAL_I2C_SPEED_FAST            I2C_SPEED_FAST
N#define __HAL_I2C_SPEED                 I2C_SPEED
N#define __HAL_I2C_7BIT_ADD_WRITE        I2C_7BIT_ADD_WRITE
N#define __HAL_I2C_7BIT_ADD_READ         I2C_7BIT_ADD_READ
N#define __HAL_I2C_10BIT_ADDRESS         I2C_10BIT_ADDRESS
N#define __HAL_I2C_10BIT_HEADER_WRITE    I2C_10BIT_HEADER_WRITE
N#define __HAL_I2C_10BIT_HEADER_READ     I2C_10BIT_HEADER_READ
N#define __HAL_I2C_MEM_ADD_MSB           I2C_MEM_ADD_MSB
N#define __HAL_I2C_MEM_ADD_LSB           I2C_MEM_ADD_LSB
N#define __HAL_I2C_FREQRANGE             I2C_FREQRANGE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2S_Aliased_Macros HAL I2S Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define IS_I2S_INSTANCE                 IS_I2S_ALL_INSTANCE
N#define IS_I2S_INSTANCE_EXT             IS_I2S_ALL_INSTANCE_EXT
N
N#if defined(STM32H7)
X#if 0L
S#define __HAL_I2S_CLEAR_FREFLAG       __HAL_I2S_CLEAR_TIFREFLAG
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_IRDA_Aliased_Macros HAL IRDA Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __IRDA_DISABLE                  __HAL_IRDA_DISABLE
N#define __IRDA_ENABLE                   __HAL_IRDA_ENABLE
N
N#define __HAL_IRDA_GETCLOCKSOURCE       IRDA_GETCLOCKSOURCE
N#define __HAL_IRDA_MASK_COMPUTATION     IRDA_MASK_COMPUTATION
N#define __IRDA_GETCLOCKSOURCE           IRDA_GETCLOCKSOURCE
N#define __IRDA_MASK_COMPUTATION         IRDA_MASK_COMPUTATION
N
N#define IS_IRDA_ONEBIT_SAMPLE           IS_IRDA_ONE_BIT_SAMPLE
N
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_IWDG_Aliased_Macros HAL IWDG Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_IWDG_ENABLE_WRITE_ACCESS  IWDG_ENABLE_WRITE_ACCESS
N#define __HAL_IWDG_DISABLE_WRITE_ACCESS IWDG_DISABLE_WRITE_ACCESS
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_LPTIM_Aliased_Macros HAL LPTIM Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_LPTIM_ENABLE_INTERRUPT    __HAL_LPTIM_ENABLE_IT
N#define __HAL_LPTIM_DISABLE_INTERRUPT   __HAL_LPTIM_DISABLE_IT
N#define __HAL_LPTIM_GET_ITSTATUS        __HAL_LPTIM_GET_IT_SOURCE
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_OPAMP_Aliased_Macros HAL OPAMP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __OPAMP_CSR_OPAXPD                OPAMP_CSR_OPAXPD
N#define __OPAMP_CSR_S3SELX                OPAMP_CSR_S3SELX
N#define __OPAMP_CSR_S4SELX                OPAMP_CSR_S4SELX
N#define __OPAMP_CSR_S5SELX                OPAMP_CSR_S5SELX
N#define __OPAMP_CSR_S6SELX                OPAMP_CSR_S6SELX
N#define __OPAMP_CSR_OPAXCAL_L             OPAMP_CSR_OPAXCAL_L
N#define __OPAMP_CSR_OPAXCAL_H             OPAMP_CSR_OPAXCAL_H
N#define __OPAMP_CSR_OPAXLPM               OPAMP_CSR_OPAXLPM
N#define __OPAMP_CSR_ALL_SWITCHES          OPAMP_CSR_ALL_SWITCHES
N#define __OPAMP_CSR_ANAWSELX              OPAMP_CSR_ANAWSELX
N#define __OPAMP_CSR_OPAXCALOUT            OPAMP_CSR_OPAXCALOUT
N#define __OPAMP_OFFSET_TRIM_BITSPOSITION  OPAMP_OFFSET_TRIM_BITSPOSITION
N#define __OPAMP_OFFSET_TRIM_SET           OPAMP_OFFSET_TRIM_SET
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_PWR_Aliased_Macros HAL PWR Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_PVD_EVENT_DISABLE                                  __HAL_PWR_PVD_EXTI_DISABLE_EVENT
N#define __HAL_PVD_EVENT_ENABLE                                   __HAL_PWR_PVD_EXTI_ENABLE_EVENT
N#define __HAL_PVD_EXTI_FALLINGTRIGGER_DISABLE                    __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE
N#define __HAL_PVD_EXTI_FALLINGTRIGGER_ENABLE                     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PVD_EXTI_RISINGTRIGGER_DISABLE                     __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE
N#define __HAL_PVD_EXTI_RISINGTRIGGER_ENABLE                      __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
N#define __HAL_PVM_EVENT_DISABLE                                  __HAL_PWR_PVM_EVENT_DISABLE
N#define __HAL_PVM_EVENT_ENABLE                                   __HAL_PWR_PVM_EVENT_ENABLE
N#define __HAL_PVM_EXTI_FALLINGTRIGGER_DISABLE                    __HAL_PWR_PVM_EXTI_FALLINGTRIGGER_DISABLE
N#define __HAL_PVM_EXTI_FALLINGTRIGGER_ENABLE                     __HAL_PWR_PVM_EXTI_FALLINGTRIGGER_ENABLE
N#define __HAL_PVM_EXTI_RISINGTRIGGER_DISABLE                     __HAL_PWR_PVM_EXTI_RISINGTRIGGER_DISABLE
N#define __HAL_PVM_EXTI_RISINGTRIGGER_ENABLE                      __HAL_PWR_PVM_EXTI_RISINGTRIGGER_ENABLE
N#define __HAL_PWR_INTERNALWAKEUP_DISABLE                         HAL_PWREx_DisableInternalWakeUpLine
N#define __HAL_PWR_INTERNALWAKEUP_ENABLE                          HAL_PWREx_EnableInternalWakeUpLine
N#define __HAL_PWR_PULL_UP_DOWN_CONFIG_DISABLE                    HAL_PWREx_DisablePullUpPullDownConfig
N#define __HAL_PWR_PULL_UP_DOWN_CONFIG_ENABLE                     HAL_PWREx_EnablePullUpPullDownConfig
N#define __HAL_PWR_PVD_EXTI_CLEAR_EGDE_TRIGGER()                  do { __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();__HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); } while(0)
N#define __HAL_PWR_PVD_EXTI_EVENT_DISABLE                         __HAL_PWR_PVD_EXTI_DISABLE_EVENT
N#define __HAL_PWR_PVD_EXTI_EVENT_ENABLE                          __HAL_PWR_PVD_EXTI_ENABLE_EVENT
N#define __HAL_PWR_PVD_EXTI_FALLINGTRIGGER_DISABLE                __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE
N#define __HAL_PWR_PVD_EXTI_FALLINGTRIGGER_ENABLE                 __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PWR_PVD_EXTI_RISINGTRIGGER_DISABLE                 __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE
N#define __HAL_PWR_PVD_EXTI_RISINGTRIGGER_ENABLE                  __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
N#define __HAL_PWR_PVD_EXTI_SET_FALLING_EGDE_TRIGGER              __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PWR_PVD_EXTI_SET_RISING_EDGE_TRIGGER               __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
N#define __HAL_PWR_PVM_DISABLE()                                  do { HAL_PWREx_DisablePVM1();HAL_PWREx_DisablePVM2();HAL_PWREx_DisablePVM3();HAL_PWREx_DisablePVM4(); } while(0)
N#define __HAL_PWR_PVM_ENABLE()                                   do { HAL_PWREx_EnablePVM1();HAL_PWREx_EnablePVM2();HAL_PWREx_EnablePVM3();HAL_PWREx_EnablePVM4(); } while(0)
N#define __HAL_PWR_SRAM2CONTENT_PRESERVE_DISABLE                  HAL_PWREx_DisableSRAM2ContentRetention
N#define __HAL_PWR_SRAM2CONTENT_PRESERVE_ENABLE                   HAL_PWREx_EnableSRAM2ContentRetention
N#define __HAL_PWR_VDDIO2_DISABLE                                 HAL_PWREx_DisableVddIO2
N#define __HAL_PWR_VDDIO2_ENABLE                                  HAL_PWREx_EnableVddIO2
N#define __HAL_PWR_VDDIO2_EXTI_CLEAR_EGDE_TRIGGER                 __HAL_PWR_VDDIO2_EXTI_DISABLE_FALLING_EDGE
N#define __HAL_PWR_VDDIO2_EXTI_SET_FALLING_EGDE_TRIGGER           __HAL_PWR_VDDIO2_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PWR_VDDUSB_DISABLE                                 HAL_PWREx_DisableVddUSB
N#define __HAL_PWR_VDDUSB_ENABLE                                  HAL_PWREx_EnableVddUSB
N
N#if defined (STM32F4)
X#if 1L
N#define __HAL_PVD_EXTI_ENABLE_IT(PWR_EXTI_LINE_PVD)         __HAL_PWR_PVD_EXTI_ENABLE_IT()
N#define __HAL_PVD_EXTI_DISABLE_IT(PWR_EXTI_LINE_PVD)        __HAL_PWR_PVD_EXTI_DISABLE_IT()
N#define __HAL_PVD_EXTI_GET_FLAG(PWR_EXTI_LINE_PVD)          __HAL_PWR_PVD_EXTI_GET_FLAG()
N#define __HAL_PVD_EXTI_CLEAR_FLAG(PWR_EXTI_LINE_PVD)        __HAL_PWR_PVD_EXTI_CLEAR_FLAG()
N#define __HAL_PVD_EXTI_GENERATE_SWIT(PWR_EXTI_LINE_PVD)     __HAL_PWR_PVD_EXTI_GENERATE_SWIT()
N#else
S#define __HAL_PVD_EXTI_CLEAR_FLAG                                __HAL_PWR_PVD_EXTI_CLEAR_FLAG
S#define __HAL_PVD_EXTI_DISABLE_IT                                __HAL_PWR_PVD_EXTI_DISABLE_IT
S#define __HAL_PVD_EXTI_ENABLE_IT                                 __HAL_PWR_PVD_EXTI_ENABLE_IT
S#define __HAL_PVD_EXTI_GENERATE_SWIT                             __HAL_PWR_PVD_EXTI_GENERATE_SWIT
S#define __HAL_PVD_EXTI_GET_FLAG                                  __HAL_PWR_PVD_EXTI_GET_FLAG
N#endif /* STM32F4 */
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_RCC_Aliased HAL RCC Aliased maintained for legacy purpose
N  * @{
N  */
N
N#define RCC_StopWakeUpClock_MSI     RCC_STOP_WAKEUPCLOCK_MSI
N#define RCC_StopWakeUpClock_HSI     RCC_STOP_WAKEUPCLOCK_HSI
N
N#define HAL_RCC_CCSCallback HAL_RCC_CSSCallback
N#define HAL_RC48_EnableBuffer_Cmd(cmd) (((cmd\
N                                         )==ENABLE) ? HAL_RCCEx_EnableHSI48_VREFINT() : HAL_RCCEx_DisableHSI48_VREFINT())
X#define HAL_RC48_EnableBuffer_Cmd(cmd) (((cmd                                         )==ENABLE) ? HAL_RCCEx_EnableHSI48_VREFINT() : HAL_RCCEx_DisableHSI48_VREFINT())
N
N#define __ADC_CLK_DISABLE          __HAL_RCC_ADC_CLK_DISABLE
N#define __ADC_CLK_ENABLE           __HAL_RCC_ADC_CLK_ENABLE
N#define __ADC_CLK_SLEEP_DISABLE    __HAL_RCC_ADC_CLK_SLEEP_DISABLE
N#define __ADC_CLK_SLEEP_ENABLE     __HAL_RCC_ADC_CLK_SLEEP_ENABLE
N#define __ADC_FORCE_RESET          __HAL_RCC_ADC_FORCE_RESET
N#define __ADC_RELEASE_RESET        __HAL_RCC_ADC_RELEASE_RESET
N#define __ADC1_CLK_DISABLE         __HAL_RCC_ADC1_CLK_DISABLE
N#define __ADC1_CLK_ENABLE          __HAL_RCC_ADC1_CLK_ENABLE
N#define __ADC1_FORCE_RESET         __HAL_RCC_ADC1_FORCE_RESET
N#define __ADC1_RELEASE_RESET       __HAL_RCC_ADC1_RELEASE_RESET
N#define __ADC1_CLK_SLEEP_ENABLE    __HAL_RCC_ADC1_CLK_SLEEP_ENABLE
N#define __ADC1_CLK_SLEEP_DISABLE   __HAL_RCC_ADC1_CLK_SLEEP_DISABLE
N#define __ADC2_CLK_DISABLE         __HAL_RCC_ADC2_CLK_DISABLE
N#define __ADC2_CLK_ENABLE          __HAL_RCC_ADC2_CLK_ENABLE
N#define __ADC2_FORCE_RESET __HAL_RCC_ADC2_FORCE_RESET
N#define __ADC2_RELEASE_RESET __HAL_RCC_ADC2_RELEASE_RESET
N#define __ADC3_CLK_DISABLE __HAL_RCC_ADC3_CLK_DISABLE
N#define __ADC3_CLK_ENABLE __HAL_RCC_ADC3_CLK_ENABLE
N#define __ADC3_FORCE_RESET __HAL_RCC_ADC3_FORCE_RESET
N#define __ADC3_RELEASE_RESET __HAL_RCC_ADC3_RELEASE_RESET
N#define __AES_CLK_DISABLE __HAL_RCC_AES_CLK_DISABLE
N#define __AES_CLK_ENABLE __HAL_RCC_AES_CLK_ENABLE
N#define __AES_CLK_SLEEP_DISABLE __HAL_RCC_AES_CLK_SLEEP_DISABLE
N#define __AES_CLK_SLEEP_ENABLE __HAL_RCC_AES_CLK_SLEEP_ENABLE
N#define __AES_FORCE_RESET __HAL_RCC_AES_FORCE_RESET
N#define __AES_RELEASE_RESET __HAL_RCC_AES_RELEASE_RESET
N#define __CRYP_CLK_SLEEP_ENABLE      __HAL_RCC_CRYP_CLK_SLEEP_ENABLE
N#define __CRYP_CLK_SLEEP_DISABLE  __HAL_RCC_CRYP_CLK_SLEEP_DISABLE
N#define __CRYP_CLK_ENABLE  __HAL_RCC_CRYP_CLK_ENABLE
N#define __CRYP_CLK_DISABLE  __HAL_RCC_CRYP_CLK_DISABLE
N#define __CRYP_FORCE_RESET       __HAL_RCC_CRYP_FORCE_RESET
N#define __CRYP_RELEASE_RESET  __HAL_RCC_CRYP_RELEASE_RESET
N#define __AFIO_CLK_DISABLE __HAL_RCC_AFIO_CLK_DISABLE
N#define __AFIO_CLK_ENABLE __HAL_RCC_AFIO_CLK_ENABLE
N#define __AFIO_FORCE_RESET __HAL_RCC_AFIO_FORCE_RESET
N#define __AFIO_RELEASE_RESET __HAL_RCC_AFIO_RELEASE_RESET
N#define __AHB_FORCE_RESET __HAL_RCC_AHB_FORCE_RESET
N#define __AHB_RELEASE_RESET __HAL_RCC_AHB_RELEASE_RESET
N#define __AHB1_FORCE_RESET __HAL_RCC_AHB1_FORCE_RESET
N#define __AHB1_RELEASE_RESET __HAL_RCC_AHB1_RELEASE_RESET
N#define __AHB2_FORCE_RESET __HAL_RCC_AHB2_FORCE_RESET
N#define __AHB2_RELEASE_RESET __HAL_RCC_AHB2_RELEASE_RESET
N#define __AHB3_FORCE_RESET __HAL_RCC_AHB3_FORCE_RESET
N#define __AHB3_RELEASE_RESET __HAL_RCC_AHB3_RELEASE_RESET
N#define __APB1_FORCE_RESET __HAL_RCC_APB1_FORCE_RESET
N#define __APB1_RELEASE_RESET __HAL_RCC_APB1_RELEASE_RESET
N#define __APB2_FORCE_RESET __HAL_RCC_APB2_FORCE_RESET
N#define __APB2_RELEASE_RESET __HAL_RCC_APB2_RELEASE_RESET
N#define __BKP_CLK_DISABLE __HAL_RCC_BKP_CLK_DISABLE
N#define __BKP_CLK_ENABLE __HAL_RCC_BKP_CLK_ENABLE
N#define __BKP_FORCE_RESET __HAL_RCC_BKP_FORCE_RESET
N#define __BKP_RELEASE_RESET __HAL_RCC_BKP_RELEASE_RESET
N#define __CAN1_CLK_DISABLE __HAL_RCC_CAN1_CLK_DISABLE
N#define __CAN1_CLK_ENABLE __HAL_RCC_CAN1_CLK_ENABLE
N#define __CAN1_CLK_SLEEP_DISABLE __HAL_RCC_CAN1_CLK_SLEEP_DISABLE
N#define __CAN1_CLK_SLEEP_ENABLE __HAL_RCC_CAN1_CLK_SLEEP_ENABLE
N#define __CAN1_FORCE_RESET __HAL_RCC_CAN1_FORCE_RESET
N#define __CAN1_RELEASE_RESET __HAL_RCC_CAN1_RELEASE_RESET
N#define __CAN_CLK_DISABLE         __HAL_RCC_CAN1_CLK_DISABLE
N#define __CAN_CLK_ENABLE          __HAL_RCC_CAN1_CLK_ENABLE
N#define __CAN_FORCE_RESET         __HAL_RCC_CAN1_FORCE_RESET
N#define __CAN_RELEASE_RESET       __HAL_RCC_CAN1_RELEASE_RESET
N#define __CAN2_CLK_DISABLE __HAL_RCC_CAN2_CLK_DISABLE
N#define __CAN2_CLK_ENABLE __HAL_RCC_CAN2_CLK_ENABLE
N#define __CAN2_FORCE_RESET __HAL_RCC_CAN2_FORCE_RESET
N#define __CAN2_RELEASE_RESET __HAL_RCC_CAN2_RELEASE_RESET
N#define __CEC_CLK_DISABLE __HAL_RCC_CEC_CLK_DISABLE
N#define __CEC_CLK_ENABLE __HAL_RCC_CEC_CLK_ENABLE
N#define __COMP_CLK_DISABLE        __HAL_RCC_COMP_CLK_DISABLE
N#define __COMP_CLK_ENABLE         __HAL_RCC_COMP_CLK_ENABLE
N#define __COMP_FORCE_RESET        __HAL_RCC_COMP_FORCE_RESET
N#define __COMP_RELEASE_RESET      __HAL_RCC_COMP_RELEASE_RESET
N#define __COMP_CLK_SLEEP_ENABLE   __HAL_RCC_COMP_CLK_SLEEP_ENABLE
N#define __COMP_CLK_SLEEP_DISABLE  __HAL_RCC_COMP_CLK_SLEEP_DISABLE
N#define __CEC_FORCE_RESET __HAL_RCC_CEC_FORCE_RESET
N#define __CEC_RELEASE_RESET __HAL_RCC_CEC_RELEASE_RESET
N#define __CRC_CLK_DISABLE __HAL_RCC_CRC_CLK_DISABLE
N#define __CRC_CLK_ENABLE __HAL_RCC_CRC_CLK_ENABLE
N#define __CRC_CLK_SLEEP_DISABLE __HAL_RCC_CRC_CLK_SLEEP_DISABLE
N#define __CRC_CLK_SLEEP_ENABLE __HAL_RCC_CRC_CLK_SLEEP_ENABLE
N#define __CRC_FORCE_RESET __HAL_RCC_CRC_FORCE_RESET
N#define __CRC_RELEASE_RESET __HAL_RCC_CRC_RELEASE_RESET
N#define __DAC_CLK_DISABLE __HAL_RCC_DAC_CLK_DISABLE
N#define __DAC_CLK_ENABLE __HAL_RCC_DAC_CLK_ENABLE
N#define __DAC_FORCE_RESET __HAL_RCC_DAC_FORCE_RESET
N#define __DAC_RELEASE_RESET __HAL_RCC_DAC_RELEASE_RESET
N#define __DAC1_CLK_DISABLE __HAL_RCC_DAC1_CLK_DISABLE
N#define __DAC1_CLK_ENABLE __HAL_RCC_DAC1_CLK_ENABLE
N#define __DAC1_CLK_SLEEP_DISABLE __HAL_RCC_DAC1_CLK_SLEEP_DISABLE
N#define __DAC1_CLK_SLEEP_ENABLE __HAL_RCC_DAC1_CLK_SLEEP_ENABLE
N#define __DAC1_FORCE_RESET __HAL_RCC_DAC1_FORCE_RESET
N#define __DAC1_RELEASE_RESET __HAL_RCC_DAC1_RELEASE_RESET
N#define __DBGMCU_CLK_ENABLE     __HAL_RCC_DBGMCU_CLK_ENABLE
N#define __DBGMCU_CLK_DISABLE     __HAL_RCC_DBGMCU_CLK_DISABLE
N#define __DBGMCU_FORCE_RESET    __HAL_RCC_DBGMCU_FORCE_RESET
N#define __DBGMCU_RELEASE_RESET  __HAL_RCC_DBGMCU_RELEASE_RESET
N#define __DFSDM_CLK_DISABLE __HAL_RCC_DFSDM_CLK_DISABLE
N#define __DFSDM_CLK_ENABLE __HAL_RCC_DFSDM_CLK_ENABLE
N#define __DFSDM_CLK_SLEEP_DISABLE __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE
N#define __DFSDM_CLK_SLEEP_ENABLE __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE
N#define __DFSDM_FORCE_RESET __HAL_RCC_DFSDM_FORCE_RESET
N#define __DFSDM_RELEASE_RESET __HAL_RCC_DFSDM_RELEASE_RESET
N#define __DMA1_CLK_DISABLE __HAL_RCC_DMA1_CLK_DISABLE
N#define __DMA1_CLK_ENABLE __HAL_RCC_DMA1_CLK_ENABLE
N#define __DMA1_CLK_SLEEP_DISABLE __HAL_RCC_DMA1_CLK_SLEEP_DISABLE
N#define __DMA1_CLK_SLEEP_ENABLE __HAL_RCC_DMA1_CLK_SLEEP_ENABLE
N#define __DMA1_FORCE_RESET __HAL_RCC_DMA1_FORCE_RESET
N#define __DMA1_RELEASE_RESET __HAL_RCC_DMA1_RELEASE_RESET
N#define __DMA2_CLK_DISABLE __HAL_RCC_DMA2_CLK_DISABLE
N#define __DMA2_CLK_ENABLE __HAL_RCC_DMA2_CLK_ENABLE
N#define __DMA2_CLK_SLEEP_DISABLE __HAL_RCC_DMA2_CLK_SLEEP_DISABLE
N#define __DMA2_CLK_SLEEP_ENABLE __HAL_RCC_DMA2_CLK_SLEEP_ENABLE
N#define __DMA2_FORCE_RESET __HAL_RCC_DMA2_FORCE_RESET
N#define __DMA2_RELEASE_RESET __HAL_RCC_DMA2_RELEASE_RESET
N#define __ETHMAC_CLK_DISABLE __HAL_RCC_ETHMAC_CLK_DISABLE
N#define __ETHMAC_CLK_ENABLE __HAL_RCC_ETHMAC_CLK_ENABLE
N#define __ETHMAC_FORCE_RESET __HAL_RCC_ETHMAC_FORCE_RESET
N#define __ETHMAC_RELEASE_RESET __HAL_RCC_ETHMAC_RELEASE_RESET
N#define __ETHMACRX_CLK_DISABLE __HAL_RCC_ETHMACRX_CLK_DISABLE
N#define __ETHMACRX_CLK_ENABLE __HAL_RCC_ETHMACRX_CLK_ENABLE
N#define __ETHMACTX_CLK_DISABLE __HAL_RCC_ETHMACTX_CLK_DISABLE
N#define __ETHMACTX_CLK_ENABLE __HAL_RCC_ETHMACTX_CLK_ENABLE
N#define __FIREWALL_CLK_DISABLE __HAL_RCC_FIREWALL_CLK_DISABLE
N#define __FIREWALL_CLK_ENABLE __HAL_RCC_FIREWALL_CLK_ENABLE
N#define __FLASH_CLK_DISABLE __HAL_RCC_FLASH_CLK_DISABLE
N#define __FLASH_CLK_ENABLE __HAL_RCC_FLASH_CLK_ENABLE
N#define __FLASH_CLK_SLEEP_DISABLE __HAL_RCC_FLASH_CLK_SLEEP_DISABLE
N#define __FLASH_CLK_SLEEP_ENABLE __HAL_RCC_FLASH_CLK_SLEEP_ENABLE
N#define __FLASH_FORCE_RESET __HAL_RCC_FLASH_FORCE_RESET
N#define __FLASH_RELEASE_RESET __HAL_RCC_FLASH_RELEASE_RESET
N#define __FLITF_CLK_DISABLE       __HAL_RCC_FLITF_CLK_DISABLE
N#define __FLITF_CLK_ENABLE        __HAL_RCC_FLITF_CLK_ENABLE
N#define __FLITF_FORCE_RESET       __HAL_RCC_FLITF_FORCE_RESET
N#define __FLITF_RELEASE_RESET     __HAL_RCC_FLITF_RELEASE_RESET
N#define __FLITF_CLK_SLEEP_ENABLE  __HAL_RCC_FLITF_CLK_SLEEP_ENABLE
N#define __FLITF_CLK_SLEEP_DISABLE __HAL_RCC_FLITF_CLK_SLEEP_DISABLE
N#define __FMC_CLK_DISABLE __HAL_RCC_FMC_CLK_DISABLE
N#define __FMC_CLK_ENABLE __HAL_RCC_FMC_CLK_ENABLE
N#define __FMC_CLK_SLEEP_DISABLE __HAL_RCC_FMC_CLK_SLEEP_DISABLE
N#define __FMC_CLK_SLEEP_ENABLE __HAL_RCC_FMC_CLK_SLEEP_ENABLE
N#define __FMC_FORCE_RESET __HAL_RCC_FMC_FORCE_RESET
N#define __FMC_RELEASE_RESET __HAL_RCC_FMC_RELEASE_RESET
N#define __FSMC_CLK_DISABLE __HAL_RCC_FSMC_CLK_DISABLE
N#define __FSMC_CLK_ENABLE __HAL_RCC_FSMC_CLK_ENABLE
N#define __GPIOA_CLK_DISABLE __HAL_RCC_GPIOA_CLK_DISABLE
N#define __GPIOA_CLK_ENABLE __HAL_RCC_GPIOA_CLK_ENABLE
N#define __GPIOA_CLK_SLEEP_DISABLE __HAL_RCC_GPIOA_CLK_SLEEP_DISABLE
N#define __GPIOA_CLK_SLEEP_ENABLE __HAL_RCC_GPIOA_CLK_SLEEP_ENABLE
N#define __GPIOA_FORCE_RESET __HAL_RCC_GPIOA_FORCE_RESET
N#define __GPIOA_RELEASE_RESET __HAL_RCC_GPIOA_RELEASE_RESET
N#define __GPIOB_CLK_DISABLE __HAL_RCC_GPIOB_CLK_DISABLE
N#define __GPIOB_CLK_ENABLE __HAL_RCC_GPIOB_CLK_ENABLE
N#define __GPIOB_CLK_SLEEP_DISABLE __HAL_RCC_GPIOB_CLK_SLEEP_DISABLE
N#define __GPIOB_CLK_SLEEP_ENABLE __HAL_RCC_GPIOB_CLK_SLEEP_ENABLE
N#define __GPIOB_FORCE_RESET __HAL_RCC_GPIOB_FORCE_RESET
N#define __GPIOB_RELEASE_RESET __HAL_RCC_GPIOB_RELEASE_RESET
N#define __GPIOC_CLK_DISABLE __HAL_RCC_GPIOC_CLK_DISABLE
N#define __GPIOC_CLK_ENABLE __HAL_RCC_GPIOC_CLK_ENABLE
N#define __GPIOC_CLK_SLEEP_DISABLE __HAL_RCC_GPIOC_CLK_SLEEP_DISABLE
N#define __GPIOC_CLK_SLEEP_ENABLE __HAL_RCC_GPIOC_CLK_SLEEP_ENABLE
N#define __GPIOC_FORCE_RESET __HAL_RCC_GPIOC_FORCE_RESET
N#define __GPIOC_RELEASE_RESET __HAL_RCC_GPIOC_RELEASE_RESET
N#define __GPIOD_CLK_DISABLE __HAL_RCC_GPIOD_CLK_DISABLE
N#define __GPIOD_CLK_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE
N#define __GPIOD_CLK_SLEEP_DISABLE __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE
N#define __GPIOD_CLK_SLEEP_ENABLE __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE
N#define __GPIOD_FORCE_RESET __HAL_RCC_GPIOD_FORCE_RESET
N#define __GPIOD_RELEASE_RESET __HAL_RCC_GPIOD_RELEASE_RESET
N#define __GPIOE_CLK_DISABLE __HAL_RCC_GPIOE_CLK_DISABLE
N#define __GPIOE_CLK_ENABLE __HAL_RCC_GPIOE_CLK_ENABLE
N#define __GPIOE_CLK_SLEEP_DISABLE __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE
N#define __GPIOE_CLK_SLEEP_ENABLE __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE
N#define __GPIOE_FORCE_RESET __HAL_RCC_GPIOE_FORCE_RESET
N#define __GPIOE_RELEASE_RESET __HAL_RCC_GPIOE_RELEASE_RESET
N#define __GPIOF_CLK_DISABLE __HAL_RCC_GPIOF_CLK_DISABLE
N#define __GPIOF_CLK_ENABLE __HAL_RCC_GPIOF_CLK_ENABLE
N#define __GPIOF_CLK_SLEEP_DISABLE __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE
N#define __GPIOF_CLK_SLEEP_ENABLE __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE
N#define __GPIOF_FORCE_RESET __HAL_RCC_GPIOF_FORCE_RESET
N#define __GPIOF_RELEASE_RESET __HAL_RCC_GPIOF_RELEASE_RESET
N#define __GPIOG_CLK_DISABLE __HAL_RCC_GPIOG_CLK_DISABLE
N#define __GPIOG_CLK_ENABLE __HAL_RCC_GPIOG_CLK_ENABLE
N#define __GPIOG_CLK_SLEEP_DISABLE __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE
N#define __GPIOG_CLK_SLEEP_ENABLE __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE
N#define __GPIOG_FORCE_RESET __HAL_RCC_GPIOG_FORCE_RESET
N#define __GPIOG_RELEASE_RESET __HAL_RCC_GPIOG_RELEASE_RESET
N#define __GPIOH_CLK_DISABLE __HAL_RCC_GPIOH_CLK_DISABLE
N#define __GPIOH_CLK_ENABLE __HAL_RCC_GPIOH_CLK_ENABLE
N#define __GPIOH_CLK_SLEEP_DISABLE __HAL_RCC_GPIOH_CLK_SLEEP_DISABLE
N#define __GPIOH_CLK_SLEEP_ENABLE __HAL_RCC_GPIOH_CLK_SLEEP_ENABLE
N#define __GPIOH_FORCE_RESET __HAL_RCC_GPIOH_FORCE_RESET
N#define __GPIOH_RELEASE_RESET __HAL_RCC_GPIOH_RELEASE_RESET
N#define __I2C1_CLK_DISABLE __HAL_RCC_I2C1_CLK_DISABLE
N#define __I2C1_CLK_ENABLE __HAL_RCC_I2C1_CLK_ENABLE
N#define __I2C1_CLK_SLEEP_DISABLE __HAL_RCC_I2C1_CLK_SLEEP_DISABLE
N#define __I2C1_CLK_SLEEP_ENABLE __HAL_RCC_I2C1_CLK_SLEEP_ENABLE
N#define __I2C1_FORCE_RESET __HAL_RCC_I2C1_FORCE_RESET
N#define __I2C1_RELEASE_RESET __HAL_RCC_I2C1_RELEASE_RESET
N#define __I2C2_CLK_DISABLE __HAL_RCC_I2C2_CLK_DISABLE
N#define __I2C2_CLK_ENABLE __HAL_RCC_I2C2_CLK_ENABLE
N#define __I2C2_CLK_SLEEP_DISABLE __HAL_RCC_I2C2_CLK_SLEEP_DISABLE
N#define __I2C2_CLK_SLEEP_ENABLE __HAL_RCC_I2C2_CLK_SLEEP_ENABLE
N#define __I2C2_FORCE_RESET __HAL_RCC_I2C2_FORCE_RESET
N#define __I2C2_RELEASE_RESET __HAL_RCC_I2C2_RELEASE_RESET
N#define __I2C3_CLK_DISABLE __HAL_RCC_I2C3_CLK_DISABLE
N#define __I2C3_CLK_ENABLE __HAL_RCC_I2C3_CLK_ENABLE
N#define __I2C3_CLK_SLEEP_DISABLE __HAL_RCC_I2C3_CLK_SLEEP_DISABLE
N#define __I2C3_CLK_SLEEP_ENABLE __HAL_RCC_I2C3_CLK_SLEEP_ENABLE
N#define __I2C3_FORCE_RESET __HAL_RCC_I2C3_FORCE_RESET
N#define __I2C3_RELEASE_RESET __HAL_RCC_I2C3_RELEASE_RESET
N#define __LCD_CLK_DISABLE __HAL_RCC_LCD_CLK_DISABLE
N#define __LCD_CLK_ENABLE __HAL_RCC_LCD_CLK_ENABLE
N#define __LCD_CLK_SLEEP_DISABLE __HAL_RCC_LCD_CLK_SLEEP_DISABLE
N#define __LCD_CLK_SLEEP_ENABLE __HAL_RCC_LCD_CLK_SLEEP_ENABLE
N#define __LCD_FORCE_RESET __HAL_RCC_LCD_FORCE_RESET
N#define __LCD_RELEASE_RESET __HAL_RCC_LCD_RELEASE_RESET
N#define __LPTIM1_CLK_DISABLE __HAL_RCC_LPTIM1_CLK_DISABLE
N#define __LPTIM1_CLK_ENABLE __HAL_RCC_LPTIM1_CLK_ENABLE
N#define __LPTIM1_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE
N#define __LPTIM1_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE
N#define __LPTIM1_FORCE_RESET __HAL_RCC_LPTIM1_FORCE_RESET
N#define __LPTIM1_RELEASE_RESET __HAL_RCC_LPTIM1_RELEASE_RESET
N#define __LPTIM2_CLK_DISABLE __HAL_RCC_LPTIM2_CLK_DISABLE
N#define __LPTIM2_CLK_ENABLE __HAL_RCC_LPTIM2_CLK_ENABLE
N#define __LPTIM2_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM2_CLK_SLEEP_DISABLE
N#define __LPTIM2_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM2_CLK_SLEEP_ENABLE
N#define __LPTIM2_FORCE_RESET __HAL_RCC_LPTIM2_FORCE_RESET
N#define __LPTIM2_RELEASE_RESET __HAL_RCC_LPTIM2_RELEASE_RESET
N#define __LPUART1_CLK_DISABLE __HAL_RCC_LPUART1_CLK_DISABLE
N#define __LPUART1_CLK_ENABLE __HAL_RCC_LPUART1_CLK_ENABLE
N#define __LPUART1_CLK_SLEEP_DISABLE __HAL_RCC_LPUART1_CLK_SLEEP_DISABLE
N#define __LPUART1_CLK_SLEEP_ENABLE __HAL_RCC_LPUART1_CLK_SLEEP_ENABLE
N#define __LPUART1_FORCE_RESET __HAL_RCC_LPUART1_FORCE_RESET
N#define __LPUART1_RELEASE_RESET __HAL_RCC_LPUART1_RELEASE_RESET
N#define __OPAMP_CLK_DISABLE __HAL_RCC_OPAMP_CLK_DISABLE
N#define __OPAMP_CLK_ENABLE __HAL_RCC_OPAMP_CLK_ENABLE
N#define __OPAMP_CLK_SLEEP_DISABLE __HAL_RCC_OPAMP_CLK_SLEEP_DISABLE
N#define __OPAMP_CLK_SLEEP_ENABLE __HAL_RCC_OPAMP_CLK_SLEEP_ENABLE
N#define __OPAMP_FORCE_RESET __HAL_RCC_OPAMP_FORCE_RESET
N#define __OPAMP_RELEASE_RESET __HAL_RCC_OPAMP_RELEASE_RESET
N#define __OTGFS_CLK_DISABLE __HAL_RCC_OTGFS_CLK_DISABLE
N#define __OTGFS_CLK_ENABLE __HAL_RCC_OTGFS_CLK_ENABLE
N#define __OTGFS_CLK_SLEEP_DISABLE __HAL_RCC_OTGFS_CLK_SLEEP_DISABLE
N#define __OTGFS_CLK_SLEEP_ENABLE __HAL_RCC_OTGFS_CLK_SLEEP_ENABLE
N#define __OTGFS_FORCE_RESET __HAL_RCC_OTGFS_FORCE_RESET
N#define __OTGFS_RELEASE_RESET __HAL_RCC_OTGFS_RELEASE_RESET
N#define __PWR_CLK_DISABLE __HAL_RCC_PWR_CLK_DISABLE
N#define __PWR_CLK_ENABLE __HAL_RCC_PWR_CLK_ENABLE
N#define __PWR_CLK_SLEEP_DISABLE __HAL_RCC_PWR_CLK_SLEEP_DISABLE
N#define __PWR_CLK_SLEEP_ENABLE __HAL_RCC_PWR_CLK_SLEEP_ENABLE
N#define __PWR_FORCE_RESET __HAL_RCC_PWR_FORCE_RESET
N#define __PWR_RELEASE_RESET __HAL_RCC_PWR_RELEASE_RESET
N#define __QSPI_CLK_DISABLE __HAL_RCC_QSPI_CLK_DISABLE
N#define __QSPI_CLK_ENABLE __HAL_RCC_QSPI_CLK_ENABLE
N#define __QSPI_CLK_SLEEP_DISABLE __HAL_RCC_QSPI_CLK_SLEEP_DISABLE
N#define __QSPI_CLK_SLEEP_ENABLE __HAL_RCC_QSPI_CLK_SLEEP_ENABLE
N#define __QSPI_FORCE_RESET __HAL_RCC_QSPI_FORCE_RESET
N#define __QSPI_RELEASE_RESET __HAL_RCC_QSPI_RELEASE_RESET
N
N#if defined(STM32WB)
X#if 0L
S#define __HAL_RCC_QSPI_CLK_DISABLE            __HAL_RCC_QUADSPI_CLK_DISABLE
S#define __HAL_RCC_QSPI_CLK_ENABLE             __HAL_RCC_QUADSPI_CLK_ENABLE
S#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE      __HAL_RCC_QUADSPI_CLK_SLEEP_DISABLE
S#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE       __HAL_RCC_QUADSPI_CLK_SLEEP_ENABLE
S#define __HAL_RCC_QSPI_FORCE_RESET            __HAL_RCC_QUADSPI_FORCE_RESET
S#define __HAL_RCC_QSPI_RELEASE_RESET          __HAL_RCC_QUADSPI_RELEASE_RESET
S#define __HAL_RCC_QSPI_IS_CLK_ENABLED         __HAL_RCC_QUADSPI_IS_CLK_ENABLED
S#define __HAL_RCC_QSPI_IS_CLK_DISABLED        __HAL_RCC_QUADSPI_IS_CLK_DISABLED
S#define __HAL_RCC_QSPI_IS_CLK_SLEEP_ENABLED   __HAL_RCC_QUADSPI_IS_CLK_SLEEP_ENABLED
S#define __HAL_RCC_QSPI_IS_CLK_SLEEP_DISABLED  __HAL_RCC_QUADSPI_IS_CLK_SLEEP_DISABLED
S#define QSPI_IRQHandler QUADSPI_IRQHandler
N#endif /* __HAL_RCC_QUADSPI_CLK_ENABLE */
N
N#define __RNG_CLK_DISABLE __HAL_RCC_RNG_CLK_DISABLE
N#define __RNG_CLK_ENABLE __HAL_RCC_RNG_CLK_ENABLE
N#define __RNG_CLK_SLEEP_DISABLE __HAL_RCC_RNG_CLK_SLEEP_DISABLE
N#define __RNG_CLK_SLEEP_ENABLE __HAL_RCC_RNG_CLK_SLEEP_ENABLE
N#define __RNG_FORCE_RESET __HAL_RCC_RNG_FORCE_RESET
N#define __RNG_RELEASE_RESET __HAL_RCC_RNG_RELEASE_RESET
N#define __SAI1_CLK_DISABLE __HAL_RCC_SAI1_CLK_DISABLE
N#define __SAI1_CLK_ENABLE __HAL_RCC_SAI1_CLK_ENABLE
N#define __SAI1_CLK_SLEEP_DISABLE __HAL_RCC_SAI1_CLK_SLEEP_DISABLE
N#define __SAI1_CLK_SLEEP_ENABLE __HAL_RCC_SAI1_CLK_SLEEP_ENABLE
N#define __SAI1_FORCE_RESET __HAL_RCC_SAI1_FORCE_RESET
N#define __SAI1_RELEASE_RESET __HAL_RCC_SAI1_RELEASE_RESET
N#define __SAI2_CLK_DISABLE __HAL_RCC_SAI2_CLK_DISABLE
N#define __SAI2_CLK_ENABLE __HAL_RCC_SAI2_CLK_ENABLE
N#define __SAI2_CLK_SLEEP_DISABLE __HAL_RCC_SAI2_CLK_SLEEP_DISABLE
N#define __SAI2_CLK_SLEEP_ENABLE __HAL_RCC_SAI2_CLK_SLEEP_ENABLE
N#define __SAI2_FORCE_RESET __HAL_RCC_SAI2_FORCE_RESET
N#define __SAI2_RELEASE_RESET __HAL_RCC_SAI2_RELEASE_RESET
N#define __SDIO_CLK_DISABLE __HAL_RCC_SDIO_CLK_DISABLE
N#define __SDIO_CLK_ENABLE __HAL_RCC_SDIO_CLK_ENABLE
N#define __SDMMC_CLK_DISABLE __HAL_RCC_SDMMC_CLK_DISABLE
N#define __SDMMC_CLK_ENABLE __HAL_RCC_SDMMC_CLK_ENABLE
N#define __SDMMC_CLK_SLEEP_DISABLE __HAL_RCC_SDMMC_CLK_SLEEP_DISABLE
N#define __SDMMC_CLK_SLEEP_ENABLE __HAL_RCC_SDMMC_CLK_SLEEP_ENABLE
N#define __SDMMC_FORCE_RESET __HAL_RCC_SDMMC_FORCE_RESET
N#define __SDMMC_RELEASE_RESET __HAL_RCC_SDMMC_RELEASE_RESET
N#define __SPI1_CLK_DISABLE __HAL_RCC_SPI1_CLK_DISABLE
N#define __SPI1_CLK_ENABLE __HAL_RCC_SPI1_CLK_ENABLE
N#define __SPI1_CLK_SLEEP_DISABLE __HAL_RCC_SPI1_CLK_SLEEP_DISABLE
N#define __SPI1_CLK_SLEEP_ENABLE __HAL_RCC_SPI1_CLK_SLEEP_ENABLE
N#define __SPI1_FORCE_RESET __HAL_RCC_SPI1_FORCE_RESET
N#define __SPI1_RELEASE_RESET __HAL_RCC_SPI1_RELEASE_RESET
N#define __SPI2_CLK_DISABLE __HAL_RCC_SPI2_CLK_DISABLE
N#define __SPI2_CLK_ENABLE __HAL_RCC_SPI2_CLK_ENABLE
N#define __SPI2_CLK_SLEEP_DISABLE __HAL_RCC_SPI2_CLK_SLEEP_DISABLE
N#define __SPI2_CLK_SLEEP_ENABLE __HAL_RCC_SPI2_CLK_SLEEP_ENABLE
N#define __SPI2_FORCE_RESET __HAL_RCC_SPI2_FORCE_RESET
N#define __SPI2_RELEASE_RESET __HAL_RCC_SPI2_RELEASE_RESET
N#define __SPI3_CLK_DISABLE __HAL_RCC_SPI3_CLK_DISABLE
N#define __SPI3_CLK_ENABLE __HAL_RCC_SPI3_CLK_ENABLE
N#define __SPI3_CLK_SLEEP_DISABLE __HAL_RCC_SPI3_CLK_SLEEP_DISABLE
N#define __SPI3_CLK_SLEEP_ENABLE __HAL_RCC_SPI3_CLK_SLEEP_ENABLE
N#define __SPI3_FORCE_RESET __HAL_RCC_SPI3_FORCE_RESET
N#define __SPI3_RELEASE_RESET __HAL_RCC_SPI3_RELEASE_RESET
N#define __SRAM_CLK_DISABLE __HAL_RCC_SRAM_CLK_DISABLE
N#define __SRAM_CLK_ENABLE __HAL_RCC_SRAM_CLK_ENABLE
N#define __SRAM1_CLK_SLEEP_DISABLE __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE
N#define __SRAM1_CLK_SLEEP_ENABLE __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE
N#define __SRAM2_CLK_SLEEP_DISABLE __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE
N#define __SRAM2_CLK_SLEEP_ENABLE __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE
N#define __SWPMI1_CLK_DISABLE __HAL_RCC_SWPMI1_CLK_DISABLE
N#define __SWPMI1_CLK_ENABLE __HAL_RCC_SWPMI1_CLK_ENABLE
N#define __SWPMI1_CLK_SLEEP_DISABLE __HAL_RCC_SWPMI1_CLK_SLEEP_DISABLE
N#define __SWPMI1_CLK_SLEEP_ENABLE __HAL_RCC_SWPMI1_CLK_SLEEP_ENABLE
N#define __SWPMI1_FORCE_RESET __HAL_RCC_SWPMI1_FORCE_RESET
N#define __SWPMI1_RELEASE_RESET __HAL_RCC_SWPMI1_RELEASE_RESET
N#define __SYSCFG_CLK_DISABLE __HAL_RCC_SYSCFG_CLK_DISABLE
N#define __SYSCFG_CLK_ENABLE __HAL_RCC_SYSCFG_CLK_ENABLE
N#define __SYSCFG_CLK_SLEEP_DISABLE __HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE
N#define __SYSCFG_CLK_SLEEP_ENABLE __HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE
N#define __SYSCFG_FORCE_RESET __HAL_RCC_SYSCFG_FORCE_RESET
N#define __SYSCFG_RELEASE_RESET __HAL_RCC_SYSCFG_RELEASE_RESET
N#define __TIM1_CLK_DISABLE __HAL_RCC_TIM1_CLK_DISABLE
N#define __TIM1_CLK_ENABLE __HAL_RCC_TIM1_CLK_ENABLE
N#define __TIM1_CLK_SLEEP_DISABLE __HAL_RCC_TIM1_CLK_SLEEP_DISABLE
N#define __TIM1_CLK_SLEEP_ENABLE __HAL_RCC_TIM1_CLK_SLEEP_ENABLE
N#define __TIM1_FORCE_RESET __HAL_RCC_TIM1_FORCE_RESET
N#define __TIM1_RELEASE_RESET __HAL_RCC_TIM1_RELEASE_RESET
N#define __TIM10_CLK_DISABLE __HAL_RCC_TIM10_CLK_DISABLE
N#define __TIM10_CLK_ENABLE __HAL_RCC_TIM10_CLK_ENABLE
N#define __TIM10_FORCE_RESET __HAL_RCC_TIM10_FORCE_RESET
N#define __TIM10_RELEASE_RESET __HAL_RCC_TIM10_RELEASE_RESET
N#define __TIM11_CLK_DISABLE __HAL_RCC_TIM11_CLK_DISABLE
N#define __TIM11_CLK_ENABLE __HAL_RCC_TIM11_CLK_ENABLE
N#define __TIM11_FORCE_RESET __HAL_RCC_TIM11_FORCE_RESET
N#define __TIM11_RELEASE_RESET __HAL_RCC_TIM11_RELEASE_RESET
N#define __TIM12_CLK_DISABLE __HAL_RCC_TIM12_CLK_DISABLE
N#define __TIM12_CLK_ENABLE __HAL_RCC_TIM12_CLK_ENABLE
N#define __TIM12_FORCE_RESET __HAL_RCC_TIM12_FORCE_RESET
N#define __TIM12_RELEASE_RESET __HAL_RCC_TIM12_RELEASE_RESET
N#define __TIM13_CLK_DISABLE __HAL_RCC_TIM13_CLK_DISABLE
N#define __TIM13_CLK_ENABLE __HAL_RCC_TIM13_CLK_ENABLE
N#define __TIM13_FORCE_RESET __HAL_RCC_TIM13_FORCE_RESET
N#define __TIM13_RELEASE_RESET __HAL_RCC_TIM13_RELEASE_RESET
N#define __TIM14_CLK_DISABLE __HAL_RCC_TIM14_CLK_DISABLE
N#define __TIM14_CLK_ENABLE __HAL_RCC_TIM14_CLK_ENABLE
N#define __TIM14_FORCE_RESET __HAL_RCC_TIM14_FORCE_RESET
N#define __TIM14_RELEASE_RESET __HAL_RCC_TIM14_RELEASE_RESET
N#define __TIM15_CLK_DISABLE __HAL_RCC_TIM15_CLK_DISABLE
N#define __TIM15_CLK_ENABLE __HAL_RCC_TIM15_CLK_ENABLE
N#define __TIM15_CLK_SLEEP_DISABLE __HAL_RCC_TIM15_CLK_SLEEP_DISABLE
N#define __TIM15_CLK_SLEEP_ENABLE __HAL_RCC_TIM15_CLK_SLEEP_ENABLE
N#define __TIM15_FORCE_RESET __HAL_RCC_TIM15_FORCE_RESET
N#define __TIM15_RELEASE_RESET __HAL_RCC_TIM15_RELEASE_RESET
N#define __TIM16_CLK_DISABLE __HAL_RCC_TIM16_CLK_DISABLE
N#define __TIM16_CLK_ENABLE __HAL_RCC_TIM16_CLK_ENABLE
N#define __TIM16_CLK_SLEEP_DISABLE __HAL_RCC_TIM16_CLK_SLEEP_DISABLE
N#define __TIM16_CLK_SLEEP_ENABLE __HAL_RCC_TIM16_CLK_SLEEP_ENABLE
N#define __TIM16_FORCE_RESET __HAL_RCC_TIM16_FORCE_RESET
N#define __TIM16_RELEASE_RESET __HAL_RCC_TIM16_RELEASE_RESET
N#define __TIM17_CLK_DISABLE __HAL_RCC_TIM17_CLK_DISABLE
N#define __TIM17_CLK_ENABLE __HAL_RCC_TIM17_CLK_ENABLE
N#define __TIM17_CLK_SLEEP_DISABLE __HAL_RCC_TIM17_CLK_SLEEP_DISABLE
N#define __TIM17_CLK_SLEEP_ENABLE __HAL_RCC_TIM17_CLK_SLEEP_ENABLE
N#define __TIM17_FORCE_RESET __HAL_RCC_TIM17_FORCE_RESET
N#define __TIM17_RELEASE_RESET __HAL_RCC_TIM17_RELEASE_RESET
N#define __TIM2_CLK_DISABLE __HAL_RCC_TIM2_CLK_DISABLE
N#define __TIM2_CLK_ENABLE __HAL_RCC_TIM2_CLK_ENABLE
N#define __TIM2_CLK_SLEEP_DISABLE __HAL_RCC_TIM2_CLK_SLEEP_DISABLE
N#define __TIM2_CLK_SLEEP_ENABLE __HAL_RCC_TIM2_CLK_SLEEP_ENABLE
N#define __TIM2_FORCE_RESET __HAL_RCC_TIM2_FORCE_RESET
N#define __TIM2_RELEASE_RESET __HAL_RCC_TIM2_RELEASE_RESET
N#define __TIM3_CLK_DISABLE __HAL_RCC_TIM3_CLK_DISABLE
N#define __TIM3_CLK_ENABLE __HAL_RCC_TIM3_CLK_ENABLE
N#define __TIM3_CLK_SLEEP_DISABLE __HAL_RCC_TIM3_CLK_SLEEP_DISABLE
N#define __TIM3_CLK_SLEEP_ENABLE __HAL_RCC_TIM3_CLK_SLEEP_ENABLE
N#define __TIM3_FORCE_RESET __HAL_RCC_TIM3_FORCE_RESET
N#define __TIM3_RELEASE_RESET __HAL_RCC_TIM3_RELEASE_RESET
N#define __TIM4_CLK_DISABLE __HAL_RCC_TIM4_CLK_DISABLE
N#define __TIM4_CLK_ENABLE __HAL_RCC_TIM4_CLK_ENABLE
N#define __TIM4_CLK_SLEEP_DISABLE __HAL_RCC_TIM4_CLK_SLEEP_DISABLE
N#define __TIM4_CLK_SLEEP_ENABLE __HAL_RCC_TIM4_CLK_SLEEP_ENABLE
N#define __TIM4_FORCE_RESET __HAL_RCC_TIM4_FORCE_RESET
N#define __TIM4_RELEASE_RESET __HAL_RCC_TIM4_RELEASE_RESET
N#define __TIM5_CLK_DISABLE __HAL_RCC_TIM5_CLK_DISABLE
N#define __TIM5_CLK_ENABLE __HAL_RCC_TIM5_CLK_ENABLE
N#define __TIM5_CLK_SLEEP_DISABLE __HAL_RCC_TIM5_CLK_SLEEP_DISABLE
N#define __TIM5_CLK_SLEEP_ENABLE __HAL_RCC_TIM5_CLK_SLEEP_ENABLE
N#define __TIM5_FORCE_RESET __HAL_RCC_TIM5_FORCE_RESET
N#define __TIM5_RELEASE_RESET __HAL_RCC_TIM5_RELEASE_RESET
N#define __TIM6_CLK_DISABLE __HAL_RCC_TIM6_CLK_DISABLE
N#define __TIM6_CLK_ENABLE __HAL_RCC_TIM6_CLK_ENABLE
N#define __TIM6_CLK_SLEEP_DISABLE __HAL_RCC_TIM6_CLK_SLEEP_DISABLE
N#define __TIM6_CLK_SLEEP_ENABLE __HAL_RCC_TIM6_CLK_SLEEP_ENABLE
N#define __TIM6_FORCE_RESET __HAL_RCC_TIM6_FORCE_RESET
N#define __TIM6_RELEASE_RESET __HAL_RCC_TIM6_RELEASE_RESET
N#define __TIM7_CLK_DISABLE __HAL_RCC_TIM7_CLK_DISABLE
N#define __TIM7_CLK_ENABLE __HAL_RCC_TIM7_CLK_ENABLE
N#define __TIM7_CLK_SLEEP_DISABLE __HAL_RCC_TIM7_CLK_SLEEP_DISABLE
N#define __TIM7_CLK_SLEEP_ENABLE __HAL_RCC_TIM7_CLK_SLEEP_ENABLE
N#define __TIM7_FORCE_RESET __HAL_RCC_TIM7_FORCE_RESET
N#define __TIM7_RELEASE_RESET __HAL_RCC_TIM7_RELEASE_RESET
N#define __TIM8_CLK_DISABLE __HAL_RCC_TIM8_CLK_DISABLE
N#define __TIM8_CLK_ENABLE __HAL_RCC_TIM8_CLK_ENABLE
N#define __TIM8_CLK_SLEEP_DISABLE __HAL_RCC_TIM8_CLK_SLEEP_DISABLE
N#define __TIM8_CLK_SLEEP_ENABLE __HAL_RCC_TIM8_CLK_SLEEP_ENABLE
N#define __TIM8_FORCE_RESET __HAL_RCC_TIM8_FORCE_RESET
N#define __TIM8_RELEASE_RESET __HAL_RCC_TIM8_RELEASE_RESET
N#define __TIM9_CLK_DISABLE __HAL_RCC_TIM9_CLK_DISABLE
N#define __TIM9_CLK_ENABLE __HAL_RCC_TIM9_CLK_ENABLE
N#define __TIM9_FORCE_RESET __HAL_RCC_TIM9_FORCE_RESET
N#define __TIM9_RELEASE_RESET __HAL_RCC_TIM9_RELEASE_RESET
N#define __TSC_CLK_DISABLE __HAL_RCC_TSC_CLK_DISABLE
N#define __TSC_CLK_ENABLE __HAL_RCC_TSC_CLK_ENABLE
N#define __TSC_CLK_SLEEP_DISABLE __HAL_RCC_TSC_CLK_SLEEP_DISABLE
N#define __TSC_CLK_SLEEP_ENABLE __HAL_RCC_TSC_CLK_SLEEP_ENABLE
N#define __TSC_FORCE_RESET __HAL_RCC_TSC_FORCE_RESET
N#define __TSC_RELEASE_RESET __HAL_RCC_TSC_RELEASE_RESET
N#define __UART4_CLK_DISABLE __HAL_RCC_UART4_CLK_DISABLE
N#define __UART4_CLK_ENABLE __HAL_RCC_UART4_CLK_ENABLE
N#define __UART4_CLK_SLEEP_DISABLE __HAL_RCC_UART4_CLK_SLEEP_DISABLE
N#define __UART4_CLK_SLEEP_ENABLE __HAL_RCC_UART4_CLK_SLEEP_ENABLE
N#define __UART4_FORCE_RESET __HAL_RCC_UART4_FORCE_RESET
N#define __UART4_RELEASE_RESET __HAL_RCC_UART4_RELEASE_RESET
N#define __UART5_CLK_DISABLE __HAL_RCC_UART5_CLK_DISABLE
N#define __UART5_CLK_ENABLE __HAL_RCC_UART5_CLK_ENABLE
N#define __UART5_CLK_SLEEP_DISABLE __HAL_RCC_UART5_CLK_SLEEP_DISABLE
N#define __UART5_CLK_SLEEP_ENABLE __HAL_RCC_UART5_CLK_SLEEP_ENABLE
N#define __UART5_FORCE_RESET __HAL_RCC_UART5_FORCE_RESET
N#define __UART5_RELEASE_RESET __HAL_RCC_UART5_RELEASE_RESET
N#define __USART1_CLK_DISABLE __HAL_RCC_USART1_CLK_DISABLE
N#define __USART1_CLK_ENABLE __HAL_RCC_USART1_CLK_ENABLE
N#define __USART1_CLK_SLEEP_DISABLE __HAL_RCC_USART1_CLK_SLEEP_DISABLE
N#define __USART1_CLK_SLEEP_ENABLE __HAL_RCC_USART1_CLK_SLEEP_ENABLE
N#define __USART1_FORCE_RESET __HAL_RCC_USART1_FORCE_RESET
N#define __USART1_RELEASE_RESET __HAL_RCC_USART1_RELEASE_RESET
N#define __USART2_CLK_DISABLE __HAL_RCC_USART2_CLK_DISABLE
N#define __USART2_CLK_ENABLE __HAL_RCC_USART2_CLK_ENABLE
N#define __USART2_CLK_SLEEP_DISABLE __HAL_RCC_USART2_CLK_SLEEP_DISABLE
N#define __USART2_CLK_SLEEP_ENABLE __HAL_RCC_USART2_CLK_SLEEP_ENABLE
N#define __USART2_FORCE_RESET __HAL_RCC_USART2_FORCE_RESET
N#define __USART2_RELEASE_RESET __HAL_RCC_USART2_RELEASE_RESET
N#define __USART3_CLK_DISABLE __HAL_RCC_USART3_CLK_DISABLE
N#define __USART3_CLK_ENABLE __HAL_RCC_USART3_CLK_ENABLE
N#define __USART3_CLK_SLEEP_DISABLE __HAL_RCC_USART3_CLK_SLEEP_DISABLE
N#define __USART3_CLK_SLEEP_ENABLE __HAL_RCC_USART3_CLK_SLEEP_ENABLE
N#define __USART3_FORCE_RESET __HAL_RCC_USART3_FORCE_RESET
N#define __USART3_RELEASE_RESET __HAL_RCC_USART3_RELEASE_RESET
N#define __USART4_CLK_DISABLE        __HAL_RCC_UART4_CLK_DISABLE
N#define __USART4_CLK_ENABLE         __HAL_RCC_UART4_CLK_ENABLE
N#define __USART4_CLK_SLEEP_ENABLE   __HAL_RCC_UART4_CLK_SLEEP_ENABLE
N#define __USART4_CLK_SLEEP_DISABLE  __HAL_RCC_UART4_CLK_SLEEP_DISABLE
N#define __USART4_FORCE_RESET        __HAL_RCC_UART4_FORCE_RESET
N#define __USART4_RELEASE_RESET      __HAL_RCC_UART4_RELEASE_RESET
N#define __USART5_CLK_DISABLE        __HAL_RCC_UART5_CLK_DISABLE
N#define __USART5_CLK_ENABLE         __HAL_RCC_UART5_CLK_ENABLE
N#define __USART5_CLK_SLEEP_ENABLE   __HAL_RCC_UART5_CLK_SLEEP_ENABLE
N#define __USART5_CLK_SLEEP_DISABLE  __HAL_RCC_UART5_CLK_SLEEP_DISABLE
N#define __USART5_FORCE_RESET        __HAL_RCC_UART5_FORCE_RESET
N#define __USART5_RELEASE_RESET      __HAL_RCC_UART5_RELEASE_RESET
N#define __USART7_CLK_DISABLE        __HAL_RCC_UART7_CLK_DISABLE
N#define __USART7_CLK_ENABLE         __HAL_RCC_UART7_CLK_ENABLE
N#define __USART7_FORCE_RESET        __HAL_RCC_UART7_FORCE_RESET
N#define __USART7_RELEASE_RESET      __HAL_RCC_UART7_RELEASE_RESET
N#define __USART8_CLK_DISABLE        __HAL_RCC_UART8_CLK_DISABLE
N#define __USART8_CLK_ENABLE         __HAL_RCC_UART8_CLK_ENABLE
N#define __USART8_FORCE_RESET        __HAL_RCC_UART8_FORCE_RESET
N#define __USART8_RELEASE_RESET      __HAL_RCC_UART8_RELEASE_RESET
N#define __USB_CLK_DISABLE         __HAL_RCC_USB_CLK_DISABLE
N#define __USB_CLK_ENABLE          __HAL_RCC_USB_CLK_ENABLE
N#define __USB_FORCE_RESET         __HAL_RCC_USB_FORCE_RESET
N#define __USB_CLK_SLEEP_ENABLE    __HAL_RCC_USB_CLK_SLEEP_ENABLE
N#define __USB_CLK_SLEEP_DISABLE   __HAL_RCC_USB_CLK_SLEEP_DISABLE
N#define __USB_OTG_FS_CLK_DISABLE __HAL_RCC_USB_OTG_FS_CLK_DISABLE
N#define __USB_OTG_FS_CLK_ENABLE __HAL_RCC_USB_OTG_FS_CLK_ENABLE
N#define __USB_RELEASE_RESET __HAL_RCC_USB_RELEASE_RESET
N
N#if defined(STM32H7)
X#if 0L
S#define __HAL_RCC_WWDG_CLK_DISABLE   __HAL_RCC_WWDG1_CLK_DISABLE
S#define __HAL_RCC_WWDG_CLK_ENABLE   __HAL_RCC_WWDG1_CLK_ENABLE
S#define __HAL_RCC_WWDG_CLK_SLEEP_DISABLE  __HAL_RCC_WWDG1_CLK_SLEEP_DISABLE
S#define __HAL_RCC_WWDG_CLK_SLEEP_ENABLE  __HAL_RCC_WWDG1_CLK_SLEEP_ENABLE
S
S#define __HAL_RCC_WWDG_FORCE_RESET    ((void)0U)  /* Not available on the STM32H7*/
S#define __HAL_RCC_WWDG_RELEASE_RESET ((void)0U) /* Not available on the STM32H7*/
S
S
S#define  __HAL_RCC_WWDG_IS_CLK_ENABLED    __HAL_RCC_WWDG1_IS_CLK_ENABLED
S#define  __HAL_RCC_WWDG_IS_CLK_DISABLED  __HAL_RCC_WWDG1_IS_CLK_DISABLED
N#endif
N
N#define __WWDG_CLK_DISABLE __HAL_RCC_WWDG_CLK_DISABLE
N#define __WWDG_CLK_ENABLE __HAL_RCC_WWDG_CLK_ENABLE
N#define __WWDG_CLK_SLEEP_DISABLE __HAL_RCC_WWDG_CLK_SLEEP_DISABLE
N#define __WWDG_CLK_SLEEP_ENABLE __HAL_RCC_WWDG_CLK_SLEEP_ENABLE
N#define __WWDG_FORCE_RESET __HAL_RCC_WWDG_FORCE_RESET
N#define __WWDG_RELEASE_RESET __HAL_RCC_WWDG_RELEASE_RESET
N
N#define __TIM21_CLK_ENABLE   __HAL_RCC_TIM21_CLK_ENABLE
N#define __TIM21_CLK_DISABLE   __HAL_RCC_TIM21_CLK_DISABLE
N#define __TIM21_FORCE_RESET   __HAL_RCC_TIM21_FORCE_RESET
N#define __TIM21_RELEASE_RESET  __HAL_RCC_TIM21_RELEASE_RESET
N#define __TIM21_CLK_SLEEP_ENABLE   __HAL_RCC_TIM21_CLK_SLEEP_ENABLE
N#define __TIM21_CLK_SLEEP_DISABLE   __HAL_RCC_TIM21_CLK_SLEEP_DISABLE
N#define __TIM22_CLK_ENABLE   __HAL_RCC_TIM22_CLK_ENABLE
N#define __TIM22_CLK_DISABLE   __HAL_RCC_TIM22_CLK_DISABLE
N#define __TIM22_FORCE_RESET   __HAL_RCC_TIM22_FORCE_RESET
N#define __TIM22_RELEASE_RESET  __HAL_RCC_TIM22_RELEASE_RESET
N#define __TIM22_CLK_SLEEP_ENABLE   __HAL_RCC_TIM22_CLK_SLEEP_ENABLE
N#define __TIM22_CLK_SLEEP_DISABLE   __HAL_RCC_TIM22_CLK_SLEEP_DISABLE
N#define __CRS_CLK_DISABLE __HAL_RCC_CRS_CLK_DISABLE
N#define __CRS_CLK_ENABLE __HAL_RCC_CRS_CLK_ENABLE
N#define __CRS_CLK_SLEEP_DISABLE __HAL_RCC_CRS_CLK_SLEEP_DISABLE
N#define __CRS_CLK_SLEEP_ENABLE __HAL_RCC_CRS_CLK_SLEEP_ENABLE
N#define __CRS_FORCE_RESET __HAL_RCC_CRS_FORCE_RESET
N#define __CRS_RELEASE_RESET __HAL_RCC_CRS_RELEASE_RESET
N#define __RCC_BACKUPRESET_FORCE __HAL_RCC_BACKUPRESET_FORCE
N#define __RCC_BACKUPRESET_RELEASE __HAL_RCC_BACKUPRESET_RELEASE
N
N#define __USB_OTG_FS_FORCE_RESET  __HAL_RCC_USB_OTG_FS_FORCE_RESET
N#define __USB_OTG_FS_RELEASE_RESET  __HAL_RCC_USB_OTG_FS_RELEASE_RESET
N#define __USB_OTG_FS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE
N#define __USB_OTG_FS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE
N#define __USB_OTG_HS_CLK_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_DISABLE
N#define __USB_OTG_HS_CLK_ENABLE          __HAL_RCC_USB_OTG_HS_CLK_ENABLE
N#define __USB_OTG_HS_ULPI_CLK_ENABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE
N#define __USB_OTG_HS_ULPI_CLK_DISABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE
N#define __TIM9_CLK_SLEEP_ENABLE          __HAL_RCC_TIM9_CLK_SLEEP_ENABLE
N#define __TIM9_CLK_SLEEP_DISABLE  __HAL_RCC_TIM9_CLK_SLEEP_DISABLE
N#define __TIM10_CLK_SLEEP_ENABLE  __HAL_RCC_TIM10_CLK_SLEEP_ENABLE
N#define __TIM10_CLK_SLEEP_DISABLE  __HAL_RCC_TIM10_CLK_SLEEP_DISABLE
N#define __TIM11_CLK_SLEEP_ENABLE  __HAL_RCC_TIM11_CLK_SLEEP_ENABLE
N#define __TIM11_CLK_SLEEP_DISABLE  __HAL_RCC_TIM11_CLK_SLEEP_DISABLE
N#define __ETHMACPTP_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE
N#define __ETHMACPTP_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE
N#define __ETHMACPTP_CLK_ENABLE          __HAL_RCC_ETHMACPTP_CLK_ENABLE
N#define __ETHMACPTP_CLK_DISABLE          __HAL_RCC_ETHMACPTP_CLK_DISABLE
N#define __HASH_CLK_ENABLE          __HAL_RCC_HASH_CLK_ENABLE
N#define __HASH_FORCE_RESET          __HAL_RCC_HASH_FORCE_RESET
N#define __HASH_RELEASE_RESET          __HAL_RCC_HASH_RELEASE_RESET
N#define __HASH_CLK_SLEEP_ENABLE          __HAL_RCC_HASH_CLK_SLEEP_ENABLE
N#define __HASH_CLK_SLEEP_DISABLE  __HAL_RCC_HASH_CLK_SLEEP_DISABLE
N#define __HASH_CLK_DISABLE            __HAL_RCC_HASH_CLK_DISABLE
N#define __SPI5_CLK_ENABLE          __HAL_RCC_SPI5_CLK_ENABLE
N#define __SPI5_CLK_DISABLE              __HAL_RCC_SPI5_CLK_DISABLE
N#define __SPI5_FORCE_RESET          __HAL_RCC_SPI5_FORCE_RESET
N#define __SPI5_RELEASE_RESET          __HAL_RCC_SPI5_RELEASE_RESET
N#define __SPI5_CLK_SLEEP_ENABLE          __HAL_RCC_SPI5_CLK_SLEEP_ENABLE
N#define __SPI5_CLK_SLEEP_DISABLE  __HAL_RCC_SPI5_CLK_SLEEP_DISABLE
N#define __SPI6_CLK_ENABLE          __HAL_RCC_SPI6_CLK_ENABLE
N#define __SPI6_CLK_DISABLE          __HAL_RCC_SPI6_CLK_DISABLE
N#define __SPI6_FORCE_RESET          __HAL_RCC_SPI6_FORCE_RESET
N#define __SPI6_RELEASE_RESET         __HAL_RCC_SPI6_RELEASE_RESET
N#define __SPI6_CLK_SLEEP_ENABLE          __HAL_RCC_SPI6_CLK_SLEEP_ENABLE
N#define __SPI6_CLK_SLEEP_DISABLE  __HAL_RCC_SPI6_CLK_SLEEP_DISABLE
N#define __LTDC_CLK_ENABLE          __HAL_RCC_LTDC_CLK_ENABLE
N#define __LTDC_CLK_DISABLE          __HAL_RCC_LTDC_CLK_DISABLE
N#define __LTDC_FORCE_RESET          __HAL_RCC_LTDC_FORCE_RESET
N#define __LTDC_RELEASE_RESET          __HAL_RCC_LTDC_RELEASE_RESET
N#define __LTDC_CLK_SLEEP_ENABLE          __HAL_RCC_LTDC_CLK_SLEEP_ENABLE
N#define __ETHMAC_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE
N#define __ETHMAC_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE
N#define __ETHMACTX_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE
N#define __ETHMACTX_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE
N#define __ETHMACRX_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE
N#define __ETHMACRX_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE
N#define __TIM12_CLK_SLEEP_ENABLE  __HAL_RCC_TIM12_CLK_SLEEP_ENABLE
N#define __TIM12_CLK_SLEEP_DISABLE  __HAL_RCC_TIM12_CLK_SLEEP_DISABLE
N#define __TIM13_CLK_SLEEP_ENABLE  __HAL_RCC_TIM13_CLK_SLEEP_ENABLE
N#define __TIM13_CLK_SLEEP_DISABLE  __HAL_RCC_TIM13_CLK_SLEEP_DISABLE
N#define __TIM14_CLK_SLEEP_ENABLE  __HAL_RCC_TIM14_CLK_SLEEP_ENABLE
N#define __TIM14_CLK_SLEEP_DISABLE  __HAL_RCC_TIM14_CLK_SLEEP_DISABLE
N#define __BKPSRAM_CLK_ENABLE          __HAL_RCC_BKPSRAM_CLK_ENABLE
N#define __BKPSRAM_CLK_DISABLE          __HAL_RCC_BKPSRAM_CLK_DISABLE
N#define __BKPSRAM_CLK_SLEEP_ENABLE  __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE
N#define __BKPSRAM_CLK_SLEEP_DISABLE  __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE
N#define __CCMDATARAMEN_CLK_ENABLE  __HAL_RCC_CCMDATARAMEN_CLK_ENABLE
N#define __CCMDATARAMEN_CLK_DISABLE  __HAL_RCC_CCMDATARAMEN_CLK_DISABLE
N#define __USART6_CLK_ENABLE          __HAL_RCC_USART6_CLK_ENABLE
N#define __USART6_CLK_DISABLE          __HAL_RCC_USART6_CLK_DISABLE
N#define __USART6_FORCE_RESET        __HAL_RCC_USART6_FORCE_RESET
N#define __USART6_RELEASE_RESET        __HAL_RCC_USART6_RELEASE_RESET
N#define __USART6_CLK_SLEEP_ENABLE  __HAL_RCC_USART6_CLK_SLEEP_ENABLE
N#define __USART6_CLK_SLEEP_DISABLE  __HAL_RCC_USART6_CLK_SLEEP_DISABLE
N#define __SPI4_CLK_ENABLE          __HAL_RCC_SPI4_CLK_ENABLE
N#define __SPI4_CLK_DISABLE          __HAL_RCC_SPI4_CLK_DISABLE
N#define __SPI4_FORCE_RESET          __HAL_RCC_SPI4_FORCE_RESET
N#define __SPI4_RELEASE_RESET        __HAL_RCC_SPI4_RELEASE_RESET
N#define __SPI4_CLK_SLEEP_ENABLE   __HAL_RCC_SPI4_CLK_SLEEP_ENABLE
N#define __SPI4_CLK_SLEEP_DISABLE  __HAL_RCC_SPI4_CLK_SLEEP_DISABLE
N#define __GPIOI_CLK_ENABLE          __HAL_RCC_GPIOI_CLK_ENABLE
N#define __GPIOI_CLK_DISABLE          __HAL_RCC_GPIOI_CLK_DISABLE
N#define __GPIOI_FORCE_RESET          __HAL_RCC_GPIOI_FORCE_RESET
N#define __GPIOI_RELEASE_RESET          __HAL_RCC_GPIOI_RELEASE_RESET
N#define __GPIOI_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE
N#define __GPIOI_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE
N#define __GPIOJ_CLK_ENABLE          __HAL_RCC_GPIOJ_CLK_ENABLE
N#define __GPIOJ_CLK_DISABLE          __HAL_RCC_GPIOJ_CLK_DISABLE
N#define __GPIOJ_FORCE_RESET         __HAL_RCC_GPIOJ_FORCE_RESET
N#define __GPIOJ_RELEASE_RESET          __HAL_RCC_GPIOJ_RELEASE_RESET
N#define __GPIOJ_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE
N#define __GPIOJ_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE
N#define __GPIOK_CLK_ENABLE          __HAL_RCC_GPIOK_CLK_ENABLE
N#define __GPIOK_CLK_DISABLE          __HAL_RCC_GPIOK_CLK_DISABLE
N#define __GPIOK_RELEASE_RESET          __HAL_RCC_GPIOK_RELEASE_RESET
N#define __GPIOK_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOK_CLK_SLEEP_ENABLE
N#define __GPIOK_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOK_CLK_SLEEP_DISABLE
N#define __ETH_CLK_ENABLE          __HAL_RCC_ETH_CLK_ENABLE
N#define __ETH_CLK_DISABLE          __HAL_RCC_ETH_CLK_DISABLE
N#define __DCMI_CLK_ENABLE          __HAL_RCC_DCMI_CLK_ENABLE
N#define __DCMI_CLK_DISABLE          __HAL_RCC_DCMI_CLK_DISABLE
N#define __DCMI_FORCE_RESET          __HAL_RCC_DCMI_FORCE_RESET
N#define __DCMI_RELEASE_RESET          __HAL_RCC_DCMI_RELEASE_RESET
N#define __DCMI_CLK_SLEEP_ENABLE   __HAL_RCC_DCMI_CLK_SLEEP_ENABLE
N#define __DCMI_CLK_SLEEP_DISABLE  __HAL_RCC_DCMI_CLK_SLEEP_DISABLE
N#define __UART7_CLK_ENABLE          __HAL_RCC_UART7_CLK_ENABLE
N#define __UART7_CLK_DISABLE          __HAL_RCC_UART7_CLK_DISABLE
N#define __UART7_RELEASE_RESET       __HAL_RCC_UART7_RELEASE_RESET
N#define __UART7_FORCE_RESET       __HAL_RCC_UART7_FORCE_RESET
N#define __UART7_CLK_SLEEP_ENABLE  __HAL_RCC_UART7_CLK_SLEEP_ENABLE
N#define __UART7_CLK_SLEEP_DISABLE  __HAL_RCC_UART7_CLK_SLEEP_DISABLE
N#define __UART8_CLK_ENABLE          __HAL_RCC_UART8_CLK_ENABLE
N#define __UART8_CLK_DISABLE          __HAL_RCC_UART8_CLK_DISABLE
N#define __UART8_FORCE_RESET          __HAL_RCC_UART8_FORCE_RESET
N#define __UART8_RELEASE_RESET          __HAL_RCC_UART8_RELEASE_RESET
N#define __UART8_CLK_SLEEP_ENABLE  __HAL_RCC_UART8_CLK_SLEEP_ENABLE
N#define __UART8_CLK_SLEEP_DISABLE  __HAL_RCC_UART8_CLK_SLEEP_DISABLE
N#define __OTGHS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
N#define __OTGHS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE
N#define __OTGHS_FORCE_RESET          __HAL_RCC_USB_OTG_HS_FORCE_RESET
N#define __OTGHS_RELEASE_RESET          __HAL_RCC_USB_OTG_HS_RELEASE_RESET
N#define __OTGHSULPI_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
N#define __OTGHSULPI_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE
N#define __HAL_RCC_OTGHS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
N#define __HAL_RCC_OTGHS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE
N#define __HAL_RCC_OTGHS_IS_CLK_SLEEP_ENABLED __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_ENABLED
N#define __HAL_RCC_OTGHS_IS_CLK_SLEEP_DISABLED __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_DISABLED
N#define __HAL_RCC_OTGHS_FORCE_RESET          __HAL_RCC_USB_OTG_HS_FORCE_RESET
N#define __HAL_RCC_OTGHS_RELEASE_RESET          __HAL_RCC_USB_OTG_HS_RELEASE_RESET
N#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_ENABLE      __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
N#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_DISABLE     __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE
N#define __HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_ENABLED  __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_ENABLED
N#define __HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_DISABLED __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_DISABLED
N#define __SRAM3_CLK_SLEEP_ENABLE       __HAL_RCC_SRAM3_CLK_SLEEP_ENABLE
N#define __CAN2_CLK_SLEEP_ENABLE        __HAL_RCC_CAN2_CLK_SLEEP_ENABLE
N#define __CAN2_CLK_SLEEP_DISABLE       __HAL_RCC_CAN2_CLK_SLEEP_DISABLE
N#define __DAC_CLK_SLEEP_ENABLE         __HAL_RCC_DAC_CLK_SLEEP_ENABLE
N#define __DAC_CLK_SLEEP_DISABLE        __HAL_RCC_DAC_CLK_SLEEP_DISABLE
N#define __ADC2_CLK_SLEEP_ENABLE        __HAL_RCC_ADC2_CLK_SLEEP_ENABLE
N#define __ADC2_CLK_SLEEP_DISABLE       __HAL_RCC_ADC2_CLK_SLEEP_DISABLE
N#define __ADC3_CLK_SLEEP_ENABLE        __HAL_RCC_ADC3_CLK_SLEEP_ENABLE
N#define __ADC3_CLK_SLEEP_DISABLE       __HAL_RCC_ADC3_CLK_SLEEP_DISABLE
N#define __FSMC_FORCE_RESET             __HAL_RCC_FSMC_FORCE_RESET
N#define __FSMC_RELEASE_RESET           __HAL_RCC_FSMC_RELEASE_RESET
N#define __FSMC_CLK_SLEEP_ENABLE        __HAL_RCC_FSMC_CLK_SLEEP_ENABLE
N#define __FSMC_CLK_SLEEP_DISABLE       __HAL_RCC_FSMC_CLK_SLEEP_DISABLE
N#define __SDIO_FORCE_RESET             __HAL_RCC_SDIO_FORCE_RESET
N#define __SDIO_RELEASE_RESET           __HAL_RCC_SDIO_RELEASE_RESET
N#define __SDIO_CLK_SLEEP_DISABLE       __HAL_RCC_SDIO_CLK_SLEEP_DISABLE
N#define __SDIO_CLK_SLEEP_ENABLE        __HAL_RCC_SDIO_CLK_SLEEP_ENABLE
N#define __DMA2D_CLK_ENABLE             __HAL_RCC_DMA2D_CLK_ENABLE
N#define __DMA2D_CLK_DISABLE            __HAL_RCC_DMA2D_CLK_DISABLE
N#define __DMA2D_FORCE_RESET            __HAL_RCC_DMA2D_FORCE_RESET
N#define __DMA2D_RELEASE_RESET          __HAL_RCC_DMA2D_RELEASE_RESET
N#define __DMA2D_CLK_SLEEP_ENABLE       __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE
N#define __DMA2D_CLK_SLEEP_DISABLE      __HAL_RCC_DMA2D_CLK_SLEEP_DISABLE
N
N/* alias define maintained for legacy */
N#define __HAL_RCC_OTGFS_FORCE_RESET    __HAL_RCC_USB_OTG_FS_FORCE_RESET
N#define __HAL_RCC_OTGFS_RELEASE_RESET  __HAL_RCC_USB_OTG_FS_RELEASE_RESET
N
N#define __ADC12_CLK_ENABLE          __HAL_RCC_ADC12_CLK_ENABLE
N#define __ADC12_CLK_DISABLE         __HAL_RCC_ADC12_CLK_DISABLE
N#define __ADC34_CLK_ENABLE          __HAL_RCC_ADC34_CLK_ENABLE
N#define __ADC34_CLK_DISABLE         __HAL_RCC_ADC34_CLK_DISABLE
N#define __DAC2_CLK_ENABLE           __HAL_RCC_DAC2_CLK_ENABLE
N#define __DAC2_CLK_DISABLE          __HAL_RCC_DAC2_CLK_DISABLE
N#define __TIM18_CLK_ENABLE          __HAL_RCC_TIM18_CLK_ENABLE
N#define __TIM18_CLK_DISABLE         __HAL_RCC_TIM18_CLK_DISABLE
N#define __TIM19_CLK_ENABLE          __HAL_RCC_TIM19_CLK_ENABLE
N#define __TIM19_CLK_DISABLE         __HAL_RCC_TIM19_CLK_DISABLE
N#define __TIM20_CLK_ENABLE          __HAL_RCC_TIM20_CLK_ENABLE
N#define __TIM20_CLK_DISABLE         __HAL_RCC_TIM20_CLK_DISABLE
N#define __HRTIM1_CLK_ENABLE         __HAL_RCC_HRTIM1_CLK_ENABLE
N#define __HRTIM1_CLK_DISABLE        __HAL_RCC_HRTIM1_CLK_DISABLE
N#define __SDADC1_CLK_ENABLE         __HAL_RCC_SDADC1_CLK_ENABLE
N#define __SDADC2_CLK_ENABLE         __HAL_RCC_SDADC2_CLK_ENABLE
N#define __SDADC3_CLK_ENABLE         __HAL_RCC_SDADC3_CLK_ENABLE
N#define __SDADC1_CLK_DISABLE        __HAL_RCC_SDADC1_CLK_DISABLE
N#define __SDADC2_CLK_DISABLE        __HAL_RCC_SDADC2_CLK_DISABLE
N#define __SDADC3_CLK_DISABLE        __HAL_RCC_SDADC3_CLK_DISABLE
N
N#define __ADC12_FORCE_RESET         __HAL_RCC_ADC12_FORCE_RESET
N#define __ADC12_RELEASE_RESET       __HAL_RCC_ADC12_RELEASE_RESET
N#define __ADC34_FORCE_RESET         __HAL_RCC_ADC34_FORCE_RESET
N#define __ADC34_RELEASE_RESET       __HAL_RCC_ADC34_RELEASE_RESET
N#define __DAC2_FORCE_RESET          __HAL_RCC_DAC2_FORCE_RESET
N#define __DAC2_RELEASE_RESET        __HAL_RCC_DAC2_RELEASE_RESET
N#define __TIM18_FORCE_RESET         __HAL_RCC_TIM18_FORCE_RESET
N#define __TIM18_RELEASE_RESET       __HAL_RCC_TIM18_RELEASE_RESET
N#define __TIM19_FORCE_RESET         __HAL_RCC_TIM19_FORCE_RESET
N#define __TIM19_RELEASE_RESET       __HAL_RCC_TIM19_RELEASE_RESET
N#define __TIM20_FORCE_RESET         __HAL_RCC_TIM20_FORCE_RESET
N#define __TIM20_RELEASE_RESET       __HAL_RCC_TIM20_RELEASE_RESET
N#define __HRTIM1_FORCE_RESET        __HAL_RCC_HRTIM1_FORCE_RESET
N#define __HRTIM1_RELEASE_RESET      __HAL_RCC_HRTIM1_RELEASE_RESET
N#define __SDADC1_FORCE_RESET        __HAL_RCC_SDADC1_FORCE_RESET
N#define __SDADC2_FORCE_RESET        __HAL_RCC_SDADC2_FORCE_RESET
N#define __SDADC3_FORCE_RESET        __HAL_RCC_SDADC3_FORCE_RESET
N#define __SDADC1_RELEASE_RESET      __HAL_RCC_SDADC1_RELEASE_RESET
N#define __SDADC2_RELEASE_RESET      __HAL_RCC_SDADC2_RELEASE_RESET
N#define __SDADC3_RELEASE_RESET      __HAL_RCC_SDADC3_RELEASE_RESET
N
N#define __ADC1_IS_CLK_ENABLED       __HAL_RCC_ADC1_IS_CLK_ENABLED
N#define __ADC1_IS_CLK_DISABLED      __HAL_RCC_ADC1_IS_CLK_DISABLED
N#define __ADC12_IS_CLK_ENABLED      __HAL_RCC_ADC12_IS_CLK_ENABLED
N#define __ADC12_IS_CLK_DISABLED     __HAL_RCC_ADC12_IS_CLK_DISABLED
N#define __ADC34_IS_CLK_ENABLED      __HAL_RCC_ADC34_IS_CLK_ENABLED
N#define __ADC34_IS_CLK_DISABLED     __HAL_RCC_ADC34_IS_CLK_DISABLED
N#define __CEC_IS_CLK_ENABLED        __HAL_RCC_CEC_IS_CLK_ENABLED
N#define __CEC_IS_CLK_DISABLED       __HAL_RCC_CEC_IS_CLK_DISABLED
N#define __CRC_IS_CLK_ENABLED        __HAL_RCC_CRC_IS_CLK_ENABLED
N#define __CRC_IS_CLK_DISABLED       __HAL_RCC_CRC_IS_CLK_DISABLED
N#define __DAC1_IS_CLK_ENABLED       __HAL_RCC_DAC1_IS_CLK_ENABLED
N#define __DAC1_IS_CLK_DISABLED      __HAL_RCC_DAC1_IS_CLK_DISABLED
N#define __DAC2_IS_CLK_ENABLED       __HAL_RCC_DAC2_IS_CLK_ENABLED
N#define __DAC2_IS_CLK_DISABLED      __HAL_RCC_DAC2_IS_CLK_DISABLED
N#define __DMA1_IS_CLK_ENABLED       __HAL_RCC_DMA1_IS_CLK_ENABLED
N#define __DMA1_IS_CLK_DISABLED      __HAL_RCC_DMA1_IS_CLK_DISABLED
N#define __DMA2_IS_CLK_ENABLED       __HAL_RCC_DMA2_IS_CLK_ENABLED
N#define __DMA2_IS_CLK_DISABLED      __HAL_RCC_DMA2_IS_CLK_DISABLED
N#define __FLITF_IS_CLK_ENABLED      __HAL_RCC_FLITF_IS_CLK_ENABLED
N#define __FLITF_IS_CLK_DISABLED     __HAL_RCC_FLITF_IS_CLK_DISABLED
N#define __FMC_IS_CLK_ENABLED        __HAL_RCC_FMC_IS_CLK_ENABLED
N#define __FMC_IS_CLK_DISABLED       __HAL_RCC_FMC_IS_CLK_DISABLED
N#define __GPIOA_IS_CLK_ENABLED      __HAL_RCC_GPIOA_IS_CLK_ENABLED
N#define __GPIOA_IS_CLK_DISABLED     __HAL_RCC_GPIOA_IS_CLK_DISABLED
N#define __GPIOB_IS_CLK_ENABLED      __HAL_RCC_GPIOB_IS_CLK_ENABLED
N#define __GPIOB_IS_CLK_DISABLED     __HAL_RCC_GPIOB_IS_CLK_DISABLED
N#define __GPIOC_IS_CLK_ENABLED      __HAL_RCC_GPIOC_IS_CLK_ENABLED
N#define __GPIOC_IS_CLK_DISABLED     __HAL_RCC_GPIOC_IS_CLK_DISABLED
N#define __GPIOD_IS_CLK_ENABLED      __HAL_RCC_GPIOD_IS_CLK_ENABLED
N#define __GPIOD_IS_CLK_DISABLED     __HAL_RCC_GPIOD_IS_CLK_DISABLED
N#define __GPIOE_IS_CLK_ENABLED      __HAL_RCC_GPIOE_IS_CLK_ENABLED
N#define __GPIOE_IS_CLK_DISABLED     __HAL_RCC_GPIOE_IS_CLK_DISABLED
N#define __GPIOF_IS_CLK_ENABLED      __HAL_RCC_GPIOF_IS_CLK_ENABLED
N#define __GPIOF_IS_CLK_DISABLED     __HAL_RCC_GPIOF_IS_CLK_DISABLED
N#define __GPIOG_IS_CLK_ENABLED      __HAL_RCC_GPIOG_IS_CLK_ENABLED
N#define __GPIOG_IS_CLK_DISABLED     __HAL_RCC_GPIOG_IS_CLK_DISABLED
N#define __GPIOH_IS_CLK_ENABLED      __HAL_RCC_GPIOH_IS_CLK_ENABLED
N#define __GPIOH_IS_CLK_DISABLED     __HAL_RCC_GPIOH_IS_CLK_DISABLED
N#define __HRTIM1_IS_CLK_ENABLED     __HAL_RCC_HRTIM1_IS_CLK_ENABLED
N#define __HRTIM1_IS_CLK_DISABLED    __HAL_RCC_HRTIM1_IS_CLK_DISABLED
N#define __I2C1_IS_CLK_ENABLED       __HAL_RCC_I2C1_IS_CLK_ENABLED
N#define __I2C1_IS_CLK_DISABLED      __HAL_RCC_I2C1_IS_CLK_DISABLED
N#define __I2C2_IS_CLK_ENABLED       __HAL_RCC_I2C2_IS_CLK_ENABLED
N#define __I2C2_IS_CLK_DISABLED      __HAL_RCC_I2C2_IS_CLK_DISABLED
N#define __I2C3_IS_CLK_ENABLED       __HAL_RCC_I2C3_IS_CLK_ENABLED
N#define __I2C3_IS_CLK_DISABLED      __HAL_RCC_I2C3_IS_CLK_DISABLED
N#define __PWR_IS_CLK_ENABLED        __HAL_RCC_PWR_IS_CLK_ENABLED
N#define __PWR_IS_CLK_DISABLED       __HAL_RCC_PWR_IS_CLK_DISABLED
N#define __SYSCFG_IS_CLK_ENABLED     __HAL_RCC_SYSCFG_IS_CLK_ENABLED
N#define __SYSCFG_IS_CLK_DISABLED    __HAL_RCC_SYSCFG_IS_CLK_DISABLED
N#define __SPI1_IS_CLK_ENABLED       __HAL_RCC_SPI1_IS_CLK_ENABLED
N#define __SPI1_IS_CLK_DISABLED      __HAL_RCC_SPI1_IS_CLK_DISABLED
N#define __SPI2_IS_CLK_ENABLED       __HAL_RCC_SPI2_IS_CLK_ENABLED
N#define __SPI2_IS_CLK_DISABLED      __HAL_RCC_SPI2_IS_CLK_DISABLED
N#define __SPI3_IS_CLK_ENABLED       __HAL_RCC_SPI3_IS_CLK_ENABLED
N#define __SPI3_IS_CLK_DISABLED      __HAL_RCC_SPI3_IS_CLK_DISABLED
N#define __SPI4_IS_CLK_ENABLED       __HAL_RCC_SPI4_IS_CLK_ENABLED
N#define __SPI4_IS_CLK_DISABLED      __HAL_RCC_SPI4_IS_CLK_DISABLED
N#define __SDADC1_IS_CLK_ENABLED     __HAL_RCC_SDADC1_IS_CLK_ENABLED
N#define __SDADC1_IS_CLK_DISABLED    __HAL_RCC_SDADC1_IS_CLK_DISABLED
N#define __SDADC2_IS_CLK_ENABLED     __HAL_RCC_SDADC2_IS_CLK_ENABLED
N#define __SDADC2_IS_CLK_DISABLED    __HAL_RCC_SDADC2_IS_CLK_DISABLED
N#define __SDADC3_IS_CLK_ENABLED     __HAL_RCC_SDADC3_IS_CLK_ENABLED
N#define __SDADC3_IS_CLK_DISABLED    __HAL_RCC_SDADC3_IS_CLK_DISABLED
N#define __SRAM_IS_CLK_ENABLED       __HAL_RCC_SRAM_IS_CLK_ENABLED
N#define __SRAM_IS_CLK_DISABLED      __HAL_RCC_SRAM_IS_CLK_DISABLED
N#define __TIM1_IS_CLK_ENABLED       __HAL_RCC_TIM1_IS_CLK_ENABLED
N#define __TIM1_IS_CLK_DISABLED      __HAL_RCC_TIM1_IS_CLK_DISABLED
N#define __TIM2_IS_CLK_ENABLED       __HAL_RCC_TIM2_IS_CLK_ENABLED
N#define __TIM2_IS_CLK_DISABLED      __HAL_RCC_TIM2_IS_CLK_DISABLED
N#define __TIM3_IS_CLK_ENABLED       __HAL_RCC_TIM3_IS_CLK_ENABLED
N#define __TIM3_IS_CLK_DISABLED      __HAL_RCC_TIM3_IS_CLK_DISABLED
N#define __TIM4_IS_CLK_ENABLED       __HAL_RCC_TIM4_IS_CLK_ENABLED
N#define __TIM4_IS_CLK_DISABLED      __HAL_RCC_TIM4_IS_CLK_DISABLED
N#define __TIM5_IS_CLK_ENABLED       __HAL_RCC_TIM5_IS_CLK_ENABLED
N#define __TIM5_IS_CLK_DISABLED      __HAL_RCC_TIM5_IS_CLK_DISABLED
N#define __TIM6_IS_CLK_ENABLED       __HAL_RCC_TIM6_IS_CLK_ENABLED
N#define __TIM6_IS_CLK_DISABLED      __HAL_RCC_TIM6_IS_CLK_DISABLED
N#define __TIM7_IS_CLK_ENABLED       __HAL_RCC_TIM7_IS_CLK_ENABLED
N#define __TIM7_IS_CLK_DISABLED      __HAL_RCC_TIM7_IS_CLK_DISABLED
N#define __TIM8_IS_CLK_ENABLED       __HAL_RCC_TIM8_IS_CLK_ENABLED
N#define __TIM8_IS_CLK_DISABLED      __HAL_RCC_TIM8_IS_CLK_DISABLED
N#define __TIM12_IS_CLK_ENABLED      __HAL_RCC_TIM12_IS_CLK_ENABLED
N#define __TIM12_IS_CLK_DISABLED     __HAL_RCC_TIM12_IS_CLK_DISABLED
N#define __TIM13_IS_CLK_ENABLED      __HAL_RCC_TIM13_IS_CLK_ENABLED
N#define __TIM13_IS_CLK_DISABLED     __HAL_RCC_TIM13_IS_CLK_DISABLED
N#define __TIM14_IS_CLK_ENABLED      __HAL_RCC_TIM14_IS_CLK_ENABLED
N#define __TIM14_IS_CLK_DISABLED     __HAL_RCC_TIM14_IS_CLK_DISABLED
N#define __TIM15_IS_CLK_ENABLED      __HAL_RCC_TIM15_IS_CLK_ENABLED
N#define __TIM15_IS_CLK_DISABLED     __HAL_RCC_TIM15_IS_CLK_DISABLED
N#define __TIM16_IS_CLK_ENABLED      __HAL_RCC_TIM16_IS_CLK_ENABLED
N#define __TIM16_IS_CLK_DISABLED     __HAL_RCC_TIM16_IS_CLK_DISABLED
N#define __TIM17_IS_CLK_ENABLED      __HAL_RCC_TIM17_IS_CLK_ENABLED
N#define __TIM17_IS_CLK_DISABLED     __HAL_RCC_TIM17_IS_CLK_DISABLED
N#define __TIM18_IS_CLK_ENABLED      __HAL_RCC_TIM18_IS_CLK_ENABLED
N#define __TIM18_IS_CLK_DISABLED     __HAL_RCC_TIM18_IS_CLK_DISABLED
N#define __TIM19_IS_CLK_ENABLED      __HAL_RCC_TIM19_IS_CLK_ENABLED
N#define __TIM19_IS_CLK_DISABLED     __HAL_RCC_TIM19_IS_CLK_DISABLED
N#define __TIM20_IS_CLK_ENABLED      __HAL_RCC_TIM20_IS_CLK_ENABLED
N#define __TIM20_IS_CLK_DISABLED     __HAL_RCC_TIM20_IS_CLK_DISABLED
N#define __TSC_IS_CLK_ENABLED        __HAL_RCC_TSC_IS_CLK_ENABLED
N#define __TSC_IS_CLK_DISABLED       __HAL_RCC_TSC_IS_CLK_DISABLED
N#define __UART4_IS_CLK_ENABLED      __HAL_RCC_UART4_IS_CLK_ENABLED
N#define __UART4_IS_CLK_DISABLED     __HAL_RCC_UART4_IS_CLK_DISABLED
N#define __UART5_IS_CLK_ENABLED      __HAL_RCC_UART5_IS_CLK_ENABLED
N#define __UART5_IS_CLK_DISABLED     __HAL_RCC_UART5_IS_CLK_DISABLED
N#define __USART1_IS_CLK_ENABLED     __HAL_RCC_USART1_IS_CLK_ENABLED
N#define __USART1_IS_CLK_DISABLED    __HAL_RCC_USART1_IS_CLK_DISABLED
N#define __USART2_IS_CLK_ENABLED     __HAL_RCC_USART2_IS_CLK_ENABLED
N#define __USART2_IS_CLK_DISABLED    __HAL_RCC_USART2_IS_CLK_DISABLED
N#define __USART3_IS_CLK_ENABLED     __HAL_RCC_USART3_IS_CLK_ENABLED
N#define __USART3_IS_CLK_DISABLED    __HAL_RCC_USART3_IS_CLK_DISABLED
N#define __USB_IS_CLK_ENABLED        __HAL_RCC_USB_IS_CLK_ENABLED
N#define __USB_IS_CLK_DISABLED       __HAL_RCC_USB_IS_CLK_DISABLED
N#define __WWDG_IS_CLK_ENABLED       __HAL_RCC_WWDG_IS_CLK_ENABLED
N#define __WWDG_IS_CLK_DISABLED      __HAL_RCC_WWDG_IS_CLK_DISABLED
N
N#if defined(STM32L1)
X#if 0L
S#define __HAL_RCC_CRYP_CLK_DISABLE         __HAL_RCC_AES_CLK_DISABLE
S#define __HAL_RCC_CRYP_CLK_ENABLE          __HAL_RCC_AES_CLK_ENABLE
S#define __HAL_RCC_CRYP_CLK_SLEEP_DISABLE   __HAL_RCC_AES_CLK_SLEEP_DISABLE
S#define __HAL_RCC_CRYP_CLK_SLEEP_ENABLE    __HAL_RCC_AES_CLK_SLEEP_ENABLE
S#define __HAL_RCC_CRYP_FORCE_RESET         __HAL_RCC_AES_FORCE_RESET
S#define __HAL_RCC_CRYP_RELEASE_RESET       __HAL_RCC_AES_RELEASE_RESET
N#endif /* STM32L1 */
N
N#if defined(STM32F4)
X#if 1L
N#define __HAL_RCC_SDMMC1_FORCE_RESET       __HAL_RCC_SDIO_FORCE_RESET
N#define __HAL_RCC_SDMMC1_RELEASE_RESET     __HAL_RCC_SDIO_RELEASE_RESET
N#define __HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE  __HAL_RCC_SDIO_CLK_SLEEP_ENABLE
N#define __HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE __HAL_RCC_SDIO_CLK_SLEEP_DISABLE
N#define __HAL_RCC_SDMMC1_CLK_ENABLE        __HAL_RCC_SDIO_CLK_ENABLE
N#define __HAL_RCC_SDMMC1_CLK_DISABLE       __HAL_RCC_SDIO_CLK_DISABLE
N#define __HAL_RCC_SDMMC1_IS_CLK_ENABLED    __HAL_RCC_SDIO_IS_CLK_ENABLED
N#define __HAL_RCC_SDMMC1_IS_CLK_DISABLED   __HAL_RCC_SDIO_IS_CLK_DISABLED
N#define Sdmmc1ClockSelection               SdioClockSelection
N#define RCC_PERIPHCLK_SDMMC1               RCC_PERIPHCLK_SDIO
N#define RCC_SDMMC1CLKSOURCE_CLK48          RCC_SDIOCLKSOURCE_CK48
N#define RCC_SDMMC1CLKSOURCE_SYSCLK         RCC_SDIOCLKSOURCE_SYSCLK
N#define __HAL_RCC_SDMMC1_CONFIG            __HAL_RCC_SDIO_CONFIG
N#define __HAL_RCC_GET_SDMMC1_SOURCE        __HAL_RCC_GET_SDIO_SOURCE
N#endif
N
N#if defined(STM32F7) || defined(STM32L4)
X#if 0L || 0L
S#define __HAL_RCC_SDIO_FORCE_RESET         __HAL_RCC_SDMMC1_FORCE_RESET
S#define __HAL_RCC_SDIO_RELEASE_RESET       __HAL_RCC_SDMMC1_RELEASE_RESET
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE    __HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE   __HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE
S#define __HAL_RCC_SDIO_CLK_ENABLE          __HAL_RCC_SDMMC1_CLK_ENABLE
S#define __HAL_RCC_SDIO_CLK_DISABLE         __HAL_RCC_SDMMC1_CLK_DISABLE
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED      __HAL_RCC_SDMMC1_IS_CLK_ENABLED
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED     __HAL_RCC_SDMMC1_IS_CLK_DISABLED
S#define SdioClockSelection                 Sdmmc1ClockSelection
S#define RCC_PERIPHCLK_SDIO                 RCC_PERIPHCLK_SDMMC1
S#define __HAL_RCC_SDIO_CONFIG              __HAL_RCC_SDMMC1_CONFIG
S#define __HAL_RCC_GET_SDIO_SOURCE          __HAL_RCC_GET_SDMMC1_SOURCE
N#endif
N
N#if defined(STM32F7)
X#if 0L
S#define RCC_SDIOCLKSOURCE_CLK48             RCC_SDMMC1CLKSOURCE_CLK48
S#define RCC_SDIOCLKSOURCE_SYSCLK           RCC_SDMMC1CLKSOURCE_SYSCLK
N#endif
N
N#if defined(STM32H7)
X#if 0L
S#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()              __HAL_RCC_USB1_OTG_HS_CLK_ENABLE()
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()         __HAL_RCC_USB1_OTG_HS_ULPI_CLK_ENABLE()
S#define __HAL_RCC_USB_OTG_HS_CLK_DISABLE()             __HAL_RCC_USB1_OTG_HS_CLK_DISABLE()
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE()        __HAL_RCC_USB1_OTG_HS_ULPI_CLK_DISABLE()
S#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()             __HAL_RCC_USB1_OTG_HS_FORCE_RESET()
S#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()           __HAL_RCC_USB1_OTG_HS_RELEASE_RESET()
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()        __HAL_RCC_USB1_OTG_HS_CLK_SLEEP_ENABLE()
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()   __HAL_RCC_USB1_OTG_HS_ULPI_CLK_SLEEP_ENABLE()
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()       __HAL_RCC_USB1_OTG_HS_CLK_SLEEP_DISABLE()
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE()  __HAL_RCC_USB1_OTG_HS_ULPI_CLK_SLEEP_DISABLE()
S
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()             __HAL_RCC_USB2_OTG_FS_CLK_ENABLE()
S#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_ENABLE()        __HAL_RCC_USB2_OTG_FS_ULPI_CLK_ENABLE()
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE()            __HAL_RCC_USB2_OTG_FS_CLK_DISABLE()
S#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_DISABLE()       __HAL_RCC_USB2_OTG_FS_ULPI_CLK_DISABLE()
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()            __HAL_RCC_USB2_OTG_FS_FORCE_RESET()
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET()          __HAL_RCC_USB2_OTG_FS_RELEASE_RESET()
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()       __HAL_RCC_USB2_OTG_FS_CLK_SLEEP_ENABLE()
S#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_SLEEP_ENABLE()  __HAL_RCC_USB2_OTG_FS_ULPI_CLK_SLEEP_ENABLE()
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()      __HAL_RCC_USB2_OTG_FS_CLK_SLEEP_DISABLE()
S#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_SLEEP_DISABLE() __HAL_RCC_USB2_OTG_FS_ULPI_CLK_SLEEP_DISABLE()
N#endif
N
N#define __HAL_RCC_I2SCLK            __HAL_RCC_I2S_CONFIG
N#define __HAL_RCC_I2SCLK_CONFIG     __HAL_RCC_I2S_CONFIG
N
N#define __RCC_PLLSRC                RCC_GET_PLL_OSCSOURCE
N
N#define IS_RCC_MSIRANGE             IS_RCC_MSI_CLOCK_RANGE
N#define IS_RCC_RTCCLK_SOURCE        IS_RCC_RTCCLKSOURCE
N#define IS_RCC_SYSCLK_DIV           IS_RCC_HCLK
N#define IS_RCC_HCLK_DIV             IS_RCC_PCLK
N#define IS_RCC_PERIPHCLK            IS_RCC_PERIPHCLOCK
N
N#define RCC_IT_HSI14                RCC_IT_HSI14RDY
N
N#define RCC_IT_CSSLSE               RCC_IT_LSECSS
N#define RCC_IT_CSSHSE               RCC_IT_CSS
N
N#define RCC_PLLMUL_3                RCC_PLL_MUL3
N#define RCC_PLLMUL_4                RCC_PLL_MUL4
N#define RCC_PLLMUL_6                RCC_PLL_MUL6
N#define RCC_PLLMUL_8                RCC_PLL_MUL8
N#define RCC_PLLMUL_12               RCC_PLL_MUL12
N#define RCC_PLLMUL_16               RCC_PLL_MUL16
N#define RCC_PLLMUL_24               RCC_PLL_MUL24
N#define RCC_PLLMUL_32               RCC_PLL_MUL32
N#define RCC_PLLMUL_48               RCC_PLL_MUL48
N
N#define RCC_PLLDIV_2                RCC_PLL_DIV2
N#define RCC_PLLDIV_3                RCC_PLL_DIV3
N#define RCC_PLLDIV_4                RCC_PLL_DIV4
N
N#define IS_RCC_MCOSOURCE            IS_RCC_MCO1SOURCE
N#define __HAL_RCC_MCO_CONFIG        __HAL_RCC_MCO1_CONFIG
N#define RCC_MCO_NODIV               RCC_MCODIV_1
N#define RCC_MCO_DIV1                RCC_MCODIV_1
N#define RCC_MCO_DIV2                RCC_MCODIV_2
N#define RCC_MCO_DIV4                RCC_MCODIV_4
N#define RCC_MCO_DIV8                RCC_MCODIV_8
N#define RCC_MCO_DIV16               RCC_MCODIV_16
N#define RCC_MCO_DIV32               RCC_MCODIV_32
N#define RCC_MCO_DIV64               RCC_MCODIV_64
N#define RCC_MCO_DIV128              RCC_MCODIV_128
N#define RCC_MCOSOURCE_NONE          RCC_MCO1SOURCE_NOCLOCK
N#define RCC_MCOSOURCE_LSI           RCC_MCO1SOURCE_LSI
N#define RCC_MCOSOURCE_LSE           RCC_MCO1SOURCE_LSE
N#define RCC_MCOSOURCE_SYSCLK        RCC_MCO1SOURCE_SYSCLK
N#define RCC_MCOSOURCE_HSI           RCC_MCO1SOURCE_HSI
N#define RCC_MCOSOURCE_HSI14         RCC_MCO1SOURCE_HSI14
N#define RCC_MCOSOURCE_HSI48         RCC_MCO1SOURCE_HSI48
N#define RCC_MCOSOURCE_HSE           RCC_MCO1SOURCE_HSE
N#define RCC_MCOSOURCE_PLLCLK_DIV1   RCC_MCO1SOURCE_PLLCLK
N#define RCC_MCOSOURCE_PLLCLK_NODIV  RCC_MCO1SOURCE_PLLCLK
N#define RCC_MCOSOURCE_PLLCLK_DIV2   RCC_MCO1SOURCE_PLLCLK_DIV2
N
N#if defined(STM32L4) || defined(STM32WB) || defined(STM32G0) || defined(STM32G4) || defined(STM32L5) || defined(STM32WL)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define RCC_RTCCLKSOURCE_NO_CLK     RCC_RTCCLKSOURCE_NONE
N#else
N#define RCC_RTCCLKSOURCE_NONE       RCC_RTCCLKSOURCE_NO_CLK
N#endif
N
N#define RCC_USBCLK_PLLSAI1          RCC_USBCLKSOURCE_PLLSAI1
N#define RCC_USBCLK_PLL              RCC_USBCLKSOURCE_PLL
N#define RCC_USBCLK_MSI              RCC_USBCLKSOURCE_MSI
N#define RCC_USBCLKSOURCE_PLLCLK     RCC_USBCLKSOURCE_PLL
N#define RCC_USBPLLCLK_DIV1          RCC_USBCLKSOURCE_PLL
N#define RCC_USBPLLCLK_DIV1_5        RCC_USBCLKSOURCE_PLL_DIV1_5
N#define RCC_USBPLLCLK_DIV2          RCC_USBCLKSOURCE_PLL_DIV2
N#define RCC_USBPLLCLK_DIV3          RCC_USBCLKSOURCE_PLL_DIV3
N
N#define HSION_BitNumber        RCC_HSION_BIT_NUMBER
N#define HSION_BITNUMBER        RCC_HSION_BIT_NUMBER
N#define HSEON_BitNumber        RCC_HSEON_BIT_NUMBER
N#define HSEON_BITNUMBER        RCC_HSEON_BIT_NUMBER
N#define MSION_BITNUMBER        RCC_MSION_BIT_NUMBER
N#define CSSON_BitNumber        RCC_CSSON_BIT_NUMBER
N#define CSSON_BITNUMBER        RCC_CSSON_BIT_NUMBER
N#define PLLON_BitNumber        RCC_PLLON_BIT_NUMBER
N#define PLLON_BITNUMBER        RCC_PLLON_BIT_NUMBER
N#define PLLI2SON_BitNumber     RCC_PLLI2SON_BIT_NUMBER
N#define I2SSRC_BitNumber       RCC_I2SSRC_BIT_NUMBER
N#define RTCEN_BitNumber        RCC_RTCEN_BIT_NUMBER
N#define RTCEN_BITNUMBER        RCC_RTCEN_BIT_NUMBER
N#define BDRST_BitNumber        RCC_BDRST_BIT_NUMBER
N#define BDRST_BITNUMBER        RCC_BDRST_BIT_NUMBER
N#define RTCRST_BITNUMBER       RCC_RTCRST_BIT_NUMBER
N#define LSION_BitNumber        RCC_LSION_BIT_NUMBER
N#define LSION_BITNUMBER        RCC_LSION_BIT_NUMBER
N#define LSEON_BitNumber        RCC_LSEON_BIT_NUMBER
N#define LSEON_BITNUMBER        RCC_LSEON_BIT_NUMBER
N#define LSEBYP_BITNUMBER       RCC_LSEBYP_BIT_NUMBER
N#define PLLSAION_BitNumber     RCC_PLLSAION_BIT_NUMBER
N#define TIMPRE_BitNumber       RCC_TIMPRE_BIT_NUMBER
N#define RMVF_BitNumber         RCC_RMVF_BIT_NUMBER
N#define RMVF_BITNUMBER         RCC_RMVF_BIT_NUMBER
N#define RCC_CR2_HSI14TRIM_BitNumber RCC_HSI14TRIM_BIT_NUMBER
N#define CR_BYTE2_ADDRESS       RCC_CR_BYTE2_ADDRESS
N#define CIR_BYTE1_ADDRESS      RCC_CIR_BYTE1_ADDRESS
N#define CIR_BYTE2_ADDRESS      RCC_CIR_BYTE2_ADDRESS
N#define BDCR_BYTE0_ADDRESS     RCC_BDCR_BYTE0_ADDRESS
N#define DBP_TIMEOUT_VALUE      RCC_DBP_TIMEOUT_VALUE
N#define LSE_TIMEOUT_VALUE      RCC_LSE_TIMEOUT_VALUE
N
N#define CR_HSION_BB            RCC_CR_HSION_BB
N#define CR_CSSON_BB            RCC_CR_CSSON_BB
N#define CR_PLLON_BB            RCC_CR_PLLON_BB
N#define CR_PLLI2SON_BB         RCC_CR_PLLI2SON_BB
N#define CR_MSION_BB            RCC_CR_MSION_BB
N#define CSR_LSION_BB           RCC_CSR_LSION_BB
N#define CSR_LSEON_BB           RCC_CSR_LSEON_BB
N#define CSR_LSEBYP_BB          RCC_CSR_LSEBYP_BB
N#define CSR_RTCEN_BB           RCC_CSR_RTCEN_BB
N#define CSR_RTCRST_BB          RCC_CSR_RTCRST_BB
N#define CFGR_I2SSRC_BB         RCC_CFGR_I2SSRC_BB
N#define BDCR_RTCEN_BB          RCC_BDCR_RTCEN_BB
N#define BDCR_BDRST_BB          RCC_BDCR_BDRST_BB
N#define CR_HSEON_BB            RCC_CR_HSEON_BB
N#define CSR_RMVF_BB            RCC_CSR_RMVF_BB
N#define CR_PLLSAION_BB         RCC_CR_PLLSAION_BB
N#define DCKCFGR_TIMPRE_BB      RCC_DCKCFGR_TIMPRE_BB
N
N#define __HAL_RCC_CRS_ENABLE_FREQ_ERROR_COUNTER     __HAL_RCC_CRS_FREQ_ERROR_COUNTER_ENABLE
N#define __HAL_RCC_CRS_DISABLE_FREQ_ERROR_COUNTER    __HAL_RCC_CRS_FREQ_ERROR_COUNTER_DISABLE
N#define __HAL_RCC_CRS_ENABLE_AUTOMATIC_CALIB        __HAL_RCC_CRS_AUTOMATIC_CALIB_ENABLE
N#define __HAL_RCC_CRS_DISABLE_AUTOMATIC_CALIB       __HAL_RCC_CRS_AUTOMATIC_CALIB_DISABLE
N#define __HAL_RCC_CRS_CALCULATE_RELOADVALUE         __HAL_RCC_CRS_RELOADVALUE_CALCULATE
N
N#define __HAL_RCC_GET_IT_SOURCE                     __HAL_RCC_GET_IT
N
N#define RCC_CRS_SYNCWARM       RCC_CRS_SYNCWARN
N#define RCC_CRS_TRIMOV         RCC_CRS_TRIMOVF
N
N#define RCC_PERIPHCLK_CK48               RCC_PERIPHCLK_CLK48
N#define RCC_CK48CLKSOURCE_PLLQ           RCC_CLK48CLKSOURCE_PLLQ
N#define RCC_CK48CLKSOURCE_PLLSAIP        RCC_CLK48CLKSOURCE_PLLSAIP
N#define RCC_CK48CLKSOURCE_PLLI2SQ        RCC_CLK48CLKSOURCE_PLLI2SQ
N#define IS_RCC_CK48CLKSOURCE             IS_RCC_CLK48CLKSOURCE
N#define RCC_SDIOCLKSOURCE_CK48           RCC_SDIOCLKSOURCE_CLK48
N
N#define __HAL_RCC_DFSDM_CLK_ENABLE             __HAL_RCC_DFSDM1_CLK_ENABLE
N#define __HAL_RCC_DFSDM_CLK_DISABLE            __HAL_RCC_DFSDM1_CLK_DISABLE
N#define __HAL_RCC_DFSDM_IS_CLK_ENABLED         __HAL_RCC_DFSDM1_IS_CLK_ENABLED
N#define __HAL_RCC_DFSDM_IS_CLK_DISABLED        __HAL_RCC_DFSDM1_IS_CLK_DISABLED
N#define __HAL_RCC_DFSDM_FORCE_RESET            __HAL_RCC_DFSDM1_FORCE_RESET
N#define __HAL_RCC_DFSDM_RELEASE_RESET          __HAL_RCC_DFSDM1_RELEASE_RESET
N#define __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE       __HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE
N#define __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE      __HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE
N#define __HAL_RCC_DFSDM_IS_CLK_SLEEP_ENABLED   __HAL_RCC_DFSDM1_IS_CLK_SLEEP_ENABLED
N#define __HAL_RCC_DFSDM_IS_CLK_SLEEP_DISABLED  __HAL_RCC_DFSDM1_IS_CLK_SLEEP_DISABLED
N#define DfsdmClockSelection         Dfsdm1ClockSelection
N#define RCC_PERIPHCLK_DFSDM         RCC_PERIPHCLK_DFSDM1
N#define RCC_DFSDMCLKSOURCE_PCLK     RCC_DFSDM1CLKSOURCE_PCLK2
N#define RCC_DFSDMCLKSOURCE_SYSCLK   RCC_DFSDM1CLKSOURCE_SYSCLK
N#define __HAL_RCC_DFSDM_CONFIG      __HAL_RCC_DFSDM1_CONFIG
N#define __HAL_RCC_GET_DFSDM_SOURCE  __HAL_RCC_GET_DFSDM1_SOURCE
N#define RCC_DFSDM1CLKSOURCE_PCLK    RCC_DFSDM1CLKSOURCE_PCLK2
N#define RCC_SWPMI1CLKSOURCE_PCLK    RCC_SWPMI1CLKSOURCE_PCLK1
N#define RCC_LPTIM1CLKSOURCE_PCLK    RCC_LPTIM1CLKSOURCE_PCLK1
N#define RCC_LPTIM2CLKSOURCE_PCLK    RCC_LPTIM2CLKSOURCE_PCLK1
N
N#define RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB1    RCC_DFSDM1AUDIOCLKSOURCE_I2S1
N#define RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB2    RCC_DFSDM1AUDIOCLKSOURCE_I2S2
N#define RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB1    RCC_DFSDM2AUDIOCLKSOURCE_I2S1
N#define RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB2    RCC_DFSDM2AUDIOCLKSOURCE_I2S2
N#define RCC_DFSDM1CLKSOURCE_APB2            RCC_DFSDM1CLKSOURCE_PCLK2
N#define RCC_DFSDM2CLKSOURCE_APB2            RCC_DFSDM2CLKSOURCE_PCLK2
N#define RCC_FMPI2C1CLKSOURCE_APB            RCC_FMPI2C1CLKSOURCE_PCLK1
N#if defined(STM32U5)
X#if 0L
S#define MSIKPLLModeSEL  RCC_MSIKPLL_MODE_SEL
S#define MSISPLLModeSEL  RCC_MSISPLL_MODE_SEL
S#define __HAL_RCC_AHB21_CLK_DISABLE           __HAL_RCC_AHB2_1_CLK_DISABLE
S#define __HAL_RCC_AHB22_CLK_DISABLE           __HAL_RCC_AHB2_2_CLK_DISABLE
S#define __HAL_RCC_AHB1_CLK_Disable_Clear      __HAL_RCC_AHB1_CLK_ENABLE
S#define __HAL_RCC_AHB21_CLK_Disable_Clear     __HAL_RCC_AHB2_1_CLK_ENABLE
S#define __HAL_RCC_AHB22_CLK_Disable_Clear     __HAL_RCC_AHB2_2_CLK_ENABLE
S#define __HAL_RCC_AHB3_CLK_Disable_Clear      __HAL_RCC_AHB3_CLK_ENABLE
S#define __HAL_RCC_APB1_CLK_Disable_Clear      __HAL_RCC_APB1_CLK_ENABLE
S#define __HAL_RCC_APB2_CLK_Disable_Clear      __HAL_RCC_APB2_CLK_ENABLE
S#define __HAL_RCC_APB3_CLK_Disable_Clear      __HAL_RCC_APB3_CLK_ENABLE
S#define IS_RCC_MSIPLLModeSelection            IS_RCC_MSIPLLMODE_SELECT
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_RNG_Aliased_Macros HAL RNG Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define  HAL_RNG_ReadyCallback(__HANDLE__)  HAL_RNG_ReadyDataCallback((__HANDLE__), uint32_t random32bit)
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_RTC_Aliased_Macros HAL RTC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#if defined (STM32G0) || defined (STM32L5) || defined (STM32L412xx) || defined (STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) || defined (STM32G4) || defined (STM32WL) || defined (STM32U5)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L
N#else
N#define __HAL_RTC_CLEAR_FLAG                      __HAL_RTC_EXTI_CLEAR_FLAG
N#endif
N#define __HAL_RTC_DISABLE_IT                      __HAL_RTC_EXTI_DISABLE_IT
N#define __HAL_RTC_ENABLE_IT                       __HAL_RTC_EXTI_ENABLE_IT
N
N#if defined (STM32F1)
X#if 0L
S#define __HAL_RTC_EXTI_CLEAR_FLAG(RTC_EXTI_LINE_ALARM_EVENT)  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG()
S
S#define __HAL_RTC_EXTI_ENABLE_IT(RTC_EXTI_LINE_ALARM_EVENT)   __HAL_RTC_ALARM_EXTI_ENABLE_IT()
S
S#define __HAL_RTC_EXTI_DISABLE_IT(RTC_EXTI_LINE_ALARM_EVENT)  __HAL_RTC_ALARM_EXTI_DISABLE_IT()
S
S#define __HAL_RTC_EXTI_GET_FLAG(RTC_EXTI_LINE_ALARM_EVENT)    __HAL_RTC_ALARM_EXTI_GET_FLAG()
S
S#define __HAL_RTC_EXTI_GENERATE_SWIT(RTC_EXTI_LINE_ALARM_EVENT)   __HAL_RTC_ALARM_EXTI_GENERATE_SWIT()
N#else
N#define __HAL_RTC_EXTI_CLEAR_FLAG(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_CLEAR_FLAG() : \
N                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG() : \
N                                                    __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()))
X#define __HAL_RTC_EXTI_CLEAR_FLAG(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_CLEAR_FLAG() :                                                    (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG() :                                                     __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()))
N#define __HAL_RTC_EXTI_ENABLE_IT(__EXTI_LINE__)   (((__EXTI_LINE__)  == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_ENABLE_IT() : \
N                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT() : \
N                                                    __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()))
X#define __HAL_RTC_EXTI_ENABLE_IT(__EXTI_LINE__)   (((__EXTI_LINE__)  == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_ENABLE_IT() :                                                    (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT() :                                                     __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()))
N#define __HAL_RTC_EXTI_DISABLE_IT(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_DISABLE_IT() : \
N                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT() : \
N                                                    __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()))
X#define __HAL_RTC_EXTI_DISABLE_IT(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_DISABLE_IT() :                                                    (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT() :                                                     __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()))
N#define __HAL_RTC_EXTI_GET_FLAG(__EXTI_LINE__)    (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GET_FLAG() : \
N                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG() : \
N                                                    __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()))
X#define __HAL_RTC_EXTI_GET_FLAG(__EXTI_LINE__)    (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GET_FLAG() :                                                    (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG() :                                                     __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()))
N#define __HAL_RTC_EXTI_GENERATE_SWIT(__EXTI_LINE__)   (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GENERATE_SWIT() : \
N                                                       (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT() :  \
N                                                        __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()))
X#define __HAL_RTC_EXTI_GENERATE_SWIT(__EXTI_LINE__)   (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GENERATE_SWIT() :                                                        (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT() :                                                          __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()))
N#endif   /* STM32F1 */
N
N#define IS_ALARM                                  IS_RTC_ALARM
N#define IS_ALARM_MASK                             IS_RTC_ALARM_MASK
N#define IS_TAMPER                                 IS_RTC_TAMPER
N#define IS_TAMPER_ERASE_MODE                      IS_RTC_TAMPER_ERASE_MODE
N#define IS_TAMPER_FILTER                          IS_RTC_TAMPER_FILTER
N#define IS_TAMPER_INTERRUPT                       IS_RTC_TAMPER_INTERRUPT
N#define IS_TAMPER_MASKFLAG_STATE                  IS_RTC_TAMPER_MASKFLAG_STATE
N#define IS_TAMPER_PRECHARGE_DURATION              IS_RTC_TAMPER_PRECHARGE_DURATION
N#define IS_TAMPER_PULLUP_STATE                    IS_RTC_TAMPER_PULLUP_STATE
N#define IS_TAMPER_SAMPLING_FREQ                   IS_RTC_TAMPER_SAMPLING_FREQ
N#define IS_TAMPER_TIMESTAMPONTAMPER_DETECTION     IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION
N#define IS_TAMPER_TRIGGER                         IS_RTC_TAMPER_TRIGGER
N#define IS_WAKEUP_CLOCK                           IS_RTC_WAKEUP_CLOCK
N#define IS_WAKEUP_COUNTER                         IS_RTC_WAKEUP_COUNTER
N
N#define __RTC_WRITEPROTECTION_ENABLE  __HAL_RTC_WRITEPROTECTION_ENABLE
N#define __RTC_WRITEPROTECTION_DISABLE  __HAL_RTC_WRITEPROTECTION_DISABLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SD_Aliased_Macros HAL SD/MMC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define SD_OCR_CID_CSD_OVERWRIETE   SD_OCR_CID_CSD_OVERWRITE
N#define SD_CMD_SD_APP_STAUS         SD_CMD_SD_APP_STATUS
N
N#if !defined(STM32F1) && !defined(STM32F2) && !defined(STM32F4) && !defined(STM32F7) && !defined(STM32L1)
X#if !0L && !0L && !1L && !0L && !0L
S#define eMMC_HIGH_VOLTAGE_RANGE     EMMC_HIGH_VOLTAGE_RANGE
S#define eMMC_DUAL_VOLTAGE_RANGE     EMMC_DUAL_VOLTAGE_RANGE
S#define eMMC_LOW_VOLTAGE_RANGE      EMMC_LOW_VOLTAGE_RANGE
S
S#define SDMMC_NSpeed_CLK_DIV        SDMMC_NSPEED_CLK_DIV
S#define SDMMC_HSpeed_CLK_DIV        SDMMC_HSPEED_CLK_DIV
N#endif
N
N#if defined(STM32F4) || defined(STM32F2)
X#if 1L || 0L
N#define  SD_SDMMC_DISABLED          SD_SDIO_DISABLED
N#define  SD_SDMMC_FUNCTION_BUSY     SD_SDIO_FUNCTION_BUSY
N#define  SD_SDMMC_FUNCTION_FAILED   SD_SDIO_FUNCTION_FAILED
N#define  SD_SDMMC_UNKNOWN_FUNCTION  SD_SDIO_UNKNOWN_FUNCTION
N#define  SD_CMD_SDMMC_SEN_OP_COND   SD_CMD_SDIO_SEN_OP_COND
N#define  SD_CMD_SDMMC_RW_DIRECT     SD_CMD_SDIO_RW_DIRECT
N#define  SD_CMD_SDMMC_RW_EXTENDED   SD_CMD_SDIO_RW_EXTENDED
N#define  __HAL_SD_SDMMC_ENABLE      __HAL_SD_SDIO_ENABLE
N#define  __HAL_SD_SDMMC_DISABLE     __HAL_SD_SDIO_DISABLE
N#define  __HAL_SD_SDMMC_DMA_ENABLE  __HAL_SD_SDIO_DMA_ENABLE
N#define  __HAL_SD_SDMMC_DMA_DISABLE __HAL_SD_SDIO_DMA_DISABL
N#define  __HAL_SD_SDMMC_ENABLE_IT   __HAL_SD_SDIO_ENABLE_IT
N#define  __HAL_SD_SDMMC_DISABLE_IT  __HAL_SD_SDIO_DISABLE_IT
N#define  __HAL_SD_SDMMC_GET_FLAG    __HAL_SD_SDIO_GET_FLAG
N#define  __HAL_SD_SDMMC_CLEAR_FLAG  __HAL_SD_SDIO_CLEAR_FLAG
N#define  __HAL_SD_SDMMC_GET_IT      __HAL_SD_SDIO_GET_IT
N#define  __HAL_SD_SDMMC_CLEAR_IT    __HAL_SD_SDIO_CLEAR_IT
N#define  SDMMC_STATIC_FLAGS         SDIO_STATIC_FLAGS
N#define  SDMMC_CMD0TIMEOUT          SDIO_CMD0TIMEOUT
N#define  SD_SDMMC_SEND_IF_COND      SD_SDIO_SEND_IF_COND
N/* alias CMSIS */
N#define  SDMMC1_IRQn                SDIO_IRQn
N#define  SDMMC1_IRQHandler          SDIO_IRQHandler
N#endif
N
N#if defined(STM32F7) || defined(STM32L4)
X#if 0L || 0L
S#define  SD_SDIO_DISABLED           SD_SDMMC_DISABLED
S#define  SD_SDIO_FUNCTION_BUSY      SD_SDMMC_FUNCTION_BUSY
S#define  SD_SDIO_FUNCTION_FAILED    SD_SDMMC_FUNCTION_FAILED
S#define  SD_SDIO_UNKNOWN_FUNCTION   SD_SDMMC_UNKNOWN_FUNCTION
S#define  SD_CMD_SDIO_SEN_OP_COND    SD_CMD_SDMMC_SEN_OP_COND
S#define  SD_CMD_SDIO_RW_DIRECT      SD_CMD_SDMMC_RW_DIRECT
S#define  SD_CMD_SDIO_RW_EXTENDED    SD_CMD_SDMMC_RW_EXTENDED
S#define  __HAL_SD_SDIO_ENABLE       __HAL_SD_SDMMC_ENABLE
S#define  __HAL_SD_SDIO_DISABLE      __HAL_SD_SDMMC_DISABLE
S#define  __HAL_SD_SDIO_DMA_ENABLE   __HAL_SD_SDMMC_DMA_ENABLE
S#define  __HAL_SD_SDIO_DMA_DISABL   __HAL_SD_SDMMC_DMA_DISABLE
S#define  __HAL_SD_SDIO_ENABLE_IT    __HAL_SD_SDMMC_ENABLE_IT
S#define  __HAL_SD_SDIO_DISABLE_IT   __HAL_SD_SDMMC_DISABLE_IT
S#define  __HAL_SD_SDIO_GET_FLAG     __HAL_SD_SDMMC_GET_FLAG
S#define  __HAL_SD_SDIO_CLEAR_FLAG   __HAL_SD_SDMMC_CLEAR_FLAG
S#define  __HAL_SD_SDIO_GET_IT       __HAL_SD_SDMMC_GET_IT
S#define  __HAL_SD_SDIO_CLEAR_IT     __HAL_SD_SDMMC_CLEAR_IT
S#define  SDIO_STATIC_FLAGS          SDMMC_STATIC_FLAGS
S#define  SDIO_CMD0TIMEOUT           SDMMC_CMD0TIMEOUT
S#define  SD_SDIO_SEND_IF_COND       SD_SDMMC_SEND_IF_COND
S/* alias CMSIS for compatibilities */
S#define  SDIO_IRQn                  SDMMC1_IRQn
S#define  SDIO_IRQHandler            SDMMC1_IRQHandler
N#endif
N
N#if defined(STM32F7) || defined(STM32F4) || defined(STM32F2) || defined(STM32L4) || defined(STM32H7)
X#if 0L || 1L || 0L || 0L || 0L
N#define  HAL_SD_CardCIDTypedef       HAL_SD_CardCIDTypeDef
N#define  HAL_SD_CardCSDTypedef       HAL_SD_CardCSDTypeDef
N#define  HAL_SD_CardStatusTypedef    HAL_SD_CardStatusTypeDef
N#define  HAL_SD_CardStateTypedef     HAL_SD_CardStateTypeDef
N#endif
N
N#if defined(STM32H7) || defined(STM32L5)
X#if 0L || 0L
S#define HAL_MMCEx_Read_DMADoubleBuffer0CpltCallback   HAL_MMCEx_Read_DMADoubleBuf0CpltCallback
S#define HAL_MMCEx_Read_DMADoubleBuffer1CpltCallback   HAL_MMCEx_Read_DMADoubleBuf1CpltCallback
S#define HAL_MMCEx_Write_DMADoubleBuffer0CpltCallback  HAL_MMCEx_Write_DMADoubleBuf0CpltCallback
S#define HAL_MMCEx_Write_DMADoubleBuffer1CpltCallback  HAL_MMCEx_Write_DMADoubleBuf1CpltCallback
S#define HAL_SDEx_Read_DMADoubleBuffer0CpltCallback    HAL_SDEx_Read_DMADoubleBuf0CpltCallback
S#define HAL_SDEx_Read_DMADoubleBuffer1CpltCallback    HAL_SDEx_Read_DMADoubleBuf1CpltCallback
S#define HAL_SDEx_Write_DMADoubleBuffer0CpltCallback   HAL_SDEx_Write_DMADoubleBuf0CpltCallback
S#define HAL_SDEx_Write_DMADoubleBuffer1CpltCallback   HAL_SDEx_Write_DMADoubleBuf1CpltCallback
S#define HAL_SD_DriveTransciver_1_8V_Callback          HAL_SD_DriveTransceiver_1_8V_Callback
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SMARTCARD_Aliased_Macros HAL SMARTCARD Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __SMARTCARD_ENABLE_IT           __HAL_SMARTCARD_ENABLE_IT
N#define __SMARTCARD_DISABLE_IT          __HAL_SMARTCARD_DISABLE_IT
N#define __SMARTCARD_ENABLE              __HAL_SMARTCARD_ENABLE
N#define __SMARTCARD_DISABLE             __HAL_SMARTCARD_DISABLE
N#define __SMARTCARD_DMA_REQUEST_ENABLE  __HAL_SMARTCARD_DMA_REQUEST_ENABLE
N#define __SMARTCARD_DMA_REQUEST_DISABLE __HAL_SMARTCARD_DMA_REQUEST_DISABLE
N
N#define __HAL_SMARTCARD_GETCLOCKSOURCE  SMARTCARD_GETCLOCKSOURCE
N#define __SMARTCARD_GETCLOCKSOURCE      SMARTCARD_GETCLOCKSOURCE
N
N#define IS_SMARTCARD_ONEBIT_SAMPLING    IS_SMARTCARD_ONE_BIT_SAMPLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SMBUS_Aliased_Macros HAL SMBUS Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_SMBUS_RESET_CR1           SMBUS_RESET_CR1
N#define __HAL_SMBUS_RESET_CR2           SMBUS_RESET_CR2
N#define __HAL_SMBUS_GENERATE_START      SMBUS_GENERATE_START
N#define __HAL_SMBUS_GET_ADDR_MATCH      SMBUS_GET_ADDR_MATCH
N#define __HAL_SMBUS_GET_DIR             SMBUS_GET_DIR
N#define __HAL_SMBUS_GET_STOP_MODE       SMBUS_GET_STOP_MODE
N#define __HAL_SMBUS_GET_PEC_MODE        SMBUS_GET_PEC_MODE
N#define __HAL_SMBUS_GET_ALERT_ENABLED   SMBUS_GET_ALERT_ENABLED
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPI_Aliased_Macros HAL SPI Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_SPI_1LINE_TX              SPI_1LINE_TX
N#define __HAL_SPI_1LINE_RX              SPI_1LINE_RX
N#define __HAL_SPI_RESET_CRC             SPI_RESET_CRC
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_UART_Aliased_Macros HAL UART Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_UART_GETCLOCKSOURCE       UART_GETCLOCKSOURCE
N#define __HAL_UART_MASK_COMPUTATION     UART_MASK_COMPUTATION
N#define __UART_GETCLOCKSOURCE           UART_GETCLOCKSOURCE
N#define __UART_MASK_COMPUTATION         UART_MASK_COMPUTATION
N
N#define IS_UART_WAKEUPMETHODE           IS_UART_WAKEUPMETHOD
N
N#define IS_UART_ONEBIT_SAMPLE           IS_UART_ONE_BIT_SAMPLE
N#define IS_UART_ONEBIT_SAMPLING         IS_UART_ONE_BIT_SAMPLE
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_USART_Aliased_Macros HAL USART Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __USART_ENABLE_IT               __HAL_USART_ENABLE_IT
N#define __USART_DISABLE_IT              __HAL_USART_DISABLE_IT
N#define __USART_ENABLE                  __HAL_USART_ENABLE
N#define __USART_DISABLE                 __HAL_USART_DISABLE
N
N#define __HAL_USART_GETCLOCKSOURCE      USART_GETCLOCKSOURCE
N#define __USART_GETCLOCKSOURCE          USART_GETCLOCKSOURCE
N
N#if defined(STM32F0) || defined(STM32F3) || defined(STM32F7)
X#if 0L || 0L || 0L
S#define USART_OVERSAMPLING_16               0x00000000U
S#define USART_OVERSAMPLING_8                USART_CR1_OVER8
S
S#define IS_USART_OVERSAMPLING(__SAMPLING__) (((__SAMPLING__) == USART_OVERSAMPLING_16) || \
S                                             ((__SAMPLING__) == USART_OVERSAMPLING_8))
X#define IS_USART_OVERSAMPLING(__SAMPLING__) (((__SAMPLING__) == USART_OVERSAMPLING_16) ||                                              ((__SAMPLING__) == USART_OVERSAMPLING_8))
N#endif /* STM32F0 || STM32F3 || STM32F7 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_USB_Aliased_Macros HAL USB Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define USB_EXTI_LINE_WAKEUP                               USB_WAKEUP_EXTI_LINE
N
N#define USB_FS_EXTI_TRIGGER_RISING_EDGE                    USB_OTG_FS_WAKEUP_EXTI_RISING_EDGE
N#define USB_FS_EXTI_TRIGGER_FALLING_EDGE                   USB_OTG_FS_WAKEUP_EXTI_FALLING_EDGE
N#define USB_FS_EXTI_TRIGGER_BOTH_EDGE                      USB_OTG_FS_WAKEUP_EXTI_RISING_FALLING_EDGE
N#define USB_FS_EXTI_LINE_WAKEUP                            USB_OTG_FS_WAKEUP_EXTI_LINE
N
N#define USB_HS_EXTI_TRIGGER_RISING_EDGE                    USB_OTG_HS_WAKEUP_EXTI_RISING_EDGE
N#define USB_HS_EXTI_TRIGGER_FALLING_EDGE                   USB_OTG_HS_WAKEUP_EXTI_FALLING_EDGE
N#define USB_HS_EXTI_TRIGGER_BOTH_EDGE                      USB_OTG_HS_WAKEUP_EXTI_RISING_FALLING_EDGE
N#define USB_HS_EXTI_LINE_WAKEUP                            USB_OTG_HS_WAKEUP_EXTI_LINE
N
N#define __HAL_USB_EXTI_ENABLE_IT                           __HAL_USB_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_USB_EXTI_DISABLE_IT                          __HAL_USB_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_USB_EXTI_GET_FLAG                            __HAL_USB_WAKEUP_EXTI_GET_FLAG
N#define __HAL_USB_EXTI_CLEAR_FLAG                          __HAL_USB_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_USB_EXTI_SET_RISING_EDGE_TRIGGER             __HAL_USB_WAKEUP_EXTI_ENABLE_RISING_EDGE
N#define __HAL_USB_EXTI_SET_FALLING_EDGE_TRIGGER            __HAL_USB_WAKEUP_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_USB_EXTI_SET_FALLINGRISING_TRIGGER           __HAL_USB_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
N
N#define __HAL_USB_FS_EXTI_ENABLE_IT                        __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_USB_FS_EXTI_DISABLE_IT                       __HAL_USB_OTG_FS_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_USB_FS_EXTI_GET_FLAG                         __HAL_USB_OTG_FS_WAKEUP_EXTI_GET_FLAG
N#define __HAL_USB_FS_EXTI_CLEAR_FLAG                       __HAL_USB_OTG_FS_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_USB_FS_EXTI_SET_RISING_EGDE_TRIGGER          __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_EDGE
N#define __HAL_USB_FS_EXTI_SET_FALLING_EGDE_TRIGGER         __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_USB_FS_EXTI_SET_FALLINGRISING_TRIGGER        __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
N#define __HAL_USB_FS_EXTI_GENERATE_SWIT                    __HAL_USB_OTG_FS_WAKEUP_EXTI_GENERATE_SWIT
N
N#define __HAL_USB_HS_EXTI_ENABLE_IT                        __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_USB_HS_EXTI_DISABLE_IT                       __HAL_USB_OTG_HS_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_USB_HS_EXTI_GET_FLAG                         __HAL_USB_OTG_HS_WAKEUP_EXTI_GET_FLAG
N#define __HAL_USB_HS_EXTI_CLEAR_FLAG                       __HAL_USB_OTG_HS_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_USB_HS_EXTI_SET_RISING_EGDE_TRIGGER          __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_EDGE
N#define __HAL_USB_HS_EXTI_SET_FALLING_EGDE_TRIGGER         __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_USB_HS_EXTI_SET_FALLINGRISING_TRIGGER        __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
N#define __HAL_USB_HS_EXTI_GENERATE_SWIT                    __HAL_USB_OTG_HS_WAKEUP_EXTI_GENERATE_SWIT
N
N#define HAL_PCD_ActiveRemoteWakeup                         HAL_PCD_ActivateRemoteWakeup
N#define HAL_PCD_DeActiveRemoteWakeup                       HAL_PCD_DeActivateRemoteWakeup
N
N#define HAL_PCD_SetTxFiFo                                  HAL_PCDEx_SetTxFiFo
N#define HAL_PCD_SetRxFiFo                                  HAL_PCDEx_SetRxFiFo
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TIM_Aliased_Macros HAL TIM Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_TIM_SetICPrescalerValue   TIM_SET_ICPRESCALERVALUE
N#define __HAL_TIM_ResetICPrescalerValue TIM_RESET_ICPRESCALERVALUE
N
N#define TIM_GET_ITSTATUS                __HAL_TIM_GET_IT_SOURCE
N#define TIM_GET_CLEAR_IT                __HAL_TIM_CLEAR_IT
N
N#define __HAL_TIM_GET_ITSTATUS          __HAL_TIM_GET_IT_SOURCE
N
N#define __HAL_TIM_DIRECTION_STATUS      __HAL_TIM_IS_TIM_COUNTING_DOWN
N#define __HAL_TIM_PRESCALER             __HAL_TIM_SET_PRESCALER
N#define __HAL_TIM_SetCounter            __HAL_TIM_SET_COUNTER
N#define __HAL_TIM_GetCounter            __HAL_TIM_GET_COUNTER
N#define __HAL_TIM_SetAutoreload         __HAL_TIM_SET_AUTORELOAD
N#define __HAL_TIM_GetAutoreload         __HAL_TIM_GET_AUTORELOAD
N#define __HAL_TIM_SetClockDivision      __HAL_TIM_SET_CLOCKDIVISION
N#define __HAL_TIM_GetClockDivision      __HAL_TIM_GET_CLOCKDIVISION
N#define __HAL_TIM_SetICPrescaler        __HAL_TIM_SET_ICPRESCALER
N#define __HAL_TIM_GetICPrescaler        __HAL_TIM_GET_ICPRESCALER
N#define __HAL_TIM_SetCompare            __HAL_TIM_SET_COMPARE
N#define __HAL_TIM_GetCompare            __HAL_TIM_GET_COMPARE
N
N#define TIM_BREAKINPUTSOURCE_DFSDM  TIM_BREAKINPUTSOURCE_DFSDM1
N/**
N  * @}
N  */
N
N/** @defgroup HAL_ETH_Aliased_Macros HAL ETH Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_ETH_EXTI_ENABLE_IT                   __HAL_ETH_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_ETH_EXTI_DISABLE_IT                  __HAL_ETH_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_ETH_EXTI_GET_FLAG                    __HAL_ETH_WAKEUP_EXTI_GET_FLAG
N#define __HAL_ETH_EXTI_CLEAR_FLAG                  __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_ETH_EXTI_SET_RISING_EGDE_TRIGGER     __HAL_ETH_WAKEUP_EXTI_ENABLE_RISING_EDGE_TRIGGER
N#define __HAL_ETH_EXTI_SET_FALLING_EGDE_TRIGGER    __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLING_EDGE_TRIGGER
N#define __HAL_ETH_EXTI_SET_FALLINGRISING_TRIGGER   __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER
N
N#define ETH_PROMISCIOUSMODE_ENABLE   ETH_PROMISCUOUS_MODE_ENABLE
N#define ETH_PROMISCIOUSMODE_DISABLE  ETH_PROMISCUOUS_MODE_DISABLE
N#define IS_ETH_PROMISCIOUS_MODE      IS_ETH_PROMISCUOUS_MODE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_LTDC_Aliased_Macros HAL LTDC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_LTDC_LAYER LTDC_LAYER
N#define __HAL_LTDC_RELOAD_CONFIG  __HAL_LTDC_RELOAD_IMMEDIATE_CONFIG
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SAI_Aliased_Macros HAL SAI Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define SAI_OUTPUTDRIVE_DISABLED          SAI_OUTPUTDRIVE_DISABLE
N#define SAI_OUTPUTDRIVE_ENABLED           SAI_OUTPUTDRIVE_ENABLE
N#define SAI_MASTERDIVIDER_ENABLED         SAI_MASTERDIVIDER_ENABLE
N#define SAI_MASTERDIVIDER_DISABLED        SAI_MASTERDIVIDER_DISABLE
N#define SAI_STREOMODE                     SAI_STEREOMODE
N#define SAI_FIFOStatus_Empty              SAI_FIFOSTATUS_EMPTY
N#define SAI_FIFOStatus_Less1QuarterFull   SAI_FIFOSTATUS_LESS1QUARTERFULL
N#define SAI_FIFOStatus_1QuarterFull       SAI_FIFOSTATUS_1QUARTERFULL
N#define SAI_FIFOStatus_HalfFull           SAI_FIFOSTATUS_HALFFULL
N#define SAI_FIFOStatus_3QuartersFull      SAI_FIFOSTATUS_3QUARTERFULL
N#define SAI_FIFOStatus_Full               SAI_FIFOSTATUS_FULL
N#define IS_SAI_BLOCK_MONO_STREO_MODE      IS_SAI_BLOCK_MONO_STEREO_MODE
N#define SAI_SYNCHRONOUS_EXT               SAI_SYNCHRONOUS_EXT_SAI1
N#define SAI_SYNCEXT_IN_ENABLE             SAI_SYNCEXT_OUTBLOCKA_ENABLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPDIFRX_Aliased_Macros HAL SPDIFRX Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#if defined(STM32H7)
X#if 0L
S#define HAL_SPDIFRX_ReceiveControlFlow      HAL_SPDIFRX_ReceiveCtrlFlow
S#define HAL_SPDIFRX_ReceiveControlFlow_IT   HAL_SPDIFRX_ReceiveCtrlFlow_IT
S#define HAL_SPDIFRX_ReceiveControlFlow_DMA  HAL_SPDIFRX_ReceiveCtrlFlow_DMA
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_HRTIM_Aliased_Functions HAL HRTIM Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#if defined (STM32H7) || defined (STM32G4) || defined (STM32F3)
X#if 0L || 0L || 0L
S#define HAL_HRTIM_WaveformCounterStart_IT      HAL_HRTIM_WaveformCountStart_IT
S#define HAL_HRTIM_WaveformCounterStart_DMA     HAL_HRTIM_WaveformCountStart_DMA
S#define HAL_HRTIM_WaveformCounterStart         HAL_HRTIM_WaveformCountStart
S#define HAL_HRTIM_WaveformCounterStop_IT       HAL_HRTIM_WaveformCountStop_IT
S#define HAL_HRTIM_WaveformCounterStop_DMA      HAL_HRTIM_WaveformCountStop_DMA
S#define HAL_HRTIM_WaveformCounterStop          HAL_HRTIM_WaveformCountStop
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_QSPI_Aliased_Macros HAL QSPI Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#if defined (STM32L4) || defined (STM32F4) || defined (STM32F7) || defined(STM32H7)
X#if 0L || 1L || 0L || 0L
N#define HAL_QPSI_TIMEOUT_DEFAULT_VALUE HAL_QSPI_TIMEOUT_DEFAULT_VALUE
N#endif /* STM32L4 || STM32F4 || STM32F7 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_PPP_Aliased_Macros HAL PPP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* STM32_HAL_LEGACY */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 35 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h" 2
N#include <stddef.h>
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060009
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 36 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  HAL Status structures definition  
N  */  
Ntypedef enum 
N{
N  HAL_OK       = 0x00U,
N  HAL_ERROR    = 0x01U,
N  HAL_BUSY     = 0x02U,
N  HAL_TIMEOUT  = 0x03U
N} HAL_StatusTypeDef;
N
N/** 
N  * @brief  HAL Lock structures definition  
N  */
Ntypedef enum 
N{
N  HAL_UNLOCKED = 0x00U,
N  HAL_LOCKED   = 0x01U  
N} HAL_LockTypeDef;
N
N/* Exported macro ------------------------------------------------------------*/
N
N#define UNUSED(X) (void)X      /* To avoid gcc/g++ warnings */
N
N#define HAL_MAX_DELAY      0xFFFFFFFFU
N
N#define HAL_IS_BIT_SET(REG, BIT)         (((REG) & (BIT)) == (BIT))
N#define HAL_IS_BIT_CLR(REG, BIT)         (((REG) & (BIT)) == 0U)
N
N#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)               \
N                        do{                                                      \
N                              (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__); \
N                              (__DMA_HANDLE__).Parent = (__HANDLE__);             \
N                          } while(0U)
X#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)                                       do{                                                                                    (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__);                               (__DMA_HANDLE__).Parent = (__HANDLE__);                                       } while(0U)
N
N/** @brief Reset the Handle's State field.
N  * @param __HANDLE__ specifies the Peripheral Handle.
N  * @note  This macro can be used for the following purpose: 
N  *          - When the Handle is declared as local variable; before passing it as parameter
N  *            to HAL_PPP_Init() for the first time, it is mandatory to use this macro 
N  *            to set to 0 the Handle's "State" field.
N  *            Otherwise, "State" field may have any random value and the first time the function 
N  *            HAL_PPP_Init() is called, the low level hardware initialization will be missed
N  *            (i.e. HAL_PPP_MspInit() will not be executed).
N  *          - When there is a need to reconfigure the low level hardware: instead of calling
N  *            HAL_PPP_DeInit() then HAL_PPP_Init(), user can make a call to this macro then HAL_PPP_Init().
N  *            In this later function, when the Handle's "State" field is set to 0, it will execute the function
N  *            HAL_PPP_MspInit() which will reconfigure the low level hardware.
N  * @retval None
N  */
N#define __HAL_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = 0U)
N
N#if (USE_RTOS == 1U)
X#if (0U == 1U)
S  /* Reserved for future use */
S  #error "USE_RTOS should be 0 in the current HAL release"
N#else
N  #define __HAL_LOCK(__HANDLE__)                                           \
N                                do{                                        \
N                                    if((__HANDLE__)->Lock == HAL_LOCKED)   \
N                                    {                                      \
N                                       return HAL_BUSY;                    \
N                                    }                                      \
N                                    else                                   \
N                                    {                                      \
N                                       (__HANDLE__)->Lock = HAL_LOCKED;    \
N                                    }                                      \
N                                  }while (0U)
X  #define __HAL_LOCK(__HANDLE__)                                                                           do{                                                                            if((__HANDLE__)->Lock == HAL_LOCKED)                                       {                                                                             return HAL_BUSY;                                                        }                                                                          else                                                                       {                                                                             (__HANDLE__)->Lock = HAL_LOCKED;                                        }                                                                        }while (0U)
N
N  #define __HAL_UNLOCK(__HANDLE__)                                          \
N                                  do{                                       \
N                                      (__HANDLE__)->Lock = HAL_UNLOCKED;    \
N                                    }while (0U)
X  #define __HAL_UNLOCK(__HANDLE__)                                                                            do{                                                                             (__HANDLE__)->Lock = HAL_UNLOCKED;                                        }while (0U)
N#endif /* USE_RTOS */
N
N#if  defined ( __GNUC__ ) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
X#if  0L || (1L && (5060183 >= 6010050))
S  #ifndef __weak
S    #define __weak   __attribute__((weak))
S  #endif /* __weak */
S  #ifndef __packed
S    #define __packed __attribute__((__packed__))
S  #endif /* __packed */
N#endif /* __GNUC__, ARM Compiler 6*/
N
N
N/* Macro to get variable aligned on 4-bytes, for __ICCARM__ the directive "#pragma data_alignment=4" must be used instead */
N#if defined   (__GNUC__) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
X#if 0L || (1L && (5060183 >= 6010050))
S  #ifndef __ALIGN_END
S    #define __ALIGN_END    __attribute__ ((aligned (4)))
S  #endif /* __ALIGN_END */
S  #ifndef __ALIGN_BEGIN  
S    #define __ALIGN_BEGIN
S  #endif /* __ALIGN_BEGIN */
N#else
N  #ifndef __ALIGN_END
N    #define __ALIGN_END
N  #endif /* __ALIGN_END */
N  #ifndef __ALIGN_BEGIN      
N    #if defined   (__CC_ARM)      /* ARM Compiler */
X    #if 1L       
N      #define __ALIGN_BEGIN    __align(4)
N    #elif defined (__ICCARM__)    /* IAR Compiler */
S      #define __ALIGN_BEGIN 
N    #endif /* __CC_ARM */
N  #endif /* __ALIGN_BEGIN */
N#endif /* __GNUC__, ARM Compiler 6 */
N
N
N/** 
N  * @brief  __RAM_FUNC definition
N  */ 
N#if defined ( __CC_ARM   ) && (defined (__ARMCC_VERSION) && (__ARMCC_VERSION < 6010050))
X#if 1L && (1L && (5060183 < 6010050))
N/* ARM Compiler
N   ------------
N   RAM functions are defined using the toolchain options. 
N   Functions that are executed in RAM should reside in a separate source module.
N   Using the 'Options for File' dialog you can simply change the 'Code / Const' 
N   area of a module to a memory space in physical RAM.
N   Available memory areas are declared in the 'Target' tab of the 'Options for Target'
N   dialog. 
N*/
N#define __RAM_FUNC
N
N#elif defined ( __ICCARM__ )
S/* ICCARM Compiler
S   ---------------
S   RAM functions are defined using a specific toolchain keyword "__ramfunc". 
S*/
S#define __RAM_FUNC __ramfunc
S
S#elif defined   (  __GNUC__  ) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
S/* GNU Compiler, ARM Compiler 6
S   ------------
S  RAM functions are defined using a specific toolchain attribute 
S   "__attribute__((section(".RamFunc")))".
S*/
S#define __RAM_FUNC __attribute__((section(".RamFunc")))
S
N#endif
N
N/** 
N  * @brief  __NOINLINE definition
N  */ 
N#if defined ( __CC_ARM   ) || defined   (  __GNUC__  )
X#if 1L || 0L
N/* ARM & GNUCompiler 
N   ---------------- 
N*/
N#define __NOINLINE __attribute__ ( (noinline) )
N
N#elif defined ( __ICCARM__ )
S/* ICCARM Compiler
S   ---------------
S*/
S#define __NOINLINE _Pragma("optimize = no_inline")
S
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* ___STM32F4xx_HAL_DEF */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 30 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rcc.h" 2
N
N/* Include RCC HAL Extended module */
N/* (include on top of file since RCC structures are defined in extended file) */
N#include "stm32f4xx_hal_rcc_ex.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rcc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_rcc_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of RCC HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_RCC_EX_H
N#define __STM32F4xx_HAL_RCC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RCCEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Types RCCEx Exported Types
N  * @{
N  */
N
N/**
N  * @brief  RCC PLL configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t PLLState;   /*!< The new state of the PLL.
N                            This parameter can be a value of @ref RCC_PLL_Config                      */
N
N  uint32_t PLLSource;  /*!< RCC_PLLSource: PLL entry clock source.
N                            This parameter must be a value of @ref RCC_PLL_Clock_Source               */
N
N  uint32_t PLLM;       /*!< PLLM: Division factor for PLL VCO input clock.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 63    */
N
N  uint32_t PLLN;       /*!< PLLN: Multiplication factor for PLL VCO output clock.
N                            This parameter must be a number between Min_Data = 50 and Max_Data = 432 
N                            except for STM32F411xE devices where the Min_Data = 192 */
N
N  uint32_t PLLP;       /*!< PLLP: Division factor for main system clock (SYSCLK).
N                            This parameter must be a value of @ref RCC_PLLP_Clock_Divider             */
N
N  uint32_t PLLQ;       /*!< PLLQ: Division factor for OTG FS, SDIO and RNG clocks.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 15    */
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L || 0L ||    0L || 0L
S  uint32_t PLLR;       /*!< PLLR: PLL division factor for I2S, SAI, SYSTEM, SPDIFRX clocks.
S                            This parameter is only available in STM32F410xx/STM32F446xx/STM32F469xx/STM32F479xx
S                            and STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/STM32F413xx/STM32F423xx devices. 
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7     */
N#endif /* STM32F410xx || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */ 
N}RCC_PLLInitTypeDef;
N
N#if defined(STM32F446xx)
X#if 0L
S/** 
S  * @brief  PLLI2S Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLI2SM;    /*!< Specifies division factor for PLL VCO input clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 63       */
S
S  uint32_t PLLI2SN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432    */
S
S  uint32_t PLLI2SP;    /*!< Specifies division factor for SPDIFRX Clock.
S                            This parameter must be a value of @ref RCCEx_PLLI2SP_Clock_Divider           */
S
S  uint32_t PLLI2SQ;    /*!< Specifies the division factor for SAI clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S                           
S  uint32_t PLLI2SR;    /*!< Specifies the division factor for I2S clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source I2S */
S}RCC_PLLI2SInitTypeDef;
S
S/** 
S  * @brief  PLLSAI Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLSAIM;    /*!< Specifies division factor for PLL VCO input clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 63       */
S
S  uint32_t PLLSAIN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432    */
S
S  uint32_t PLLSAIP;    /*!< Specifies division factor for OTG FS, SDIO and RNG clocks.
S                            This parameter must be a value of @ref RCCEx_PLLSAIP_Clock_Divider           */
S                                                             
S  uint32_t PLLSAIQ;    /*!< Specifies the division factor for SAI clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S                            This parameter will be used only when PLLSAI is selected as Clock Source SAI */
S}RCC_PLLSAIInitTypeDef;
S
S/** 
S  * @brief  RCC extended clocks structure definition  
S  */
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  RCC_PLLI2SInitTypeDef PLLI2S;  /*!< PLL I2S structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
S
S  RCC_PLLSAIInitTypeDef PLLSAI;  /*!< PLL SAI structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI or LTDC */
S
S  uint32_t PLLI2SDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S
S  uint32_t PLLSAIDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLSAI is selected as Clock Source SAI */
S
S  uint32_t Sai1ClockSelection;    /*!< Specifies SAI1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SAI1_Clock_Source */
S
S  uint32_t Sai2ClockSelection;    /*!< Specifies SAI2 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SAI2_Clock_Source */
S                                      
S  uint32_t I2sApb1ClockSelection;    /*!< Specifies I2S APB1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2SAPB1_Clock_Source */
S
S  uint32_t I2sApb2ClockSelection;    /*!< Specifies I2S APB2 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2SAPB2_Clock_Source */
S
S  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t SdioClockSelection;    /*!< Specifies SDIO Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SDIO_Clock_Source */
S
S  uint32_t CecClockSelection;      /*!< Specifies CEC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_CEC_Clock_Source */
S
S  uint32_t Fmpi2c1ClockSelection;  /*!< Specifies FMPI2C1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_FMPI2C1_Clock_Source */
S
S  uint32_t SpdifClockSelection;    /*!< Specifies SPDIFRX Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SPDIFRX_Clock_Source */
S
S  uint32_t Clk48ClockSelection;     /*!< Specifies CLK48 Clock Selection this clock used OTG FS, SDIO and RNG clocks. 
S                                      This parameter can be a value of @ref RCCEx_CLK48_Clock_Source */
S  
S  uint8_t TIMPresSelection;      /*!< Specifies TIM Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F446xx */   
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** 
S  * @brief  RCC extended clocks structure definition
S  */
Stypedef struct
S{
S  uint32_t PeriphClockSelection;   /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  uint32_t I2SClockSelection;      /*!< Specifies RTC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2S_APB_Clock_Source */
S                                      
S  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t Lptim1ClockSelection;   /*!< Specifies LPTIM1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_LPTIM1_Clock_Source */
S  
S  uint32_t Fmpi2c1ClockSelection;  /*!< Specifies FMPI2C1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_FMPI2C1_Clock_Source */
S
S  uint8_t TIMPresSelection;        /*!< Specifies TIM Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** 
S  * @brief  PLLI2S Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLI2SM;    /*!< Specifies division factor for PLL VCO input clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 63       */
S
S  uint32_t PLLI2SN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432    */
S
S  uint32_t PLLI2SQ;    /*!< Specifies the division factor for SAI clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S                           
S  uint32_t PLLI2SR;    /*!< Specifies the division factor for I2S clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source I2S */
S}RCC_PLLI2SInitTypeDef;
S
S/** 
S  * @brief  RCC extended clocks structure definition
S  */
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  RCC_PLLI2SInitTypeDef PLLI2S;  /*!< PLL I2S structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S */
S  
S#if defined(STM32F413xx) || defined(STM32F423xx)
S  uint32_t PLLDivR;              /*!< Specifies the PLL division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLL is selected as Clock Source SAI */
S
S  uint32_t PLLI2SDivR;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S#endif /* STM32F413xx || STM32F423xx */  
S                                      
S  uint32_t I2sApb1ClockSelection;    /*!< Specifies I2S APB1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2SAPB1_Clock_Source */
S
S  uint32_t I2sApb2ClockSelection;    /*!< Specifies I2S APB2 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2SAPB2_Clock_Source */
S
S  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t SdioClockSelection;    /*!< Specifies SDIO Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SDIO_Clock_Source */
S
S  uint32_t Fmpi2c1ClockSelection;  /*!< Specifies FMPI2C1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_FMPI2C1_Clock_Source */
S
S  uint32_t Clk48ClockSelection;     /*!< Specifies CLK48 Clock Selection this clock used OTG FS, SDIO and RNG clocks.
S                                      This parameter can be a value of @ref RCCEx_CLK48_Clock_Source */
S  
S  uint32_t Dfsdm1ClockSelection;    /*!< Specifies DFSDM1 Clock Selection.
S                                      This parameter can be a value of @ref RCCEx_DFSDM1_Kernel_Clock_Source */
S
S  uint32_t Dfsdm1AudioClockSelection;/*!< Specifies DFSDM1 Audio Clock Selection.
S                                      This parameter can be a value of @ref RCCEx_DFSDM1_Audio_Clock_Source */
S  
S#if defined(STM32F413xx) || defined(STM32F423xx)
S  uint32_t Dfsdm2ClockSelection;    /*!< Specifies DFSDM2 Clock Selection.
S                                      This parameter can be a value of @ref RCCEx_DFSDM2_Kernel_Clock_Source */
S
S  uint32_t Dfsdm2AudioClockSelection;/*!< Specifies DFSDM2 Audio Clock Selection.
S                                      This parameter can be a value of @ref RCCEx_DFSDM2_Audio_Clock_Source */
S  
S  uint32_t Lptim1ClockSelection;   /*!< Specifies LPTIM1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_LPTIM1_Clock_Source */
S  
S  uint32_t SaiAClockSelection;     /*!< Specifies SAI1_A Clock Prescalers Selection
S                                        This parameter can be a value of @ref RCCEx_SAI1_BlockA_Clock_Source */
S
S  uint32_t SaiBClockSelection;     /*!< Specifies SAI1_B Clock Prescalers Selection
S                                        This parameter can be a value of @ref RCCEx_SAI1_BlockB_Clock_Source */
S#endif /* STM32F413xx || STM32F423xx */
S
S  uint32_t PLLI2SSelection;      /*!< Specifies PLL I2S Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_PLL_I2S_Clock_Source */
S
S  uint8_t TIMPresSelection;      /*!< Specifies TIM Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S
S/** 
S  * @brief  PLLI2S Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLI2SN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
S
S  uint32_t PLLI2SR;    /*!< Specifies the division factor for I2S clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
S
S  uint32_t PLLI2SQ;    /*!< Specifies the division factor for SAI1 clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S}RCC_PLLI2SInitTypeDef;
S
S/** 
S  * @brief  PLLSAI Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLSAIN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S                            This parameter will be used only when PLLSAI is selected as Clock Source SAI or LTDC */ 
S#if defined(STM32F469xx) || defined(STM32F479xx)
S  uint32_t PLLSAIP;    /*!< Specifies division factor for OTG FS and SDIO clocks.
S                            This parameter is only available in STM32F469xx/STM32F479xx devices.
S                            This parameter must be a value of @ref RCCEx_PLLSAIP_Clock_Divider  */  
S#endif /* STM32F469xx || STM32F479xx */
S                                 
S  uint32_t PLLSAIQ;    /*!< Specifies the division factor for SAI1 clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S                            This parameter will be used only when PLLSAI is selected as Clock Source SAI or LTDC */
S                              
S  uint32_t PLLSAIR;    /*!< specifies the division factor for LTDC clock
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S                            This parameter will be used only when PLLSAI is selected as Clock Source LTDC */
S
S}RCC_PLLSAIInitTypeDef;
S
S/** 
S  * @brief  RCC extended clocks structure definition  
S  */
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  RCC_PLLI2SInitTypeDef PLLI2S;  /*!< PLL I2S structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
S
S  RCC_PLLSAIInitTypeDef PLLSAI;  /*!< PLL SAI structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI or LTDC */
S
S  uint32_t PLLI2SDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S
S  uint32_t PLLSAIDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLSAI is selected as Clock Source SAI */
S
S  uint32_t PLLSAIDivR;           /*!< Specifies the PLLSAI division factor for LTDC clock.
S                                      This parameter must be one value of @ref RCCEx_PLLSAI_DIVR */
S
S  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Prescalers Selection. 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint8_t TIMPresSelection;      /*!< Specifies TIM Clock Prescalers Selection. 
S                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
S#if defined(STM32F469xx) || defined(STM32F479xx)
S  uint32_t Clk48ClockSelection;  /*!< Specifies CLK48 Clock Selection this clock used OTG FS, SDIO and RNG clocks. 
S                                      This parameter can be a value of @ref RCCEx_CLK48_Clock_Source */
S
S  uint32_t SdioClockSelection;   /*!< Specifies SDIO Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SDIO_Clock_Source */  
S#endif /* STM32F469xx || STM32F479xx */  
S}RCC_PeriphCLKInitTypeDef;
S
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
X#if 0L || 0L || 1L || 0L ||    0L || 0L || 0L
N/** 
N  * @brief  PLLI2S Clock structure definition  
N  */
Ntypedef struct
N{
N#if defined(STM32F411xE)
X#if 0L
S  uint32_t PLLI2SM;    /*!< PLLM: Division factor for PLLI2S VCO input clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 62  */
N#endif /* STM32F411xE */
N                                
N  uint32_t PLLI2SN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
N                            This parameter must be a number between Min_Data = 50 and Max_Data = 432
N                            Except for STM32F411xE devices where the Min_Data = 192. 
N                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
N
N  uint32_t PLLI2SR;    /*!< Specifies the division factor for I2S clock.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 7. 
N                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
N
N}RCC_PLLI2SInitTypeDef;
N 
N/** 
N  * @brief  RCC extended clocks structure definition  
N  */
Ntypedef struct
N{
N  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
N                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
N
N  RCC_PLLI2SInitTypeDef PLLI2S;  /*!< PLL I2S structure parameters.
N                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
N
N  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Prescalers Selection.
N                                       This parameter can be a value of @ref RCC_RTC_Clock_Source */
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) 
X#if 0L || 0L || 0L 
S  uint8_t TIMPresSelection;        /*!< Specifies TIM Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
N#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
N}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F411xE */
N/**
N  * @}
N  */ 
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Constants RCCEx Exported Constants
N  * @{
N  */
N
N/** @defgroup RCCEx_Periph_Clock_Selection RCC Periph Clock Selection
N  * @{
N  */
N/* Peripheral Clock source for STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx */
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define RCC_PERIPHCLK_I2S_APB1        0x00000001U
S#define RCC_PERIPHCLK_I2S_APB2        0x00000002U
S#define RCC_PERIPHCLK_TIM             0x00000004U
S#define RCC_PERIPHCLK_RTC             0x00000008U
S#define RCC_PERIPHCLK_FMPI2C1         0x00000010U
S#define RCC_PERIPHCLK_CLK48           0x00000020U
S#define RCC_PERIPHCLK_SDIO            0x00000040U
S#define RCC_PERIPHCLK_PLLI2S          0x00000080U
S#define RCC_PERIPHCLK_DFSDM1          0x00000100U
S#define RCC_PERIPHCLK_DFSDM1_AUDIO    0x00000200U
N#endif /* STM32F412Zx || STM32F412Vx) || STM32F412Rx || STM32F412Cx */
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define RCC_PERIPHCLK_DFSDM2          0x00000400U
S#define RCC_PERIPHCLK_DFSDM2_AUDIO    0x00000800U
S#define RCC_PERIPHCLK_LPTIM1          0x00001000U
S#define RCC_PERIPHCLK_SAIA            0x00002000U
S#define RCC_PERIPHCLK_SAIB            0x00004000U
N#endif /* STM32F413xx || STM32F423xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------- Peripheral Clock source for STM32F410xx ----------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define RCC_PERIPHCLK_I2S             0x00000001U
S#define RCC_PERIPHCLK_TIM             0x00000002U
S#define RCC_PERIPHCLK_RTC             0x00000004U
S#define RCC_PERIPHCLK_FMPI2C1         0x00000008U
S#define RCC_PERIPHCLK_LPTIM1          0x00000010U
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------- Peripheral Clock source for STM32F446xx ----------------*/
N#if defined(STM32F446xx)
X#if 0L
S#define RCC_PERIPHCLK_I2S_APB1        0x00000001U
S#define RCC_PERIPHCLK_I2S_APB2        0x00000002U
S#define RCC_PERIPHCLK_SAI1            0x00000004U
S#define RCC_PERIPHCLK_SAI2            0x00000008U
S#define RCC_PERIPHCLK_TIM             0x00000010U
S#define RCC_PERIPHCLK_RTC             0x00000020U
S#define RCC_PERIPHCLK_CEC             0x00000040U
S#define RCC_PERIPHCLK_FMPI2C1         0x00000080U
S#define RCC_PERIPHCLK_CLK48           0x00000100U
S#define RCC_PERIPHCLK_SDIO            0x00000200U
S#define RCC_PERIPHCLK_SPDIFRX         0x00000400U
S#define RCC_PERIPHCLK_PLLI2S          0x00000800U
N#endif /* STM32F446xx */
N/*-----------------------------------------------------------------------------*/
N    
N/*----------- Peripheral Clock source for STM32F469xx/STM32F479xx -------------*/
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S#define RCC_PERIPHCLK_I2S             0x00000001U
S#define RCC_PERIPHCLK_SAI_PLLI2S      0x00000002U
S#define RCC_PERIPHCLK_SAI_PLLSAI      0x00000004U
S#define RCC_PERIPHCLK_LTDC            0x00000008U
S#define RCC_PERIPHCLK_TIM             0x00000010U
S#define RCC_PERIPHCLK_RTC             0x00000020U
S#define RCC_PERIPHCLK_PLLI2S          0x00000040U
S#define RCC_PERIPHCLK_CLK48           0x00000080U
S#define RCC_PERIPHCLK_SDIO            0x00000100U
N#endif /* STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*-------- Peripheral Clock source for STM32F42xxx/STM32F43xxx ---------------*/
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
X#if 0L || 0L || 0L || 0L
S#define RCC_PERIPHCLK_I2S             0x00000001U
S#define RCC_PERIPHCLK_SAI_PLLI2S      0x00000002U
S#define RCC_PERIPHCLK_SAI_PLLSAI      0x00000004U
S#define RCC_PERIPHCLK_LTDC            0x00000008U
S#define RCC_PERIPHCLK_TIM             0x00000010U
S#define RCC_PERIPHCLK_RTC             0x00000020U
S#define RCC_PERIPHCLK_PLLI2S          0x00000040U
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */
N/*----------------------------------------------------------------------------*/
N
N/*-------- Peripheral Clock source for STM32F40xxx/STM32F41xxx ---------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) 
X#if 0L || 0L || 1L|| 0L ||    0L || 0L || 0L 
N#define RCC_PERIPHCLK_I2S             0x00000001U
N#define RCC_PERIPHCLK_RTC             0x00000002U
N#define RCC_PERIPHCLK_PLLI2S          0x00000004U
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F411xE */
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
X#if 0L || 0L || 0L
S#define RCC_PERIPHCLK_TIM             0x00000008U
N#endif /* STM32F401xC || STM32F401xE || STM32F411xE */      
N/*----------------------------------------------------------------------------*/
N/**
N  * @}
N  */
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F469xx) || \
N    defined(STM32F479xx) 
X#if 0L || 0L || 1L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L 
N/** @defgroup RCCEx_I2S_Clock_Source I2S Clock Source
N  * @{
N  */
N#define RCC_I2SCLKSOURCE_PLLI2S         0x00000000U
N#define RCC_I2SCLKSOURCE_EXT            0x00000001U
N/**
N  * @}
N  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F469xx || STM32F479xx */
N
N/** @defgroup RCCEx_PLLSAI_DIVR RCC PLLSAI DIVR
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F446xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L 
S#define RCC_PLLSAIDIVR_2                0x00000000U
S#define RCC_PLLSAIDIVR_4                0x00010000U
S#define RCC_PLLSAIDIVR_8                0x00020000U
S#define RCC_PLLSAIDIVR_16               0x00030000U
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_PLLI2SP_Clock_Divider RCC PLLI2SP Clock Divider
N  * @{
N  */
N#if defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx)
X#if 0L || 0L || 0L ||     0L || 0L
S#define RCC_PLLI2SP_DIV2                  0x00000002U
S#define RCC_PLLI2SP_DIV4                  0x00000004U
S#define RCC_PLLI2SP_DIV6                  0x00000006U
S#define RCC_PLLI2SP_DIV8                  0x00000008U
N#endif /* STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_PLLSAIP_Clock_Divider RCC PLLSAIP Clock Divider
N  * @{
N  */
N#if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L 
S#define RCC_PLLSAIP_DIV2                  0x00000002U
S#define RCC_PLLSAIP_DIV4                  0x00000004U
S#define RCC_PLLSAIP_DIV6                  0x00000006U
S#define RCC_PLLSAIP_DIV8                  0x00000008U
N#endif /* STM32F446xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** @defgroup RCCEx_SAI_BlockA_Clock_Source  RCC SAI BlockA Clock Source
S  * @{
S  */
S#define RCC_SAIACLKSOURCE_PLLSAI             0x00000000U
S#define RCC_SAIACLKSOURCE_PLLI2S             0x00100000U
S#define RCC_SAIACLKSOURCE_EXT                0x00200000U
S/**
S  * @}
S  */ 
S
S/** @defgroup RCCEx_SAI_BlockB_Clock_Source  RCC SAI BlockB Clock Source
S  * @{
S  */
S#define RCC_SAIBCLKSOURCE_PLLSAI             0x00000000U
S#define RCC_SAIBCLKSOURCE_PLLI2S             0x00400000U
S#define RCC_SAIBCLKSOURCE_EXT                0x00800000U
S/**
S  * @}
S  */ 
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N      
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S/** @defgroup RCCEx_CLK48_Clock_Source  RCC CLK48 Clock Source
S  * @{
S  */
S#define RCC_CLK48CLKSOURCE_PLLQ              0x00000000U
S#define RCC_CLK48CLKSOURCE_PLLSAIP           ((uint32_t)RCC_DCKCFGR_CK48MSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_SDIO_Clock_Source  RCC SDIO Clock Source
S  * @{
S  */
S#define RCC_SDIOCLKSOURCE_CLK48             0x00000000U
S#define RCC_SDIOCLKSOURCE_SYSCLK            ((uint32_t)RCC_DCKCFGR_SDIOSEL)
S/**
S  * @}
S  */    
S  
S/** @defgroup RCCEx_DSI_Clock_Source  RCC DSI Clock Source
S  * @{
S  */
S#define RCC_DSICLKSOURCE_DSIPHY             0x00000000U
S#define RCC_DSICLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_DSISEL)
S/**
S  * @}
S  */
N#endif /* STM32F469xx || STM32F479xx */
N
N#if defined(STM32F446xx)
X#if 0L
S/** @defgroup RCCEx_SAI1_Clock_Source RCC SAI1 Clock Source 
S  * @{
S  */
S#define RCC_SAI1CLKSOURCE_PLLSAI             0x00000000U
S#define RCC_SAI1CLKSOURCE_PLLI2S             ((uint32_t)RCC_DCKCFGR_SAI1SRC_0)
S#define RCC_SAI1CLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_SAI1SRC_1)
S#define RCC_SAI1CLKSOURCE_EXT                ((uint32_t)RCC_DCKCFGR_SAI1SRC)
S/**
S  * @}
S  */ 
S
S/** @defgroup RCCEx_SAI2_Clock_Source  RCC SAI2 Clock Source
S  * @{
S  */
S#define RCC_SAI2CLKSOURCE_PLLSAI             0x00000000U
S#define RCC_SAI2CLKSOURCE_PLLI2S             ((uint32_t)RCC_DCKCFGR_SAI2SRC_0)
S#define RCC_SAI2CLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_SAI2SRC_1)
S#define RCC_SAI2CLKSOURCE_PLLSRC             ((uint32_t)RCC_DCKCFGR_SAI2SRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_I2SAPB1_Clock_Source  RCC I2S APB1 Clock Source
S  * @{
S  */
S#define RCC_I2SAPB1CLKSOURCE_PLLI2S          0x00000000U
S#define RCC_I2SAPB1CLKSOURCE_EXT             ((uint32_t)RCC_DCKCFGR_I2S1SRC_0)
S#define RCC_I2SAPB1CLKSOURCE_PLLR            ((uint32_t)RCC_DCKCFGR_I2S1SRC_1)
S#define RCC_I2SAPB1CLKSOURCE_PLLSRC          ((uint32_t)RCC_DCKCFGR_I2S1SRC)
S/**
S  * @}
S  */ 
S
S/** @defgroup RCCEx_I2SAPB2_Clock_Source  RCC I2S APB2 Clock Source
S  * @{
S  */
S#define RCC_I2SAPB2CLKSOURCE_PLLI2S          0x00000000U
S#define RCC_I2SAPB2CLKSOURCE_EXT             ((uint32_t)RCC_DCKCFGR_I2S2SRC_0)
S#define RCC_I2SAPB2CLKSOURCE_PLLR            ((uint32_t)RCC_DCKCFGR_I2S2SRC_1)
S#define RCC_I2SAPB2CLKSOURCE_PLLSRC          ((uint32_t)RCC_DCKCFGR_I2S2SRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_FMPI2C1_Clock_Source  RCC FMPI2C1 Clock Source
S  * @{
S  */
S#define RCC_FMPI2C1CLKSOURCE_PCLK1            0x00000000U
S#define RCC_FMPI2C1CLKSOURCE_SYSCLK           ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_0)
S#define RCC_FMPI2C1CLKSOURCE_HSI              ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_1)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_CEC_Clock_Source  RCC CEC Clock Source
S  * @{
S  */
S#define RCC_CECCLKSOURCE_HSI                0x00000000U
S#define RCC_CECCLKSOURCE_LSE                ((uint32_t)RCC_DCKCFGR2_CECSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_CLK48_Clock_Source  RCC CLK48 Clock Source
S  * @{
S  */
S#define RCC_CLK48CLKSOURCE_PLLQ              0x00000000U
S#define RCC_CLK48CLKSOURCE_PLLSAIP           ((uint32_t)RCC_DCKCFGR2_CK48MSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_SDIO_Clock_Source  RCC SDIO Clock Source
S  * @{
S  */
S#define RCC_SDIOCLKSOURCE_CLK48             0x00000000U
S#define RCC_SDIOCLKSOURCE_SYSCLK            ((uint32_t)RCC_DCKCFGR2_SDIOSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_SPDIFRX_Clock_Source   RCC SPDIFRX Clock Source
S  * @{
S  */
S#define RCC_SPDIFRXCLKSOURCE_PLLR           0x00000000U
S#define RCC_SPDIFRXCLKSOURCE_PLLI2SP        ((uint32_t)RCC_DCKCFGR2_SPDIFRXSEL)
S/**
S  * @}
S  */
S
N#endif /* STM32F446xx */
N
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S/** @defgroup RCCEx_SAI1_BlockA_Clock_Source  RCC SAI BlockA Clock Source
S  * @{
S  */
S#define RCC_SAIACLKSOURCE_PLLI2SR            0x00000000U
S#define RCC_SAIACLKSOURCE_EXT                ((uint32_t)RCC_DCKCFGR_SAI1ASRC_0)
S#define RCC_SAIACLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_SAI1ASRC_1)
S#define RCC_SAIACLKSOURCE_PLLSRC             ((uint32_t)RCC_DCKCFGR_SAI1ASRC_0 | RCC_DCKCFGR_SAI1ASRC_1)
S/**
S  * @}
S  */ 
S
S/** @defgroup RCCEx_SAI1_BlockB_Clock_Source  RCC SAI BlockB Clock Source
S  * @{
S  */
S#define RCC_SAIBCLKSOURCE_PLLI2SR            0x00000000U
S#define RCC_SAIBCLKSOURCE_EXT                ((uint32_t)RCC_DCKCFGR_SAI1BSRC_0)
S#define RCC_SAIBCLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_SAI1BSRC_1)
S#define RCC_SAIBCLKSOURCE_PLLSRC             ((uint32_t)RCC_DCKCFGR_SAI1BSRC_0 | RCC_DCKCFGR_SAI1BSRC_1)
S/**
S  * @}
S  */ 
S      
S/** @defgroup RCCEx_LPTIM1_Clock_Source  RCC LPTIM1 Clock Source
S  * @{
S  */
S#define RCC_LPTIM1CLKSOURCE_PCLK1           0x00000000U
S#define RCC_LPTIM1CLKSOURCE_HSI             ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0)
S#define RCC_LPTIM1CLKSOURCE_LSI             ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_1)
S#define RCC_LPTIM1CLKSOURCE_LSE             ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0 | RCC_DCKCFGR2_LPTIM1SEL_1)
S/**
S  * @}
S  */
S      
S
S/** @defgroup RCCEx_DFSDM2_Audio_Clock_Source  RCC DFSDM2 Audio Clock Source
S  * @{
S  */
S#define RCC_DFSDM2AUDIOCLKSOURCE_I2S1       0x00000000U
S#define RCC_DFSDM2AUDIOCLKSOURCE_I2S2       ((uint32_t)RCC_DCKCFGR_CKDFSDM2ASEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_DFSDM2_Kernel_Clock_Source  RCC DFSDM2 Kernel Clock Source
S  * @{
S  */
S#define RCC_DFSDM2CLKSOURCE_PCLK2           0x00000000U
S#define RCC_DFSDM2CLKSOURCE_SYSCLK          ((uint32_t)RCC_DCKCFGR_CKDFSDM1SEL)
S/**
S  * @}
S  */
S
N#endif /* STM32F413xx || STM32F423xx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** @defgroup RCCEx_PLL_I2S_Clock_Source PLL I2S Clock Source
S  * @{
S  */
S#define RCC_PLLI2SCLKSOURCE_PLLSRC          0x00000000U 
S#define RCC_PLLI2SCLKSOURCE_EXT             ((uint32_t)RCC_PLLI2SCFGR_PLLI2SSRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_DFSDM1_Audio_Clock_Source  RCC DFSDM1 Audio Clock Source
S  * @{
S  */
S#define RCC_DFSDM1AUDIOCLKSOURCE_I2S1       0x00000000U
S#define RCC_DFSDM1AUDIOCLKSOURCE_I2S2       ((uint32_t)RCC_DCKCFGR_CKDFSDM1ASEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_DFSDM1_Kernel_Clock_Source  RCC DFSDM1 Kernel Clock Source
S  * @{
S  */
S#define RCC_DFSDM1CLKSOURCE_PCLK2           0x00000000U
S#define RCC_DFSDM1CLKSOURCE_SYSCLK          ((uint32_t)RCC_DCKCFGR_CKDFSDM1SEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_I2SAPB1_Clock_Source  RCC I2S APB1 Clock Source
S  * @{
S  */
S#define RCC_I2SAPB1CLKSOURCE_PLLI2S         0x00000000U
S#define RCC_I2SAPB1CLKSOURCE_EXT            ((uint32_t)RCC_DCKCFGR_I2S1SRC_0)
S#define RCC_I2SAPB1CLKSOURCE_PLLR           ((uint32_t)RCC_DCKCFGR_I2S1SRC_1)
S#define RCC_I2SAPB1CLKSOURCE_PLLSRC         ((uint32_t)RCC_DCKCFGR_I2S1SRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_I2SAPB2_Clock_Source  RCC I2S APB2 Clock Source
S  * @{
S  */
S#define RCC_I2SAPB2CLKSOURCE_PLLI2S         0x00000000U
S#define RCC_I2SAPB2CLKSOURCE_EXT            ((uint32_t)RCC_DCKCFGR_I2S2SRC_0)
S#define RCC_I2SAPB2CLKSOURCE_PLLR           ((uint32_t)RCC_DCKCFGR_I2S2SRC_1)
S#define RCC_I2SAPB2CLKSOURCE_PLLSRC         ((uint32_t)RCC_DCKCFGR_I2S2SRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_FMPI2C1_Clock_Source  RCC FMPI2C1 Clock Source
S  * @{
S  */
S#define RCC_FMPI2C1CLKSOURCE_PCLK1          0x00000000U
S#define RCC_FMPI2C1CLKSOURCE_SYSCLK         ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_0)
S#define RCC_FMPI2C1CLKSOURCE_HSI            ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_1)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_CLK48_Clock_Source  RCC CLK48 Clock Source
S  * @{
S  */
S#define RCC_CLK48CLKSOURCE_PLLQ             0x00000000U
S#define RCC_CLK48CLKSOURCE_PLLI2SQ          ((uint32_t)RCC_DCKCFGR2_CK48MSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_SDIO_Clock_Source  RCC SDIO Clock Source
S  * @{
S  */
S#define RCC_SDIOCLKSOURCE_CLK48             0x00000000U
S#define RCC_SDIOCLKSOURCE_SYSCLK            ((uint32_t)RCC_DCKCFGR2_SDIOSEL)
S/**
S  * @}
S  */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S
S/** @defgroup RCCEx_I2S_APB_Clock_Source  RCC I2S APB Clock Source
S  * @{
S  */
S#define RCC_I2SAPBCLKSOURCE_PLLR            0x00000000U
S#define RCC_I2SAPBCLKSOURCE_EXT             ((uint32_t)RCC_DCKCFGR_I2SSRC_0)
S#define RCC_I2SAPBCLKSOURCE_PLLSRC          ((uint32_t)RCC_DCKCFGR_I2SSRC_1)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_FMPI2C1_Clock_Source  RCC FMPI2C1 Clock Source
S  * @{
S  */
S#define RCC_FMPI2C1CLKSOURCE_PCLK1              0x00000000U
S#define RCC_FMPI2C1CLKSOURCE_SYSCLK             ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_0)
S#define RCC_FMPI2C1CLKSOURCE_HSI                ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_1)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_LPTIM1_Clock_Source  RCC LPTIM1 Clock Source
S  * @{
S  */
S#define RCC_LPTIM1CLKSOURCE_PCLK1          0x00000000U
S#define RCC_LPTIM1CLKSOURCE_HSI            ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0)
S#define RCC_LPTIM1CLKSOURCE_LSI            ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_1)
S#define RCC_LPTIM1CLKSOURCE_LSE            ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0 | RCC_DCKCFGR2_LPTIM1SEL_1)
S/**
S  * @}
S  */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
S/** @defgroup RCCEx_TIM_PRescaler_Selection  RCC TIM PRescaler Selection
S  * @{
S  */
S#define RCC_TIMPRES_DESACTIVATED        ((uint8_t)0x00)
S#define RCC_TIMPRES_ACTIVATED           ((uint8_t)0x01)
S/**
S  * @}
S  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
S/** @defgroup RCCEx_LSE_Dual_Mode_Selection  RCC LSE Dual Mode Selection
S  * @{
S  */
S#define RCC_LSE_LOWPOWER_MODE           ((uint8_t)0x00)
S#define RCC_LSE_HIGHDRIVE_MODE          ((uint8_t)0x01)
S/**
S  * @}
S  */
N#endif /* STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx ||\
N          STM32F412Rx || STM32F412Cx */
X#endif  
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 1L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L
N/** @defgroup RCC_MCO2_Clock_Source MCO2 Clock Source
N  * @{
N  */
N#define RCC_MCO2SOURCE_SYSCLK            0x00000000U
N#define RCC_MCO2SOURCE_PLLI2SCLK         RCC_CFGR_MCO2_0
N#define RCC_MCO2SOURCE_HSE               RCC_CFGR_MCO2_1
N#define RCC_MCO2SOURCE_PLLCLK            RCC_CFGR_MCO2
N/**
N  * @}
N  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx ||
N          STM32F412Rx || STM32F413xx | STM32F423xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** @defgroup RCC_MCO2_Clock_Source MCO2 Clock Source
S  * @{
S  */
S#define RCC_MCO2SOURCE_SYSCLK            0x00000000U
S#define RCC_MCO2SOURCE_I2SCLK            RCC_CFGR_MCO2_0
S#define RCC_MCO2SOURCE_HSE               RCC_CFGR_MCO2_1
S#define RCC_MCO2SOURCE_PLLCLK            RCC_CFGR_MCO2
S/**
S  * @}
S  */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/**
N  * @}
N  */
N     
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Macros RCCEx Exported Macros
N  * @{
N  */
N/*------------------- STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx --------*/
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L || 0L || 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOI_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOI_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOF_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOG_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOJ_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOJ_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOK_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOK_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_DMA2D_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_DMA2D_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_ETHMAC_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_ETHMAC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_ETHMACTX_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_ETHMACTX_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_ETHMACRX_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
S                                         UNUSED(tmpreg); \
S                                         } while(0U)
X#define __HAL_RCC_ETHMACRX_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                         UNUSED(tmpreg);                                          } while(0U)
S#define __HAL_RCC_ETHMACPTP_CLK_ENABLE() do { \
S                                         __IO uint32_t tmpreg = 0x00U; \
S                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
S                                         /* Delay after an RCC peripheral clock enabling */ \
S                                         tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
S                                         UNUSED(tmpreg); \
S                                         } while(0U)
X#define __HAL_RCC_ETHMACPTP_CLK_ENABLE() do {                                          __IO uint32_t tmpreg = 0x00U;                                          SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                                                                    tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                         UNUSED(tmpreg);                                          } while(0U)
S#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#define __HAL_RCC_GPIOE_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#define __HAL_RCC_GPIOF_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))
S#define __HAL_RCC_GPIOG_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))
S#define __HAL_RCC_GPIOI_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOIEN))
S#define __HAL_RCC_GPIOJ_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOJEN))
S#define __HAL_RCC_GPIOK_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOKEN))
S#define __HAL_RCC_DMA2D_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA2DEN))
S#define __HAL_RCC_ETHMAC_CLK_DISABLE()          (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACEN))
S#define __HAL_RCC_ETHMACTX_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACTXEN))
S#define __HAL_RCC_ETHMACRX_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACRXEN))
S#define __HAL_RCC_ETHMACPTP_CLK_DISABLE()       (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACPTPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_DISABLE()      (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSULPIEN))
S#define __HAL_RCC_BKPSRAM_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_BKPSRAMEN))
S#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
S#define __HAL_RCC_CRC_CLK_DISABLE()             (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S
S/**
S  * @brief  Enable ETHERNET clock.
S  */
S#define __HAL_RCC_ETH_CLK_ENABLE() do {                                     \
S                                        __HAL_RCC_ETHMAC_CLK_ENABLE();      \
S                                        __HAL_RCC_ETHMACTX_CLK_ENABLE();    \
S                                        __HAL_RCC_ETHMACRX_CLK_ENABLE();    \
S                                      } while(0U)
X#define __HAL_RCC_ETH_CLK_ENABLE() do {                                                                             __HAL_RCC_ETHMAC_CLK_ENABLE();                                              __HAL_RCC_ETHMACTX_CLK_ENABLE();                                            __HAL_RCC_ETHMACRX_CLK_ENABLE();                                          } while(0U)
S/**
S  * @brief  Disable ETHERNET clock.
S  */
S#define __HAL_RCC_ETH_CLK_DISABLE()  do {                                      \
S                                          __HAL_RCC_ETHMACTX_CLK_DISABLE();    \
S                                          __HAL_RCC_ETHMACRX_CLK_DISABLE();    \
S                                          __HAL_RCC_ETHMAC_CLK_DISABLE();      \
S                                        } while(0U)
X#define __HAL_RCC_ETH_CLK_DISABLE()  do {                                                                                __HAL_RCC_ETHMACTX_CLK_DISABLE();                                              __HAL_RCC_ETHMACRX_CLK_DISABLE();                                              __HAL_RCC_ETHMAC_CLK_DISABLE();                                              } while(0U)
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET) 
S#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET) 
S#define __HAL_RCC_GPIOG_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET)
S#define __HAL_RCC_GPIOI_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) != RESET) 
S#define __HAL_RCC_GPIOJ_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOJEN)) != RESET) 
S#define __HAL_RCC_GPIOK_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOKEN)) != RESET)
S#define __HAL_RCC_DMA2D_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2DEN)) != RESET) 
S#define __HAL_RCC_ETHMAC_IS_CLK_ENABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) != RESET) 
S#define __HAL_RCC_ETHMACTX_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) != RESET)
S#define __HAL_RCC_ETHMACRX_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) != RESET)
S#define __HAL_RCC_ETHMACPTP_IS_CLK_ENABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) != RESET)
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_ENABLED()      ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_ENABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) != RESET)
S#define __HAL_RCC_BKPSRAM_IS_CLK_ENABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) != RESET)
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) != RESET) 
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)
S#define __HAL_RCC_ETH_IS_CLK_ENABLED()             (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   && \
S                                                    __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() && \
S                                                    __HAL_RCC_ETHMACRX_IS_CLK_ENABLED()) 
X#define __HAL_RCC_ETH_IS_CLK_ENABLED()             (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   &&                                                     __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() &&                                                     __HAL_RCC_ETHMACRX_IS_CLK_ENABLED()) 
S
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET) 
S#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET) 
S#define __HAL_RCC_GPIOG_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET)
S#define __HAL_RCC_GPIOI_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) == RESET) 
S#define __HAL_RCC_GPIOJ_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOJEN)) == RESET) 
S#define __HAL_RCC_GPIOK_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOKEN)) == RESET)
S#define __HAL_RCC_DMA2D_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2DEN)) == RESET) 
S#define __HAL_RCC_ETHMAC_IS_CLK_DISABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) == RESET) 
S#define __HAL_RCC_ETHMACTX_IS_CLK_DISABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) == RESET)
S#define __HAL_RCC_ETHMACRX_IS_CLK_DISABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) == RESET)
S#define __HAL_RCC_ETHMACPTP_IS_CLK_DISABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) == RESET)
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_DISABLED()      ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) == RESET)
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) == RESET)
S#define __HAL_RCC_BKPSRAM_IS_CLK_DISABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) == RESET)
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET) 
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)
S#define __HAL_RCC_ETH_IS_CLK_DISABLED()             (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   && \
S                                                     __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() && \
S                                                     __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
X#define __HAL_RCC_ETH_IS_CLK_DISABLED()             (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   &&                                                      __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() &&                                                      __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S #define __HAL_RCC_DCMI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X #define __HAL_RCC_DCMI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DCMI_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_DCMIEN))
S
S#if defined(STM32F437xx)|| defined(STM32F439xx) || defined(STM32F479xx)
S#define __HAL_RCC_CRYP_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CRYP_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_HASH_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_HASH_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_CRYP_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_CRYPEN))
S#define __HAL_RCC_HASH_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_HASHEN))
S#endif /* STM32F437xx || STM32F439xx || STM32F479xx */
S
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S
S#define __HAL_RCC_RNG_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_RNG_CLK_DISABLE()   (RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */ 
S#define __HAL_RCC_DCMI_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) != RESET)
S#define __HAL_RCC_DCMI_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) == RESET)
S
S#if defined(STM32F437xx)|| defined(STM32F439xx) || defined(STM32F479xx)
S#define __HAL_RCC_CRYP_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) != RESET)
S#define __HAL_RCC_CRYP_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) == RESET)
S
S#define __HAL_RCC_HASH_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) != RESET)
S#define __HAL_RCC_HASH_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) == RESET)
S#endif /* STM32F437xx || STM32F439xx || STM32F479xx */
S
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
S
S#define __HAL_RCC_RNG_IS_CLK_ENABLED()         ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET) 
S#define __HAL_RCC_RNG_IS_CLK_DISABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET)     
S/**
S  * @}
S  */   
S
S/** @defgroup RCCEx_AHB3_Clock_Enable_Disable AHB3 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{  
S  */
S#define __HAL_RCC_FMC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FMC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_FMC_CLK_DISABLE()  (RCC->AHB3ENR &= ~(RCC_AHB3ENR_FMCEN))
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_QSPI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_QSPI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_QSPI_CLK_DISABLE()  (RCC->AHB3ENR &= ~(RCC_AHB3ENR_QSPIEN))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S
S/** @defgroup RCCEx_AHB3_Peripheral_Clock_Enable_Disable_Status AHB3 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_FMC_IS_CLK_ENABLED()   ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) != RESET)
S#define __HAL_RCC_FMC_IS_CLK_DISABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) == RESET)
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_QSPI_IS_CLK_ENABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) != RESET)
S#define __HAL_RCC_QSPI_IS_CLK_DISABLED() ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) == RESET)
S#endif /* STM32F469xx || STM32F479xx */  
S/**
S  * @}
S  */
S    
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM12_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM12_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM13_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM13_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USART3_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USART3_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART4_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART4_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART5_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART5_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DAC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART7_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART7_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART8_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART8_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S#define __HAL_RCC_TIM6_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
S#define __HAL_RCC_TIM7_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
S#define __HAL_RCC_TIM12_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))
S#define __HAL_RCC_TIM13_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))
S#define __HAL_RCC_TIM14_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN))
S#define __HAL_RCC_USART3_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
S#define __HAL_RCC_UART4_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))
S#define __HAL_RCC_UART5_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))
S#define __HAL_RCC_CAN1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))
S#define __HAL_RCC_CAN2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))
S#define __HAL_RCC_DAC_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
S#define __HAL_RCC_UART7_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART7EN))
S#define __HAL_RCC_UART8_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART8EN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET)
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
S#define __HAL_RCC_TIM6_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET) 
S#define __HAL_RCC_TIM7_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET) 
S#define __HAL_RCC_TIM12_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET) 
S#define __HAL_RCC_TIM13_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET)  
S#define __HAL_RCC_TIM14_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET) 
S#define __HAL_RCC_USART3_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET) 
S#define __HAL_RCC_UART4_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET) 
S#define __HAL_RCC_UART5_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET) 
S#define __HAL_RCC_CAN1_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) != RESET)
S#define __HAL_RCC_CAN2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET)
S#define __HAL_RCC_DAC_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET) 
S#define __HAL_RCC_UART7_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) != RESET)
S#define __HAL_RCC_UART8_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) != RESET) 
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET)
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)
S#define __HAL_RCC_TIM6_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET) 
S#define __HAL_RCC_TIM7_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET) 
S#define __HAL_RCC_TIM12_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET) 
S#define __HAL_RCC_TIM13_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET)  
S#define __HAL_RCC_TIM14_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET) 
S#define __HAL_RCC_USART3_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET) 
S#define __HAL_RCC_UART4_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET) 
S#define __HAL_RCC_UART5_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET) 
S#define __HAL_RCC_CAN1_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET)
S#define __HAL_RCC_CAN2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET)
S#define __HAL_RCC_DAC_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET) 
S#define __HAL_RCC_UART7_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) == RESET)
S#define __HAL_RCC_UART8_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) == RESET) 
S/**
S  * @}
S  */
S    
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM8_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC3_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC3_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI5_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI5_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SAI1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SAI1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S#define __HAL_RCC_TIM8_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))
S#define __HAL_RCC_ADC2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC2EN))
S#define __HAL_RCC_ADC3_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC3EN))
S#define __HAL_RCC_SPI5_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))
S#define __HAL_RCC_SPI6_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI6EN))
S#define __HAL_RCC_SAI1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI1EN))
S
S#if defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_LTDC_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_LTDC_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_LTDC_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_LTDCEN))
S#endif /* STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_DSI_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DSI_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_DSI_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_DSIEN))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */  
S#define __HAL_RCC_TIM8_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET)
S#define __HAL_RCC_ADC2_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) != RESET)
S#define __HAL_RCC_ADC3_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) != RESET) 
S#define __HAL_RCC_SPI5_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET) 
S#define __HAL_RCC_SPI6_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI6EN)) != RESET) 
S#define __HAL_RCC_SAI1_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) != RESET) 
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET)
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN))!= RESET)  
S
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET)
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN))== RESET)
S#define __HAL_RCC_TIM8_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET)
S#define __HAL_RCC_ADC2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) == RESET)
S#define __HAL_RCC_ADC3_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) == RESET)
S#define __HAL_RCC_SPI5_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)
S#define __HAL_RCC_SPI6_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI6EN)) == RESET)
S#define __HAL_RCC_SAI1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) == RESET)
S
S#if defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_LTDC_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_LTDCEN)) != RESET)
S#define __HAL_RCC_LTDC_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_LTDCEN)) == RESET)
S#endif /* STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_DSI_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_DSIEN)) != RESET)
S#define __HAL_RCC_DSI_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_DSIEN)) == RESET)
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_GPIOI_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOIRST))
S#define __HAL_RCC_ETHMAC_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_ETHMACRST))
S#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_GPIOJ_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOJRST))
S#define __HAL_RCC_GPIOK_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOKRST))
S#define __HAL_RCC_DMA2D_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA2DRST))
S#define __HAL_RCC_CRC_FORCE_RESET()      (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_GPIOI_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOIRST))
S#define __HAL_RCC_ETHMAC_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_ETHMACRST))
S#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_GPIOJ_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOJRST))
S#define __HAL_RCC_GPIOK_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOKRST))
S#define __HAL_RCC_DMA2D_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA2DRST))
S#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU) 
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_RNG_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_DCMI_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_DCMIRST))
S
S#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_RNG_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_DCMI_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_DCMIRST))
S
S#if defined(STM32F437xx)|| defined(STM32F439xx) || defined(STM32F479xx) 
S#define __HAL_RCC_CRYP_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_HASHRST))
S
S#define __HAL_RCC_CRYP_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_HASHRST))
S#endif /* STM32F437xx || STM32F439xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S#define __HAL_RCC_FMC_FORCE_RESET()    (RCC->AHB3RSTR |= (RCC_AHB3RSTR_FMCRST))
S#define __HAL_RCC_FMC_RELEASE_RESET()  (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FMCRST))
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_QSPI_FORCE_RESET()   (RCC->AHB3RSTR |= (RCC_AHB3RSTR_QSPIRST))
S#define __HAL_RCC_QSPI_RELEASE_RESET()   (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_QSPIRST))  
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_CAN1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_DAC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_UART7_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART7RST))
S#define __HAL_RCC_UART8_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART8RST))
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
S
S#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
S#define __HAL_RCC_TIM6_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_USART3_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_CAN1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_DAC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_UART7_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART7RST))
S#define __HAL_RCC_UART8_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART8RST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM8_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))
S#define __HAL_RCC_SPI5_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))
S#define __HAL_RCC_SPI6_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI6RST))
S#define __HAL_RCC_SAI1_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI1RST))
S#define __HAL_RCC_SDIO_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()  (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
S
S#define __HAL_RCC_SDIO_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S#define __HAL_RCC_TIM8_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))
S#define __HAL_RCC_SPI5_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))
S#define __HAL_RCC_SPI6_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI6RST))
S#define __HAL_RCC_SAI1_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI1RST))
S
S#if defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_LTDC_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_LTDCRST))
S#define __HAL_RCC_LTDC_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_LTDCRST))
S#endif /* STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_DSI_FORCE_RESET()   (RCC->APB2RSTR |=  (RCC_APB2RSTR_DSIRST))
S#define __HAL_RCC_DSI_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_DSIRST))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOILPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACLPEN))
S#define __HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACTXLPEN))
S#define __HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACRXLPEN))
S#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACPTPLPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOJLPEN))
S#define __HAL_RCC_GPIOK_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOKLPEN))
S#define __HAL_RCC_SRAM3_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM3LPEN))
S#define __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA2DLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()        (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_BKPSRAMLPEN))
S
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOILPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACLPEN))
S#define __HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACTXLPEN))
S#define __HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACRXLPEN))
S#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACPTPLPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOJLPEN))
S#define __HAL_RCC_GPIOK_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOKLPEN))
S#define __HAL_RCC_DMA2D_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA2DLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()       (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_BKPSRAMLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S
S#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()   (RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))
S#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()  (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))
S
S#define __HAL_RCC_DCMI_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_DCMILPEN))
S#define __HAL_RCC_DCMI_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_DCMILPEN))
S
S#if defined(STM32F437xx)|| defined(STM32F439xx) || defined(STM32F479xx) 
S#define __HAL_RCC_CRYP_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_HASHLPEN))
S
S#define __HAL_RCC_CRYP_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_HASHLPEN))
S#endif /* STM32F437xx || STM32F439xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_LowPower_Enable_Disable AHB3 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_FMC_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_FMCLPEN))
S#define __HAL_RCC_FMC_CLK_SLEEP_DISABLE() (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FMCLPEN))
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_QSPILPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE()  (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_QSPILPEN))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */  
S#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_UART7_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART7LPEN))
S#define __HAL_RCC_UART8_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART8LPEN))
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
S#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_UART7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART7LPEN))
S#define __HAL_RCC_UART8_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART8LPEN))
S/**
S  * @}
S  */
S                                        
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */ 
S#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC3LPEN))
S#define __HAL_RCC_SPI5_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))
S#define __HAL_RCC_SPI6_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI6LPEN))
S#define __HAL_RCC_SAI1_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI1LPEN))
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
S
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
S#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC3LPEN))
S#define __HAL_RCC_SPI5_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))
S#define __HAL_RCC_SPI6_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI6LPEN))
S#define __HAL_RCC_SAI1_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI1LPEN))
S
S#if defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_LTDC_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_LTDCLPEN))
S
S#define __HAL_RCC_LTDC_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_LTDCLPEN))
S#endif /* STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_DSI_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |=  (RCC_APB2LPENR_DSILPEN))
S#define __HAL_RCC_DSI_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_DSILPEN))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*----------------------------------- STM32F40xxx/STM32F41xxx-----------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)
X#if 0L || 0L || 1L|| 0L
N/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
N  * @brief  Enables or disables the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
N                                        UNUSED(tmpreg); \
N                                        } while(0U)
X#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
N#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
N                                        UNUSED(tmpreg); \
N                                        } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
N#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
N                                        UNUSED(tmpreg); \
N                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
N#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_GPIOI_CLK_ENABLE()   do { \
N                                       __IO uint32_t tmpreg = 0x00U; \
N                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
N                                       /* Delay after an RCC peripheral clock enabling */ \
N                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
N                                       UNUSED(tmpreg); \
N                                       } while(0U)
X#define __HAL_RCC_GPIOI_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                       UNUSED(tmpreg);                                        } while(0U)
N#define __HAL_RCC_GPIOF_CLK_ENABLE()   do { \
N                                       __IO uint32_t tmpreg = 0x00U; \
N                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
N                                       /* Delay after an RCC peripheral clock enabling */ \
N                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
N                                       UNUSED(tmpreg); \
N                                       } while(0U)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                       UNUSED(tmpreg);                                        } while(0U)
N#define __HAL_RCC_GPIOG_CLK_ENABLE()   do { \
N                                       __IO uint32_t tmpreg = 0x00U; \
N                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
N                                       /* Delay after an RCC peripheral clock enabling */ \
N                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
N                                       UNUSED(tmpreg); \
N                                       } while(0U)
X#define __HAL_RCC_GPIOG_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                       UNUSED(tmpreg);                                        } while(0U)
N#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do { \
N                                       __IO uint32_t tmpreg = 0x00U; \
N                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
N                                       /* Delay after an RCC peripheral clock enabling */ \
N                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
N                                       UNUSED(tmpreg); \
N                                       } while(0U)
X#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                       UNUSED(tmpreg);                                        } while(0U)
N#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do { \
N                                       __IO uint32_t tmpreg = 0x00U; \
N                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
N                                       /* Delay after an RCC peripheral clock enabling */ \
N                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
N                                       UNUSED(tmpreg); \
N                                       } while(0U)
X#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                       UNUSED(tmpreg);                                        } while(0U)
N#define __HAL_RCC_GPIOD_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
N#define __HAL_RCC_GPIOE_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
N#define __HAL_RCC_GPIOF_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))
N#define __HAL_RCC_GPIOG_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))
N#define __HAL_RCC_GPIOI_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOIEN))
N#define __HAL_RCC_USB_OTG_HS_CLK_DISABLE()      (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSEN))
N#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSULPIEN))
N#define __HAL_RCC_BKPSRAM_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_BKPSRAMEN))
N#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
N#define __HAL_RCC_CRC_CLK_DISABLE()             (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
N#if defined(STM32F407xx)|| defined(STM32F417xx)
X#if 1L|| 0L
N/**
N  * @brief  Enable ETHERNET clock.
N  */
N#define __HAL_RCC_ETHMAC_CLK_ENABLE()  do { \
N                                       __IO uint32_t tmpreg = 0x00U; \
N                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
N                                       /* Delay after an RCC peripheral clock enabling */ \
N                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
N                                       UNUSED(tmpreg); \
N                                       } while(0U)
X#define __HAL_RCC_ETHMAC_CLK_ENABLE()  do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                       UNUSED(tmpreg);                                        } while(0U)
N#define __HAL_RCC_ETHMACTX_CLK_ENABLE() do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
N                                        UNUSED(tmpreg); \
N                                        } while(0U)
X#define __HAL_RCC_ETHMACTX_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                        UNUSED(tmpreg);                                         } while(0U)
N#define __HAL_RCC_ETHMACRX_CLK_ENABLE() do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
N                                        UNUSED(tmpreg); \
N                                        } while(0U)
X#define __HAL_RCC_ETHMACRX_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                        UNUSED(tmpreg);                                         } while(0U)
N#define __HAL_RCC_ETHMACPTP_CLK_ENABLE() do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
N                                        UNUSED(tmpreg); \
N                                        } while(0U)
X#define __HAL_RCC_ETHMACPTP_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                        UNUSED(tmpreg);                                         } while(0U)
N#define __HAL_RCC_ETH_CLK_ENABLE()      do {                            \
N                                        __HAL_RCC_ETHMAC_CLK_ENABLE();      \
N                                        __HAL_RCC_ETHMACTX_CLK_ENABLE();    \
N                                        __HAL_RCC_ETHMACRX_CLK_ENABLE();    \
N                                        } while(0U)
X#define __HAL_RCC_ETH_CLK_ENABLE()      do {                                                                    __HAL_RCC_ETHMAC_CLK_ENABLE();                                              __HAL_RCC_ETHMACTX_CLK_ENABLE();                                            __HAL_RCC_ETHMACRX_CLK_ENABLE();                                            } while(0U)
N
N/**
N  * @brief  Disable ETHERNET clock.
N  */
N#define __HAL_RCC_ETHMAC_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACEN))
N#define __HAL_RCC_ETHMACTX_CLK_DISABLE()  (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACTXEN))
N#define __HAL_RCC_ETHMACRX_CLK_DISABLE()  (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACRXEN))
N#define __HAL_RCC_ETHMACPTP_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACPTPEN))  
N#define __HAL_RCC_ETH_CLK_DISABLE()       do {                             \
N                                           __HAL_RCC_ETHMACTX_CLK_DISABLE();    \
N                                           __HAL_RCC_ETHMACRX_CLK_DISABLE();    \
N                                           __HAL_RCC_ETHMAC_CLK_DISABLE();      \
N                                          } while(0U)
X#define __HAL_RCC_ETH_CLK_DISABLE()       do {                                                                        __HAL_RCC_ETHMACTX_CLK_DISABLE();                                               __HAL_RCC_ETHMACRX_CLK_DISABLE();                                               __HAL_RCC_ETHMAC_CLK_DISABLE();                                                } while(0U)
N#endif /* STM32F407xx || STM32F417xx */
N/**
N  * @}
N  */
N  
N/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */  
N#define __HAL_RCC_BKPSRAM_IS_CLK_ENABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) != RESET)
N#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) != RESET)
N#define __HAL_RCC_CRC_IS_CLK_ENABLED()              ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)
N#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET)
N#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET)
N#define __HAL_RCC_GPIOI_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) != RESET)
N#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET)
N#define __HAL_RCC_GPIOG_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET)
N#define __HAL_RCC_USB_OTG_HS_IS_CLK_ENABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) != RESET)
N#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_ENABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) != RESET)
N
N#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET)
N#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET)
N#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET)
N#define __HAL_RCC_GPIOG_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET)
N#define __HAL_RCC_GPIOI_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) == RESET)
N#define __HAL_RCC_USB_OTG_HS_IS_CLK_DISABLED()      ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) == RESET)
N#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN))== RESET)
N#define __HAL_RCC_BKPSRAM_IS_CLK_DISABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) == RESET)
N#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET)
N#define __HAL_RCC_CRC_IS_CLK_DISABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)
N#if defined(STM32F407xx)|| defined(STM32F417xx)
X#if 1L|| 0L
N/**
N  * @brief  Enable ETHERNET clock.
N  */
N#define __HAL_RCC_ETHMAC_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) != RESET)
N#define __HAL_RCC_ETHMACTX_IS_CLK_ENABLED()   ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) != RESET)
N#define __HAL_RCC_ETHMACRX_IS_CLK_ENABLED()   ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) != RESET)
N#define __HAL_RCC_ETHMACPTP_IS_CLK_ENABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) != RESET)
N#define __HAL_RCC_ETH_IS_CLK_ENABLED()        (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   && \
N                                               __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() && \
N                                               __HAL_RCC_ETHMACRX_IS_CLK_ENABLED())
X#define __HAL_RCC_ETH_IS_CLK_ENABLED()        (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   &&                                                __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() &&                                                __HAL_RCC_ETHMACRX_IS_CLK_ENABLED())
N/**
N  * @brief  Disable ETHERNET clock.
N  */
N#define __HAL_RCC_ETHMAC_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) == RESET)
N#define __HAL_RCC_ETHMACTX_IS_CLK_DISABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) == RESET)
N#define __HAL_RCC_ETHMACRX_IS_CLK_DISABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) == RESET)
N#define __HAL_RCC_ETHMACPTP_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) == RESET)
N#define __HAL_RCC_ETH_IS_CLK_DISABLED()        (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   && \
N                                                __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() && \
N                                                __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
X#define __HAL_RCC_ETH_IS_CLK_DISABLED()        (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   &&                                                 __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() &&                                                 __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
N#endif /* STM32F407xx || STM32F417xx */
N/**
N  * @}
N  */
N  
N/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable 
N  * @brief  Enable or disable the AHB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
N                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
N                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
N                                        
N#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
N
N#define __HAL_RCC_RNG_CLK_ENABLE()    do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_RNG_CLK_DISABLE()   (RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))
N
N#if defined(STM32F407xx)|| defined(STM32F417xx) 
X#if 1L|| 0L 
N#define __HAL_RCC_DCMI_CLK_ENABLE()   do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_DCMI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_DCMI_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_DCMIEN))
N#endif /* STM32F407xx || STM32F417xx */
N
N#if defined(STM32F415xx) || defined(STM32F417xx)
X#if 0L || 0L
S#define __HAL_RCC_CRYP_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CRYP_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_HASH_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_HASH_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CRYP_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_CRYPEN))
S#define __HAL_RCC_HASH_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_HASHEN))
N#endif /* STM32F415xx || STM32F417xx */
N/**
N  * @}
N  */
N
N
N/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
N#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET) 
N
N#define __HAL_RCC_RNG_IS_CLK_ENABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET)   
N#define __HAL_RCC_RNG_IS_CLK_DISABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET) 
N
N#if defined(STM32F407xx)|| defined(STM32F417xx) 
X#if 1L|| 0L 
N#define __HAL_RCC_DCMI_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) != RESET) 
N#define __HAL_RCC_DCMI_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) == RESET) 
N#endif /* STM32F407xx || STM32F417xx */
N
N#if defined(STM32F415xx) || defined(STM32F417xx)
X#if 0L || 0L
S#define __HAL_RCC_CRYP_IS_CLK_ENABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) != RESET) 
S#define __HAL_RCC_HASH_IS_CLK_ENABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) != RESET) 
S
S#define __HAL_RCC_CRYP_IS_CLK_DISABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) == RESET) 
S#define __HAL_RCC_HASH_IS_CLK_DISABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) == RESET) 
N#endif /* STM32F415xx || STM32F417xx */  
N/**
N  * @}
N  */  
N  
N/** @defgroup RCCEx_AHB3_Clock_Enable_Disable AHB3 Peripheral Clock Enable Disable
N  * @brief  Enables or disables the AHB3 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @{  
N  */
N#define __HAL_RCC_FSMC_CLK_ENABLE()   do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_FSMC_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_FSMC_CLK_DISABLE() (RCC->AHB3ENR &= ~(RCC_AHB3ENR_FSMCEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB3_Peripheral_Clock_Enable_Disable_Status AHB3 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB3 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_FSMC_IS_CLK_ENABLED()   ((RCC->AHB3ENR & (RCC_AHB3ENR_FSMCEN)) != RESET) 
N#define __HAL_RCC_FSMC_IS_CLK_DISABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_FSMCEN)) == RESET) 
N/**
N  * @}
N  */   
N   
N/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @{  
N  */
N#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM12_CLK_ENABLE()  do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM12_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM13_CLK_ENABLE()  do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM13_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_USART3_CLK_ENABLE() do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_USART3_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_UART4_CLK_ENABLE()  do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_UART4_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_UART5_CLK_ENABLE()  do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_UART5_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_CAN2_CLK_ENABLE()   do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_CAN2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_DAC_CLK_ENABLE()    do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
N#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
N#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
N#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
N#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
N#define __HAL_RCC_TIM6_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
N#define __HAL_RCC_TIM7_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
N#define __HAL_RCC_TIM12_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))
N#define __HAL_RCC_TIM13_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))
N#define __HAL_RCC_TIM14_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN))
N#define __HAL_RCC_USART3_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
N#define __HAL_RCC_UART4_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))
N#define __HAL_RCC_UART5_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))
N#define __HAL_RCC_CAN1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))
N#define __HAL_RCC_CAN2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))
N#define __HAL_RCC_DAC_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
N/**
N  * @}
N  */
N 
N/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */ 
N#define __HAL_RCC_TIM2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET)  
N#define __HAL_RCC_TIM3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET) 
N#define __HAL_RCC_TIM4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET)
N#define __HAL_RCC_SPI3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET) 
N#define __HAL_RCC_I2C3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET) 
N#define __HAL_RCC_TIM6_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET) 
N#define __HAL_RCC_TIM7_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET) 
N#define __HAL_RCC_TIM12_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET) 
N#define __HAL_RCC_TIM13_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET) 
N#define __HAL_RCC_TIM14_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET) 
N#define __HAL_RCC_USART3_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET) 
N#define __HAL_RCC_UART4_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET) 
N#define __HAL_RCC_UART5_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET) 
N#define __HAL_RCC_CAN1_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) != RESET) 
N#define __HAL_RCC_CAN2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET) 
N#define __HAL_RCC_DAC_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET) 
N
N#define __HAL_RCC_TIM2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET)  
N#define __HAL_RCC_TIM3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET) 
N#define __HAL_RCC_TIM4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET)
N#define __HAL_RCC_SPI3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET) 
N#define __HAL_RCC_I2C3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET) 
N#define __HAL_RCC_TIM6_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET) 
N#define __HAL_RCC_TIM7_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET) 
N#define __HAL_RCC_TIM12_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET) 
N#define __HAL_RCC_TIM13_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET) 
N#define __HAL_RCC_TIM14_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET) 
N#define __HAL_RCC_USART3_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET) 
N#define __HAL_RCC_UART4_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET) 
N#define __HAL_RCC_UART5_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET) 
N#define __HAL_RCC_CAN1_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET) 
N#define __HAL_RCC_CAN2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET) 
N#define __HAL_RCC_DAC_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET) 
N  /**
N  * @}
N  */
N  
N/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @{
N  */ 
N#define __HAL_RCC_TIM8_CLK_ENABLE()   do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM8_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_ADC2_CLK_ENABLE()   do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_ADC2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_ADC3_CLK_ENABLE()   do { \
N                                      __IO uint32_t tmpreg = 0x00U; \
N                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
N                                      /* Delay after an RCC peripheral clock enabling */ \
N                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
N                                      UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_ADC3_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                      UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
N#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
N#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
N#define __HAL_RCC_TIM8_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))
N#define __HAL_RCC_ADC2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC2EN))
N#define __HAL_RCC_ADC3_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC3EN))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_SDIO_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET)  
N#define __HAL_RCC_SPI4_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)  
N#define __HAL_RCC_TIM10_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET) 
N#define __HAL_RCC_TIM8_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET) 
N#define __HAL_RCC_ADC2_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) != RESET) 
N#define __HAL_RCC_ADC3_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) != RESET)
N  
N#define __HAL_RCC_SDIO_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET)  
N#define __HAL_RCC_SPI4_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)  
N#define __HAL_RCC_TIM10_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET) 
N#define __HAL_RCC_TIM8_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET) 
N#define __HAL_RCC_ADC2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) == RESET) 
N#define __HAL_RCC_ADC3_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) == RESET)
N/**
N  * @}
N  */
N    
N/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
N  * @brief  Force or release AHB1 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_GPIOD_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
N#define __HAL_RCC_GPIOE_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
N#define __HAL_RCC_GPIOF_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))
N#define __HAL_RCC_GPIOG_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))
N#define __HAL_RCC_GPIOI_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOIRST))
N#define __HAL_RCC_ETHMAC_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_ETHMACRST))
N#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_OTGHRST))
N#define __HAL_RCC_CRC_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
N
N#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
N#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
N#define __HAL_RCC_GPIOF_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))
N#define __HAL_RCC_GPIOG_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))
N#define __HAL_RCC_GPIOI_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOIRST))
N#define __HAL_RCC_ETHMAC_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_ETHMACRST))
N#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_OTGHRST))
N#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
N  * @brief  Force or release AHB2 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_AHB2_FORCE_RESET()         (RCC->AHB2RSTR = 0xFFFFFFFFU) 
N#define __HAL_RCC_AHB2_RELEASE_RESET()       (RCC->AHB2RSTR = 0x00U)
N
N#if defined(STM32F407xx)|| defined(STM32F417xx)  
X#if 1L|| 0L  
N#define __HAL_RCC_DCMI_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_DCMIRST))
N#define __HAL_RCC_DCMI_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_DCMIRST))
N#endif /* STM32F407xx || STM32F417xx */
N
N#if defined(STM32F415xx) || defined(STM32F417xx) 
X#if 0L || 0L 
S#define __HAL_RCC_CRYP_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_HASHRST))
S
S#define __HAL_RCC_CRYP_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_HASHRST))
N#endif /* STM32F415xx || STM32F417xx */
N   
N#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
N#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
N
N#define __HAL_RCC_RNG_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))
N#define __HAL_RCC_RNG_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
N  * @brief  Force or release AHB3 peripheral reset.
N  * @{
N  */ 
N#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
N
N#define __HAL_RCC_FSMC_FORCE_RESET()   (RCC->AHB3RSTR |= (RCC_AHB3RSTR_FSMCRST))
N#define __HAL_RCC_FSMC_RELEASE_RESET() (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FSMCRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
N  * @brief  Force or release APB1 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
N#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
N#define __HAL_RCC_TIM12_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))
N#define __HAL_RCC_TIM13_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))
N#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST))
N#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
N#define __HAL_RCC_UART4_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))
N#define __HAL_RCC_UART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))
N#define __HAL_RCC_CAN1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))
N#define __HAL_RCC_CAN2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))
N#define __HAL_RCC_DAC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
N#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
N#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
N#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
N#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
N#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
N
N#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
N#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
N#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
N#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
N#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
N#define __HAL_RCC_TIM6_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
N#define __HAL_RCC_TIM7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
N#define __HAL_RCC_TIM12_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))
N#define __HAL_RCC_TIM13_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))
N#define __HAL_RCC_TIM14_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST))
N#define __HAL_RCC_USART3_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
N#define __HAL_RCC_UART4_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))
N#define __HAL_RCC_UART5_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))
N#define __HAL_RCC_CAN1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))
N#define __HAL_RCC_CAN2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))
N#define __HAL_RCC_DAC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
N  * @brief  Force or release APB2 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_TIM8_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))
N#define __HAL_RCC_SDIO_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
N#define __HAL_RCC_SPI4_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
N#define __HAL_RCC_TIM10_FORCE_RESET()  (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
N                                          
N#define __HAL_RCC_SDIO_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
N#define __HAL_RCC_SPI4_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
N#define __HAL_RCC_TIM10_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
N#define __HAL_RCC_TIM8_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))
N/**
N  * @}
N  */
N                                        
N/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
N#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
N#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))
N#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))
N#define __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOILPEN))
N#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))
N#define __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACLPEN))
N#define __HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACTXLPEN))
N#define __HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACRXLPEN))
N#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACPTPLPEN))
N#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSLPEN))
N#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSULPILPEN))
N#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
N#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
N#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
N#define __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_BKPSRAMLPEN))
N
N#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
N#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
N#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))
N#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))
N#define __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOILPEN))
N#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))
N#define __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACLPEN))
N#define __HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACTXLPEN))
N#define __HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACRXLPEN))
N#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACPTPLPEN))
N#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSLPEN))
N#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSULPILPEN))
N#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()       (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
N#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
N#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
N#define __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_BKPSRAMLPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
N#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
N
N#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()   (RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))
N#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()  (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))
N
N#if defined(STM32F407xx)|| defined(STM32F417xx) 
X#if 1L|| 0L 
N#define __HAL_RCC_DCMI_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_DCMILPEN))
N#define __HAL_RCC_DCMI_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_DCMILPEN))
N#endif /* STM32F407xx || STM32F417xx */
N
N#if defined(STM32F415xx) || defined(STM32F417xx) 
X#if 0L || 0L 
S#define __HAL_RCC_CRYP_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_HASHLPEN))
S
S#define __HAL_RCC_CRYP_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_HASHLPEN))
N#endif /* STM32F415xx || STM32F417xx */
N/**
N  * @}
N  */
N                                        
N/** @defgroup RCCEx_AHB3_LowPower_Enable_Disable AHB3 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_FSMC_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_FSMCLPEN))
N#define __HAL_RCC_FSMC_CLK_SLEEP_DISABLE() (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FSMCLPEN))
N/**
N  * @}
N  */
N                                        
N/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
N#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))
N#define __HAL_RCC_TIM12_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))
N#define __HAL_RCC_TIM13_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))
N#define __HAL_RCC_TIM14_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))
N#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))
N#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))
N#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))
N#define __HAL_RCC_CAN1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))
N#define __HAL_RCC_CAN2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))
N#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
N#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
N#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
N#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
N#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
N#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
N
N#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
N#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
N#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
N#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
N#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
N#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
N#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))
N#define __HAL_RCC_TIM12_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))
N#define __HAL_RCC_TIM13_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))
N#define __HAL_RCC_TIM14_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))
N#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))
N#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))
N#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))
N#define __HAL_RCC_CAN1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))
N#define __HAL_RCC_CAN2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))
N#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
N/**
N  * @}
N  */
N                                        
N/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))
N#define __HAL_RCC_ADC2_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC2LPEN))
N#define __HAL_RCC_ADC3_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC3LPEN))
N#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
N#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
N#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
N
N#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
N#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
N#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
N#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))
N#define __HAL_RCC_ADC2_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC2LPEN))
N#define __HAL_RCC_ADC3_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC3LPEN))
N/**
N  * @}
N  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------------- STM32F401xE/STM32F401xC --------------------------*/
N#if defined(STM32F401xC) || defined(STM32F401xE)
X#if 0L || 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.   
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CRC_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE()  do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE()  do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_GPIOD_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#define __HAL_RCC_GPIOE_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#define __HAL_RCC_CRC_CLK_DISABLE()          (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET)  
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)  
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) != RESET)  
S
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET)  
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)  
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET)  
S/**
S  * @}
S  */ 
S  
S/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
S/**
S  * @}
S  */  
S  
S/** @defgroup RCC_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)
S/**
S  * @}
S  */ 
S  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET)  
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)   
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)  
S
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET)
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET) 
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET) 
S/**
S  * @}
S  */
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */  
S#define __HAL_RCC_AHB1_FORCE_RESET()    (RCC->AHB1RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_GPIOD_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_CRC_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#define __HAL_RCC_AHB1_RELEASE_RESET()  (RCC->AHB1RSTR = 0x00U)
S#define __HAL_RCC_GPIOD_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_CRC_RELEASE_RESET()   (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU) 
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S
S#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_APB1_FORCE_RESET()     (RCC->APB1RSTR = 0xFFFFFFFFU)  
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
S
S#define __HAL_RCC_APB1_RELEASE_RESET()   (RCC->APB1RSTR = 0x00U) 
S#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_APB2_FORCE_RESET()     (RCC->APB2RSTR = 0xFFFFFFFFU)  
S#define __HAL_RCC_SDIO_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
S
S#define __HAL_RCC_APB2_RELEASE_RESET()   (RCC->APB2RSTR = 0x00U)
S#define __HAL_RCC_SDIO_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable 
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()   (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
S
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
S/**
S  * @}
S  */
N#endif /* STM32F401xC || STM32F401xE*/
N/*----------------------------------------------------------------------------*/
N
N/*-------------------------------- STM32F410xx -------------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable     
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_RNG_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_RNGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_RNGEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_RNGEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CRC_CLK_DISABLE()     (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S#define __HAL_RCC_RNG_CLK_DISABLE()     (RCC->AHB1ENR &= ~(RCC_AHB1ENR_RNGEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)
S#define __HAL_RCC_RNG_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_RNGEN)) != RESET)
S      
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)
S#define __HAL_RCC_RNG_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_RNGEN)) == RESET)
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable  
S  * @brief  Enable or disable the High Speed APB (APB1) peripheral clock.
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_RTCAPB_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RTCAPB_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U) 
X#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                      UNUSED(tmpreg);                                       } while(0U) 
S#define __HAL_RCC_DAC_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
S                                        
S#define __HAL_RCC_TIM6_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
S#define __HAL_RCC_RTCAPB_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_RTCAPBEN))
S#define __HAL_RCC_LPTIM1_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_LPTIM1EN))
S#define __HAL_RCC_FMPI2C1_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_FMPI2C1EN))
S#define __HAL_RCC_DAC_CLK_DISABLE()     (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */  
S#define __HAL_RCC_TIM6_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET) 
S#define __HAL_RCC_RTCAPB_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_RTCAPBEN)) != RESET)
S#define __HAL_RCC_LPTIM1_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) != RESET) 
S#define __HAL_RCC_FMPI2C1_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) != RESET)  
S#define __HAL_RCC_DAC_IS_CLK_ENABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET) 
S
S#define __HAL_RCC_TIM6_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET) 
S#define __HAL_RCC_RTCAPB_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_RTCAPBEN)) == RESET)
S#define __HAL_RCC_LPTIM1_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) == RESET) 
S#define __HAL_RCC_FMPI2C1_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) == RESET)  
S#define __HAL_RCC_DAC_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET)  
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable  
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @{
S  */  
S#define __HAL_RCC_SPI5_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI5_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_EXTIT_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_EXTIT_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI5_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))
S#define __HAL_RCC_EXTIT_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_EXTITEN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_SPI5_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET)  
S#define __HAL_RCC_EXTIT_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_EXTITEN)) != RESET)  
S  
S#define __HAL_RCC_SPI5_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)  
S#define __HAL_RCC_EXTIT_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_EXTITEN)) == RESET)  
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_CRC_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S#define __HAL_RCC_RNG_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_RNGRST))
S#define __HAL_RCC_CRC_RELEASE_RESET()   (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S#define __HAL_RCC_RNG_RELEASE_RESET()   (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_RNGRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()
S#define __HAL_RCC_AHB2_RELEASE_RESET()
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET()
S#define __HAL_RCC_AHB3_RELEASE_RESET()
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM6_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_LPTIM1_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_LPTIM1RST))
S#define __HAL_RCC_FMPI2C1_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_DAC_FORCE_RESET()       (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
S
S#define __HAL_RCC_TIM6_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_LPTIM1_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_LPTIM1RST))
S#define __HAL_RCC_FMPI2C1_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_DAC_RELEASE_RESET()     (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_SPI5_FORCE_RESET()      (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))
S#define __HAL_RCC_SPI5_RELEASE_RESET()    (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))                                        
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable  
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_RNGLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S
S#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_RNGLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable                                         
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_LPTIM1LPEN))
S#define __HAL_RCC_RTCAPB_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_RTCAPBLPEN))
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_ENABLE() (RCC->APB1LPENR |= (RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
S
S#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_LPTIM1LPEN))
S#define __HAL_RCC_RTCAPB_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_RTCAPBLPEN))
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()     (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable                                         
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @{
S  */
S#define __HAL_RCC_SPI5_CLK_SLEEP_ENABLE()     (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))
S#define __HAL_RCC_EXTIT_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_EXTITLPEN))                                
S#define __HAL_RCC_SPI5_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))                                        
S#define __HAL_RCC_EXTIT_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_EXTITLPEN))
S/**
S  * @}
S  */
S
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*----------------------------------------------------------------------------*/
N
N/*-------------------------------- STM32F411xx -------------------------------*/
N#if defined(STM32F411xE)
X#if 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#define __HAL_RCC_GPIOE_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
S#define __HAL_RCC_CRC_CLK_DISABLE()             (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */  
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET) 
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) != RESET) 
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET) 
S
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET) 
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET) 
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET) 
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEX_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
S/**
S  * @}
S  */  
S
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S/**
S  * @}
S  */ 
S  
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET) 
S/**
S  * @}
S  */ 
S  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @{
S  */
S#define __HAL_RCC_SPI5_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI5_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S#define __HAL_RCC_SPI5_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET)  
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)   
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)  
S#define __HAL_RCC_SPI5_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET) 
S
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET)  
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)   
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET)  
S#define __HAL_RCC_SPI5_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)   
S/**
S  * @}
S  */  
S  
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_GPIOD_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_CRC_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU) 
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S
S#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
S
S#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_SPI5_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))
S#define __HAL_RCC_SDIO_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
S
S#define __HAL_RCC_SDIO_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S#define __HAL_RCC_SPI5_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable 
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S                                        
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))                                        
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()   (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable 
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @{
S  */
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable 
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @{
S  */
S#define __HAL_RCC_SPI5_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
S
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
S#define __HAL_RCC_SPI5_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))
S/**
S  * @}
S  */
N#endif /* STM32F411xE */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F446xx -----------------------------*/
N#if defined(STM32F446xx)
X#if 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOF_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOG_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOG_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOD_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#define __HAL_RCC_GPIOE_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#define __HAL_RCC_GPIOF_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))
S#define __HAL_RCC_GPIOG_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_DISABLE()      (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSULPIEN))
S#define __HAL_RCC_BKPSRAM_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_BKPSRAMEN))
S#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
S#define __HAL_RCC_CRC_CLK_DISABLE()             (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET) 
S#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET) 
S#define __HAL_RCC_GPIOG_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET) 
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_ENABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) != RESET)  
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_ENABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) != RESET) 
S#define __HAL_RCC_BKPSRAM_IS_CLK_ENABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) != RESET)  
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN))!= RESET)  
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()              ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET) 
S
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET) 
S#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET) 
S#define __HAL_RCC_GPIOG_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET) 
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_DISABLED()      ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) == RESET)  
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) == RESET) 
S#define __HAL_RCC_BKPSRAM_IS_CLK_DISABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) == RESET)  
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET)  
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET) 
S/**
S  * @}
S  */  
S  
S/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_DCMI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DCMI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DCMI_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_DCMIEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S
S#define __HAL_RCC_RNG_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_RNG_CLK_DISABLE()   (RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_DCMI_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) != RESET)
S#define __HAL_RCC_DCMI_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) == RESET)
S
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
S
S#define __HAL_RCC_RNG_IS_CLK_ENABLED()    ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET) 
S#define __HAL_RCC_RNG_IS_CLK_DISABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET) 
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB3_Clock_Enable_Disable AHB3 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#define __HAL_RCC_FMC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FMC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_QSPI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_QSPI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_FMC_CLK_DISABLE()    (RCC->AHB3ENR &= ~(RCC_AHB3ENR_FMCEN))
S#define __HAL_RCC_QSPI_CLK_DISABLE()   (RCC->AHB3ENR &= ~(RCC_AHB3ENR_QSPIEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Peripheral_Clock_Enable_Disable_Status AHB3 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_FMC_IS_CLK_ENABLED()   ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) != RESET)
S#define __HAL_RCC_QSPI_IS_CLK_ENABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) != RESET)
S
S#define __HAL_RCC_FMC_IS_CLK_DISABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) == RESET)
S#define __HAL_RCC_QSPI_IS_CLK_DISABLED() ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) == RESET)
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM12_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM12_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM13_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM13_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPDIFRX_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPDIFRX_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USART3_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USART3_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART4_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART4_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART5_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART5_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CEC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CEC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DAC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S#define __HAL_RCC_TIM6_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
S#define __HAL_RCC_TIM7_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
S#define __HAL_RCC_TIM12_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))
S#define __HAL_RCC_TIM13_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))
S#define __HAL_RCC_TIM14_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN))
S#define __HAL_RCC_SPDIFRX_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPDIFRXEN))
S#define __HAL_RCC_USART3_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
S#define __HAL_RCC_UART4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))
S#define __HAL_RCC_UART5_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))
S#define __HAL_RCC_FMPI2C1_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_FMPI2C1EN))
S#define __HAL_RCC_CAN1_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))
S#define __HAL_RCC_CAN2_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))
S#define __HAL_RCC_CEC_CLK_DISABLE()     (RCC->APB1ENR &= ~(RCC_APB1ENR_CECEN))
S#define __HAL_RCC_DAC_CLK_DISABLE()     (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET)
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET)
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
S#define __HAL_RCC_TIM6_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET)
S#define __HAL_RCC_TIM7_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET)
S#define __HAL_RCC_TIM12_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET)
S#define __HAL_RCC_TIM13_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET)
S#define __HAL_RCC_TIM14_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET)
S#define __HAL_RCC_SPDIFRX_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_SPDIFRXEN)) != RESET)
S#define __HAL_RCC_USART3_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET)
S#define __HAL_RCC_UART4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET)
S#define __HAL_RCC_UART5_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET)
S#define __HAL_RCC_FMPI2C1_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) != RESET)
S#define __HAL_RCC_CAN1_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) != RESET)
S#define __HAL_RCC_CAN2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET)
S#define __HAL_RCC_CEC_IS_CLK_ENABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) != RESET)
S#define __HAL_RCC_DAC_IS_CLK_ENABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET)
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET)
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET)
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)
S#define __HAL_RCC_TIM6_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET)
S#define __HAL_RCC_TIM7_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET)
S#define __HAL_RCC_TIM12_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET)
S#define __HAL_RCC_TIM13_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET)
S#define __HAL_RCC_TIM14_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET)
S#define __HAL_RCC_SPDIFRX_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_SPDIFRXEN)) == RESET)
S#define __HAL_RCC_USART3_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET)
S#define __HAL_RCC_UART4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET)
S#define __HAL_RCC_UART5_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET)
S#define __HAL_RCC_FMPI2C1_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) == RESET)
S#define __HAL_RCC_CAN1_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET)
S#define __HAL_RCC_CAN2_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET)
S#define __HAL_RCC_CEC_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) == RESET)
S#define __HAL_RCC_DAC_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET)
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM8_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC3_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC3_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SAI1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SAI1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SAI2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SAI2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S#define __HAL_RCC_TIM8_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))
S#define __HAL_RCC_ADC2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC2EN))
S#define __HAL_RCC_ADC3_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC3EN))
S#define __HAL_RCC_SAI1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI1EN))
S#define __HAL_RCC_SAI2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI2EN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET) 
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET) 
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)  
S#define __HAL_RCC_TIM8_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET)
S#define __HAL_RCC_ADC2_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) != RESET) 
S#define __HAL_RCC_ADC3_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) != RESET) 
S#define __HAL_RCC_SAI1_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) != RESET)
S#define __HAL_RCC_SAI2_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI2EN)) != RESET)
S
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET) 
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET) 
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET)  
S#define __HAL_RCC_TIM8_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET)
S#define __HAL_RCC_ADC2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) == RESET) 
S#define __HAL_RCC_ADC3_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) == RESET) 
S#define __HAL_RCC_SAI1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) == RESET)
S#define __HAL_RCC_SAI2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI2EN)) == RESET) 
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_CRC_FORCE_RESET()      (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU) 
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_RNG_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_DCMI_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_DCMIRST))
S
S#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_RNG_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_DCMI_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_DCMIRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S
S#define __HAL_RCC_FMC_FORCE_RESET()    (RCC->AHB3RSTR |= (RCC_AHB3RSTR_FMCRST))
S#define __HAL_RCC_QSPI_FORCE_RESET()   (RCC->AHB3RSTR |= (RCC_AHB3RSTR_QSPIRST))
S
S#define __HAL_RCC_FMC_RELEASE_RESET()    (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FMCRST))
S#define __HAL_RCC_QSPI_RELEASE_RESET()   (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_QSPIRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_SPDIFRX_FORCE_RESET()  (RCC->APB1RSTR |= (RCC_APB1RSTR_SPDIFRXRST))
S#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_FMPI2C1_FORCE_RESET()  (RCC->APB1RSTR |= (RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_CAN1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_CEC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_CECRST))
S#define __HAL_RCC_DAC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
S                                          
S#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
S#define __HAL_RCC_TIM6_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_SPDIFRX_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPDIFRXRST))
S#define __HAL_RCC_USART3_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_FMPI2C1_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_CAN1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_CEC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CECRST))
S#define __HAL_RCC_DAC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM8_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))
S#define __HAL_RCC_SAI1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI1RST)) 
S#define __HAL_RCC_SAI2_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI2RST))
S#define __HAL_RCC_SDIO_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
S
S#define __HAL_RCC_SDIO_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S#define __HAL_RCC_TIM8_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))
S#define __HAL_RCC_SAI1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI1RST))
S#define __HAL_RCC_SAI2_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI2RST)) 
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable 
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()        (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_BKPSRAMLPEN))
S
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()       (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_BKPSRAMLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S
S#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()   (RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))
S#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()  (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))
S
S#define __HAL_RCC_DCMI_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_DCMILPEN))
S#define __HAL_RCC_DCMI_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_DCMILPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_LowPower_Enable_Disable AHB3 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_FMC_CLK_SLEEP_ENABLE()   (RCC->AHB3LPENR |= (RCC_AHB3LPENR_FMCLPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_QSPILPEN))
S
S#define __HAL_RCC_FMC_CLK_SLEEP_DISABLE()   (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FMCLPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE()  (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_QSPILPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */ 
S#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_SPDIFRX_CLK_SLEEP_ENABLE() (RCC->APB1LPENR |= (RCC_APB1LPENR_SPDIFRXLPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_ENABLE() (RCC->APB1LPENR |= (RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_CEC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_CECLPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
S#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_SPDIFRX_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPDIFRXLPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_CEC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CECLPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC3LPEN))
S#define __HAL_RCC_SAI1_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI1LPEN))
S#define __HAL_RCC_SAI2_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI2LPEN))
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
S
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
S#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC3LPEN))
S#define __HAL_RCC_SAI1_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI1LPEN))
S#define __HAL_RCC_SAI2_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI2LPEN))
S/**
S  * @}
S  */
S
N#endif /* STM32F446xx */
N/*----------------------------------------------------------------------------*/
N
N/*-------STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx-------*/
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) 
X#if 0L || 0L || 0L || 0L || 0L || 0L 
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define __HAL_RCC_GPIOE_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)                                        
S#define __HAL_RCC_GPIOF_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOG_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOG_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */                                       
S#define __HAL_RCC_CRC_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                        
X#define __HAL_RCC_CRC_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                      UNUSED(tmpreg);                                       } while(0U)                                        
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define __HAL_RCC_GPIOD_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define __HAL_RCC_GPIOE_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))
S#define __HAL_RCC_GPIOG_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_CLK_DISABLE()          (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET)
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET)
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET)
S#define __HAL_RCC_GPIOG_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET)
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)
S
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET)
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET)
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET)
S#define __HAL_RCC_GPIOG_IS_CLK_DISABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET)
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#if defined(STM32F423xx)
S#define __HAL_RCC_AES_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_AESEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_AESEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_AES_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_AESEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_AESEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_AES_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_AESEN))
S#endif /* STM32F423xx */
S                                        
S#define __HAL_RCC_RNG_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_RNG_CLK_DISABLE()   (RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))
S                                     
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#if defined(STM32F423xx)
S#define __HAL_RCC_AES_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_AESEN)) != RESET)
S#define __HAL_RCC_AES_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_AESEN)) == RESET)
S#endif /* STM32F423xx */
S                                        
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
S          
S#define __HAL_RCC_RNG_IS_CLK_ENABLED()         ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET)   
S#define __HAL_RCC_RNG_IS_CLK_DISABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET)   
S/**
S  * @}
S  */  
S
S/** @defgroup RCCEx_AHB3_Clock_Enable_Disable AHB3 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_FSMC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FSMC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_QSPI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_QSPI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_FSMC_CLK_DISABLE()    (RCC->AHB3ENR &= ~(RCC_AHB3ENR_FSMCEN))
S#define __HAL_RCC_QSPI_CLK_DISABLE()    (RCC->AHB3ENR &= ~(RCC_AHB3ENR_QSPIEN))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */ 
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Peripheral_Clock_Enable_Disable_Status AHB3 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_FSMC_IS_CLK_ENABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_FSMCEN)) != RESET) 
S#define __HAL_RCC_QSPI_IS_CLK_ENABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) != RESET) 
S
S#define __HAL_RCC_FSMC_IS_CLK_DISABLED() ((RCC->AHB3ENR & (RCC_AHB3ENR_FSMCEN)) == RESET)
S#define __HAL_RCC_QSPI_IS_CLK_DISABLED() ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) == RESET)
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM12_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM12_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM13_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM13_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)                                        
S#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F413xx || STM32F423xx */  
S#define __HAL_RCC_RTCAPB_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RTCAPB_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USART3_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USART3_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART4_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART5_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART5_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F413xx || STM32F423xx */
S                                        
S#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN3_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F413xx || STM32F423xx */
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DAC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART7_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART7_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART8_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART8_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F413xx || STM32F423xx */
S                                        
S#define __HAL_RCC_TIM2_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_TIM6_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
S#define __HAL_RCC_TIM7_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
S#define __HAL_RCC_TIM12_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))
S#define __HAL_RCC_TIM13_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))
S#define __HAL_RCC_TIM14_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN)) 
S#if defined(STM32F413xx) || defined(STM32F423xx)                 
S#define __HAL_RCC_LPTIM1_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_LPTIM1EN))
S#endif /* STM32F413xx || STM32F423xx */
S#define __HAL_RCC_RTCAPB_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_RTCAPBEN))                                       
S#define __HAL_RCC_SPI3_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#define __HAL_RCC_USART3_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
S#if defined(STM32F413xx) || defined(STM32F423xx)   
S#define __HAL_RCC_UART4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))
S#define __HAL_RCC_UART5_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_I2C3_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S#define __HAL_RCC_FMPI2C1_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_FMPI2C1EN))
S#define __HAL_RCC_CAN1_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))
S#define __HAL_RCC_CAN2_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN3EN))                                        
S#define __HAL_RCC_DAC_CLK_DISABLE()     (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
S#define __HAL_RCC_UART7_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART7EN))
S#define __HAL_RCC_UART8_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART8EN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S                                        
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET)
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET)
S#define __HAL_RCC_TIM6_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET)
S#define __HAL_RCC_TIM7_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET)
S#define __HAL_RCC_TIM12_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET)
S#define __HAL_RCC_TIM13_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET)
S#define __HAL_RCC_TIM14_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET) 
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) != RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                            
S#define __HAL_RCC_RTCAPB_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_RTCAPBEN)) != RESET)                                    
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET)
S#define __HAL_RCC_USART3_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET) 
S#define __HAL_RCC_UART5_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
S#define __HAL_RCC_FMPI2C1_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) != RESET)
S#define __HAL_RCC_CAN1_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN))!= RESET)
S#define __HAL_RCC_CAN2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN3EN)) != RESET)
S#define __HAL_RCC_DAC_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET) 
S#define __HAL_RCC_UART7_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) != RESET)
S#define __HAL_RCC_UART8_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) != RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                         
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET)
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET)
S#define __HAL_RCC_TIM6_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET)
S#define __HAL_RCC_TIM7_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET)
S#define __HAL_RCC_TIM12_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET)
S#define __HAL_RCC_TIM13_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET)
S#define __HAL_RCC_TIM14_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)                                          
S#define __HAL_RCC_LPTIM1_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) == RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_RTCAPB_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_RTCAPBEN)) == RESET)                                        
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET)
S#define __HAL_RCC_USART3_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)                                           
S#define __HAL_RCC_UART4_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET) 
S#define __HAL_RCC_UART5_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                          
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)
S#define __HAL_RCC_FMPI2C1_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) == RESET)
S#define __HAL_RCC_CAN1_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET)
S#define __HAL_RCC_CAN2_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)                                        
S#define __HAL_RCC_CAN3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN3EN)) == RESET)
S#define __HAL_RCC_DAC_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET) 
S#define __HAL_RCC_UART7_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) == RESET)
S#define __HAL_RCC_UART8_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) == RESET)
S#endif /* STM32F413xx || STM32F423xx */                                         
S/**
S  * @}
S  */  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM8_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_UART9EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_UART9EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART9_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_UART9EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_UART9EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART10_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_UART10EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_UART10EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                          
X#define __HAL_RCC_UART10_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_UART10EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_UART10EN);                                      UNUSED(tmpreg);                                       } while(0U)                                          
S#endif /* STM32F413xx || STM32F423xx */                                   
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U) 
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U) 
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_EXTIT_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                        
X#define __HAL_RCC_EXTIT_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);                                      UNUSED(tmpreg);                                       } while(0U)                                        
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U) 
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U) 
S#define __HAL_RCC_SPI5_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI5_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                         
X#define __HAL_RCC_SAI1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                      UNUSED(tmpreg);                                       } while(0U)                                         
S#endif /* STM32F413xx || STM32F423xx */                                          
S#define __HAL_RCC_DFSDM1_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DFSDM1_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                        
X#define __HAL_RCC_DFSDM2_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM2EN);                                      UNUSED(tmpreg);                                       } while(0U)                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S 
S#define __HAL_RCC_TIM8_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_UART9EN))
S#define __HAL_RCC_UART10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_UART10EN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_SDIO_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_EXTIT_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_EXTITEN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S#define __HAL_RCC_SPI5_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI1EN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_DFSDM1EN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_DFSDM2EN))                                      
S#endif /* STM32F413xx || STM32F423xx */                                         
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM8_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_UART9EN)) != RESET)
S#define __HAL_RCC_UART10_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_UART10EN)) != RESET)                                        
S#endif /* STM32F413xx || STM32F423xx */                                          
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET) 
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)
S#define __HAL_RCC_EXTIT_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_EXTITEN)) != RESET)
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)
S#define __HAL_RCC_SPI5_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) != RESET)                                    
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_DFSDM1_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM1EN)) != RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM2EN)) != RESET)                                  
S#endif /* STM32F413xx || STM32F423xx */                                         
S
S#define __HAL_RCC_TIM8_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_UART9EN)) == RESET) 
S#define __HAL_RCC_UART10_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_UART10EN)) == RESET)                                         
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET) 
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)
S#define __HAL_RCC_EXTIT_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_EXTITEN)) == RESET)
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET)
S#define __HAL_RCC_SPI5_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) == RESET)                                       
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM1EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM2EN)) == RESET)                                       
S#endif /* STM32F413xx || STM32F423xx */                                         
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOD_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOE_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_FORCE_RESET()      (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
S
S#if defined(STM32F423xx)
S#define __HAL_RCC_AES_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_AESRST))
S#define __HAL_RCC_AES_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_AESRST))                                        
S#endif /* STM32F423xx */ 
S                                        
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S
S#define __HAL_RCC_RNG_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_RNG_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S
S#define __HAL_RCC_FSMC_FORCE_RESET()    (RCC->AHB3RSTR |= (RCC_AHB3RSTR_FSMCRST))
S#define __HAL_RCC_QSPI_FORCE_RESET()   (RCC->AHB3RSTR |= (RCC_AHB3RSTR_QSPIRST))
S
S#define __HAL_RCC_FSMC_RELEASE_RESET()    (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FSMCRST))
S#define __HAL_RCC_QSPI_RELEASE_RESET()   (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_QSPIRST))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */ 
S#if defined(STM32F412Cx)
S#define __HAL_RCC_AHB3_FORCE_RESET()
S#define __HAL_RCC_AHB3_RELEASE_RESET()
S
S#define __HAL_RCC_FSMC_FORCE_RESET()
S#define __HAL_RCC_QSPI_FORCE_RESET()
S
S#define __HAL_RCC_FSMC_RELEASE_RESET()
S#define __HAL_RCC_QSPI_RELEASE_RESET()
S#endif /* STM32F412Cx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST)) 
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))                                        
S#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST)) 
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_LPTIM1RST)) 
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))                                        
S#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))                                        
S#endif /* STM32F413xx || STM32F423xx */                                          
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))                                        
S#define __HAL_RCC_FMPI2C1_FORCE_RESET()  (RCC->APB1RSTR |= (RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_CAN1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN3RST))
S#define __HAL_RCC_DAC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_UART7_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART7RST))
S#define __HAL_RCC_UART8_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART8RST))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S
S#define __HAL_RCC_TIM2_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_TIM6_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST)) 
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_LPTIM1RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SPI3_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_USART3_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_I2C3_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))                                        
S#define __HAL_RCC_FMPI2C1_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_CAN1_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN3RST))
S#define __HAL_RCC_DAC_RELEASE_RESET()     (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_UART7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART7RST))
S#define __HAL_RCC_UART8_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART8RST))                                      
S#endif /* STM32F413xx || STM32F423xx */                                         
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM8_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_UART9RST))
S#define __HAL_RCC_UART10_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_UART10RST))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SDIO_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))                                        
S#define __HAL_RCC_SPI5_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI1RST))
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_DFSDM1_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_DFSDM1RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_DFSDM2RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S
S#define __HAL_RCC_TIM8_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_UART9RST))
S#define __HAL_RCC_UART10_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_UART10RST))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SDIO_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S#define __HAL_RCC_SPI5_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI1RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_DFSDM1RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_DFSDM2RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()        (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()       (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#if defined(STM32F423xx)
S#define __HAL_RCC_AES_CLK_SLEEP_ENABLE()      (RCC->AHB2LPENR |= (RCC_AHB2LPENR_AESLPEN))                                        
S#define __HAL_RCC_AES_CLK_SLEEP_DISABLE()     (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_AESLPEN))
S#endif /* STM32F423xx */
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()   (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S
S#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()   (RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))
S#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()  (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_LowPower_Enable_Disable AHB3 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_FSMC_CLK_SLEEP_ENABLE()   (RCC->AHB3LPENR |= (RCC_AHB3LPENR_FSMCLPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_QSPILPEN))
S
S#define __HAL_RCC_FSMC_CLK_SLEEP_DISABLE()   (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FSMCLPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE()  (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_QSPILPEN))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))                                        
S#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_LPTIM1LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_RTCAPB_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_RTCAPBLPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))                                       
S#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))                                        
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_ENABLE() (RCC->APB1LPENR |= (RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN3LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_UART7_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART7LPEN))
S#define __HAL_RCC_UART8_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART8LPEN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_LPTIM1LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_RTCAPB_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_RTCAPBLPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))                                        
S#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))                                        
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN3LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_UART7_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART7LPEN))
S#define __HAL_RCC_UART8_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART8LPEN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                     
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_UART9LPEN))
S#define __HAL_RCC_UART10_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_UART10LPEN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))  
S#define __HAL_RCC_EXTIT_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_EXTITLPEN)) 
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))                                        
S#define __HAL_RCC_SPI5_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI1LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_DFSDM1LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_DFSDM2LPEN))
S#endif /* STM32F413xx || STM32F423xx */
S                                        
S#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_UART9LPEN))
S#define __HAL_RCC_UART10_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_UART10LPEN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_EXTIT_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_EXTITLPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))    
S#define __HAL_RCC_SPI5_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI1LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_DFSDM1LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_DFSDM2LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S/**
S  * @}
S  */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------------------- PLL Configuration --------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F446xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
S/** @brief  Macro to configure the main PLL clock source, multiplication and division factors.
S  * @note   This function must be used only when the main PLL is disabled.
S  * @param  __RCC_PLLSource__ specifies the PLL entry clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
S  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
S  * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
S  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 2 MHz to limit PLL jitter.
S  * @param  __PLLN__ specifies the multiplication factor for PLL VCO output clock
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
S  *         output frequency is between 100 and 432 MHz.
S  *   
S  * @param  __PLLP__ specifies the division factor for main system clock (SYSCLK)
S  *         This parameter must be a number in the range {2, 4, 6, or 8}.
S  *           
S  * @param  __PLLQ__ specifies the division factor for OTG FS, SDIO and RNG clocks
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  * @note   If the USB OTG FS is used in your application, you have to set the
S  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
S  *         the SDIO and RNG need a frequency lower than or equal to 48 MHz to work
S  *         correctly.
S  *     
S  * @param  __PLLR__ PLL division factor for I2S, SAI, SYSTEM, SPDIFRX clocks.
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   This parameter is only available in STM32F446xx/STM32F469xx/STM32F479xx/
S            STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/STM32F413xx/STM32F423xx devices.
S  *      
S  */
S#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__,__PLLR__)  \
S                            (RCC->PLLCFGR = ((__RCC_PLLSource__) | (__PLLM__)                   | \
S                            ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos)                      | \
S                            ((((__PLLP__) >> 1U) -1U) << RCC_PLLCFGR_PLLP_Pos)          | \
S                            ((__PLLQ__) << RCC_PLLCFGR_PLLQ_Pos)                      | \
S                            ((__PLLR__) << RCC_PLLCFGR_PLLR_Pos)))
X#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__,__PLLR__)                              (RCC->PLLCFGR = ((__RCC_PLLSource__) | (__PLLM__)                   |                             ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos)                      |                             ((((__PLLP__) >> 1U) -1U) << RCC_PLLCFGR_PLLP_Pos)          |                             ((__PLLQ__) << RCC_PLLCFGR_PLLQ_Pos)                      |                             ((__PLLR__) << RCC_PLLCFGR_PLLR_Pos)))
N#else
N/** @brief  Macro to configure the main PLL clock source, multiplication and division factors.
N  * @note   This function must be used only when the main PLL is disabled.
N  * @param  __RCC_PLLSource__ specifies the PLL entry clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
N  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
N  * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
N  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
N  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
N  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
N  *         of 2 MHz to limit PLL jitter.
N  * @param  __PLLN__ specifies the multiplication factor for PLL VCO output clock
N  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432
N  *         Except for STM32F411xE devices where Min_Data = 192.
N  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
N  *         output frequency is between 100 and 432 MHz, Except for STM32F411xE devices
N  *         where frequency is between 192 and 432 MHz.
N  * @param  __PLLP__ specifies the division factor for main system clock (SYSCLK)
N  *         This parameter must be a number in the range {2, 4, 6, or 8}.
N  *           
N  * @param  __PLLQ__ specifies the division factor for OTG FS, SDIO and RNG clocks
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
N  * @note   If the USB OTG FS is used in your application, you have to set the
N  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
N  *         the SDIO and RNG need a frequency lower than or equal to 48 MHz to work
N  *         correctly.
N  *      
N  */
N#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__)     \
N                            (RCC->PLLCFGR = (0x20000000U | (__RCC_PLLSource__) | (__PLLM__)| \
N                            ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos)                | \
N                            ((((__PLLP__) >> 1U) -1U) << RCC_PLLCFGR_PLLP_Pos)    | \
N                            ((__PLLQ__) << RCC_PLLCFGR_PLLQ_Pos)))
X#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__)                                 (RCC->PLLCFGR = (0x20000000U | (__RCC_PLLSource__) | (__PLLM__)|                             ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos)                |                             ((((__PLLP__) >> 1U) -1U) << RCC_PLLCFGR_PLLP_Pos)    |                             ((__PLLQ__) << RCC_PLLCFGR_PLLQ_Pos)))
N #endif /* STM32F410xx || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*----------------------------------------------------------------------------*/
N                             
N/*----------------------------PLLI2S Configuration ---------------------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 1L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
N
N/** @brief Macros to enable or disable the PLLI2S. 
N  * @note  The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.
N  */
N#define __HAL_RCC_PLLI2S_ENABLE() (*(__IO uint32_t *) RCC_CR_PLLI2SON_BB = ENABLE)
N#define __HAL_RCC_PLLI2S_DISABLE() (*(__IO uint32_t *) RCC_CR_PLLI2SON_BB = DISABLE)
N
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || 
N          STM32F412Rx || STM32F412Cx */
N#if defined(STM32F446xx)
X#if 0L
S/** @brief  Macro to configure the PLLI2S clock multiplication and division factors .
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   PLLI2S clock source is common with the main PLL (configured in 
S  *         HAL_RCC_ClockConfig() API).
S  * @param  __PLLI2SM__ specifies the division factor for PLLI2S VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   You have to set the PLLI2SM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 1 MHz to limit PLLI2S jitter.
S  *
S  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLI2SP__ specifies division factor for SPDIFRX Clock.
S  *         This parameter must be a number in the range {2, 4, 6, or 8}.
S  * @note   the PLLI2SP parameter is only available with STM32F446xx Devices
S  *                 
S  * @param  __PLLI2SR__ specifies the division factor for I2S clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
S  *         on the I2S clock frequency.
S  *   
S  * @param  __PLLI2SQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  */
S#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SP__, __PLLI2SQ__, __PLLI2SR__)    \
S                               (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                   |\
S                               ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |\
S                               ((((__PLLI2SP__) >> 1U) -1U) << RCC_PLLI2SCFGR_PLLI2SP_Pos) |\
S                               ((__PLLI2SQ__) << RCC_PLLI2SCFGR_PLLI2SQ_Pos)             |\
S                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
X#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SP__, __PLLI2SQ__, __PLLI2SR__)                                   (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                   |                               ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |                               ((((__PLLI2SP__) >> 1U) -1U) << RCC_PLLI2SCFGR_PLLI2SP_Pos) |                               ((__PLLI2SQ__) << RCC_PLLI2SCFGR_PLLI2SQ_Pos)             |                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
S#elif defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
S      defined(STM32F413xx) || defined(STM32F423xx)
X#elif 0L || 0L || 0L || 0L ||      0L || 0L
S/** @brief  Macro to configure the PLLI2S clock multiplication and division factors .
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   PLLI2S clock source is common with the main PLL (configured in 
S  *         HAL_RCC_ClockConfig() API).
S  * @param  __PLLI2SM__ specifies the division factor for PLLI2S VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   You have to set the PLLI2SM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 1 MHz to limit PLLI2S jitter.
S  *
S  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLI2SR__ specifies the division factor for I2S clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
S  *         on the I2S clock frequency.
S  *
S  * @param  __PLLI2SQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  */
S#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SQ__, __PLLI2SR__)    \
S                               (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                   |\
S                               ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |\
S                               ((__PLLI2SQ__) << RCC_PLLI2SCFGR_PLLI2SQ_Pos)             |\
S                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
X#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SQ__, __PLLI2SR__)                                   (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                   |                               ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |                               ((__PLLI2SQ__) << RCC_PLLI2SCFGR_PLLI2SQ_Pos)             |                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
N#else
N/** @brief  Macro to configure the PLLI2S clock multiplication and division factors .
N  * @note   This macro must be used only when the PLLI2S is disabled.
N  * @note   PLLI2S clock source is common with the main PLL (configured in 
N  *         HAL_RCC_ClockConfig() API).
N  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock
N  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
N  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
N  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
N  *
N  * @param  __PLLI2SR__ specifies the division factor for I2S clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
N  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
N  *         on the I2S clock frequency.
N  *
N  */
N#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SN__, __PLLI2SR__)                                                    \
N                               (RCC->PLLI2SCFGR = (((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)  |\
N                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
X#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SN__, __PLLI2SR__)                                                                                   (RCC->PLLI2SCFGR = (((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)  |                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
N#endif /* STM32F446xx */
N
N#if defined(STM32F411xE)
X#if 0L
S/** @brief  Macro to configure the PLLI2S clock multiplication and division factors .
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   PLLI2S clock source is common with the main PLL (configured in 
S  *         HAL_RCC_ClockConfig() API).
S  * @param  __PLLI2SM__ specifies the division factor for PLLI2S VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   The PLLI2SM parameter is only used with STM32F411xE/STM32F410xx Devices
S  * @note   You have to set the PLLI2SM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 2 MHz to limit PLLI2S jitter.    
S  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock
S  *         This parameter must be a number between Min_Data = 192 and Max_Data = 432.
S  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 192 and Max_Data = 432 MHz.
S  * @param  __PLLI2SR__ specifies the division factor for I2S clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
S  *         on the I2S clock frequency.
S  */
S#define __HAL_RCC_PLLI2S_I2SCLK_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SR__) (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                                       |\
S                                                                                                  ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |\
S                                                                                                  ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
X#define __HAL_RCC_PLLI2S_I2SCLK_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SR__) (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                                       |                                                                                                  ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |                                                                                                  ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
N#endif /* STM32F411xE */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** @brief  Macro used by the SAI HAL driver to configure the PLLI2S clock multiplication and division factors.
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   PLLI2S clock source is common with the main PLL (configured in 
S  *         HAL_RCC_ClockConfig() API)             
S  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock.
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  * @param  __PLLI2SQ__ specifies the division factor for SAI1 clock.
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
S  * @note   the PLLI2SQ parameter is only available with STM32F427xx/437xx/429xx/439xx/469xx/479xx 
S  *         Devices and can be configured using the __HAL_RCC_PLLI2S_PLLSAICLK_CONFIG() macro
S  * @param  __PLLI2SR__ specifies the division factor for I2S clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
S  *         on the I2S clock frequency.
S  */
S#define __HAL_RCC_PLLI2S_SAICLK_CONFIG(__PLLI2SN__, __PLLI2SQ__, __PLLI2SR__) (RCC->PLLI2SCFGR = ((__PLLI2SN__) << 6U)  |\
S                                                                                                 ((__PLLI2SQ__) << 24U) |\
S                                                                                                 ((__PLLI2SR__) << 28U))
X#define __HAL_RCC_PLLI2S_SAICLK_CONFIG(__PLLI2SN__, __PLLI2SQ__, __PLLI2SR__) (RCC->PLLI2SCFGR = ((__PLLI2SN__) << 6U)  |                                                                                                 ((__PLLI2SQ__) << 24U) |                                                                                                 ((__PLLI2SR__) << 28U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */   
N/*----------------------------------------------------------------------------*/
N
N/*------------------------------ PLLSAI Configuration ------------------------*/
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L
S/** @brief Macros to Enable or Disable the PLLISAI. 
S  * @note  The PLLSAI is only available with STM32F429x/439x Devices.
S  * @note  The PLLSAI is disabled by hardware when entering STOP and STANDBY modes. 
S  */
S#define __HAL_RCC_PLLSAI_ENABLE() (*(__IO uint32_t *) RCC_CR_PLLSAION_BB = ENABLE)
S#define __HAL_RCC_PLLSAI_DISABLE() (*(__IO uint32_t *) RCC_CR_PLLSAION_BB = DISABLE)
S
S#if defined(STM32F446xx)
S/** @brief  Macro to configure the PLLSAI clock multiplication and division factors.
S  *
S  * @param  __PLLSAIM__ specifies the division factor for PLLSAI VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   You have to set the PLLSAIM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 1 MHz to limit PLLI2S jitter.
S  * @note   The PLLSAIM parameter is only used with STM32F446xx Devices
S  *             
S  * @param  __PLLSAIN__ specifies the multiplication factor for PLLSAI VCO output clock.
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLSAIP__ specifies division factor for OTG FS, SDIO and RNG clocks.
S  *         This parameter must be a number in the range {2, 4, 6, or 8}.
S  * @note   the PLLSAIP parameter is only available with STM32F446xx Devices
S  *                 
S  * @param  __PLLSAIQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  *           
S  * @param  __PLLSAIR__ specifies the division factor for LTDC clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   the PLLI2SR parameter is only available with STM32F427/437/429/439xx Devices  
S  */
S#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIM__, __PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__)     \
S                               (RCC->PLLSAICFGR = ((__PLLSAIM__)                                   | \
S                               ((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)             | \
S                               ((((__PLLSAIP__) >> 1U) -1U) << RCC_PLLSAICFGR_PLLSAIP_Pos) | \
S                               ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos))) 
X#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIM__, __PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__)                                    (RCC->PLLSAICFGR = ((__PLLSAIM__)                                   |                                ((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)             |                                ((((__PLLSAIP__) >> 1U) -1U) << RCC_PLLSAICFGR_PLLSAIP_Pos) |                                ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos))) 
S#endif /* STM32F446xx */
S                                 
S#if defined(STM32F469xx) || defined(STM32F479xx)
S/** @brief  Macro to configure the PLLSAI clock multiplication and division factors.
S  *             
S  * @param  __PLLSAIN__ specifies the multiplication factor for PLLSAI VCO output clock.
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLSAIP__ specifies division factor for SDIO and CLK48 clocks.
S  *         This parameter must be a number in the range {2, 4, 6, or 8}.
S  *                 
S  * @param  __PLLSAIQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  *           
S  * @param  __PLLSAIR__ specifies the division factor for LTDC clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.  
S  */
S#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__) \
S                               (RCC->PLLSAICFGR = (((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)             |\
S                                                   ((((__PLLSAIP__) >> 1U) -1U) << RCC_PLLSAICFGR_PLLSAIP_Pos) |\
S                                                   ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos)             |\
S                                                   ((__PLLSAIR__) << RCC_PLLSAICFGR_PLLSAIR_Pos)))
X#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__)                                (RCC->PLLSAICFGR = (((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)             |                                                   ((((__PLLSAIP__) >> 1U) -1U) << RCC_PLLSAICFGR_PLLSAIP_Pos) |                                                   ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos)             |                                                   ((__PLLSAIR__) << RCC_PLLSAICFGR_PLLSAIR_Pos)))
S#endif /* STM32F469xx || STM32F479xx */                                 
S
S#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
S/** @brief  Macro to configure the PLLSAI clock multiplication and division factors.
S  *             
S  * @param  __PLLSAIN__ specifies the multiplication factor for PLLSAI VCO output clock.
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLSAIQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  *           
S  * @param  __PLLSAIR__ specifies the division factor for LTDC clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   the PLLI2SR parameter is only available with STM32F427/437/429/439xx Devices  
S  */
S#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIQ__, __PLLSAIR__)                                        \
S                               (RCC->PLLSAICFGR = (((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)  | \
S                               ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos)                      | \
S                               ((__PLLSAIR__) << RCC_PLLSAICFGR_PLLSAIR_Pos)))
X#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIQ__, __PLLSAIR__)                                                                       (RCC->PLLSAICFGR = (((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)  |                                ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos)                      |                                ((__PLLSAIR__) << RCC_PLLSAICFGR_PLLSAIR_Pos)))
S#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */
S
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------- PLLSAI/PLLI2S Dividers Configuration -------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S/** @brief  Macro to configure the SAI clock Divider coming from PLLI2S.
S  * @note   This function must be called before enabling the PLLI2S.
S  * @param  __PLLI2SDivR__ specifies the PLLI2S division factor for SAI1 clock.
S  *          This parameter must be a number between 1 and 32.
S  *          SAI1 clock frequency = f(PLLI2SR) / __PLLI2SDivR__ 
S  */
S#define __HAL_RCC_PLLI2S_PLLSAICLKDIVR_CONFIG(__PLLI2SDivR__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLI2SDIVR, (__PLLI2SDivR__)-1U))
S
S/** @brief  Macro to configure the SAI clock Divider coming from PLL.
S  * @param  __PLLDivR__ specifies the PLL division factor for SAI1 clock.
S  *          This parameter must be a number between 1 and 32.
S  *          SAI1 clock frequency = f(PLLR) / __PLLDivR__ 
S  */
S#define __HAL_RCC_PLL_PLLSAICLKDIVR_CONFIG(__PLLDivR__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLDIVR, ((__PLLDivR__)-1U)<<8U))                                 
N#endif /* STM32F413xx || STM32F423xx */  
N                                 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)  || defined(STM32F446xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L  || 0L ||    0L || 0L
S/** @brief  Macro to configure the SAI clock Divider coming from PLLI2S.
S  * @note   This function must be called before enabling the PLLI2S.
S  * @param  __PLLI2SDivQ__ specifies the PLLI2S division factor for SAI1 clock.
S  *          This parameter must be a number between 1 and 32.
S  *          SAI1 clock frequency = f(PLLI2SQ) / __PLLI2SDivQ__ 
S  */
S#define __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(__PLLI2SDivQ__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLI2SDIVQ, (__PLLI2SDivQ__)-1U))
S
S/** @brief  Macro to configure the SAI clock Divider coming from PLLSAI.
S  * @note   This function must be called before enabling the PLLSAI.
S  * @param  __PLLSAIDivQ__ specifies the PLLSAI division factor for SAI1 clock .
S  *         This parameter must be a number between Min_Data = 1 and Max_Data = 32.
S  *         SAI1 clock frequency = f(PLLSAIQ) / __PLLSAIDivQ__  
S  */
S#define __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(__PLLSAIDivQ__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLSAIDIVQ, ((__PLLSAIDivQ__)-1U)<<8U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** @brief  Macro to configure the LTDC clock Divider coming from PLLSAI.
S  * 
S  * @note   The LTDC peripheral is only available with STM32F427/437/429/439/469/479xx Devices.
S  * @note   This function must be called before enabling the PLLSAI. 
S  * @param  __PLLSAIDivR__ specifies the PLLSAI division factor for LTDC clock .
S  *          This parameter must be a number between Min_Data = 2 and Max_Data = 16.
S  *          LTDC clock frequency = f(PLLSAIR) / __PLLSAIDivR__ 
S  */
S#define __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(__PLLSAIDivR__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLSAIDIVR, (__PLLSAIDivR__)))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------------- Peripheral Clock selection -----------------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F469xx) ||\
N    defined(STM32F479xx)
X#if 0L || 0L || 1L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
N/** @brief  Macro to configure the I2S clock source (I2SCLK).
N  * @note   This function must be called before enabling the I2S APB clock.
N  * @param  __SOURCE__ specifies the I2S clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_I2SCLKSOURCE_PLLI2S: PLLI2S clock used as I2S clock source.
N  *            @arg RCC_I2SCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin
N  *                                       used as I2S clock source.
N  */
N#define __HAL_RCC_I2S_CONFIG(__SOURCE__) (*(__IO uint32_t *) RCC_CFGR_I2SSRC_BB = (__SOURCE__))
N
N
N/** @brief  Macro to get the I2S clock source (I2SCLK).
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_I2SCLKSOURCE_PLLI2S: PLLI2S clock used as I2S clock source.
N  *            @arg @ref RCC_I2SCLKSOURCE_EXT External clock mapped on the I2S_CKIN pin
N  *                                        used as I2S clock source
N  */
N#define __HAL_RCC_GET_I2S_SOURCE() ((uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_I2SSRC)))
N#endif /* STM32F40xxx || STM32F41xxx || STM32F42xxx || STM32F43xxx || STM32F469xx || STM32F479xx */
N                                 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S                                 
S/** @brief  Macro to configure SAI1BlockA clock source selection.
S  * @note   The SAI peripheral is only available with STM32F427/437/429/439/469/479xx Devices.      
S  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI Block A clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAIACLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
S  *                                           as SAI1 Block A clock. 
S  *            @arg RCC_SAIACLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
S  *                                           as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_Ext: External clock mapped on the I2S_CKIN pin
S  *                                        used as SAI1 Block A clock.
S  */
S#define __HAL_RCC_SAI_BLOCKACLKSOURCE_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1ASRC, (__SOURCE__)))
S
S/** @brief  Macro to configure SAI1BlockB clock source selection.
S  * @note   The SAI peripheral is only available with STM32F427/437/429/439/469/479xx Devices.
S  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI Block B clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAIBCLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
S  *                                           as SAI1 Block B clock. 
S  *            @arg RCC_SAIBCLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
S  *                                           as SAI1 Block B clock. 
S  *            @arg RCC_SAIBCLKSOURCE_Ext: External clock mapped on the I2S_CKIN pin
S  *                                        used as SAI1 Block B clock.
S  */
S#define __HAL_RCC_SAI_BLOCKBCLKSOURCE_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1BSRC, (__SOURCE__)))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F446xx)
X#if 0L
S/** @brief  Macro to configure SAI1 clock source selection.
S  * @note   This configuration is only available with STM32F446xx Devices.
S  * @note   This function must be called before enabling PLL, PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAI1CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used as SAI1 clock. 
S  *            @arg RCC_SAI1CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used as SAI1 clock.
S  *            @arg RCC_SAI1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SAI1 clock.  
S  *            @arg RCC_SAI1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as SAI1 clock.
S  */
S#define __HAL_RCC_SAI1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get SAI1 clock source selection.
S  * @note   This configuration is only available with STM32F446xx Devices.      
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SAI1CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used as SAI1 clock. 
S  *            @arg RCC_SAI1CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used as SAI1 clock.
S  *            @arg RCC_SAI1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SAI1 clock.  
S  *            @arg RCC_SAI1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as SAI1 clock.
S  */
S#define __HAL_RCC_GET_SAI1_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SAI1SRC))
S
S/** @brief  Macro to configure SAI2 clock source selection.
S  * @note   This configuration is only available with STM32F446xx Devices.      
S  * @note   This function must be called before enabling PLL, PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI2 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAI2CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used as SAI2 clock. 
S  *            @arg RCC_SAI2CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used as SAI2 clock.
S  *            @arg RCC_SAI2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SAI2 clock.  
S  *            @arg RCC_SAI2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock used as SAI2 clock.
S  */
S#define __HAL_RCC_SAI2_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI2SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get SAI2 clock source selection.
S  * @note   This configuration is only available with STM32F446xx Devices.      
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SAI2CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used as SAI2 clock. 
S  *            @arg RCC_SAI2CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used as SAI2 clock.
S  *            @arg RCC_SAI2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SAI2 clock.  
S  *            @arg RCC_SAI2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock used as SAI2 clock.
S  */
S#define __HAL_RCC_GET_SAI2_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SAI2SRC))
S
S/** @brief  Macro to configure I2S APB1 clock source selection.
S  * @note   This function must be called before enabling PLL, PLLI2S and the I2S clock.
S  * @param  __SOURCE__ specifies the I2S APB1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock. 
S  *            @arg RCC_I2SAPB1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S APB1 clock.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as I2S APB1 clock.  
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_I2S_APB1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2S1SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S APB1 clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock. 
S  *            @arg RCC_I2SAPB1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S APB1 clock.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as I2S APB1 clock.  
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_I2S_APB1_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2S1SRC))
S
S/** @brief  Macro to configure I2S APB2 clock source selection.
S  * @note   This function must be called before enabling PLL, PLLI2S and the I2S clock.
S  * @param  __SOURCE__ specifies the SAI Block A clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock. 
S  *            @arg RCC_I2SAPB2CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S APB2 clock.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as I2S APB2 clock.  
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_I2S_APB2_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2S2SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S APB2 clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock. 
S  *            @arg RCC_I2SAPB2CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S APB2 clock.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as I2S APB2 clock.  
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_I2S_APB2_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2S2SRC))
S
S/** @brief  Macro to configure the CEC clock.
S  * @param  __SOURCE__ specifies the CEC clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_CECCLKSOURCE_HSI: HSI selected as CEC clock
S  *            @arg RCC_CECCLKSOURCE_LSE: LSE selected as CEC clock
S  */
S#define __HAL_RCC_CEC_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the CEC clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_CECCLKSOURCE_HSI488: HSI selected as CEC clock
S  *            @arg RCC_CECCLKSOURCE_LSE: LSE selected as CEC clock
S  */
S#define __HAL_RCC_GET_CEC_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL))
S
S/** @brief  Macro to configure the FMPI2C1 clock.
S  * @param  __SOURCE__ specifies the FMPI2C1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_FMPI2C1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the FMPI2C1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_GET_FMPI2C1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL))
S
S/** @brief  Macro to configure the CLK48 clock.
S  * @param  __SOURCE__ specifies the CLK48 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLSAIP: PLLSAI VCO Output divided by PLLSAIP used as CLK48 clock. 
S  */
S#define __HAL_RCC_CLK48_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the CLK48 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLSAIP: PLLSAI VCO Output divided by PLLSAIP used as CLK48 clock. 
S  */
S#define __HAL_RCC_GET_CLK48_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL))
S
S/** @brief  Macro to configure the SDIO clock.
S  * @param  __SOURCE__ specifies the SDIO clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_SDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the SDIO clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_GET_SDIO_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL))
S
S/** @brief  Macro to configure the SPDIFRX clock.
S  * @param  __SOURCE__ specifies the SPDIFRX clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SPDIFRXCLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SPDIFRX clock.  
S  *            @arg RCC_SPDIFRXCLKSOURCE_PLLI2SP: PLLI2S VCO Output divided by PLLI2SP used as SPDIFRX clock. 
S  */
S#define __HAL_RCC_SPDIFRX_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SPDIFRXSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the SPDIFRX clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SPDIFRXCLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SPDIFRX clock.  
S  *            @arg RCC_SPDIFRXCLKSOURCE_PLLI2SP: PLLI2S VCO Output divided by PLLI2SP used as SPDIFRX clock. 
S  */
S#define __HAL_RCC_GET_SPDIFRX_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SPDIFRXSEL))
N#endif /* STM32F446xx */
N      
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S      
S/** @brief  Macro to configure the CLK48 clock.
S  * @param  __SOURCE__ specifies the CLK48 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLSAIP: PLLSAI VCO Output divided by PLLSAIP used as CLK48 clock. 
S  */
S#define __HAL_RCC_CLK48_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CK48MSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the CLK48 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLSAIP: PLLSAI VCO Output divided by PLLSAIP used as CLK48 clock. 
S  */
S#define __HAL_RCC_GET_CLK48_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CK48MSEL))
S
S/** @brief  Macro to configure the SDIO clock.
S  * @param  __SOURCE__ specifies the SDIO clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_SDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SDIOSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the SDIO clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_GET_SDIO_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SDIOSEL))  
S      
S/** @brief  Macro to configure the DSI clock.
S  * @param  __SOURCE__ specifies the DSI clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DSICLKSOURCE_PLLR: PLLR output used as DSI clock. 
S  *            @arg RCC_DSICLKSOURCE_DSIPHY: DSI-PHY output used as DSI clock. 
S  */
S#define __HAL_RCC_DSI_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_DSISEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the DSI clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DSICLKSOURCE_PLLR: PLLR output used as DSI clock. 
S  *            @arg RCC_DSICLKSOURCE_DSIPHY: DSI-PHY output used as DSI clock. 
S  */
S#define __HAL_RCC_GET_DSI_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_DSISEL))       
S      
N#endif /* STM32F469xx || STM32F479xx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S /** @brief  Macro to configure the DFSDM1 clock.
S  * @param  __DFSDM1_CLKSOURCE__ specifies the DFSDM1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DFSDM1CLKSOURCE_PCLK2: PCLK2 clock used as kernel clock. 
S  *            @arg RCC_DFSDM1CLKSOURCE_SYSCLK: System clock used as kernel clock.
S  * @retval None
S  */
S#define __HAL_RCC_DFSDM1_CONFIG(__DFSDM1_CLKSOURCE__)  MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1SEL, (__DFSDM1_CLKSOURCE__))
S
S/** @brief  Macro to get the DFSDM1 clock source.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DFSDM1CLKSOURCE_PCLK2: PCLK2 clock used as kernel clock. 
S  *            @arg RCC_DFSDM1CLKSOURCE_SYSCLK: System clock used as kernel clock.
S  */
S#define __HAL_RCC_GET_DFSDM1_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1SEL)))
S
S/** @brief  Macro to configure DFSDM1 Audio clock source selection.
S  * @note   This configuration is only available with STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/
S            STM32F413xx/STM32F423xx Devices.
S  * @param  __SOURCE__ specifies the DFSDM1 Audio clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_I2S1: CK_I2S_PCLK1 selected as audio clock
S  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_I2S2: CK_I2S_PCLK2 selected as audio clock
S  */
S#define __HAL_RCC_DFSDM1AUDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1ASEL, (__SOURCE__)))
S
S/** @brief  Macro to Get DFSDM1 Audio clock source selection.
S  * @note   This configuration is only available with STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/
S            STM32F413xx/STM32F423xx Devices.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_I2S1: CK_I2S_PCLK1 selected as audio clock
S  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_I2S2: CK_I2S_PCLK2 selected as audio clock
S  */
S#define __HAL_RCC_GET_DFSDM1AUDIO_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1ASEL))
S
S#if defined(STM32F413xx) || defined(STM32F423xx)
S /** @brief  Macro to configure the DFSDM2 clock.
S  * @param  __DFSDM2_CLKSOURCE__ specifies the DFSDM1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DFSDM2CLKSOURCE_PCLK2: PCLK2 clock used as kernel clock. 
S  *            @arg RCC_DFSDM2CLKSOURCE_SYSCLK: System clock used as kernel clock.
S  * @retval None
S  */
S#define __HAL_RCC_DFSDM2_CONFIG(__DFSDM2_CLKSOURCE__)  MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1SEL, (__DFSDM2_CLKSOURCE__))
S
S/** @brief  Macro to get the DFSDM2 clock source.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DFSDM2CLKSOURCE_PCLK2: PCLK2 clock used as kernel clock. 
S  *            @arg RCC_DFSDM2CLKSOURCE_SYSCLK: System clock used as kernel clock.
S  */
S#define __HAL_RCC_GET_DFSDM2_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1SEL)))
S
S/** @brief  Macro to configure DFSDM1 Audio clock source selection.
S  * @note   This configuration is only available with STM32F413xx/STM32F423xx Devices.
S  * @param  __SOURCE__ specifies the DFSDM2 Audio clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DFSDM2AUDIOCLKSOURCE_I2S1: CK_I2S_PCLK1 selected as audio clock
S  *            @arg RCC_DFSDM2AUDIOCLKSOURCE_I2S2: CK_I2S_PCLK2 selected as audio clock
S  */
S#define __HAL_RCC_DFSDM2AUDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM2ASEL, (__SOURCE__)))
S
S/** @brief  Macro to Get DFSDM2 Audio clock source selection.
S  * @note   This configuration is only available with STM32F413xx/STM32F423xx Devices.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DFSDM2AUDIOCLKSOURCE_I2S1: CK_I2S_PCLK1 selected as audio clock
S  *            @arg RCC_DFSDM2AUDIOCLKSOURCE_I2S2: CK_I2S_PCLK2 selected as audio clock
S  */
S#define __HAL_RCC_GET_DFSDM2AUDIO_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM2ASEL))
S      
S/** @brief  Macro to configure SAI1BlockA clock source selection.
S  * @note   The SAI peripheral is only available with STM32F413xx/STM32F423xx Devices.      
S  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI Block A clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAIACLKSOURCE_PLLI2SR: PLLI2S_R clock divided (R2) used as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_EXT: External clock mapped on the I2S_CKIN pinused as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_PLLR: PLL_R clock divided (R1) used as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_SAI_BLOCKACLKSOURCE_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1ASRC, (__SOURCE__)))
S      
S/** @brief  Macro to Get SAI1 BlockA clock source selection.
S  * @note   This configuration is only available with STM32F413xx/STM32F423xx Devices.      
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SAIACLKSOURCE_PLLI2SR: PLLI2S_R clock divided (R2) used as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_EXT: External clock mapped on the I2S_CKIN pinused as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_PLLR: PLL_R clock divided (R1) used as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_SAI_BLOCKA_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SAI1ASRC))
S
S/** @brief  Macro to configure SAI1 BlockB clock source selection.
S  * @note   The SAI peripheral is only available with STM32F413xx/STM32F423xx Devices.
S  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI Block B clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAIBCLKSOURCE_PLLI2SR: PLLI2S_R clock divided (R2) used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_PLLR: PLL_R clock divided (R1) used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_SAI_BLOCKBCLKSOURCE_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1BSRC, (__SOURCE__)))
S      
S/** @brief  Macro to Get SAI1 BlockB clock source selection.
S  * @note   This configuration is only available with STM32F413xx/STM32F423xx Devices.      
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SAIBCLKSOURCE_PLLI2SR: PLLI2S_R clock divided (R2) used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_PLLR: PLL_R clock divided (R1) used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_SAI_BLOCKB_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SAI1BSRC))
S
S/** @brief  Macro to configure the LPTIM1 clock.
S  * @param  __SOURCE__ specifies the LPTIM1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI clock selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
S  */
S#define __HAL_RCC_LPTIM1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the LPTIM1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI clock selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
S  */
S#define __HAL_RCC_GET_LPTIM1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL))      
S#endif /* STM32F413xx || STM32F423xx */
S      
S/** @brief  Macro to configure I2S APB1 clock source selection.
S  * @param  __SOURCE__ specifies the I2S APB1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR.
S  *            @arg RCC_I2SAPB1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_I2S_APB1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2S1SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S APB1 clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR.
S  *            @arg RCC_I2SAPB1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_I2S_APB1_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2S1SRC))
S
S/** @brief  Macro to configure I2S APB2 clock source selection.
S  * @param  __SOURCE__ specifies the I2S APB2 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR.
S  *            @arg RCC_I2SAPB2CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_I2S_APB2_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2S2SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S APB2 clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR.
S  *            @arg RCC_I2SAPB2CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_I2S_APB2_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2S2SRC))
S
S/** @brief  Macro to configure the PLL I2S clock source (PLLI2SCLK).
S  * @note   This macro must be called before enabling the I2S APB clock.
S  * @param  __SOURCE__ specifies the I2S clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_PLLI2SCLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  *            @arg RCC_PLLI2SCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin
S  *                                       used as I2S clock source.
S  */
S#define __HAL_RCC_PLL_I2S_CONFIG(__SOURCE__) (*(__IO uint32_t *) RCC_PLLI2SCFGR_PLLI2SSRC_BB = (__SOURCE__))
S      
S/** @brief  Macro to configure the FMPI2C1 clock.
S  * @param  __SOURCE__ specifies the FMPI2C1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_FMPI2C1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the FMPI2C1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_GET_FMPI2C1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL))
S
S/** @brief  Macro to configure the CLK48 clock.
S  * @param  __SOURCE__ specifies the CLK48 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLI2SQ: PLLI2S VCO Output divided by PLLI2SQ used as CLK48 clock.
S  */
S#define __HAL_RCC_CLK48_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the CLK48 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLI2SQ: PLLI2S VCO Output divided by PLLI2SQ used as CLK48 clock
S  */
S#define __HAL_RCC_GET_CLK48_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL))
S
S/** @brief  Macro to configure the SDIO clock.
S  * @param  __SOURCE__ specifies the SDIO clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_SDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the SDIO clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_GET_SDIO_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL))
S
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** @brief  Macro to configure I2S clock source selection.
S  * @param  __SOURCE__ specifies the I2S clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPBCLKSOURCE_PLLR: PLL VCO output clock divided by PLLR.
S  *            @arg RCC_I2SAPBCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPBCLKSOURCE_PLLSRC: HSI/HSE depends on PLLSRC.
S  */
S#define __HAL_RCC_I2S_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2SSRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPBCLKSOURCE_PLLR: PLL VCO output clock divided by PLLR.
S  *            @arg RCC_I2SAPBCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPBCLKSOURCE_PLLSRC: HSI/HSE depends on PLLSRC.
S  */
S#define __HAL_RCC_GET_I2S_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2SSRC))
S
S/** @brief  Macro to configure the FMPI2C1 clock.
S  * @param  __SOURCE__ specifies the FMPI2C1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_FMPI2C1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the FMPI2C1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_GET_FMPI2C1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL))
S
S/** @brief  Macro to configure the LPTIM1 clock.
S  * @param  __SOURCE__ specifies the LPTIM1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK1 selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI clock selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
S  */
S#define __HAL_RCC_LPTIM1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the LPTIM1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK1 selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI clock selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
S  */
S#define __HAL_RCC_GET_LPTIM1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N      
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
S/** @brief  Macro to configure the Timers clocks prescalers 
S  * @note   This feature is only available with STM32F429x/439x Devices.  
S  * @param  __PRESC__  specifies the Timers clocks prescalers selection
S  *         This parameter can be one of the following values:
S  *            @arg RCC_TIMPRES_DESACTIVATED: The Timers kernels clocks prescaler is 
S  *                 equal to HPRE if PPREx is corresponding to division by 1 or 2, 
S  *                 else it is equal to [(HPRE * PPREx) / 2] if PPREx is corresponding to 
S  *                 division by 4 or more.       
S  *            @arg RCC_TIMPRES_ACTIVATED: The Timers kernels clocks prescaler is 
S  *                 equal to HPRE if PPREx is corresponding to division by 1, 2 or 4, 
S  *                 else it is equal to [(HPRE * PPREx) / 4] if PPREx is corresponding 
S  *                 to division by 8 or more.
S  */     
S#define __HAL_RCC_TIMCLKPRESCALER(__PRESC__) (*(__IO uint32_t *) RCC_DCKCFGR_TIMPRE_BB = (__PRESC__))
S
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx) || STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE ||\
N          STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx  || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx ||\
N          STM32F423xx */
X#endif  
N
N/*----------------------------------------------------------------------------*/
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L
S/** @brief Enable PLLSAI_RDY interrupt.
S  */
S#define __HAL_RCC_PLLSAI_ENABLE_IT() (RCC->CIR |= (RCC_CIR_PLLSAIRDYIE))
S
S/** @brief Disable PLLSAI_RDY interrupt.
S  */
S#define __HAL_RCC_PLLSAI_DISABLE_IT() (RCC->CIR &= ~(RCC_CIR_PLLSAIRDYIE))
S
S/** @brief Clear the PLLSAI RDY interrupt pending bits.
S  */
S#define __HAL_RCC_PLLSAI_CLEAR_IT() (RCC->CIR |= (RCC_CIR_PLLSAIRDYF))
S
S/** @brief Check the PLLSAI RDY interrupt has occurred or not.
S  * @retval The new state (TRUE or FALSE).
S  */
S#define __HAL_RCC_PLLSAI_GET_IT() ((RCC->CIR & (RCC_CIR_PLLSAIRDYIE)) == (RCC_CIR_PLLSAIRDYIE))
S
S/** @brief  Check PLLSAI RDY flag is set or not.
S  * @retval The new state (TRUE or FALSE).
S  */
S#define __HAL_RCC_PLLSAI_GET_FLAG() ((RCC->CR & (RCC_CR_PLLSAIRDY)) == (RCC_CR_PLLSAIRDY))
S
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** @brief  Macros to enable or disable the RCC MCO1 feature.
S  */
S#define __HAL_RCC_MCO1_ENABLE() (*(__IO uint32_t *) RCC_CFGR_MCO1EN_BB = ENABLE)
S#define __HAL_RCC_MCO1_DISABLE() (*(__IO uint32_t *) RCC_CFGR_MCO1EN_BB = DISABLE)
S
S/** @brief  Macros to enable or disable the RCC MCO2 feature.
S  */
S#define __HAL_RCC_MCO2_ENABLE() (*(__IO uint32_t *) RCC_CFGR_MCO2EN_BB = ENABLE)
S#define __HAL_RCC_MCO2_DISABLE() (*(__IO uint32_t *) RCC_CFGR_MCO2EN_BB = DISABLE)
S
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup RCCEx_Exported_Functions
N  *  @{
N  */
N
N/** @addtogroup RCCEx_Exported_Functions_Group1
N  *  @{
N  */
NHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
Nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
N
Nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk);
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
Svoid HAL_RCCEx_SelectLSEMode(uint8_t Mode);
N#endif /* STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N#if defined(RCC_PLLI2S_SUPPORT)
X#if 1L
NHAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef  *PLLI2SInit);
NHAL_StatusTypeDef HAL_RCCEx_DisablePLLI2S(void);
N#endif /* RCC_PLLI2S_SUPPORT */
N#if defined(RCC_PLLSAI_SUPPORT)
X#if 0L
SHAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI(RCC_PLLSAIInitTypeDef  *PLLSAIInit);
SHAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI(void);
N#endif /* RCC_PLLSAI_SUPPORT */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RCCEx_Private_Constants RCCEx Private Constants
N  * @{
N  */
N
N/** @defgroup RCCEx_BitAddress_AliasRegion RCC BitAddress AliasRegion
N  * @brief RCC registers bit address in the alias region
N  * @{
N  */
N/* --- CR Register ---*/  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L
S/* Alias word address of PLLSAION bit */
S#define RCC_PLLSAION_BIT_NUMBER       0x1CU
S#define RCC_CR_PLLSAION_BB            (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_PLLSAION_BIT_NUMBER * 4U))
S
S#define PLLSAI_TIMEOUT_VALUE          2U  /* Timeout value fixed to 2 ms  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 1L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
N/* Alias word address of PLLI2SON bit */
N#define RCC_PLLI2SON_BIT_NUMBER    0x1AU
N#define RCC_CR_PLLI2SON_BB         (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_PLLI2SON_BIT_NUMBER * 4U))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx ||
N          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N
N/* --- DCKCFGR Register ---*/
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F401xC) ||\
N    defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
S/* Alias word address of TIMPRE bit */
S#define RCC_DCKCFGR_OFFSET            (RCC_OFFSET + 0x8CU)
S#define RCC_TIMPRE_BIT_NUMBER          0x18U
S#define RCC_DCKCFGR_TIMPRE_BB         (PERIPH_BB_BASE + (RCC_DCKCFGR_OFFSET * 32U) + (RCC_TIMPRE_BIT_NUMBER * 4U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F410xx || STM32F401xC ||\
N          STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N/* --- CFGR Register ---*/
N#define RCC_CFGR_OFFSET            (RCC_OFFSET + 0x08U)
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 1L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L
N/* Alias word address of I2SSRC bit */
N#define RCC_I2SSRC_BIT_NUMBER      0x17U
N#define RCC_CFGR_I2SSRC_BB         (PERIPH_BB_BASE + (RCC_CFGR_OFFSET * 32U) + (RCC_I2SSRC_BIT_NUMBER * 4U))
N      
N#define PLLI2S_TIMEOUT_VALUE       2U  /* Timeout value fixed to 2 ms  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx */
N      
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S/* --- PLLI2SCFGR Register ---*/
S#define RCC_PLLI2SCFGR_OFFSET         (RCC_OFFSET + 0x84U)
S/* Alias word address of PLLI2SSRC bit */
S#define RCC_PLLI2SSRC_BIT_NUMBER      0x16U
S#define RCC_PLLI2SCFGR_PLLI2SSRC_BB         (PERIPH_BB_BASE + (RCC_PLLI2SCFGR_OFFSET * 32U) + (RCC_PLLI2SSRC_BIT_NUMBER * 4U))
S      
S#define PLLI2S_TIMEOUT_VALUE          2U  /* Timeout value fixed to 2 ms */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx | STM32F423xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/* Alias word address of MCO1EN bit */
S#define RCC_MCO1EN_BIT_NUMBER      0x8U
S#define RCC_CFGR_MCO1EN_BB         (PERIPH_BB_BASE + (RCC_CFGR_OFFSET * 32U) + (RCC_MCO1EN_BIT_NUMBER * 4U))
S
S/* Alias word address of MCO2EN bit */
S#define RCC_MCO2EN_BIT_NUMBER      0x9U
S#define RCC_CFGR_MCO2EN_BB         (PERIPH_BB_BASE + (RCC_CFGR_OFFSET * 32U) + (RCC_MCO2EN_BIT_NUMBER * 4U))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#define PLL_TIMEOUT_VALUE          2U  /* 2 ms */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RCCEx_Private_Macros RCCEx Private Macros
N  * @{
N  */
N/** @defgroup RCCEx_IS_RCC_Definitions RCC Private macros to check input parameters
N  * @{
N  */
N#define IS_RCC_PLLN_VALUE(VALUE) ((50U <= (VALUE)) && ((VALUE) <= 432U))
N#define IS_RCC_PLLI2SN_VALUE(VALUE) ((50U <= (VALUE)) && ((VALUE) <= 432U))
N      
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx)
X#if 0L || 0L || 0L|| 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x0000007FU))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx) 
X#if 0L || 0L || 1L|| 0L 
N#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x00000007U))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) 
X#if 0L || 0L || 0L 
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x0000000FU))
N#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x0000001FU))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F446xx)
X#if 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x00000FFFU))
N#endif /* STM32F446xx */
N
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x000001FFU))
N#endif /* STM32F469xx || STM32F479xx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)
X#if 0L || 0L || 0L || 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x000003FFU))
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N      
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x00007FFFU))
N#endif /* STM32F413xx || STM32F423xx */
N      
N#define IS_RCC_PLLI2SR_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 7U))
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L || 0L
S#define IS_RCC_PLLI2SQ_VALUE(VALUE)     ((2U <= (VALUE)) && ((VALUE) <= 15U))
S
S#define IS_RCC_PLLSAIN_VALUE(VALUE)     ((50U <= (VALUE)) && ((VALUE) <= 432U))
S
S#define IS_RCC_PLLSAIQ_VALUE(VALUE)     ((2U <= (VALUE)) && ((VALUE) <= 15U))
S
S#define IS_RCC_PLLSAIR_VALUE(VALUE)     ((2U <= (VALUE)) && ((VALUE) <= 7U))
S
S#define IS_RCC_PLLSAI_DIVQ_VALUE(VALUE) ((1U <= (VALUE)) && ((VALUE) <= 32U))
S
S#define IS_RCC_PLLI2S_DIVQ_VALUE(VALUE) ((1U <= (VALUE)) && ((VALUE) <= 32U))
S
S#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDIVR_2)  ||\
S                                         ((VALUE) == RCC_PLLSAIDIVR_4)  ||\
S                                         ((VALUE) == RCC_PLLSAIDIVR_8)  ||\
S                                         ((VALUE) == RCC_PLLSAIDIVR_16))
X#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDIVR_2)  ||                                         ((VALUE) == RCC_PLLSAIDIVR_4)  ||                                         ((VALUE) == RCC_PLLSAIDIVR_8)  ||                                         ((VALUE) == RCC_PLLSAIDIVR_16))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
S#define IS_RCC_PLLI2SM_VALUE(VALUE)   ((2U <= (VALUE)) && ((VALUE) <= 63U))
S 
S#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) ||\
S                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
X#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) ||                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
N#endif /* STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx  */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_RCC_PLLR_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 7U))
S
S#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) ||\
S                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
X#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) ||                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
S
S#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
X#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
S
S#define IS_RCC_LPTIM1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK1) ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI) ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI) ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
X#define IS_RCC_LPTIM1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK1) ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI) ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI) ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
S
S#define IS_RCC_I2SAPBCLKSOURCE(SOURCE)      (((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLR)    ||\
S                                             ((SOURCE) == RCC_I2SAPBCLKSOURCE_EXT)    ||\
S                                             ((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLSRC))
X#define IS_RCC_I2SAPBCLKSOURCE(SOURCE)      (((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLR)    ||                                             ((SOURCE) == RCC_I2SAPBCLKSOURCE_EXT)    ||                                             ((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLSRC))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F446xx)
X#if 0L
S#define IS_RCC_PLLR_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 7U))
S  
S#define IS_RCC_PLLI2SP_VALUE(VALUE)       (((VALUE) == RCC_PLLI2SP_DIV2) ||\
S                                           ((VALUE) == RCC_PLLI2SP_DIV4) ||\
S                                           ((VALUE) == RCC_PLLI2SP_DIV6) ||\
S                                           ((VALUE) == RCC_PLLI2SP_DIV8))
X#define IS_RCC_PLLI2SP_VALUE(VALUE)       (((VALUE) == RCC_PLLI2SP_DIV2) ||                                           ((VALUE) == RCC_PLLI2SP_DIV4) ||                                           ((VALUE) == RCC_PLLI2SP_DIV6) ||                                           ((VALUE) == RCC_PLLI2SP_DIV8))
S
S#define IS_RCC_PLLSAIM_VALUE(VALUE)       ((VALUE) <= 63U)
S  
S#define IS_RCC_PLLSAIP_VALUE(VALUE)       (((VALUE) == RCC_PLLSAIP_DIV2) ||\
S                                           ((VALUE) == RCC_PLLSAIP_DIV4) ||\
S                                           ((VALUE) == RCC_PLLSAIP_DIV6) ||\
S                                           ((VALUE) == RCC_PLLSAIP_DIV8))
X#define IS_RCC_PLLSAIP_VALUE(VALUE)       (((VALUE) == RCC_PLLSAIP_DIV2) ||                                           ((VALUE) == RCC_PLLSAIP_DIV4) ||                                           ((VALUE) == RCC_PLLSAIP_DIV6) ||                                           ((VALUE) == RCC_PLLSAIP_DIV8))
S
S#define IS_RCC_SAI1CLKSOURCE(SOURCE)      (((SOURCE) == RCC_SAI1CLKSOURCE_PLLSAI) ||\
S                                           ((SOURCE) == RCC_SAI1CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_SAI1CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_SAI1CLKSOURCE_EXT))
X#define IS_RCC_SAI1CLKSOURCE(SOURCE)      (((SOURCE) == RCC_SAI1CLKSOURCE_PLLSAI) ||                                           ((SOURCE) == RCC_SAI1CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_SAI1CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_SAI1CLKSOURCE_EXT))
S
S#define IS_RCC_SAI2CLKSOURCE(SOURCE)      (((SOURCE) == RCC_SAI2CLKSOURCE_PLLSAI) ||\
S                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLSRC))
X#define IS_RCC_SAI2CLKSOURCE(SOURCE)      (((SOURCE) == RCC_SAI2CLKSOURCE_PLLSAI) ||                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLSRC))
S 
S#define IS_RCC_I2SAPB1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_EXT)    ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLSRC))
X#define IS_RCC_I2SAPB1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_EXT)    ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLSRC))
S                                              
S #define IS_RCC_I2SAPB2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_EXT)    ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLSRC))
X #define IS_RCC_I2SAPB2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_EXT)    ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLSRC))
S
S#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
X#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
S
S#define IS_RCC_CECCLKSOURCE(SOURCE)       (((SOURCE) == RCC_CECCLKSOURCE_HSI)   ||\
S                                           ((SOURCE) == RCC_CECCLKSOURCE_LSE))
X#define IS_RCC_CECCLKSOURCE(SOURCE)       (((SOURCE) == RCC_CECCLKSOURCE_HSI)   ||                                           ((SOURCE) == RCC_CECCLKSOURCE_LSE))
S
S#define IS_RCC_CLK48CLKSOURCE(SOURCE)      (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||\
S                                            ((SOURCE) == RCC_CLK48CLKSOURCE_PLLSAIP))
X#define IS_RCC_CLK48CLKSOURCE(SOURCE)      (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||                                            ((SOURCE) == RCC_CLK48CLKSOURCE_PLLSAIP))
S
S#define IS_RCC_SDIOCLKSOURCE(SOURCE)      (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||\
S                                           ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
X#define IS_RCC_SDIOCLKSOURCE(SOURCE)      (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||                                           ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
S
S#define IS_RCC_SPDIFRXCLKSOURCE(SOURCE)   (((SOURCE) == RCC_SPDIFRXCLKSOURCE_PLLR) ||\
S                                           ((SOURCE) == RCC_SPDIFRXCLKSOURCE_PLLI2SP))  
X#define IS_RCC_SPDIFRXCLKSOURCE(SOURCE)   (((SOURCE) == RCC_SPDIFRXCLKSOURCE_PLLR) ||                                           ((SOURCE) == RCC_SPDIFRXCLKSOURCE_PLLI2SP))  
N#endif /* STM32F446xx */
N
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S#define IS_RCC_PLLR_VALUE(VALUE)            ((2U <= (VALUE)) && ((VALUE) <= 7U))
S
S#define IS_RCC_PLLSAIP_VALUE(VALUE)         (((VALUE) == RCC_PLLSAIP_DIV2) ||\
S                                             ((VALUE) == RCC_PLLSAIP_DIV4) ||\
S                                             ((VALUE) == RCC_PLLSAIP_DIV6) ||\
S                                             ((VALUE) == RCC_PLLSAIP_DIV8))
X#define IS_RCC_PLLSAIP_VALUE(VALUE)         (((VALUE) == RCC_PLLSAIP_DIV2) ||                                             ((VALUE) == RCC_PLLSAIP_DIV4) ||                                             ((VALUE) == RCC_PLLSAIP_DIV6) ||                                             ((VALUE) == RCC_PLLSAIP_DIV8))
S 
S#define IS_RCC_CLK48CLKSOURCE(SOURCE)        (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||\
S                                              ((SOURCE) == RCC_CLK48CLKSOURCE_PLLSAIP))
X#define IS_RCC_CLK48CLKSOURCE(SOURCE)        (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||                                              ((SOURCE) == RCC_CLK48CLKSOURCE_PLLSAIP))
S
S#define IS_RCC_SDIOCLKSOURCE(SOURCE)        (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||\
S                                             ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
X#define IS_RCC_SDIOCLKSOURCE(SOURCE)        (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||                                             ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
S
S#define IS_RCC_DSIBYTELANECLKSOURCE(SOURCE) (((SOURCE) == RCC_DSICLKSOURCE_PLLR)  ||\
S                                             ((SOURCE) == RCC_DSICLKSOURCE_DSIPHY))
X#define IS_RCC_DSIBYTELANECLKSOURCE(SOURCE) (((SOURCE) == RCC_DSICLKSOURCE_PLLR)  ||                                             ((SOURCE) == RCC_DSICLKSOURCE_DSIPHY))
S
S#define IS_RCC_LSE_MODE(MODE)               (((MODE) == RCC_LSE_LOWPOWER_MODE) ||\
S                                             ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
X#define IS_RCC_LSE_MODE(MODE)               (((MODE) == RCC_LSE_LOWPOWER_MODE) ||                                             ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
N#endif /* STM32F469xx || STM32F479xx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define IS_RCC_PLLI2SQ_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 15U))
S    
S#define IS_RCC_PLLR_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 7U))
S
S#define IS_RCC_PLLI2SCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_PLLI2SCLKSOURCE_PLLSRC) || \
S                                            ((__SOURCE__) == RCC_PLLI2SCLKSOURCE_EXT))
X#define IS_RCC_PLLI2SCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_PLLI2SCLKSOURCE_PLLSRC) ||                                             ((__SOURCE__) == RCC_PLLI2SCLKSOURCE_EXT))
S 
S#define IS_RCC_I2SAPB1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_EXT)    ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLSRC))
X#define IS_RCC_I2SAPB1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_EXT)    ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLSRC))
S                                              
S #define IS_RCC_I2SAPB2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_EXT)    ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLSRC))
X #define IS_RCC_I2SAPB2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_EXT)    ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLSRC))
S
S#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
X#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
S
S#define IS_RCC_CLK48CLKSOURCE(SOURCE)      (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||\
S                                            ((SOURCE) == RCC_CLK48CLKSOURCE_PLLI2SQ))
X#define IS_RCC_CLK48CLKSOURCE(SOURCE)      (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||                                            ((SOURCE) == RCC_CLK48CLKSOURCE_PLLI2SQ))
S
S#define IS_RCC_SDIOCLKSOURCE(SOURCE)      (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||\
S                                           ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
X#define IS_RCC_SDIOCLKSOURCE(SOURCE)      (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||                                           ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
S
S#define IS_RCC_DFSDM1CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM1CLKSOURCE_PCLK2) || \
S                                            ((__SOURCE__) == RCC_DFSDM1CLKSOURCE_SYSCLK))
X#define IS_RCC_DFSDM1CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM1CLKSOURCE_PCLK2) ||                                             ((__SOURCE__) == RCC_DFSDM1CLKSOURCE_SYSCLK))
S
S#define IS_RCC_DFSDM1AUDIOCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM1AUDIOCLKSOURCE_I2S1) || \
S                                                 ((__SOURCE__) == RCC_DFSDM1AUDIOCLKSOURCE_I2S2))
X#define IS_RCC_DFSDM1AUDIOCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM1AUDIOCLKSOURCE_I2S1) ||                                                  ((__SOURCE__) == RCC_DFSDM1AUDIOCLKSOURCE_I2S2))
S
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define IS_RCC_DFSDM2CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM2CLKSOURCE_PCLK2) || \
S                                            ((__SOURCE__) == RCC_DFSDM2CLKSOURCE_SYSCLK))
X#define IS_RCC_DFSDM2CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM2CLKSOURCE_PCLK2) ||                                             ((__SOURCE__) == RCC_DFSDM2CLKSOURCE_SYSCLK))
S
S#define IS_RCC_DFSDM2AUDIOCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM2AUDIOCLKSOURCE_I2S1) || \
S                                                 ((__SOURCE__) == RCC_DFSDM2AUDIOCLKSOURCE_I2S2))
X#define IS_RCC_DFSDM2AUDIOCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM2AUDIOCLKSOURCE_I2S1) ||                                                  ((__SOURCE__) == RCC_DFSDM2AUDIOCLKSOURCE_I2S2))
S
S#define IS_RCC_LPTIM1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK1) ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI)  ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI)  ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
X#define IS_RCC_LPTIM1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK1) ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI)  ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI)  ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
S
S#define IS_RCC_SAIACLKSOURCE(SOURCE)     (((SOURCE) == RCC_SAIACLKSOURCE_PLLI2SR) ||\
S                                          ((SOURCE) == RCC_SAIACLKSOURCE_EXT)     ||\
S                                          ((SOURCE) == RCC_SAIACLKSOURCE_PLLR)    ||\
S                                          ((SOURCE) == RCC_SAIACLKSOURCE_PLLSRC))
X#define IS_RCC_SAIACLKSOURCE(SOURCE)     (((SOURCE) == RCC_SAIACLKSOURCE_PLLI2SR) ||                                          ((SOURCE) == RCC_SAIACLKSOURCE_EXT)     ||                                          ((SOURCE) == RCC_SAIACLKSOURCE_PLLR)    ||                                          ((SOURCE) == RCC_SAIACLKSOURCE_PLLSRC))
S
S#define IS_RCC_SAIBCLKSOURCE(SOURCE)     (((SOURCE) == RCC_SAIBCLKSOURCE_PLLI2SR) ||\
S                                          ((SOURCE) == RCC_SAIBCLKSOURCE_EXT)     ||\
S                                          ((SOURCE) == RCC_SAIBCLKSOURCE_PLLR)    ||\
S                                          ((SOURCE) == RCC_SAIBCLKSOURCE_PLLSRC))
X#define IS_RCC_SAIBCLKSOURCE(SOURCE)     (((SOURCE) == RCC_SAIBCLKSOURCE_PLLI2SR) ||                                          ((SOURCE) == RCC_SAIBCLKSOURCE_EXT)     ||                                          ((SOURCE) == RCC_SAIBCLKSOURCE_PLLR)    ||                                          ((SOURCE) == RCC_SAIBCLKSOURCE_PLLSRC))
S
S#define IS_RCC_PLL_DIVR_VALUE(VALUE) ((1U <= (VALUE)) && ((VALUE) <= 32U))
S
S#define IS_RCC_PLLI2S_DIVR_VALUE(VALUE) ((1U <= (VALUE)) && ((VALUE) <= 32U))
S
S#endif /* STM32F413xx || STM32F423xx */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 1L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L
N      
N#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_PLLI2SCLK)|| \
N                                   ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
X#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_PLLI2SCLK)||                                    ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
N
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || \
N          STM32F412Rx */
X#endif  
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)      
X#if 0L || 0L || 0L      
S#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_I2SCLK)|| \
S                                   ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
X#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_I2SCLK)||                                    ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_RCC_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 34 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rcc.h" 2
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RCC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup RCC_Exported_Types RCC Exported Types
N  * @{
N  */
N
N/**
N  * @brief  RCC Internal/External Oscillator (HSE, HSI, LSE and LSI) configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t OscillatorType;       /*!< The oscillators to be configured.
N                                      This parameter can be a value of @ref RCC_Oscillator_Type                   */
N
N  uint32_t HSEState;             /*!< The new state of the HSE.
N                                      This parameter can be a value of @ref RCC_HSE_Config                        */
N
N  uint32_t LSEState;             /*!< The new state of the LSE.
N                                      This parameter can be a value of @ref RCC_LSE_Config                        */
N
N  uint32_t HSIState;             /*!< The new state of the HSI.
N                                      This parameter can be a value of @ref RCC_HSI_Config                        */
N
N  uint32_t HSICalibrationValue;  /*!< The HSI calibration trimming value (default is RCC_HSICALIBRATION_DEFAULT).
N                                       This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x1F */
N
N  uint32_t LSIState;             /*!< The new state of the LSI.
N                                      This parameter can be a value of @ref RCC_LSI_Config                        */
N
N  RCC_PLLInitTypeDef PLL;        /*!< PLL structure parameters                                                    */
N}RCC_OscInitTypeDef;
N
N/**
N  * @brief  RCC System, AHB and APB busses clock configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t ClockType;             /*!< The clock to be configured.
N                                       This parameter can be a value of @ref RCC_System_Clock_Type      */
N
N  uint32_t SYSCLKSource;          /*!< The clock source (SYSCLKS) used as system clock.
N                                       This parameter can be a value of @ref RCC_System_Clock_Source    */
N
N  uint32_t AHBCLKDivider;         /*!< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).
N                                       This parameter can be a value of @ref RCC_AHB_Clock_Source       */
N
N  uint32_t APB1CLKDivider;        /*!< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source */
N
N  uint32_t APB2CLKDivider;        /*!< The APB2 clock (PCLK2) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source */
N
N}RCC_ClkInitTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RCC_Exported_Constants RCC Exported Constants
N  * @{
N  */
N
N/** @defgroup RCC_Oscillator_Type Oscillator Type
N  * @{
N  */
N#define RCC_OSCILLATORTYPE_NONE            0x00000000U
N#define RCC_OSCILLATORTYPE_HSE             0x00000001U
N#define RCC_OSCILLATORTYPE_HSI             0x00000002U
N#define RCC_OSCILLATORTYPE_LSE             0x00000004U
N#define RCC_OSCILLATORTYPE_LSI             0x00000008U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSE_Config HSE Config
N  * @{
N  */
N#define RCC_HSE_OFF                      0x00000000U
N#define RCC_HSE_ON                       RCC_CR_HSEON
N#define RCC_HSE_BYPASS                   ((uint32_t)(RCC_CR_HSEBYP | RCC_CR_HSEON))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Config LSE Config
N  * @{
N  */
N#define RCC_LSE_OFF                    0x00000000U
N#define RCC_LSE_ON                     RCC_BDCR_LSEON
N#define RCC_LSE_BYPASS                 ((uint32_t)(RCC_BDCR_LSEBYP | RCC_BDCR_LSEON))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSI_Config HSI Config
N  * @{
N  */
N#define RCC_HSI_OFF                      ((uint8_t)0x00)
N#define RCC_HSI_ON                       ((uint8_t)0x01)
N
N#define RCC_HSICALIBRATION_DEFAULT       0x10U         /* Default HSI calibration trimming value */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSI_Config LSI Config
N  * @{
N  */
N#define RCC_LSI_OFF                      ((uint8_t)0x00)
N#define RCC_LSI_ON                       ((uint8_t)0x01)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Config PLL Config
N  * @{
N  */
N#define RCC_PLL_NONE                      ((uint8_t)0x00)
N#define RCC_PLL_OFF                       ((uint8_t)0x01)
N#define RCC_PLL_ON                        ((uint8_t)0x02)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLLP_Clock_Divider PLLP Clock Divider
N  * @{
N  */
N#define RCC_PLLP_DIV2                  0x00000002U
N#define RCC_PLLP_DIV4                  0x00000004U
N#define RCC_PLLP_DIV6                  0x00000006U
N#define RCC_PLLP_DIV8                  0x00000008U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Clock_Source PLL Clock Source
N  * @{
N  */
N#define RCC_PLLSOURCE_HSI                RCC_PLLCFGR_PLLSRC_HSI
N#define RCC_PLLSOURCE_HSE                RCC_PLLCFGR_PLLSRC_HSE
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Type System Clock Type
N  * @{
N  */
N#define RCC_CLOCKTYPE_SYSCLK             0x00000001U
N#define RCC_CLOCKTYPE_HCLK               0x00000002U
N#define RCC_CLOCKTYPE_PCLK1              0x00000004U
N#define RCC_CLOCKTYPE_PCLK2              0x00000008U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Source System Clock Source
N  * @note     The RCC_SYSCLKSOURCE_PLLRCLK parameter is available only for
N  *           STM32F446xx devices.
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_HSI             RCC_CFGR_SW_HSI
N#define RCC_SYSCLKSOURCE_HSE             RCC_CFGR_SW_HSE
N#define RCC_SYSCLKSOURCE_PLLCLK          RCC_CFGR_SW_PLL
N#define RCC_SYSCLKSOURCE_PLLRCLK         ((uint32_t)(RCC_CFGR_SW_0 | RCC_CFGR_SW_1))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Source_Status System Clock Source Status
N  * @note     The RCC_SYSCLKSOURCE_STATUS_PLLRCLK parameter is available only for
N  *           STM32F446xx devices.
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_STATUS_HSI     RCC_CFGR_SWS_HSI   /*!< HSI used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_HSE     RCC_CFGR_SWS_HSE   /*!< HSE used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_PLLCLK  RCC_CFGR_SWS_PLL   /*!< PLL used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_PLLRCLK ((uint32_t)(RCC_CFGR_SWS_0 | RCC_CFGR_SWS_1))   /*!< PLLR used as system clock */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Clock_Source AHB Clock Source
N  * @{
N  */
N#define RCC_SYSCLK_DIV1                  RCC_CFGR_HPRE_DIV1
N#define RCC_SYSCLK_DIV2                  RCC_CFGR_HPRE_DIV2
N#define RCC_SYSCLK_DIV4                  RCC_CFGR_HPRE_DIV4
N#define RCC_SYSCLK_DIV8                  RCC_CFGR_HPRE_DIV8
N#define RCC_SYSCLK_DIV16                 RCC_CFGR_HPRE_DIV16
N#define RCC_SYSCLK_DIV64                 RCC_CFGR_HPRE_DIV64
N#define RCC_SYSCLK_DIV128                RCC_CFGR_HPRE_DIV128
N#define RCC_SYSCLK_DIV256                RCC_CFGR_HPRE_DIV256
N#define RCC_SYSCLK_DIV512                RCC_CFGR_HPRE_DIV512
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_APB2_Clock_Source APB1/APB2 Clock Source
N  * @{
N  */
N#define RCC_HCLK_DIV1                    RCC_CFGR_PPRE1_DIV1
N#define RCC_HCLK_DIV2                    RCC_CFGR_PPRE1_DIV2
N#define RCC_HCLK_DIV4                    RCC_CFGR_PPRE1_DIV4
N#define RCC_HCLK_DIV8                    RCC_CFGR_PPRE1_DIV8
N#define RCC_HCLK_DIV16                   RCC_CFGR_PPRE1_DIV16
N/**
N  * @}
N  */
N
N/** @defgroup RCC_RTC_Clock_Source RTC Clock Source
N  * @{
N  */
N#define RCC_RTCCLKSOURCE_NO_CLK          0x00000000U
N#define RCC_RTCCLKSOURCE_LSE             0x00000100U
N#define RCC_RTCCLKSOURCE_LSI             0x00000200U
N#define RCC_RTCCLKSOURCE_HSE_DIVX        0x00000300U
N#define RCC_RTCCLKSOURCE_HSE_DIV2        0x00020300U
N#define RCC_RTCCLKSOURCE_HSE_DIV3        0x00030300U
N#define RCC_RTCCLKSOURCE_HSE_DIV4        0x00040300U
N#define RCC_RTCCLKSOURCE_HSE_DIV5        0x00050300U
N#define RCC_RTCCLKSOURCE_HSE_DIV6        0x00060300U
N#define RCC_RTCCLKSOURCE_HSE_DIV7        0x00070300U
N#define RCC_RTCCLKSOURCE_HSE_DIV8        0x00080300U
N#define RCC_RTCCLKSOURCE_HSE_DIV9        0x00090300U
N#define RCC_RTCCLKSOURCE_HSE_DIV10       0x000A0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV11       0x000B0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV12       0x000C0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV13       0x000D0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV14       0x000E0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV15       0x000F0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV16       0x00100300U
N#define RCC_RTCCLKSOURCE_HSE_DIV17       0x00110300U
N#define RCC_RTCCLKSOURCE_HSE_DIV18       0x00120300U
N#define RCC_RTCCLKSOURCE_HSE_DIV19       0x00130300U
N#define RCC_RTCCLKSOURCE_HSE_DIV20       0x00140300U
N#define RCC_RTCCLKSOURCE_HSE_DIV21       0x00150300U
N#define RCC_RTCCLKSOURCE_HSE_DIV22       0x00160300U
N#define RCC_RTCCLKSOURCE_HSE_DIV23       0x00170300U
N#define RCC_RTCCLKSOURCE_HSE_DIV24       0x00180300U
N#define RCC_RTCCLKSOURCE_HSE_DIV25       0x00190300U
N#define RCC_RTCCLKSOURCE_HSE_DIV26       0x001A0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV27       0x001B0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV28       0x001C0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV29       0x001D0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV30       0x001E0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV31       0x001F0300U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO_Index MCO Index
N  * @{
N  */
N#define RCC_MCO1                         0x00000000U
N#define RCC_MCO2                         0x00000001U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO1_Clock_Source MCO1 Clock Source
N  * @{
N  */
N#define RCC_MCO1SOURCE_HSI               0x00000000U
N#define RCC_MCO1SOURCE_LSE               RCC_CFGR_MCO1_0
N#define RCC_MCO1SOURCE_HSE               RCC_CFGR_MCO1_1
N#define RCC_MCO1SOURCE_PLLCLK            RCC_CFGR_MCO1
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCOx_Clock_Prescaler MCOx Clock Prescaler
N  * @{
N  */
N#define RCC_MCODIV_1                    0x00000000U
N#define RCC_MCODIV_2                    RCC_CFGR_MCO1PRE_2
N#define RCC_MCODIV_3                    ((uint32_t)RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_2)
N#define RCC_MCODIV_4                    ((uint32_t)RCC_CFGR_MCO1PRE_1 | RCC_CFGR_MCO1PRE_2)
N#define RCC_MCODIV_5                    RCC_CFGR_MCO1PRE
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Interrupt Interrupts
N  * @{
N  */
N#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
N#define RCC_IT_LSERDY                    ((uint8_t)0x02)
N#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
N#define RCC_IT_HSERDY                    ((uint8_t)0x08)
N#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
N#define RCC_IT_PLLI2SRDY                 ((uint8_t)0x20)
N#define RCC_IT_CSS                       ((uint8_t)0x80)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Flag Flags
N  *        Elements values convention: 0XXYYYYYb
N  *           - YYYYY  : Flag position in the register
N  *           - 0XX  : Register index
N  *                 - 01: CR register
N  *                 - 10: BDCR register
N  *                 - 11: CSR register
N  * @{
N  */
N/* Flags in the CR register */
N#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
N#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
N#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
N#define RCC_FLAG_PLLI2SRDY               ((uint8_t)0x3B)
N
N/* Flags in the BDCR register */
N#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
N
N/* Flags in the CSR register */
N#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
N#define RCC_FLAG_BORRST                  ((uint8_t)0x79)
N#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
N#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
N#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
N#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
N#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
N#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RCC_Exported_Macros RCC Exported Macros
N  * @{
N  */
N
N/** @defgroup RCC_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_GPIOA_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_GPIOA_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_GPIOB_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_GPIOB_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_GPIOC_CLK_ENABLE()  do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_GPIOC_CLK_ENABLE()  do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_GPIOH_CLK_ENABLE()  do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);\
N                                        UNUSED(tmpreg); \
N                                         } while(0U)
X#define __HAL_RCC_GPIOH_CLK_ENABLE()  do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);                                        UNUSED(tmpreg);                                          } while(0U)
N#define __HAL_RCC_DMA1_CLK_ENABLE()  do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);\
N                                        UNUSED(tmpreg); \
N                                         } while(0U)
X#define __HAL_RCC_DMA1_CLK_ENABLE()  do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);                                        UNUSED(tmpreg);                                          } while(0U)
N#define __HAL_RCC_DMA2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_DMA2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);                                        UNUSED(tmpreg);                                           } while(0U)
N
N#define __HAL_RCC_GPIOA_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOAEN))
N#define __HAL_RCC_GPIOB_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOBEN))
N#define __HAL_RCC_GPIOC_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOCEN))
N#define __HAL_RCC_GPIOH_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOHEN))
N#define __HAL_RCC_DMA1_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA1EN))
N#define __HAL_RCC_DMA2_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA2EN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_GPIOA_IS_CLK_ENABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOAEN)) != RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_ENABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOBEN)) != RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_ENABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOCEN)) != RESET)
N#define __HAL_RCC_GPIOH_IS_CLK_ENABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOHEN)) != RESET)
N#define __HAL_RCC_DMA1_IS_CLK_ENABLED()         ((RCC->AHB1ENR &(RCC_AHB1ENR_DMA1EN)) != RESET)
N#define __HAL_RCC_DMA2_IS_CLK_ENABLED()         ((RCC->AHB1ENR &(RCC_AHB1ENR_DMA2EN)) != RESET)
N
N#define __HAL_RCC_GPIOA_IS_CLK_DISABLED()       ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOAEN)) == RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_DISABLED()       ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOBEN)) == RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_DISABLED()       ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOCEN)) == RESET)
N#define __HAL_RCC_GPIOH_IS_CLK_DISABLED()       ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOHEN)) == RESET)
N#define __HAL_RCC_DMA1_IS_CLK_DISABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_DMA1EN)) == RESET)
N#define __HAL_RCC_DMA2_IS_CLK_DISABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_DMA2EN)) == RESET)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM5_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_TIM5_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_WWDG_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_WWDG_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_SPI2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_SPI2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_USART2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_USART2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_I2C1_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_I2C1_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_I2C2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_I2C2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_PWR_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_PWR_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);                                        UNUSED(tmpreg);                                           } while(0U)
N
N#define __HAL_RCC_TIM5_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM5EN))
N#define __HAL_RCC_WWDG_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_WWDGEN))
N#define __HAL_RCC_SPI2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI2EN))
N#define __HAL_RCC_USART2_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART2EN))
N#define __HAL_RCC_I2C1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C1EN))
N#define __HAL_RCC_I2C2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C2EN))
N#define __HAL_RCC_PWR_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_PWREN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM5_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM5EN)) != RESET)
N#define __HAL_RCC_WWDG_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN)) != RESET)
N#define __HAL_RCC_SPI2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) != RESET)
N#define __HAL_RCC_USART2_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) != RESET)
N#define __HAL_RCC_I2C1_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN)) != RESET)
N#define __HAL_RCC_I2C2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) != RESET)
N#define __HAL_RCC_PWR_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_PWREN)) != RESET)
N
N#define __HAL_RCC_TIM5_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM5EN)) == RESET)
N#define __HAL_RCC_WWDG_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN)) == RESET)
N#define __HAL_RCC_SPI2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) == RESET)
N#define __HAL_RCC_USART2_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) == RESET)
N#define __HAL_RCC_I2C1_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN)) == RESET)
N#define __HAL_RCC_I2C2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) == RESET)
N#define __HAL_RCC_PWR_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_PWREN)) == RESET)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM1_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_TIM1_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_USART1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_USART1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_USART6_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_USART6_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_ADC1_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_ADC1_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_SPI1_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_SPI1_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_SYSCFG_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_SYSCFG_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_TIM9_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_TIM9_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_TIM11_CLK_ENABLE()    do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_TIM11_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);                                        UNUSED(tmpreg);                                           } while(0U)
N
N#define __HAL_RCC_TIM1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM1EN))
N#define __HAL_RCC_USART1_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_USART1EN))
N#define __HAL_RCC_USART6_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_USART6EN))
N#define __HAL_RCC_ADC1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC1EN))
N#define __HAL_RCC_SPI1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI1EN))
N#define __HAL_RCC_SYSCFG_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_SYSCFGEN))
N#define __HAL_RCC_TIM9_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM9EN))
N#define __HAL_RCC_TIM11_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM11EN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM1_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN)) != RESET)
N#define __HAL_RCC_USART1_IS_CLK_ENABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) != RESET)
N#define __HAL_RCC_USART6_IS_CLK_ENABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) != RESET)
N#define __HAL_RCC_ADC1_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN)) != RESET)
N#define __HAL_RCC_SPI1_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN)) != RESET)
N#define __HAL_RCC_SYSCFG_IS_CLK_ENABLED() ((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) != RESET)
N#define __HAL_RCC_TIM9_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM9EN)) != RESET)
N#define __HAL_RCC_TIM11_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM11EN)) != RESET)
N
N#define __HAL_RCC_TIM1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN)) == RESET)
N#define __HAL_RCC_USART1_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) == RESET)
N#define __HAL_RCC_USART6_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) == RESET)
N#define __HAL_RCC_ADC1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN)) == RESET)
N#define __HAL_RCC_SPI1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN)) == RESET)
N#define __HAL_RCC_SYSCFG_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) == RESET)
N#define __HAL_RCC_TIM9_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM9EN)) == RESET)
N#define __HAL_RCC_TIM11_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM11EN)) == RESET)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB1_Force_Release_Reset AHB1 Force Release Reset
N  * @brief  Force or release AHB1 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_AHB1_FORCE_RESET()    (RCC->AHB1RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_GPIOA_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOARST))
N#define __HAL_RCC_GPIOB_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOBRST))
N#define __HAL_RCC_GPIOC_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOCRST))
N#define __HAL_RCC_GPIOH_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOHRST))
N#define __HAL_RCC_DMA1_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA1RST))
N#define __HAL_RCC_DMA2_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA2RST))
N
N#define __HAL_RCC_AHB1_RELEASE_RESET()  (RCC->AHB1RSTR = 0x00U)
N#define __HAL_RCC_GPIOA_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOARST))
N#define __HAL_RCC_GPIOB_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOBRST))
N#define __HAL_RCC_GPIOC_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOCRST))
N#define __HAL_RCC_GPIOH_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOHRST))
N#define __HAL_RCC_DMA1_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA1RST))
N#define __HAL_RCC_DMA2_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA2RST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Force_Release_Reset APB1 Force Release Reset
N  * @brief  Force or release APB1 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_APB1_FORCE_RESET()     (RCC->APB1RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_TIM5_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM5RST))
N#define __HAL_RCC_WWDG_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_WWDGRST))
N#define __HAL_RCC_SPI2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI2RST))
N#define __HAL_RCC_USART2_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART2RST))
N#define __HAL_RCC_I2C1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C1RST))
N#define __HAL_RCC_I2C2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C2RST))
N#define __HAL_RCC_PWR_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_PWRRST))
N
N#define __HAL_RCC_APB1_RELEASE_RESET()   (RCC->APB1RSTR = 0x00U)
N#define __HAL_RCC_TIM5_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM5RST))
N#define __HAL_RCC_WWDG_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_WWDGRST))
N#define __HAL_RCC_SPI2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI2RST))
N#define __HAL_RCC_USART2_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART2RST))
N#define __HAL_RCC_I2C1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C1RST))
N#define __HAL_RCC_I2C2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C2RST))
N#define __HAL_RCC_PWR_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_PWRRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Force_Release_Reset APB2 Force Release Reset
N  * @brief  Force or release APB2 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_APB2_FORCE_RESET()     (RCC->APB2RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_TIM1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM1RST))
N#define __HAL_RCC_USART1_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_USART1RST))
N#define __HAL_RCC_USART6_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_USART6RST))
N#define __HAL_RCC_ADC_FORCE_RESET()      (RCC->APB2RSTR |= (RCC_APB2RSTR_ADCRST))
N#define __HAL_RCC_SPI1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI1RST))
N#define __HAL_RCC_SYSCFG_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SYSCFGRST))
N#define __HAL_RCC_TIM9_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM9RST))
N#define __HAL_RCC_TIM11_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM11RST))
N
N#define __HAL_RCC_APB2_RELEASE_RESET()   (RCC->APB2RSTR = 0x00U)
N#define __HAL_RCC_TIM1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM1RST))
N#define __HAL_RCC_USART1_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART1RST))
N#define __HAL_RCC_USART6_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART6RST))
N#define __HAL_RCC_ADC_RELEASE_RESET()    (RCC->APB2RSTR &= ~(RCC_APB2RSTR_ADCRST))
N#define __HAL_RCC_SPI1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI1RST))
N#define __HAL_RCC_SYSCFG_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SYSCFGRST))
N#define __HAL_RCC_TIM9_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM9RST))
N#define __HAL_RCC_TIM11_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM11RST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_GPIOA_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOALPEN))
N#define __HAL_RCC_GPIOB_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOBLPEN))
N#define __HAL_RCC_GPIOC_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOCLPEN))
N#define __HAL_RCC_GPIOH_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOHLPEN))
N#define __HAL_RCC_DMA1_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA1LPEN))
N#define __HAL_RCC_DMA2_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA2LPEN))
N
N#define __HAL_RCC_GPIOA_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOALPEN))
N#define __HAL_RCC_GPIOB_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOBLPEN))
N#define __HAL_RCC_GPIOC_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOCLPEN))
N#define __HAL_RCC_GPIOH_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOHLPEN))
N#define __HAL_RCC_DMA1_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA1LPEN))
N#define __HAL_RCC_DMA2_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA2LPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_TIM5_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM5LPEN))
N#define __HAL_RCC_WWDG_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_WWDGLPEN))
N#define __HAL_RCC_SPI2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI2LPEN))
N#define __HAL_RCC_USART2_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART2LPEN))
N#define __HAL_RCC_I2C1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C1LPEN))
N#define __HAL_RCC_I2C2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C2LPEN))
N#define __HAL_RCC_PWR_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_PWRLPEN))
N
N#define __HAL_RCC_TIM5_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM5LPEN))
N#define __HAL_RCC_WWDG_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_WWDGLPEN))
N#define __HAL_RCC_SPI2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI2LPEN))
N#define __HAL_RCC_USART2_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART2LPEN))
N#define __HAL_RCC_I2C1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C1LPEN))
N#define __HAL_RCC_I2C2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C2LPEN))
N#define __HAL_RCC_PWR_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_PWRLPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_TIM1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM1LPEN))
N#define __HAL_RCC_USART1_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_USART1LPEN))
N#define __HAL_RCC_USART6_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_USART6LPEN))
N#define __HAL_RCC_ADC1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC1LPEN))
N#define __HAL_RCC_SPI1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI1LPEN))
N#define __HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_SYSCFGLPEN))
N#define __HAL_RCC_TIM9_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM9LPEN))
N#define __HAL_RCC_TIM11_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM11LPEN))
N
N#define __HAL_RCC_TIM1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM1LPEN))
N#define __HAL_RCC_USART1_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_USART1LPEN))
N#define __HAL_RCC_USART6_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_USART6LPEN))
N#define __HAL_RCC_ADC1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC1LPEN))
N#define __HAL_RCC_SPI1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI1LPEN))
N#define __HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SYSCFGLPEN))
N#define __HAL_RCC_TIM9_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM9LPEN))
N#define __HAL_RCC_TIM11_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM11LPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSI_Configuration HSI Configuration
N  * @{
N  */
N
N/** @brief  Macros to enable or disable the Internal High Speed oscillator (HSI).
N  * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
N  *         It is used (enabled by hardware) as system clock source after startup
N  *         from Reset, wake-up from STOP and STANDBY mode, or in case of failure
N  *         of the HSE used directly or indirectly as system clock (if the Clock
N  *         Security System CSS is enabled).
N  * @note   HSI can not be stopped if it is used as system clock source. In this case,
N  *         you have to select another source of the system clock then stop the HSI.
N  * @note   After enabling the HSI, the application software should wait on HSIRDY
N  *         flag to be set indicating that HSI clock is stable and can be used as
N  *         system clock source.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
N  *         clock cycles.
N  */
N#define __HAL_RCC_HSI_ENABLE() (*(__IO uint32_t *) RCC_CR_HSION_BB = ENABLE)
N#define __HAL_RCC_HSI_DISABLE() (*(__IO uint32_t *) RCC_CR_HSION_BB = DISABLE)
N
N/** @brief  Macro to adjust the Internal High Speed oscillator (HSI) calibration value.
N  * @note   The calibration is used to compensate for the variations in voltage
N  *         and temperature that influence the frequency of the internal HSI RC.
N  * @param  __HSICalibrationValue__ specifies the calibration trimming value.
N  *         (default is RCC_HSICALIBRATION_DEFAULT).
N  *         This parameter must be a number between 0 and 0x1F.
N  */
N#define __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(__HSICalibrationValue__) (MODIFY_REG(RCC->CR,\
N        RCC_CR_HSITRIM, (uint32_t)(__HSICalibrationValue__) << RCC_CR_HSITRIM_Pos))
X#define __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(__HSICalibrationValue__) (MODIFY_REG(RCC->CR,        RCC_CR_HSITRIM, (uint32_t)(__HSICalibrationValue__) << RCC_CR_HSITRIM_Pos))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSI_Configuration LSI Configuration
N  * @{
N  */
N
N/** @brief  Macros to enable or disable the Internal Low Speed oscillator (LSI).
N  * @note   After enabling the LSI, the application software should wait on
N  *         LSIRDY flag to be set indicating that LSI clock is stable and can
N  *         be used to clock the IWDG and/or the RTC.
N  * @note   LSI can not be disabled if the IWDG is running.
N  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
N  *         clock cycles.
N  */
N#define __HAL_RCC_LSI_ENABLE() (*(__IO uint32_t *) RCC_CSR_LSION_BB = ENABLE)
N#define __HAL_RCC_LSI_DISABLE() (*(__IO uint32_t *) RCC_CSR_LSION_BB = DISABLE)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSE_Configuration HSE Configuration
N  * @{
N  */
N
N/**
N  * @brief  Macro to configure the External High Speed oscillator (HSE).
N  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not supported by this macro.
N  *         User should request a transition to HSE Off first and then HSE On or HSE Bypass.
N  * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
N  *         software should wait on HSERDY flag to be set indicating that HSE clock
N  *         is stable and can be used to clock the PLL and/or system clock.
N  * @note   HSE state can not be changed if it is used directly or through the
N  *         PLL as system clock. In this case, you have to select another source
N  *         of the system clock then change the HSE state (ex. disable it).
N  * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
N  * @note   This function reset the CSSON bit, so if the clock security system(CSS)
N  *         was previously enabled you have to enable it again after calling this
N  *         function.
N  * @param  __STATE__ specifies the new state of the HSE.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
N  *                              6 HSE oscillator clock cycles.
N  *            @arg RCC_HSE_ON: turn ON the HSE oscillator.
N  *            @arg RCC_HSE_BYPASS: HSE oscillator bypassed with external clock.
N  */
N#define __HAL_RCC_HSE_CONFIG(__STATE__)                         \
N                    do {                                        \
N                      if ((__STATE__) == RCC_HSE_ON)            \
N                      {                                         \
N                        SET_BIT(RCC->CR, RCC_CR_HSEON);         \
N                      }                                         \
N                      else if ((__STATE__) == RCC_HSE_BYPASS)   \
N                      {                                         \
N                        SET_BIT(RCC->CR, RCC_CR_HSEBYP);        \
N                        SET_BIT(RCC->CR, RCC_CR_HSEON);         \
N                      }                                         \
N                      else                                      \
N                      {                                         \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEON);       \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);      \
N                      }                                         \
N                    } while(0U)
X#define __HAL_RCC_HSE_CONFIG(__STATE__)                                             do {                                                              if ((__STATE__) == RCC_HSE_ON)                                  {                                                                 SET_BIT(RCC->CR, RCC_CR_HSEON);                               }                                                               else if ((__STATE__) == RCC_HSE_BYPASS)                         {                                                                 SET_BIT(RCC->CR, RCC_CR_HSEBYP);                                SET_BIT(RCC->CR, RCC_CR_HSEON);                               }                                                               else                                                            {                                                                 CLEAR_BIT(RCC->CR, RCC_CR_HSEON);                               CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);                            }                                                             } while(0U)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Configuration LSE Configuration
N  * @{
N  */
N
N/**
N  * @brief  Macro to configure the External Low Speed oscillator (LSE).
N  * @note   Transition LSE Bypass to LSE On and LSE On to LSE Bypass are not supported by this macro.
N  *         User should request a transition to LSE Off first and then LSE On or LSE Bypass.
N  * @note   As the LSE is in the Backup domain and write access is denied to
N  *         this domain after reset, you have to enable write access using
N  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
N  *         (to be done once after reset).
N  * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_BYPASS), the application
N  *         software should wait on LSERDY flag to be set indicating that LSE clock
N  *         is stable and can be used to clock the RTC.
N  * @param  __STATE__ specifies the new state of the LSE.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
N  *                              6 LSE oscillator clock cycles.
N  *            @arg RCC_LSE_ON: turn ON the LSE oscillator.
N  *            @arg RCC_LSE_BYPASS: LSE oscillator bypassed with external clock.
N  */
N#define __HAL_RCC_LSE_CONFIG(__STATE__) \
N                    do {                                       \
N                      if((__STATE__) == RCC_LSE_ON)            \
N                      {                                        \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);    \
N                      }                                        \
N                      else if((__STATE__) == RCC_LSE_BYPASS)   \
N                      {                                        \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);   \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);    \
N                      }                                        \
N                      else                                     \
N                      {                                        \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);  \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP); \
N                      }                                        \
N                    } while(0U)
X#define __HAL_RCC_LSE_CONFIG(__STATE__)                     do {                                                             if((__STATE__) == RCC_LSE_ON)                                  {                                                                SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          }                                                              else if((__STATE__) == RCC_LSE_BYPASS)                         {                                                                SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                           SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          }                                                              else                                                           {                                                                CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                       }                                                            } while(0U)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Internal_RTC_Clock_Configuration RTC Clock Configuration
N  * @{
N  */
N
N/** @brief  Macros to enable or disable the RTC clock.
N  * @note   These macros must be used only after the RTC clock source was selected.
N  */
N#define __HAL_RCC_RTC_ENABLE() (*(__IO uint32_t *) RCC_BDCR_RTCEN_BB = ENABLE)
N#define __HAL_RCC_RTC_DISABLE() (*(__IO uint32_t *) RCC_BDCR_RTCEN_BB = DISABLE)
N
N/** @brief  Macros to configure the RTC clock (RTCCLK).
N  * @note   As the RTC clock configuration bits are in the Backup domain and write
N  *         access is denied to this domain after reset, you have to enable write
N  *         access using the Power Backup Access macro before to configure
N  *         the RTC clock source (to be done once after reset).
N  * @note   Once the RTC clock is configured it can't be changed unless the
N  *         Backup domain is reset using __HAL_RCC_BackupReset_RELEASE() macro, or by
N  *         a Power On Reset (POR).
N  * @param  __RTCCLKSource__ specifies the RTC clock source.
N  *         This parameter can be one of the following values:
N  *            @arg @ref RCC_RTCCLKSOURCE_NO_CLK : No clock selected as RTC clock.
N  *            @arg @ref RCC_RTCCLKSOURCE_LSE : LSE selected as RTC clock.
N  *            @arg @ref RCC_RTCCLKSOURCE_LSI : LSI selected as RTC clock.
N  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIVX HSE divided by X selected as RTC clock (X can be retrieved thanks to @ref __HAL_RCC_GET_RTC_HSE_PRESCALER()
N  * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
N  *         work in STOP and STANDBY modes, and can be used as wake-up source.
N  *         However, when the HSE clock is used as RTC clock source, the RTC
N  *         cannot be used in STOP and STANDBY modes.
N  * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
N  *         RTC clock source).
N  */
N#define __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__) (((__RTCCLKSource__) & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL) ?    \
N                                                 MODIFY_REG(RCC->CFGR, RCC_CFGR_RTCPRE, ((__RTCCLKSource__) & 0xFFFFCFFU)) : CLEAR_BIT(RCC->CFGR, RCC_CFGR_RTCPRE)
X#define __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__) (((__RTCCLKSource__) & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL) ?                                                     MODIFY_REG(RCC->CFGR, RCC_CFGR_RTCPRE, ((__RTCCLKSource__) & 0xFFFFCFFU)) : CLEAR_BIT(RCC->CFGR, RCC_CFGR_RTCPRE)
N
N#define __HAL_RCC_RTC_CONFIG(__RTCCLKSource__) do { __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__);    \
N                                                    RCC->BDCR |= ((__RTCCLKSource__) & 0x00000FFFU);  \
N                                                   } while(0U)
X#define __HAL_RCC_RTC_CONFIG(__RTCCLKSource__) do { __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__);                                                        RCC->BDCR |= ((__RTCCLKSource__) & 0x00000FFFU);                                                     } while(0U)
N
N/** @brief Macro to get the RTC clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_RTCCLKSOURCE_NO_CLK No clock selected as RTC clock
N  *            @arg @ref RCC_RTCCLKSOURCE_LSE LSE selected as RTC clock
N  *            @arg @ref RCC_RTCCLKSOURCE_LSI LSI selected as RTC clock
N  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIVX HSE divided by X selected as RTC clock (X can be retrieved thanks to @ref __HAL_RCC_GET_RTC_HSE_PRESCALER()
N  */
N#define __HAL_RCC_GET_RTC_SOURCE() (READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL))
N
N/**
N  * @brief   Get the RTC and HSE clock divider (RTCPRE).
N  * @retval Returned value can be one of the following values:
N *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIVX HSE divided by X selected as RTC clock (X can be retrieved thanks to @ref __HAL_RCC_GET_RTC_HSE_PRESCALER()
N  */
N#define  __HAL_RCC_GET_RTC_HSE_PRESCALER() (READ_BIT(RCC->CFGR, RCC_CFGR_RTCPRE) | RCC_BDCR_RTCSEL)
N
N/** @brief  Macros to force or release the Backup domain reset.
N  * @note   This function resets the RTC peripheral (including the backup registers)
N  *         and the RTC clock source selection in RCC_CSR register.
N  * @note   The BKPSRAM is not affected by this reset.
N  */
N#define __HAL_RCC_BACKUPRESET_FORCE() (*(__IO uint32_t *) RCC_BDCR_BDRST_BB = ENABLE)
N#define __HAL_RCC_BACKUPRESET_RELEASE() (*(__IO uint32_t *) RCC_BDCR_BDRST_BB = DISABLE)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Configuration PLL Configuration
N  * @{
N  */
N
N/** @brief  Macros to enable or disable the main PLL.
N  * @note   After enabling the main PLL, the application software should wait on
N  *         PLLRDY flag to be set indicating that PLL clock is stable and can
N  *         be used as system clock source.
N  * @note   The main PLL can not be disabled if it is used as system clock source
N  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
N  */
N#define __HAL_RCC_PLL_ENABLE() (*(__IO uint32_t *) RCC_CR_PLLON_BB = ENABLE)
N#define __HAL_RCC_PLL_DISABLE() (*(__IO uint32_t *) RCC_CR_PLLON_BB = DISABLE)
N
N/** @brief  Macro to configure the PLL clock source.
N  * @note   This function must be used only when the main PLL is disabled.
N  * @param  __PLLSOURCE__ specifies the PLL entry clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
N  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
N  *
N  */
N#define __HAL_RCC_PLL_PLLSOURCE_CONFIG(__PLLSOURCE__) MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, (__PLLSOURCE__))
N
N/** @brief  Macro to configure the PLL multiplication factor.
N  * @note   This function must be used only when the main PLL is disabled.
N  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
N  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
N  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
N  *         of 2 MHz to limit PLL jitter.
N  *
N  */
N#define __HAL_RCC_PLL_PLLM_CONFIG(__PLLM__) MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLM, (__PLLM__))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Get_Clock_source Get Clock source
N  * @{
N  */
N/**
N  * @brief Macro to configure the system clock source.
N  * @param __RCC_SYSCLKSOURCE__ specifies the system clock source.
N  * This parameter can be one of the following values:
N  *              - RCC_SYSCLKSOURCE_HSI: HSI oscillator is used as system clock source.
N  *              - RCC_SYSCLKSOURCE_HSE: HSE oscillator is used as system clock source.
N  *              - RCC_SYSCLKSOURCE_PLLCLK: PLL output is used as system clock source.
N  *              - RCC_SYSCLKSOURCE_PLLRCLK: PLLR output is used as system clock source. This
N  *                parameter is available only for STM32F446xx devices.
N  */
N#define __HAL_RCC_SYSCLK_CONFIG(__RCC_SYSCLKSOURCE__) MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, (__RCC_SYSCLKSOURCE__))
N
N/** @brief  Macro to get the clock source used as system clock.
N  * @retval The clock source used as system clock. The returned value can be one
N  *         of the following:
N  *              - RCC_SYSCLKSOURCE_STATUS_HSI: HSI used as system clock.
N  *              - RCC_SYSCLKSOURCE_STATUS_HSE: HSE used as system clock.
N  *              - RCC_SYSCLKSOURCE_STATUS_PLLCLK: PLL used as system clock.
N  *              - RCC_SYSCLKSOURCE_STATUS_PLLRCLK: PLLR used as system clock. This parameter
N  *                is available only for STM32F446xx devices.
N  */
N#define __HAL_RCC_GET_SYSCLK_SOURCE() (RCC->CFGR & RCC_CFGR_SWS)
N
N/** @brief  Macro to get the oscillator used as PLL clock source.
N  * @retval The oscillator used as PLL clock source. The returned value can be one
N  *         of the following:
N  *              - RCC_PLLSOURCE_HSI: HSI oscillator is used as PLL clock source.
N  *              - RCC_PLLSOURCE_HSE: HSE oscillator is used as PLL clock source.
N  */
N#define __HAL_RCC_GET_PLL_OSCSOURCE() ((uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_MCOx_Clock_Config RCC Extended MCOx Clock Config
N  * @{
N  */
N
N/** @brief  Macro to configure the MCO1 clock.
N  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
N  *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
N  *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
N  *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source
N  * @param  __MCODIV__ specifies the MCO clock prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCODIV_1: no division applied to MCOx clock
N  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
N  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
N  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
N  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
N  */
N#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__) \
N                 MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))
X#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__)                  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))
N
N/** @brief  Macro to configure the MCO2 clock.
N  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
N  *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source, available for all STM32F4 devices except STM32F410xx
N  *            @arg RCC_MCO2SOURCE_I2SCLK: I2SCLK clock selected as MCO2 source, available only for STM32F410Rx devices
N  *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
N  *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source
N  * @param  __MCODIV__ specifies the MCO clock prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCODIV_1: no division applied to MCOx clock
N  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
N  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
N  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
N  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
N  * @note  For STM32F410Rx devices, to output I2SCLK clock on MCO2, you should have
N  *        at least one of the SPI clocks enabled (SPI1, SPI2 or SPI5).
N  */
N#define __HAL_RCC_MCO2_CONFIG(__MCOCLKSOURCE__, __MCODIV__) \
N    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), ((__MCOCLKSOURCE__) | ((__MCODIV__) << 3U)));
X#define __HAL_RCC_MCO2_CONFIG(__MCOCLKSOURCE__, __MCODIV__)     MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), ((__MCOCLKSOURCE__) | ((__MCODIV__) << 3U)));
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Flags_Interrupts_Management Flags Interrupts Management
N  * @brief macros to manage the specified RCC Flags and interrupts.
N  * @{
N  */
N
N/** @brief  Enable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to enable
N  *         the selected interrupts).
N  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be enabled.
N  *         This parameter can be any combination of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  */
N#define __HAL_RCC_ENABLE_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS |= (__INTERRUPT__))
N
N/** @brief Disable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to disable
N  *        the selected interrupts).
N  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be disabled.
N  *         This parameter can be any combination of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  */
N#define __HAL_RCC_DISABLE_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS &= (uint8_t)(~(__INTERRUPT__)))
N
N/** @brief  Clear the RCC's interrupt pending bits (Perform Byte access to RCC_CIR[23:16]
N  *         bits to clear the selected interrupt pending bits.
N  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
N  *         This parameter can be any combination of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  *            @arg RCC_IT_CSS: Clock Security System interrupt
N  */
N#define __HAL_RCC_CLEAR_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE2_ADDRESS = (__INTERRUPT__))
N
N/** @brief  Check the RCC's interrupt has occurred or not.
N  * @param  __INTERRUPT__ specifies the RCC interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  *            @arg RCC_IT_CSS: Clock Security System interrupt
N  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
N  */
N#define __HAL_RCC_GET_IT(__INTERRUPT__) ((RCC->CIR & (__INTERRUPT__)) == (__INTERRUPT__))
N
N/** @brief Set RMVF bit to clear the reset flags: RCC_FLAG_PINRST, RCC_FLAG_PORRST,
N  *        RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST and RCC_FLAG_LPWRRST.
N  */
N#define __HAL_RCC_CLEAR_RESET_FLAGS() (RCC->CSR |= RCC_CSR_RMVF)
N
N/** @brief  Check RCC flag is set or not.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready.
N  *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready.
N  *            @arg RCC_FLAG_PLLRDY: Main PLL clock ready.
N  *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready.
N  *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready.
N  *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready.
N  *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset.
N  *            @arg RCC_FLAG_PINRST: Pin reset.
N  *            @arg RCC_FLAG_PORRST: POR/PDR reset.
N  *            @arg RCC_FLAG_SFTRST: Software reset.
N  *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset.
N  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset.
N  *            @arg RCC_FLAG_LPWRRST: Low Power reset.
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define RCC_FLAG_MASK  ((uint8_t)0x1FU)
N#define __HAL_RCC_GET_FLAG(__FLAG__) (((((((__FLAG__) >> 5U) == 1U)? RCC->CR :((((__FLAG__) >> 5U) == 2U) ? RCC->BDCR :((((__FLAG__) >> 5U) == 3U)? RCC->CSR :RCC->CIR))) & (1U << ((__FLAG__) & RCC_FLAG_MASK)))!= 0U)? 1U : 0U)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N /** @addtogroup RCC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup RCC_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions  ******************************/
NHAL_StatusTypeDef HAL_RCC_DeInit(void);
NHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
NHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t FLatency);
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions  ************************************************/
Nvoid     HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv);
Nvoid     HAL_RCC_EnableCSS(void);
Nvoid     HAL_RCC_DisableCSS(void);
Nuint32_t HAL_RCC_GetSysClockFreq(void);
Nuint32_t HAL_RCC_GetHCLKFreq(void);
Nuint32_t HAL_RCC_GetPCLK1Freq(void);
Nuint32_t HAL_RCC_GetPCLK2Freq(void);
Nvoid     HAL_RCC_GetOscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
Nvoid     HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t *pFLatency);
N
N/* CSS NMI IRQ handler */
Nvoid HAL_RCC_NMI_IRQHandler(void);
N
N/* User Callbacks in non blocking mode (IT mode) */
Nvoid HAL_RCC_CSSCallback(void);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RCC_Private_Constants RCC Private Constants
N  * @{
N  */
N
N/** @defgroup RCC_BitAddress_AliasRegion RCC BitAddress AliasRegion
N  * @brief RCC registers bit address in the alias region
N  * @{
N  */
N#define RCC_OFFSET                 (RCC_BASE - PERIPH_BASE)
N/* --- CR Register --- */
N/* Alias word address of HSION bit */
N#define RCC_CR_OFFSET              (RCC_OFFSET + 0x00U)
N#define RCC_HSION_BIT_NUMBER       0x00U
N#define RCC_CR_HSION_BB            (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_HSION_BIT_NUMBER * 4U))
N/* Alias word address of CSSON bit */
N#define RCC_CSSON_BIT_NUMBER       0x13U
N#define RCC_CR_CSSON_BB            (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_CSSON_BIT_NUMBER * 4U))
N/* Alias word address of PLLON bit */
N#define RCC_PLLON_BIT_NUMBER       0x18U
N#define RCC_CR_PLLON_BB            (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_PLLON_BIT_NUMBER * 4U))
N
N/* --- BDCR Register --- */
N/* Alias word address of RTCEN bit */
N#define RCC_BDCR_OFFSET            (RCC_OFFSET + 0x70U)
N#define RCC_RTCEN_BIT_NUMBER       0x0FU
N#define RCC_BDCR_RTCEN_BB          (PERIPH_BB_BASE + (RCC_BDCR_OFFSET * 32U) + (RCC_RTCEN_BIT_NUMBER * 4U))
N/* Alias word address of BDRST bit */
N#define RCC_BDRST_BIT_NUMBER       0x10U
N#define RCC_BDCR_BDRST_BB          (PERIPH_BB_BASE + (RCC_BDCR_OFFSET * 32U) + (RCC_BDRST_BIT_NUMBER * 4U))
N
N/* --- CSR Register --- */
N/* Alias word address of LSION bit */
N#define RCC_CSR_OFFSET             (RCC_OFFSET + 0x74U)
N#define RCC_LSION_BIT_NUMBER        0x00U
N#define RCC_CSR_LSION_BB           (PERIPH_BB_BASE + (RCC_CSR_OFFSET * 32U) + (RCC_LSION_BIT_NUMBER * 4U))
N
N/* CR register byte 3 (Bits[23:16]) base address */
N#define RCC_CR_BYTE2_ADDRESS       0x40023802U
N
N/* CIR register byte 2 (Bits[15:8]) base address */
N#define RCC_CIR_BYTE1_ADDRESS      ((uint32_t)(RCC_BASE + 0x0CU + 0x01U))
N
N/* CIR register byte 3 (Bits[23:16]) base address */
N#define RCC_CIR_BYTE2_ADDRESS      ((uint32_t)(RCC_BASE + 0x0CU + 0x02U))
N
N/* BDCR register base address */
N#define RCC_BDCR_BYTE0_ADDRESS     (PERIPH_BASE + RCC_BDCR_OFFSET)
N
N#define RCC_DBP_TIMEOUT_VALUE      2U
N#define RCC_LSE_TIMEOUT_VALUE      LSE_STARTUP_TIMEOUT
N
N#define HSE_TIMEOUT_VALUE          HSE_STARTUP_TIMEOUT
N#define HSI_TIMEOUT_VALUE          2U  /* 2 ms */
N#define LSI_TIMEOUT_VALUE          2U  /* 2 ms */
N#define CLOCKSWITCH_TIMEOUT_VALUE  5000U /* 5 s */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RCC_Private_Macros RCC Private Macros
N  * @{
N  */
N
N/** @defgroup RCC_IS_RCC_Definitions RCC Private macros to check input parameters
N  * @{
N  */
N#define IS_RCC_OSCILLATORTYPE(OSCILLATOR) ((OSCILLATOR) <= 15U)
N
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_BYPASS))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_BYPASS))
N
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_BYPASS))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_BYPASS))
N
N#define IS_RCC_HSI(HSI) (((HSI) == RCC_HSI_OFF) || ((HSI) == RCC_HSI_ON))
N
N#define IS_RCC_LSI(LSI) (((LSI) == RCC_LSI_OFF) || ((LSI) == RCC_LSI_ON))
N
N#define IS_RCC_PLL(PLL) (((PLL) == RCC_PLL_NONE) ||((PLL) == RCC_PLL_OFF) || ((PLL) == RCC_PLL_ON))
N
N#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI) || \
N                                  ((SOURCE) == RCC_PLLSOURCE_HSE))
X#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI) ||                                   ((SOURCE) == RCC_PLLSOURCE_HSE))
N
N#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_HSI) || \
N                                     ((SOURCE) == RCC_SYSCLKSOURCE_HSE) || \
N                                     ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK) || \
N                                     ((SOURCE) == RCC_SYSCLKSOURCE_PLLRCLK))
X#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_HSI) ||                                      ((SOURCE) == RCC_SYSCLKSOURCE_HSE) ||                                      ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK) ||                                      ((SOURCE) == RCC_SYSCLKSOURCE_PLLRCLK))
N
N#define IS_RCC_RTCCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_RTCCLKSOURCE_LSE) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_LSI) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV2) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV3) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV4) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV5) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV6) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV7) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV8) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV9) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV10) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV11) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV12) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV13) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV14) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV15) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV16) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV17) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV18) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV19) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV20) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV21) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV22) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV23) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV24) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV25) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV26) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV27) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV28) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV29) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV30) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV31))
X#define IS_RCC_RTCCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_RTCCLKSOURCE_LSE) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_LSI) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV2) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV3) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV4) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV5) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV6) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV7) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV8) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV9) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV10) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV11) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV12) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV13) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV14) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV15) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV16) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV17) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV18) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV19) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV20) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV21) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV22) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV23) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV24) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV25) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV26) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV27) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV28) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV29) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV30) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV31))
N
N#define IS_RCC_PLLM_VALUE(VALUE) ((VALUE) <= 63U)
N
N#define IS_RCC_PLLP_VALUE(VALUE) (((VALUE) == 2U) || ((VALUE) == 4U) || ((VALUE) == 6U) || ((VALUE) == 8U))
N
N#define IS_RCC_PLLQ_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 15U))
N
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_DIV1)   || ((HCLK) == RCC_SYSCLK_DIV2)   || \
N                           ((HCLK) == RCC_SYSCLK_DIV4)   || ((HCLK) == RCC_SYSCLK_DIV8)   || \
N                           ((HCLK) == RCC_SYSCLK_DIV16)  || ((HCLK) == RCC_SYSCLK_DIV64)  || \
N                           ((HCLK) == RCC_SYSCLK_DIV128) || ((HCLK) == RCC_SYSCLK_DIV256) || \
N                           ((HCLK) == RCC_SYSCLK_DIV512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_DIV1)   || ((HCLK) == RCC_SYSCLK_DIV2)   ||                            ((HCLK) == RCC_SYSCLK_DIV4)   || ((HCLK) == RCC_SYSCLK_DIV8)   ||                            ((HCLK) == RCC_SYSCLK_DIV16)  || ((HCLK) == RCC_SYSCLK_DIV64)  ||                            ((HCLK) == RCC_SYSCLK_DIV128) || ((HCLK) == RCC_SYSCLK_DIV256) ||                            ((HCLK) == RCC_SYSCLK_DIV512))
N
N#define IS_RCC_CLOCKTYPE(CLK) ((1U <= (CLK)) && ((CLK) <= 15U))
N
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_DIV1) || ((PCLK) == RCC_HCLK_DIV2) || \
N                           ((PCLK) == RCC_HCLK_DIV4) || ((PCLK) == RCC_HCLK_DIV8) || \
N                           ((PCLK) == RCC_HCLK_DIV16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_DIV1) || ((PCLK) == RCC_HCLK_DIV2) ||                            ((PCLK) == RCC_HCLK_DIV4) || ((PCLK) == RCC_HCLK_DIV8) ||                            ((PCLK) == RCC_HCLK_DIV16))
N
N#define IS_RCC_MCO(MCOx) (((MCOx) == RCC_MCO1) || ((MCOx) == RCC_MCO2))
N
N#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1SOURCE_HSI) || ((SOURCE) == RCC_MCO1SOURCE_LSE) || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_HSE) || ((SOURCE) == RCC_MCO1SOURCE_PLLCLK))
X#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1SOURCE_HSI) || ((SOURCE) == RCC_MCO1SOURCE_LSE) ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSE) || ((SOURCE) == RCC_MCO1SOURCE_PLLCLK))
N
N#define IS_RCC_MCODIV(DIV) (((DIV) == RCC_MCODIV_1)  || ((DIV) == RCC_MCODIV_2) || \
N                             ((DIV) == RCC_MCODIV_3) || ((DIV) == RCC_MCODIV_4) || \
N                             ((DIV) == RCC_MCODIV_5))
X#define IS_RCC_MCODIV(DIV) (((DIV) == RCC_MCODIV_1)  || ((DIV) == RCC_MCODIV_2) ||                              ((DIV) == RCC_MCODIV_3) || ((DIV) == RCC_MCODIV_4) ||                              ((DIV) == RCC_MCODIV_5))
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1FU)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_RCC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 276 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_RCC_MODULE_ENABLED */
N
N#ifdef HAL_GPIO_MODULE_ENABLED
N  #include "stm32f4xx_hal_gpio.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_gpio.h
N  * @author  MCD Application Team
N  * @brief   Header file of GPIO HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_GPIO_H
N#define __STM32F4xx_HAL_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup GPIO
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup GPIO_Exported_Types GPIO Exported Types
N  * @{
N  */
N
N/** 
N  * @brief GPIO Init structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t Pin;       /*!< Specifies the GPIO pins to be configured.
N                           This parameter can be any value of @ref GPIO_pins_define */
N
N  uint32_t Mode;      /*!< Specifies the operating mode for the selected pins.
N                           This parameter can be a value of @ref GPIO_mode_define */
N
N  uint32_t Pull;      /*!< Specifies the Pull-up or Pull-Down activation for the selected pins.
N                           This parameter can be a value of @ref GPIO_pull_define */
N
N  uint32_t Speed;     /*!< Specifies the speed for the selected pins.
N                           This parameter can be a value of @ref GPIO_speed_define */
N
N  uint32_t Alternate;  /*!< Peripheral to be connected to the selected pins. 
N                            This parameter can be a value of @ref GPIO_Alternate_function_selection */
N}GPIO_InitTypeDef;
N
N/** 
N  * @brief  GPIO Bit SET and Bit RESET enumeration 
N  */
Ntypedef enum
N{
N  GPIO_PIN_RESET = 0,
N  GPIO_PIN_SET
N}GPIO_PinState;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup GPIO_Exported_Constants GPIO Exported Constants
N  * @{
N  */ 
N
N/** @defgroup GPIO_pins_define GPIO pins define
N  * @{
N  */
N#define GPIO_PIN_0                 ((uint16_t)0x0001)  /* Pin 0 selected    */
N#define GPIO_PIN_1                 ((uint16_t)0x0002)  /* Pin 1 selected    */
N#define GPIO_PIN_2                 ((uint16_t)0x0004)  /* Pin 2 selected    */
N#define GPIO_PIN_3                 ((uint16_t)0x0008)  /* Pin 3 selected    */
N#define GPIO_PIN_4                 ((uint16_t)0x0010)  /* Pin 4 selected    */
N#define GPIO_PIN_5                 ((uint16_t)0x0020)  /* Pin 5 selected    */
N#define GPIO_PIN_6                 ((uint16_t)0x0040)  /* Pin 6 selected    */
N#define GPIO_PIN_7                 ((uint16_t)0x0080)  /* Pin 7 selected    */
N#define GPIO_PIN_8                 ((uint16_t)0x0100)  /* Pin 8 selected    */
N#define GPIO_PIN_9                 ((uint16_t)0x0200)  /* Pin 9 selected    */
N#define GPIO_PIN_10                ((uint16_t)0x0400)  /* Pin 10 selected   */
N#define GPIO_PIN_11                ((uint16_t)0x0800)  /* Pin 11 selected   */
N#define GPIO_PIN_12                ((uint16_t)0x1000)  /* Pin 12 selected   */
N#define GPIO_PIN_13                ((uint16_t)0x2000)  /* Pin 13 selected   */
N#define GPIO_PIN_14                ((uint16_t)0x4000)  /* Pin 14 selected   */
N#define GPIO_PIN_15                ((uint16_t)0x8000)  /* Pin 15 selected   */
N#define GPIO_PIN_All               ((uint16_t)0xFFFF)  /* All pins selected */
N
N#define GPIO_PIN_MASK              0x0000FFFFU /* PIN mask for assert test */
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_mode_define GPIO mode define
N  * @brief GPIO Configuration Mode
N  *        Elements values convention: 0x00WX00YZ
N  *           - W  : EXTI trigger detection on 3 bits
N  *           - X  : EXTI mode (IT or Event) on 2 bits
N  *           - Y  : Output type (Push Pull or Open Drain) on 1 bit
N  *           - Z  : GPIO mode (Input, Output, Alternate or Analog) on 2 bits
N  * @{
N  */ 
N#define  GPIO_MODE_INPUT                        MODE_INPUT                                                  /*!< Input Floating Mode                   */
N#define  GPIO_MODE_OUTPUT_PP                    (MODE_OUTPUT | OUTPUT_PP)                                   /*!< Output Push Pull Mode                 */
N#define  GPIO_MODE_OUTPUT_OD                    (MODE_OUTPUT | OUTPUT_OD)                                   /*!< Output Open Drain Mode                */
N#define  GPIO_MODE_AF_PP                        (MODE_AF | OUTPUT_PP)                                       /*!< Alternate Function Push Pull Mode     */
N#define  GPIO_MODE_AF_OD                        (MODE_AF | OUTPUT_OD)                                       /*!< Alternate Function Open Drain Mode    */
N
N#define  GPIO_MODE_ANALOG                       MODE_ANALOG                                                 /*!< Analog Mode  */
N    
N#define  GPIO_MODE_IT_RISING                    (MODE_INPUT | EXTI_IT | TRIGGER_RISING)                     /*!< External Interrupt Mode with Rising edge trigger detection          */
N#define  GPIO_MODE_IT_FALLING                   (MODE_INPUT | EXTI_IT | TRIGGER_FALLING)                    /*!< External Interrupt Mode with Falling edge trigger detection         */
N#define  GPIO_MODE_IT_RISING_FALLING            (MODE_INPUT | EXTI_IT | TRIGGER_RISING | TRIGGER_FALLING)   /*!< External Interrupt Mode with Rising/Falling edge trigger detection  */
N 
N#define  GPIO_MODE_EVT_RISING                   (MODE_INPUT | EXTI_EVT | TRIGGER_RISING)                     /*!< External Event Mode with Rising edge trigger detection             */
N#define  GPIO_MODE_EVT_FALLING                  (MODE_INPUT | EXTI_EVT | TRIGGER_FALLING)                    /*!< External Event Mode with Falling edge trigger detection            */
N#define  GPIO_MODE_EVT_RISING_FALLING           (MODE_INPUT | EXTI_EVT | TRIGGER_RISING | TRIGGER_FALLING)   /*!< External Event Mode with Rising/Falling edge trigger detection     */
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_speed_define  GPIO speed define
N  * @brief GPIO Output Maximum frequency
N  * @{
N  */
N#define  GPIO_SPEED_FREQ_LOW         0x00000000U  /*!< IO works at 2 MHz, please refer to the product datasheet */
N#define  GPIO_SPEED_FREQ_MEDIUM      0x00000001U  /*!< range 12,5 MHz to 50 MHz, please refer to the product datasheet */
N#define  GPIO_SPEED_FREQ_HIGH        0x00000002U  /*!< range 25 MHz to 100 MHz, please refer to the product datasheet  */
N#define  GPIO_SPEED_FREQ_VERY_HIGH   0x00000003U  /*!< range 50 MHz to 200 MHz, please refer to the product datasheet  */
N/**
N  * @}
N  */
N
N /** @defgroup GPIO_pull_define GPIO pull define
N   * @brief GPIO Pull-Up or Pull-Down Activation
N   * @{
N   */  
N#define  GPIO_NOPULL        0x00000000U   /*!< No Pull-up or Pull-down activation  */
N#define  GPIO_PULLUP        0x00000001U   /*!< Pull-up activation                  */
N#define  GPIO_PULLDOWN      0x00000002U   /*!< Pull-down activation                */
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIO_Exported_Macros GPIO Exported Macros
N  * @{
N  */
N
N/**
N  * @brief  Checks whether the specified EXTI line flag is set or not.
N  * @param  __EXTI_LINE__ specifies the EXTI line flag to check.
N  *         This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval The new state of __EXTI_LINE__ (SET or RESET).
N  */
N#define __HAL_GPIO_EXTI_GET_FLAG(__EXTI_LINE__) (EXTI->PR & (__EXTI_LINE__))
N
N/**
N  * @brief  Clears the EXTI's line pending flags.
N  * @param  __EXTI_LINE__ specifies the EXTI lines flags to clear.
N  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_CLEAR_FLAG(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))
N
N/**
N  * @brief  Checks whether the specified EXTI line is asserted or not.
N  * @param  __EXTI_LINE__ specifies the EXTI line to check.
N  *          This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval The new state of __EXTI_LINE__ (SET or RESET).
N  */
N#define __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__) (EXTI->PR & (__EXTI_LINE__))
N
N/**
N  * @brief  Clears the EXTI's line pending bits.
N  * @param  __EXTI_LINE__ specifies the EXTI lines to clear.
N  *          This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))
N
N/**
N  * @brief  Generates a Software interrupt on selected EXTI line.
N  * @param  __EXTI_LINE__ specifies the EXTI line to check.
N  *          This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_GENERATE_SWIT(__EXTI_LINE__) (EXTI->SWIER |= (__EXTI_LINE__))
N/**
N  * @}
N  */
N
N/* Include GPIO HAL Extension module */
N#include "stm32f4xx_hal_gpio_ex.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_gpio_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_gpio_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of GPIO HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_GPIO_EX_H
N#define __STM32F4xx_HAL_GPIO_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup GPIOEx GPIOEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Constants GPIO Exported Constants
N  * @{
N  */
N  
N/** @defgroup GPIO_Alternate_function_selection GPIO Alternate Function Selection
N  * @{
N  */
N
N/*------------------------------------------ STM32F429xx/STM32F439xx ---------*/
N#if defined(STM32F429xx) || defined(STM32F439xx)
X#if 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S#define GPIO_AF5_SPI5          ((uint8_t)0x05)  /* SPI5 Alternate Function mapping        */
S#define GPIO_AF5_SPI6          ((uint8_t)0x05)  /* SPI6 Alternate Function mapping        */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping       */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_UART7         ((uint8_t)0x08)  /* UART7 Alternate Function mapping  */
S#define GPIO_AF8_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping    */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping   */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping   */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping   */
S#define GPIO_AF9_LTDC          ((uint8_t)0x09)  /* LCD-TFT Alternate Function mapping */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S
S/** 
S  * @brief   AF 11 selection  
S  */ 
S#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FMC           ((uint8_t)0x0C)  /* FMC Alternate Function mapping                      */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 13 selection  
S  */ 
S#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
S
S/** 
S  * @brief   AF 14 selection  
S  */
S#define GPIO_AF14_LTDC          ((uint8_t)0x0E)  /* LCD-TFT Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F429xx || STM32F439xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F427xx/STM32F437xx------------------*/
N#if defined(STM32F427xx) || defined(STM32F437xx)
X#if 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S#define GPIO_AF5_SPI5          ((uint8_t)0x05)  /* SPI5 Alternate Function mapping        */
S#define GPIO_AF5_SPI6          ((uint8_t)0x05)  /* SPI6 Alternate Function mapping        */
S/** @brief  GPIO_Legacy 
S  */
S#define GPIO_AF5_I2S3ext       GPIO_AF5_SPI3   /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping       */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_UART7         ((uint8_t)0x08)  /* UART7 Alternate Function mapping  */
S#define GPIO_AF8_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S
S/** 
S  * @brief   AF 11 selection  
S  */ 
S#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FMC           ((uint8_t)0x0C)  /* FMC Alternate Function mapping                      */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 13 selection  
S  */ 
S#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F427xx || STM32F437xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F407xx/STM32F417xx------------------*/
N#if defined(STM32F407xx) || defined(STM32F417xx)
X#if 1L || 0L
N/** 
N  * @brief   AF 0 selection  
N  */ 
N#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
N#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
N#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
N#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
N#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
N
N/** 
N  * @brief   AF 1 selection  
N  */ 
N#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
N#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
N
N/** 
N  * @brief   AF 2 selection  
N  */ 
N#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
N#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
N#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
N
N/** 
N  * @brief   AF 3 selection  
N  */ 
N#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
N#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
N#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
N#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
N
N/** 
N  * @brief   AF 4 selection  
N  */ 
N#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
N#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
N#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
N
N/** 
N  * @brief   AF 5 selection  
N  */ 
N#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
N#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
N#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
N
N/** 
N  * @brief   AF 6 selection  
N  */ 
N#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
N#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
N
N/** 
N  * @brief   AF 7 selection  
N  */ 
N#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
N#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
N#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
N#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
N
N/** 
N  * @brief   AF 8 selection  
N  */ 
N#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
N#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
N#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
N
N/** 
N  * @brief   AF 9 selection 
N  */ 
N#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
N#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
N#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
N#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
N#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
N
N/** 
N  * @brief   AF 10 selection  
N  */ 
N#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
N#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
N
N/** 
N  * @brief   AF 11 selection  
N  */ 
N#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
N
N/** 
N  * @brief   AF 12 selection  
N  */ 
N#define GPIO_AF12_FSMC          ((uint8_t)0x0C)  /* FSMC Alternate Function mapping                     */
N#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
N#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
N
N/** 
N  * @brief   AF 13 selection  
N  */ 
N#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
N
N/** 
N  * @brief   AF 15 selection  
N  */ 
N#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F407xx || STM32F417xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F405xx/STM32F415xx------------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx)
X#if 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FSMC          ((uint8_t)0x0C)  /* FSMC Alternate Function mapping                     */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F405xx || STM32F415xx */
N
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------------- STM32F401xx------------------------*/
N#if defined(STM32F401xC) || defined(STM32F401xE) 
X#if 0L || 0L 
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3 Alternate Function mapping        */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping  */
S#define GPIO_AF9_I2C3          ((uint8_t)0x09)  /* I2C3 Alternate Function mapping  */
S
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping  */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F401xC || STM32F401xE */
N/*----------------------------------------------------------------------------*/
N
N/*--------------- STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx-------------*/
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)   
X#if 0L || 0L || 0L || 0L   
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping    */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping    */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping    */
S#define GPIO_AF4_FMPI2C1       ((uint8_t)0x04)  /* FMPI2C1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4/I2S4 Alternate Function mapping   */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* I2S2 Alternate Function mapping       */
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_SPI4          ((uint8_t)0x06)  /* SPI4/I2S4 Alternate Function mapping  */
S#define GPIO_AF6_SPI5          ((uint8_t)0x06)  /* SPI5/I2S5 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_DFSDM1        ((uint8_t)0x06)  /* DFSDM1 Alternate Function mapping     */
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_USART3        ((uint8_t)0x08)  /* USART3 Alternate Function mapping */
S#define GPIO_AF8_DFSDM1        ((uint8_t)0x08)  /* DFSDM1 Alternate Function mapping */
S#define GPIO_AF8_CAN1          ((uint8_t)0x08)  /* CAN1 Alternate Function mapping   */
S
S/** 
S  * @brief   AF 9 selection 
S  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping   */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping   */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping   */
S#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping    */
S#define GPIO_AF9_I2C3          ((uint8_t)0x09)  /* I2C3 Alternate Function mapping    */
S#define GPIO_AF9_FMPI2C1       ((uint8_t)0x09)  /* FMPI2C1 Alternate Function mapping */
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */  
S#define GPIO_AF9_QSPI          ((uint8_t)0x09)  /* QSPI Alternate Function mapping    */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_DFSDM1        ((uint8_t)0x0A)  /* DFSDM1 Alternate Function mapping */
S#define GPIO_AF10_QSPI          ((uint8_t)0x0A)  /* QSPI Alternate Function mapping   */
S#define GPIO_AF10_FMC           ((uint8_t)0x0A)  /* FMC Alternate Function mapping    */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping  */
S#define GPIO_AF12_FSMC          ((uint8_t)0x0C)  /* FMC Alternate Function mapping   */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N/*----------------------------------------------------------------------------*/
N
N/*--------------- STM32F413xx/STM32F423xx-------------------------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)   
X#if 0L || 0L   
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S#define GPIO_AF1_LPTIM1        ((uint8_t)0x01)  /* LPTIM1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S#define GPIO_AF3_DFSDM2        ((uint8_t)0x03)  /* DFSDM2 Alternate Function mapping */   
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping    */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping    */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping    */
S#define GPIO_AF4_FMPI2C1       ((uint8_t)0x04)  /* FMPI2C1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4/I2S4 Alternate Function mapping   */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* I2S2 Alternate Function mapping       */
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_SPI4          ((uint8_t)0x06)  /* SPI4/I2S4 Alternate Function mapping  */
S#define GPIO_AF6_SPI5          ((uint8_t)0x06)  /* SPI5/I2S5 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_DFSDM1        ((uint8_t)0x06)  /* DFSDM1 Alternate Function mapping     */
S#define GPIO_AF6_DFSDM2        ((uint8_t)0x06)  /* DFSDM2 Alternate Function mapping     */   
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF7_SAI1          ((uint8_t)0x07)  /* SAI1 Alternate Function mapping       */
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S#define GPIO_AF7_DFSDM2        ((uint8_t)0x07)  /* DFSDM2 Alternate Function mapping     */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_USART3        ((uint8_t)0x08)  /* USART3 Alternate Function mapping */
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_UART7         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S#define GPIO_AF8_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S#define GPIO_AF8_DFSDM1        ((uint8_t)0x08)  /* DFSDM1 Alternate Function mapping */
S#define GPIO_AF8_CAN1          ((uint8_t)0x08)  /* CAN1 Alternate Function mapping   */
S
S/** 
S  * @brief   AF 9 selection 
S  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping   */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping   */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping   */
S#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping    */
S#define GPIO_AF9_I2C3          ((uint8_t)0x09)  /* I2C3 Alternate Function mapping    */
S#define GPIO_AF9_FMPI2C1       ((uint8_t)0x09)  /* FMPI2C1 Alternate Function mapping */
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_QSPI          ((uint8_t)0x09)  /* QSPI Alternate Function mapping    */
S
S/** 
S  * @brief   AF 10 selection  
S  */
S#define GPIO_AF10_SAI1          ((uint8_t)0x0A)  /* SAI1 Alternate Function mapping   */
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_DFSDM1        ((uint8_t)0x0A)  /* DFSDM1 Alternate Function mapping */
S#define GPIO_AF10_DFSDM2        ((uint8_t)0x0A)  /* DFSDM2 Alternate Function mapping */
S#define GPIO_AF10_QSPI          ((uint8_t)0x0A)  /* QSPI Alternate Function mapping   */
S#define GPIO_AF10_FSMC          ((uint8_t)0x0A)  /* FSMC Alternate Function mapping   */
S
S/** 
S  * @brief   AF 11 selection  
S  */
S#define GPIO_AF11_UART4         ((uint8_t)0x0B)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF11_UART5         ((uint8_t)0x0B)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF11_UART9         ((uint8_t)0x0B)  /* UART9 Alternate Function mapping  */
S#define GPIO_AF11_UART10        ((uint8_t)0x0B)  /* UART10 Alternate Function mapping */
S#define GPIO_AF11_CAN3          ((uint8_t)0x0B)  /* CAN3 Alternate Function mapping   */
S   
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping  */
S#define GPIO_AF12_FSMC          ((uint8_t)0x0C)  /* FMC Alternate Function mapping   */
S
S/** 
S  * @brief   AF 14 selection  
S  */ 
S#define GPIO_AF14_RNG           ((uint8_t)0x0E)  /* RNG Alternate Function mapping  */
S   
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F413xx || STM32F423xx */
N
N/*---------------------------------------- STM32F411xx------------------------*/
N#if defined(STM32F411xE) 
X#if 0L 
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* I2S2 Alternate Function mapping       */
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_SPI4          ((uint8_t)0x06)  /* SPI4/I2S4 Alternate Function mapping  */
S#define GPIO_AF6_SPI5          ((uint8_t)0x06)  /* SPI5/I2S5 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
S#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping  */
S#define GPIO_AF9_I2C3          ((uint8_t)0x09)  /* I2C3 Alternate Function mapping  */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping  */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F411xE */
N
N/*---------------------------------------- STM32F410xx------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_LPTIM1        ((uint8_t)0x01)  /* LPTIM1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_FMPI2C1       ((uint8_t)0x04)  /* FMPI2C1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#if defined(STM32F410Cx) || defined(STM32F410Rx)  
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#endif /* STM32F410Cx || STM32F410Rx */   
S
S/** 
S  * @brief   AF 6 selection  
S  */
S#define GPIO_AF6_SPI1          ((uint8_t)0x06)  /* SPI1 Alternate Function mapping  */
S#if defined(STM32F410Cx) || defined(STM32F410Rx)   
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* I2S2 Alternate Function mapping       */
S#endif /* STM32F410Cx || STM32F410Rx */   
S#define GPIO_AF6_SPI5          ((uint8_t)0x06)  /* SPI5/I2S5 Alternate Function mapping  */
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping  */
S#define GPIO_AF9_FMPI2C1       ((uint8_t)0x09)  /* FMPI2C1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/*---------------------------------------- STM32F446xx -----------------------*/
N#if defined(STM32F446xx)
X#if 0L
S/**
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S#define GPIO_AF3_CEC           ((uint8_t)0x03)  /* CEC Alternate Function mapping   */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S#define GPIO_AF4_FMPI2C1       ((uint8_t)0x04)  /* FMPI2C1 Alternate Function mapping */
S#define GPIO_AF4_CEC           ((uint8_t)0x04)  /* CEC Alternate Function mapping  */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* SPI2/I2S2 Alternate Function mapping  */
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_SPI4          ((uint8_t)0x06)  /* SPI4 Alternate Function mapping       */
S#define GPIO_AF6_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping       */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_UART5         ((uint8_t)0x07)  /* UART5 Alternate Function mapping      */
S#define GPIO_AF7_SPI2          ((uint8_t)0x07)  /* SPI2/I2S2 Alternate Function mapping  */
S#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF7_SPDIFRX       ((uint8_t)0x07)  /* SPDIFRX Alternate Function mapping      */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_SPDIFRX       ((uint8_t)0x08)  /* SPDIFRX Alternate Function mapping  */
S#define GPIO_AF8_SAI2          ((uint8_t)0x08)  /* SAI2 Alternate Function mapping   */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
S#define GPIO_AF9_QSPI          ((uint8_t)0x09)  /* QSPI Alternate Function mapping  */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S#define GPIO_AF10_SAI2          ((uint8_t)0x0A)  /* SAI2 Alternate Function mapping   */
S#define GPIO_AF10_QSPI          ((uint8_t)0x0A)  /* QSPI Alternate Function mapping  */
S
S/** 
S  * @brief   AF 11 selection  
S  */ 
S#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FMC           ((uint8_t)0x0C)  /* FMC Alternate Function mapping                      */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 13 selection  
S  */ 
S#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
S
N#endif /* STM32F446xx */
N/*----------------------------------------------------------------------------*/
N
N/*-------------------------------- STM32F469xx/STM32F479xx--------------------*/
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S#define GPIO_AF5_SPI5          ((uint8_t)0x05)  /* SPI5 Alternate Function mapping        */
S#define GPIO_AF5_SPI6          ((uint8_t)0x05)  /* SPI6 Alternate Function mapping        */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping       */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_UART7         ((uint8_t)0x08)  /* UART7 Alternate Function mapping  */
S#define GPIO_AF8_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping    */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping   */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping   */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping   */
S#define GPIO_AF9_LTDC          ((uint8_t)0x09)  /* LCD-TFT Alternate Function mapping */
S#define GPIO_AF9_QSPI          ((uint8_t)0x09)  /* QSPI Alternate Function mapping    */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S#define GPIO_AF10_QSPI          ((uint8_t)0x0A)  /* QSPI Alternate Function mapping   */
S
S/** 
S  * @brief   AF 11 selection  
S  */ 
S#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FMC           ((uint8_t)0x0C)  /* FMC Alternate Function mapping                      */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 13 selection  
S  */ 
S#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
S#define GPIO_AF13_DSI           ((uint8_t)0x0D)  /* DSI Alternate Function mapping  */
S
S/** 
S  * @brief   AF 14 selection  
S  */
S#define GPIO_AF14_LTDC          ((uint8_t)0x0E)  /* LCD-TFT Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
S
N#endif /* STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Macros GPIO Exported Macros
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Functions GPIO Exported Functions
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup GPIOEx_Private_Constants GPIO Private Constants
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup GPIOEx_Private_Macros GPIO Private Macros
N  * @{
N  */
N/** @defgroup GPIOEx_Get_Port_Index GPIO Get Port Index
N  * @{
N  */
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
X#if 0L || 0L || 1L || 0L
N#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
N                                               ((__GPIOx__) == (GPIOB))? 1U :\
N                                               ((__GPIOx__) == (GPIOC))? 2U :\
N                                               ((__GPIOx__) == (GPIOD))? 3U :\
N                                               ((__GPIOx__) == (GPIOE))? 4U :\
N                                               ((__GPIOx__) == (GPIOF))? 5U :\
N                                               ((__GPIOx__) == (GPIOG))? 6U :\
N                                               ((__GPIOx__) == (GPIOH))? 7U : 8U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U :                                               ((__GPIOx__) == (GPIOF))? 5U :                                               ((__GPIOx__) == (GPIOG))? 6U :                                               ((__GPIOx__) == (GPIOH))? 7U : 8U)
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U :\
S                                               ((__GPIOx__) == (GPIOE))? 4U :\
S                                               ((__GPIOx__) == (GPIOF))? 5U :\
S                                               ((__GPIOx__) == (GPIOG))? 6U :\
S                                               ((__GPIOx__) == (GPIOH))? 7U :\
S                                               ((__GPIOx__) == (GPIOI))? 8U :\
S                                               ((__GPIOx__) == (GPIOJ))? 9U : 10U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U :                                               ((__GPIOx__) == (GPIOF))? 5U :                                               ((__GPIOx__) == (GPIOG))? 6U :                                               ((__GPIOx__) == (GPIOH))? 7U :                                               ((__GPIOx__) == (GPIOI))? 8U :                                               ((__GPIOx__) == (GPIOJ))? 9U : 10U)
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) 
X#if 0L || 0L || 0L 
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U : 7U)
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) 
X#if 0L || 0L || 0L 
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U :\
S                                               ((__GPIOx__) == (GPIOE))? 4U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U : 7U)
N#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
N
N#if defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
X#if 0L || 0L || 0L || 0L 
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U :\
S                                               ((__GPIOx__) == (GPIOE))? 4U :\
S                                               ((__GPIOx__) == (GPIOF))? 5U :\
S                                               ((__GPIOx__) == (GPIOG))? 6U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U :                                               ((__GPIOx__) == (GPIOF))? 5U :                                               ((__GPIOx__) == (GPIOG))? 6U : 7U)
N#endif /* STM32F446xx || STM32F412Zx  || STM32F413xx || STM32F423xx */
N#if defined(STM32F412Vx)
X#if 0L
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U :\
S                                               ((__GPIOx__) == (GPIOE))? 4U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U : 7U)
N#endif /* STM32F412Vx */
N#if defined(STM32F412Rx)
X#if 0L
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U : 7U)
N#endif /* STM32F412Rx */
N#if defined(STM32F412Cx)
X#if 0L
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U : 7U)
N#endif /* STM32F412Cx */
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIOEx_IS_Alternat_function_selection GPIO Check Alternate Function
N  * @{
N  */  
N/*------------------------- STM32F429xx/STM32F439xx---------------------------*/
N#if defined(STM32F429xx) || defined(STM32F439xx)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      || \
S                          ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1)      || \
S                          ((AF) == GPIO_AF14_LTDC))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      ||                           ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1)      ||                           ((AF) == GPIO_AF14_LTDC))
S
N#endif /* STM32F429xx || STM32F439xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F427xx/STM32F437xx------------------*/
N#if defined(STM32F427xx) || defined(STM32F437xx)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      || \
S                          ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      ||                           ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1))
S
N#endif /* STM32F427xx || STM32F437xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F407xx/STM32F417xx------------------*/
N#if defined(STM32F407xx) || defined(STM32F417xx)
X#if 1L || 0L
N#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
N                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
N                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
N                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
N                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
N                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
N                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
N                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
N                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
N                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
N                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
N                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
N                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
N                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
N                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
N                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
N                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
N                          ((AF) == GPIO_AF12_FSMC)      || ((AF) == GPIO_AF15_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF12_FSMC)      || ((AF) == GPIO_AF15_EVENTOUT))
N
N#endif /* STM32F407xx || STM32F417xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F405xx/STM32F415xx------------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF12_OTG_HS_FS) || ((AF) == GPIO_AF12_SDIO)      || \
S                          ((AF) == GPIO_AF12_FSMC)      || ((AF) == GPIO_AF15_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF12_OTG_HS_FS) || ((AF) == GPIO_AF12_SDIO)      ||                           ((AF) == GPIO_AF12_FSMC)      || ((AF) == GPIO_AF15_EVENTOUT))
S
N#endif /* STM32F405xx || STM32F415xx */
N
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------------- STM32F401xx------------------------*/
N#if defined(STM32F401xC) || defined(STM32F401xE)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF12_SDIO)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM9)       || \
S                          ((AF) == GPIO_AF3_TIM10)      || ((AF) == GPIO_AF3_TIM11)      || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF7_USART1)     || \
S                          ((AF) == GPIO_AF7_USART2)     || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_I2C2)       || ((AF) == GPIO_AF9_I2C3)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF15_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF12_SDIO)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM9)       ||                           ((AF) == GPIO_AF3_TIM10)      || ((AF) == GPIO_AF3_TIM11)      ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF7_USART1)     ||                           ((AF) == GPIO_AF7_USART2)     || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_I2C2)       || ((AF) == GPIO_AF9_I2C3)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF15_EVENTOUT))
N#endif /* STM32F401xC || STM32F401xE */
N/*----------------------------------------------------------------------------*/
N/*---------------------------------------- STM32F410xx------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) 
X#if 0L || 0L || 0L 
S#define IS_GPIO_AF(AF)   (((AF) < 10U) || ((AF) == 15U))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/*---------------------------------------- STM32F411xx------------------------*/
N#if defined(STM32F411xE) 
X#if 0L 
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF4_I2C1)       || \
S                          ((AF) == GPIO_AF4_I2C2)       || ((AF) == GPIO_AF4_I2C3)       || \
S                          ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       || \
S                          ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF6_SPI4)       || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF6_SPI5)       || ((AF) == GPIO_AF7_SPI3)       || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF8_USART6)     || ((AF) == GPIO_AF10_OTG_FS)    || \
S                          ((AF) == GPIO_AF9_I2C2)       || ((AF) == GPIO_AF9_I2C3)       || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF15_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF4_I2C1)       ||                           ((AF) == GPIO_AF4_I2C2)       || ((AF) == GPIO_AF4_I2C3)       ||                           ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       ||                           ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF6_SPI4)       ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF6_SPI5)       || ((AF) == GPIO_AF7_SPI3)       ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF8_USART6)     || ((AF) == GPIO_AF10_OTG_FS)    ||                           ((AF) == GPIO_AF9_I2C2)       || ((AF) == GPIO_AF9_I2C3)       ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF15_EVENTOUT))
S
N#endif /* STM32F411xE */
N/*----------------------------------------------------------------------------*/
N
N/*----------------------------------------------- STM32F446xx ----------------*/
N#if defined(STM32F446xx) 
X#if 0L 
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1)      || \
S                          ((AF) == GPIO_AF3_CEC)        ||  ((AF) == GPIO_AF4_CEC)       || \
S                          ((AF) == GPIO_AF5_SPI3)       ||  ((AF) == GPIO_AF6_SPI2)      || \
S                          ((AF) == GPIO_AF6_SPI4)       ||  ((AF) == GPIO_AF7_UART5)     || \
S                          ((AF) == GPIO_AF7_SPI2)       ||  ((AF) == GPIO_AF7_SPI3)      || \
S                          ((AF) == GPIO_AF7_SPDIFRX)    ||  ((AF) == GPIO_AF8_SPDIFRX)   || \
S                          ((AF) == GPIO_AF8_SAI2)       ||  ((AF) == GPIO_AF9_QSPI)      || \
S                          ((AF) == GPIO_AF10_SAI2)      ||  ((AF) == GPIO_AF10_QSPI))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1)      ||                           ((AF) == GPIO_AF3_CEC)        ||  ((AF) == GPIO_AF4_CEC)       ||                           ((AF) == GPIO_AF5_SPI3)       ||  ((AF) == GPIO_AF6_SPI2)      ||                           ((AF) == GPIO_AF6_SPI4)       ||  ((AF) == GPIO_AF7_UART5)     ||                           ((AF) == GPIO_AF7_SPI2)       ||  ((AF) == GPIO_AF7_SPI3)      ||                           ((AF) == GPIO_AF7_SPDIFRX)    ||  ((AF) == GPIO_AF8_SPDIFRX)   ||                           ((AF) == GPIO_AF8_SAI2)       ||  ((AF) == GPIO_AF9_QSPI)      ||                           ((AF) == GPIO_AF10_SAI2)      ||  ((AF) == GPIO_AF10_QSPI))
S
N#endif /* STM32F446xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------------------------------- STM32F469xx/STM32F479xx --------*/
N#if defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L 
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      || \
S                          ((AF) == GPIO_AF12_FMC)       || ((AF) == GPIO_AF6_SAI1)       || \
S                          ((AF) == GPIO_AF14_LTDC)      || ((AF) == GPIO_AF13_DSI)      || \
S                          ((AF) == GPIO_AF9_QSPI)       || ((AF) == GPIO_AF10_QSPI))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      ||                           ((AF) == GPIO_AF12_FMC)       || ((AF) == GPIO_AF6_SAI1)       ||                           ((AF) == GPIO_AF14_LTDC)      || ((AF) == GPIO_AF13_DSI)      ||                           ((AF) == GPIO_AF9_QSPI)       || ((AF) == GPIO_AF10_QSPI))
S
N#endif /* STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx-----------*/
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L  
S#define IS_GPIO_AF(AF)   (((AF) < 16U) && ((AF) != 11U) && ((AF) != 14U) && ((AF) != 13U))
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------STM32F413xx/STM32F423xx-----------------------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)  
X#if 0L || 0L  
S#define IS_GPIO_AF(AF)   (((AF) < 16U) && ((AF) != 13U))
N#endif /* STM32F413xx || STM32F423xx */
N/*----------------------------------------------------------------------------*/
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup GPIOEx_Private_Functions GPIO Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_GPIO_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 215 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_gpio.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup GPIO_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup GPIO_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
Nvoid  HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init);
Nvoid  HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin);
N/**
N  * @}
N  */
N
N/** @addtogroup GPIO_Exported_Functions_Group2
N  * @{
N  */
N/* IO operation functions *****************************************************/
NGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
Nvoid HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
NHAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin);
Nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup GPIO_Private_Constants GPIO Private Constants
N  * @{
N  */
N#define GPIO_MODE_Pos                           0U
N#define GPIO_MODE                               (0x3UL << GPIO_MODE_Pos)
N#define MODE_INPUT                              (0x0UL << GPIO_MODE_Pos)
N#define MODE_OUTPUT                             (0x1UL << GPIO_MODE_Pos)
N#define MODE_AF                                 (0x2UL << GPIO_MODE_Pos)
N#define MODE_ANALOG                             (0x3UL << GPIO_MODE_Pos)
N#define OUTPUT_TYPE_Pos                         4U
N#define OUTPUT_TYPE                             (0x1UL << OUTPUT_TYPE_Pos)
N#define OUTPUT_PP                               (0x0UL << OUTPUT_TYPE_Pos)
N#define OUTPUT_OD                               (0x1UL << OUTPUT_TYPE_Pos)
N#define EXTI_MODE_Pos                           16U
N#define EXTI_MODE                               (0x3UL << EXTI_MODE_Pos)
N#define EXTI_IT                                 (0x1UL << EXTI_MODE_Pos)
N#define EXTI_EVT                                (0x2UL << EXTI_MODE_Pos)
N#define TRIGGER_MODE_Pos                         20U
N#define TRIGGER_MODE                            (0x7UL << TRIGGER_MODE_Pos)
N#define TRIGGER_RISING                          (0x1UL << TRIGGER_MODE_Pos)
N#define TRIGGER_FALLING                         (0x2UL << TRIGGER_MODE_Pos)
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup GPIO_Private_Macros GPIO Private Macros
N  * @{
N  */
N#define IS_GPIO_PIN_ACTION(ACTION) (((ACTION) == GPIO_PIN_RESET) || ((ACTION) == GPIO_PIN_SET))
N#define IS_GPIO_PIN(PIN)           (((((uint32_t)PIN) & GPIO_PIN_MASK ) != 0x00U) && ((((uint32_t)PIN) & ~GPIO_PIN_MASK) == 0x00U))
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_MODE_INPUT)              ||\
N                            ((MODE) == GPIO_MODE_OUTPUT_PP)          ||\
N                            ((MODE) == GPIO_MODE_OUTPUT_OD)          ||\
N                            ((MODE) == GPIO_MODE_AF_PP)              ||\
N                            ((MODE) == GPIO_MODE_AF_OD)              ||\
N                            ((MODE) == GPIO_MODE_IT_RISING)          ||\
N                            ((MODE) == GPIO_MODE_IT_FALLING)         ||\
N                            ((MODE) == GPIO_MODE_IT_RISING_FALLING)  ||\
N                            ((MODE) == GPIO_MODE_EVT_RISING)         ||\
N                            ((MODE) == GPIO_MODE_EVT_FALLING)        ||\
N                            ((MODE) == GPIO_MODE_EVT_RISING_FALLING) ||\
N                            ((MODE) == GPIO_MODE_ANALOG))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_MODE_INPUT)              ||                            ((MODE) == GPIO_MODE_OUTPUT_PP)          ||                            ((MODE) == GPIO_MODE_OUTPUT_OD)          ||                            ((MODE) == GPIO_MODE_AF_PP)              ||                            ((MODE) == GPIO_MODE_AF_OD)              ||                            ((MODE) == GPIO_MODE_IT_RISING)          ||                            ((MODE) == GPIO_MODE_IT_FALLING)         ||                            ((MODE) == GPIO_MODE_IT_RISING_FALLING)  ||                            ((MODE) == GPIO_MODE_EVT_RISING)         ||                            ((MODE) == GPIO_MODE_EVT_FALLING)        ||                            ((MODE) == GPIO_MODE_EVT_RISING_FALLING) ||                            ((MODE) == GPIO_MODE_ANALOG))
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_SPEED_FREQ_LOW)  || ((SPEED) == GPIO_SPEED_FREQ_MEDIUM) || \
N                              ((SPEED) == GPIO_SPEED_FREQ_HIGH) || ((SPEED) == GPIO_SPEED_FREQ_VERY_HIGH))
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_SPEED_FREQ_LOW)  || ((SPEED) == GPIO_SPEED_FREQ_MEDIUM) ||                               ((SPEED) == GPIO_SPEED_FREQ_HIGH) || ((SPEED) == GPIO_SPEED_FREQ_VERY_HIGH))
N#define IS_GPIO_PULL(PULL) (((PULL) == GPIO_NOPULL) || ((PULL) == GPIO_PULLUP) || \
N                            ((PULL) == GPIO_PULLDOWN))
X#define IS_GPIO_PULL(PULL) (((PULL) == GPIO_NOPULL) || ((PULL) == GPIO_PULLUP) ||                             ((PULL) == GPIO_PULLDOWN))
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup GPIO_Private_Functions GPIO Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_GPIO_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 280 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_GPIO_MODULE_ENABLED */
N
N#ifdef HAL_EXTI_MODULE_ENABLED
N  #include "stm32f4xx_hal_exti.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_exti.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_exti.h
N  * @author  MCD Application Team
N  * @brief   Header file of EXTI HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32f4xx_HAL_EXTI_H
N#define STM32f4xx_HAL_EXTI_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup EXTI EXTI
N  * @brief EXTI HAL module driver
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup EXTI_Exported_Types EXTI Exported Types
N  * @{
N  */
Ntypedef enum
N{
N  HAL_EXTI_COMMON_CB_ID          = 0x00U
N} EXTI_CallbackIDTypeDef;
N
N/**
N  * @brief  EXTI Handle structure definition
N  */
Ntypedef struct
N{
N  uint32_t Line;                    /*!<  Exti line number */
N  void (* PendingCallback)(void);   /*!<  Exti pending callback */
N} EXTI_HandleTypeDef;
N
N/**
N  * @brief  EXTI Configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t Line;      /*!< The Exti line to be configured. This parameter
N                           can be a value of @ref EXTI_Line */
N  uint32_t Mode;      /*!< The Exit Mode to be configured for a core.
N                           This parameter can be a combination of @ref EXTI_Mode */
N  uint32_t Trigger;   /*!< The Exti Trigger to be configured. This parameter
N                           can be a value of @ref EXTI_Trigger */
N  uint32_t GPIOSel;   /*!< The Exti GPIO multiplexer selection to be configured.
N                           This parameter is only possible for line 0 to 15. It
N                           can be a value of @ref EXTI_GPIOSel */
N} EXTI_ConfigTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup EXTI_Exported_Constants EXTI Exported Constants
N  * @{
N  */
N
N/** @defgroup EXTI_Line  EXTI Line
N  * @{
N  */
N#define EXTI_LINE_0                        (EXTI_GPIO       | 0x00u)    /*!< External interrupt line 0 */
N#define EXTI_LINE_1                        (EXTI_GPIO       | 0x01u)    /*!< External interrupt line 1 */
N#define EXTI_LINE_2                        (EXTI_GPIO       | 0x02u)    /*!< External interrupt line 2 */
N#define EXTI_LINE_3                        (EXTI_GPIO       | 0x03u)    /*!< External interrupt line 3 */
N#define EXTI_LINE_4                        (EXTI_GPIO       | 0x04u)    /*!< External interrupt line 4 */
N#define EXTI_LINE_5                        (EXTI_GPIO       | 0x05u)    /*!< External interrupt line 5 */
N#define EXTI_LINE_6                        (EXTI_GPIO       | 0x06u)    /*!< External interrupt line 6 */
N#define EXTI_LINE_7                        (EXTI_GPIO       | 0x07u)    /*!< External interrupt line 7 */
N#define EXTI_LINE_8                        (EXTI_GPIO       | 0x08u)    /*!< External interrupt line 8 */
N#define EXTI_LINE_9                        (EXTI_GPIO       | 0x09u)    /*!< External interrupt line 9 */
N#define EXTI_LINE_10                       (EXTI_GPIO       | 0x0Au)    /*!< External interrupt line 10 */
N#define EXTI_LINE_11                       (EXTI_GPIO       | 0x0Bu)    /*!< External interrupt line 11 */
N#define EXTI_LINE_12                       (EXTI_GPIO       | 0x0Cu)    /*!< External interrupt line 12 */
N#define EXTI_LINE_13                       (EXTI_GPIO       | 0x0Du)    /*!< External interrupt line 13 */
N#define EXTI_LINE_14                       (EXTI_GPIO       | 0x0Eu)    /*!< External interrupt line 14 */
N#define EXTI_LINE_15                       (EXTI_GPIO       | 0x0Fu)    /*!< External interrupt line 15 */
N#define EXTI_LINE_16                       (EXTI_CONFIG     | 0x10u)    /*!< External interrupt line 16 Connected to the PVD Output */
N#define EXTI_LINE_17                       (EXTI_CONFIG     | 0x11u)    /*!< External interrupt line 17 Connected to the RTC Alarm event */
N#if defined(EXTI_IMR_IM18)
X#if 1L
N#define EXTI_LINE_18                       (EXTI_CONFIG     | 0x12u)    /*!< External interrupt line 18 Connected to the USB OTG FS Wakeup from suspend event */
N#else
S#define EXTI_LINE_18                       (EXTI_RESERVED   | 0x12u)    /*!< No interrupt supported in this line */
N#endif /* EXTI_IMR_IM18 */
N#if defined(EXTI_IMR_IM19)
X#if 1L
N#define EXTI_LINE_19                       (EXTI_CONFIG     | 0x13u)    /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */
N#else
S#define EXTI_LINE_19                       (EXTI_RESERVED   | 0x13u)    /*!< No interrupt supported in this line */
N#endif /* EXTI_IMR_IM19 */
N#if defined(EXTI_IMR_IM20)
X#if 1L
N#define EXTI_LINE_20                       (EXTI_CONFIG     | 0x14u)    /*!< External interrupt line 20 Connected to the USB OTG HS (configured in FS) Wakeup event  */
N#else
S#define EXTI_LINE_20                       (EXTI_RESERVED   | 0x14u)    /*!< No interrupt supported in this line */
N#endif /* EXTI_IMR_IM20 */
N#define EXTI_LINE_21                       (EXTI_CONFIG     | 0x15u)    /*!< External interrupt line 21 Connected to the RTC Tamper and Time Stamp events */
N#define EXTI_LINE_22                       (EXTI_CONFIG     | 0x16u)    /*!< External interrupt line 22 Connected to the RTC Wakeup event */
N#if defined(EXTI_IMR_IM23)
X#if 0L
S#define EXTI_LINE_23                       (EXTI_CONFIG     | 0x17u)    /*!< External interrupt line 23 Connected to the LPTIM1 asynchronous event */
N#endif /* EXTI_IMR_IM23 */
N
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_Mode  EXTI Mode
N  * @{
N  */
N#define EXTI_MODE_NONE                      0x00000000u
N#define EXTI_MODE_INTERRUPT                 0x00000001u
N#define EXTI_MODE_EVENT                     0x00000002u
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_Trigger  EXTI Trigger
N  * @{
N  */
N
N#define EXTI_TRIGGER_NONE                   0x00000000u
N#define EXTI_TRIGGER_RISING                 0x00000001u
N#define EXTI_TRIGGER_FALLING                0x00000002u
N#define EXTI_TRIGGER_RISING_FALLING         (EXTI_TRIGGER_RISING | EXTI_TRIGGER_FALLING)
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_GPIOSel  EXTI GPIOSel
N  * @brief
N  * @{
N  */
N#define EXTI_GPIOA                          0x00000000u
N#define EXTI_GPIOB                          0x00000001u
N#define EXTI_GPIOC                          0x00000002u
N#if defined (GPIOD)
X#if 1L
N#define EXTI_GPIOD                          0x00000003u
N#endif /* GPIOD */
N#if defined (GPIOE)
X#if 1L
N#define EXTI_GPIOE                          0x00000004u
N#endif /* GPIOE */
N#if defined (GPIOF)
X#if 1L
N#define EXTI_GPIOF                          0x00000005u
N#endif /* GPIOF */
N#if defined (GPIOG)
X#if 1L
N#define EXTI_GPIOG                          0x00000006u
N#endif /* GPIOG */
N#if defined (GPIOH)
X#if 1L
N#define EXTI_GPIOH                          0x00000007u
N#endif /* GPIOH */
N#if defined (GPIOI)
X#if 1L
N#define EXTI_GPIOI                          0x00000008u
N#endif /* GPIOI */
N#if defined (GPIOJ)
X#if 0L
S#define EXTI_GPIOJ                          0x00000009u
N#endif /* GPIOJ */
N#if defined (GPIOK)
X#if 0L
S#define EXTI_GPIOK                          0x0000000Au
N#endif /* GPIOK */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup EXTI_Exported_Macros EXTI Exported Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private constants --------------------------------------------------------*/
N/** @defgroup EXTI_Private_Constants EXTI Private Constants
N  * @{
N  */
N/**
N  * @brief  EXTI Line property definition
N  */
N#define EXTI_PROPERTY_SHIFT                  24u
N#define EXTI_CONFIG                         (0x02uL << EXTI_PROPERTY_SHIFT)
N#define EXTI_GPIO                           ((0x04uL << EXTI_PROPERTY_SHIFT) | EXTI_CONFIG)
N#define EXTI_RESERVED                       (0x08uL << EXTI_PROPERTY_SHIFT)
N#define EXTI_PROPERTY_MASK                  (EXTI_CONFIG | EXTI_GPIO)
N
N/**
N  * @brief  EXTI bit usage
N  */
N#define EXTI_PIN_MASK                       0x0000001Fu
N
N/**
N  * @brief  EXTI Mask for interrupt & event mode
N  */
N#define EXTI_MODE_MASK                      (EXTI_MODE_EVENT | EXTI_MODE_INTERRUPT)
N
N/**
N  * @brief  EXTI Mask for trigger possibilities
N  */
N#define EXTI_TRIGGER_MASK                   (EXTI_TRIGGER_RISING | EXTI_TRIGGER_FALLING)
N
N/**
N  * @brief  EXTI Line number
N  */
N#if defined(EXTI_IMR_IM23)
X#if 0L
S#define EXTI_LINE_NB                        24UL
N#else
N#define EXTI_LINE_NB                        23UL
N#endif /* EXTI_IMR_IM23 */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup EXTI_Private_Macros EXTI Private Macros
N  * @{
N  */
N#define IS_EXTI_LINE(__EXTI_LINE__)          ((((__EXTI_LINE__) & ~(EXTI_PROPERTY_MASK | EXTI_PIN_MASK)) == 0x00u) && \
N                                             ((((__EXTI_LINE__) & EXTI_PROPERTY_MASK) == EXTI_CONFIG)              || \
N                                              (((__EXTI_LINE__) & EXTI_PROPERTY_MASK) == EXTI_GPIO))               && \
N                                              (((__EXTI_LINE__) & EXTI_PIN_MASK) < EXTI_LINE_NB))
X#define IS_EXTI_LINE(__EXTI_LINE__)          ((((__EXTI_LINE__) & ~(EXTI_PROPERTY_MASK | EXTI_PIN_MASK)) == 0x00u) &&                                              ((((__EXTI_LINE__) & EXTI_PROPERTY_MASK) == EXTI_CONFIG)              ||                                               (((__EXTI_LINE__) & EXTI_PROPERTY_MASK) == EXTI_GPIO))               &&                                               (((__EXTI_LINE__) & EXTI_PIN_MASK) < EXTI_LINE_NB))
N
N#define IS_EXTI_MODE(__EXTI_LINE__)          ((((__EXTI_LINE__) & EXTI_MODE_MASK) != 0x00u) && \
N                                              (((__EXTI_LINE__) & ~EXTI_MODE_MASK) == 0x00u))
X#define IS_EXTI_MODE(__EXTI_LINE__)          ((((__EXTI_LINE__) & EXTI_MODE_MASK) != 0x00u) &&                                               (((__EXTI_LINE__) & ~EXTI_MODE_MASK) == 0x00u))
N
N#define IS_EXTI_TRIGGER(__EXTI_LINE__)       (((__EXTI_LINE__)  & ~EXTI_TRIGGER_MASK) == 0x00u)
N
N#define IS_EXTI_PENDING_EDGE(__EXTI_LINE__)  ((__EXTI_LINE__) == EXTI_TRIGGER_RISING_FALLING)
N
N#define IS_EXTI_CONFIG_LINE(__EXTI_LINE__)   (((__EXTI_LINE__) & EXTI_CONFIG) != 0x00u)
N
N#if !defined (GPIOD)
X#if !1L
S#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) || \
S                                         ((__PORT__) == EXTI_GPIOB) || \
S                                         ((__PORT__) == EXTI_GPIOC) || \
S                                         ((__PORT__) == EXTI_GPIOH))
X#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) ||                                          ((__PORT__) == EXTI_GPIOB) ||                                          ((__PORT__) == EXTI_GPIOC) ||                                          ((__PORT__) == EXTI_GPIOH))
S#elif !defined (GPIOE)
X#elif !1L
S#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) || \
S                                         ((__PORT__) == EXTI_GPIOB) || \
S                                         ((__PORT__) == EXTI_GPIOC) || \
S                                         ((__PORT__) == EXTI_GPIOD) || \
S                                         ((__PORT__) == EXTI_GPIOH))
X#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) ||                                          ((__PORT__) == EXTI_GPIOB) ||                                          ((__PORT__) == EXTI_GPIOC) ||                                          ((__PORT__) == EXTI_GPIOD) ||                                          ((__PORT__) == EXTI_GPIOH))
S#elif !defined (GPIOF)
X#elif !1L
S#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) || \
S                                         ((__PORT__) == EXTI_GPIOB) || \
S                                         ((__PORT__) == EXTI_GPIOC) || \
S                                         ((__PORT__) == EXTI_GPIOD) || \
S                                         ((__PORT__) == EXTI_GPIOE) || \
S                                         ((__PORT__) == EXTI_GPIOH))
X#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) ||                                          ((__PORT__) == EXTI_GPIOB) ||                                          ((__PORT__) == EXTI_GPIOC) ||                                          ((__PORT__) == EXTI_GPIOD) ||                                          ((__PORT__) == EXTI_GPIOE) ||                                          ((__PORT__) == EXTI_GPIOH))
S#elif !defined (GPIOI)
X#elif !1L
S#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) || \
S                                         ((__PORT__) == EXTI_GPIOB) || \
S                                         ((__PORT__) == EXTI_GPIOC) || \
S                                         ((__PORT__) == EXTI_GPIOD) || \
S                                         ((__PORT__) == EXTI_GPIOE) || \
S                                         ((__PORT__) == EXTI_GPIOF) || \
S                                         ((__PORT__) == EXTI_GPIOG) || \
S                                         ((__PORT__) == EXTI_GPIOH))
X#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) ||                                          ((__PORT__) == EXTI_GPIOB) ||                                          ((__PORT__) == EXTI_GPIOC) ||                                          ((__PORT__) == EXTI_GPIOD) ||                                          ((__PORT__) == EXTI_GPIOE) ||                                          ((__PORT__) == EXTI_GPIOF) ||                                          ((__PORT__) == EXTI_GPIOG) ||                                          ((__PORT__) == EXTI_GPIOH))
N#elif !defined (GPIOJ)
X#elif !0L
N#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) || \
N                                         ((__PORT__) == EXTI_GPIOB) || \
N                                         ((__PORT__) == EXTI_GPIOC) || \
N                                         ((__PORT__) == EXTI_GPIOD) || \
N                                         ((__PORT__) == EXTI_GPIOE) || \
N                                         ((__PORT__) == EXTI_GPIOF) || \
N                                         ((__PORT__) == EXTI_GPIOG) || \
N                                         ((__PORT__) == EXTI_GPIOH) || \
N                                         ((__PORT__) == EXTI_GPIOI))
X#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) ||                                          ((__PORT__) == EXTI_GPIOB) ||                                          ((__PORT__) == EXTI_GPIOC) ||                                          ((__PORT__) == EXTI_GPIOD) ||                                          ((__PORT__) == EXTI_GPIOE) ||                                          ((__PORT__) == EXTI_GPIOF) ||                                          ((__PORT__) == EXTI_GPIOG) ||                                          ((__PORT__) == EXTI_GPIOH) ||                                          ((__PORT__) == EXTI_GPIOI))
N#else
S#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) || \
S                                         ((__PORT__) == EXTI_GPIOB) || \
S                                         ((__PORT__) == EXTI_GPIOC) || \
S                                         ((__PORT__) == EXTI_GPIOD) || \
S                                         ((__PORT__) == EXTI_GPIOE) || \
S                                         ((__PORT__) == EXTI_GPIOF) || \
S                                         ((__PORT__) == EXTI_GPIOG) || \
S                                         ((__PORT__) == EXTI_GPIOH) || \
S                                         ((__PORT__) == EXTI_GPIOI) || \
S                                         ((__PORT__) == EXTI_GPIOJ) || \
S                                         ((__PORT__) == EXTI_GPIOK))
X#define IS_EXTI_GPIO_PORT(__PORT__)     (((__PORT__) == EXTI_GPIOA) ||                                          ((__PORT__) == EXTI_GPIOB) ||                                          ((__PORT__) == EXTI_GPIOC) ||                                          ((__PORT__) == EXTI_GPIOD) ||                                          ((__PORT__) == EXTI_GPIOE) ||                                          ((__PORT__) == EXTI_GPIOF) ||                                          ((__PORT__) == EXTI_GPIOG) ||                                          ((__PORT__) == EXTI_GPIOH) ||                                          ((__PORT__) == EXTI_GPIOI) ||                                          ((__PORT__) == EXTI_GPIOJ) ||                                          ((__PORT__) == EXTI_GPIOK))
N#endif /* GPIOD */
N
N#define IS_EXTI_GPIO_PIN(__PIN__)       ((__PIN__) < 16U)
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup EXTI_Exported_Functions EXTI Exported Functions
N  * @brief    EXTI Exported Functions
N  * @{
N  */
N
N/** @defgroup EXTI_Exported_Functions_Group1 Configuration functions
N  * @brief    Configuration functions
N  * @{
N  */
N/* Configuration functions ****************************************************/
NHAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig);
NHAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig);
NHAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti);
NHAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void));
NHAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine);
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_Exported_Functions_Group2 IO operation functions
N  * @brief    IO operation functions
N  * @{
N  */
N/* IO operation functions *****************************************************/
Nvoid HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti);
Nuint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge);
Nvoid HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge);
Nvoid HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* STM32f4xx_HAL_EXTI_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 284 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_EXTI_MODULE_ENABLED */
N
N#ifdef HAL_DMA_MODULE_ENABLED
N  #include "stm32f4xx_hal_dma.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_dma.h
N  * @author  MCD Application Team
N  * @brief   Header file of DMA HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_DMA_H
N#define __STM32F4xx_HAL_DMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DMA
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Types DMA Exported Types
N  * @brief    DMA Exported Types 
N  * @{
N  */
N   
N/** 
N  * @brief  DMA Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t Channel;              /*!< Specifies the channel used for the specified stream. 
N                                      This parameter can be a value of @ref DMA_Channel_selection                    */
N
N  uint32_t Direction;            /*!< Specifies if the data will be transferred from memory to peripheral, 
N                                      from memory to memory or from peripheral to memory.
N                                      This parameter can be a value of @ref DMA_Data_transfer_direction              */
N
N  uint32_t PeriphInc;            /*!< Specifies whether the Peripheral address register should be incremented or not.
N                                      This parameter can be a value of @ref DMA_Peripheral_incremented_mode          */
N
N  uint32_t MemInc;               /*!< Specifies whether the memory address register should be incremented or not.
N                                      This parameter can be a value of @ref DMA_Memory_incremented_mode              */
N
N  uint32_t PeriphDataAlignment;  /*!< Specifies the Peripheral data width.
N                                      This parameter can be a value of @ref DMA_Peripheral_data_size                 */
N
N  uint32_t MemDataAlignment;     /*!< Specifies the Memory data width.
N                                      This parameter can be a value of @ref DMA_Memory_data_size                     */
N
N  uint32_t Mode;                 /*!< Specifies the operation mode of the DMAy Streamx.
N                                      This parameter can be a value of @ref DMA_mode
N                                      @note The circular buffer mode cannot be used if the memory-to-memory
N                                            data transfer is configured on the selected Stream                        */
N
N  uint32_t Priority;             /*!< Specifies the software priority for the DMAy Streamx.
N                                      This parameter can be a value of @ref DMA_Priority_level                       */
N
N  uint32_t FIFOMode;             /*!< Specifies if the FIFO mode or Direct mode will be used for the specified stream.
N                                      This parameter can be a value of @ref DMA_FIFO_direct_mode
N                                      @note The Direct mode (FIFO mode disabled) cannot be used if the 
N                                            memory-to-memory data transfer is configured on the selected stream       */
N
N  uint32_t FIFOThreshold;        /*!< Specifies the FIFO threshold level.
N                                      This parameter can be a value of @ref DMA_FIFO_threshold_level                  */
N
N  uint32_t MemBurst;             /*!< Specifies the Burst transfer configuration for the memory transfers. 
N                                      It specifies the amount of data to be transferred in a single non interruptible
N                                      transaction.
N                                      This parameter can be a value of @ref DMA_Memory_burst 
N                                      @note The burst mode is possible only if the address Increment mode is enabled. */
N
N  uint32_t PeriphBurst;          /*!< Specifies the Burst transfer configuration for the peripheral transfers. 
N                                      It specifies the amount of data to be transferred in a single non interruptible 
N                                      transaction. 
N                                      This parameter can be a value of @ref DMA_Peripheral_burst
N                                      @note The burst mode is possible only if the address Increment mode is enabled. */
N}DMA_InitTypeDef;
N
N
N/** 
N  * @brief  HAL DMA State structures definition
N  */
Ntypedef enum
N{
N  HAL_DMA_STATE_RESET             = 0x00U,  /*!< DMA not yet initialized or disabled */
N  HAL_DMA_STATE_READY             = 0x01U,  /*!< DMA initialized and ready for use   */
N  HAL_DMA_STATE_BUSY              = 0x02U,  /*!< DMA process is ongoing              */
N  HAL_DMA_STATE_TIMEOUT           = 0x03U,  /*!< DMA timeout state                   */
N  HAL_DMA_STATE_ERROR             = 0x04U,  /*!< DMA error state                     */
N  HAL_DMA_STATE_ABORT             = 0x05U,  /*!< DMA Abort state                     */
N}HAL_DMA_StateTypeDef;
N
N/** 
N  * @brief  HAL DMA Error Code structure definition
N  */
Ntypedef enum
N{
N  HAL_DMA_FULL_TRANSFER           = 0x00U,  /*!< Full transfer     */
N  HAL_DMA_HALF_TRANSFER           = 0x01U   /*!< Half Transfer     */
N}HAL_DMA_LevelCompleteTypeDef;
N
N/** 
N  * @brief  HAL DMA Error Code structure definition
N  */
Ntypedef enum
N{
N  HAL_DMA_XFER_CPLT_CB_ID         = 0x00U,  /*!< Full transfer     */
N  HAL_DMA_XFER_HALFCPLT_CB_ID     = 0x01U,  /*!< Half Transfer     */
N  HAL_DMA_XFER_M1CPLT_CB_ID       = 0x02U,  /*!< M1 Full Transfer  */
N  HAL_DMA_XFER_M1HALFCPLT_CB_ID   = 0x03U,  /*!< M1 Half Transfer  */
N  HAL_DMA_XFER_ERROR_CB_ID        = 0x04U,  /*!< Error             */
N  HAL_DMA_XFER_ABORT_CB_ID        = 0x05U,  /*!< Abort             */
N  HAL_DMA_XFER_ALL_CB_ID          = 0x06U   /*!< All               */
N}HAL_DMA_CallbackIDTypeDef;
N
N/** 
N  * @brief  DMA handle Structure definition
N  */
Ntypedef struct __DMA_HandleTypeDef
N{
N  DMA_Stream_TypeDef         *Instance;                                                        /*!< Register base address                  */
N
N  DMA_InitTypeDef            Init;                                                             /*!< DMA communication parameters           */ 
N
N  HAL_LockTypeDef            Lock;                                                             /*!< DMA locking object                     */  
N
N  __IO HAL_DMA_StateTypeDef  State;                                                            /*!< DMA transfer state                     */
X  volatile HAL_DMA_StateTypeDef  State;                                                             
N
N  void                       *Parent;                                                          /*!< Parent object state                    */ 
N
N  void                       (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma);         /*!< DMA transfer complete callback         */
N
N  void                       (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);     /*!< DMA Half transfer complete callback    */
N
N  void                       (* XferM1CpltCallback)( struct __DMA_HandleTypeDef * hdma);       /*!< DMA transfer complete Memory1 callback */
N  
N  void                       (* XferM1HalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);   /*!< DMA transfer Half complete Memory1 callback */
N  
N  void                       (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma);        /*!< DMA transfer error callback            */
N  
N  void                       (* XferAbortCallback)( struct __DMA_HandleTypeDef * hdma);        /*!< DMA transfer Abort callback            */  
N
N  __IO uint32_t              ErrorCode;                                                        /*!< DMA Error code                          */
X  volatile uint32_t              ErrorCode;                                                         
N  
N  uint32_t                   StreamBaseAddress;                                                /*!< DMA Stream Base Address                */
N
N  uint32_t                   StreamIndex;                                                      /*!< DMA Stream Index                       */
N 
N}DMA_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Constants DMA Exported Constants
N  * @brief    DMA Exported constants 
N  * @{
N  */
N
N/** @defgroup DMA_Error_Code DMA Error Code
N  * @brief    DMA Error Code 
N  * @{
N  */ 
N#define HAL_DMA_ERROR_NONE            0x00000000U    /*!< No error                               */
N#define HAL_DMA_ERROR_TE              0x00000001U    /*!< Transfer error                         */
N#define HAL_DMA_ERROR_FE              0x00000002U    /*!< FIFO error                             */
N#define HAL_DMA_ERROR_DME             0x00000004U    /*!< Direct Mode error                      */
N#define HAL_DMA_ERROR_TIMEOUT         0x00000020U    /*!< Timeout error                          */
N#define HAL_DMA_ERROR_PARAM           0x00000040U    /*!< Parameter error                        */
N#define HAL_DMA_ERROR_NO_XFER         0x00000080U    /*!< Abort requested with no Xfer ongoing   */
N#define HAL_DMA_ERROR_NOT_SUPPORTED   0x00000100U    /*!< Not supported mode                     */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Channel_selection DMA Channel selection
N  * @brief    DMA channel selection 
N  * @{
N  */ 
N#define DMA_CHANNEL_0                 0x00000000U    /*!< DMA Channel 0 */
N#define DMA_CHANNEL_1                 0x02000000U    /*!< DMA Channel 1 */
N#define DMA_CHANNEL_2                 0x04000000U    /*!< DMA Channel 2 */
N#define DMA_CHANNEL_3                 0x06000000U    /*!< DMA Channel 3 */
N#define DMA_CHANNEL_4                 0x08000000U    /*!< DMA Channel 4 */
N#define DMA_CHANNEL_5                 0x0A000000U    /*!< DMA Channel 5 */
N#define DMA_CHANNEL_6                 0x0C000000U    /*!< DMA Channel 6 */
N#define DMA_CHANNEL_7                 0x0E000000U    /*!< DMA Channel 7 */
N#if defined (DMA_SxCR_CHSEL_3)
X#if 0L
S#define DMA_CHANNEL_8                 0x10000000U    /*!< DMA Channel 8 */
S#define DMA_CHANNEL_9                 0x12000000U    /*!< DMA Channel 9 */
S#define DMA_CHANNEL_10                0x14000000U    /*!< DMA Channel 10 */
S#define DMA_CHANNEL_11                0x16000000U    /*!< DMA Channel 11 */
S#define DMA_CHANNEL_12                0x18000000U    /*!< DMA Channel 12 */
S#define DMA_CHANNEL_13                0x1A000000U    /*!< DMA Channel 13 */
S#define DMA_CHANNEL_14                0x1C000000U    /*!< DMA Channel 14 */
S#define DMA_CHANNEL_15                0x1E000000U    /*!< DMA Channel 15 */
N#endif /* DMA_SxCR_CHSEL_3 */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Data_transfer_direction DMA Data transfer direction
N  * @brief    DMA data transfer direction 
N  * @{
N  */ 
N#define DMA_PERIPH_TO_MEMORY          0x00000000U                 /*!< Peripheral to memory direction */
N#define DMA_MEMORY_TO_PERIPH          ((uint32_t)DMA_SxCR_DIR_0)  /*!< Memory to peripheral direction */
N#define DMA_MEMORY_TO_MEMORY          ((uint32_t)DMA_SxCR_DIR_1)  /*!< Memory to memory direction     */
N/**
N  * @}
N  */
N        
N/** @defgroup DMA_Peripheral_incremented_mode DMA Peripheral incremented mode
N  * @brief    DMA peripheral incremented mode 
N  * @{
N  */ 
N#define DMA_PINC_ENABLE               ((uint32_t)DMA_SxCR_PINC)   /*!< Peripheral increment mode enable  */
N#define DMA_PINC_DISABLE              0x00000000U                 /*!< Peripheral increment mode disable */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_incremented_mode DMA Memory incremented mode
N  * @brief    DMA memory incremented mode 
N  * @{
N  */ 
N#define DMA_MINC_ENABLE               ((uint32_t)DMA_SxCR_MINC)   /*!< Memory increment mode enable  */
N#define DMA_MINC_DISABLE              0x00000000U                 /*!< Memory increment mode disable */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Peripheral_data_size DMA Peripheral data size
N  * @brief    DMA peripheral data size 
N  * @{
N  */ 
N#define DMA_PDATAALIGN_BYTE           0x00000000U                  /*!< Peripheral data alignment: Byte     */
N#define DMA_PDATAALIGN_HALFWORD       ((uint32_t)DMA_SxCR_PSIZE_0) /*!< Peripheral data alignment: HalfWord */
N#define DMA_PDATAALIGN_WORD           ((uint32_t)DMA_SxCR_PSIZE_1) /*!< Peripheral data alignment: Word     */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_data_size DMA Memory data size
N  * @brief    DMA memory data size 
N  * @{ 
N  */
N#define DMA_MDATAALIGN_BYTE           0x00000000U                  /*!< Memory data alignment: Byte     */
N#define DMA_MDATAALIGN_HALFWORD       ((uint32_t)DMA_SxCR_MSIZE_0) /*!< Memory data alignment: HalfWord */
N#define DMA_MDATAALIGN_WORD           ((uint32_t)DMA_SxCR_MSIZE_1) /*!< Memory data alignment: Word     */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_mode DMA mode
N  * @brief    DMA mode 
N  * @{
N  */ 
N#define DMA_NORMAL                    0x00000000U                  /*!< Normal mode                  */
N#define DMA_CIRCULAR                  ((uint32_t)DMA_SxCR_CIRC)    /*!< Circular mode                */
N#define DMA_PFCTRL                    ((uint32_t)DMA_SxCR_PFCTRL)  /*!< Peripheral flow control mode */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Priority_level DMA Priority level
N  * @brief    DMA priority levels 
N  * @{
N  */
N#define DMA_PRIORITY_LOW              0x00000000U                 /*!< Priority level: Low       */
N#define DMA_PRIORITY_MEDIUM           ((uint32_t)DMA_SxCR_PL_0)   /*!< Priority level: Medium    */
N#define DMA_PRIORITY_HIGH             ((uint32_t)DMA_SxCR_PL_1)   /*!< Priority level: High      */
N#define DMA_PRIORITY_VERY_HIGH        ((uint32_t)DMA_SxCR_PL)     /*!< Priority level: Very High */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_FIFO_direct_mode DMA FIFO direct mode
N  * @brief    DMA FIFO direct mode
N  * @{
N  */
N#define DMA_FIFOMODE_DISABLE          0x00000000U                 /*!< FIFO mode disable */
N#define DMA_FIFOMODE_ENABLE           ((uint32_t)DMA_SxFCR_DMDIS) /*!< FIFO mode enable  */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_FIFO_threshold_level DMA FIFO threshold level
N  * @brief    DMA FIFO level 
N  * @{
N  */
N#define DMA_FIFO_THRESHOLD_1QUARTERFULL       0x00000000U                  /*!< FIFO threshold 1 quart full configuration  */
N#define DMA_FIFO_THRESHOLD_HALFFULL           ((uint32_t)DMA_SxFCR_FTH_0)  /*!< FIFO threshold half full configuration     */
N#define DMA_FIFO_THRESHOLD_3QUARTERSFULL      ((uint32_t)DMA_SxFCR_FTH_1)  /*!< FIFO threshold 3 quarts full configuration */
N#define DMA_FIFO_THRESHOLD_FULL               ((uint32_t)DMA_SxFCR_FTH)    /*!< FIFO threshold full configuration          */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_burst DMA Memory burst
N  * @brief    DMA memory burst 
N  * @{
N  */ 
N#define DMA_MBURST_SINGLE             0x00000000U
N#define DMA_MBURST_INC4               ((uint32_t)DMA_SxCR_MBURST_0)  
N#define DMA_MBURST_INC8               ((uint32_t)DMA_SxCR_MBURST_1)  
N#define DMA_MBURST_INC16              ((uint32_t)DMA_SxCR_MBURST)  
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Peripheral_burst DMA Peripheral burst
N  * @brief    DMA peripheral burst 
N  * @{
N  */ 
N#define DMA_PBURST_SINGLE             0x00000000U
N#define DMA_PBURST_INC4               ((uint32_t)DMA_SxCR_PBURST_0)
N#define DMA_PBURST_INC8               ((uint32_t)DMA_SxCR_PBURST_1)
N#define DMA_PBURST_INC16              ((uint32_t)DMA_SxCR_PBURST)
N/**
N  * @}
N  */
N
N/** @defgroup DMA_interrupt_enable_definitions DMA interrupt enable definitions
N  * @brief    DMA interrupts definition 
N  * @{
N  */
N#define DMA_IT_TC                     ((uint32_t)DMA_SxCR_TCIE)
N#define DMA_IT_HT                     ((uint32_t)DMA_SxCR_HTIE)
N#define DMA_IT_TE                     ((uint32_t)DMA_SxCR_TEIE)
N#define DMA_IT_DME                    ((uint32_t)DMA_SxCR_DMEIE)
N#define DMA_IT_FE                     0x00000080U
N/**
N  * @}
N  */
N
N/** @defgroup DMA_flag_definitions DMA flag definitions
N  * @brief    DMA flag definitions 
N  * @{
N  */ 
N#define DMA_FLAG_FEIF0_4              0x00000001U
N#define DMA_FLAG_DMEIF0_4             0x00000004U
N#define DMA_FLAG_TEIF0_4              0x00000008U
N#define DMA_FLAG_HTIF0_4              0x00000010U
N#define DMA_FLAG_TCIF0_4              0x00000020U
N#define DMA_FLAG_FEIF1_5              0x00000040U
N#define DMA_FLAG_DMEIF1_5             0x00000100U
N#define DMA_FLAG_TEIF1_5              0x00000200U
N#define DMA_FLAG_HTIF1_5              0x00000400U
N#define DMA_FLAG_TCIF1_5              0x00000800U
N#define DMA_FLAG_FEIF2_6              0x00010000U
N#define DMA_FLAG_DMEIF2_6             0x00040000U
N#define DMA_FLAG_TEIF2_6              0x00080000U
N#define DMA_FLAG_HTIF2_6              0x00100000U
N#define DMA_FLAG_TCIF2_6              0x00200000U
N#define DMA_FLAG_FEIF3_7              0x00400000U
N#define DMA_FLAG_DMEIF3_7             0x01000000U
N#define DMA_FLAG_TEIF3_7              0x02000000U
N#define DMA_FLAG_HTIF3_7              0x04000000U
N#define DMA_FLAG_TCIF3_7              0x08000000U
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N 
N/* Exported macro ------------------------------------------------------------*/
N
N/** @brief Reset DMA handle state
N  * @param  __HANDLE__ specifies the DMA handle.
N  * @retval None
N  */
N#define __HAL_DMA_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DMA_STATE_RESET)
N
N/**
N  * @brief  Return the current DMA Stream FIFO filled level.
N  * @param  __HANDLE__ DMA handle
N  * @retval The FIFO filling state.
N  *           - DMA_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
N  *                                              and not empty.
N  *           - DMA_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
N  *           - DMA_FIFOStatus_HalfFull: if more than 1 half-full.
N  *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
N  *           - DMA_FIFOStatus_Empty: when FIFO is empty
N  *           - DMA_FIFOStatus_Full: when FIFO is full
N  */
N#define __HAL_DMA_GET_FS(__HANDLE__)      (((__HANDLE__)->Instance->FCR & (DMA_SxFCR_FS)))
N
N/**
N  * @brief  Enable the specified DMA Stream.
N  * @param  __HANDLE__ DMA handle
N  * @retval None
N  */
N#define __HAL_DMA_ENABLE(__HANDLE__)      ((__HANDLE__)->Instance->CR |=  DMA_SxCR_EN)
N
N/**
N  * @brief  Disable the specified DMA Stream.
N  * @param  __HANDLE__ DMA handle
N  * @retval None
N  */
N#define __HAL_DMA_DISABLE(__HANDLE__)     ((__HANDLE__)->Instance->CR &=  ~DMA_SxCR_EN)
N
N/* Interrupt & Flag management */
N
N/**
N  * @brief  Return the current DMA Stream transfer complete flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified transfer complete flag index.
N  */
N#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) \
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TCIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TCIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TCIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TCIF2_6 :\
N   DMA_FLAG_TCIF3_7)
X#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TCIF2_6 :   DMA_FLAG_TCIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream half transfer complete flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified half transfer complete flag index.
N  */      
N#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_HTIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_HTIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_HTIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_HTIF2_6 :\
N   DMA_FLAG_HTIF3_7)
X#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_HTIF2_6 :   DMA_FLAG_HTIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream transfer error flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified transfer error flag index.
N  */
N#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TEIF2_6 :\
N   DMA_FLAG_TEIF3_7)
X#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TEIF2_6 :   DMA_FLAG_TEIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream FIFO error flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified FIFO error flag index.
N  */
N#define __HAL_DMA_GET_FE_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_FEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_FEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_FEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_FEIF2_6 :\
N   DMA_FLAG_FEIF3_7)
X#define __HAL_DMA_GET_FE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_FEIF2_6 :   DMA_FLAG_FEIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream direct mode error flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified direct mode error flag index.
N  */
N#define __HAL_DMA_GET_DME_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_DMEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_DMEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_DMEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_DMEIF2_6 :\
N   DMA_FLAG_DMEIF3_7)
X#define __HAL_DMA_GET_DME_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_DMEIF2_6 :   DMA_FLAG_DMEIF3_7)
N
N/**
N  * @brief  Get the DMA Stream pending flags.
N  * @param  __HANDLE__ DMA handle
N  * @param  __FLAG__ Get the specified flag.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_FLAG_TCIFx: Transfer complete flag.
N  *            @arg DMA_FLAG_HTIFx: Half transfer complete flag.
N  *            @arg DMA_FLAG_TEIFx: Transfer error flag.
N  *            @arg DMA_FLAG_DMEIFx: Direct mode error flag.
N  *            @arg DMA_FLAG_FEIFx: FIFO error flag.
N  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Stream flag.   
N  * @retval The state of FLAG (SET or RESET).
N  */
N#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)\
N(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HISR & (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LISR & (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HISR & (__FLAG__)) : (DMA1->LISR & (__FLAG__)))
X#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HISR & (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LISR & (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HISR & (__FLAG__)) : (DMA1->LISR & (__FLAG__)))
N
N/**
N  * @brief  Clear the DMA Stream pending flags.
N  * @param  __HANDLE__ DMA handle
N  * @param  __FLAG__ specifies the flag to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_FLAG_TCIFx: Transfer complete flag.
N  *            @arg DMA_FLAG_HTIFx: Half transfer complete flag.
N  *            @arg DMA_FLAG_TEIFx: Transfer error flag.
N  *            @arg DMA_FLAG_DMEIFx: Direct mode error flag.
N  *            @arg DMA_FLAG_FEIFx: FIFO error flag.
N  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Stream flag.   
N  * @retval None
N  */
N#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) \
N(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HIFCR = (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LIFCR = (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HIFCR = (__FLAG__)) : (DMA1->LIFCR = (__FLAG__)))
X#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) (((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HIFCR = (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LIFCR = (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HIFCR = (__FLAG__)) : (DMA1->LIFCR = (__FLAG__)))
N
N/**
N  * @brief  Enable the specified DMA Stream interrupts.
N  * @param  __HANDLE__ DMA handle
N  * @param  __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled. 
N  *        This parameter can be any combination of the following values:
N  *           @arg DMA_IT_TC: Transfer complete interrupt mask.
N  *           @arg DMA_IT_HT: Half transfer complete interrupt mask.
N  *           @arg DMA_IT_TE: Transfer error interrupt mask.
N  *           @arg DMA_IT_FE: FIFO error interrupt mask.
N  *           @arg DMA_IT_DME: Direct mode error interrupt.
N  * @retval None
N  */
N#define __HAL_DMA_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((__INTERRUPT__) != DMA_IT_FE)? \
N((__HANDLE__)->Instance->CR |= (__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR |= (__INTERRUPT__)))
X#define __HAL_DMA_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((__INTERRUPT__) != DMA_IT_FE)? ((__HANDLE__)->Instance->CR |= (__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR |= (__INTERRUPT__)))
N
N/**
N  * @brief  Disable the specified DMA Stream interrupts.
N  * @param  __HANDLE__ DMA handle
N  * @param  __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled. 
N  *         This parameter can be any combination of the following values:
N  *            @arg DMA_IT_TC: Transfer complete interrupt mask.
N  *            @arg DMA_IT_HT: Half transfer complete interrupt mask.
N  *            @arg DMA_IT_TE: Transfer error interrupt mask.
N  *            @arg DMA_IT_FE: FIFO error interrupt mask.
N  *            @arg DMA_IT_DME: Direct mode error interrupt.
N  * @retval None
N  */
N#define __HAL_DMA_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)? \
N((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR &= ~(__INTERRUPT__)))
X#define __HAL_DMA_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)? ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR &= ~(__INTERRUPT__)))
N
N/**
N  * @brief  Check whether the specified DMA Stream interrupt is enabled or disabled.
N  * @param  __HANDLE__ DMA handle
N  * @param  __INTERRUPT__ specifies the DMA interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg DMA_IT_TC: Transfer complete interrupt mask.
N  *            @arg DMA_IT_HT: Half transfer complete interrupt mask.
N  *            @arg DMA_IT_TE: Transfer error interrupt mask.
N  *            @arg DMA_IT_FE: FIFO error interrupt mask.
N  *            @arg DMA_IT_DME: Direct mode error interrupt.
N  * @retval The state of DMA_IT.
N  */
N#define __HAL_DMA_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)? \
N                                                        ((__HANDLE__)->Instance->CR & (__INTERRUPT__)) : \
N                                                        ((__HANDLE__)->Instance->FCR & (__INTERRUPT__)))
X#define __HAL_DMA_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)?                                                         ((__HANDLE__)->Instance->CR & (__INTERRUPT__)) :                                                         ((__HANDLE__)->Instance->FCR & (__INTERRUPT__)))
N
N/**
N  * @brief  Writes the number of data units to be transferred on the DMA Stream.
N  * @param  __HANDLE__ DMA handle
N  * @param  __COUNTER__ Number of data units to be transferred (from 0 to 65535) 
N  *          Number of data items depends only on the Peripheral data format.
N  *            
N  * @note   If Peripheral data format is Bytes: number of data units is equal 
N  *         to total number of bytes to be transferred.
N  *           
N  * @note   If Peripheral data format is Half-Word: number of data units is  
N  *         equal to total number of bytes to be transferred / 2.
N  *           
N  * @note   If Peripheral data format is Word: number of data units is equal 
N  *         to total  number of bytes to be transferred / 4.
N  *      
N  * @retval The number of remaining data units in the current DMAy Streamx transfer.
N  */
N#define __HAL_DMA_SET_COUNTER(__HANDLE__, __COUNTER__) ((__HANDLE__)->Instance->NDTR = (uint16_t)(__COUNTER__))
N
N/**
N  * @brief  Returns the number of remaining data units in the current DMAy Streamx transfer.
N  * @param  __HANDLE__ DMA handle
N  *   
N  * @retval The number of remaining data units in the current DMA Stream transfer.
N  */
N#define __HAL_DMA_GET_COUNTER(__HANDLE__) ((__HANDLE__)->Instance->NDTR)
N
N
N/* Include DMA HAL Extension module */
N#include "stm32f4xx_hal_dma_ex.h"   
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_dma_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_dma_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of DMA HAL extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_DMA_EX_H
N#define __STM32F4xx_HAL_DMA_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DMAEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup DMAEx_Exported_Types DMAEx Exported Types
N  * @brief DMAEx Exported types
N  * @{
N  */
N   
N/** 
N  * @brief  HAL DMA Memory definition  
N  */ 
Ntypedef enum
N{
N  MEMORY0      = 0x00U,    /*!< Memory 0     */
N  MEMORY1      = 0x01U     /*!< Memory 1     */
N}HAL_DMA_MemoryTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup DMAEx_Exported_Functions DMAEx Exported Functions
N  * @brief   DMAEx Exported functions
N  * @{
N  */
N
N/** @defgroup DMAEx_Exported_Functions_Group1 Extended features functions
N  * @brief   Extended features functions
N  * @{
N  */
N
N/* IO operation functions *******************************************************/
NHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory);
N
N/**
N  * @}
N  */
N/**
N  * @}
N  */
N         
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup DMAEx_Private_Functions DMAEx Private Functions
N  * @brief DMAEx Private functions
N  * @{
N  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_HAL_DMA_EX_H*/
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 641 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_dma.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Functions DMA Exported Functions
N  * @brief    DMA Exported functions 
N  * @{
N  */
N
N/** @defgroup DMA_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @brief   Initialization and de-initialization functions 
N  * @{
N  */
NHAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma); 
NHAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Exported_Functions_Group2 I/O operation functions
N  * @brief   I/O operation functions  
N  * @{
N  */
NHAL_StatusTypeDef HAL_DMA_Start (DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout);
Nvoid              HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_CleanCallbacks(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma));
NHAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID);
N
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Exported_Functions_Group3 Peripheral State functions
N  * @brief    Peripheral State functions 
N  * @{
N  */
NHAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma);
Nuint32_t             HAL_DMA_GetError(DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */ 
N/**
N  * @}
N  */ 
N/* Private Constants -------------------------------------------------------------*/
N/** @defgroup DMA_Private_Constants DMA Private Constants
N  * @brief    DMA private defines and constants 
N  * @{
N  */
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup DMA_Private_Macros DMA Private Macros
N  * @brief    DMA private macros 
N  * @{
N  */
N#if defined (DMA_SxCR_CHSEL_3)
X#if 0L
S#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) || \
S                                 ((CHANNEL) == DMA_CHANNEL_1) || \
S                                 ((CHANNEL) == DMA_CHANNEL_2) || \
S                                 ((CHANNEL) == DMA_CHANNEL_3) || \
S                                 ((CHANNEL) == DMA_CHANNEL_4) || \
S                                 ((CHANNEL) == DMA_CHANNEL_5) || \
S                                 ((CHANNEL) == DMA_CHANNEL_6) || \
S                                 ((CHANNEL) == DMA_CHANNEL_7) || \
S                                 ((CHANNEL) == DMA_CHANNEL_8) || \
S                                 ((CHANNEL) == DMA_CHANNEL_9) || \
S                                 ((CHANNEL) == DMA_CHANNEL_10)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_11)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_12)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_13)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_14)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_15))
X#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) ||                                  ((CHANNEL) == DMA_CHANNEL_1) ||                                  ((CHANNEL) == DMA_CHANNEL_2) ||                                  ((CHANNEL) == DMA_CHANNEL_3) ||                                  ((CHANNEL) == DMA_CHANNEL_4) ||                                  ((CHANNEL) == DMA_CHANNEL_5) ||                                  ((CHANNEL) == DMA_CHANNEL_6) ||                                  ((CHANNEL) == DMA_CHANNEL_7) ||                                  ((CHANNEL) == DMA_CHANNEL_8) ||                                  ((CHANNEL) == DMA_CHANNEL_9) ||                                  ((CHANNEL) == DMA_CHANNEL_10)||                                  ((CHANNEL) == DMA_CHANNEL_11)||                                  ((CHANNEL) == DMA_CHANNEL_12)||                                  ((CHANNEL) == DMA_CHANNEL_13)||                                  ((CHANNEL) == DMA_CHANNEL_14)||                                  ((CHANNEL) == DMA_CHANNEL_15))
N#else
N#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) || \
N                                 ((CHANNEL) == DMA_CHANNEL_1) || \
N                                 ((CHANNEL) == DMA_CHANNEL_2) || \
N                                 ((CHANNEL) == DMA_CHANNEL_3) || \
N                                 ((CHANNEL) == DMA_CHANNEL_4) || \
N                                 ((CHANNEL) == DMA_CHANNEL_5) || \
N                                 ((CHANNEL) == DMA_CHANNEL_6) || \
N                                 ((CHANNEL) == DMA_CHANNEL_7))
X#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) ||                                  ((CHANNEL) == DMA_CHANNEL_1) ||                                  ((CHANNEL) == DMA_CHANNEL_2) ||                                  ((CHANNEL) == DMA_CHANNEL_3) ||                                  ((CHANNEL) == DMA_CHANNEL_4) ||                                  ((CHANNEL) == DMA_CHANNEL_5) ||                                  ((CHANNEL) == DMA_CHANNEL_6) ||                                  ((CHANNEL) == DMA_CHANNEL_7))
N#endif /* DMA_SxCR_CHSEL_3 */
N
N#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_PERIPH_TO_MEMORY ) || \
N                                     ((DIRECTION) == DMA_MEMORY_TO_PERIPH)  || \
N                                     ((DIRECTION) == DMA_MEMORY_TO_MEMORY)) 
X#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_PERIPH_TO_MEMORY ) ||                                      ((DIRECTION) == DMA_MEMORY_TO_PERIPH)  ||                                      ((DIRECTION) == DMA_MEMORY_TO_MEMORY)) 
N
N#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x01U) && ((SIZE) < 0x10000U))
N
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PINC_ENABLE) || \
N                                            ((STATE) == DMA_PINC_DISABLE))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PINC_ENABLE) ||                                             ((STATE) == DMA_PINC_DISABLE))
N
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MINC_ENABLE)  || \
N                                        ((STATE) == DMA_MINC_DISABLE))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MINC_ENABLE)  ||                                         ((STATE) == DMA_MINC_DISABLE))
N
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PDATAALIGN_BYTE)     || \
N                                           ((SIZE) == DMA_PDATAALIGN_HALFWORD) || \
N                                           ((SIZE) == DMA_PDATAALIGN_WORD))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PDATAALIGN_BYTE)     ||                                            ((SIZE) == DMA_PDATAALIGN_HALFWORD) ||                                            ((SIZE) == DMA_PDATAALIGN_WORD))
N
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MDATAALIGN_BYTE)     || \
N                                       ((SIZE) == DMA_MDATAALIGN_HALFWORD) || \
N                                       ((SIZE) == DMA_MDATAALIGN_WORD ))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MDATAALIGN_BYTE)     ||                                        ((SIZE) == DMA_MDATAALIGN_HALFWORD) ||                                        ((SIZE) == DMA_MDATAALIGN_WORD ))
N
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_NORMAL )  || \
N                           ((MODE) == DMA_CIRCULAR) || \
N                           ((MODE) == DMA_PFCTRL)) 
X#define IS_DMA_MODE(MODE) (((MODE) == DMA_NORMAL )  ||                            ((MODE) == DMA_CIRCULAR) ||                            ((MODE) == DMA_PFCTRL)) 
N
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_PRIORITY_LOW )   || \
N                                   ((PRIORITY) == DMA_PRIORITY_MEDIUM) || \
N                                   ((PRIORITY) == DMA_PRIORITY_HIGH)   || \
N                                   ((PRIORITY) == DMA_PRIORITY_VERY_HIGH)) 
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_PRIORITY_LOW )   ||                                    ((PRIORITY) == DMA_PRIORITY_MEDIUM) ||                                    ((PRIORITY) == DMA_PRIORITY_HIGH)   ||                                    ((PRIORITY) == DMA_PRIORITY_VERY_HIGH)) 
N
N#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMODE_DISABLE ) || \
N                                       ((STATE) == DMA_FIFOMODE_ENABLE))
X#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMODE_DISABLE ) ||                                        ((STATE) == DMA_FIFOMODE_ENABLE))
N
N#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFO_THRESHOLD_1QUARTERFULL ) || \
N                                          ((THRESHOLD) == DMA_FIFO_THRESHOLD_HALFFULL)      || \
N                                          ((THRESHOLD) == DMA_FIFO_THRESHOLD_3QUARTERSFULL) || \
N                                          ((THRESHOLD) == DMA_FIFO_THRESHOLD_FULL))
X#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFO_THRESHOLD_1QUARTERFULL ) ||                                           ((THRESHOLD) == DMA_FIFO_THRESHOLD_HALFFULL)      ||                                           ((THRESHOLD) == DMA_FIFO_THRESHOLD_3QUARTERSFULL) ||                                           ((THRESHOLD) == DMA_FIFO_THRESHOLD_FULL))
N
N#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MBURST_SINGLE) || \
N                                    ((BURST) == DMA_MBURST_INC4)   || \
N                                    ((BURST) == DMA_MBURST_INC8)   || \
N                                    ((BURST) == DMA_MBURST_INC16))
X#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MBURST_SINGLE) ||                                     ((BURST) == DMA_MBURST_INC4)   ||                                     ((BURST) == DMA_MBURST_INC8)   ||                                     ((BURST) == DMA_MBURST_INC16))
N
N#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PBURST_SINGLE) || \
N                                        ((BURST) == DMA_PBURST_INC4)   || \
N                                        ((BURST) == DMA_PBURST_INC8)   || \
N                                        ((BURST) == DMA_PBURST_INC16))
X#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PBURST_SINGLE) ||                                         ((BURST) == DMA_PBURST_INC4)   ||                                         ((BURST) == DMA_PBURST_INC8)   ||                                         ((BURST) == DMA_PBURST_INC16))
N/**
N  * @}
N  */ 
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup DMA_Private_Functions DMA Private Functions
N  * @brief    DMA private  functions 
N  * @{
N  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_DMA_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 288 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_DMA_MODULE_ENABLED */
N
N#ifdef HAL_CORTEX_MODULE_ENABLED
N  #include "stm32f4xx_hal_cortex.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_cortex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_cortex.h
N  * @author  MCD Application Team
N  * @brief   Header file of CORTEX HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_CORTEX_H
N#define __STM32F4xx_HAL_CORTEX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup CORTEX
N  * @{
N  */ 
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup CORTEX_Exported_Types Cortex Exported Types
N  * @{
N  */
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
N/** @defgroup CORTEX_MPU_Region_Initialization_Structure_definition MPU Region Initialization Structure Definition
N  * @brief  MPU Region initialization structure 
N  * @{
N  */
Ntypedef struct
N{
N  uint8_t                Enable;                /*!< Specifies the status of the region. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Enable                 */
N  uint8_t                Number;                /*!< Specifies the number of the region to protect. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Number                 */
N  uint32_t               BaseAddress;           /*!< Specifies the base address of the region to protect.                           */
N  uint8_t                Size;                  /*!< Specifies the size of the region to protect. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Size                   */
N  uint8_t                SubRegionDisable;      /*!< Specifies the number of the subregion protection to disable. 
N                                                     This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF    */         
N  uint8_t                TypeExtField;          /*!< Specifies the TEX field level.
N                                                     This parameter can be a value of @ref CORTEX_MPU_TEX_Levels                    */                 
N  uint8_t                AccessPermission;      /*!< Specifies the region access permission type. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Permission_Attributes  */
N  uint8_t                DisableExec;           /*!< Specifies the instruction access status. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Instruction_Access            */
N  uint8_t                IsShareable;           /*!< Specifies the shareability status of the protected region. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Shareable              */
N  uint8_t                IsCacheable;           /*!< Specifies the cacheable status of the region protected. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Cacheable              */
N  uint8_t                IsBufferable;          /*!< Specifies the bufferable status of the protected region. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Bufferable             */
N}MPU_Region_InitTypeDef;
N/**
N  * @}
N  */
N#endif /* __MPU_PRESENT */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CORTEX_Exported_Constants CORTEX Exported Constants
N  * @{
N  */
N
N/** @defgroup CORTEX_Preemption_Priority_Group CORTEX Preemption Priority Group
N  * @{
N  */
N#define NVIC_PRIORITYGROUP_0         0x00000007U /*!< 0 bits for pre-emption priority
N                                                      4 bits for subpriority */
N#define NVIC_PRIORITYGROUP_1         0x00000006U /*!< 1 bits for pre-emption priority
N                                                      3 bits for subpriority */
N#define NVIC_PRIORITYGROUP_2         0x00000005U /*!< 2 bits for pre-emption priority
N                                                      2 bits for subpriority */
N#define NVIC_PRIORITYGROUP_3         0x00000004U /*!< 3 bits for pre-emption priority
N                                                      1 bits for subpriority */
N#define NVIC_PRIORITYGROUP_4         0x00000003U /*!< 4 bits for pre-emption priority
N                                                      0 bits for subpriority */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_SysTick_clock_source CORTEX _SysTick clock source 
N  * @{
N  */
N#define SYSTICK_CLKSOURCE_HCLK_DIV8    0x00000000U
N#define SYSTICK_CLKSOURCE_HCLK         0x00000004U
N
N/**
N  * @}
N  */
N
N#if (__MPU_PRESENT == 1)
X#if (1U == 1)
N/** @defgroup CORTEX_MPU_HFNMI_PRIVDEF_Control MPU HFNMI and PRIVILEGED Access control
N  * @{
N  */
N#define  MPU_HFNMI_PRIVDEF_NONE           0x00000000U
N#define  MPU_HARDFAULT_NMI                MPU_CTRL_HFNMIENA_Msk
N#define  MPU_PRIVILEGED_DEFAULT           MPU_CTRL_PRIVDEFENA_Msk
N#define  MPU_HFNMI_PRIVDEF               (MPU_CTRL_HFNMIENA_Msk | MPU_CTRL_PRIVDEFENA_Msk)
N
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Region_Enable CORTEX MPU Region Enable
N  * @{
N  */
N#define  MPU_REGION_ENABLE     ((uint8_t)0x01)
N#define  MPU_REGION_DISABLE    ((uint8_t)0x00)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Instruction_Access CORTEX MPU Instruction Access
N  * @{
N  */
N#define  MPU_INSTRUCTION_ACCESS_ENABLE      ((uint8_t)0x00)
N#define  MPU_INSTRUCTION_ACCESS_DISABLE     ((uint8_t)0x01)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Access_Shareable CORTEX MPU Instruction Access Shareable
N  * @{
N  */
N#define  MPU_ACCESS_SHAREABLE        ((uint8_t)0x01)
N#define  MPU_ACCESS_NOT_SHAREABLE    ((uint8_t)0x00)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Access_Cacheable CORTEX MPU Instruction Access Cacheable
N  * @{
N  */
N#define  MPU_ACCESS_CACHEABLE         ((uint8_t)0x01)
N#define  MPU_ACCESS_NOT_CACHEABLE     ((uint8_t)0x00)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Access_Bufferable CORTEX MPU Instruction Access Bufferable
N  * @{
N  */
N#define  MPU_ACCESS_BUFFERABLE         ((uint8_t)0x01)
N#define  MPU_ACCESS_NOT_BUFFERABLE     ((uint8_t)0x00)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_TEX_Levels MPU TEX Levels
N  * @{
N  */
N#define  MPU_TEX_LEVEL0    ((uint8_t)0x00)
N#define  MPU_TEX_LEVEL1    ((uint8_t)0x01)
N#define  MPU_TEX_LEVEL2    ((uint8_t)0x02)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Region_Size CORTEX MPU Region Size
N  * @{
N  */
N#define   MPU_REGION_SIZE_32B      ((uint8_t)0x04)
N#define   MPU_REGION_SIZE_64B      ((uint8_t)0x05)
N#define   MPU_REGION_SIZE_128B     ((uint8_t)0x06)
N#define   MPU_REGION_SIZE_256B     ((uint8_t)0x07)
N#define   MPU_REGION_SIZE_512B     ((uint8_t)0x08)
N#define   MPU_REGION_SIZE_1KB      ((uint8_t)0x09)
N#define   MPU_REGION_SIZE_2KB      ((uint8_t)0x0A)
N#define   MPU_REGION_SIZE_4KB      ((uint8_t)0x0B)
N#define   MPU_REGION_SIZE_8KB      ((uint8_t)0x0C)
N#define   MPU_REGION_SIZE_16KB     ((uint8_t)0x0D)
N#define   MPU_REGION_SIZE_32KB     ((uint8_t)0x0E)
N#define   MPU_REGION_SIZE_64KB     ((uint8_t)0x0F)
N#define   MPU_REGION_SIZE_128KB    ((uint8_t)0x10)
N#define   MPU_REGION_SIZE_256KB    ((uint8_t)0x11)
N#define   MPU_REGION_SIZE_512KB    ((uint8_t)0x12)
N#define   MPU_REGION_SIZE_1MB      ((uint8_t)0x13)
N#define   MPU_REGION_SIZE_2MB      ((uint8_t)0x14)
N#define   MPU_REGION_SIZE_4MB      ((uint8_t)0x15)
N#define   MPU_REGION_SIZE_8MB      ((uint8_t)0x16)
N#define   MPU_REGION_SIZE_16MB     ((uint8_t)0x17)
N#define   MPU_REGION_SIZE_32MB     ((uint8_t)0x18)
N#define   MPU_REGION_SIZE_64MB     ((uint8_t)0x19)
N#define   MPU_REGION_SIZE_128MB    ((uint8_t)0x1A)
N#define   MPU_REGION_SIZE_256MB    ((uint8_t)0x1B)
N#define   MPU_REGION_SIZE_512MB    ((uint8_t)0x1C)
N#define   MPU_REGION_SIZE_1GB      ((uint8_t)0x1D)
N#define   MPU_REGION_SIZE_2GB      ((uint8_t)0x1E)
N#define   MPU_REGION_SIZE_4GB      ((uint8_t)0x1F)
N/**
N  * @}
N  */
N   
N/** @defgroup CORTEX_MPU_Region_Permission_Attributes CORTEX MPU Region Permission Attributes 
N  * @{
N  */
N#define  MPU_REGION_NO_ACCESS      ((uint8_t)0x00)
N#define  MPU_REGION_PRIV_RW        ((uint8_t)0x01)
N#define  MPU_REGION_PRIV_RW_URO    ((uint8_t)0x02)
N#define  MPU_REGION_FULL_ACCESS    ((uint8_t)0x03)
N#define  MPU_REGION_PRIV_RO        ((uint8_t)0x05)
N#define  MPU_REGION_PRIV_RO_URO    ((uint8_t)0x06)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Region_Number CORTEX MPU Region Number
N  * @{
N  */
N#define  MPU_REGION_NUMBER0    ((uint8_t)0x00)
N#define  MPU_REGION_NUMBER1    ((uint8_t)0x01)
N#define  MPU_REGION_NUMBER2    ((uint8_t)0x02)
N#define  MPU_REGION_NUMBER3    ((uint8_t)0x03)
N#define  MPU_REGION_NUMBER4    ((uint8_t)0x04)
N#define  MPU_REGION_NUMBER5    ((uint8_t)0x05)
N#define  MPU_REGION_NUMBER6    ((uint8_t)0x06)
N#define  MPU_REGION_NUMBER7    ((uint8_t)0x07)
N/**
N  * @}
N  */
N#endif /* __MPU_PRESENT */
N
N/**
N  * @}
N  */
N
N
N/* Exported Macros -----------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup CORTEX_Exported_Functions
N  * @{
N  */
N  
N/** @addtogroup CORTEX_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
Nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup);
Nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);
Nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_SystemReset(void);
Nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb);
N/**
N  * @}
N  */
N
N/** @addtogroup CORTEX_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions ***********************************************/
Nuint32_t HAL_NVIC_GetPriorityGrouping(void);
Nvoid HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority);
Nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn);
Nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn);
Nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource);
Nvoid HAL_SYSTICK_IRQHandler(void);
Nvoid HAL_SYSTICK_Callback(void);
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
Nvoid HAL_MPU_Enable(uint32_t MPU_Control);
Nvoid HAL_MPU_Disable(void);
Nvoid HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init);
N#endif /* __MPU_PRESENT */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup CORTEX_Private_Macros CORTEX Private Macros
N  * @{
N  */
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PRIORITYGROUP_0) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_1) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_2) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_3) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PRIORITYGROUP_0) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_1) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_2) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_3) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10U)
N
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)         ((PRIORITY) < 0x10U)
N
N#define IS_NVIC_DEVICE_IRQ(IRQ)                ((IRQ) >= (IRQn_Type)0x00U)
N
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) || \
N                                       ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) ||                                        ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
N#define IS_MPU_REGION_ENABLE(STATE) (((STATE) == MPU_REGION_ENABLE) || \
N                                     ((STATE) == MPU_REGION_DISABLE))
X#define IS_MPU_REGION_ENABLE(STATE) (((STATE) == MPU_REGION_ENABLE) ||                                      ((STATE) == MPU_REGION_DISABLE))
N
N#define IS_MPU_INSTRUCTION_ACCESS(STATE) (((STATE) == MPU_INSTRUCTION_ACCESS_ENABLE) || \
N                                          ((STATE) == MPU_INSTRUCTION_ACCESS_DISABLE))
X#define IS_MPU_INSTRUCTION_ACCESS(STATE) (((STATE) == MPU_INSTRUCTION_ACCESS_ENABLE) ||                                           ((STATE) == MPU_INSTRUCTION_ACCESS_DISABLE))
N
N#define IS_MPU_ACCESS_SHAREABLE(STATE)   (((STATE) == MPU_ACCESS_SHAREABLE) || \
N                                          ((STATE) == MPU_ACCESS_NOT_SHAREABLE))
X#define IS_MPU_ACCESS_SHAREABLE(STATE)   (((STATE) == MPU_ACCESS_SHAREABLE) ||                                           ((STATE) == MPU_ACCESS_NOT_SHAREABLE))
N
N#define IS_MPU_ACCESS_CACHEABLE(STATE)   (((STATE) == MPU_ACCESS_CACHEABLE) || \
N                                          ((STATE) == MPU_ACCESS_NOT_CACHEABLE))
X#define IS_MPU_ACCESS_CACHEABLE(STATE)   (((STATE) == MPU_ACCESS_CACHEABLE) ||                                           ((STATE) == MPU_ACCESS_NOT_CACHEABLE))
N
N#define IS_MPU_ACCESS_BUFFERABLE(STATE)   (((STATE) == MPU_ACCESS_BUFFERABLE) || \
N                                          ((STATE) == MPU_ACCESS_NOT_BUFFERABLE))
X#define IS_MPU_ACCESS_BUFFERABLE(STATE)   (((STATE) == MPU_ACCESS_BUFFERABLE) ||                                           ((STATE) == MPU_ACCESS_NOT_BUFFERABLE))
N
N#define IS_MPU_TEX_LEVEL(TYPE) (((TYPE) == MPU_TEX_LEVEL0)  || \
N                                ((TYPE) == MPU_TEX_LEVEL1)  || \
N                                ((TYPE) == MPU_TEX_LEVEL2))
X#define IS_MPU_TEX_LEVEL(TYPE) (((TYPE) == MPU_TEX_LEVEL0)  ||                                 ((TYPE) == MPU_TEX_LEVEL1)  ||                                 ((TYPE) == MPU_TEX_LEVEL2))
N
N#define IS_MPU_REGION_PERMISSION_ATTRIBUTE(TYPE) (((TYPE) == MPU_REGION_NO_ACCESS)   || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RW)     || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RW_URO) || \
N                                                  ((TYPE) == MPU_REGION_FULL_ACCESS) || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RO)     || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RO_URO))
X#define IS_MPU_REGION_PERMISSION_ATTRIBUTE(TYPE) (((TYPE) == MPU_REGION_NO_ACCESS)   ||                                                   ((TYPE) == MPU_REGION_PRIV_RW)     ||                                                   ((TYPE) == MPU_REGION_PRIV_RW_URO) ||                                                   ((TYPE) == MPU_REGION_FULL_ACCESS) ||                                                   ((TYPE) == MPU_REGION_PRIV_RO)     ||                                                   ((TYPE) == MPU_REGION_PRIV_RO_URO))
N
N#define IS_MPU_REGION_NUMBER(NUMBER)    (((NUMBER) == MPU_REGION_NUMBER0) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER1) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER2) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER3) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER4) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER5) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER6) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER7))
X#define IS_MPU_REGION_NUMBER(NUMBER)    (((NUMBER) == MPU_REGION_NUMBER0) ||                                          ((NUMBER) == MPU_REGION_NUMBER1) ||                                          ((NUMBER) == MPU_REGION_NUMBER2) ||                                          ((NUMBER) == MPU_REGION_NUMBER3) ||                                          ((NUMBER) == MPU_REGION_NUMBER4) ||                                          ((NUMBER) == MPU_REGION_NUMBER5) ||                                          ((NUMBER) == MPU_REGION_NUMBER6) ||                                          ((NUMBER) == MPU_REGION_NUMBER7))
N
N#define IS_MPU_REGION_SIZE(SIZE)    (((SIZE) == MPU_REGION_SIZE_32B)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_64B)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_128B)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_256B)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_512B)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_1KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_2KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_4KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_8KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_16KB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_32KB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_64KB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_128KB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_256KB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_512KB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_1MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_2MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_4MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_8MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_16MB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_32MB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_64MB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_128MB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_256MB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_512MB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_1GB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_2GB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_4GB))
X#define IS_MPU_REGION_SIZE(SIZE)    (((SIZE) == MPU_REGION_SIZE_32B)   ||                                      ((SIZE) == MPU_REGION_SIZE_64B)   ||                                      ((SIZE) == MPU_REGION_SIZE_128B)  ||                                      ((SIZE) == MPU_REGION_SIZE_256B)  ||                                      ((SIZE) == MPU_REGION_SIZE_512B)  ||                                      ((SIZE) == MPU_REGION_SIZE_1KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_2KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_4KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_8KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_16KB)  ||                                      ((SIZE) == MPU_REGION_SIZE_32KB)  ||                                      ((SIZE) == MPU_REGION_SIZE_64KB)  ||                                      ((SIZE) == MPU_REGION_SIZE_128KB) ||                                      ((SIZE) == MPU_REGION_SIZE_256KB) ||                                      ((SIZE) == MPU_REGION_SIZE_512KB) ||                                      ((SIZE) == MPU_REGION_SIZE_1MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_2MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_4MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_8MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_16MB)  ||                                      ((SIZE) == MPU_REGION_SIZE_32MB)  ||                                      ((SIZE) == MPU_REGION_SIZE_64MB)  ||                                      ((SIZE) == MPU_REGION_SIZE_128MB) ||                                      ((SIZE) == MPU_REGION_SIZE_256MB) ||                                      ((SIZE) == MPU_REGION_SIZE_512MB) ||                                      ((SIZE) == MPU_REGION_SIZE_1GB)   ||                                      ((SIZE) == MPU_REGION_SIZE_2GB)   ||                                      ((SIZE) == MPU_REGION_SIZE_4GB))
N
N#define IS_MPU_SUB_REGION_DISABLE(SUBREGION)  ((SUBREGION) < (uint16_t)0x00FF)
N#endif /* __MPU_PRESENT */
N
N/**                                                                          
N  * @}                                                                  
N  */
N
N/* Private functions ---------------------------------------------------------*/
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_CORTEX_H */
N 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 292 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_CORTEX_MODULE_ENABLED */
N
N#ifdef HAL_ADC_MODULE_ENABLED
S  #include "stm32f4xx_hal_adc.h"
N#endif /* HAL_ADC_MODULE_ENABLED */
N
N#ifdef HAL_CAN_MODULE_ENABLED
N  #include "stm32f4xx_hal_can.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_can.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_can.h
N  * @author  MCD Application Team
N  * @brief   Header file of CAN HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32F4xx_HAL_CAN_H
N#define STM32F4xx_HAL_CAN_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N#if defined (CAN1)
X#if 1L
N/** @addtogroup CAN
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup CAN_Exported_Types CAN Exported Types
N  * @{
N  */
N/**
N  * @brief  HAL State structures definition
N  */
Ntypedef enum
N{
N  HAL_CAN_STATE_RESET             = 0x00U,  /*!< CAN not yet initialized or disabled */
N  HAL_CAN_STATE_READY             = 0x01U,  /*!< CAN initialized and ready for use   */
N  HAL_CAN_STATE_LISTENING         = 0x02U,  /*!< CAN receive process is ongoing      */
N  HAL_CAN_STATE_SLEEP_PENDING     = 0x03U,  /*!< CAN sleep request is pending        */
N  HAL_CAN_STATE_SLEEP_ACTIVE      = 0x04U,  /*!< CAN sleep mode is active            */
N  HAL_CAN_STATE_ERROR             = 0x05U   /*!< CAN error state                     */
N
N} HAL_CAN_StateTypeDef;
N
N/**
N  * @brief  CAN init structure definition
N  */
Ntypedef struct
N{
N  uint32_t Prescaler;                  /*!< Specifies the length of a time quantum.
N                                            This parameter must be a number between Min_Data = 1 and Max_Data = 1024. */
N
N  uint32_t Mode;                       /*!< Specifies the CAN operating mode.
N                                            This parameter can be a value of @ref CAN_operating_mode */
N
N  uint32_t SyncJumpWidth;              /*!< Specifies the maximum number of time quanta the CAN hardware
N                                            is allowed to lengthen or shorten a bit to perform resynchronization.
N                                            This parameter can be a value of @ref CAN_synchronisation_jump_width */
N
N  uint32_t TimeSeg1;                   /*!< Specifies the number of time quanta in Bit Segment 1.
N                                            This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_1 */
N
N  uint32_t TimeSeg2;                   /*!< Specifies the number of time quanta in Bit Segment 2.
N                                            This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_2 */
N
N  FunctionalState TimeTriggeredMode;   /*!< Enable or disable the time triggered communication mode.
N                                            This parameter can be set to ENABLE or DISABLE. */
N
N  FunctionalState AutoBusOff;          /*!< Enable or disable the automatic bus-off management.
N                                            This parameter can be set to ENABLE or DISABLE. */
N
N  FunctionalState AutoWakeUp;          /*!< Enable or disable the automatic wake-up mode.
N                                            This parameter can be set to ENABLE or DISABLE. */
N
N  FunctionalState AutoRetransmission;  /*!< Enable or disable the non-automatic retransmission mode.
N                                            This parameter can be set to ENABLE or DISABLE. */
N
N  FunctionalState ReceiveFifoLocked;   /*!< Enable or disable the Receive FIFO Locked mode.
N                                            This parameter can be set to ENABLE or DISABLE. */
N
N  FunctionalState TransmitFifoPriority;/*!< Enable or disable the transmit FIFO priority.
N                                            This parameter can be set to ENABLE or DISABLE. */
N
N} CAN_InitTypeDef;
N
N/**
N  * @brief  CAN filter configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t FilterIdHigh;          /*!< Specifies the filter identification number (MSBs for a 32-bit
N                                       configuration, first one for a 16-bit configuration).
N                                       This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF. */
N
N  uint32_t FilterIdLow;           /*!< Specifies the filter identification number (LSBs for a 32-bit
N                                       configuration, second one for a 16-bit configuration).
N                                       This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF. */
N
N  uint32_t FilterMaskIdHigh;      /*!< Specifies the filter mask number or identification number,
N                                       according to the mode (MSBs for a 32-bit configuration,
N                                       first one for a 16-bit configuration).
N                                       This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF. */
N
N  uint32_t FilterMaskIdLow;       /*!< Specifies the filter mask number or identification number,
N                                       according to the mode (LSBs for a 32-bit configuration,
N                                       second one for a 16-bit configuration).
N                                       This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF. */
N
N  uint32_t FilterFIFOAssignment;  /*!< Specifies the FIFO (0 or 1U) which will be assigned to the filter.
N                                       This parameter can be a value of @ref CAN_filter_FIFO */
N
N  uint32_t FilterBank;            /*!< Specifies the filter bank which will be initialized.
N                                       For single CAN instance(14 dedicated filter banks),
N                                       this parameter must be a number between Min_Data = 0 and Max_Data = 13.
N                                       For dual CAN instances(28 filter banks shared),
N                                       this parameter must be a number between Min_Data = 0 and Max_Data = 27. */
N
N  uint32_t FilterMode;            /*!< Specifies the filter mode to be initialized.
N                                       This parameter can be a value of @ref CAN_filter_mode */
N
N  uint32_t FilterScale;           /*!< Specifies the filter scale.
N                                       This parameter can be a value of @ref CAN_filter_scale */
N
N  uint32_t FilterActivation;      /*!< Enable or disable the filter.
N                                       This parameter can be a value of @ref CAN_filter_activation */
N
N  uint32_t SlaveStartFilterBank;  /*!< Select the start filter bank for the slave CAN instance.
N                                       For single CAN instances, this parameter is meaningless.
N                                       For dual CAN instances, all filter banks with lower index are assigned to master
N                                       CAN instance, whereas all filter banks with greater index are assigned to slave
N                                       CAN instance.
N                                       This parameter must be a number between Min_Data = 0 and Max_Data = 27. */
N
N} CAN_FilterTypeDef;
N
N/**
N  * @brief  CAN Tx message header structure definition
N  */
Ntypedef struct
N{
N  uint32_t StdId;    /*!< Specifies the standard identifier.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 0x7FF. */
N
N  uint32_t ExtId;    /*!< Specifies the extended identifier.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 0x1FFFFFFF. */
N
N  uint32_t IDE;      /*!< Specifies the type of identifier for the message that will be transmitted.
N                          This parameter can be a value of @ref CAN_identifier_type */
N
N  uint32_t RTR;      /*!< Specifies the type of frame for the message that will be transmitted.
N                          This parameter can be a value of @ref CAN_remote_transmission_request */
N
N  uint32_t DLC;      /*!< Specifies the length of the frame that will be transmitted.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 8. */
N
N  FunctionalState TransmitGlobalTime; /*!< Specifies whether the timestamp counter value captured on start
N                          of frame transmission, is sent in DATA6 and DATA7 replacing pData[6] and pData[7].
N                          @note: Time Triggered Communication Mode must be enabled.
N                          @note: DLC must be programmed as 8 bytes, in order these 2 bytes are sent.
N                          This parameter can be set to ENABLE or DISABLE. */
N
N} CAN_TxHeaderTypeDef;
N
N/**
N  * @brief  CAN Rx message header structure definition
N  */
Ntypedef struct
N{
N  uint32_t StdId;    /*!< Specifies the standard identifier.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 0x7FF. */
N
N  uint32_t ExtId;    /*!< Specifies the extended identifier.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 0x1FFFFFFF. */
N
N  uint32_t IDE;      /*!< Specifies the type of identifier for the message that will be transmitted.
N                          This parameter can be a value of @ref CAN_identifier_type */
N
N  uint32_t RTR;      /*!< Specifies the type of frame for the message that will be transmitted.
N                          This parameter can be a value of @ref CAN_remote_transmission_request */
N
N  uint32_t DLC;      /*!< Specifies the length of the frame that will be transmitted.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 8. */
N
N  uint32_t Timestamp; /*!< Specifies the timestamp counter value captured on start of frame reception.
N                          @note: Time Triggered Communication Mode must be enabled.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 0xFFFF. */
N
N  uint32_t FilterMatchIndex; /*!< Specifies the index of matching acceptance filter element.
N                          This parameter must be a number between Min_Data = 0 and Max_Data = 0xFF. */
N
N} CAN_RxHeaderTypeDef;
N
N/**
N  * @brief  CAN handle Structure definition
N  */
Ntypedef struct __CAN_HandleTypeDef
N{
N  CAN_TypeDef                 *Instance;                 /*!< Register base address */
N
N  CAN_InitTypeDef             Init;                      /*!< CAN required parameters */
N
N  __IO HAL_CAN_StateTypeDef   State;                     /*!< CAN communication state */
X  volatile HAL_CAN_StateTypeDef   State;                      
N
N  __IO uint32_t               ErrorCode;                 /*!< CAN Error code.
X  volatile uint32_t               ErrorCode;                 
N                                                              This parameter can be a value of @ref CAN_Error_Code */
N
N#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
X#if 0U == 1
S  void (* TxMailbox0CompleteCallback)(struct __CAN_HandleTypeDef *hcan);/*!< CAN Tx Mailbox 0 complete callback    */
S  void (* TxMailbox1CompleteCallback)(struct __CAN_HandleTypeDef *hcan);/*!< CAN Tx Mailbox 1 complete callback    */
S  void (* TxMailbox2CompleteCallback)(struct __CAN_HandleTypeDef *hcan);/*!< CAN Tx Mailbox 2 complete callback    */
S  void (* TxMailbox0AbortCallback)(struct __CAN_HandleTypeDef *hcan);   /*!< CAN Tx Mailbox 0 abort callback       */
S  void (* TxMailbox1AbortCallback)(struct __CAN_HandleTypeDef *hcan);   /*!< CAN Tx Mailbox 1 abort callback       */
S  void (* TxMailbox2AbortCallback)(struct __CAN_HandleTypeDef *hcan);   /*!< CAN Tx Mailbox 2 abort callback       */
S  void (* RxFifo0MsgPendingCallback)(struct __CAN_HandleTypeDef *hcan); /*!< CAN Rx FIFO 0 msg pending callback    */
S  void (* RxFifo0FullCallback)(struct __CAN_HandleTypeDef *hcan);       /*!< CAN Rx FIFO 0 full callback           */
S  void (* RxFifo1MsgPendingCallback)(struct __CAN_HandleTypeDef *hcan); /*!< CAN Rx FIFO 1 msg pending callback    */
S  void (* RxFifo1FullCallback)(struct __CAN_HandleTypeDef *hcan);       /*!< CAN Rx FIFO 1 full callback           */
S  void (* SleepCallback)(struct __CAN_HandleTypeDef *hcan);             /*!< CAN Sleep callback                    */
S  void (* WakeUpFromRxMsgCallback)(struct __CAN_HandleTypeDef *hcan);   /*!< CAN Wake Up from Rx msg callback      */
S  void (* ErrorCallback)(struct __CAN_HandleTypeDef *hcan);             /*!< CAN Error callback                    */
S
S  void (* MspInitCallback)(struct __CAN_HandleTypeDef *hcan);           /*!< CAN Msp Init callback                 */
S  void (* MspDeInitCallback)(struct __CAN_HandleTypeDef *hcan);         /*!< CAN Msp DeInit callback               */
S
N#endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */
N} CAN_HandleTypeDef;
N
N#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
X#if 0U == 1
S/**
S  * @brief  HAL CAN common Callback ID enumeration definition
S  */
Stypedef enum
S{
S  HAL_CAN_TX_MAILBOX0_COMPLETE_CB_ID       = 0x00U,    /*!< CAN Tx Mailbox 0 complete callback ID         */
S  HAL_CAN_TX_MAILBOX1_COMPLETE_CB_ID       = 0x01U,    /*!< CAN Tx Mailbox 1 complete callback ID         */
S  HAL_CAN_TX_MAILBOX2_COMPLETE_CB_ID       = 0x02U,    /*!< CAN Tx Mailbox 2 complete callback ID         */
S  HAL_CAN_TX_MAILBOX0_ABORT_CB_ID          = 0x03U,    /*!< CAN Tx Mailbox 0 abort callback ID            */
S  HAL_CAN_TX_MAILBOX1_ABORT_CB_ID          = 0x04U,    /*!< CAN Tx Mailbox 1 abort callback ID            */
S  HAL_CAN_TX_MAILBOX2_ABORT_CB_ID          = 0x05U,    /*!< CAN Tx Mailbox 2 abort callback ID            */
S  HAL_CAN_RX_FIFO0_MSG_PENDING_CB_ID       = 0x06U,    /*!< CAN Rx FIFO 0 message pending callback ID     */
S  HAL_CAN_RX_FIFO0_FULL_CB_ID              = 0x07U,    /*!< CAN Rx FIFO 0 full callback ID                */
S  HAL_CAN_RX_FIFO1_MSG_PENDING_CB_ID       = 0x08U,    /*!< CAN Rx FIFO 1 message pending callback ID     */
S  HAL_CAN_RX_FIFO1_FULL_CB_ID              = 0x09U,    /*!< CAN Rx FIFO 1 full callback ID                */
S  HAL_CAN_SLEEP_CB_ID                      = 0x0AU,    /*!< CAN Sleep callback ID                         */
S  HAL_CAN_WAKEUP_FROM_RX_MSG_CB_ID         = 0x0BU,    /*!< CAN Wake Up from Rx msg callback ID          */
S  HAL_CAN_ERROR_CB_ID                      = 0x0CU,    /*!< CAN Error callback ID                         */
S
S  HAL_CAN_MSPINIT_CB_ID                    = 0x0DU,    /*!< CAN MspInit callback ID                       */
S  HAL_CAN_MSPDEINIT_CB_ID                  = 0x0EU,    /*!< CAN MspDeInit callback ID                     */
S
S} HAL_CAN_CallbackIDTypeDef;
S
S/**
S  * @brief  HAL CAN Callback pointer definition
S  */
Stypedef  void (*pCAN_CallbackTypeDef)(CAN_HandleTypeDef *hcan); /*!< pointer to a CAN callback function   */
S
N#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CAN_Exported_Constants CAN Exported Constants
N  * @{
N  */
N
N/** @defgroup CAN_Error_Code CAN Error Code
N  * @{
N  */
N#define HAL_CAN_ERROR_NONE            (0x00000000U)  /*!< No error                                             */
N#define HAL_CAN_ERROR_EWG             (0x00000001U)  /*!< Protocol Error Warning                               */
N#define HAL_CAN_ERROR_EPV             (0x00000002U)  /*!< Error Passive                                        */
N#define HAL_CAN_ERROR_BOF             (0x00000004U)  /*!< Bus-off error                                        */
N#define HAL_CAN_ERROR_STF             (0x00000008U)  /*!< Stuff error                                          */
N#define HAL_CAN_ERROR_FOR             (0x00000010U)  /*!< Form error                                           */
N#define HAL_CAN_ERROR_ACK             (0x00000020U)  /*!< Acknowledgment error                                 */
N#define HAL_CAN_ERROR_BR              (0x00000040U)  /*!< Bit recessive error                                  */
N#define HAL_CAN_ERROR_BD              (0x00000080U)  /*!< Bit dominant error                                   */
N#define HAL_CAN_ERROR_CRC             (0x00000100U)  /*!< CRC error                                            */
N#define HAL_CAN_ERROR_RX_FOV0         (0x00000200U)  /*!< Rx FIFO0 overrun error                               */
N#define HAL_CAN_ERROR_RX_FOV1         (0x00000400U)  /*!< Rx FIFO1 overrun error                               */
N#define HAL_CAN_ERROR_TX_ALST0        (0x00000800U)  /*!< TxMailbox 0 transmit failure due to arbitration lost */
N#define HAL_CAN_ERROR_TX_TERR0        (0x00001000U)  /*!< TxMailbox 0 transmit failure due to transmit error    */
N#define HAL_CAN_ERROR_TX_ALST1        (0x00002000U)  /*!< TxMailbox 1 transmit failure due to arbitration lost */
N#define HAL_CAN_ERROR_TX_TERR1        (0x00004000U)  /*!< TxMailbox 1 transmit failure due to transmit error    */
N#define HAL_CAN_ERROR_TX_ALST2        (0x00008000U)  /*!< TxMailbox 2 transmit failure due to arbitration lost */
N#define HAL_CAN_ERROR_TX_TERR2        (0x00010000U)  /*!< TxMailbox 2 transmit failure due to transmit error    */
N#define HAL_CAN_ERROR_TIMEOUT         (0x00020000U)  /*!< Timeout error                                        */
N#define HAL_CAN_ERROR_NOT_INITIALIZED (0x00040000U)  /*!< Peripheral not initialized                           */
N#define HAL_CAN_ERROR_NOT_READY       (0x00080000U)  /*!< Peripheral not ready                                 */
N#define HAL_CAN_ERROR_NOT_STARTED     (0x00100000U)  /*!< Peripheral not started                               */
N#define HAL_CAN_ERROR_PARAM           (0x00200000U)  /*!< Parameter error                                      */
N
N#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
X#if 0U == 1
S#define HAL_CAN_ERROR_INVALID_CALLBACK (0x00400000U) /*!< Invalid Callback error                               */
N#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
N#define HAL_CAN_ERROR_INTERNAL        (0x00800000U)  /*!< Internal error                                       */
N
N/**
N  * @}
N  */
N
N/** @defgroup CAN_InitStatus CAN InitStatus
N  * @{
N  */
N#define CAN_INITSTATUS_FAILED       (0x00000000U)  /*!< CAN initialization failed */
N#define CAN_INITSTATUS_SUCCESS      (0x00000001U)  /*!< CAN initialization OK     */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_operating_mode CAN Operating Mode
N  * @{
N  */
N#define CAN_MODE_NORMAL             (0x00000000U)                              /*!< Normal mode   */
N#define CAN_MODE_LOOPBACK           ((uint32_t)CAN_BTR_LBKM)                   /*!< Loopback mode */
N#define CAN_MODE_SILENT             ((uint32_t)CAN_BTR_SILM)                   /*!< Silent mode   */
N#define CAN_MODE_SILENT_LOOPBACK    ((uint32_t)(CAN_BTR_LBKM | CAN_BTR_SILM))  /*!< Loopback combined with silent mode */
N/**
N  * @}
N  */
N
N
N/** @defgroup CAN_synchronisation_jump_width CAN Synchronization Jump Width
N  * @{
N  */
N#define CAN_SJW_1TQ                 (0x00000000U)              /*!< 1 time quantum */
N#define CAN_SJW_2TQ                 ((uint32_t)CAN_BTR_SJW_0)  /*!< 2 time quantum */
N#define CAN_SJW_3TQ                 ((uint32_t)CAN_BTR_SJW_1)  /*!< 3 time quantum */
N#define CAN_SJW_4TQ                 ((uint32_t)CAN_BTR_SJW)    /*!< 4 time quantum */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_time_quantum_in_bit_segment_1 CAN Time Quantum in Bit Segment 1
N  * @{
N  */
N#define CAN_BS1_1TQ                 (0x00000000U)                                                /*!< 1 time quantum  */
N#define CAN_BS1_2TQ                 ((uint32_t)CAN_BTR_TS1_0)                                    /*!< 2 time quantum  */
N#define CAN_BS1_3TQ                 ((uint32_t)CAN_BTR_TS1_1)                                    /*!< 3 time quantum  */
N#define CAN_BS1_4TQ                 ((uint32_t)(CAN_BTR_TS1_1 | CAN_BTR_TS1_0))                  /*!< 4 time quantum  */
N#define CAN_BS1_5TQ                 ((uint32_t)CAN_BTR_TS1_2)                                    /*!< 5 time quantum  */
N#define CAN_BS1_6TQ                 ((uint32_t)(CAN_BTR_TS1_2 | CAN_BTR_TS1_0))                  /*!< 6 time quantum  */
N#define CAN_BS1_7TQ                 ((uint32_t)(CAN_BTR_TS1_2 | CAN_BTR_TS1_1))                  /*!< 7 time quantum  */
N#define CAN_BS1_8TQ                 ((uint32_t)(CAN_BTR_TS1_2 | CAN_BTR_TS1_1 | CAN_BTR_TS1_0))  /*!< 8 time quantum  */
N#define CAN_BS1_9TQ                 ((uint32_t)CAN_BTR_TS1_3)                                    /*!< 9 time quantum  */
N#define CAN_BS1_10TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_0))                  /*!< 10 time quantum */
N#define CAN_BS1_11TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_1))                  /*!< 11 time quantum */
N#define CAN_BS1_12TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_1 | CAN_BTR_TS1_0))  /*!< 12 time quantum */
N#define CAN_BS1_13TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_2))                  /*!< 13 time quantum */
N#define CAN_BS1_14TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_2 | CAN_BTR_TS1_0))  /*!< 14 time quantum */
N#define CAN_BS1_15TQ                ((uint32_t)(CAN_BTR_TS1_3 | CAN_BTR_TS1_2 | CAN_BTR_TS1_1))  /*!< 15 time quantum */
N#define CAN_BS1_16TQ                ((uint32_t)CAN_BTR_TS1) /*!< 16 time quantum */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_time_quantum_in_bit_segment_2 CAN Time Quantum in Bit Segment 2
N  * @{
N  */
N#define CAN_BS2_1TQ                 (0x00000000U)                                /*!< 1 time quantum */
N#define CAN_BS2_2TQ                 ((uint32_t)CAN_BTR_TS2_0)                    /*!< 2 time quantum */
N#define CAN_BS2_3TQ                 ((uint32_t)CAN_BTR_TS2_1)                    /*!< 3 time quantum */
N#define CAN_BS2_4TQ                 ((uint32_t)(CAN_BTR_TS2_1 | CAN_BTR_TS2_0))  /*!< 4 time quantum */
N#define CAN_BS2_5TQ                 ((uint32_t)CAN_BTR_TS2_2)                    /*!< 5 time quantum */
N#define CAN_BS2_6TQ                 ((uint32_t)(CAN_BTR_TS2_2 | CAN_BTR_TS2_0))  /*!< 6 time quantum */
N#define CAN_BS2_7TQ                 ((uint32_t)(CAN_BTR_TS2_2 | CAN_BTR_TS2_1))  /*!< 7 time quantum */
N#define CAN_BS2_8TQ                 ((uint32_t)CAN_BTR_TS2)                      /*!< 8 time quantum */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_mode CAN Filter Mode
N  * @{
N  */
N#define CAN_FILTERMODE_IDMASK       (0x00000000U)  /*!< Identifier mask mode */
N#define CAN_FILTERMODE_IDLIST       (0x00000001U)  /*!< Identifier list mode */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_scale CAN Filter Scale
N  * @{
N  */
N#define CAN_FILTERSCALE_16BIT       (0x00000000U)  /*!< Two 16-bit filters */
N#define CAN_FILTERSCALE_32BIT       (0x00000001U)  /*!< One 32-bit filter  */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_activation CAN Filter Activation
N  * @{
N  */
N#define CAN_FILTER_DISABLE          (0x00000000U)  /*!< Disable filter */
N#define CAN_FILTER_ENABLE           (0x00000001U)  /*!< Enable filter  */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_FIFO CAN Filter FIFO
N  * @{
N  */
N#define CAN_FILTER_FIFO0            (0x00000000U)  /*!< Filter FIFO 0 assignment for filter x */
N#define CAN_FILTER_FIFO1            (0x00000001U)  /*!< Filter FIFO 1 assignment for filter x */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_identifier_type CAN Identifier Type
N  * @{
N  */
N#define CAN_ID_STD                  (0x00000000U)  /*!< Standard Id */
N#define CAN_ID_EXT                  (0x00000004U)  /*!< Extended Id */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_remote_transmission_request CAN Remote Transmission Request
N  * @{
N  */
N#define CAN_RTR_DATA                (0x00000000U)  /*!< Data frame   */
N#define CAN_RTR_REMOTE              (0x00000002U)  /*!< Remote frame */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_receive_FIFO_number CAN Receive FIFO Number
N  * @{
N  */
N#define CAN_RX_FIFO0                (0x00000000U)  /*!< CAN receive FIFO 0 */
N#define CAN_RX_FIFO1                (0x00000001U)  /*!< CAN receive FIFO 1 */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_Tx_Mailboxes CAN Tx Mailboxes
N  * @{
N  */
N#define CAN_TX_MAILBOX0             (0x00000001U)  /*!< Tx Mailbox 0  */
N#define CAN_TX_MAILBOX1             (0x00000002U)  /*!< Tx Mailbox 1  */
N#define CAN_TX_MAILBOX2             (0x00000004U)  /*!< Tx Mailbox 2  */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_flags CAN Flags
N  * @{
N  */
N/* Transmit Flags */
N#define CAN_FLAG_RQCP0              (0x00000500U)  /*!< Request complete MailBox 0 flag   */
N#define CAN_FLAG_TXOK0              (0x00000501U)  /*!< Transmission OK MailBox 0 flag    */
N#define CAN_FLAG_ALST0              (0x00000502U)  /*!< Arbitration Lost MailBox 0 flag   */
N#define CAN_FLAG_TERR0              (0x00000503U)  /*!< Transmission error MailBox 0 flag */
N#define CAN_FLAG_RQCP1              (0x00000508U)  /*!< Request complete MailBox1 flag    */
N#define CAN_FLAG_TXOK1              (0x00000509U)  /*!< Transmission OK MailBox 1 flag    */
N#define CAN_FLAG_ALST1              (0x0000050AU)  /*!< Arbitration Lost MailBox 1 flag   */
N#define CAN_FLAG_TERR1              (0x0000050BU)  /*!< Transmission error MailBox 1 flag */
N#define CAN_FLAG_RQCP2              (0x00000510U)  /*!< Request complete MailBox2 flag    */
N#define CAN_FLAG_TXOK2              (0x00000511U)  /*!< Transmission OK MailBox 2 flag    */
N#define CAN_FLAG_ALST2              (0x00000512U)  /*!< Arbitration Lost MailBox 2 flag   */
N#define CAN_FLAG_TERR2              (0x00000513U)  /*!< Transmission error MailBox 2 flag */
N#define CAN_FLAG_TME0               (0x0000051AU)  /*!< Transmit mailbox 0 empty flag     */
N#define CAN_FLAG_TME1               (0x0000051BU)  /*!< Transmit mailbox 1 empty flag     */
N#define CAN_FLAG_TME2               (0x0000051CU)  /*!< Transmit mailbox 2 empty flag     */
N#define CAN_FLAG_LOW0               (0x0000051DU)  /*!< Lowest priority mailbox 0 flag    */
N#define CAN_FLAG_LOW1               (0x0000051EU)  /*!< Lowest priority mailbox 1 flag    */
N#define CAN_FLAG_LOW2               (0x0000051FU)  /*!< Lowest priority mailbox 2 flag    */
N
N/* Receive Flags */
N#define CAN_FLAG_FF0                (0x00000203U)  /*!< RX FIFO 0 Full flag               */
N#define CAN_FLAG_FOV0               (0x00000204U)  /*!< RX FIFO 0 Overrun flag            */
N#define CAN_FLAG_FF1                (0x00000403U)  /*!< RX FIFO 1 Full flag               */
N#define CAN_FLAG_FOV1               (0x00000404U)  /*!< RX FIFO 1 Overrun flag            */
N
N/* Operating Mode Flags */
N#define CAN_FLAG_INAK               (0x00000100U)  /*!< Initialization acknowledge flag   */
N#define CAN_FLAG_SLAK               (0x00000101U)  /*!< Sleep acknowledge flag            */
N#define CAN_FLAG_ERRI               (0x00000102U)  /*!< Error flag                        */
N#define CAN_FLAG_WKU                (0x00000103U)  /*!< Wake up interrupt flag            */
N#define CAN_FLAG_SLAKI              (0x00000104U)  /*!< Sleep acknowledge interrupt flag  */
N
N/* Error Flags */
N#define CAN_FLAG_EWG                (0x00000300U)  /*!< Error warning flag                */
N#define CAN_FLAG_EPV                (0x00000301U)  /*!< Error passive flag                */
N#define CAN_FLAG_BOF                (0x00000302U)  /*!< Bus-Off flag                      */
N/**
N  * @}
N  */
N
N
N/** @defgroup CAN_Interrupts CAN Interrupts
N  * @{
N  */
N/* Transmit Interrupt */
N#define CAN_IT_TX_MAILBOX_EMPTY     ((uint32_t)CAN_IER_TMEIE)   /*!< Transmit mailbox empty interrupt */
N
N/* Receive Interrupts */
N#define CAN_IT_RX_FIFO0_MSG_PENDING ((uint32_t)CAN_IER_FMPIE0)  /*!< FIFO 0 message pending interrupt */
N#define CAN_IT_RX_FIFO0_FULL        ((uint32_t)CAN_IER_FFIE0)   /*!< FIFO 0 full interrupt            */
N#define CAN_IT_RX_FIFO0_OVERRUN     ((uint32_t)CAN_IER_FOVIE0)  /*!< FIFO 0 overrun interrupt         */
N#define CAN_IT_RX_FIFO1_MSG_PENDING ((uint32_t)CAN_IER_FMPIE1)  /*!< FIFO 1 message pending interrupt */
N#define CAN_IT_RX_FIFO1_FULL        ((uint32_t)CAN_IER_FFIE1)   /*!< FIFO 1 full interrupt            */
N#define CAN_IT_RX_FIFO1_OVERRUN     ((uint32_t)CAN_IER_FOVIE1)  /*!< FIFO 1 overrun interrupt         */
N
N/* Operating Mode Interrupts */
N#define CAN_IT_WAKEUP               ((uint32_t)CAN_IER_WKUIE)   /*!< Wake-up interrupt                */
N#define CAN_IT_SLEEP_ACK            ((uint32_t)CAN_IER_SLKIE)   /*!< Sleep acknowledge interrupt      */
N
N/* Error Interrupts */
N#define CAN_IT_ERROR_WARNING        ((uint32_t)CAN_IER_EWGIE)   /*!< Error warning interrupt          */
N#define CAN_IT_ERROR_PASSIVE        ((uint32_t)CAN_IER_EPVIE)   /*!< Error passive interrupt          */
N#define CAN_IT_BUSOFF               ((uint32_t)CAN_IER_BOFIE)   /*!< Bus-off interrupt                */
N#define CAN_IT_LAST_ERROR_CODE      ((uint32_t)CAN_IER_LECIE)   /*!< Last error code interrupt        */
N#define CAN_IT_ERROR                ((uint32_t)CAN_IER_ERRIE)   /*!< Error Interrupt                  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup CAN_Exported_Macros CAN Exported Macros
N  * @{
N  */
N
N/** @brief  Reset CAN handle state
N  * @param  __HANDLE__ CAN handle.
N  * @retval None
N  */
N#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
X#if 0U == 1
S#define __HAL_CAN_RESET_HANDLE_STATE(__HANDLE__) do{                                              \
S                                                     (__HANDLE__)->State = HAL_CAN_STATE_RESET;   \
S                                                     (__HANDLE__)->MspInitCallback = NULL;        \
S                                                     (__HANDLE__)->MspDeInitCallback = NULL;      \
S                                                   } while(0)
X#define __HAL_CAN_RESET_HANDLE_STATE(__HANDLE__) do{                                                                                                   (__HANDLE__)->State = HAL_CAN_STATE_RESET;                                                        (__HANDLE__)->MspInitCallback = NULL;                                                             (__HANDLE__)->MspDeInitCallback = NULL;                                                         } while(0)
N#else
N#define __HAL_CAN_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_CAN_STATE_RESET)
N#endif /*USE_HAL_CAN_REGISTER_CALLBACKS */
N
N/**
N  * @brief  Enable the specified CAN interrupts.
N  * @param  __HANDLE__ CAN handle.
N  * @param  __INTERRUPT__ CAN Interrupt sources to enable.
N  *           This parameter can be any combination of @arg CAN_Interrupts
N  * @retval None
N  */
N#define __HAL_CAN_ENABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->IER) |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the specified CAN interrupts.
N  * @param  __HANDLE__ CAN handle.
N  * @param  __INTERRUPT__ CAN Interrupt sources to disable.
N  *           This parameter can be any combination of @arg CAN_Interrupts
N  * @retval None
N  */
N#define __HAL_CAN_DISABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->IER) &= ~(__INTERRUPT__))
N
N/** @brief  Check if the specified CAN interrupt source is enabled or disabled.
N  * @param  __HANDLE__ specifies the CAN Handle.
N  * @param  __INTERRUPT__ specifies the CAN interrupt source to check.
N  *           This parameter can be a value of @arg CAN_Interrupts
N  * @retval The state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_CAN_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->IER) & (__INTERRUPT__))
N
N/** @brief  Check whether the specified CAN flag is set or not.
N  * @param  __HANDLE__ specifies the CAN Handle.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of @arg CAN_flags
N  * @retval The state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_CAN_GET_FLAG(__HANDLE__, __FLAG__) \
N  ((((__FLAG__) >> 8U) == 5U)? ((((__HANDLE__)->Instance->TSR) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))): \
N   (((__FLAG__) >> 8U) == 2U)? ((((__HANDLE__)->Instance->RF0R) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))): \
N   (((__FLAG__) >> 8U) == 4U)? ((((__HANDLE__)->Instance->RF1R) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))): \
N   (((__FLAG__) >> 8U) == 1U)? ((((__HANDLE__)->Instance->MSR) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))): \
N   (((__FLAG__) >> 8U) == 3U)? ((((__HANDLE__)->Instance->ESR) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))): 0U)
X#define __HAL_CAN_GET_FLAG(__HANDLE__, __FLAG__)   ((((__FLAG__) >> 8U) == 5U)? ((((__HANDLE__)->Instance->TSR) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))):    (((__FLAG__) >> 8U) == 2U)? ((((__HANDLE__)->Instance->RF0R) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))):    (((__FLAG__) >> 8U) == 4U)? ((((__HANDLE__)->Instance->RF1R) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))):    (((__FLAG__) >> 8U) == 1U)? ((((__HANDLE__)->Instance->MSR) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))):    (((__FLAG__) >> 8U) == 3U)? ((((__HANDLE__)->Instance->ESR) & (1U << ((__FLAG__) & CAN_FLAG_MASK))) == (1U << ((__FLAG__) & CAN_FLAG_MASK))): 0U)
N
N/** @brief  Clear the specified CAN pending flag.
N  * @param  __HANDLE__ specifies the CAN Handle.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg CAN_FLAG_RQCP0: Request complete MailBox 0 Flag
N  *            @arg CAN_FLAG_TXOK0: Transmission OK MailBox 0 Flag
N  *            @arg CAN_FLAG_ALST0: Arbitration Lost MailBox 0 Flag
N  *            @arg CAN_FLAG_TERR0: Transmission error MailBox 0 Flag
N  *            @arg CAN_FLAG_RQCP1: Request complete MailBox 1 Flag
N  *            @arg CAN_FLAG_TXOK1: Transmission OK MailBox 1 Flag
N  *            @arg CAN_FLAG_ALST1: Arbitration Lost MailBox 1 Flag
N  *            @arg CAN_FLAG_TERR1: Transmission error MailBox 1 Flag
N  *            @arg CAN_FLAG_RQCP2: Request complete MailBox 2 Flag
N  *            @arg CAN_FLAG_TXOK2: Transmission OK MailBox 2 Flag
N  *            @arg CAN_FLAG_ALST2: Arbitration Lost MailBox 2 Flag
N  *            @arg CAN_FLAG_TERR2: Transmission error MailBox 2 Flag
N  *            @arg CAN_FLAG_FF0:   RX FIFO 0 Full Flag
N  *            @arg CAN_FLAG_FOV0:  RX FIFO 0 Overrun Flag
N  *            @arg CAN_FLAG_FF1:   RX FIFO 1 Full Flag
N  *            @arg CAN_FLAG_FOV1:  RX FIFO 1 Overrun Flag
N  *            @arg CAN_FLAG_WKUI:  Wake up Interrupt Flag
N  *            @arg CAN_FLAG_SLAKI: Sleep acknowledge Interrupt Flag
N  * @retval None
N  */
N#define __HAL_CAN_CLEAR_FLAG(__HANDLE__, __FLAG__) \
N  ((((__FLAG__) >> 8U) == 5U)? (((__HANDLE__)->Instance->TSR) = (1U << ((__FLAG__) & CAN_FLAG_MASK))): \
N   (((__FLAG__) >> 8U) == 2U)? (((__HANDLE__)->Instance->RF0R) = (1U << ((__FLAG__) & CAN_FLAG_MASK))): \
N   (((__FLAG__) >> 8U) == 4U)? (((__HANDLE__)->Instance->RF1R) = (1U << ((__FLAG__) & CAN_FLAG_MASK))): \
N   (((__FLAG__) >> 8U) == 1U)? (((__HANDLE__)->Instance->MSR) = (1U << ((__FLAG__) & CAN_FLAG_MASK))): 0U)
X#define __HAL_CAN_CLEAR_FLAG(__HANDLE__, __FLAG__)   ((((__FLAG__) >> 8U) == 5U)? (((__HANDLE__)->Instance->TSR) = (1U << ((__FLAG__) & CAN_FLAG_MASK))):    (((__FLAG__) >> 8U) == 2U)? (((__HANDLE__)->Instance->RF0R) = (1U << ((__FLAG__) & CAN_FLAG_MASK))):    (((__FLAG__) >> 8U) == 4U)? (((__HANDLE__)->Instance->RF1R) = (1U << ((__FLAG__) & CAN_FLAG_MASK))):    (((__FLAG__) >> 8U) == 1U)? (((__HANDLE__)->Instance->MSR) = (1U << ((__FLAG__) & CAN_FLAG_MASK))): 0U)
N
N/**
N * @}
N */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup CAN_Exported_Functions CAN Exported Functions
N  * @{
N  */
N
N/** @addtogroup CAN_Exported_Functions_Group1 Initialization and de-initialization functions
N *  @brief    Initialization and Configuration functions
N * @{
N */
N
N/* Initialization and de-initialization functions *****************************/
NHAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan);
NHAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_MspInit(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_MspDeInit(CAN_HandleTypeDef *hcan);
N
N#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
X#if 0U == 1
S/* Callbacks Register/UnRegister functions  ***********************************/
SHAL_StatusTypeDef HAL_CAN_RegisterCallback(CAN_HandleTypeDef *hcan, HAL_CAN_CallbackIDTypeDef CallbackID, void (* pCallback)(CAN_HandleTypeDef *_hcan));
SHAL_StatusTypeDef HAL_CAN_UnRegisterCallback(CAN_HandleTypeDef *hcan, HAL_CAN_CallbackIDTypeDef CallbackID);
S
N#endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */
N/**
N * @}
N */
N
N/** @addtogroup CAN_Exported_Functions_Group2 Configuration functions
N *  @brief    Configuration functions
N * @{
N */
N
N/* Configuration functions ****************************************************/
NHAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, CAN_FilterTypeDef *sFilterConfig);
N
N/**
N * @}
N */
N
N/** @addtogroup CAN_Exported_Functions_Group3 Control functions
N *  @brief    Control functions
N * @{
N */
N
N/* Control functions **********************************************************/
NHAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan);
NHAL_StatusTypeDef HAL_CAN_Stop(CAN_HandleTypeDef *hcan);
NHAL_StatusTypeDef HAL_CAN_RequestSleep(CAN_HandleTypeDef *hcan);
NHAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef *hcan);
Nuint32_t HAL_CAN_IsSleepActive(CAN_HandleTypeDef *hcan);
NHAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pHeader, uint8_t aData[], uint32_t *pTxMailbox);
NHAL_StatusTypeDef HAL_CAN_AbortTxRequest(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes);
Nuint32_t HAL_CAN_GetTxMailboxesFreeLevel(CAN_HandleTypeDef *hcan);
Nuint32_t HAL_CAN_IsTxMessagePending(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes);
Nuint32_t HAL_CAN_GetTxTimestamp(CAN_HandleTypeDef *hcan, uint32_t TxMailbox);
NHAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef *pHeader, uint8_t aData[]);
Nuint32_t HAL_CAN_GetRxFifoFillLevel(CAN_HandleTypeDef *hcan, uint32_t RxFifo);
N
N/**
N * @}
N */
N
N/** @addtogroup CAN_Exported_Functions_Group4 Interrupts management
N *  @brief    Interrupts management
N * @{
N */
N/* Interrupts management ******************************************************/
NHAL_StatusTypeDef HAL_CAN_ActivateNotification(CAN_HandleTypeDef *hcan, uint32_t ActiveITs);
NHAL_StatusTypeDef HAL_CAN_DeactivateNotification(CAN_HandleTypeDef *hcan, uint32_t InactiveITs);
Nvoid HAL_CAN_IRQHandler(CAN_HandleTypeDef *hcan);
N
N/**
N * @}
N */
N
N/** @addtogroup CAN_Exported_Functions_Group5 Callback functions
N *  @brief    Callback functions
N * @{
N */
N/* Callbacks functions ********************************************************/
N
Nvoid HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan);
Nvoid HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan);
N
N/**
N * @}
N */
N
N/** @addtogroup CAN_Exported_Functions_Group6 Peripheral State and Error functions
N *  @brief   CAN Peripheral State functions
N * @{
N */
N/* Peripheral State and Error functions ***************************************/
NHAL_CAN_StateTypeDef HAL_CAN_GetState(CAN_HandleTypeDef *hcan);
Nuint32_t HAL_CAN_GetError(CAN_HandleTypeDef *hcan);
NHAL_StatusTypeDef HAL_CAN_ResetError(CAN_HandleTypeDef *hcan);
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/* Private types -------------------------------------------------------------*/
N/** @defgroup CAN_Private_Types CAN Private Types
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup CAN_Private_Variables CAN Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup CAN_Private_Constants CAN Private Constants
N  * @{
N  */
N#define CAN_FLAG_MASK  (0x000000FFU)
N/**
N  * @}
N  */
N
N/* Private Macros -----------------------------------------------------------*/
N/** @defgroup CAN_Private_Macros CAN Private Macros
N  * @{
N  */
N
N#define IS_CAN_MODE(MODE) (((MODE) == CAN_MODE_NORMAL) || \
N                           ((MODE) == CAN_MODE_LOOPBACK)|| \
N                           ((MODE) == CAN_MODE_SILENT) || \
N                           ((MODE) == CAN_MODE_SILENT_LOOPBACK))
X#define IS_CAN_MODE(MODE) (((MODE) == CAN_MODE_NORMAL) ||                            ((MODE) == CAN_MODE_LOOPBACK)||                            ((MODE) == CAN_MODE_SILENT) ||                            ((MODE) == CAN_MODE_SILENT_LOOPBACK))
N#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1TQ) || ((SJW) == CAN_SJW_2TQ) || \
N                         ((SJW) == CAN_SJW_3TQ) || ((SJW) == CAN_SJW_4TQ))
X#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1TQ) || ((SJW) == CAN_SJW_2TQ) ||                          ((SJW) == CAN_SJW_3TQ) || ((SJW) == CAN_SJW_4TQ))
N#define IS_CAN_BS1(BS1) (((BS1) == CAN_BS1_1TQ) || ((BS1) == CAN_BS1_2TQ) || \
N                         ((BS1) == CAN_BS1_3TQ) || ((BS1) == CAN_BS1_4TQ) || \
N                         ((BS1) == CAN_BS1_5TQ) || ((BS1) == CAN_BS1_6TQ) || \
N                         ((BS1) == CAN_BS1_7TQ) || ((BS1) == CAN_BS1_8TQ) || \
N                         ((BS1) == CAN_BS1_9TQ) || ((BS1) == CAN_BS1_10TQ)|| \
N                         ((BS1) == CAN_BS1_11TQ)|| ((BS1) == CAN_BS1_12TQ)|| \
N                         ((BS1) == CAN_BS1_13TQ)|| ((BS1) == CAN_BS1_14TQ)|| \
N                         ((BS1) == CAN_BS1_15TQ)|| ((BS1) == CAN_BS1_16TQ))
X#define IS_CAN_BS1(BS1) (((BS1) == CAN_BS1_1TQ) || ((BS1) == CAN_BS1_2TQ) ||                          ((BS1) == CAN_BS1_3TQ) || ((BS1) == CAN_BS1_4TQ) ||                          ((BS1) == CAN_BS1_5TQ) || ((BS1) == CAN_BS1_6TQ) ||                          ((BS1) == CAN_BS1_7TQ) || ((BS1) == CAN_BS1_8TQ) ||                          ((BS1) == CAN_BS1_9TQ) || ((BS1) == CAN_BS1_10TQ)||                          ((BS1) == CAN_BS1_11TQ)|| ((BS1) == CAN_BS1_12TQ)||                          ((BS1) == CAN_BS1_13TQ)|| ((BS1) == CAN_BS1_14TQ)||                          ((BS1) == CAN_BS1_15TQ)|| ((BS1) == CAN_BS1_16TQ))
N#define IS_CAN_BS2(BS2) (((BS2) == CAN_BS2_1TQ) || ((BS2) == CAN_BS2_2TQ) || \
N                         ((BS2) == CAN_BS2_3TQ) || ((BS2) == CAN_BS2_4TQ) || \
N                         ((BS2) == CAN_BS2_5TQ) || ((BS2) == CAN_BS2_6TQ) || \
N                         ((BS2) == CAN_BS2_7TQ) || ((BS2) == CAN_BS2_8TQ))
X#define IS_CAN_BS2(BS2) (((BS2) == CAN_BS2_1TQ) || ((BS2) == CAN_BS2_2TQ) ||                          ((BS2) == CAN_BS2_3TQ) || ((BS2) == CAN_BS2_4TQ) ||                          ((BS2) == CAN_BS2_5TQ) || ((BS2) == CAN_BS2_6TQ) ||                          ((BS2) == CAN_BS2_7TQ) || ((BS2) == CAN_BS2_8TQ))
N#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1U) && ((PRESCALER) <= 1024U))
N#define IS_CAN_FILTER_ID_HALFWORD(HALFWORD) ((HALFWORD) <= 0xFFFFU)
N#define IS_CAN_FILTER_BANK_DUAL(BANK) ((BANK) <= 27U)
N#define IS_CAN_FILTER_BANK_SINGLE(BANK) ((BANK) <= 13U)
N#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FILTERMODE_IDMASK) || \
N                                  ((MODE) == CAN_FILTERMODE_IDLIST))
X#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FILTERMODE_IDMASK) ||                                   ((MODE) == CAN_FILTERMODE_IDLIST))
N#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FILTERSCALE_16BIT) || \
N                                    ((SCALE) == CAN_FILTERSCALE_32BIT))
X#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FILTERSCALE_16BIT) ||                                     ((SCALE) == CAN_FILTERSCALE_32BIT))
N#define IS_CAN_FILTER_ACTIVATION(ACTIVATION) (((ACTIVATION) == CAN_FILTER_DISABLE) || \
N                                              ((ACTIVATION) == CAN_FILTER_ENABLE))
X#define IS_CAN_FILTER_ACTIVATION(ACTIVATION) (((ACTIVATION) == CAN_FILTER_DISABLE) ||                                               ((ACTIVATION) == CAN_FILTER_ENABLE))
N#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FILTER_FIFO0) || \
N                                  ((FIFO) == CAN_FILTER_FIFO1))
X#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FILTER_FIFO0) ||                                   ((FIFO) == CAN_FILTER_FIFO1))
N#define IS_CAN_TX_MAILBOX(TRANSMITMAILBOX) (((TRANSMITMAILBOX) == CAN_TX_MAILBOX0 ) || \
N                                            ((TRANSMITMAILBOX) == CAN_TX_MAILBOX1 ) || \
N                                            ((TRANSMITMAILBOX) == CAN_TX_MAILBOX2 ))
X#define IS_CAN_TX_MAILBOX(TRANSMITMAILBOX) (((TRANSMITMAILBOX) == CAN_TX_MAILBOX0 ) ||                                             ((TRANSMITMAILBOX) == CAN_TX_MAILBOX1 ) ||                                             ((TRANSMITMAILBOX) == CAN_TX_MAILBOX2 ))
N#define IS_CAN_TX_MAILBOX_LIST(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= (CAN_TX_MAILBOX0 | CAN_TX_MAILBOX1 | CAN_TX_MAILBOX2))
N#define IS_CAN_STDID(STDID)   ((STDID) <= 0x7FFU)
N#define IS_CAN_EXTID(EXTID)   ((EXTID) <= 0x1FFFFFFFU)
N#define IS_CAN_DLC(DLC)       ((DLC) <= 8U)
N#define IS_CAN_IDTYPE(IDTYPE)  (((IDTYPE) == CAN_ID_STD) || \
N                                ((IDTYPE) == CAN_ID_EXT))
X#define IS_CAN_IDTYPE(IDTYPE)  (((IDTYPE) == CAN_ID_STD) ||                                 ((IDTYPE) == CAN_ID_EXT))
N#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_DATA) || ((RTR) == CAN_RTR_REMOTE))
N#define IS_CAN_RX_FIFO(FIFO) (((FIFO) == CAN_RX_FIFO0) || ((FIFO) == CAN_RX_FIFO1))
N#define IS_CAN_IT(IT) ((IT) <= (CAN_IT_TX_MAILBOX_EMPTY     | CAN_IT_RX_FIFO0_MSG_PENDING      | \
N                                CAN_IT_RX_FIFO0_FULL        | CAN_IT_RX_FIFO0_OVERRUN          | \
N                                CAN_IT_RX_FIFO1_MSG_PENDING | CAN_IT_RX_FIFO1_FULL             | \
N                                CAN_IT_RX_FIFO1_OVERRUN     | CAN_IT_WAKEUP                    | \
N                                CAN_IT_SLEEP_ACK            | CAN_IT_ERROR_WARNING             | \
N                                CAN_IT_ERROR_PASSIVE        | CAN_IT_BUSOFF                    | \
N                                CAN_IT_LAST_ERROR_CODE      | CAN_IT_ERROR))
X#define IS_CAN_IT(IT) ((IT) <= (CAN_IT_TX_MAILBOX_EMPTY     | CAN_IT_RX_FIFO0_MSG_PENDING      |                                 CAN_IT_RX_FIFO0_FULL        | CAN_IT_RX_FIFO0_OVERRUN          |                                 CAN_IT_RX_FIFO1_MSG_PENDING | CAN_IT_RX_FIFO1_FULL             |                                 CAN_IT_RX_FIFO1_OVERRUN     | CAN_IT_WAKEUP                    |                                 CAN_IT_SLEEP_ACK            | CAN_IT_ERROR_WARNING             |                                 CAN_IT_ERROR_PASSIVE        | CAN_IT_BUSOFF                    |                                 CAN_IT_LAST_ERROR_CODE      | CAN_IT_ERROR))
N
N/**
N  * @}
N  */
N/* End of private macros -----------------------------------------------------*/
N
N/**
N  * @}
N  */
N
N
N#endif /* CAN1 */
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* STM32F4xx_HAL_CAN_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 300 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_CAN_MODULE_ENABLED */
N
N#ifdef HAL_CAN_LEGACY_MODULE_ENABLED
S  #include "stm32f4xx_hal_can_legacy.h"
N#endif /* HAL_CAN_LEGACY_MODULE_ENABLED */
N
N#ifdef HAL_CRC_MODULE_ENABLED
S  #include "stm32f4xx_hal_crc.h"
N#endif /* HAL_CRC_MODULE_ENABLED */
N
N#ifdef HAL_CRYP_MODULE_ENABLED
S  #include "stm32f4xx_hal_cryp.h"
N#endif /* HAL_CRYP_MODULE_ENABLED */
N
N#ifdef HAL_DMA2D_MODULE_ENABLED
S  #include "stm32f4xx_hal_dma2d.h"
N#endif /* HAL_DMA2D_MODULE_ENABLED */
N
N#ifdef HAL_DAC_MODULE_ENABLED
S  #include "stm32f4xx_hal_dac.h"
N#endif /* HAL_DAC_MODULE_ENABLED */
N
N#ifdef HAL_DCMI_MODULE_ENABLED
S  #include "stm32f4xx_hal_dcmi.h"
N#endif /* HAL_DCMI_MODULE_ENABLED */
N
N#ifdef HAL_ETH_MODULE_ENABLED
S  #include "stm32f4xx_hal_eth.h"
N#endif /* HAL_ETH_MODULE_ENABLED */
N
N#ifdef HAL_FLASH_MODULE_ENABLED
N  #include "stm32f4xx_hal_flash.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_flash.h
N  * @author  MCD Application Team
N  * @brief   Header file of FLASH HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_FLASH_H
N#define __STM32F4xx_HAL_FLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup FLASH
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Types FLASH Exported Types
N  * @{
N  */
N 
N/**
N  * @brief  FLASH Procedure structure definition
N  */
Ntypedef enum 
N{
N  FLASH_PROC_NONE = 0U, 
N  FLASH_PROC_SECTERASE,
N  FLASH_PROC_MASSERASE,
N  FLASH_PROC_PROGRAM
N} FLASH_ProcedureTypeDef;
N
N/** 
N  * @brief  FLASH handle Structure definition  
N  */
Ntypedef struct
N{
N  __IO FLASH_ProcedureTypeDef ProcedureOnGoing;   /*Internal variable to indicate which procedure is ongoing or not in IT context*/
X  volatile FLASH_ProcedureTypeDef ProcedureOnGoing;    
N  
N  __IO uint32_t               NbSectorsToErase;   /*Internal variable to save the remaining sectors to erase in IT context*/
X  volatile uint32_t               NbSectorsToErase;    
N  
N  __IO uint8_t                VoltageForErase;    /*Internal variable to provide voltage range selected by user in IT context*/
X  volatile uint8_t                VoltageForErase;     
N  
N  __IO uint32_t               Sector;             /*Internal variable to define the current sector which is erasing*/
X  volatile uint32_t               Sector;              
N  
N  __IO uint32_t               Bank;               /*Internal variable to save current bank selected during mass erase*/
X  volatile uint32_t               Bank;                
N  
N  __IO uint32_t               Address;            /*Internal variable to save address selected for program*/
X  volatile uint32_t               Address;             
N  
N  HAL_LockTypeDef             Lock;               /* FLASH locking object                */
N
N  __IO uint32_t               ErrorCode;          /* FLASH error code                    */
X  volatile uint32_t               ErrorCode;           
N
N}FLASH_ProcessTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Constants FLASH Exported Constants
N  * @{
N  */  
N/** @defgroup FLASH_Error_Code FLASH Error Code
N  * @brief    FLASH Error Code 
N  * @{
N  */ 
N#define HAL_FLASH_ERROR_NONE         0x00000000U    /*!< No error                      */
N#define HAL_FLASH_ERROR_RD           0x00000001U    /*!< Read Protection error         */
N#define HAL_FLASH_ERROR_PGS          0x00000002U    /*!< Programming Sequence error    */
N#define HAL_FLASH_ERROR_PGP          0x00000004U    /*!< Programming Parallelism error */
N#define HAL_FLASH_ERROR_PGA          0x00000008U    /*!< Programming Alignment error   */
N#define HAL_FLASH_ERROR_WRP          0x00000010U    /*!< Write protection error        */
N#define HAL_FLASH_ERROR_OPERATION    0x00000020U    /*!< Operation Error               */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Type_Program FLASH Type Program
N  * @{
N  */ 
N#define FLASH_TYPEPROGRAM_BYTE        0x00000000U  /*!< Program byte (8-bit) at a specified address           */
N#define FLASH_TYPEPROGRAM_HALFWORD    0x00000001U  /*!< Program a half-word (16-bit) at a specified address   */
N#define FLASH_TYPEPROGRAM_WORD        0x00000002U  /*!< Program a word (32-bit) at a specified address        */
N#define FLASH_TYPEPROGRAM_DOUBLEWORD  0x00000003U  /*!< Program a double word (64-bit) at a specified address */
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Flag_definition FLASH Flag definition
N  * @brief Flag definition
N  * @{
N  */ 
N#define FLASH_FLAG_EOP                 FLASH_SR_EOP            /*!< FLASH End of Operation flag               */
N#define FLASH_FLAG_OPERR               FLASH_SR_SOP            /*!< FLASH operation Error flag                */
N#define FLASH_FLAG_WRPERR              FLASH_SR_WRPERR         /*!< FLASH Write protected error flag          */
N#define FLASH_FLAG_PGAERR              FLASH_SR_PGAERR         /*!< FLASH Programming Alignment error flag    */
N#define FLASH_FLAG_PGPERR              FLASH_SR_PGPERR         /*!< FLASH Programming Parallelism error flag  */
N#define FLASH_FLAG_PGSERR              FLASH_SR_PGSERR         /*!< FLASH Programming Sequence error flag     */
N#if defined(FLASH_SR_RDERR)
X#if 0L
S#define FLASH_FLAG_RDERR               FLASH_SR_RDERR          /*!< Read Protection error flag (PCROP)        */
N#endif /* FLASH_SR_RDERR */
N#define FLASH_FLAG_BSY                 FLASH_SR_BSY            /*!< FLASH Busy flag                           */ 
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Interrupt_definition FLASH Interrupt definition
N  * @brief FLASH Interrupt definition
N  * @{
N  */ 
N#define FLASH_IT_EOP                   FLASH_CR_EOPIE          /*!< End of FLASH Operation Interrupt source */
N#define FLASH_IT_ERR                   0x02000000U             /*!< Error Interrupt source                  */
N/**
N  * @}
N  */  
N
N/** @defgroup FLASH_Program_Parallelism FLASH Program Parallelism
N  * @{
N  */
N#define FLASH_PSIZE_BYTE           0x00000000U
N#define FLASH_PSIZE_HALF_WORD      0x00000100U
N#define FLASH_PSIZE_WORD           0x00000200U
N#define FLASH_PSIZE_DOUBLE_WORD    0x00000300U
N#define CR_PSIZE_MASK              0xFFFFFCFFU
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Keys FLASH Keys
N  * @{
N  */ 
N#define RDP_KEY                  ((uint16_t)0x00A5)
N#define FLASH_KEY1               0x45670123U
N#define FLASH_KEY2               0xCDEF89ABU
N#define FLASH_OPT_KEY1           0x08192A3BU
N#define FLASH_OPT_KEY2           0x4C5D6E7FU
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Macros FLASH Exported Macros
N  * @{
N  */
N/**
N  * @brief  Set the FLASH Latency.
N  * @param  __LATENCY__ FLASH Latency
N  *         The value of this parameter depend on device used within the same series
N  * @retval none
N  */ 
N#define __HAL_FLASH_SET_LATENCY(__LATENCY__) (*(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)(__LATENCY__))
N
N/**
N  * @brief  Get the FLASH Latency.
N  * @retval FLASH Latency
N  *          The value of this parameter depend on device used within the same series
N  */ 
N#define __HAL_FLASH_GET_LATENCY()     (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY))
N
N/**
N  * @brief  Enable the FLASH prefetch buffer.
N  * @retval none
N  */ 
N#define __HAL_FLASH_PREFETCH_BUFFER_ENABLE()  (FLASH->ACR |= FLASH_ACR_PRFTEN)
N
N/**
N  * @brief  Disable the FLASH prefetch buffer.
N  * @retval none
N  */ 
N#define __HAL_FLASH_PREFETCH_BUFFER_DISABLE()   (FLASH->ACR &= (~FLASH_ACR_PRFTEN))
N
N/**
N  * @brief  Enable the FLASH instruction cache.
N  * @retval none
N  */ 
N#define __HAL_FLASH_INSTRUCTION_CACHE_ENABLE()  (FLASH->ACR |= FLASH_ACR_ICEN)
N
N/**
N  * @brief  Disable the FLASH instruction cache.
N  * @retval none
N  */ 
N#define __HAL_FLASH_INSTRUCTION_CACHE_DISABLE()   (FLASH->ACR &= (~FLASH_ACR_ICEN))
N
N/**
N  * @brief  Enable the FLASH data cache.
N  * @retval none
N  */ 
N#define __HAL_FLASH_DATA_CACHE_ENABLE()  (FLASH->ACR |= FLASH_ACR_DCEN)
N
N/**
N  * @brief  Disable the FLASH data cache.
N  * @retval none
N  */ 
N#define __HAL_FLASH_DATA_CACHE_DISABLE()   (FLASH->ACR &= (~FLASH_ACR_DCEN))
N
N/**
N  * @brief  Resets the FLASH instruction Cache.
N  * @note   This function must be used only when the Instruction Cache is disabled.  
N  * @retval None
N  */
N#define __HAL_FLASH_INSTRUCTION_CACHE_RESET() do {FLASH->ACR |= FLASH_ACR_ICRST;  \
N                                                  FLASH->ACR &= ~FLASH_ACR_ICRST; \
N                                                 }while(0U)
X#define __HAL_FLASH_INSTRUCTION_CACHE_RESET() do {FLASH->ACR |= FLASH_ACR_ICRST;                                                    FLASH->ACR &= ~FLASH_ACR_ICRST;                                                  }while(0U)
N
N/**
N  * @brief  Resets the FLASH data Cache.
N  * @note   This function must be used only when the data Cache is disabled.  
N  * @retval None
N  */
N#define __HAL_FLASH_DATA_CACHE_RESET() do {FLASH->ACR |= FLASH_ACR_DCRST;  \
N                                           FLASH->ACR &= ~FLASH_ACR_DCRST; \
N                                          }while(0U)
X#define __HAL_FLASH_DATA_CACHE_RESET() do {FLASH->ACR |= FLASH_ACR_DCRST;                                             FLASH->ACR &= ~FLASH_ACR_DCRST;                                           }while(0U)
N/**
N  * @brief  Enable the specified FLASH interrupt.
N  * @param  __INTERRUPT__  FLASH interrupt 
N  *         This parameter can be any combination of the following values:
N  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
N  *     @arg FLASH_IT_ERR: Error Interrupt    
N  * @retval none
N  */  
N#define __HAL_FLASH_ENABLE_IT(__INTERRUPT__)  (FLASH->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the specified FLASH interrupt.
N  * @param  __INTERRUPT__  FLASH interrupt 
N  *         This parameter can be any combination of the following values:
N  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
N  *     @arg FLASH_IT_ERR: Error Interrupt    
N  * @retval none
N  */  
N#define __HAL_FLASH_DISABLE_IT(__INTERRUPT__)  (FLASH->CR &= ~(uint32_t)(__INTERRUPT__))
N
N/**
N  * @brief  Get the specified FLASH flag status. 
N  * @param  __FLAG__ specifies the FLASH flags to check.
N  *          This parameter can be any combination of the following values:
N  *            @arg FLASH_FLAG_EOP   : FLASH End of Operation flag 
N  *            @arg FLASH_FLAG_OPERR : FLASH operation Error flag 
N  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
N  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
N  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
N  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
N  *            @arg FLASH_FLAG_RDERR : FLASH Read Protection error flag (PCROP) (*)
N  *            @arg FLASH_FLAG_BSY   : FLASH Busy flag
N  *           (*) FLASH_FLAG_RDERR is not available for STM32F405xx/407xx/415xx/417xx devices                             
N  * @retval The new state of __FLAG__ (SET or RESET).
N  */
N#define __HAL_FLASH_GET_FLAG(__FLAG__)   ((FLASH->SR & (__FLAG__)))
N
N/**
N  * @brief  Clear the specified FLASH flags.
N  * @param  __FLAG__ specifies the FLASH flags to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg FLASH_FLAG_EOP   : FLASH End of Operation flag 
N  *            @arg FLASH_FLAG_OPERR : FLASH operation Error flag 
N  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
N  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
N  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
N  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
N  *            @arg FLASH_FLAG_RDERR : FLASH Read Protection error flag (PCROP) (*)
N  *           (*) FLASH_FLAG_RDERR is not available for STM32F405xx/407xx/415xx/417xx devices   
N  * @retval none
N  */
N#define __HAL_FLASH_CLEAR_FLAG(__FLAG__)   (FLASH->SR = (__FLAG__))
N/**
N  * @}
N  */
N
N/* Include FLASH HAL Extension module */
N#include "stm32f4xx_hal_flash_ex.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_flash_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of FLASH HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_FLASH_EX_H
N#define __STM32F4xx_HAL_FLASH_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup FLASHEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup FLASHEx_Exported_Types FLASH Exported Types
N  * @{
N  */
N
N/**
N  * @brief  FLASH Erase structure definition
N  */
Ntypedef struct
N{
N  uint32_t TypeErase;   /*!< Mass erase or sector Erase.
N                             This parameter can be a value of @ref FLASHEx_Type_Erase */
N
N  uint32_t Banks;       /*!< Select banks to erase when Mass erase is enabled.
N                             This parameter must be a value of @ref FLASHEx_Banks */
N
N  uint32_t Sector;      /*!< Initial FLASH sector to erase when Mass erase is disabled
N                             This parameter must be a value of @ref FLASHEx_Sectors */
N
N  uint32_t NbSectors;   /*!< Number of sectors to be erased.
N                             This parameter must be a value between 1 and (max number of sectors - value of Initial sector)*/
N
N  uint32_t VoltageRange;/*!< The device voltage range which defines the erase parallelism
N                             This parameter must be a value of @ref FLASHEx_Voltage_Range */
N
N} FLASH_EraseInitTypeDef;
N
N/**
N  * @brief  FLASH Option Bytes Program structure definition
N  */
Ntypedef struct
N{
N  uint32_t OptionType;   /*!< Option byte to be configured.
N                              This parameter can be a value of @ref FLASHEx_Option_Type */
N
N  uint32_t WRPState;     /*!< Write protection activation or deactivation.
N                              This parameter can be a value of @ref FLASHEx_WRP_State */
N
N  uint32_t WRPSector;         /*!< Specifies the sector(s) to be write protected.
N                              The value of this parameter depend on device used within the same series */
N
N  uint32_t Banks;        /*!< Select banks for WRP activation/deactivation of all sectors.
N                              This parameter must be a value of @ref FLASHEx_Banks */        
N
N  uint32_t RDPLevel;     /*!< Set the read protection level.
N                              This parameter can be a value of @ref FLASHEx_Option_Bytes_Read_Protection */
N
N  uint32_t BORLevel;     /*!< Set the BOR Level.
N                              This parameter can be a value of @ref FLASHEx_BOR_Reset_Level */
N
N  uint8_t  USERConfig;   /*!< Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY. */
N
N} FLASH_OBProgramInitTypeDef;
N
N/**
N  * @brief  FLASH Advanced Option Bytes Program structure definition
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
Stypedef struct
S{
S  uint32_t OptionType;     /*!< Option byte to be configured for extension.
S                                This parameter can be a value of @ref FLASHEx_Advanced_Option_Type */
S
S  uint32_t PCROPState;     /*!< PCROP activation or deactivation.
S                                This parameter can be a value of @ref FLASHEx_PCROP_State */
S
S#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
S    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
S  uint16_t Sectors;        /*!< specifies the sector(s) set for PCROP.
S                                This parameter can be a value of @ref FLASHEx_Option_Bytes_PC_ReadWrite_Protection */
S#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx ||\
S          STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
S
S#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
S  uint32_t Banks;          /*!< Select banks for PCROP activation/deactivation of all sectors.
S                                This parameter must be a value of @ref FLASHEx_Banks */
S
S  uint16_t SectorsBank1;   /*!< Specifies the sector(s) set for PCROP for Bank1.
S                                This parameter can be a value of @ref FLASHEx_Option_Bytes_PC_ReadWrite_Protection */
S
S  uint16_t SectorsBank2;   /*!< Specifies the sector(s) set for PCROP for Bank2.
S                                This parameter can be a value of @ref FLASHEx_Option_Bytes_PC_ReadWrite_Protection */
S
S  uint8_t BootConfig;      /*!< Specifies Option bytes for boot config.
S                                This parameter can be a value of @ref FLASHEx_Dual_Boot */
S
S#endif /*STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
S}FLASH_AdvOBProgramInitTypeDef;
S#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx ||
N          STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup FLASHEx_Exported_Constants FLASH Exported Constants
N  * @{
N  */
N
N/** @defgroup FLASHEx_Type_Erase FLASH Type Erase
N  * @{
N  */ 
N#define FLASH_TYPEERASE_SECTORS         0x00000000U  /*!< Sectors erase only          */
N#define FLASH_TYPEERASE_MASSERASE       0x00000001U  /*!< Flash Mass erase activation */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Voltage_Range FLASH Voltage Range
N  * @{
N  */ 
N#define FLASH_VOLTAGE_RANGE_1        0x00000000U  /*!< Device operating range: 1.8V to 2.1V                */
N#define FLASH_VOLTAGE_RANGE_2        0x00000001U  /*!< Device operating range: 2.1V to 2.7V                */
N#define FLASH_VOLTAGE_RANGE_3        0x00000002U  /*!< Device operating range: 2.7V to 3.6V                */
N#define FLASH_VOLTAGE_RANGE_4        0x00000003U  /*!< Device operating range: 2.7V to 3.6V + External Vpp */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_WRP_State FLASH WRP State
N  * @{
N  */ 
N#define OB_WRPSTATE_DISABLE       0x00000000U  /*!< Disable the write protection of the desired bank 1 sectors */
N#define OB_WRPSTATE_ENABLE        0x00000001U  /*!< Enable the write protection of the desired bank 1 sectors  */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Option_Type FLASH Option Type
N  * @{
N  */ 
N#define OPTIONBYTE_WRP        0x00000001U  /*!< WRP option byte configuration  */
N#define OPTIONBYTE_RDP        0x00000002U  /*!< RDP option byte configuration  */
N#define OPTIONBYTE_USER       0x00000004U  /*!< USER option byte configuration */
N#define OPTIONBYTE_BOR        0x00000008U  /*!< BOR option byte configuration  */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Option_Bytes_Read_Protection FLASH Option Bytes Read Protection
N  * @{
N  */
N#define OB_RDP_LEVEL_0   ((uint8_t)0xAA)
N#define OB_RDP_LEVEL_1   ((uint8_t)0x55)
N#define OB_RDP_LEVEL_2   ((uint8_t)0xCC) /*!< Warning: When enabling read protection level 2 
N                                              it s no more possible to go back to level 1 or 0 */
N/**
N  * @}
N  */ 
N  
N/** @defgroup FLASHEx_Option_Bytes_IWatchdog FLASH Option Bytes IWatchdog
N  * @{
N  */ 
N#define OB_IWDG_SW                     ((uint8_t)0x20)  /*!< Software IWDG selected */
N#define OB_IWDG_HW                     ((uint8_t)0x00)  /*!< Hardware IWDG selected */
N/**
N  * @}
N  */ 
N  
N/** @defgroup FLASHEx_Option_Bytes_nRST_STOP FLASH Option Bytes nRST_STOP
N  * @{
N  */ 
N#define OB_STOP_NO_RST                 ((uint8_t)0x40) /*!< No reset generated when entering in STOP */
N#define OB_STOP_RST                    ((uint8_t)0x00) /*!< Reset generated when entering in STOP    */
N/**
N  * @}
N  */ 
N
N
N/** @defgroup FLASHEx_Option_Bytes_nRST_STDBY FLASH Option Bytes nRST_STDBY
N  * @{
N  */ 
N#define OB_STDBY_NO_RST                ((uint8_t)0x80) /*!< No reset generated when entering in STANDBY */
N#define OB_STDBY_RST                   ((uint8_t)0x00) /*!< Reset generated when entering in STANDBY    */
N/**
N  * @}
N  */    
N
N/** @defgroup FLASHEx_BOR_Reset_Level FLASH BOR Reset Level
N  * @{
N  */  
N#define OB_BOR_LEVEL3          ((uint8_t)0x00)  /*!< Supply voltage ranges from 2.70 to 3.60 V */
N#define OB_BOR_LEVEL2          ((uint8_t)0x04)  /*!< Supply voltage ranges from 2.40 to 2.70 V */
N#define OB_BOR_LEVEL1          ((uint8_t)0x08)  /*!< Supply voltage ranges from 2.10 to 2.40 V */
N#define OB_BOR_OFF             ((uint8_t)0x0C)  /*!< Supply voltage ranges from 1.62 to 2.10 V */
N/**
N  * @}
N  */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
S/** @defgroup FLASHEx_PCROP_State FLASH PCROP State
S  * @{
S  */ 
S#define OB_PCROP_STATE_DISABLE       0x00000000U  /*!< Disable PCROP */
S#define OB_PCROP_STATE_ENABLE        0x00000001U  /*!< Enable PCROP  */
S/**
S  * @}
S  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N/** @defgroup FLASHEx_Advanced_Option_Type FLASH Advanced Option Type
N  * @{
N  */ 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define OPTIONBYTE_PCROP        0x00000001U  /*!< PCROP option byte configuration      */
S#define OPTIONBYTE_BOOTCONFIG   0x00000002U  /*!< BOOTConfig option byte configuration */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
S#define OPTIONBYTE_PCROP        0x00000001U  /*!<PCROP option byte configuration */
S#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
N          STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Latency FLASH Latency
N  * @{
N  */
N/*------------------------- STM32F42xxx/STM32F43xxx/STM32F446xx/STM32F469xx/STM32F479xx ----------------------*/  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L || 0L
S#define FLASH_LATENCY_0                FLASH_ACR_LATENCY_0WS   /*!< FLASH Zero Latency cycle      */
S#define FLASH_LATENCY_1                FLASH_ACR_LATENCY_1WS   /*!< FLASH One Latency cycle       */
S#define FLASH_LATENCY_2                FLASH_ACR_LATENCY_2WS   /*!< FLASH Two Latency cycles      */
S#define FLASH_LATENCY_3                FLASH_ACR_LATENCY_3WS   /*!< FLASH Three Latency cycles    */
S#define FLASH_LATENCY_4                FLASH_ACR_LATENCY_4WS   /*!< FLASH Four Latency cycles     */
S#define FLASH_LATENCY_5                FLASH_ACR_LATENCY_5WS   /*!< FLASH Five Latency cycles     */
S#define FLASH_LATENCY_6                FLASH_ACR_LATENCY_6WS   /*!< FLASH Six Latency cycles      */
S#define FLASH_LATENCY_7                FLASH_ACR_LATENCY_7WS   /*!< FLASH Seven Latency cycles    */
S#define FLASH_LATENCY_8                FLASH_ACR_LATENCY_8WS   /*!< FLASH Eight Latency cycles    */
S#define FLASH_LATENCY_9                FLASH_ACR_LATENCY_9WS   /*!< FLASH Nine Latency cycles     */
S#define FLASH_LATENCY_10               FLASH_ACR_LATENCY_10WS  /*!< FLASH Ten Latency cycles      */
S#define FLASH_LATENCY_11               FLASH_ACR_LATENCY_11WS  /*!< FLASH Eleven Latency cycles   */
S#define FLASH_LATENCY_12               FLASH_ACR_LATENCY_12WS  /*!< FLASH Twelve Latency cycles   */
S#define FLASH_LATENCY_13               FLASH_ACR_LATENCY_13WS  /*!< FLASH Thirteen Latency cycles */
S#define FLASH_LATENCY_14               FLASH_ACR_LATENCY_14WS  /*!< FLASH Fourteen Latency cycles */
S#define FLASH_LATENCY_15               FLASH_ACR_LATENCY_15WS  /*!< FLASH Fifteen Latency cycles  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/*--------------------------------------------------------------------------------------------------------------*/
N
N/*-------------------------- STM32F40xxx/STM32F41xxx/STM32F401xx/STM32F411xx/STM32F423xx -----------------------*/ 
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 1L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L
N     
N#define FLASH_LATENCY_0                FLASH_ACR_LATENCY_0WS   /*!< FLASH Zero Latency cycle      */
N#define FLASH_LATENCY_1                FLASH_ACR_LATENCY_1WS   /*!< FLASH One Latency cycle       */
N#define FLASH_LATENCY_2                FLASH_ACR_LATENCY_2WS   /*!< FLASH Two Latency cycles      */
N#define FLASH_LATENCY_3                FLASH_ACR_LATENCY_3WS   /*!< FLASH Three Latency cycles    */
N#define FLASH_LATENCY_4                FLASH_ACR_LATENCY_4WS   /*!< FLASH Four Latency cycles     */
N#define FLASH_LATENCY_5                FLASH_ACR_LATENCY_5WS   /*!< FLASH Five Latency cycles     */
N#define FLASH_LATENCY_6                FLASH_ACR_LATENCY_6WS   /*!< FLASH Six Latency cycles      */
N#define FLASH_LATENCY_7                FLASH_ACR_LATENCY_7WS   /*!< FLASH Seven Latency cycles    */
N#endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
N          STM32F413xx || STM32F423xx */
N/*--------------------------------------------------------------------------------------------------------------*/
N
N/**
N  * @}
N  */ 
N  
N
N/** @defgroup FLASHEx_Banks FLASH Banks
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
S#define FLASH_BANK_1     1U /*!< Bank 1   */
S#define FLASH_BANK_2     2U /*!< Bank 2   */
S#define FLASH_BANK_BOTH  ((uint32_t)FLASH_BANK_1 | FLASH_BANK_2) /*!< Bank1 and Bank2  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 1L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
N#define FLASH_BANK_1     1U /*!< Bank 1   */
N#endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
N          STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */ 
N    
N/** @defgroup FLASHEx_MassErase_bit FLASH Mass Erase bit
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
S#define FLASH_MER_BIT     (FLASH_CR_MER1 | FLASH_CR_MER2) /*!< 2 MER bits here to clear */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 1L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
N#define FLASH_MER_BIT     (FLASH_CR_MER) /*!< only 1 MER Bit */
N#endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
N          STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASHEx_Sectors FLASH Sectors
N  * @{
N  */
N/*-------------------------------------- STM32F42xxx/STM32F43xxx/STM32F469xx ------------------------------------*/   
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
S#define FLASH_SECTOR_0     0U  /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U  /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U  /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U  /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U  /*!< Sector Number 4   */
S#define FLASH_SECTOR_5     5U  /*!< Sector Number 5   */
S#define FLASH_SECTOR_6     6U  /*!< Sector Number 6   */
S#define FLASH_SECTOR_7     7U  /*!< Sector Number 7   */
S#define FLASH_SECTOR_8     8U  /*!< Sector Number 8   */
S#define FLASH_SECTOR_9     9U  /*!< Sector Number 9   */
S#define FLASH_SECTOR_10    10U /*!< Sector Number 10  */
S#define FLASH_SECTOR_11    11U /*!< Sector Number 11  */
S#define FLASH_SECTOR_12    12U /*!< Sector Number 12  */
S#define FLASH_SECTOR_13    13U /*!< Sector Number 13  */
S#define FLASH_SECTOR_14    14U /*!< Sector Number 14  */
S#define FLASH_SECTOR_15    15U /*!< Sector Number 15  */
S#define FLASH_SECTOR_16    16U /*!< Sector Number 16  */
S#define FLASH_SECTOR_17    17U /*!< Sector Number 17  */
S#define FLASH_SECTOR_18    18U /*!< Sector Number 18  */
S#define FLASH_SECTOR_19    19U /*!< Sector Number 19  */
S#define FLASH_SECTOR_20    20U /*!< Sector Number 20  */
S#define FLASH_SECTOR_21    21U /*!< Sector Number 21  */
S#define FLASH_SECTOR_22    22U /*!< Sector Number 22  */
S#define FLASH_SECTOR_23    23U /*!< Sector Number 23  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*-------------------------------------- STM32F413xx/STM32F423xx --------------------------------------*/   
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define FLASH_SECTOR_0     0U  /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U  /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U  /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U  /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U  /*!< Sector Number 4   */
S#define FLASH_SECTOR_5     5U  /*!< Sector Number 5   */
S#define FLASH_SECTOR_6     6U  /*!< Sector Number 6   */
S#define FLASH_SECTOR_7     7U  /*!< Sector Number 7   */
S#define FLASH_SECTOR_8     8U  /*!< Sector Number 8   */
S#define FLASH_SECTOR_9     9U  /*!< Sector Number 9   */
S#define FLASH_SECTOR_10    10U /*!< Sector Number 10  */
S#define FLASH_SECTOR_11    11U /*!< Sector Number 11  */
S#define FLASH_SECTOR_12    12U /*!< Sector Number 12  */
S#define FLASH_SECTOR_13    13U /*!< Sector Number 13  */
S#define FLASH_SECTOR_14    14U /*!< Sector Number 14  */
S#define FLASH_SECTOR_15    15U /*!< Sector Number 15  */
N#endif /* STM32F413xx || STM32F423xx */
N/*-----------------------------------------------------------------------------------------------------*/      
N
N/*--------------------------------------- STM32F40xxx/STM32F41xxx -------------------------------------*/ 
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 1L || 0L || 0L ||    0L || 0L || 0L  
N#define FLASH_SECTOR_0     0U  /*!< Sector Number 0   */
N#define FLASH_SECTOR_1     1U  /*!< Sector Number 1   */
N#define FLASH_SECTOR_2     2U  /*!< Sector Number 2   */
N#define FLASH_SECTOR_3     3U  /*!< Sector Number 3   */
N#define FLASH_SECTOR_4     4U  /*!< Sector Number 4   */
N#define FLASH_SECTOR_5     5U  /*!< Sector Number 5   */
N#define FLASH_SECTOR_6     6U  /*!< Sector Number 6   */
N#define FLASH_SECTOR_7     7U  /*!< Sector Number 7   */
N#define FLASH_SECTOR_8     8U  /*!< Sector Number 8   */
N#define FLASH_SECTOR_9     9U  /*!< Sector Number 9   */
N#define FLASH_SECTOR_10    10U /*!< Sector Number 10  */
N#define FLASH_SECTOR_11    11U /*!< Sector Number 11  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------------- STM32F401xC -------------------------------------------*/ 
N#if defined(STM32F401xC)
X#if 0L
S#define FLASH_SECTOR_0     0U /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U /*!< Sector Number 4   */
S#define FLASH_SECTOR_5     5U /*!< Sector Number 5   */
N#endif /* STM32F401xC */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------------- STM32F410xx -------------------------------------------*/ 
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define FLASH_SECTOR_0     0U /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U /*!< Sector Number 4   */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F401xE/STM32F411xE/STM32F446xx ------------------------------*/
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx)
X#if 0L || 0L || 0L
S#define FLASH_SECTOR_0     0U /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U /*!< Sector Number 4   */
S#define FLASH_SECTOR_5     5U /*!< Sector Number 5   */
S#define FLASH_SECTOR_6     6U /*!< Sector Number 6   */
S#define FLASH_SECTOR_7     7U /*!< Sector Number 7   */
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASHEx_Option_Bytes_Write_Protection FLASH Option Bytes Write Protection
N  * @{
N  */
N/*--------------------------- STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx -------------------------*/  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L ||    0L || 0L 
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
S#define OB_WRP_SECTOR_6       0x00000040U /*!< Write protection of Sector6     */
S#define OB_WRP_SECTOR_7       0x00000080U /*!< Write protection of Sector7     */
S#define OB_WRP_SECTOR_8       0x00000100U /*!< Write protection of Sector8     */
S#define OB_WRP_SECTOR_9       0x00000200U /*!< Write protection of Sector9     */
S#define OB_WRP_SECTOR_10      0x00000400U /*!< Write protection of Sector10    */
S#define OB_WRP_SECTOR_11      0x00000800U /*!< Write protection of Sector11    */
S#define OB_WRP_SECTOR_12      0x00000001U << 12U /*!< Write protection of Sector12    */
S#define OB_WRP_SECTOR_13      0x00000002U << 12U /*!< Write protection of Sector13    */
S#define OB_WRP_SECTOR_14      0x00000004U << 12U /*!< Write protection of Sector14    */
S#define OB_WRP_SECTOR_15      0x00000008U << 12U /*!< Write protection of Sector15    */
S#define OB_WRP_SECTOR_16      0x00000010U << 12U /*!< Write protection of Sector16    */
S#define OB_WRP_SECTOR_17      0x00000020U << 12U /*!< Write protection of Sector17    */
S#define OB_WRP_SECTOR_18      0x00000040U << 12U /*!< Write protection of Sector18    */
S#define OB_WRP_SECTOR_19      0x00000080U << 12U /*!< Write protection of Sector19    */
S#define OB_WRP_SECTOR_20      0x00000100U << 12U /*!< Write protection of Sector20    */
S#define OB_WRP_SECTOR_21      0x00000200U << 12U /*!< Write protection of Sector21    */
S#define OB_WRP_SECTOR_22      0x00000400U << 12U /*!< Write protection of Sector22    */
S#define OB_WRP_SECTOR_23      0x00000800U << 12U /*!< Write protection of Sector23    */
S#define OB_WRP_SECTOR_All     0x00000FFFU << 12U /*!< Write protection of all Sectors */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------- STM32F413xx/STM32F423xx -------------------------------------*/ 
N#if defined(STM32F413xx) || defined(STM32F423xx)  
X#if 0L || 0L  
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
S#define OB_WRP_SECTOR_6       0x00000040U /*!< Write protection of Sector6     */
S#define OB_WRP_SECTOR_7       0x00000080U /*!< Write protection of Sector7     */
S#define OB_WRP_SECTOR_8       0x00000100U /*!< Write protection of Sector8     */
S#define OB_WRP_SECTOR_9       0x00000200U /*!< Write protection of Sector9     */
S#define OB_WRP_SECTOR_10      0x00000400U /*!< Write protection of Sector10    */
S#define OB_WRP_SECTOR_11      0x00000800U /*!< Write protection of Sector11    */
S#define OB_WRP_SECTOR_12      0x00001000U /*!< Write protection of Sector12    */
S#define OB_WRP_SECTOR_13      0x00002000U /*!< Write protection of Sector13    */
S#define OB_WRP_SECTOR_14      0x00004000U /*!< Write protection of Sector14    */
S#define OB_WRP_SECTOR_15      0x00004000U /*!< Write protection of Sector15    */      
S#define OB_WRP_SECTOR_All     0x00007FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F413xx || STM32F423xx */
N/*-----------------------------------------------------------------------------------------------------*/    
N      
N/*--------------------------------------- STM32F40xxx/STM32F41xxx -------------------------------------*/ 
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 1L || 0L || 0L ||    0L || 0L || 0L  
N#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
N#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
N#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
N#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
N#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
N#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
N#define OB_WRP_SECTOR_6       0x00000040U /*!< Write protection of Sector6     */
N#define OB_WRP_SECTOR_7       0x00000080U /*!< Write protection of Sector7     */
N#define OB_WRP_SECTOR_8       0x00000100U /*!< Write protection of Sector8     */
N#define OB_WRP_SECTOR_9       0x00000200U /*!< Write protection of Sector9     */
N#define OB_WRP_SECTOR_10      0x00000400U /*!< Write protection of Sector10    */
N#define OB_WRP_SECTOR_11      0x00000800U /*!< Write protection of Sector11    */
N#define OB_WRP_SECTOR_All     0x00000FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------------- STM32F401xC -------------------------------------------*/
N#if defined(STM32F401xC)
X#if 0L
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
S#define OB_WRP_SECTOR_All     0x00000FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F401xC */
N/*-----------------------------------------------------------------------------------------------------*/
N 
N/*--------------------------------------------- STM32F410xx -------------------------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_All     0x00000FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F401xE/STM32F411xE/STM32F446xx ------------------------------*/
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx)
X#if 0L || 0L || 0L
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
S#define OB_WRP_SECTOR_6       0x00000040U /*!< Write protection of Sector6     */
S#define OB_WRP_SECTOR_7       0x00000080U /*!< Write protection of Sector7     */
S#define OB_WRP_SECTOR_All     0x00000FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx */
N/*-----------------------------------------------------------------------------------------------------*/
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Option_Bytes_PC_ReadWrite_Protection FLASH Option Bytes PC ReadWrite Protection
N  * @{
N  */
N/*-------------------------------- STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx ---------------------------*/   
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L|| 0L ||    0L || 0L 
S#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
S#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
S#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
S#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
S#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
S#define OB_PCROP_SECTOR_5        0x00000020U /*!< PC Read/Write protection of Sector5      */
S#define OB_PCROP_SECTOR_6        0x00000040U /*!< PC Read/Write protection of Sector6      */
S#define OB_PCROP_SECTOR_7        0x00000080U /*!< PC Read/Write protection of Sector7      */
S#define OB_PCROP_SECTOR_8        0x00000100U /*!< PC Read/Write protection of Sector8      */
S#define OB_PCROP_SECTOR_9        0x00000200U /*!< PC Read/Write protection of Sector9      */
S#define OB_PCROP_SECTOR_10       0x00000400U /*!< PC Read/Write protection of Sector10     */
S#define OB_PCROP_SECTOR_11       0x00000800U /*!< PC Read/Write protection of Sector11     */
S#define OB_PCROP_SECTOR_12       0x00000001U /*!< PC Read/Write protection of Sector12     */
S#define OB_PCROP_SECTOR_13       0x00000002U /*!< PC Read/Write protection of Sector13     */
S#define OB_PCROP_SECTOR_14       0x00000004U /*!< PC Read/Write protection of Sector14     */
S#define OB_PCROP_SECTOR_15       0x00000008U /*!< PC Read/Write protection of Sector15     */
S#define OB_PCROP_SECTOR_16       0x00000010U /*!< PC Read/Write protection of Sector16     */
S#define OB_PCROP_SECTOR_17       0x00000020U /*!< PC Read/Write protection of Sector17     */
S#define OB_PCROP_SECTOR_18       0x00000040U /*!< PC Read/Write protection of Sector18     */
S#define OB_PCROP_SECTOR_19       0x00000080U /*!< PC Read/Write protection of Sector19     */
S#define OB_PCROP_SECTOR_20       0x00000100U /*!< PC Read/Write protection of Sector20     */
S#define OB_PCROP_SECTOR_21       0x00000200U /*!< PC Read/Write protection of Sector21     */
S#define OB_PCROP_SECTOR_22       0x00000400U /*!< PC Read/Write protection of Sector22     */
S#define OB_PCROP_SECTOR_23       0x00000800U /*!< PC Read/Write protection of Sector23     */
S#define OB_PCROP_SECTOR_All      0x00000FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/*-----------------------------------------------------------------------------------------------------*/
N      
N/*------------------------------------- STM32F413xx/STM32F423xx ---------------------------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)  
X#if 0L || 0L  
S#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
S#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
S#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
S#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
S#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
S#define OB_PCROP_SECTOR_5        0x00000020U /*!< PC Read/Write protection of Sector5      */
S#define OB_PCROP_SECTOR_6        0x00000040U /*!< PC Read/Write protection of Sector6      */
S#define OB_PCROP_SECTOR_7        0x00000080U /*!< PC Read/Write protection of Sector7      */
S#define OB_PCROP_SECTOR_8        0x00000100U /*!< PC Read/Write protection of Sector8      */
S#define OB_PCROP_SECTOR_9        0x00000200U /*!< PC Read/Write protection of Sector9      */
S#define OB_PCROP_SECTOR_10       0x00000400U /*!< PC Read/Write protection of Sector10     */
S#define OB_PCROP_SECTOR_11       0x00000800U /*!< PC Read/Write protection of Sector11     */
S#define OB_PCROP_SECTOR_12       0x00001000U /*!< PC Read/Write protection of Sector12     */
S#define OB_PCROP_SECTOR_13       0x00002000U /*!< PC Read/Write protection of Sector13     */
S#define OB_PCROP_SECTOR_14       0x00004000U /*!< PC Read/Write protection of Sector14     */
S#define OB_PCROP_SECTOR_15       0x00004000U /*!< PC Read/Write protection of Sector15     */      
S#define OB_PCROP_SECTOR_All      0x00007FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F413xx || STM32F423xx */
N/*-----------------------------------------------------------------------------------------------------*/      
N
N/*--------------------------------------------- STM32F401xC -------------------------------------------*/
N#if defined(STM32F401xC)
X#if 0L
S#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
S#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
S#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
S#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
S#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
S#define OB_PCROP_SECTOR_5        0x00000020U /*!< PC Read/Write protection of Sector5      */
S#define OB_PCROP_SECTOR_All      0x00000FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F401xC */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------------- STM32F410xx -------------------------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
S#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
S#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
S#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
S#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
S#define OB_PCROP_SECTOR_All      0x00000FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*-------------- STM32F401xE/STM32F411xE/STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/STM32F446xx --*/
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L  
S#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
S#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
S#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
S#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
S#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
S#define OB_PCROP_SECTOR_5        0x00000020U /*!< PC Read/Write protection of Sector5      */
S#define OB_PCROP_SECTOR_6        0x00000040U /*!< PC Read/Write protection of Sector6      */
S#define OB_PCROP_SECTOR_7        0x00000080U /*!< PC Read/Write protection of Sector7      */
S#define OB_PCROP_SECTOR_All      0x00000FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Dual_Boot FLASH Dual Boot
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L|| 0L ||    0L || 0L 
S#define OB_DUAL_BOOT_ENABLE   ((uint8_t)0x10) /*!< Dual Bank Boot Enable                             */
S#define OB_DUAL_BOOT_DISABLE  ((uint8_t)0x00) /*!< Dual Bank Boot Disable, always boot on User Flash */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N/** @defgroup  FLASHEx_Selection_Protection_Mode FLASH Selection Protection Mode
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
S#define OB_PCROP_DESELECTED     ((uint8_t)0x00) /*!< Disabled PcROP, nWPRi bits used for Write Protection on sector i */
S#define OB_PCROP_SELECTED       ((uint8_t)0x80) /*!< Enable PcROP, nWPRi bits used for PCRoP Protection on sector i   */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup FLASHEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup FLASHEx_Exported_Functions_Group1
N  * @{
N  */
N/* Extension Program operation functions  *************************************/
NHAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError);
NHAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit);
NHAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
Nvoid              HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
SHAL_StatusTypeDef HAL_FLASHEx_AdvOBProgram (FLASH_AdvOBProgramInitTypeDef *pAdvOBInit);
Svoid              HAL_FLASHEx_AdvOBGetConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit);
SHAL_StatusTypeDef HAL_FLASHEx_OB_SelectPCROP(void);
SHAL_StatusTypeDef HAL_FLASHEx_OB_DeSelectPCROP(void);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
Suint16_t          HAL_FLASHEx_OB_GetBank2WRP(void);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup FLASHEx_Private_Constants FLASH Private Constants
N  * @{
N  */
N/*--------------------------------- STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx---------------------*/ 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L || 0L || 0L
S#define FLASH_SECTOR_TOTAL  24U
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N/*-------------------------------------- STM32F413xx/STM32F423xx ---------------------------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define FLASH_SECTOR_TOTAL  16U
N#endif /* STM32F413xx || STM32F423xx */
N
N/*--------------------------------------- STM32F40xxx/STM32F41xxx -------------------------------------*/ 
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 1L || 0L || 0L ||    0L || 0L || 0L  
N#define FLASH_SECTOR_TOTAL  12U
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N/*--------------------------------------------- STM32F401xC -------------------------------------------*/ 
N#if defined(STM32F401xC)
X#if 0L
S#define FLASH_SECTOR_TOTAL  6U
N#endif /* STM32F401xC */
N
N/*--------------------------------------------- STM32F410xx -------------------------------------------*/ 
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define FLASH_SECTOR_TOTAL  5U
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/*--------------------------------- STM32F401xE/STM32F411xE/STM32F412xG/STM32F446xx -------------------*/
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx)
X#if 0L || 0L || 0L
S#define FLASH_SECTOR_TOTAL  8U
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx */
N
N/** 
N  * @brief OPTCR1 register byte 2 (Bits[23:16]) base address  
N  */ 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)  
X#if 0L || 0L || 0L|| 0L || 0L || 0L  
S#define OPTCR1_BYTE2_ADDRESS         0x40023C1AU
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup FLASHEx_Private_Macros FLASH Private Macros
N  * @{
N  */
N
N/** @defgroup FLASHEx_IS_FLASH_Definitions FLASH Private macros to check input parameters
N  * @{
N  */
N
N#define IS_FLASH_TYPEERASE(VALUE)(((VALUE) == FLASH_TYPEERASE_SECTORS) || \
N                                  ((VALUE) == FLASH_TYPEERASE_MASSERASE))  
X#define IS_FLASH_TYPEERASE(VALUE)(((VALUE) == FLASH_TYPEERASE_SECTORS) ||                                   ((VALUE) == FLASH_TYPEERASE_MASSERASE))  
N
N#define IS_VOLTAGERANGE(RANGE)(((RANGE) == FLASH_VOLTAGE_RANGE_1) || \
N                               ((RANGE) == FLASH_VOLTAGE_RANGE_2) || \
N                               ((RANGE) == FLASH_VOLTAGE_RANGE_3) || \
N                               ((RANGE) == FLASH_VOLTAGE_RANGE_4))  
X#define IS_VOLTAGERANGE(RANGE)(((RANGE) == FLASH_VOLTAGE_RANGE_1) ||                                ((RANGE) == FLASH_VOLTAGE_RANGE_2) ||                                ((RANGE) == FLASH_VOLTAGE_RANGE_3) ||                                ((RANGE) == FLASH_VOLTAGE_RANGE_4))  
N
N#define IS_WRPSTATE(VALUE)(((VALUE) == OB_WRPSTATE_DISABLE) || \
N                           ((VALUE) == OB_WRPSTATE_ENABLE))  
X#define IS_WRPSTATE(VALUE)(((VALUE) == OB_WRPSTATE_DISABLE) ||                            ((VALUE) == OB_WRPSTATE_ENABLE))  
N
N#define IS_OPTIONBYTE(VALUE)(((VALUE) <= (OPTIONBYTE_WRP|OPTIONBYTE_RDP|OPTIONBYTE_USER|OPTIONBYTE_BOR)))
N
N#define IS_OB_RDP_LEVEL(LEVEL) (((LEVEL) == OB_RDP_LEVEL_0) ||\
N                                ((LEVEL) == OB_RDP_LEVEL_1) ||\
N                                ((LEVEL) == OB_RDP_LEVEL_2))
X#define IS_OB_RDP_LEVEL(LEVEL) (((LEVEL) == OB_RDP_LEVEL_0) ||                                ((LEVEL) == OB_RDP_LEVEL_1) ||                                ((LEVEL) == OB_RDP_LEVEL_2))
N
N#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N
N#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NO_RST) || ((SOURCE) == OB_STOP_RST))
N
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NO_RST) || ((SOURCE) == OB_STDBY_RST))
N
N#define IS_OB_BOR_LEVEL(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||\
N                                ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
X#define IS_OB_BOR_LEVEL(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||                                ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
S#define IS_PCROPSTATE(VALUE)(((VALUE) == OB_PCROP_STATE_DISABLE) || \
S                             ((VALUE) == OB_PCROP_STATE_ENABLE))  
X#define IS_PCROPSTATE(VALUE)(((VALUE) == OB_PCROP_STATE_DISABLE) ||                              ((VALUE) == OB_PCROP_STATE_ENABLE))  
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define IS_OBEX(VALUE)(((VALUE) == OPTIONBYTE_PCROP) || \
S                       ((VALUE) == OPTIONBYTE_BOOTCONFIG))  
X#define IS_OBEX(VALUE)(((VALUE) == OPTIONBYTE_PCROP) ||                        ((VALUE) == OPTIONBYTE_BOOTCONFIG))  
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
S#define IS_OBEX(VALUE)(((VALUE) == OPTIONBYTE_PCROP))  
N#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L || 0L
S#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  || \
S                                   ((LATENCY) == FLASH_LATENCY_1)  || \
S                                   ((LATENCY) == FLASH_LATENCY_2)  || \
S                                   ((LATENCY) == FLASH_LATENCY_3)  || \
S                                   ((LATENCY) == FLASH_LATENCY_4)  || \
S                                   ((LATENCY) == FLASH_LATENCY_5)  || \
S                                   ((LATENCY) == FLASH_LATENCY_6)  || \
S                                   ((LATENCY) == FLASH_LATENCY_7)  || \
S                                   ((LATENCY) == FLASH_LATENCY_8)  || \
S                                   ((LATENCY) == FLASH_LATENCY_9)  || \
S                                   ((LATENCY) == FLASH_LATENCY_10) || \
S                                   ((LATENCY) == FLASH_LATENCY_11) || \
S                                   ((LATENCY) == FLASH_LATENCY_12) || \
S                                   ((LATENCY) == FLASH_LATENCY_13) || \
S                                   ((LATENCY) == FLASH_LATENCY_14) || \
S                                   ((LATENCY) == FLASH_LATENCY_15))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  ||                                    ((LATENCY) == FLASH_LATENCY_1)  ||                                    ((LATENCY) == FLASH_LATENCY_2)  ||                                    ((LATENCY) == FLASH_LATENCY_3)  ||                                    ((LATENCY) == FLASH_LATENCY_4)  ||                                    ((LATENCY) == FLASH_LATENCY_5)  ||                                    ((LATENCY) == FLASH_LATENCY_6)  ||                                    ((LATENCY) == FLASH_LATENCY_7)  ||                                    ((LATENCY) == FLASH_LATENCY_8)  ||                                    ((LATENCY) == FLASH_LATENCY_9)  ||                                    ((LATENCY) == FLASH_LATENCY_10) ||                                    ((LATENCY) == FLASH_LATENCY_11) ||                                    ((LATENCY) == FLASH_LATENCY_12) ||                                    ((LATENCY) == FLASH_LATENCY_13) ||                                    ((LATENCY) == FLASH_LATENCY_14) ||                                    ((LATENCY) == FLASH_LATENCY_15))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 1L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  || \
N                                   ((LATENCY) == FLASH_LATENCY_1)  || \
N                                   ((LATENCY) == FLASH_LATENCY_2)  || \
N                                   ((LATENCY) == FLASH_LATENCY_3)  || \
N                                   ((LATENCY) == FLASH_LATENCY_4)  || \
N                                   ((LATENCY) == FLASH_LATENCY_5)  || \
N                                   ((LATENCY) == FLASH_LATENCY_6)  || \
N                                   ((LATENCY) == FLASH_LATENCY_7))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  ||                                    ((LATENCY) == FLASH_LATENCY_1)  ||                                    ((LATENCY) == FLASH_LATENCY_2)  ||                                    ((LATENCY) == FLASH_LATENCY_3)  ||                                    ((LATENCY) == FLASH_LATENCY_4)  ||                                    ((LATENCY) == FLASH_LATENCY_5)  ||                                    ((LATENCY) == FLASH_LATENCY_6)  ||                                    ((LATENCY) == FLASH_LATENCY_7))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F412Zx || STM32F412Vx ||\
N          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define IS_FLASH_BANK(BANK) (((BANK) == FLASH_BANK_1)  || \
S                             ((BANK) == FLASH_BANK_2)  || \
S                             ((BANK) == FLASH_BANK_BOTH))
X#define IS_FLASH_BANK(BANK) (((BANK) == FLASH_BANK_1)  ||                              ((BANK) == FLASH_BANK_2)  ||                              ((BANK) == FLASH_BANK_BOTH))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 1L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
N#define IS_FLASH_BANK(BANK) (((BANK) == FLASH_BANK_1))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx ||\
N          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define IS_FLASH_SECTOR(SECTOR) ( ((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_16)  || ((SECTOR) == FLASH_SECTOR_17)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_18)  || ((SECTOR) == FLASH_SECTOR_19)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_20)  || ((SECTOR) == FLASH_SECTOR_21)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_22)  || ((SECTOR) == FLASH_SECTOR_23))
X#define IS_FLASH_SECTOR(SECTOR) ( ((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                  ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                  ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                  ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||                                  ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||                                  ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||                                  ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||                                  ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15)  ||                                  ((SECTOR) == FLASH_SECTOR_16)  || ((SECTOR) == FLASH_SECTOR_17)  ||                                  ((SECTOR) == FLASH_SECTOR_18)  || ((SECTOR) == FLASH_SECTOR_19)  ||                                  ((SECTOR) == FLASH_SECTOR_20)  || ((SECTOR) == FLASH_SECTOR_21)  ||                                  ((SECTOR) == FLASH_SECTOR_22)  || ((SECTOR) == FLASH_SECTOR_23))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define IS_FLASH_SECTOR(SECTOR) ( ((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15))
X#define IS_FLASH_SECTOR(SECTOR) ( ((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                  ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                  ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                  ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||                                  ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||                                  ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||                                  ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||                                  ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15))
N#endif /* STM32F413xx || STM32F423xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 1L || 0L || 0L ||    0L || 0L || 0L  
N#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||                                 ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||                                 ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N#if defined(STM32F401xC)
X#if 0L
S#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5))
N#endif /* STM32F401xC */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_4))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx)
X#if 0L || 0L || 0L
S#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7))
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx */
N
N#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= FLASH_BASE) && ((ADDRESS) <= FLASH_END)) || \
N                                   (((ADDRESS) >= FLASH_OTP_BASE) && ((ADDRESS) <= FLASH_OTP_END)))
X#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= FLASH_BASE) && ((ADDRESS) <= FLASH_END)) ||                                    (((ADDRESS) >= FLASH_OTP_BASE) && ((ADDRESS) <= FLASH_OTP_END)))
N
N#define IS_FLASH_NBSECTORS(NBSECTORS) (((NBSECTORS) != 0) && ((NBSECTORS) <= FLASH_SECTOR_TOTAL))
N  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L || 0L || 0L 
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFF000000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F413xx) || defined(STM32F423xx) 
X#if 0L || 0L 
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFF8000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F413xx || STM32F423xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
X#if 0L || 0L || 1L || 0L
N#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N
N#if defined(STM32F401xC)
X#if 0L
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F401xC */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L  
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N   
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFF8000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))      
N#endif /* STM32F413xx || STM32F423xx */
N
N#if defined(STM32F401xC)
X#if 0L
S#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F401xC */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L  
S#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L ||    0L || 0L 
S#define IS_OB_BOOT(BOOT) (((BOOT) == OB_DUAL_BOOT_ENABLE) || ((BOOT) == OB_DUAL_BOOT_DISABLE))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
S#define IS_OB_PCROP_SELECT(PCROP) (((PCROP) == OB_PCROP_SELECTED) || ((PCROP) == OB_PCROP_DESELECTED))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup FLASHEx_Private_Functions FLASH Private Functions
N  * @{
N  */
Nvoid FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange);
Nvoid FLASH_FlushCaches(void);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_FLASH_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 298 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash.h" 2
N#include "stm32f4xx_hal_flash_ramfunc.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash_ramfunc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_flash_ramfunc.h
N  * @author  MCD Application Team
N  * @brief   Header file of FLASH RAMFUNC driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_FLASH_RAMFUNC_H
N#define __STM32F4xx_FLASH_RAMFUNC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L  
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32f4xx_hal_def.h"
S
S/** @addtogroup STM32F4xx_HAL_Driver
S  * @{
S  */
S
S/** @addtogroup FLASH_RAMFUNC
S  * @{
S  */
S
S/* Exported types ------------------------------------------------------------*/
S/* Exported macro ------------------------------------------------------------*/
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup FLASH_RAMFUNC_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup FLASH_RAMFUNC_Exported_Functions_Group1
S  * @{
S  */   
S__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StopFlashInterfaceClk(void);
S__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StartFlashInterfaceClk(void);
S__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_EnableFlashSleepMode(void);
S__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_DisableFlashSleepMode(void);
S/**
S  * @}
S  */ 
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */ 
S
S/**
S  * @}
S  */
S
N#endif /* STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */  
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F4xx_FLASH_RAMFUNC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 299 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup FLASH_Exported_Functions
N  * @{
N  */
N/** @addtogroup FLASH_Exported_Functions_Group1
N  * @{
N  */
N/* Program operation functions  ***********************************************/
NHAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
NHAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
N/* FLASH IRQ handler method */
Nvoid HAL_FLASH_IRQHandler(void);
N/* Callbacks in non blocking modes */ 
Nvoid HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue);
Nvoid HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue);
N/**
N  * @}
N  */
N
N/** @addtogroup FLASH_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions  **********************************************/
NHAL_StatusTypeDef HAL_FLASH_Unlock(void);
NHAL_StatusTypeDef HAL_FLASH_Lock(void);
NHAL_StatusTypeDef HAL_FLASH_OB_Unlock(void);
NHAL_StatusTypeDef HAL_FLASH_OB_Lock(void);
N/* Option bytes control */
NHAL_StatusTypeDef HAL_FLASH_OB_Launch(void);
N/**
N  * @}
N  */
N
N/** @addtogroup FLASH_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State functions  ************************************************/
Nuint32_t HAL_FLASH_GetError(void);
NHAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup FLASH_Private_Variables FLASH Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup FLASH_Private_Constants FLASH Private Constants
N  * @{
N  */
N
N/** 
N  * @brief   ACR register byte 0 (Bits[7:0]) base address  
N  */ 
N#define ACR_BYTE0_ADDRESS           0x40023C00U 
N/** 
N  * @brief   OPTCR register byte 0 (Bits[7:0]) base address  
N  */ 
N#define OPTCR_BYTE0_ADDRESS         0x40023C14U
N/** 
N  * @brief   OPTCR register byte 1 (Bits[15:8]) base address  
N  */ 
N#define OPTCR_BYTE1_ADDRESS         0x40023C15U
N/** 
N  * @brief   OPTCR register byte 2 (Bits[23:16]) base address  
N  */ 
N#define OPTCR_BYTE2_ADDRESS         0x40023C16U
N/** 
N  * @brief   OPTCR register byte 3 (Bits[31:24]) base address  
N  */ 
N#define OPTCR_BYTE3_ADDRESS         0x40023C17U
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup FLASH_Private_Macros FLASH Private Macros
N  * @{
N  */
N
N/** @defgroup FLASH_IS_FLASH_Definitions FLASH Private macros to check input parameters
N  * @{
N  */
N#define IS_FLASH_TYPEPROGRAM(VALUE)(((VALUE) == FLASH_TYPEPROGRAM_BYTE) || \
N                                    ((VALUE) == FLASH_TYPEPROGRAM_HALFWORD) || \
N                                    ((VALUE) == FLASH_TYPEPROGRAM_WORD) || \
N                                    ((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD))  
X#define IS_FLASH_TYPEPROGRAM(VALUE)(((VALUE) == FLASH_TYPEPROGRAM_BYTE) ||                                     ((VALUE) == FLASH_TYPEPROGRAM_HALFWORD) ||                                     ((VALUE) == FLASH_TYPEPROGRAM_WORD) ||                                     ((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD))  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup FLASH_Private_Functions FLASH Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_FLASH_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 332 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_FLASH_MODULE_ENABLED */
N
N#ifdef HAL_SRAM_MODULE_ENABLED
S  #include "stm32f4xx_hal_sram.h"
N#endif /* HAL_SRAM_MODULE_ENABLED */
N
N#ifdef HAL_NOR_MODULE_ENABLED
S  #include "stm32f4xx_hal_nor.h"
N#endif /* HAL_NOR_MODULE_ENABLED */
N
N#ifdef HAL_NAND_MODULE_ENABLED
S  #include "stm32f4xx_hal_nand.h"
N#endif /* HAL_NAND_MODULE_ENABLED */
N
N#ifdef HAL_PCCARD_MODULE_ENABLED
S  #include "stm32f4xx_hal_pccard.h"
N#endif /* HAL_PCCARD_MODULE_ENABLED */
N
N#ifdef HAL_SDRAM_MODULE_ENABLED
S  #include "stm32f4xx_hal_sdram.h"
N#endif /* HAL_SDRAM_MODULE_ENABLED */
N
N#ifdef HAL_HASH_MODULE_ENABLED
S #include "stm32f4xx_hal_hash.h"
N#endif /* HAL_HASH_MODULE_ENABLED */
N
N#ifdef HAL_I2C_MODULE_ENABLED
N #include "stm32f4xx_hal_i2c.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_i2c.h
N  * @author  MCD Application Team
N  * @brief   Header file of I2C HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_I2C_H
N#define __STM32F4xx_HAL_I2C_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup I2C
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup I2C_Exported_Types I2C Exported Types
N  * @{
N  */
N
N/** @defgroup I2C_Configuration_Structure_definition I2C Configuration Structure definition
N  * @brief  I2C Configuration Structure definition
N  * @{
N  */
Ntypedef struct
N{
N  uint32_t ClockSpeed;       /*!< Specifies the clock frequency.
N                                  This parameter must be set to a value lower than 400kHz */
N
N  uint32_t DutyCycle;        /*!< Specifies the I2C fast mode duty cycle.
N                                  This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */
N
N  uint32_t OwnAddress1;      /*!< Specifies the first device own address.
N                                  This parameter can be a 7-bit or 10-bit address. */
N
N  uint32_t AddressingMode;   /*!< Specifies if 7-bit or 10-bit addressing mode is selected.
N                                  This parameter can be a value of @ref I2C_addressing_mode */
N
N  uint32_t DualAddressMode;  /*!< Specifies if dual addressing mode is selected.
N                                  This parameter can be a value of @ref I2C_dual_addressing_mode */
N
N  uint32_t OwnAddress2;      /*!< Specifies the second device own address if dual addressing mode is selected
N                                  This parameter can be a 7-bit address. */
N
N  uint32_t GeneralCallMode;  /*!< Specifies if general call mode is selected.
N                                  This parameter can be a value of @ref I2C_general_call_addressing_mode */
N
N  uint32_t NoStretchMode;    /*!< Specifies if nostretch mode is selected.
N                                  This parameter can be a value of @ref I2C_nostretch_mode */
N
N} I2C_InitTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_state_structure_definition HAL state structure definition
N  * @brief  HAL State structure definition
N  * @note  HAL I2C State value coding follow below described bitmap :
N  *          b7-b6  Error information
N  *             00 : No Error
N  *             01 : Abort (Abort user request on going)
N  *             10 : Timeout
N  *             11 : Error
N  *          b5     Peripheral initialization status
N  *             0  : Reset (Peripheral not initialized)
N  *             1  : Init done (Peripheral initialized and ready to use. HAL I2C Init function called)
N  *          b4     (not used)
N  *             x  : Should be set to 0
N  *          b3
N  *             0  : Ready or Busy (No Listen mode ongoing)
N  *             1  : Listen (Peripheral in Address Listen Mode)
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (Peripheral busy with some configuration or internal operations)
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  * @{
N  */
Ntypedef enum
N{
N  HAL_I2C_STATE_RESET             = 0x00U,   /*!< Peripheral is not yet Initialized         */
N  HAL_I2C_STATE_READY             = 0x20U,   /*!< Peripheral Initialized and ready for use  */
N  HAL_I2C_STATE_BUSY              = 0x24U,   /*!< An internal process is ongoing            */
N  HAL_I2C_STATE_BUSY_TX           = 0x21U,   /*!< Data Transmission process is ongoing      */
N  HAL_I2C_STATE_BUSY_RX           = 0x22U,   /*!< Data Reception process is ongoing         */
N  HAL_I2C_STATE_LISTEN            = 0x28U,   /*!< Address Listen Mode is ongoing            */
N  HAL_I2C_STATE_BUSY_TX_LISTEN    = 0x29U,   /*!< Address Listen Mode and Data Transmission
N                                                 process is ongoing                         */
N  HAL_I2C_STATE_BUSY_RX_LISTEN    = 0x2AU,   /*!< Address Listen Mode and Data Reception
N                                                 process is ongoing                         */
N  HAL_I2C_STATE_ABORT             = 0x60U,   /*!< Abort user request ongoing                */
N  HAL_I2C_STATE_TIMEOUT           = 0xA0U,   /*!< Timeout state                             */
N  HAL_I2C_STATE_ERROR             = 0xE0U    /*!< Error                                     */
N
N} HAL_I2C_StateTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_mode_structure_definition HAL mode structure definition
N  * @brief  HAL Mode structure definition
N  * @note  HAL I2C Mode value coding follow below described bitmap :\n
N  *          b7     (not used)\n
N  *             x  : Should be set to 0\n
N  *          b6\n
N  *             0  : None\n
N  *             1  : Memory (HAL I2C communication is in Memory Mode)\n
N  *          b5\n
N  *             0  : None\n
N  *             1  : Slave (HAL I2C communication is in Slave Mode)\n
N  *          b4\n
N  *             0  : None\n
N  *             1  : Master (HAL I2C communication is in Master Mode)\n
N  *          b3-b2-b1-b0  (not used)\n
N  *             xxxx : Should be set to 0000
N  * @{
N  */
Ntypedef enum
N{
N  HAL_I2C_MODE_NONE               = 0x00U,   /*!< No I2C communication on going             */
N  HAL_I2C_MODE_MASTER             = 0x10U,   /*!< I2C communication is in Master Mode       */
N  HAL_I2C_MODE_SLAVE              = 0x20U,   /*!< I2C communication is in Slave Mode        */
N  HAL_I2C_MODE_MEM                = 0x40U    /*!< I2C communication is in Memory Mode       */
N
N} HAL_I2C_ModeTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Error_Code_definition I2C Error Code definition
N  * @brief  I2C Error Code definition
N  * @{
N  */
N#define HAL_I2C_ERROR_NONE              0x00000000U    /*!< No error              */
N#define HAL_I2C_ERROR_BERR              0x00000001U    /*!< BERR error            */
N#define HAL_I2C_ERROR_ARLO              0x00000002U    /*!< ARLO error            */
N#define HAL_I2C_ERROR_AF                0x00000004U    /*!< AF error              */
N#define HAL_I2C_ERROR_OVR               0x00000008U    /*!< OVR error             */
N#define HAL_I2C_ERROR_DMA               0x00000010U    /*!< DMA transfer error    */
N#define HAL_I2C_ERROR_TIMEOUT           0x00000020U    /*!< Timeout Error         */
N#define HAL_I2C_ERROR_SIZE              0x00000040U    /*!< Size Management error */
N#define HAL_I2C_ERROR_DMA_PARAM         0x00000080U    /*!< DMA Parameter Error   */
N#define HAL_I2C_WRONG_START             0x00000200U    /*!< Wrong start Error     */
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
X#if (0U == 1)
S#define HAL_I2C_ERROR_INVALID_CALLBACK  0x00000100U    /*!< Invalid Callback error */
N#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_handle_Structure_definition I2C handle Structure definition
N  * @brief  I2C handle Structure definition
N  * @{
N  */
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
X#if (0U == 1)
Stypedef struct __I2C_HandleTypeDef
N#else
Ntypedef struct
N#endif  /* USE_HAL_I2C_REGISTER_CALLBACKS */
N{
N  I2C_TypeDef                *Instance;      /*!< I2C registers base address               */
N
N  I2C_InitTypeDef            Init;           /*!< I2C communication parameters             */
N
N  uint8_t                    *pBuffPtr;      /*!< Pointer to I2C transfer buffer           */
N
N  uint16_t                   XferSize;       /*!< I2C transfer size                        */
N
N  __IO uint16_t              XferCount;      /*!< I2C transfer counter                     */
X  volatile uint16_t              XferCount;       
N
N  __IO uint32_t              XferOptions;    /*!< I2C transfer options                     */
X  volatile uint32_t              XferOptions;     
N
N  __IO uint32_t              PreviousState;  /*!< I2C communication Previous state and mode
X  volatile uint32_t              PreviousState;  
N                                                  context for internal usage               */
N
N  DMA_HandleTypeDef          *hdmatx;        /*!< I2C Tx DMA handle parameters             */
N
N  DMA_HandleTypeDef          *hdmarx;        /*!< I2C Rx DMA handle parameters             */
N
N  HAL_LockTypeDef            Lock;           /*!< I2C locking object                       */
N
N  __IO HAL_I2C_StateTypeDef  State;          /*!< I2C communication state                  */
X  volatile HAL_I2C_StateTypeDef  State;           
N
N  __IO HAL_I2C_ModeTypeDef   Mode;           /*!< I2C communication mode                   */
X  volatile HAL_I2C_ModeTypeDef   Mode;            
N
N  __IO uint32_t              ErrorCode;      /*!< I2C Error code                           */
X  volatile uint32_t              ErrorCode;       
N
N  __IO uint32_t              Devaddress;     /*!< I2C Target device address                */
X  volatile uint32_t              Devaddress;      
N
N  __IO uint32_t              Memaddress;     /*!< I2C Target memory address                */
X  volatile uint32_t              Memaddress;      
N
N  __IO uint32_t              MemaddSize;     /*!< I2C Target memory address  size          */
X  volatile uint32_t              MemaddSize;      
N
N  __IO uint32_t              EventCount;     /*!< I2C Event counter                        */
X  volatile uint32_t              EventCount;      
N
N
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
X#if (0U == 1)
S  void (* MasterTxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);           /*!< I2C Master Tx Transfer completed callback */
S  void (* MasterRxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);           /*!< I2C Master Rx Transfer completed callback */
S  void (* SlaveTxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);            /*!< I2C Slave Tx Transfer completed callback  */
S  void (* SlaveRxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);            /*!< I2C Slave Rx Transfer completed callback  */
S  void (* ListenCpltCallback)(struct __I2C_HandleTypeDef *hi2c);             /*!< I2C Listen Complete callback              */
S  void (* MemTxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);              /*!< I2C Memory Tx Transfer completed callback */
S  void (* MemRxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);              /*!< I2C Memory Rx Transfer completed callback */
S  void (* ErrorCallback)(struct __I2C_HandleTypeDef *hi2c);                  /*!< I2C Error callback                        */
S  void (* AbortCpltCallback)(struct __I2C_HandleTypeDef *hi2c);              /*!< I2C Abort callback                        */
S
S  void (* AddrCallback)(struct __I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode);  /*!< I2C Slave Address Match callback */
S
S  void (* MspInitCallback)(struct __I2C_HandleTypeDef *hi2c);                /*!< I2C Msp Init callback                     */
S  void (* MspDeInitCallback)(struct __I2C_HandleTypeDef *hi2c);              /*!< I2C Msp DeInit callback                   */
S
N#endif  /* USE_HAL_I2C_REGISTER_CALLBACKS */
N} I2C_HandleTypeDef;
N
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
X#if (0U == 1)
S/**
S  * @brief  HAL I2C Callback ID enumeration definition
S  */
Stypedef enum
S{
S  HAL_I2C_MASTER_TX_COMPLETE_CB_ID      = 0x00U,    /*!< I2C Master Tx Transfer completed callback ID  */
S  HAL_I2C_MASTER_RX_COMPLETE_CB_ID      = 0x01U,    /*!< I2C Master Rx Transfer completed callback ID  */
S  HAL_I2C_SLAVE_TX_COMPLETE_CB_ID       = 0x02U,    /*!< I2C Slave Tx Transfer completed callback ID   */
S  HAL_I2C_SLAVE_RX_COMPLETE_CB_ID       = 0x03U,    /*!< I2C Slave Rx Transfer completed callback ID   */
S  HAL_I2C_LISTEN_COMPLETE_CB_ID         = 0x04U,    /*!< I2C Listen Complete callback ID               */
S  HAL_I2C_MEM_TX_COMPLETE_CB_ID         = 0x05U,    /*!< I2C Memory Tx Transfer callback ID            */
S  HAL_I2C_MEM_RX_COMPLETE_CB_ID         = 0x06U,    /*!< I2C Memory Rx Transfer completed callback ID  */
S  HAL_I2C_ERROR_CB_ID                   = 0x07U,    /*!< I2C Error callback ID                         */
S  HAL_I2C_ABORT_CB_ID                   = 0x08U,    /*!< I2C Abort callback ID                         */
S
S  HAL_I2C_MSPINIT_CB_ID                 = 0x09U,    /*!< I2C Msp Init callback ID                      */
S  HAL_I2C_MSPDEINIT_CB_ID               = 0x0AU     /*!< I2C Msp DeInit callback ID                    */
S
S} HAL_I2C_CallbackIDTypeDef;
S
S/**
S  * @brief  HAL I2C Callback pointer definition
S  */
Stypedef  void (*pI2C_CallbackTypeDef)(I2C_HandleTypeDef *hi2c); /*!< pointer to an I2C callback function */
Stypedef  void (*pI2C_AddrCallbackTypeDef)(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode); /*!< pointer to an I2C Address Match callback function */
S
N#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup I2C_Exported_Constants I2C Exported Constants
N  * @{
N  */
N
N/** @defgroup I2C_duty_cycle_in_fast_mode I2C duty cycle in fast mode
N  * @{
N  */
N#define I2C_DUTYCYCLE_2                 0x00000000U
N#define I2C_DUTYCYCLE_16_9              I2C_CCR_DUTY
N/**
N  * @}
N  */
N
N/** @defgroup I2C_addressing_mode I2C addressing mode
N  * @{
N  */
N#define I2C_ADDRESSINGMODE_7BIT         0x00004000U
N#define I2C_ADDRESSINGMODE_10BIT        (I2C_OAR1_ADDMODE | 0x00004000U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_dual_addressing_mode  I2C dual addressing mode
N  * @{
N  */
N#define I2C_DUALADDRESS_DISABLE        0x00000000U
N#define I2C_DUALADDRESS_ENABLE         I2C_OAR2_ENDUAL
N/**
N  * @}
N  */
N
N/** @defgroup I2C_general_call_addressing_mode I2C general call addressing mode
N  * @{
N  */
N#define I2C_GENERALCALL_DISABLE        0x00000000U
N#define I2C_GENERALCALL_ENABLE         I2C_CR1_ENGC
N/**
N  * @}
N  */
N
N/** @defgroup I2C_nostretch_mode I2C nostretch mode
N  * @{
N  */
N#define I2C_NOSTRETCH_DISABLE          0x00000000U
N#define I2C_NOSTRETCH_ENABLE           I2C_CR1_NOSTRETCH
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Memory_Address_Size I2C Memory Address Size
N  * @{
N  */
N#define I2C_MEMADD_SIZE_8BIT            0x00000001U
N#define I2C_MEMADD_SIZE_16BIT           0x00000010U
N/**
N  * @}
N  */
N
N/** @defgroup I2C_XferDirection_definition I2C XferDirection definition
N  * @{
N  */
N#define I2C_DIRECTION_RECEIVE           0x00000000U
N#define I2C_DIRECTION_TRANSMIT          0x00000001U
N/**
N  * @}
N  */
N
N/** @defgroup I2C_XferOptions_definition I2C XferOptions definition
N  * @{
N  */
N#define  I2C_FIRST_FRAME                0x00000001U
N#define  I2C_FIRST_AND_NEXT_FRAME       0x00000002U
N#define  I2C_NEXT_FRAME                 0x00000004U
N#define  I2C_FIRST_AND_LAST_FRAME       0x00000008U
N#define  I2C_LAST_FRAME_NO_STOP         0x00000010U
N#define  I2C_LAST_FRAME                 0x00000020U
N
N/* List of XferOptions in usage of :
N * 1- Restart condition in all use cases (direction change or not)
N */
N#define  I2C_OTHER_FRAME                (0x00AA0000U)
N#define  I2C_OTHER_AND_LAST_FRAME       (0xAA000000U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Interrupt_configuration_definition I2C Interrupt configuration definition
N  * @brief I2C Interrupt definition
N  *        Elements values convention: 0xXXXXXXXX
N  *           - XXXXXXXX  : Interrupt control mask
N  * @{
N  */
N#define I2C_IT_BUF                      I2C_CR2_ITBUFEN
N#define I2C_IT_EVT                      I2C_CR2_ITEVTEN
N#define I2C_IT_ERR                      I2C_CR2_ITERREN
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Flag_definition I2C Flag definition
N  * @{
N  */
N
N#define I2C_FLAG_OVR                    0x00010800U
N#define I2C_FLAG_AF                     0x00010400U
N#define I2C_FLAG_ARLO                   0x00010200U
N#define I2C_FLAG_BERR                   0x00010100U
N#define I2C_FLAG_TXE                    0x00010080U
N#define I2C_FLAG_RXNE                   0x00010040U
N#define I2C_FLAG_STOPF                  0x00010010U
N#define I2C_FLAG_ADD10                  0x00010008U
N#define I2C_FLAG_BTF                    0x00010004U
N#define I2C_FLAG_ADDR                   0x00010002U
N#define I2C_FLAG_SB                     0x00010001U
N#define I2C_FLAG_DUALF                  0x00100080U
N#define I2C_FLAG_GENCALL                0x00100010U
N#define I2C_FLAG_TRA                    0x00100004U
N#define I2C_FLAG_BUSY                   0x00100002U
N#define I2C_FLAG_MSL                    0x00100001U
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N
N/** @defgroup I2C_Exported_Macros I2C Exported Macros
N  * @{
N  */
N
N/** @brief Reset I2C handle state.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
X#if (0U == 1)
S#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                do{                                                   \
S                                                                    (__HANDLE__)->State = HAL_I2C_STATE_RESET;       \
S                                                                    (__HANDLE__)->MspInitCallback = NULL;            \
S                                                                    (__HANDLE__)->MspDeInitCallback = NULL;          \
S                                                                  } while(0)
X#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                do{                                                                                                                       (__HANDLE__)->State = HAL_I2C_STATE_RESET;                                                                           (__HANDLE__)->MspInitCallback = NULL;                                                                                (__HANDLE__)->MspDeInitCallback = NULL;                                                                            } while(0)
N#else
N#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                ((__HANDLE__)->State = HAL_I2C_STATE_RESET)
N#endif
N
N/** @brief  Enable or disable the specified I2C interrupts.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the interrupt source to enable or disable.
N  *         This parameter can be one of the following values:
N  *            @arg I2C_IT_BUF: Buffer interrupt enable
N  *            @arg I2C_IT_EVT: Event interrupt enable
N  *            @arg I2C_IT_ERR: Error interrupt enable
N  * @retval None
N  */
N#define __HAL_I2C_ENABLE_IT(__HANDLE__, __INTERRUPT__)   SET_BIT((__HANDLE__)->Instance->CR2,(__INTERRUPT__))
N#define __HAL_I2C_DISABLE_IT(__HANDLE__, __INTERRUPT__)  CLEAR_BIT((__HANDLE__)->Instance->CR2, (__INTERRUPT__))
N
N/** @brief  Checks if the specified I2C interrupt source is enabled or disabled.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the I2C interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg I2C_IT_BUF: Buffer interrupt enable
N  *            @arg I2C_IT_EVT: Event interrupt enable
N  *            @arg I2C_IT_ERR: Error interrupt enable
N  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
N  */
N#define __HAL_I2C_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Checks whether the specified I2C flag is set or not.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg I2C_FLAG_OVR: Overrun/Underrun flag
N  *            @arg I2C_FLAG_AF: Acknowledge failure flag
N  *            @arg I2C_FLAG_ARLO: Arbitration lost flag
N  *            @arg I2C_FLAG_BERR: Bus error flag
N  *            @arg I2C_FLAG_TXE: Data register empty flag
N  *            @arg I2C_FLAG_RXNE: Data register not empty flag
N  *            @arg I2C_FLAG_STOPF: Stop detection flag
N  *            @arg I2C_FLAG_ADD10: 10-bit header sent flag
N  *            @arg I2C_FLAG_BTF: Byte transfer finished flag
N  *            @arg I2C_FLAG_ADDR: Address sent flag
N  *                                Address matched flag
N  *            @arg I2C_FLAG_SB: Start bit flag
N  *            @arg I2C_FLAG_DUALF: Dual flag
N  *            @arg I2C_FLAG_GENCALL: General call header flag
N  *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
N  *            @arg I2C_FLAG_BUSY: Bus busy flag
N  *            @arg I2C_FLAG_MSL: Master/Slave flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_I2C_GET_FLAG(__HANDLE__, __FLAG__) ((((uint8_t)((__FLAG__) >> 16U)) == 0x01U) ? \
N                                                  (((((__HANDLE__)->Instance->SR1) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET) : \
N                                                  (((((__HANDLE__)->Instance->SR2) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET))
X#define __HAL_I2C_GET_FLAG(__HANDLE__, __FLAG__) ((((uint8_t)((__FLAG__) >> 16U)) == 0x01U) ?                                                   (((((__HANDLE__)->Instance->SR1) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET) :                                                   (((((__HANDLE__)->Instance->SR2) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET))
N
N/** @brief  Clears the I2C pending flags which are cleared by writing 0 in a specific bit.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __FLAG__ specifies the flag to clear.
N  *         This parameter can be any combination of the following values:
N  *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
N  *            @arg I2C_FLAG_AF: Acknowledge failure flag
N  *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
N  *            @arg I2C_FLAG_BERR: Bus error flag
N  * @retval None
N  */
N#define __HAL_I2C_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->SR1 = ~((__FLAG__) & I2C_FLAG_MASK))
N
N/** @brief  Clears the I2C ADDR pending flag.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  *         This parameter can be I2C where x: 1, 2, or 3 to select the I2C peripheral.
N  * @retval None
N  */
N#define __HAL_I2C_CLEAR_ADDRFLAG(__HANDLE__)    \
N  do{                                           \
N    __IO uint32_t tmpreg = 0x00U;               \
N    tmpreg = (__HANDLE__)->Instance->SR1;       \
N    tmpreg = (__HANDLE__)->Instance->SR2;       \
N    UNUSED(tmpreg);                             \
N  } while(0)
X#define __HAL_I2C_CLEAR_ADDRFLAG(__HANDLE__)      do{                                               __IO uint32_t tmpreg = 0x00U;                   tmpreg = (__HANDLE__)->Instance->SR1;           tmpreg = (__HANDLE__)->Instance->SR2;           UNUSED(tmpreg);                               } while(0)
N
N/** @brief  Clears the I2C STOPF pending flag.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_CLEAR_STOPFLAG(__HANDLE__)           \
N  do{                                                  \
N    __IO uint32_t tmpreg = 0x00U;                      \
N    tmpreg = (__HANDLE__)->Instance->SR1;              \
N    SET_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE);  \
N    UNUSED(tmpreg);                                    \
N  } while(0)
X#define __HAL_I2C_CLEAR_STOPFLAG(__HANDLE__)             do{                                                      __IO uint32_t tmpreg = 0x00U;                          tmpreg = (__HANDLE__)->Instance->SR1;                  SET_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE);      UNUSED(tmpreg);                                      } while(0)
N
N/** @brief  Enable the specified I2C peripheral.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_ENABLE(__HANDLE__)                  SET_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE)
N
N/** @brief  Disable the specified I2C peripheral.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_DISABLE(__HANDLE__)                 CLEAR_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE)
N
N/**
N  * @}
N  */
N
N/* Include I2C HAL Extension module */
N#include "stm32f4xx_hal_i2c_ex.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_i2c_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_i2c_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of I2C HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_I2C_EX_H
N#define __STM32F4xx_HAL_I2C_EX_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if  defined(I2C_FLTR_ANOFF)&&defined(I2C_FLTR_DNF)
X#if  0L&&0L
S/* Includes ------------------------------------------------------------------*/
S#include "stm32f4xx_hal_def.h"
S
S/** @addtogroup STM32F4xx_HAL_Driver
S  * @{
S  */
S
S/** @addtogroup I2CEx
S  * @{
S  */
S
S/* Exported types ------------------------------------------------------------*/
S/* Exported constants --------------------------------------------------------*/
S/** @defgroup I2CEx_Exported_Constants I2C Exported Constants
S  * @{
S  */
S
S/** @defgroup I2CEx_Analog_Filter I2C Analog Filter
S  * @{
S  */
S#define I2C_ANALOGFILTER_ENABLE        0x00000000U
S#define I2C_ANALOGFILTER_DISABLE       I2C_FLTR_ANOFF
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S/* Exported macro ------------------------------------------------------------*/
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup I2CEx_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup I2CEx_Exported_Functions_Group1
S  * @{
S  */
S/* Peripheral Control functions  ************************************************/
SHAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter);
SHAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter);
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S/* Private types -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/* Private constants ---------------------------------------------------------*/
S/** @defgroup I2CEx_Private_Constants I2C Private Constants
S  * @{
S  */
S
S/**
S  * @}
S  */
S
S/* Private macros ------------------------------------------------------------*/
S/** @defgroup I2CEx_Private_Macros I2C Private Macros
S  * @{
S  */
S#define IS_I2C_ANALOG_FILTER(FILTER) (((FILTER) == I2C_ANALOGFILTER_ENABLE) || \
S                                      ((FILTER) == I2C_ANALOGFILTER_DISABLE))
X#define IS_I2C_ANALOG_FILTER(FILTER) (((FILTER) == I2C_ANALOGFILTER_ENABLE) ||                                       ((FILTER) == I2C_ANALOGFILTER_DISABLE))
S#define IS_I2C_DIGITAL_FILTER(FILTER)   ((FILTER) <= 0x0000000FU)
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_I2C_EX_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 535 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_i2c.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup I2C_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N/* Initialization and de-initialization functions******************************/
NHAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c);
N
N/* Callbacks Register/UnRegister functions  ***********************************/
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
X#if (0U == 1)
SHAL_StatusTypeDef HAL_I2C_RegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID, pI2C_CallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_I2C_UnRegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID);
S
SHAL_StatusTypeDef HAL_I2C_RegisterAddrCallback(I2C_HandleTypeDef *hi2c, pI2C_AddrCallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_I2C_UnRegisterAddrCallback(I2C_HandleTypeDef *hi2c);
N#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group2 Input and Output operation functions
N  * @{
N  */
N/* IO operation functions  ****************************************************/
N/******* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout);
N
N/******* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
N
NHAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress);
N
N/******* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
N
NHAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
N * @{
N */
N/******* I2C IRQHandler and Callbacks used in non blocking modes (Interrupt and DMA) */
Nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode);
Nvoid HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c);
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
N  * @{
N  */
N/* Peripheral State, Mode and Error functions  *********************************/
NHAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c);
NHAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c);
Nuint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Constants I2C Private Constants
N  * @{
N  */
N#define I2C_FLAG_MASK                    0x0000FFFFU
N#define I2C_MIN_PCLK_FREQ_STANDARD       2000000U     /*!< 2 MHz                     */
N#define I2C_MIN_PCLK_FREQ_FAST           4000000U     /*!< 4 MHz                     */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup I2C_Private_Macros I2C Private Macros
N  * @{
N  */
N
N#define I2C_MIN_PCLK_FREQ(__PCLK__, __SPEED__)             (((__SPEED__) <= 100000U) ? ((__PCLK__) < I2C_MIN_PCLK_FREQ_STANDARD) : ((__PCLK__) < I2C_MIN_PCLK_FREQ_FAST))
N#define I2C_CCR_CALCULATION(__PCLK__, __SPEED__, __COEFF__)     (((((__PCLK__) - 1U)/((__SPEED__) * (__COEFF__))) + 1U) & I2C_CCR_CCR)
N#define I2C_FREQRANGE(__PCLK__)                            ((__PCLK__)/1000000U)
N#define I2C_RISE_TIME(__FREQRANGE__, __SPEED__)            (((__SPEED__) <= 100000U) ? ((__FREQRANGE__) + 1U) : ((((__FREQRANGE__) * 300U) / 1000U) + 1U))
N#define I2C_SPEED_STANDARD(__PCLK__, __SPEED__)            ((I2C_CCR_CALCULATION((__PCLK__), (__SPEED__), 2U) < 4U)? 4U:I2C_CCR_CALCULATION((__PCLK__), (__SPEED__), 2U))
N#define I2C_SPEED_FAST(__PCLK__, __SPEED__, __DUTYCYCLE__) (((__DUTYCYCLE__) == I2C_DUTYCYCLE_2)? I2C_CCR_CALCULATION((__PCLK__), (__SPEED__), 3U) : (I2C_CCR_CALCULATION((__PCLK__), (__SPEED__), 25U) | I2C_DUTYCYCLE_16_9))
N#define I2C_SPEED(__PCLK__, __SPEED__, __DUTYCYCLE__)      (((__SPEED__) <= 100000U)? (I2C_SPEED_STANDARD((__PCLK__), (__SPEED__))) : \
N                                                                  ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__)) & I2C_CCR_CCR) == 0U)? 1U : \
N                                                                  ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__))) | I2C_CCR_FS))
X#define I2C_SPEED(__PCLK__, __SPEED__, __DUTYCYCLE__)      (((__SPEED__) <= 100000U)? (I2C_SPEED_STANDARD((__PCLK__), (__SPEED__))) :                                                                   ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__)) & I2C_CCR_CCR) == 0U)? 1U :                                                                   ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__))) | I2C_CCR_FS))
N
N#define I2C_7BIT_ADD_WRITE(__ADDRESS__)                    ((uint8_t)((__ADDRESS__) & (uint8_t)(~I2C_OAR1_ADD0)))
N#define I2C_7BIT_ADD_READ(__ADDRESS__)                     ((uint8_t)((__ADDRESS__) | I2C_OAR1_ADD0))
N
N#define I2C_10BIT_ADDRESS(__ADDRESS__)                     ((uint8_t)((uint16_t)((__ADDRESS__) & (uint16_t)0x00FF)))
N#define I2C_10BIT_HEADER_WRITE(__ADDRESS__)                ((uint8_t)((uint16_t)((uint16_t)(((uint16_t)((__ADDRESS__) & (uint16_t)0x0300)) >> 7) | (uint16_t)0x00F0)))
N#define I2C_10BIT_HEADER_READ(__ADDRESS__)                 ((uint8_t)((uint16_t)((uint16_t)(((uint16_t)((__ADDRESS__) & (uint16_t)0x0300)) >> 7) | (uint16_t)(0x00F1))))
N
N#define I2C_MEM_ADD_MSB(__ADDRESS__)                       ((uint8_t)((uint16_t)(((uint16_t)((__ADDRESS__) & (uint16_t)0xFF00)) >> 8)))
N#define I2C_MEM_ADD_LSB(__ADDRESS__)                       ((uint8_t)((uint16_t)((__ADDRESS__) & (uint16_t)0x00FF)))
N
N/** @defgroup I2C_IS_RTC_Definitions I2C Private macros to check input parameters
N  * @{
N  */
N#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DUTYCYCLE_2) || \
N                                  ((CYCLE) == I2C_DUTYCYCLE_16_9))
X#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DUTYCYCLE_2) ||                                   ((CYCLE) == I2C_DUTYCYCLE_16_9))
N#define IS_I2C_ADDRESSING_MODE(ADDRESS) (((ADDRESS) == I2C_ADDRESSINGMODE_7BIT) || \
N                                         ((ADDRESS) == I2C_ADDRESSINGMODE_10BIT))
X#define IS_I2C_ADDRESSING_MODE(ADDRESS) (((ADDRESS) == I2C_ADDRESSINGMODE_7BIT) ||                                          ((ADDRESS) == I2C_ADDRESSINGMODE_10BIT))
N#define IS_I2C_DUAL_ADDRESS(ADDRESS) (((ADDRESS) == I2C_DUALADDRESS_DISABLE) || \
N                                      ((ADDRESS) == I2C_DUALADDRESS_ENABLE))
X#define IS_I2C_DUAL_ADDRESS(ADDRESS) (((ADDRESS) == I2C_DUALADDRESS_DISABLE) ||                                       ((ADDRESS) == I2C_DUALADDRESS_ENABLE))
N#define IS_I2C_GENERAL_CALL(CALL) (((CALL) == I2C_GENERALCALL_DISABLE) || \
N                                   ((CALL) == I2C_GENERALCALL_ENABLE))
X#define IS_I2C_GENERAL_CALL(CALL) (((CALL) == I2C_GENERALCALL_DISABLE) ||                                    ((CALL) == I2C_GENERALCALL_ENABLE))
N#define IS_I2C_NO_STRETCH(STRETCH) (((STRETCH) == I2C_NOSTRETCH_DISABLE) || \
N                                    ((STRETCH) == I2C_NOSTRETCH_ENABLE))
X#define IS_I2C_NO_STRETCH(STRETCH) (((STRETCH) == I2C_NOSTRETCH_DISABLE) ||                                     ((STRETCH) == I2C_NOSTRETCH_ENABLE))
N#define IS_I2C_MEMADD_SIZE(SIZE) (((SIZE) == I2C_MEMADD_SIZE_8BIT) || \
N                                  ((SIZE) == I2C_MEMADD_SIZE_16BIT))
X#define IS_I2C_MEMADD_SIZE(SIZE) (((SIZE) == I2C_MEMADD_SIZE_8BIT) ||                                   ((SIZE) == I2C_MEMADD_SIZE_16BIT))
N#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) > 0U) && ((SPEED) <= 400000U))
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1) (((ADDRESS1) & 0xFFFFFC00U) == 0U)
N#define IS_I2C_OWN_ADDRESS2(ADDRESS2) (((ADDRESS2) & 0xFFFFFF01U) == 0U)
N#define IS_I2C_TRANSFER_OPTIONS_REQUEST(REQUEST)      (((REQUEST) == I2C_FIRST_FRAME)              || \
N                                                       ((REQUEST) == I2C_FIRST_AND_NEXT_FRAME)     || \
N                                                       ((REQUEST) == I2C_NEXT_FRAME)               || \
N                                                       ((REQUEST) == I2C_FIRST_AND_LAST_FRAME)     || \
N                                                       ((REQUEST) == I2C_LAST_FRAME)               || \
N                                                       ((REQUEST) == I2C_LAST_FRAME_NO_STOP)       || \
N                                                       IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST))
X#define IS_I2C_TRANSFER_OPTIONS_REQUEST(REQUEST)      (((REQUEST) == I2C_FIRST_FRAME)              ||                                                        ((REQUEST) == I2C_FIRST_AND_NEXT_FRAME)     ||                                                        ((REQUEST) == I2C_NEXT_FRAME)               ||                                                        ((REQUEST) == I2C_FIRST_AND_LAST_FRAME)     ||                                                        ((REQUEST) == I2C_LAST_FRAME)               ||                                                        ((REQUEST) == I2C_LAST_FRAME_NO_STOP)       ||                                                        IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST))
N
N#define IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST) (((REQUEST) == I2C_OTHER_FRAME)     || \
N                                                        ((REQUEST) == I2C_OTHER_AND_LAST_FRAME))
X#define IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST) (((REQUEST) == I2C_OTHER_FRAME)     ||                                                         ((REQUEST) == I2C_OTHER_AND_LAST_FRAME))
N
N#define I2C_CHECK_FLAG(__ISR__, __FLAG__)         ((((__ISR__) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET)
N#define I2C_CHECK_IT_SOURCE(__CR1__, __IT__)      ((((__CR1__) & (__IT__)) == (__IT__)) ? SET : RESET)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Functions I2C Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F4xx_HAL_I2C_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 360 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_I2C_MODULE_ENABLED */
N
N#ifdef HAL_SMBUS_MODULE_ENABLED
S #include "stm32f4xx_hal_smbus.h"
N#endif /* HAL_SMBUS_MODULE_ENABLED */
N
N#ifdef HAL_I2S_MODULE_ENABLED
S #include "stm32f4xx_hal_i2s.h"
N#endif /* HAL_I2S_MODULE_ENABLED */
N
N#ifdef HAL_IWDG_MODULE_ENABLED
S #include "stm32f4xx_hal_iwdg.h"
N#endif /* HAL_IWDG_MODULE_ENABLED */
N
N#ifdef HAL_LTDC_MODULE_ENABLED
S #include "stm32f4xx_hal_ltdc.h"
N#endif /* HAL_LTDC_MODULE_ENABLED */
N
N#ifdef HAL_PWR_MODULE_ENABLED
N #include "stm32f4xx_hal_pwr.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_pwr.h
N  * @author  MCD Application Team
N  * @brief   Header file of PWR HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_PWR_H
N#define __STM32F4xx_HAL_PWR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PWR
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup PWR_Exported_Types PWR Exported Types
N  * @{
N  */
N   
N/**
N  * @brief  PWR PVD configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t PVDLevel;   /*!< PVDLevel: Specifies the PVD detection level.
N                            This parameter can be a value of @ref PWR_PVD_detection_level */
N
N  uint32_t Mode;      /*!< Mode: Specifies the operating mode for the selected pins.
N                           This parameter can be a value of @ref PWR_PVD_Mode */
N}PWR_PVDTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup PWR_Exported_Constants PWR Exported Constants
N  * @{
N  */
N  
N/** @defgroup PWR_WakeUp_Pins PWR WakeUp Pins
N  * @{
N  */
N#define PWR_WAKEUP_PIN1                 0x00000100U
N/**
N  * @}
N  */
N
N/** @defgroup PWR_PVD_detection_level PWR PVD detection level
N  * @{
N  */ 
N#define PWR_PVDLEVEL_0                  PWR_CR_PLS_LEV0
N#define PWR_PVDLEVEL_1                  PWR_CR_PLS_LEV1
N#define PWR_PVDLEVEL_2                  PWR_CR_PLS_LEV2
N#define PWR_PVDLEVEL_3                  PWR_CR_PLS_LEV3
N#define PWR_PVDLEVEL_4                  PWR_CR_PLS_LEV4
N#define PWR_PVDLEVEL_5                  PWR_CR_PLS_LEV5
N#define PWR_PVDLEVEL_6                  PWR_CR_PLS_LEV6
N#define PWR_PVDLEVEL_7                  PWR_CR_PLS_LEV7/* External input analog voltage 
N                                                          (Compare internally to VREFINT) */
N/**
N  * @}
N  */   
N 
N/** @defgroup PWR_PVD_Mode PWR PVD Mode
N  * @{
N  */
N#define PWR_PVD_MODE_NORMAL                 0x00000000U   /*!< basic mode is used */
N#define PWR_PVD_MODE_IT_RISING              0x00010001U   /*!< External Interrupt Mode with Rising edge trigger detection */
N#define PWR_PVD_MODE_IT_FALLING             0x00010002U   /*!< External Interrupt Mode with Falling edge trigger detection */
N#define PWR_PVD_MODE_IT_RISING_FALLING      0x00010003U   /*!< External Interrupt Mode with Rising/Falling edge trigger detection */
N#define PWR_PVD_MODE_EVENT_RISING           0x00020001U   /*!< Event Mode with Rising edge trigger detection */
N#define PWR_PVD_MODE_EVENT_FALLING          0x00020002U   /*!< Event Mode with Falling edge trigger detection */
N#define PWR_PVD_MODE_EVENT_RISING_FALLING   0x00020003U   /*!< Event Mode with Rising/Falling edge trigger detection */
N/**
N  * @}
N  */
N
N
N/** @defgroup PWR_Regulator_state_in_STOP_mode PWR Regulator state in SLEEP/STOP mode
N  * @{
N  */
N#define PWR_MAINREGULATOR_ON                        0x00000000U
N#define PWR_LOWPOWERREGULATOR_ON                    PWR_CR_LPDS
N/**
N  * @}
N  */
N    
N/** @defgroup PWR_SLEEP_mode_entry PWR SLEEP mode entry
N  * @{
N  */
N#define PWR_SLEEPENTRY_WFI              ((uint8_t)0x01)
N#define PWR_SLEEPENTRY_WFE              ((uint8_t)0x02)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_STOP_mode_entry PWR STOP mode entry
N  * @{
N  */
N#define PWR_STOPENTRY_WFI               ((uint8_t)0x01)
N#define PWR_STOPENTRY_WFE               ((uint8_t)0x02)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Flag PWR Flag
N  * @{
N  */
N#define PWR_FLAG_WU                     PWR_CSR_WUF
N#define PWR_FLAG_SB                     PWR_CSR_SBF
N#define PWR_FLAG_PVDO                   PWR_CSR_PVDO
N#define PWR_FLAG_BRR                    PWR_CSR_BRR
N#define PWR_FLAG_VOSRDY                 PWR_CSR_VOSRDY
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWR_Exported_Macro PWR Exported Macro
N  * @{
N  */
N
N/** @brief  Check PWR flag is set or not.
N  * @param  __FLAG__ specifies the flag to check.
N  *           This parameter can be one of the following values:
N  *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
N  *                  was received from the WKUP pin or from the RTC alarm (Alarm A 
N  *                  or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
N  *                  An additional wakeup event is detected if the WKUP pin is enabled 
N  *                  (by setting the EWUP bit) when the WKUP pin level is already high.  
N  *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
N  *                  resumed from StandBy mode.    
N  *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
N  *                  by the HAL_PWR_EnablePVD() function. The PVD is stopped by Standby mode 
N  *                  For this reason, this bit is equal to 0 after Standby or reset
N  *                  until the PVDE bit is set.
N  *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
N  *                  when the device wakes up from Standby mode or by a system reset 
N  *                  or power reset.  
N  *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
N  *                 scaling output selection is ready.
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_PWR_GET_FLAG(__FLAG__) ((PWR->CSR & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clear the PWR's pending flags.
N  * @param  __FLAG__ specifies the flag to clear.
N  *          This parameter can be one of the following values:
N  *            @arg PWR_FLAG_WU: Wake Up flag
N  *            @arg PWR_FLAG_SB: StandBy flag
N  */
N#define __HAL_PWR_CLEAR_FLAG(__FLAG__) (PWR->CR |=  (__FLAG__) << 2U)
N
N/**
N  * @brief Enable the PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_IT()   (EXTI->IMR |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Disable the PVD EXTI Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_IT()  (EXTI->IMR &= ~(PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Enable event on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_EVENT()   (EXTI->EMR |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Disable event on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_EVENT()  (EXTI->EMR &= ~(PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Enable the PVD Extended Interrupt Rising Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE()   SET_BIT(EXTI->RTSR, PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief Disable the PVD Extended Interrupt Rising Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE()  CLEAR_BIT(EXTI->RTSR, PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief Enable the PVD Extended Interrupt Falling Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE()   SET_BIT(EXTI->FTSR, PWR_EXTI_LINE_PVD)
N
N
N/**
N  * @brief Disable the PVD Extended Interrupt Falling Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE()  CLEAR_BIT(EXTI->FTSR, PWR_EXTI_LINE_PVD)
N
N
N/**
N  * @brief  PVD EXTI line configuration: set rising & falling edge trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_FALLING_EDGE()   do{__HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();\
N                                                             __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();\
N                                                            }while(0U)
X#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_FALLING_EDGE()   do{__HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();                                                             __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();                                                            }while(0U)
N
N/**
N  * @brief Disable the PVD Extended Interrupt Rising & Falling Trigger.
N  * This parameter can be:
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_FALLING_EDGE()  do{__HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();\
N                                                             __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();\
N                                                            }while(0U) 
X#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_FALLING_EDGE()  do{__HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();                                                             __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();                                                            }while(0U) 
N
N/**
N  * @brief checks whether the specified PVD Exti interrupt flag is set or not.
N  * @retval EXTI PVD Line Status.
N  */
N#define __HAL_PWR_PVD_EXTI_GET_FLAG()  (EXTI->PR & (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Clear the PVD Exti flag.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_CLEAR_FLAG()  (EXTI->PR = (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief  Generates a Software interrupt on PVD EXTI line.
N  * @retval None
N  */
N#define __HAL_PWR_PVD_EXTI_GENERATE_SWIT() (EXTI->SWIER |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @}
N  */
N
N/* Include PWR HAL Extension module */
N#include "stm32f4xx_hal_pwr_ex.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_pwr_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_pwr_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of PWR HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_PWR_EX_H
N#define __STM32F4xx_HAL_PWR_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PWREx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup PWREx_Exported_Constants PWREx Exported Constants
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L
S   
S/** @defgroup PWREx_Regulator_state_in_UnderDrive_mode PWREx Regulator state in UnderDrive mode
S  * @{
S  */
S#define PWR_MAINREGULATOR_UNDERDRIVE_ON                       PWR_CR_MRUDS
S#define PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON                   ((uint32_t)(PWR_CR_LPDS | PWR_CR_LPUDS))
S/**
S  * @}
S  */ 
S  
S/** @defgroup PWREx_Over_Under_Drive_Flag PWREx Over Under Drive Flag
S  * @{
S  */
S#define PWR_FLAG_ODRDY                  PWR_CSR_ODRDY
S#define PWR_FLAG_ODSWRDY                PWR_CSR_ODSWRDY
S#define PWR_FLAG_UDRDY                  PWR_CSR_UDSWRDY
S/**
S  * @}
S  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N/** @defgroup PWREx_Regulator_Voltage_Scale PWREx Regulator Voltage Scale
N  * @{
N  */
N#if defined(STM32F405xx) || defined(STM32F407xx) || defined(STM32F415xx) || defined(STM32F417xx)   
X#if 0L || 1L || 0L || 0L   
N#define PWR_REGULATOR_VOLTAGE_SCALE1         PWR_CR_VOS             /* Scale 1 mode(default value at reset): the maximum value of fHCLK = 168 MHz. */
N#define PWR_REGULATOR_VOLTAGE_SCALE2         0x00000000U            /* Scale 2 mode: the maximum value of fHCLK = 144 MHz. */
N#else
S#define PWR_REGULATOR_VOLTAGE_SCALE1         PWR_CR_VOS             /* Scale 1 mode(default value at reset): the maximum value of fHCLK is 168 MHz. It can be extended to
S                                                                       180 MHz by activating the over-drive mode. */
S#define PWR_REGULATOR_VOLTAGE_SCALE2         PWR_CR_VOS_1           /* Scale 2 mode: the maximum value of fHCLK is 144 MHz. It can be extended to
S                                                                       168 MHz by activating the over-drive mode. */
S#define PWR_REGULATOR_VOLTAGE_SCALE3         PWR_CR_VOS_0           /* Scale 3 mode: the maximum value of fHCLK is 120 MHz. */
N#endif /* STM32F405xx || STM32F407xx || STM32F415xx || STM32F417xx */ 
N/**
N  * @}
N  */
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
S/** @defgroup PWREx_WakeUp_Pins PWREx WakeUp Pins
S  * @{
S  */
S#define PWR_WAKEUP_PIN2                 0x00000080U
S#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
S    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) 
X#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F412Zx) || defined(STM32F412Vx) ||     defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define PWR_WAKEUP_PIN3                 0x00000040U
S#endif /* STM32F410xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Zx || STM32F412Vx || \
S          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
S/**
S  * @}
S  */   
S#endif /* STM32F410xx || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
N          STM32F413xx || STM32F423xx */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWREx_Exported_Constants PWREx Exported Constants
N  *  @{
N  */
N
N#if defined(STM32F405xx) || defined(STM32F407xx) || defined(STM32F415xx) || defined(STM32F417xx)
X#if 0L || 1L || 0L || 0L
N/** @brief  macros configure the main internal regulator output voltage.
N  * @param  __REGULATOR__ specifies the regulator output voltage to achieve
N  *         a tradeoff between performance and power consumption when the device does
N  *         not operate at the maximum frequency (refer to the datasheets for more details).
N  *          This parameter can be one of the following values:
N  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output Scale 1 mode
N  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output Scale 2 mode
N  * @retval None
N  */
N#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                     \
N                                                            __IO uint32_t tmpreg = 0x00U;                        \
N                                                            MODIFY_REG(PWR->CR, PWR_CR_VOS, (__REGULATOR__));   \
N                                                            /* Delay after an RCC peripheral clock enabling */  \
N                                                            tmpreg = READ_BIT(PWR->CR, PWR_CR_VOS);             \
N                                                            UNUSED(tmpreg);                                     \
N                                                          } while(0U)
X#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                                                                                 __IO uint32_t tmpreg = 0x00U;                                                                                    MODIFY_REG(PWR->CR, PWR_CR_VOS, (__REGULATOR__));                                                                                                                              tmpreg = READ_BIT(PWR->CR, PWR_CR_VOS);                                                                         UNUSED(tmpreg);                                                                                               } while(0U)
N#else
S/** @brief  macros configure the main internal regulator output voltage.
S  * @param  __REGULATOR__ specifies the regulator output voltage to achieve
S  *         a tradeoff between performance and power consumption when the device does
S  *         not operate at the maximum frequency (refer to the datasheets for more details).
S  *          This parameter can be one of the following values:
S  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output Scale 1 mode
S  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output Scale 2 mode
S  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output Scale 3 mode
S  * @retval None
S  */
S#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                     \
S                                                            __IO uint32_t tmpreg = 0x00U;                        \
S                                                            MODIFY_REG(PWR->CR, PWR_CR_VOS, (__REGULATOR__));   \
S                                                            /* Delay after an RCC peripheral clock enabling */  \
S                                                            tmpreg = READ_BIT(PWR->CR, PWR_CR_VOS);             \
S                                                            UNUSED(tmpreg);                                     \
S                                                          } while(0U)
X#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                                                                                 __IO uint32_t tmpreg = 0x00U;                                                                                    MODIFY_REG(PWR->CR, PWR_CR_VOS, (__REGULATOR__));                                                                                                                              tmpreg = READ_BIT(PWR->CR, PWR_CR_VOS);                                                                         UNUSED(tmpreg);                                                                                               } while(0U)
N#endif /* STM32F405xx || STM32F407xx || STM32F415xx || STM32F417xx */ 
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L
S/** @brief Macros to enable or disable the Over drive mode.
S  * @note  These macros can be used only for STM32F42xx/STM3243xx devices.
S  */
S#define __HAL_PWR_OVERDRIVE_ENABLE() (*(__IO uint32_t *) CR_ODEN_BB = ENABLE)
S#define __HAL_PWR_OVERDRIVE_DISABLE() (*(__IO uint32_t *) CR_ODEN_BB = DISABLE)
S
S/** @brief Macros to enable or disable the Over drive switching.
S  * @note  These macros can be used only for STM32F42xx/STM3243xx devices. 
S  */
S#define __HAL_PWR_OVERDRIVESWITCHING_ENABLE() (*(__IO uint32_t *) CR_ODSWEN_BB = ENABLE)
S#define __HAL_PWR_OVERDRIVESWITCHING_DISABLE() (*(__IO uint32_t *) CR_ODSWEN_BB = DISABLE)
S
S/** @brief Macros to enable or disable the Under drive mode.
S  * @note  This mode is enabled only with STOP low power mode.
S  *        In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
S  *        mode is only available when the main regulator or the low power regulator 
S  *        is in low voltage mode.      
S  * @note  If the Under-drive mode was enabled, it is automatically disabled after 
S  *        exiting Stop mode. 
S  *        When the voltage regulator operates in Under-drive mode, an additional  
S  *        startup delay is induced when waking up from Stop mode.
S  */
S#define __HAL_PWR_UNDERDRIVE_ENABLE() (PWR->CR |= (uint32_t)PWR_CR_UDEN)
S#define __HAL_PWR_UNDERDRIVE_DISABLE() (PWR->CR &= (uint32_t)(~PWR_CR_UDEN))
S
S/** @brief  Check PWR flag is set or not.
S  * @note   These macros can be used only for STM32F42xx/STM3243xx devices.
S  * @param  __FLAG__ specifies the flag to check.
S  *         This parameter can be one of the following values:
S  *            @arg PWR_FLAG_ODRDY: This flag indicates that the Over-drive mode
S  *                                 is ready 
S  *            @arg PWR_FLAG_ODSWRDY: This flag indicates that the Over-drive mode
S  *                                   switching is ready  
S  *            @arg PWR_FLAG_UDRDY: This flag indicates that the Under-drive mode
S  *                                 is enabled in Stop mode
S  * @retval The new state of __FLAG__ (TRUE or FALSE).
S  */
S#define __HAL_PWR_GET_ODRUDR_FLAG(__FLAG__) ((PWR->CSR & (__FLAG__)) == (__FLAG__))
S
S/** @brief Clear the Under-Drive Ready flag.
S  * @note  These macros can be used only for STM32F42xx/STM3243xx devices.
S  */
S#define __HAL_PWR_CLEAR_ODRUDR_FLAG() (PWR->CSR |= PWR_FLAG_UDRDY)
S
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup PWREx_Exported_Functions PWREx Exported Functions
N  *  @{
N  */
N 
N/** @addtogroup PWREx_Exported_Functions_Group1
N  * @{
N  */
Nvoid HAL_PWREx_EnableFlashPowerDown(void);
Nvoid HAL_PWREx_DisableFlashPowerDown(void); 
NHAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void);
NHAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void); 
Nuint32_t HAL_PWREx_GetVoltageRange(void);
NHAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling);
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F401xC) ||\
N    defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L
Svoid HAL_PWREx_EnableMainRegulatorLowVoltage(void);
Svoid HAL_PWREx_DisableMainRegulatorLowVoltage(void);
Svoid HAL_PWREx_EnableLowRegulatorLowVoltage(void);
Svoid HAL_PWREx_DisableLowRegulatorLowVoltage(void);
N#endif /* STM32F410xx || STM32F401xC || STM32F401xE || STM32F411xE || STM32F412Zx || STM32F412Vx ||\
N          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F446xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L
SHAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void);
SHAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void);
SHAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup PWREx_Private_Constants PWREx Private Constants
N  * @{
N  */
N
N/** @defgroup PWREx_register_alias_address PWREx Register alias address
N  * @{
N  */
N/* ------------- PWR registers bit address in the alias region ---------------*/
N/* --- CR Register ---*/
N/* Alias word address of FPDS bit */
N#define FPDS_BIT_NUMBER          PWR_CR_FPDS_Pos
N#define CR_FPDS_BB               (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (FPDS_BIT_NUMBER * 4U))
N
N/* Alias word address of ODEN bit   */
N#define ODEN_BIT_NUMBER          PWR_CR_ODEN_Pos
N#define CR_ODEN_BB               (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (ODEN_BIT_NUMBER * 4U))
N
N/* Alias word address of ODSWEN bit */
N#define ODSWEN_BIT_NUMBER        PWR_CR_ODSWEN_Pos
N#define CR_ODSWEN_BB             (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (ODSWEN_BIT_NUMBER * 4U))
N    
N/* Alias word address of MRLVDS bit */
N#define MRLVDS_BIT_NUMBER        PWR_CR_MRLVDS_Pos
N#define CR_MRLVDS_BB             (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (MRLVDS_BIT_NUMBER * 4U))
N
N/* Alias word address of LPLVDS bit */
N#define LPLVDS_BIT_NUMBER        PWR_CR_LPLVDS_Pos
N#define CR_LPLVDS_BB             (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (LPLVDS_BIT_NUMBER * 4U))
N
N /**
N  * @}
N  */
N
N/** @defgroup PWREx_CSR_register_alias PWRx CSR Register alias address
N  * @{
N  */  
N/* --- CSR Register ---*/
N/* Alias word address of BRE bit */
N#define BRE_BIT_NUMBER   PWR_CSR_BRE_Pos
N#define CSR_BRE_BB      (uint32_t)(PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (BRE_BIT_NUMBER * 4U))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup PWREx_Private_Macros PWREx Private Macros
N  * @{
N  */
N
N/** @defgroup PWREx_IS_PWR_Definitions PWREx Private macros to check input parameters
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L
S#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_UNDERDRIVE_ON) || \
S                                                ((REGULATOR) == PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON))
X#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_UNDERDRIVE_ON) ||                                                 ((REGULATOR) == PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F407xx) || defined(STM32F415xx) || defined(STM32F417xx)
X#if 0L || 1L || 0L || 0L
N#define IS_PWR_VOLTAGE_SCALING_RANGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) || \
N                                               ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2))
X#define IS_PWR_VOLTAGE_SCALING_RANGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) ||                                                ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2))
N#else
S#define IS_PWR_VOLTAGE_SCALING_RANGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) || \
S                                               ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2) || \
S                                               ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE3))
X#define IS_PWR_VOLTAGE_SCALING_RANGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) ||                                                ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2) ||                                                ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE3))
N#endif /* STM32F405xx || STM32F407xx || STM32F415xx || STM32F417xx */ 
N
N#if defined(STM32F446xx)
X#if 0L
S#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || ((PIN) == PWR_WAKEUP_PIN2))
S#elif defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F412Zx) ||\
S      defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
S      defined(STM32F423xx)
X#elif 0L || 0L || 0L || 0L ||      0L || 0L || 0L || 0L ||      0L
S#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || ((PIN) == PWR_WAKEUP_PIN2) || \
S                                ((PIN) == PWR_WAKEUP_PIN3))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || ((PIN) == PWR_WAKEUP_PIN2) ||                                 ((PIN) == PWR_WAKEUP_PIN3))
N#else
N#define IS_PWR_WAKEUP_PIN(PIN) ((PIN) == PWR_WAKEUP_PIN1)
N#endif /* STM32F446xx */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F4xx_HAL_PWR_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 275 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_pwr.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup PWR_Exported_Functions PWR Exported Functions
N  * @{
N  */
N  
N/** @addtogroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
Nvoid HAL_PWR_DeInit(void);
Nvoid HAL_PWR_EnableBkUpAccess(void);
Nvoid HAL_PWR_DisableBkUpAccess(void);
N/**
N  * @}
N  */
N
N/** @addtogroup PWR_Exported_Functions_Group2 Peripheral Control functions 
N  * @{
N  */
N/* Peripheral Control functions  **********************************************/
N/* PVD configuration */
Nvoid HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD);
Nvoid HAL_PWR_EnablePVD(void);
Nvoid HAL_PWR_DisablePVD(void);
N
N/* WakeUp pins configuration */
Nvoid HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx);
Nvoid HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx);
N
N/* Low Power modes entry */
Nvoid HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry);
Nvoid HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry);
Nvoid HAL_PWR_EnterSTANDBYMode(void);
N
N/* Power PVD IRQ Handler */
Nvoid HAL_PWR_PVD_IRQHandler(void);
Nvoid HAL_PWR_PVDCallback(void);
N
N/* Cortex System Control functions  *******************************************/
Nvoid HAL_PWR_EnableSleepOnExit(void);
Nvoid HAL_PWR_DisableSleepOnExit(void);
Nvoid HAL_PWR_EnableSEVOnPend(void);
Nvoid HAL_PWR_DisableSEVOnPend(void);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup PWR_Private_Constants PWR Private Constants
N  * @{
N  */
N
N/** @defgroup PWR_PVD_EXTI_Line PWR PVD EXTI Line
N  * @{
N  */
N#define PWR_EXTI_LINE_PVD  ((uint32_t)EXTI_IMR_MR16)  /*!< External interrupt line 16 Connected to the PVD EXTI Line */
N/**
N  * @}
N  */
N
N/** @defgroup PWR_register_alias_address PWR Register alias address
N  * @{
N  */
N/* ------------- PWR registers bit address in the alias region ---------------*/
N#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
N#define PWR_CR_OFFSET            0x00U
N#define PWR_CSR_OFFSET           0x04U
N#define PWR_CR_OFFSET_BB         (PWR_OFFSET + PWR_CR_OFFSET)
N#define PWR_CSR_OFFSET_BB        (PWR_OFFSET + PWR_CSR_OFFSET)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_CR_register_alias PWR CR Register alias address
N  * @{
N  */
N/* --- CR Register ---*/
N/* Alias word address of DBP bit */
N#define DBP_BIT_NUMBER   PWR_CR_DBP_Pos
N#define CR_DBP_BB        (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (DBP_BIT_NUMBER * 4U))
N
N/* Alias word address of PVDE bit */
N#define PVDE_BIT_NUMBER  PWR_CR_PVDE_Pos
N#define CR_PVDE_BB       (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (PVDE_BIT_NUMBER * 4U))
N
N/* Alias word address of VOS bit */
N#define VOS_BIT_NUMBER  PWR_CR_VOS_Pos
N#define CR_VOS_BB      (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (VOS_BIT_NUMBER * 4U))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_CSR_register_alias PWR CSR Register alias address
N  * @{
N  */
N/* --- CSR Register ---*/
N/* Alias word address of EWUP bit */
N#define EWUP_BIT_NUMBER  PWR_CSR_EWUP_Pos
N#define CSR_EWUP_BB      (PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (EWUP_BIT_NUMBER * 4U))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup PWR_Private_Macros PWR Private Macros
N  * @{
N  */
N
N/** @defgroup PWR_IS_PWR_Definitions PWR Private macros to check input parameters
N  * @{
N  */
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)||                                  ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)||                                  ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)||                                  ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))
N#define IS_PWR_PVD_MODE(MODE) (((MODE) == PWR_PVD_MODE_IT_RISING)|| ((MODE) == PWR_PVD_MODE_IT_FALLING) || \
N                              ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) || \
N                              ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING) || \
N                              ((MODE) == PWR_PVD_MODE_NORMAL))
X#define IS_PWR_PVD_MODE(MODE) (((MODE) == PWR_PVD_MODE_IT_RISING)|| ((MODE) == PWR_PVD_MODE_IT_FALLING) ||                               ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) ||                               ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING) ||                               ((MODE) == PWR_PVD_MODE_NORMAL))
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_ON) || \
N                                     ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_ON) ||                                      ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))
N#define IS_PWR_SLEEP_ENTRY(ENTRY) (((ENTRY) == PWR_SLEEPENTRY_WFI) || ((ENTRY) == PWR_SLEEPENTRY_WFE))
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPENTRY_WFI) || ((ENTRY) == PWR_STOPENTRY_WFE))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F4xx_HAL_PWR_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 380 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_PWR_MODULE_ENABLED */
N
N#ifdef HAL_RNG_MODULE_ENABLED
S #include "stm32f4xx_hal_rng.h"
N#endif /* HAL_RNG_MODULE_ENABLED */
N
N#ifdef HAL_RTC_MODULE_ENABLED
S #include "stm32f4xx_hal_rtc.h"
N#endif /* HAL_RTC_MODULE_ENABLED */
N
N#ifdef HAL_SAI_MODULE_ENABLED
S #include "stm32f4xx_hal_sai.h"
N#endif /* HAL_SAI_MODULE_ENABLED */
N
N#ifdef HAL_SD_MODULE_ENABLED
S #include "stm32f4xx_hal_sd.h"
N#endif /* HAL_SD_MODULE_ENABLED */
N
N#ifdef HAL_SPI_MODULE_ENABLED
N #include "stm32f4xx_hal_spi.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_spi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_spi.h
N  * @author  MCD Application Team
N  * @brief   Header file of SPI HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32F4xx_HAL_SPI_H
N#define STM32F4xx_HAL_SPI_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup SPI
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup SPI_Exported_Types SPI Exported Types
N  * @{
N  */
N
N/**
N  * @brief  SPI Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t Mode;                /*!< Specifies the SPI operating mode.
N                                     This parameter can be a value of @ref SPI_Mode */
N
N  uint32_t Direction;           /*!< Specifies the SPI bidirectional mode state.
N                                     This parameter can be a value of @ref SPI_Direction */
N
N  uint32_t DataSize;            /*!< Specifies the SPI data size.
N                                     This parameter can be a value of @ref SPI_Data_Size */
N
N  uint32_t CLKPolarity;         /*!< Specifies the serial clock steady state.
N                                     This parameter can be a value of @ref SPI_Clock_Polarity */
N
N  uint32_t CLKPhase;            /*!< Specifies the clock active edge for the bit capture.
N                                     This parameter can be a value of @ref SPI_Clock_Phase */
N
N  uint32_t NSS;                 /*!< Specifies whether the NSS signal is managed by
N                                     hardware (NSS pin) or by software using the SSI bit.
N                                     This parameter can be a value of @ref SPI_Slave_Select_management */
N
N  uint32_t BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
N                                     used to configure the transmit and receive SCK clock.
N                                     This parameter can be a value of @ref SPI_BaudRate_Prescaler
N                                     @note The communication clock is derived from the master
N                                     clock. The slave clock does not need to be set. */
N
N  uint32_t FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                     This parameter can be a value of @ref SPI_MSB_LSB_transmission */
N
N  uint32_t TIMode;              /*!< Specifies if the TI mode is enabled or not.
N                                     This parameter can be a value of @ref SPI_TI_mode */
N
N  uint32_t CRCCalculation;      /*!< Specifies if the CRC calculation is enabled or not.
N                                     This parameter can be a value of @ref SPI_CRC_Calculation */
N
N  uint32_t CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation.
N                                     This parameter must be an odd number between Min_Data = 1 and Max_Data = 65535 */
N} SPI_InitTypeDef;
N
N/**
N  * @brief  HAL SPI State structure definition
N  */
Ntypedef enum
N{
N  HAL_SPI_STATE_RESET      = 0x00U,    /*!< Peripheral not Initialized                         */
N  HAL_SPI_STATE_READY      = 0x01U,    /*!< Peripheral Initialized and ready for use           */
N  HAL_SPI_STATE_BUSY       = 0x02U,    /*!< an internal process is ongoing                     */
N  HAL_SPI_STATE_BUSY_TX    = 0x03U,    /*!< Data Transmission process is ongoing               */
N  HAL_SPI_STATE_BUSY_RX    = 0x04U,    /*!< Data Reception process is ongoing                  */
N  HAL_SPI_STATE_BUSY_TX_RX = 0x05U,    /*!< Data Transmission and Reception process is ongoing */
N  HAL_SPI_STATE_ERROR      = 0x06U,    /*!< SPI error state                                    */
N  HAL_SPI_STATE_ABORT      = 0x07U     /*!< SPI abort is ongoing                               */
N} HAL_SPI_StateTypeDef;
N
N/**
N  * @brief  SPI handle Structure definition
N  */
Ntypedef struct __SPI_HandleTypeDef
N{
N  SPI_TypeDef                *Instance;      /*!< SPI registers base address               */
N
N  SPI_InitTypeDef            Init;           /*!< SPI communication parameters             */
N
N  uint8_t                    *pTxBuffPtr;    /*!< Pointer to SPI Tx transfer Buffer        */
N
N  uint16_t                   TxXferSize;     /*!< SPI Tx Transfer size                     */
N
N  __IO uint16_t              TxXferCount;    /*!< SPI Tx Transfer Counter                  */
X  volatile uint16_t              TxXferCount;     
N
N  uint8_t                    *pRxBuffPtr;    /*!< Pointer to SPI Rx transfer Buffer        */
N
N  uint16_t                   RxXferSize;     /*!< SPI Rx Transfer size                     */
N
N  __IO uint16_t              RxXferCount;    /*!< SPI Rx Transfer Counter                  */
X  volatile uint16_t              RxXferCount;     
N
N  void (*RxISR)(struct __SPI_HandleTypeDef *hspi);   /*!< function pointer on Rx ISR       */
N
N  void (*TxISR)(struct __SPI_HandleTypeDef *hspi);   /*!< function pointer on Tx ISR       */
N
N  DMA_HandleTypeDef          *hdmatx;        /*!< SPI Tx DMA Handle parameters             */
N
N  DMA_HandleTypeDef          *hdmarx;        /*!< SPI Rx DMA Handle parameters             */
N
N  HAL_LockTypeDef            Lock;           /*!< Locking object                           */
N
N  __IO HAL_SPI_StateTypeDef  State;          /*!< SPI communication state                  */
X  volatile HAL_SPI_StateTypeDef  State;           
N
N  __IO uint32_t              ErrorCode;      /*!< SPI Error code                           */
X  volatile uint32_t              ErrorCode;       
N
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
X#if (0U == 1U)
S  void (* TxCpltCallback)(struct __SPI_HandleTypeDef *hspi);             /*!< SPI Tx Completed callback          */
S  void (* RxCpltCallback)(struct __SPI_HandleTypeDef *hspi);             /*!< SPI Rx Completed callback          */
S  void (* TxRxCpltCallback)(struct __SPI_HandleTypeDef *hspi);           /*!< SPI TxRx Completed callback        */
S  void (* TxHalfCpltCallback)(struct __SPI_HandleTypeDef *hspi);         /*!< SPI Tx Half Completed callback     */
S  void (* RxHalfCpltCallback)(struct __SPI_HandleTypeDef *hspi);         /*!< SPI Rx Half Completed callback     */
S  void (* TxRxHalfCpltCallback)(struct __SPI_HandleTypeDef *hspi);       /*!< SPI TxRx Half Completed callback   */
S  void (* ErrorCallback)(struct __SPI_HandleTypeDef *hspi);              /*!< SPI Error callback                 */
S  void (* AbortCpltCallback)(struct __SPI_HandleTypeDef *hspi);          /*!< SPI Abort callback                 */
S  void (* MspInitCallback)(struct __SPI_HandleTypeDef *hspi);            /*!< SPI Msp Init callback              */
S  void (* MspDeInitCallback)(struct __SPI_HandleTypeDef *hspi);          /*!< SPI Msp DeInit callback            */
S
N#endif  /* USE_HAL_SPI_REGISTER_CALLBACKS */
N} SPI_HandleTypeDef;
N
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
X#if (0U == 1U)
S/**
S  * @brief  HAL SPI Callback ID enumeration definition
S  */
Stypedef enum
S{
S  HAL_SPI_TX_COMPLETE_CB_ID             = 0x00U,    /*!< SPI Tx Completed callback ID         */
S  HAL_SPI_RX_COMPLETE_CB_ID             = 0x01U,    /*!< SPI Rx Completed callback ID         */
S  HAL_SPI_TX_RX_COMPLETE_CB_ID          = 0x02U,    /*!< SPI TxRx Completed callback ID       */
S  HAL_SPI_TX_HALF_COMPLETE_CB_ID        = 0x03U,    /*!< SPI Tx Half Completed callback ID    */
S  HAL_SPI_RX_HALF_COMPLETE_CB_ID        = 0x04U,    /*!< SPI Rx Half Completed callback ID    */
S  HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID     = 0x05U,    /*!< SPI TxRx Half Completed callback ID  */
S  HAL_SPI_ERROR_CB_ID                   = 0x06U,    /*!< SPI Error callback ID                */
S  HAL_SPI_ABORT_CB_ID                   = 0x07U,    /*!< SPI Abort callback ID                */
S  HAL_SPI_MSPINIT_CB_ID                 = 0x08U,    /*!< SPI Msp Init callback ID             */
S  HAL_SPI_MSPDEINIT_CB_ID               = 0x09U     /*!< SPI Msp DeInit callback ID           */
S
S} HAL_SPI_CallbackIDTypeDef;
S
S/**
S  * @brief  HAL SPI Callback pointer definition
S  */
Stypedef  void (*pSPI_CallbackTypeDef)(SPI_HandleTypeDef *hspi); /*!< pointer to an SPI callback function */
S
N#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SPI_Exported_Constants SPI Exported Constants
N  * @{
N  */
N
N/** @defgroup SPI_Error_Code SPI Error Code
N  * @{
N  */
N#define HAL_SPI_ERROR_NONE              (0x00000000U)   /*!< No error                               */
N#define HAL_SPI_ERROR_MODF              (0x00000001U)   /*!< MODF error                             */
N#define HAL_SPI_ERROR_CRC               (0x00000002U)   /*!< CRC error                              */
N#define HAL_SPI_ERROR_OVR               (0x00000004U)   /*!< OVR error                              */
N#define HAL_SPI_ERROR_FRE               (0x00000008U)   /*!< FRE error                              */
N#define HAL_SPI_ERROR_DMA               (0x00000010U)   /*!< DMA transfer error                     */
N#define HAL_SPI_ERROR_FLAG              (0x00000020U)   /*!< Error on RXNE/TXE/BSY Flag             */
N#define HAL_SPI_ERROR_ABORT             (0x00000040U)   /*!< Error during SPI Abort procedure       */
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
X#if (0U == 1U)
S#define HAL_SPI_ERROR_INVALID_CALLBACK  (0x00000080U)   /*!< Invalid Callback error                 */
N#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Mode SPI Mode
N  * @{
N  */
N#define SPI_MODE_SLAVE                  (0x00000000U)
N#define SPI_MODE_MASTER                 (SPI_CR1_MSTR | SPI_CR1_SSI)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Direction SPI Direction Mode
N  * @{
N  */
N#define SPI_DIRECTION_2LINES            (0x00000000U)
N#define SPI_DIRECTION_2LINES_RXONLY     SPI_CR1_RXONLY
N#define SPI_DIRECTION_1LINE             SPI_CR1_BIDIMODE
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Data_Size SPI Data Size
N  * @{
N  */
N#define SPI_DATASIZE_8BIT               (0x00000000U)
N#define SPI_DATASIZE_16BIT              SPI_CR1_DFF
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Polarity SPI Clock Polarity
N  * @{
N  */
N#define SPI_POLARITY_LOW                (0x00000000U)
N#define SPI_POLARITY_HIGH               SPI_CR1_CPOL
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Phase SPI Clock Phase
N  * @{
N  */
N#define SPI_PHASE_1EDGE                 (0x00000000U)
N#define SPI_PHASE_2EDGE                 SPI_CR1_CPHA
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Slave_Select_management SPI Slave Select Management
N  * @{
N  */
N#define SPI_NSS_SOFT                    SPI_CR1_SSM
N#define SPI_NSS_HARD_INPUT              (0x00000000U)
N#define SPI_NSS_HARD_OUTPUT             (SPI_CR2_SSOE << 16U)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_BaudRate_Prescaler SPI BaudRate Prescaler
N  * @{
N  */
N#define SPI_BAUDRATEPRESCALER_2         (0x00000000U)
N#define SPI_BAUDRATEPRESCALER_4         (SPI_CR1_BR_0)
N#define SPI_BAUDRATEPRESCALER_8         (SPI_CR1_BR_1)
N#define SPI_BAUDRATEPRESCALER_16        (SPI_CR1_BR_1 | SPI_CR1_BR_0)
N#define SPI_BAUDRATEPRESCALER_32        (SPI_CR1_BR_2)
N#define SPI_BAUDRATEPRESCALER_64        (SPI_CR1_BR_2 | SPI_CR1_BR_0)
N#define SPI_BAUDRATEPRESCALER_128       (SPI_CR1_BR_2 | SPI_CR1_BR_1)
N#define SPI_BAUDRATEPRESCALER_256       (SPI_CR1_BR_2 | SPI_CR1_BR_1 | SPI_CR1_BR_0)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_MSB_LSB_transmission SPI MSB LSB Transmission
N  * @{
N  */
N#define SPI_FIRSTBIT_MSB                (0x00000000U)
N#define SPI_FIRSTBIT_LSB                SPI_CR1_LSBFIRST
N/**
N  * @}
N  */
N
N/** @defgroup SPI_TI_mode SPI TI Mode
N  * @{
N  */
N#define SPI_TIMODE_DISABLE              (0x00000000U)
N#define SPI_TIMODE_ENABLE               SPI_CR2_FRF
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_Calculation SPI CRC Calculation
N  * @{
N  */
N#define SPI_CRCCALCULATION_DISABLE      (0x00000000U)
N#define SPI_CRCCALCULATION_ENABLE       SPI_CR1_CRCEN
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Interrupt_definition SPI Interrupt Definition
N  * @{
N  */
N#define SPI_IT_TXE                      SPI_CR2_TXEIE
N#define SPI_IT_RXNE                     SPI_CR2_RXNEIE
N#define SPI_IT_ERR                      SPI_CR2_ERRIE
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Flags_definition SPI Flags Definition
N  * @{
N  */
N#define SPI_FLAG_RXNE                   SPI_SR_RXNE   /* SPI status flag: Rx buffer not empty flag       */
N#define SPI_FLAG_TXE                    SPI_SR_TXE    /* SPI status flag: Tx buffer empty flag           */
N#define SPI_FLAG_BSY                    SPI_SR_BSY    /* SPI status flag: Busy flag                      */
N#define SPI_FLAG_CRCERR                 SPI_SR_CRCERR /* SPI Error flag: CRC error flag                  */
N#define SPI_FLAG_MODF                   SPI_SR_MODF   /* SPI Error flag: Mode fault flag                 */
N#define SPI_FLAG_OVR                    SPI_SR_OVR    /* SPI Error flag: Overrun flag                    */
N#define SPI_FLAG_FRE                    SPI_SR_FRE    /* SPI Error flag: TI mode frame format error flag */
N#define SPI_FLAG_MASK                   (SPI_SR_RXNE | SPI_SR_TXE | SPI_SR_BSY | SPI_SR_CRCERR\
N                                         | SPI_SR_MODF | SPI_SR_OVR | SPI_SR_FRE)
X#define SPI_FLAG_MASK                   (SPI_SR_RXNE | SPI_SR_TXE | SPI_SR_BSY | SPI_SR_CRCERR                                         | SPI_SR_MODF | SPI_SR_OVR | SPI_SR_FRE)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup SPI_Exported_Macros SPI Exported Macros
N  * @{
N  */
N
N/** @brief  Reset SPI handle state.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
X#if (0U == 1U)
S#define __HAL_SPI_RESET_HANDLE_STATE(__HANDLE__)                do{                                                  \
S                                                                    (__HANDLE__)->State = HAL_SPI_STATE_RESET;       \
S                                                                    (__HANDLE__)->MspInitCallback = NULL;            \
S                                                                    (__HANDLE__)->MspDeInitCallback = NULL;          \
S                                                                  } while(0)
X#define __HAL_SPI_RESET_HANDLE_STATE(__HANDLE__)                do{                                                                                                                      (__HANDLE__)->State = HAL_SPI_STATE_RESET;                                                                           (__HANDLE__)->MspInitCallback = NULL;                                                                                (__HANDLE__)->MspDeInitCallback = NULL;                                                                            } while(0)
N#else
N#define __HAL_SPI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SPI_STATE_RESET)
N#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
N
N/** @brief  Enable the specified SPI interrupts.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __INTERRUPT__ specifies the interrupt source to enable.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval None
N  */
N#define __HAL_SPI_ENABLE_IT(__HANDLE__, __INTERRUPT__)   SET_BIT((__HANDLE__)->Instance->CR2, (__INTERRUPT__))
N
N/** @brief  Disable the specified SPI interrupts.
N  * @param  __HANDLE__ specifies the SPI handle.
N  *         This parameter can be SPIx where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __INTERRUPT__ specifies the interrupt source to disable.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval None
N  */
N#define __HAL_SPI_DISABLE_IT(__HANDLE__, __INTERRUPT__)  CLEAR_BIT((__HANDLE__)->Instance->CR2, (__INTERRUPT__))
N
N/** @brief  Check whether the specified SPI interrupt source is enabled or not.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __INTERRUPT__ specifies the SPI interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_SPI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->CR2\
N                                                              & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
X#define __HAL_SPI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->CR2                                                              & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Check whether the specified SPI flag is set or not.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_FLAG_RXNE: Receive buffer not empty flag
N  *            @arg SPI_FLAG_TXE: Transmit buffer empty flag
N  *            @arg SPI_FLAG_CRCERR: CRC error flag
N  *            @arg SPI_FLAG_MODF: Mode fault flag
N  *            @arg SPI_FLAG_OVR: Overrun flag
N  *            @arg SPI_FLAG_BSY: Busy flag
N  *            @arg SPI_FLAG_FRE: Frame format error flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_SPI_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clear the SPI CRCERR pending flag.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_CRCERRFLAG(__HANDLE__) ((__HANDLE__)->Instance->SR = (uint16_t)(~SPI_FLAG_CRCERR))
N
N/** @brief  Clear the SPI MODF pending flag.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_MODFFLAG(__HANDLE__)             \
N  do{                                                    \
N    __IO uint32_t tmpreg_modf = 0x00U;                   \
N    tmpreg_modf = (__HANDLE__)->Instance->SR;            \
N    CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_SPE); \
N    UNUSED(tmpreg_modf);                                 \
N  } while(0U)
X#define __HAL_SPI_CLEAR_MODFFLAG(__HANDLE__)               do{                                                        __IO uint32_t tmpreg_modf = 0x00U;                       tmpreg_modf = (__HANDLE__)->Instance->SR;                CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_SPE);     UNUSED(tmpreg_modf);                                   } while(0U)
N
N/** @brief  Clear the SPI OVR pending flag.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_OVRFLAG(__HANDLE__)        \
N  do{                                              \
N    __IO uint32_t tmpreg_ovr = 0x00U;              \
N    tmpreg_ovr = (__HANDLE__)->Instance->DR;       \
N    tmpreg_ovr = (__HANDLE__)->Instance->SR;       \
N    UNUSED(tmpreg_ovr);                            \
N  } while(0U)
X#define __HAL_SPI_CLEAR_OVRFLAG(__HANDLE__)          do{                                                  __IO uint32_t tmpreg_ovr = 0x00U;                  tmpreg_ovr = (__HANDLE__)->Instance->DR;           tmpreg_ovr = (__HANDLE__)->Instance->SR;           UNUSED(tmpreg_ovr);                              } while(0U)
N
N/** @brief  Clear the SPI FRE pending flag.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_FREFLAG(__HANDLE__)        \
N  do{                                              \
N    __IO uint32_t tmpreg_fre = 0x00U;              \
N    tmpreg_fre = (__HANDLE__)->Instance->SR;       \
N    UNUSED(tmpreg_fre);                            \
N  }while(0U)
X#define __HAL_SPI_CLEAR_FREFLAG(__HANDLE__)          do{                                                  __IO uint32_t tmpreg_fre = 0x00U;                  tmpreg_fre = (__HANDLE__)->Instance->SR;           UNUSED(tmpreg_fre);                              }while(0U)
N
N/** @brief  Enable the SPI peripheral.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_ENABLE(__HANDLE__)  SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_SPE)
N
N/** @brief  Disable the SPI peripheral.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_DISABLE(__HANDLE__) CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_SPE)
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup SPI_Private_Macros SPI Private Macros
N  * @{
N  */
N
N/** @brief  Set the SPI transmit-only mode.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define SPI_1LINE_TX(__HANDLE__)  SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_BIDIOE)
N
N/** @brief  Set the SPI receive-only mode.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define SPI_1LINE_RX(__HANDLE__)  CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_BIDIOE)
N
N/** @brief  Reset the CRC calculation of the SPI.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define SPI_RESET_CRC(__HANDLE__) do{CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);\
N                                       SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);}while(0U)
X#define SPI_RESET_CRC(__HANDLE__) do{CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);                                       SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);}while(0U)
N
N/** @brief  Check whether the specified SPI flag is set or not.
N  * @param  __SR__  copy of SPI SR register.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_FLAG_RXNE: Receive buffer not empty flag
N  *            @arg SPI_FLAG_TXE: Transmit buffer empty flag
N  *            @arg SPI_FLAG_CRCERR: CRC error flag
N  *            @arg SPI_FLAG_MODF: Mode fault flag
N  *            @arg SPI_FLAG_OVR: Overrun flag
N  *            @arg SPI_FLAG_BSY: Busy flag
N  *            @arg SPI_FLAG_FRE: Frame format error flag
N  * @retval SET or RESET.
N  */
N#define SPI_CHECK_FLAG(__SR__, __FLAG__) ((((__SR__) & ((__FLAG__) & SPI_FLAG_MASK)) == \
N                                          ((__FLAG__) & SPI_FLAG_MASK)) ? SET : RESET)
X#define SPI_CHECK_FLAG(__SR__, __FLAG__) ((((__SR__) & ((__FLAG__) & SPI_FLAG_MASK)) ==                                           ((__FLAG__) & SPI_FLAG_MASK)) ? SET : RESET)
N
N/** @brief  Check whether the specified SPI Interrupt is set or not.
N  * @param  __CR2__  copy of SPI CR2 register.
N  * @param  __INTERRUPT__ specifies the SPI interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval SET or RESET.
N  */
N#define SPI_CHECK_IT_SOURCE(__CR2__, __INTERRUPT__) ((((__CR2__) & (__INTERRUPT__)) == \
N                                                     (__INTERRUPT__)) ? SET : RESET)
X#define SPI_CHECK_IT_SOURCE(__CR2__, __INTERRUPT__) ((((__CR2__) & (__INTERRUPT__)) ==                                                      (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Checks if SPI Mode parameter is in allowed range.
N  * @param  __MODE__ specifies the SPI Mode.
N  *         This parameter can be a value of @ref SPI_Mode
N  * @retval None
N  */
N#define IS_SPI_MODE(__MODE__)      (((__MODE__) == SPI_MODE_SLAVE)   || \
N                                    ((__MODE__) == SPI_MODE_MASTER))
X#define IS_SPI_MODE(__MODE__)      (((__MODE__) == SPI_MODE_SLAVE)   ||                                     ((__MODE__) == SPI_MODE_MASTER))
N
N/** @brief  Checks if SPI Direction Mode parameter is in allowed range.
N  * @param  __MODE__ specifies the SPI Direction Mode.
N  *         This parameter can be a value of @ref SPI_Direction
N  * @retval None
N  */
N#define IS_SPI_DIRECTION(__MODE__) (((__MODE__) == SPI_DIRECTION_2LINES)        || \
N                                    ((__MODE__) == SPI_DIRECTION_2LINES_RXONLY) || \
N                                    ((__MODE__) == SPI_DIRECTION_1LINE))
X#define IS_SPI_DIRECTION(__MODE__) (((__MODE__) == SPI_DIRECTION_2LINES)        ||                                     ((__MODE__) == SPI_DIRECTION_2LINES_RXONLY) ||                                     ((__MODE__) == SPI_DIRECTION_1LINE))
N
N/** @brief  Checks if SPI Direction Mode parameter is 2 lines.
N  * @param  __MODE__ specifies the SPI Direction Mode.
N  * @retval None
N  */
N#define IS_SPI_DIRECTION_2LINES(__MODE__) ((__MODE__) == SPI_DIRECTION_2LINES)
N
N/** @brief  Checks if SPI Direction Mode parameter is 1 or 2 lines.
N  * @param  __MODE__ specifies the SPI Direction Mode.
N  * @retval None
N  */
N#define IS_SPI_DIRECTION_2LINES_OR_1LINE(__MODE__) (((__MODE__) == SPI_DIRECTION_2LINES) || \
N                                                    ((__MODE__) == SPI_DIRECTION_1LINE))
X#define IS_SPI_DIRECTION_2LINES_OR_1LINE(__MODE__) (((__MODE__) == SPI_DIRECTION_2LINES) ||                                                     ((__MODE__) == SPI_DIRECTION_1LINE))
N
N/** @brief  Checks if SPI Data Size parameter is in allowed range.
N  * @param  __DATASIZE__ specifies the SPI Data Size.
N  *         This parameter can be a value of @ref SPI_Data_Size
N  * @retval None
N  */
N#define IS_SPI_DATASIZE(__DATASIZE__) (((__DATASIZE__) == SPI_DATASIZE_16BIT) || \
N                                       ((__DATASIZE__) == SPI_DATASIZE_8BIT))
X#define IS_SPI_DATASIZE(__DATASIZE__) (((__DATASIZE__) == SPI_DATASIZE_16BIT) ||                                        ((__DATASIZE__) == SPI_DATASIZE_8BIT))
N
N/** @brief  Checks if SPI Serial clock steady state parameter is in allowed range.
N  * @param  __CPOL__ specifies the SPI serial clock steady state.
N  *         This parameter can be a value of @ref SPI_Clock_Polarity
N  * @retval None
N  */
N#define IS_SPI_CPOL(__CPOL__)      (((__CPOL__) == SPI_POLARITY_LOW) || \
N                                    ((__CPOL__) == SPI_POLARITY_HIGH))
X#define IS_SPI_CPOL(__CPOL__)      (((__CPOL__) == SPI_POLARITY_LOW) ||                                     ((__CPOL__) == SPI_POLARITY_HIGH))
N
N/** @brief  Checks if SPI Clock Phase parameter is in allowed range.
N  * @param  __CPHA__ specifies the SPI Clock Phase.
N  *         This parameter can be a value of @ref SPI_Clock_Phase
N  * @retval None
N  */
N#define IS_SPI_CPHA(__CPHA__)      (((__CPHA__) == SPI_PHASE_1EDGE) || \
N                                    ((__CPHA__) == SPI_PHASE_2EDGE))
X#define IS_SPI_CPHA(__CPHA__)      (((__CPHA__) == SPI_PHASE_1EDGE) ||                                     ((__CPHA__) == SPI_PHASE_2EDGE))
N
N/** @brief  Checks if SPI Slave Select parameter is in allowed range.
N  * @param  __NSS__ specifies the SPI Slave Select management parameter.
N  *         This parameter can be a value of @ref SPI_Slave_Select_management
N  * @retval None
N  */
N#define IS_SPI_NSS(__NSS__)        (((__NSS__) == SPI_NSS_SOFT)       || \
N                                    ((__NSS__) == SPI_NSS_HARD_INPUT) || \
N                                    ((__NSS__) == SPI_NSS_HARD_OUTPUT))
X#define IS_SPI_NSS(__NSS__)        (((__NSS__) == SPI_NSS_SOFT)       ||                                     ((__NSS__) == SPI_NSS_HARD_INPUT) ||                                     ((__NSS__) == SPI_NSS_HARD_OUTPUT))
N
N/** @brief  Checks if SPI Baudrate prescaler parameter is in allowed range.
N  * @param  __PRESCALER__ specifies the SPI Baudrate prescaler.
N  *         This parameter can be a value of @ref SPI_BaudRate_Prescaler
N  * @retval None
N  */
N#define IS_SPI_BAUDRATE_PRESCALER(__PRESCALER__) (((__PRESCALER__) == SPI_BAUDRATEPRESCALER_2)   || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_4)   || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_8)   || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_16)  || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_32)  || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_64)  || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_128) || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_256))
X#define IS_SPI_BAUDRATE_PRESCALER(__PRESCALER__) (((__PRESCALER__) == SPI_BAUDRATEPRESCALER_2)   ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_4)   ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_8)   ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_16)  ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_32)  ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_64)  ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_128) ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_256))
N
N/** @brief  Checks if SPI MSB LSB transmission parameter is in allowed range.
N  * @param  __BIT__ specifies the SPI MSB LSB transmission (whether data transfer starts from MSB or LSB bit).
N  *         This parameter can be a value of @ref SPI_MSB_LSB_transmission
N  * @retval None
N  */
N#define IS_SPI_FIRST_BIT(__BIT__)  (((__BIT__) == SPI_FIRSTBIT_MSB) || \
N                                    ((__BIT__) == SPI_FIRSTBIT_LSB))
X#define IS_SPI_FIRST_BIT(__BIT__)  (((__BIT__) == SPI_FIRSTBIT_MSB) ||                                     ((__BIT__) == SPI_FIRSTBIT_LSB))
N
N/** @brief  Checks if SPI TI mode parameter is in allowed range.
N  * @param  __MODE__ specifies the SPI TI mode.
N  *         This parameter can be a value of @ref SPI_TI_mode
N  * @retval None
N  */
N#define IS_SPI_TIMODE(__MODE__)    (((__MODE__) == SPI_TIMODE_DISABLE) || \
N                                    ((__MODE__) == SPI_TIMODE_ENABLE))
X#define IS_SPI_TIMODE(__MODE__)    (((__MODE__) == SPI_TIMODE_DISABLE) ||                                     ((__MODE__) == SPI_TIMODE_ENABLE))
N
N/** @brief  Checks if SPI CRC calculation enabled state is in allowed range.
N  * @param  __CALCULATION__ specifies the SPI CRC calculation enable state.
N  *         This parameter can be a value of @ref SPI_CRC_Calculation
N  * @retval None
N  */
N#define IS_SPI_CRC_CALCULATION(__CALCULATION__) (((__CALCULATION__) == SPI_CRCCALCULATION_DISABLE) || \
N                                                 ((__CALCULATION__) == SPI_CRCCALCULATION_ENABLE))
X#define IS_SPI_CRC_CALCULATION(__CALCULATION__) (((__CALCULATION__) == SPI_CRCCALCULATION_DISABLE) ||                                                  ((__CALCULATION__) == SPI_CRCCALCULATION_ENABLE))
N
N/** @brief  Checks if SPI polynomial value to be used for the CRC calculation, is in allowed range.
N  * @param  __POLYNOMIAL__ specifies the SPI polynomial value to be used for the CRC calculation.
N  *         This parameter must be a number between Min_Data = 0 and Max_Data = 65535
N  * @retval None
N  */
N#define IS_SPI_CRC_POLYNOMIAL(__POLYNOMIAL__) (((__POLYNOMIAL__) >= 0x1U)    && \
N                                               ((__POLYNOMIAL__) <= 0xFFFFU) && \
N                                              (((__POLYNOMIAL__)&0x1U) != 0U))
X#define IS_SPI_CRC_POLYNOMIAL(__POLYNOMIAL__) (((__POLYNOMIAL__) >= 0x1U)    &&                                                ((__POLYNOMIAL__) <= 0xFFFFU) &&                                               (((__POLYNOMIAL__)&0x1U) != 0U))
N
N/** @brief  Checks if DMA handle is valid.
N  * @param  __HANDLE__ specifies a DMA Handle.
N  * @retval None
N  */
N#define IS_SPI_DMA_HANDLE(__HANDLE__) ((__HANDLE__) != NULL)
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup SPI_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup SPI_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions  ********************************/
NHAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_MspInit(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi);
N
N/* Callbacks Register/UnRegister functions  ***********************************/
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
X#if (0U == 1U)
SHAL_StatusTypeDef HAL_SPI_RegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID, pSPI_CallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_SPI_UnRegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID);
N#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @addtogroup SPI_Exported_Functions_Group2
N  * @{
N  */
N/* I/O operation functions  ***************************************************/
NHAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
N                                          uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
N                                             uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
N                                              uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi);
N/* Transfer Abort functions */
NHAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi);
N
Nvoid HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi);
N/**
N  * @}
N  */
N
N/** @addtogroup SPI_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State and Error functions ***************************************/
NHAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi);
Nuint32_t             HAL_SPI_GetError(SPI_HandleTypeDef *hspi);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* STM32F4xx_HAL_SPI_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 400 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_SPI_MODULE_ENABLED */
N
N#ifdef HAL_TIM_MODULE_ENABLED
S #include "stm32f4xx_hal_tim.h"
N#endif /* HAL_TIM_MODULE_ENABLED */
N
N#ifdef HAL_UART_MODULE_ENABLED
N #include "stm32f4xx_hal_uart.h"
L 1 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_uart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_uart.h
N  * @author  MCD Application Team
N  * @brief   Header file of UART HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_UART_H
N#define __STM32F4xx_HAL_UART_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup UART
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup UART_Exported_Types UART Exported Types
N  * @{
N  */
N
N/**
N  * @brief UART Init Structure definition
N  */
Ntypedef struct
N{
N  uint32_t BaudRate;                  /*!< This member configures the UART communication baud rate.
N                                           The baud rate is computed using the following formula:
N                                           - IntegerDivider = ((PCLKx) / (8 * (OVR8+1) * (huart->Init.BaudRate)))
N                                           - FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 8 * (OVR8+1)) + 0.5
N                                           Where OVR8 is the "oversampling by 8 mode" configuration bit in the CR1 register. */
N
N  uint32_t WordLength;                /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref UART_Word_Length */
N
N  uint32_t StopBits;                  /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref UART_Stop_Bits */
N
N  uint32_t Parity;                    /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref UART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N
N  uint32_t Mode;                      /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref UART_Mode */
N
N  uint32_t HwFlowCtl;                 /*!< Specifies whether the hardware flow control mode is enabled or disabled.
N                                           This parameter can be a value of @ref UART_Hardware_Flow_Control */
N
N  uint32_t OverSampling;              /*!< Specifies whether the Over sampling 8 is enabled or disabled, to achieve higher speed (up to fPCLK/8).
N                                           This parameter can be a value of @ref UART_Over_Sampling */
N} UART_InitTypeDef;
N
N/**
N  * @brief HAL UART State structures definition
N  * @note  HAL UART State value is a combination of 2 different substates: gState and RxState.
N  *        - gState contains UART state information related to global Handle management
N  *          and also information related to Tx operations.
N  *          gState value coding follow below described bitmap :
N  *          b7-b6  Error information
N  *             00 : No Error
N  *             01 : (Not Used)
N  *             10 : Timeout
N  *             11 : Error
N  *          b5     Peripheral initialization status
N  *             0  : Reset (Peripheral not initialized)
N  *             1  : Init done (Peripheral initialized. HAL UART Init function already called)
N  *          b4-b3  (not used)
N  *             xx : Should be set to 00
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (Peripheral busy with some configuration or internal operations)
N  *          b1     (not used)
N  *             x  : Should be set to 0
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  *        - RxState contains information related to Rx operations.
N  *          RxState value coding follow below described bitmap :
N  *          b7-b6  (not used)
N  *             xx : Should be set to 00
N  *          b5     Peripheral initialization status
N  *             0  : Reset (Peripheral not initialized)
N  *             1  : Init done (Peripheral initialized)
N  *          b4-b2  (not used)
N  *            xxx : Should be set to 000
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     (not used)
N  *             x  : Should be set to 0.
N  */
Ntypedef enum
N{
N  HAL_UART_STATE_RESET             = 0x00U,    /*!< Peripheral is not yet Initialized
N                                                   Value is allowed for gState and RxState */
N  HAL_UART_STATE_READY             = 0x20U,    /*!< Peripheral Initialized and ready for use
N                                                   Value is allowed for gState and RxState */
N  HAL_UART_STATE_BUSY              = 0x24U,    /*!< an internal process is ongoing
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_BUSY_TX           = 0x21U,    /*!< Data Transmission process is ongoing
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_BUSY_RX           = 0x22U,    /*!< Data Reception process is ongoing
N                                                   Value is allowed for RxState only */
N  HAL_UART_STATE_BUSY_TX_RX        = 0x23U,    /*!< Data Transmission and Reception process is ongoing
N                                                   Not to be used for neither gState nor RxState.
N                                                   Value is result of combination (Or) between gState and RxState values */
N  HAL_UART_STATE_TIMEOUT           = 0xA0U,    /*!< Timeout state
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_ERROR             = 0xE0U     /*!< Error
N                                                   Value is allowed for gState only */
N} HAL_UART_StateTypeDef;
N
N/**
N  * @brief HAL UART Reception type definition
N  * @note  HAL UART Reception type value aims to identify which type of Reception is ongoing.
N  *        It is expected to admit following values :
N  *           HAL_UART_RECEPTION_STANDARD         = 0x00U,
N  *           HAL_UART_RECEPTION_TOIDLE           = 0x01U,
N  */
Ntypedef uint32_t HAL_UART_RxTypeTypeDef;
N
N/**
N  * @brief  UART handle Structure definition
N  */
Ntypedef struct __UART_HandleTypeDef
N{
N  USART_TypeDef                 *Instance;        /*!< UART registers base address        */
N
N  UART_InitTypeDef              Init;             /*!< UART communication parameters      */
N
N  uint8_t                       *pTxBuffPtr;      /*!< Pointer to UART Tx transfer Buffer */
N
N  uint16_t                      TxXferSize;       /*!< UART Tx Transfer size              */
N
N  __IO uint16_t                 TxXferCount;      /*!< UART Tx Transfer Counter           */
X  volatile uint16_t                 TxXferCount;       
N
N  uint8_t                       *pRxBuffPtr;      /*!< Pointer to UART Rx transfer Buffer */
N
N  uint16_t                      RxXferSize;       /*!< UART Rx Transfer size              */
N
N  __IO uint16_t                 RxXferCount;      /*!< UART Rx Transfer Counter           */
X  volatile uint16_t                 RxXferCount;       
N
N  __IO HAL_UART_RxTypeTypeDef ReceptionType;      /*!< Type of ongoing reception          */
X  volatile HAL_UART_RxTypeTypeDef ReceptionType;       
N
N  DMA_HandleTypeDef             *hdmatx;          /*!< UART Tx DMA Handle parameters      */
N
N  DMA_HandleTypeDef             *hdmarx;          /*!< UART Rx DMA Handle parameters      */
N
N  HAL_LockTypeDef               Lock;             /*!< Locking object                     */
N
N  __IO HAL_UART_StateTypeDef    gState;           /*!< UART state information related to global Handle management
X  volatile HAL_UART_StateTypeDef    gState;           
N                                                       and also related to Tx operations.
N                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO HAL_UART_StateTypeDef    RxState;          /*!< UART state information related to Rx operations.
X  volatile HAL_UART_StateTypeDef    RxState;          
N                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO uint32_t                 ErrorCode;        /*!< UART Error code                    */
X  volatile uint32_t                 ErrorCode;         
N
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
X#if (1U == 1)
N  void (* TxHalfCpltCallback)(struct __UART_HandleTypeDef *huart);        /*!< UART Tx Half Complete Callback        */
N  void (* TxCpltCallback)(struct __UART_HandleTypeDef *huart);            /*!< UART Tx Complete Callback             */
N  void (* RxHalfCpltCallback)(struct __UART_HandleTypeDef *huart);        /*!< UART Rx Half Complete Callback        */
N  void (* RxCpltCallback)(struct __UART_HandleTypeDef *huart);            /*!< UART Rx Complete Callback             */
N  void (* ErrorCallback)(struct __UART_HandleTypeDef *huart);             /*!< UART Error Callback                   */
N  void (* AbortCpltCallback)(struct __UART_HandleTypeDef *huart);         /*!< UART Abort Complete Callback          */
N  void (* AbortTransmitCpltCallback)(struct __UART_HandleTypeDef *huart); /*!< UART Abort Transmit Complete Callback */
N  void (* AbortReceiveCpltCallback)(struct __UART_HandleTypeDef *huart);  /*!< UART Abort Receive Complete Callback  */
N  void (* WakeupCallback)(struct __UART_HandleTypeDef *huart);            /*!< UART Wakeup Callback                  */
N  void (* RxEventCallback)(struct __UART_HandleTypeDef *huart, uint16_t Pos); /*!< UART Reception Event Callback     */
N
N  void (* MspInitCallback)(struct __UART_HandleTypeDef *huart);           /*!< UART Msp Init callback                */
N  void (* MspDeInitCallback)(struct __UART_HandleTypeDef *huart);         /*!< UART Msp DeInit callback              */
N#endif  /* USE_HAL_UART_REGISTER_CALLBACKS */
N
N} UART_HandleTypeDef;
N
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
X#if (1U == 1)
N/**
N  * @brief  HAL UART Callback ID enumeration definition
N  */
Ntypedef enum
N{
N  HAL_UART_TX_HALFCOMPLETE_CB_ID         = 0x00U,    /*!< UART Tx Half Complete Callback ID        */
N  HAL_UART_TX_COMPLETE_CB_ID             = 0x01U,    /*!< UART Tx Complete Callback ID             */
N  HAL_UART_RX_HALFCOMPLETE_CB_ID         = 0x02U,    /*!< UART Rx Half Complete Callback ID        */
N  HAL_UART_RX_COMPLETE_CB_ID             = 0x03U,    /*!< UART Rx Complete Callback ID             */
N  HAL_UART_ERROR_CB_ID                   = 0x04U,    /*!< UART Error Callback ID                   */
N  HAL_UART_ABORT_COMPLETE_CB_ID          = 0x05U,    /*!< UART Abort Complete Callback ID          */
N  HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID = 0x06U,    /*!< UART Abort Transmit Complete Callback ID */
N  HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID  = 0x07U,    /*!< UART Abort Receive Complete Callback ID  */
N  HAL_UART_WAKEUP_CB_ID                  = 0x08U,    /*!< UART Wakeup Callback ID                  */
N
N  HAL_UART_MSPINIT_CB_ID                 = 0x0BU,    /*!< UART MspInit callback ID                 */
N  HAL_UART_MSPDEINIT_CB_ID               = 0x0CU     /*!< UART MspDeInit callback ID               */
N
N} HAL_UART_CallbackIDTypeDef;
N
N/**
N  * @brief  HAL UART Callback pointer definition
N  */
Ntypedef  void (*pUART_CallbackTypeDef)(UART_HandleTypeDef *huart);  /*!< pointer to an UART callback function */
Ntypedef  void (*pUART_RxEventCallbackTypeDef)(struct __UART_HandleTypeDef *huart, uint16_t Pos);   /*!< pointer to a UART Rx Event specific callback function */
N
N#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup UART_Exported_Constants UART Exported Constants
N  * @{
N  */
N
N/** @defgroup UART_Error_Code UART Error Code
N  * @{
N  */
N#define HAL_UART_ERROR_NONE              0x00000000U   /*!< No error            */
N#define HAL_UART_ERROR_PE                0x00000001U   /*!< Parity error        */
N#define HAL_UART_ERROR_NE                0x00000002U   /*!< Noise error         */
N#define HAL_UART_ERROR_FE                0x00000004U   /*!< Frame error         */
N#define HAL_UART_ERROR_ORE               0x00000008U   /*!< Overrun error       */
N#define HAL_UART_ERROR_DMA               0x00000010U   /*!< DMA transfer error  */
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
X#if (1U == 1)
N#define  HAL_UART_ERROR_INVALID_CALLBACK 0x00000020U   /*!< Invalid Callback error  */
N#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Word_Length UART Word Length
N  * @{
N  */
N#define UART_WORDLENGTH_8B                  0x00000000U
N#define UART_WORDLENGTH_9B                  ((uint32_t)USART_CR1_M)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Stop_Bits UART Number of Stop Bits
N  * @{
N  */
N#define UART_STOPBITS_1                     0x00000000U
N#define UART_STOPBITS_2                     ((uint32_t)USART_CR2_STOP_1)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Parity UART Parity
N  * @{
N  */
N#define UART_PARITY_NONE                    0x00000000U
N#define UART_PARITY_EVEN                    ((uint32_t)USART_CR1_PCE)
N#define UART_PARITY_ODD                     ((uint32_t)(USART_CR1_PCE | USART_CR1_PS))
N/**
N  * @}
N  */
N
N/** @defgroup UART_Hardware_Flow_Control UART Hardware Flow Control
N  * @{
N  */
N#define UART_HWCONTROL_NONE                  0x00000000U
N#define UART_HWCONTROL_RTS                   ((uint32_t)USART_CR3_RTSE)
N#define UART_HWCONTROL_CTS                   ((uint32_t)USART_CR3_CTSE)
N#define UART_HWCONTROL_RTS_CTS               ((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE))
N/**
N  * @}
N  */
N
N/** @defgroup UART_Mode UART Transfer Mode
N  * @{
N  */
N#define UART_MODE_RX                        ((uint32_t)USART_CR1_RE)
N#define UART_MODE_TX                        ((uint32_t)USART_CR1_TE)
N#define UART_MODE_TX_RX                     ((uint32_t)(USART_CR1_TE | USART_CR1_RE))
N/**
N  * @}
N  */
N
N/** @defgroup UART_State UART State
N  * @{
N  */
N#define UART_STATE_DISABLE                  0x00000000U
N#define UART_STATE_ENABLE                   ((uint32_t)USART_CR1_UE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Over_Sampling UART Over Sampling
N  * @{
N  */
N#define UART_OVERSAMPLING_16                    0x00000000U
N#define UART_OVERSAMPLING_8                     ((uint32_t)USART_CR1_OVER8)
N/**
N  * @}
N  */
N
N/** @defgroup UART_LIN_Break_Detection_Length  UART LIN Break Detection Length
N  * @{
N  */
N#define UART_LINBREAKDETECTLENGTH_10B      0x00000000U
N#define UART_LINBREAKDETECTLENGTH_11B      ((uint32_t)USART_CR2_LBDL)
N/**
N  * @}
N  */
N
N/** @defgroup UART_WakeUp_functions  UART Wakeup Functions
N  * @{
N  */
N#define UART_WAKEUPMETHOD_IDLELINE                0x00000000U
N#define UART_WAKEUPMETHOD_ADDRESSMARK             ((uint32_t)USART_CR1_WAKE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Flags   UART FLags
N  *        Elements values convention: 0xXXXX
N  *           - 0xXXXX  : Flag mask in the SR register
N  * @{
N  */
N#define UART_FLAG_CTS                       ((uint32_t)USART_SR_CTS)
N#define UART_FLAG_LBD                       ((uint32_t)USART_SR_LBD)
N#define UART_FLAG_TXE                       ((uint32_t)USART_SR_TXE)
N#define UART_FLAG_TC                        ((uint32_t)USART_SR_TC)
N#define UART_FLAG_RXNE                      ((uint32_t)USART_SR_RXNE)
N#define UART_FLAG_IDLE                      ((uint32_t)USART_SR_IDLE)
N#define UART_FLAG_ORE                       ((uint32_t)USART_SR_ORE)
N#define UART_FLAG_NE                        ((uint32_t)USART_SR_NE)
N#define UART_FLAG_FE                        ((uint32_t)USART_SR_FE)
N#define UART_FLAG_PE                        ((uint32_t)USART_SR_PE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Interrupt_definition  UART Interrupt Definitions
N  *        Elements values convention: 0xY000XXXX
N  *           - XXXX  : Interrupt mask (16 bits) in the Y register
N  *           - Y  : Interrupt source register (2bits)
N  *                   - 0001: CR1 register
N  *                   - 0010: CR2 register
N  *                   - 0011: CR3 register
N  * @{
N  */
N
N#define UART_IT_PE                       ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_PEIE))
N#define UART_IT_TXE                      ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_TXEIE))
N#define UART_IT_TC                       ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_TCIE))
N#define UART_IT_RXNE                     ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_RXNEIE))
N#define UART_IT_IDLE                     ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_IDLEIE))
N
N#define UART_IT_LBD                      ((uint32_t)(UART_CR2_REG_INDEX << 28U | USART_CR2_LBDIE))
N
N#define UART_IT_CTS                      ((uint32_t)(UART_CR3_REG_INDEX << 28U | USART_CR3_CTSIE))
N#define UART_IT_ERR                      ((uint32_t)(UART_CR3_REG_INDEX << 28U | USART_CR3_EIE))
N/**
N  * @}
N  */
N
N/** @defgroup UART_RECEPTION_TYPE_Values  UART Reception type values
N  * @{
N  */
N#define HAL_UART_RECEPTION_STANDARD          (0x00000000U)             /*!< Standard reception                       */
N#define HAL_UART_RECEPTION_TOIDLE            (0x00000001U)             /*!< Reception till completion or IDLE event  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup UART_Exported_Macros UART Exported Macros
N  * @{
N  */
N
N/** @brief Reset UART handle gstate & RxState
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
X#if (1U == 1)
N#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
N                                                       (__HANDLE__)->gState = HAL_UART_STATE_RESET;      \
N                                                       (__HANDLE__)->RxState = HAL_UART_STATE_RESET;     \
N                                                       (__HANDLE__)->MspInitCallback = NULL;             \
N                                                       (__HANDLE__)->MspDeInitCallback = NULL;           \
N                                                     } while(0U)
X#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                                                                          (__HANDLE__)->gState = HAL_UART_STATE_RESET;                                                             (__HANDLE__)->RxState = HAL_UART_STATE_RESET;                                                            (__HANDLE__)->MspInitCallback = NULL;                                                                    (__HANDLE__)->MspDeInitCallback = NULL;                                                                } while(0U)
N#else
S#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
S                                                       (__HANDLE__)->gState = HAL_UART_STATE_RESET;      \
S                                                       (__HANDLE__)->RxState = HAL_UART_STATE_RESET;     \
S                                                     } while(0U)
X#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                                                                          (__HANDLE__)->gState = HAL_UART_STATE_RESET;                                                             (__HANDLE__)->RxState = HAL_UART_STATE_RESET;                                                          } while(0U)
N#endif /*USE_HAL_UART_REGISTER_CALLBACKS */
N
N/** @brief  Flushes the UART DR register
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  */
N#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__) ((__HANDLE__)->Instance->DR)
N
N/** @brief  Checks whether the specified UART flag is set or not.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __FLAG__ specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg UART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
N  *            @arg UART_FLAG_LBD:  LIN Break detection flag
N  *            @arg UART_FLAG_TXE:  Transmit data register empty flag
N  *            @arg UART_FLAG_TC:   Transmission Complete flag
N  *            @arg UART_FLAG_RXNE: Receive data register not empty flag
N  *            @arg UART_FLAG_IDLE: Idle Line detection flag
N  *            @arg UART_FLAG_ORE:  Overrun Error flag
N  *            @arg UART_FLAG_NE:   Noise Error flag
N  *            @arg UART_FLAG_FE:   Framing Error flag
N  *            @arg UART_FLAG_PE:   Parity Error flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->SR & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clears the specified UART pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __FLAG__ specifies the flag to check.
N  *          This parameter can be any combination of the following values:
N  *            @arg UART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
N  *            @arg UART_FLAG_LBD:  LIN Break detection flag.
N  *            @arg UART_FLAG_TC:   Transmission Complete flag.
N  *            @arg UART_FLAG_RXNE: Receive data register not empty flag.
N  *
N  * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (Overrun
N  *          error) and IDLE (Idle line detected) flags are cleared by software
N  *          sequence: a read operation to USART_SR register followed by a read
N  *          operation to USART_DR register.
N  * @note   RXNE flag can be also cleared by a read to the USART_DR register.
N  * @note   TC flag can be also cleared by software sequence: a read operation to
N  *          USART_SR register followed by a write operation to USART_DR register.
N  * @note   TXE flag is cleared only by a write to the USART_DR register.
N  *
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->SR = ~(__FLAG__))
N
N/** @brief  Clears the UART PE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_PEFLAG(__HANDLE__)     \
N  do{                                           \
N    __IO uint32_t tmpreg = 0x00U;               \
N    tmpreg = (__HANDLE__)->Instance->SR;        \
N    tmpreg = (__HANDLE__)->Instance->DR;        \
N    UNUSED(tmpreg);                             \
N  } while(0U)
X#define __HAL_UART_CLEAR_PEFLAG(__HANDLE__)       do{                                               __IO uint32_t tmpreg = 0x00U;                   tmpreg = (__HANDLE__)->Instance->SR;            tmpreg = (__HANDLE__)->Instance->DR;            UNUSED(tmpreg);                               } while(0U)
N
N/** @brief  Clears the UART FE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_FEFLAG(__HANDLE__) __HAL_UART_CLEAR_PEFLAG(__HANDLE__)
N
N/** @brief  Clears the UART NE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_NEFLAG(__HANDLE__) __HAL_UART_CLEAR_PEFLAG(__HANDLE__)
N
N/** @brief  Clears the UART ORE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_OREFLAG(__HANDLE__) __HAL_UART_CLEAR_PEFLAG(__HANDLE__)
N
N/** @brief  Clears the UART IDLE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_IDLEFLAG(__HANDLE__) __HAL_UART_CLEAR_PEFLAG(__HANDLE__)
N
N/** @brief  Enable the specified UART interrupt.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __INTERRUPT__ specifies the UART interrupt source to enable.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_CTS:  CTS change interrupt
N  *            @arg UART_IT_LBD:  LIN Break detection interrupt
N  *            @arg UART_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:   Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_PE:   Parity Error interrupt
N  *            @arg UART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 |= ((__INTERRUPT__) & UART_IT_MASK)): \
N                                                           (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 |= ((__INTERRUPT__) & UART_IT_MASK)): \
N                                                           ((__HANDLE__)->Instance->CR3 |= ((__INTERRUPT__) & UART_IT_MASK)))
X#define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 |= ((__INTERRUPT__) & UART_IT_MASK)):                                                            (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 |= ((__INTERRUPT__) & UART_IT_MASK)):                                                            ((__HANDLE__)->Instance->CR3 |= ((__INTERRUPT__) & UART_IT_MASK)))
N
N/** @brief  Disable the specified UART interrupt.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __INTERRUPT__ specifies the UART interrupt source to disable.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_CTS:  CTS change interrupt
N  *            @arg UART_IT_LBD:  LIN Break detection interrupt
N  *            @arg UART_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:   Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_PE:   Parity Error interrupt
N  *            @arg UART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 &= ~((__INTERRUPT__) & UART_IT_MASK)): \
N                                                           (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 &= ~((__INTERRUPT__) & UART_IT_MASK)): \
N                                                           ((__HANDLE__)->Instance->CR3 &= ~ ((__INTERRUPT__) & UART_IT_MASK)))
X#define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 &= ~((__INTERRUPT__) & UART_IT_MASK)):                                                            (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 &= ~((__INTERRUPT__) & UART_IT_MASK)):                                                            ((__HANDLE__)->Instance->CR3 &= ~ ((__INTERRUPT__) & UART_IT_MASK)))
N
N/** @brief  Checks whether the specified UART interrupt source is enabled or not.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __IT__ specifies the UART interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_CTS: CTS change interrupt (not available for UART4 and UART5)
N  *            @arg UART_IT_LBD: LIN Break detection interrupt
N  *            @arg UART_IT_TXE: Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:  Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_ERR: Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) (((((__IT__) >> 28U) == UART_CR1_REG_INDEX)? (__HANDLE__)->Instance->CR1:(((((uint32_t)(__IT__)) >> 28U) == UART_CR2_REG_INDEX)? \
N                                                       (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (((uint32_t)(__IT__)) & UART_IT_MASK))
X#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) (((((__IT__) >> 28U) == UART_CR1_REG_INDEX)? (__HANDLE__)->Instance->CR1:(((((uint32_t)(__IT__)) >> 28U) == UART_CR2_REG_INDEX)?                                                        (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (((uint32_t)(__IT__)) & UART_IT_MASK))
N
N/** @brief  Enable CTS flow control
N  * @note   This macro allows to enable CTS hardware flow control for a given UART instance,
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         The Handle Instance can be any USARTx (supporting the HW Flow control feature).
N  *         It is used to select the USART peripheral (USART availability and x value depending on device).
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)        \
N  do{                                                      \
N    ATOMIC_SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);  \
N    (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE;        \
N  } while(0U)
X#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)          do{                                                          ATOMIC_SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);      (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE;          } while(0U)
N
N/** @brief  Disable CTS flow control
N  * @note   This macro allows to disable CTS hardware flow control for a given UART instance,
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         The Handle Instance can be any USARTx (supporting the HW Flow control feature).
N  *         It is used to select the USART peripheral (USART availability and x value depending on device).
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)        \
N  do{                                                       \
N    ATOMIC_CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE); \
N    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE);      \
N  } while(0U)
X#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)          do{                                                           ATOMIC_CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);     (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE);        } while(0U)
N
N/** @brief  Enable RTS flow control
N  *         This macro allows to enable RTS hardware flow control for a given UART instance,
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         The Handle Instance can be any USARTx (supporting the HW Flow control feature).
N  *         It is used to select the USART peripheral (USART availability and x value depending on device).
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)       \
N  do{                                                     \
N    ATOMIC_SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE); \
N    (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE;       \
N  } while(0U)
X#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)         do{                                                         ATOMIC_SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);     (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE;         } while(0U)
N
N/** @brief  Disable RTS flow control
N  *         This macro allows to disable RTS hardware flow control for a given UART instance,
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         The Handle Instance can be any USARTx (supporting the HW Flow control feature).
N  *         It is used to select the USART peripheral (USART availability and x value depending on device).
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)       \
N  do{                                                      \
N    ATOMIC_CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);\
N    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE);     \
N  } while(0U)
X#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)         do{                                                          ATOMIC_CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE);       } while(0U)
N
N/** @brief  Macro to enable the UART's one bit sample method
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_ONE_BIT_SAMPLE_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3|= USART_CR3_ONEBIT)
N
N/** @brief  Macro to disable the UART's one bit sample method
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_ONE_BIT_SAMPLE_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3\
N                                                       &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT))
X#define __HAL_UART_ONE_BIT_SAMPLE_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3                                                       &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT))
N
N/** @brief  Enable UART
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_ENABLE(__HANDLE__)               ((__HANDLE__)->Instance->CR1 |=  USART_CR1_UE)
N
N/** @brief  Disable UART
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_DISABLE(__HANDLE__)              ((__HANDLE__)->Instance->CR1 &=  ~USART_CR1_UE)
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup UART_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N
N/* Initialization/de-initialization functions  **********************************/
NHAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength);
NHAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod);
NHAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart);
Nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart);
Nvoid HAL_UART_MspDeInit(UART_HandleTypeDef *huart);
N
N/* Callbacks Register/UnRegister functions  ***********************************/
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
X#if (1U == 1)
NHAL_StatusTypeDef HAL_UART_RegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID,
N                                            pUART_CallbackTypeDef pCallback);
NHAL_StatusTypeDef HAL_UART_UnRegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID);
N
NHAL_StatusTypeDef HAL_UART_RegisterRxEventCallback(UART_HandleTypeDef *huart, pUART_RxEventCallbackTypeDef pCallback);
NHAL_StatusTypeDef HAL_UART_UnRegisterRxEventCallback(UART_HandleTypeDef *huart);
N#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group2 IO operation functions
N  * @{
N  */
N
N/* IO operation functions *******************************************************/
NHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart);
N
NHAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen,
N                                           uint32_t Timeout);
NHAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
N
N/* Transfer Abort functions */
NHAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart);
N
Nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart);
Nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_ErrorCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart);
N
Nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size);
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral Control functions  ************************************************/
NHAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart);
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group4
N  * @{
N  */
N/* Peripheral State functions  **************************************************/
NHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart);
Nuint32_t              HAL_UART_GetError(UART_HandleTypeDef *huart);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup UART_Private_Constants UART Private Constants
N  * @{
N  */
N/** @brief UART interruptions flag mask
N  *
N  */
N#define UART_IT_MASK                     0x0000FFFFU
N
N#define UART_CR1_REG_INDEX               1U
N#define UART_CR2_REG_INDEX               2U
N#define UART_CR3_REG_INDEX               3U
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup UART_Private_Macros UART Private Macros
N  * @{
N  */
N#define IS_UART_WORD_LENGTH(LENGTH) (((LENGTH) == UART_WORDLENGTH_8B) || \
N                                     ((LENGTH) == UART_WORDLENGTH_9B))
X#define IS_UART_WORD_LENGTH(LENGTH) (((LENGTH) == UART_WORDLENGTH_8B) ||                                      ((LENGTH) == UART_WORDLENGTH_9B))
N#define IS_UART_LIN_WORD_LENGTH(LENGTH) (((LENGTH) == UART_WORDLENGTH_8B))
N#define IS_UART_STOPBITS(STOPBITS) (((STOPBITS) == UART_STOPBITS_1) || \
N                                    ((STOPBITS) == UART_STOPBITS_2))
X#define IS_UART_STOPBITS(STOPBITS) (((STOPBITS) == UART_STOPBITS_1) ||                                     ((STOPBITS) == UART_STOPBITS_2))
N#define IS_UART_PARITY(PARITY) (((PARITY) == UART_PARITY_NONE) || \
N                                ((PARITY) == UART_PARITY_EVEN) || \
N                                ((PARITY) == UART_PARITY_ODD))
X#define IS_UART_PARITY(PARITY) (((PARITY) == UART_PARITY_NONE) ||                                 ((PARITY) == UART_PARITY_EVEN) ||                                 ((PARITY) == UART_PARITY_ODD))
N#define IS_UART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == UART_HWCONTROL_NONE) || \
N                               ((CONTROL) == UART_HWCONTROL_RTS) || \
N                               ((CONTROL) == UART_HWCONTROL_CTS) || \
N                               ((CONTROL) == UART_HWCONTROL_RTS_CTS))
X#define IS_UART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == UART_HWCONTROL_NONE) ||                                ((CONTROL) == UART_HWCONTROL_RTS) ||                                ((CONTROL) == UART_HWCONTROL_CTS) ||                                ((CONTROL) == UART_HWCONTROL_RTS_CTS))
N#define IS_UART_MODE(MODE) ((((MODE) & 0x0000FFF3U) == 0x00U) && ((MODE) != 0x00U))
N#define IS_UART_STATE(STATE) (((STATE) == UART_STATE_DISABLE) || \
N                              ((STATE) == UART_STATE_ENABLE))
X#define IS_UART_STATE(STATE) (((STATE) == UART_STATE_DISABLE) ||                               ((STATE) == UART_STATE_ENABLE))
N#define IS_UART_OVERSAMPLING(SAMPLING) (((SAMPLING) == UART_OVERSAMPLING_16) || \
N                                        ((SAMPLING) == UART_OVERSAMPLING_8))
X#define IS_UART_OVERSAMPLING(SAMPLING) (((SAMPLING) == UART_OVERSAMPLING_16) ||                                         ((SAMPLING) == UART_OVERSAMPLING_8))
N#define IS_UART_LIN_OVERSAMPLING(SAMPLING) (((SAMPLING) == UART_OVERSAMPLING_16))
N#define IS_UART_LIN_BREAK_DETECT_LENGTH(LENGTH) (((LENGTH) == UART_LINBREAKDETECTLENGTH_10B) || \
N                                                 ((LENGTH) == UART_LINBREAKDETECTLENGTH_11B))
X#define IS_UART_LIN_BREAK_DETECT_LENGTH(LENGTH) (((LENGTH) == UART_LINBREAKDETECTLENGTH_10B) ||                                                  ((LENGTH) == UART_LINBREAKDETECTLENGTH_11B))
N#define IS_UART_WAKEUPMETHOD(WAKEUP) (((WAKEUP) == UART_WAKEUPMETHOD_IDLELINE) || \
N                                      ((WAKEUP) == UART_WAKEUPMETHOD_ADDRESSMARK))
X#define IS_UART_WAKEUPMETHOD(WAKEUP) (((WAKEUP) == UART_WAKEUPMETHOD_IDLELINE) ||                                       ((WAKEUP) == UART_WAKEUPMETHOD_ADDRESSMARK))
N#define IS_UART_BAUDRATE(BAUDRATE) ((BAUDRATE) <= 10500000U)
N#define IS_UART_ADDRESS(ADDRESS) ((ADDRESS) <= 0x0FU)
N
N#define UART_DIV_SAMPLING16(_PCLK_, _BAUD_)            ((uint32_t)((((uint64_t)(_PCLK_))*25U)/(4U*((uint64_t)(_BAUD_)))))
N#define UART_DIVMANT_SAMPLING16(_PCLK_, _BAUD_)        (UART_DIV_SAMPLING16((_PCLK_), (_BAUD_))/100U)
N#define UART_DIVFRAQ_SAMPLING16(_PCLK_, _BAUD_)        ((((UART_DIV_SAMPLING16((_PCLK_), (_BAUD_)) - (UART_DIVMANT_SAMPLING16((_PCLK_), (_BAUD_)) * 100U)) * 16U)\
N                                                         + 50U) / 100U)
X#define UART_DIVFRAQ_SAMPLING16(_PCLK_, _BAUD_)        ((((UART_DIV_SAMPLING16((_PCLK_), (_BAUD_)) - (UART_DIVMANT_SAMPLING16((_PCLK_), (_BAUD_)) * 100U)) * 16U)                                                         + 50U) / 100U)
N/* UART BRR = mantissa + overflow + fraction
N            = (UART DIVMANT << 4) + (UART DIVFRAQ & 0xF0) + (UART DIVFRAQ & 0x0FU) */
N#define UART_BRR_SAMPLING16(_PCLK_, _BAUD_)            ((UART_DIVMANT_SAMPLING16((_PCLK_), (_BAUD_)) << 4U) + \
N                                                        (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0xF0U) + \
N                                                        (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0x0FU))
X#define UART_BRR_SAMPLING16(_PCLK_, _BAUD_)            ((UART_DIVMANT_SAMPLING16((_PCLK_), (_BAUD_)) << 4U) +                                                         (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0xF0U) +                                                         (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0x0FU))
N
N#define UART_DIV_SAMPLING8(_PCLK_, _BAUD_)             ((uint32_t)((((uint64_t)(_PCLK_))*25U)/(2U*((uint64_t)(_BAUD_)))))
N#define UART_DIVMANT_SAMPLING8(_PCLK_, _BAUD_)         (UART_DIV_SAMPLING8((_PCLK_), (_BAUD_))/100U)
N#define UART_DIVFRAQ_SAMPLING8(_PCLK_, _BAUD_)         ((((UART_DIV_SAMPLING8((_PCLK_), (_BAUD_)) - (UART_DIVMANT_SAMPLING8((_PCLK_), (_BAUD_)) * 100U)) * 8U)\
N                                                         + 50U) / 100U)
X#define UART_DIVFRAQ_SAMPLING8(_PCLK_, _BAUD_)         ((((UART_DIV_SAMPLING8((_PCLK_), (_BAUD_)) - (UART_DIVMANT_SAMPLING8((_PCLK_), (_BAUD_)) * 100U)) * 8U)                                                         + 50U) / 100U)
N/* UART BRR = mantissa + overflow + fraction
N            = (UART DIVMANT << 4) + ((UART DIVFRAQ & 0xF8) << 1) + (UART DIVFRAQ & 0x07U) */
N#define UART_BRR_SAMPLING8(_PCLK_, _BAUD_)             ((UART_DIVMANT_SAMPLING8((_PCLK_), (_BAUD_)) << 4U) + \
N                                                        ((UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0xF8U) << 1U) + \
N                                                        (UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0x07U))
X#define UART_BRR_SAMPLING8(_PCLK_, _BAUD_)             ((UART_DIVMANT_SAMPLING8((_PCLK_), (_BAUD_)) << 4U) +                                                         ((UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0xF8U) << 1U) +                                                         (UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0x07U))
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup UART_Private_Functions UART Private Functions
N  * @{
N  */
N
NHAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_UART_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 408 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_UART_MODULE_ENABLED */
N
N#ifdef HAL_USART_MODULE_ENABLED
S #include "stm32f4xx_hal_usart.h"
N#endif /* HAL_USART_MODULE_ENABLED */
N
N#ifdef HAL_IRDA_MODULE_ENABLED
S #include "stm32f4xx_hal_irda.h"
N#endif /* HAL_IRDA_MODULE_ENABLED */
N
N#ifdef HAL_SMARTCARD_MODULE_ENABLED
S #include "stm32f4xx_hal_smartcard.h"
N#endif /* HAL_SMARTCARD_MODULE_ENABLED */
N
N#ifdef HAL_WWDG_MODULE_ENABLED
S #include "stm32f4xx_hal_wwdg.h"
N#endif /* HAL_WWDG_MODULE_ENABLED */
N
N#ifdef HAL_PCD_MODULE_ENABLED
S #include "stm32f4xx_hal_pcd.h"
N#endif /* HAL_PCD_MODULE_ENABLED */
N
N#ifdef HAL_HCD_MODULE_ENABLED
S #include "stm32f4xx_hal_hcd.h"
N#endif /* HAL_HCD_MODULE_ENABLED */
N
N#ifdef HAL_DSI_MODULE_ENABLED
S #include "stm32f4xx_hal_dsi.h"
N#endif /* HAL_DSI_MODULE_ENABLED */
N
N#ifdef HAL_QSPI_MODULE_ENABLED
S #include "stm32f4xx_hal_qspi.h"
N#endif /* HAL_QSPI_MODULE_ENABLED */
N
N#ifdef HAL_CEC_MODULE_ENABLED
S #include "stm32f4xx_hal_cec.h"
N#endif /* HAL_CEC_MODULE_ENABLED */
N
N#ifdef HAL_FMPI2C_MODULE_ENABLED
S #include "stm32f4xx_hal_fmpi2c.h"
N#endif /* HAL_FMPI2C_MODULE_ENABLED */
N
N#ifdef HAL_FMPSMBUS_MODULE_ENABLED
S #include "stm32f4xx_hal_fmpsmbus.h"
N#endif /* HAL_FMPSMBUS_MODULE_ENABLED */
N
N#ifdef HAL_SPDIFRX_MODULE_ENABLED
S #include "stm32f4xx_hal_spdifrx.h"
N#endif /* HAL_SPDIFRX_MODULE_ENABLED */
N
N#ifdef HAL_DFSDM_MODULE_ENABLED
S #include "stm32f4xx_hal_dfsdm.h"
N#endif /* HAL_DFSDM_MODULE_ENABLED */
N
N#ifdef HAL_LPTIM_MODULE_ENABLED
S #include "stm32f4xx_hal_lptim.h"
N#endif /* HAL_LPTIM_MODULE_ENABLED */
N
N#ifdef HAL_MMC_MODULE_ENABLED
S #include "stm32f4xx_hal_mmc.h"
N#endif /* HAL_MMC_MODULE_ENABLED */
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr If expr is false, it calls assert_failed function
S  *         which reports the name of the source file and the source
S  *         line number of the call that failed.
S  *         If expr is true, it returns no value.
S  * @retval None
S  */
S  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0U)
N#endif /* USE_FULL_ASSERT */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_CONF_H */
L 31 "D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal.h" 2
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup HAL
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup HAL_Exported_Constants HAL Exported Constants
N  * @{
N  */
N
N/** @defgroup HAL_TICK_FREQ Tick Frequency
N  * @{
N  */
Ntypedef enum
N{
N  HAL_TICK_FREQ_10HZ         = 100U,
N  HAL_TICK_FREQ_100HZ        = 10U,
N  HAL_TICK_FREQ_1KHZ         = 1U,
N  HAL_TICK_FREQ_DEFAULT      = HAL_TICK_FREQ_1KHZ
N} HAL_TickFreqTypeDef;
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N   
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup HAL_Exported_Macros HAL Exported Macros
N  * @{
N  */
N
N/** @brief  Freeze/Unfreeze Peripherals in Debug mode 
N  */
N#define __HAL_DBGMCU_FREEZE_TIM2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM2_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM3()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM3_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM4()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM4_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM5()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM5_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM6()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM6_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM7()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM7_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM12()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM12_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM13()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM13_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM14()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM14_STOP))
N#define __HAL_DBGMCU_FREEZE_RTC()            (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_RTC_STOP))
N#define __HAL_DBGMCU_FREEZE_WWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_WWDG_STOP))
N#define __HAL_DBGMCU_FREEZE_IWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_IWDG_STOP))
N#define __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_I2C2_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_I2C3_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_CAN1()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN1_STOP))
N#define __HAL_DBGMCU_FREEZE_CAN2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN2_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM1()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM1_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM8()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM8_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM9()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM9_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM10()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM10_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM11()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM11_STOP))
N
N#define __HAL_DBGMCU_UNFREEZE_TIM2()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM2_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM3()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM3_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM4()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM4_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM5()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM5_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM6()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM6_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM7()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM7_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM12()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM12_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM13()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM13_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM14()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM14_STOP))
N#define __HAL_DBGMCU_UNFREEZE_RTC()            (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_RTC_STOP))
N#define __HAL_DBGMCU_UNFREEZE_WWDG()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_WWDG_STOP))
N#define __HAL_DBGMCU_UNFREEZE_IWDG()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_IWDG_STOP))
N#define __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_CAN1()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN1_STOP))
N#define __HAL_DBGMCU_UNFREEZE_CAN2()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN2_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM1()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM1_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM8()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM8_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM9()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM9_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM10()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM10_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM11()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM11_STOP))
N
N/** @brief  Main Flash memory mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_FLASH()             (SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE))
N
N/** @brief  System Flash memory mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
N                                                         SYSCFG->MEMRMP |= SYSCFG_MEMRMP_MEM_MODE_0;\
N                                                        }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                         SYSCFG->MEMRMP |= SYSCFG_MEMRMP_MEM_MODE_0;                                                        }while(0);
N
N/** @brief  Embedded SRAM mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_SRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
N                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_0 | SYSCFG_MEMRMP_MEM_MODE_1);\
N                                                 }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_SRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_0 | SYSCFG_MEMRMP_MEM_MODE_1);                                                 }while(0);
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)
X#if 0L || 0L || 1L|| 0L
N/** @brief  FSMC Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_FSMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
N                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);\
N                                                 }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FSMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);                                                 }while(0);
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
S/** @brief  FMC Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                 SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);\
S                                                }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                 SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);                                                }while(0);
S
S/** @brief  FMC/SDRAM Bank 1 and 2 mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                       SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_2);\
S                                                      }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                       SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_2);                                                      }while(0);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */ 
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L
S/** @defgroup Cortex_Lockup_Enable Cortex Lockup Enable
S  * @{
S  */
S/** @brief  SYSCFG Break Lockup lock
S  *         Enables and locks the connection of Cortex-M4 LOCKUP (Hardfault) output to TIM1/8 input
S  * @note   The selected configuration is locked and can be unlocked by system reset
S  */
S#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK); \
S                                               SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;    \
S                                              }while(0)
X#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK);                                                SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;                                                  }while(0)
S/**
S * @}
S */
S
S/** @defgroup PVD_Lock_Enable PVD Lock
S  * @{
S  */
S/** @brief  SYSCFG Break PVD lock
S  *         Enables and locks the PVD connection with Timer1/8 Break Input, , as well as the PVDE and PLS[2:0] in the PWR_CR register
S  * @note   The selected configuration is locked and can be unlocked by system reset
S  */
S#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()     do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK); \
S                                                 SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;    \
S                                                }while(0)
X#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()     do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK);                                                  SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;                                                    }while(0)
S/**
S * @}
S */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx || STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_Private_Macros HAL Private Macros
N  * @{
N  */
N#define IS_TICKFREQ(FREQ) (((FREQ) == HAL_TICK_FREQ_10HZ)  || \
N                           ((FREQ) == HAL_TICK_FREQ_100HZ) || \
N                           ((FREQ) == HAL_TICK_FREQ_1KHZ))
X#define IS_TICKFREQ(FREQ) (((FREQ) == HAL_TICK_FREQ_10HZ)  ||                            ((FREQ) == HAL_TICK_FREQ_100HZ) ||                            ((FREQ) == HAL_TICK_FREQ_1KHZ))
N/**
N  * @}
N  */
N
N/* Exported variables --------------------------------------------------------*/
N
N/** @addtogroup HAL_Exported_Variables
N  * @{
N  */
Nextern __IO uint32_t uwTick;
Xextern volatile uint32_t uwTick;
Nextern uint32_t uwTickPrio;
Nextern HAL_TickFreqTypeDef uwTickFreq;
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup HAL_Exported_Functions
N  * @{
N  */
N/** @addtogroup HAL_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and Configuration functions  ******************************/
NHAL_StatusTypeDef HAL_Init(void);
NHAL_StatusTypeDef HAL_DeInit(void);
Nvoid HAL_MspInit(void);
Nvoid HAL_MspDeInit(void);
NHAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority);
N/**
N  * @}
N  */
N
N/** @addtogroup HAL_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions  ************************************************/
Nvoid HAL_IncTick(void);
Nvoid HAL_Delay(uint32_t Delay);
Nuint32_t HAL_GetTick(void);
Nuint32_t HAL_GetTickPrio(void);
NHAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq);
NHAL_TickFreqTypeDef HAL_GetTickFreq(void);
Nvoid HAL_SuspendTick(void);
Nvoid HAL_ResumeTick(void);
Nuint32_t HAL_GetHalVersion(void);
Nuint32_t HAL_GetREVID(void);
Nuint32_t HAL_GetDEVID(void);
Nvoid HAL_DBGMCU_EnableDBGSleepMode(void);
Nvoid HAL_DBGMCU_DisableDBGSleepMode(void);
Nvoid HAL_DBGMCU_EnableDBGStopMode(void);
Nvoid HAL_DBGMCU_DisableDBGStopMode(void);
Nvoid HAL_DBGMCU_EnableDBGStandbyMode(void);
Nvoid HAL_DBGMCU_DisableDBGStandbyMode(void);
Nvoid HAL_EnableCompensationCell(void);
Nvoid HAL_DisableCompensationCell(void);
Nuint32_t HAL_GetUIDw0(void);
Nuint32_t HAL_GetUIDw1(void);
Nuint32_t HAL_GetUIDw2(void);
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
Svoid HAL_EnableMemorySwappingBank(void);
Svoid HAL_DisableMemorySwappingBank(void);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */ 
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup HAL_Private_Variables HAL Private Variables
N  * @{
N  */
N/**
N  * @}
N  */
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup HAL_Private_Constants HAL Private Constants
N  * @{
N  */
N/**
N  * @}
N  */
N/* Private macros ------------------------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 31 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\main.h" 2
N
N/* Private includes ----------------------------------------------------------*/
N/* USER CODE BEGIN Includes */
N#include "SPIDriver.h"
L 1 ".\etherCAT\SPIDriver.h" 1
N/*******************************************************************************
N PIC32 SPI Interface Driver
N
N  Company:
N    Microchip Technology Inc.
N
N  File Name:
N    SPIDriver.h
N
N  Summary:
N    Contains the Header File of PIC32 SPI Interface Driver
N
N  Description:
N    This file contains the Header File of PIC32 SPI Interface Driver
N	
N  Change History:
N    Version		Changes
N	1.3			Initial version.
N
N*******************************************************************************/
N
N// DOM-IGNORE-BEGIN
N/*******************************************************************************
N Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
N
N Microchip licenses to you the right to use, modify, copy and distribute
N Software only when embedded on a Microchip microcontroller or digital signal
N controller that is integrated into your product or third party product
N (pursuant to the sublicense terms in the accompanying license agreement).
N
N You should refer to the license agreement accompanying this Software for
N additional information regarding your rights and obligations.
N
N SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
N EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
N MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
N IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
N CONTRACT, NEGLiPMPCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
N OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
N INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
N CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
N SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
N (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
N *******************************************************************************/
N// DOM-IGNORE-END
N
N// *****************************************************************************
N// *****************************************************************************
N// Section: Included Files
N// *****************************************************************************
N// *****************************************************************************
N
N
N#ifndef SPIDRIVER_H
N#define	SPIDRIVER_H
N
N#include "ecat_def.h"
L 1 ".\etherCAT\ecat_def.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N*/
N
N
N/*-----------------------------------------------------------------------------------------
N------	
N------	ecat_def.h
N------  SSC version : 5.13
N-----------------------------------------------------------------------------------------*/
N
N#ifndef _ECATDEF_H_
N#define _ECATDEF_H_
N
N/*-----------------------------------------------------------------------------------------
N------	
N------	Includes
N------ 
N-----------------------------------------------------------------------------------------*/
N#include <stdlib.h>
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060009
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 22 ".\etherCAT\ecat_def.h" 2
N#include <string.h>
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060009
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 23 ".\etherCAT\ecat_def.h" 2
N
N/*-----------------------------------------------------------------------------------------
N------	
N------	Slave Sample Code Configuration Defines
N------	
N-----------------------------------------------------------------------------------------*/
N#define SSC_VERSION_MAJOR 5
N#define SSC_VERSION_MINOR 13
N
N
N/** 
NEL9800_HW: Shall be set if the Slave code is executed on the PIC mounted on the EL9800 EtherCAT Evaluation Board.<br>
N(if the MCI interface provided by EL9800 board should be used MCI_HW shall be set and this define shall be reset).<br>
NThis settings should also be enabled if the ESC is connected via a serial interface and no specific hardware access files are avilable yet.<br>
NNOTE: The PDI type needs also to be configured in the "ESC_CONFIG_DATA". */
N#ifndef EL9800_HW
N#define EL9800_HW                                 0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NMCI_HW: Shall be set if the MCI of the ESC is connected.<br>
NThis settings should also be enabled if the ESC is connected via a parallel interface and no specific hardware access files are avilable yet.<br>
NNOTE: The PDI type needs also to be configured in the "ESC_CONFIG_DATA". */
N#ifndef MCI_HW
N#define MCI_HW                                    0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NFC1100_HW: Shall be set if the EtherCAT slave controller is located on an FC1100 PCI card.<br>
NNOTE: The PDI type needs also to be configured in the "ESC_CONFIG_DATA". */
N#ifndef FC1100_HW
N#define FC1100_HW                                 0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NTIESC_HW: Temporary define to support TI ICE/IDK development board (Shall be set if the Slave code shall executed on an AM335X ICE/IDK Evaluation Board<br>
Nfrom Texas Instruments) */
N#ifndef TIESC_HW
N#define TIESC_HW                                  0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NCONTROLLER_16BIT: Shall be set if the host controller is a 16Bit architecture */
N#ifndef CONTROLLER_16BIT
N#define CONTROLLER_16BIT                          0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NCONTROLLER_32BIT: Shall be set if the host controller is a 32Bit architecture */
N#ifndef CONTROLLER_32BIT
N#define CONTROLLER_32BIT                          1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NMEMORY_UNIT_16BIT: Shall be set if the smallest controller memory unit is 16bit */
N#ifndef MEMORY_UNIT_16BIT
N#define MEMORY_UNIT_16BIT                         0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
N_PIC18: Microchip PIC18F452 Specific Code <br>
NThis processor is mounted on the Beckhoff Slave Evaluation Board (Hardware version up to EL9800_2). */
N#ifndef _PIC18
N#define _PIC18                                    0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
N_PIC24: Microchip PIC24HJ128GP306 Specific Code <br>
NThis processor is mounted on the Beckhoff Slave Evaluation Board (Hardware version up to EL9800_4A). */
N#ifndef _PIC24
N#define _PIC24                                    0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NESC_16BIT_ACCESS: If the microcontroller only supports 16Bit access to the ESC. */
N#ifndef ESC_16BIT_ACCESS
N#define ESC_16BIT_ACCESS                          1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NESC_32BIT_ACCESS: If the microcontroller only supports 32Bit access to the ESC. */
N#ifndef ESC_32BIT_ACCESS
N#define ESC_32BIT_ACCESS                          0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NMBX_16BIT_ACCESS: If the microcontroller only supports 16Bit access to local mailbox memory(access to ESC DPRAM is controlled by "ESC_16BIT_ACCESS"). If reset 8Bit access is used. */
N#ifndef MBX_16BIT_ACCESS
N#define MBX_16BIT_ACCESS                          1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NBIG_ENDIAN_16BIT: If the microcontroller always make 16 bit access to external memory, operates in BigEndian format<br>
Nand the switching of the high and low byte is done in hardware. */
N#ifndef BIG_ENDIAN_16BIT
N#define BIG_ENDIAN_16BIT                          0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NBIG_ENDIAN_FORMAT: If the microcontroller works with BigEndian format, then this switch shall be set. In that case all WORD-<br>
Nand DWORD-accesses will make a BYTE- or WORD-swapping, the macros SWAPWORD and SWAPDWORD in ecatslv.h might be adapted. <br>
NIf this switch is set, then BIG_ENDIAN_16BIT shall be reset. */
N#ifndef BIG_ENDIAN_FORMAT
N#define BIG_ENDIAN_FORMAT                         0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NEXT_DEBUGER_INTERFACE: If this switch is set, the external debugger interface on the EL9800_4A (_PIC24) will be activated.<br>
NThis define will be ignored if _PIC24 is not set. */
N#ifndef EXT_DEBUGER_INTERFACE
N#define EXT_DEBUGER_INTERFACE                     0
N#endif
N
N/** 
NUC_SET_ECAT_LED: If set the EtherCAT Run and Error LEDs are set by the uController. If set ESC_SUPPORT_ECAT_LED shall be reset. */
N#ifndef UC_SET_ECAT_LED
N#define UC_SET_ECAT_LED                           0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NESC_SUPPORT_ECAT_LED: This switch can be enabled if the connected ESC support Error and Run LED indication. See the ESC datasheet if the LED indication is supported. If set UC_SET_ECAT_LED shall be reset. */
N#ifndef ESC_SUPPORT_ECAT_LED
N#define ESC_SUPPORT_ECAT_LED                      1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NESC_EEPROM_EMULATION: If this switch is set EEPROM emulation is supported. Not all ESC types support EEPROM emulation. See ESC datasheet for more information. */
N#ifndef ESC_EEPROM_EMULATION
N#define ESC_EEPROM_EMULATION                      0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NESC_EEPROM_SIZE: Specify the EEPROM size in Bytes of the connected EEPROM or the emulated EEPROM. */
N#ifndef ESC_EEPROM_SIZE
N#define ESC_EEPROM_SIZE                           0x800
N#endif
N
N/** 
NEEPROM_WRITE_SIZE: Only required if EEPROM emulation is active. This value defines the number of bytes which will be written per opertion. */
N#ifndef EEPROM_WRITE_SIZE
N#define EEPROM_WRITE_SIZE                         0x2
N#endif
N
N/** 
NAL_EVENT_ENABLED: If an interrupt routine shall be called when one of the Events in the AL Event Register (0x220) changes, <br>
Nthis switch has to be defined to 1 (synchronous modes are supported). <br>
NIf the AL Event register shall only be polled, this switch has to be defined to 0 (only free run mode is supported). */
N#ifndef AL_EVENT_ENABLED
N#define AL_EVENT_ENABLED                          1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NDC_SUPPORTED: If distributed clocks should be supported by the slave, this switch shall be set.<br>
NNOTE: The DC support needs also be set in the "ESC_CONFIG_DATA" settings. */
N#ifndef DC_SUPPORTED
N#define DC_SUPPORTED                              1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NECAT_TIMER_INT: If this switch is set, then the watchdog time for the EtherCAT watchdog will be checked in a timer interrupt routine. */
N#ifndef ECAT_TIMER_INT
N#define ECAT_TIMER_INT                            0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NINTERRUPTS_SUPPORTED: If this switch is set the slave stack provides interrupt handling.<br>
NNOTE: value will be evaluated automatically!! */
N#ifndef INTERRUPTS_SUPPORTED
N#define INTERRUPTS_SUPPORTED                      1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NTEST_APPLICATION: NOTE: THIS SETTING SHALL NOT BE USED TO CREATE A USER SPECIFIC APPLICATION!<br>
NSelect this setting to test the slave stack or a master implementation. For further information about this application see the SSC Application Node. */
N#ifndef TEST_APPLICATION
N#define TEST_APPLICATION                          0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NTEST_APPLICATION_REDUCED_MEMORY: This define reduces the memory footprint of the test application (should only be used if the default test application generates no memory errors when accessing the OD or FoE files) */
N#ifndef TEST_APPLICATION_REDUCED_MEMORY
N#define TEST_APPLICATION_REDUCED_MEMORY           0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NEL9800_APPLICATION: Should be set if the Slave Sample Code runs on an EL9800_x Evaluation Board. */
N#ifndef EL9800_APPLICATION
N#define EL9800_APPLICATION                        0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NCiA402_SAMPLE_APPLICATION: If this switch is set, then the sample implementation of CiA402 device profile will be activated. */
N#ifndef CiA402_SAMPLE_APPLICATION
N#define CiA402_SAMPLE_APPLICATION                 0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NSAMPLE_APPLICATION: Select this define if the hardware independent sample application shall be activated. */
N#ifndef SAMPLE_APPLICATION
N#define SAMPLE_APPLICATION                        0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NSAMPLE_APPLICATION_INTERFACE: Select this define to activate the Sample Application Interface. This provides an simple interface to create a static library and used in an external application.<br>
NNOTE: The file "EtherCATSampleLibrary.h" includes the library interface (maybe need to be adapted).  */
N#ifndef SAMPLE_APPLICATION_INTERFACE
N#define SAMPLE_APPLICATION_INTERFACE              0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NBOOTLOADER_SAMPLE: Select this define to enable a small footprint application which only supports the BOOT state and FoE mailbox protocol. */
N#ifndef BOOTLOADER_SAMPLE
N#define BOOTLOADER_SAMPLE                         0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NUSE_DEFAULT_MAIN: Set to 1 if the main function of a default application shall be used.<br>
NOtherwise the Init functions and the mainloop handler shall be called for a user specific function (see ET9300 Application Note for further details https://www.beckhoff.com/de-de/support/downloadfinder/technische-dokumentationen/?q=ET1100). */
N#ifndef USE_DEFAULT_MAIN
N#define USE_DEFAULT_MAIN                          0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NMAILBOX_QUEUE: If this switch is set, the mailbox services will be stored in a queue.<br>
NWith this switch reset only one mailbox service can be processed in parallel. */
N#ifndef MAILBOX_QUEUE
N#define MAILBOX_QUEUE                             1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NAOE_SUPPORTED: If the AoE services are supported, then this switch shall be set. */
N#ifndef AOE_SUPPORTED
N#define AOE_SUPPORTED                             0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NCOE_SUPPORTED: If the CoE services are supported, then his switch shall be set. */
N#ifndef COE_SUPPORTED
N#define COE_SUPPORTED                             1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NCOMPLETE_ACCESS_SUPPORTED: If the complete SDO access (accessing all entries of an object with one SDO service, then this<br>
Nswitch shall be set. Furthermore,COE_SUPPORTED shall be set. */
N#ifndef COMPLETE_ACCESS_SUPPORTED
N#define COMPLETE_ACCESS_SUPPORTED                 1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NSEGMENTED_SDO_SUPPORTED: If the segmented SDO services should be supported, then this switch shall be set.<br>
NFurthermore, COE_SUPPORTED shall be set. */
N#ifndef SEGMENTED_SDO_SUPPORTED
N#define SEGMENTED_SDO_SUPPORTED                   1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NSDO_RES_INTERFACE: If a SDO response cannot be generated immediately (e.g. when access over<br>
Na serial interface is needed), this switch should be set. In that case ABORTIDX_WORKING shall be<br>
Nreturned from OBJ_Read or OBJ_Write and the response shall be sent by calling SDOS_SdoRes, when<br>
Nthe response is available. */
N#ifndef SDO_RES_INTERFACE
N#define SDO_RES_INTERFACE                         1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NUSE_SINGLE_PDO_MAPPING_ENTRY_DESCR: If this setting is set a PDO mapping entry description just need to be defined for the first entry. For all furher entries the same description is used. */
N#ifndef USE_SINGLE_PDO_MAPPING_ENTRY_DESCR
N#define USE_SINGLE_PDO_MAPPING_ENTRY_DESCR        0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NBACKUP_PARAMETER_SUPPORTED: If this switch is set, then the functions in the application example to load and<br>
Nstore backup parameter will be compiled. Furthermore, COE_SUPPORTED shall be set. */
N#ifndef BACKUP_PARAMETER_SUPPORTED
N#define BACKUP_PARAMETER_SUPPORTED                0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NSTORE_BACKUP_PARAMETER_IMMEDIATELY: Objet values will be stored when they are written.This switch is only evaluated if "BACKUP_PARAMETER_SUPPORTED" is set. */
N#ifndef STORE_BACKUP_PARAMETER_IMMEDIATELY
N#define STORE_BACKUP_PARAMETER_IMMEDIATELY        0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NDIAGNOSIS_SUPPORTED: If this define is set the slave stack supports diagnosis messages (Object 0x10F3). <br>
NTo support diagnosis messages COE_SUPPORTED shall be enabled and the platform shall support dynamic memory allocation.<br>
NNOTE: this feature is implemented according to ETG.1020 */
N#ifndef DIAGNOSIS_SUPPORTED
N#define DIAGNOSIS_SUPPORTED                       0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NEMERGENCY_SUPPORTED: If this define is set the slave stack supports emergency messages. COE_SUPPORTED or SOE_SUPPORTED shall be enabled */
N#ifndef EMERGENCY_SUPPORTED
N#define EMERGENCY_SUPPORTED                       1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NVOE_SUPPORTED: If the VoE services should be supported, then this switch shall be set. This means only the calling of the <br>
NVoE functions in mailbox.c are implemented, but the VoE service functions have to be added. Furthermore, the example code cannot be linked<br>
Ncorrectly, because these functions are missing. */
N#ifndef VOE_SUPPORTED
N#define VOE_SUPPORTED                             0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NSOE_SUPPORTED: If the SoE services should be supported, then this switch shall be set. This means only the calling of the <br>
NSoE functions in mailbox.c are implemented, but the SoE service functions have to be added. Furthermore, the example code cannot be linked<br>
Ncorrectly, because these functions are missing. */
N#ifndef SOE_SUPPORTED
N#define SOE_SUPPORTED                             0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NEOE_SUPPORTED: If the EoE services should be supported, then this switch shall be set. */
N#ifndef EOE_SUPPORTED
N#define EOE_SUPPORTED                             0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NSTATIC_ETHERNET_BUFFER: If this switch is set a static buffer is used to store ethernet frames, otherwise the buffer is allocated on demand */
N#ifndef STATIC_ETHERNET_BUFFER
N#define STATIC_ETHERNET_BUFFER                    0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NFOE_SUPPORTED: If the FoE services should be supported, then this switch shall be set.  */
N#ifndef FOE_SUPPORTED
N#define FOE_SUPPORTED                             1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NMAILBOX_SUPPORTED: This switch is set automatically if at least one mailbox protocol is enabled. */
N#ifndef MAILBOX_SUPPORTED
N#define MAILBOX_SUPPORTED                         1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NBOOTSTRAPMODE_SUPPORTED: If the firmware update over FoE services should be supported, then this switch shall be set.<br>
NIf this switch is set, then also "FOE_SUPPORTED" shall be set.  */
N#ifndef BOOTSTRAPMODE_SUPPORTED
N#define BOOTSTRAPMODE_SUPPORTED                   1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NOP_PD_REQUIRED: If this switch is reset the state transition SAFEOP_2_OP will also successful if no process data was received. The watchdog will only be active when first process data was received (bEcatFirstOutputsReceived) */
N#ifndef OP_PD_REQUIRED
N#define OP_PD_REQUIRED                            1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NPREOPTIMEOUT: Specify timeout value in ms for the state transition from Init to PreOP/Boot.(ESI Value : "PreopTimeout").<br>
NNOTE: Within the stack this value - 50ms will be used to react before the master run into the timeout. */
N#ifndef PREOPTIMEOUT
N#define PREOPTIMEOUT                              0x7D0
N#endif
N
N/** 
NSAFEOP2OPTIMEOUT: Specifiy the timeout in ms from SafeOP to OP. (ESI Value : "SafeopOpTimeout")<br>
NNOTE: Within the stack this value - 50ms will be used to react before the master run into the timeout. */
N#ifndef SAFEOP2OPTIMEOUT
N#define SAFEOP2OPTIMEOUT                          0x2328
N#endif
N
N/** 
NCHECK_SM_PARAM_ALIGNMENT: If true the SyncManager length and start address will be checked according the ESC Access.<br>
Ne.g. ESC_32BIT_ACCESS is set the length and address shall be to an even 4Byte address. */
N#ifndef CHECK_SM_PARAM_ALIGNMENT
N#define CHECK_SM_PARAM_ALIGNMENT                  0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NEXPLICIT_DEVICE_ID: If this switch is set Explicit device ID requests are handled. For further information about Explicit Device ID see ETG.1020 specification: www.ethercat.org/MemberArea/download_protocolenhancements.asp */
N#ifndef EXPLICIT_DEVICE_ID
N#define EXPLICIT_DEVICE_ID                        1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NESC_SM_WD_SUPPORTED: This switch should be set if the SyncManger watchdog provided by the ESC should be used. If reset the process data watchdog is triggered by a local timer */
N#ifndef ESC_SM_WD_SUPPORTED
N#define ESC_SM_WD_SUPPORTED                       1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NSTATIC_OBJECT_DIC: If this switch is set, the object dictionary is "build" static (by default only PIC18 objects are added static) */
N#ifndef STATIC_OBJECT_DIC
N#define STATIC_OBJECT_DIC                         0 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NESC_EEPROM_ACCESS_SUPPORT: If this switch is set the slave stack provides functions to access the EEPROM. */
N#ifndef ESC_EEPROM_ACCESS_SUPPORT
N#define ESC_EEPROM_ACCESS_SUPPORT                 1 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N
N/*-----------------------------------------------------------------------------------------
N------	
N------	Compiler Defines
N------	
N-----------------------------------------------------------------------------------------*/
N
N/** 
NFALSE: Will be used for variables from type BOOL */
N#ifndef FALSE
N#define FALSE                                     0
N#endif
N
N/** 
NTRUE: Will be used for variables from type BOOL  */
N#ifndef TRUE
N#define TRUE                                      1
N#endif
N
N/** 
NBOOL: Should be adapted to the boolean type of the microcontroller */
N#ifndef BOOL
N#define BOOL                                      unsigned char
N#endif
N
N/** 
NUINT8: Should be adapted to the unsigned8 type of the microcontroller  */
N#ifndef UINT8
N#define UINT8                                     unsigned char
N#endif
N
N/** 
NUINT16: Should be adapted to the unsigned16 type of the microcontroller  */
N#ifndef UINT16
N#define UINT16                                    unsigned short
N#endif
N
N/** 
NUINT32: Should be adapted to the unsigned32 type of the microcontroller  */
N#ifndef UINT32
N#define UINT32                                    unsigned int
N#endif
N
N/** 
NUINT64: Should be adapted to the unsigned64 type of the microcontroller  */
N#ifndef UINT64
N#define UINT64                                    unsigned long long
N#endif
N
N/** 
NUSHORT: Should be adapted to the unsigned16 type of the microcontroller */
N#ifndef USHORT
N#define USHORT                                    unsigned short
N#endif
N
N/** 
NINT8: Should be adapted to the integer8 type of the microcontroller */
N#ifndef INT8
N#define INT8                                      char
N#endif
N
N/** 
NINT16: Should be adapted to the integer16 type of the microcontroller  */
N#ifndef INT16
N#define INT16                                     short
N#endif
N
N/** 
NINT32: Should be adapted to the integer32 type of the microcontroller */
N#ifndef INT32
N#define INT32                                     int
N#endif
N
N/** 
NINT64: Should be adapted to the integer64 type of the microcontroller */
N#ifndef INT64
N#define INT64                                     long long
N#endif
N
N/** 
NCHAR: Should be adapted to the character type of the microcontroller */
N#ifndef CHAR
N#define CHAR                                      char
N#endif
N
N/** 
NUCHAR: Should be adapted to the unsigned character type of the microcontroller */
N#ifndef UCHAR
N#define UCHAR                                     unsigned char
N#endif
N
N/** 
NREAL32: Should be adapted to the 32bit real type of the microcontroller */
N#ifndef REAL32
N#define REAL32                                    float
N#endif
N
N/** 
NREAL64: Should be adapted to the 64bit real type of the microcontroller */
N#ifndef REAL64
N#define REAL64                                    double
N#endif
N
N/** 
NSIZEOF(x): Used to calculate the size in Bytes */
N#ifndef SIZEOF
N#define SIZEOF(x)                                 sizeof(x)
N#endif
N
N/** 
NHUGE: Should be adapted to the huge type of the microcontroller, if the microcontroller<br>
Ndoes not support a huge type, HUGE shall be defined to nothing */
N#ifndef HUGE
N#define HUGE 
N#endif
N
N/** 
NHMEMSET: Should be defined to the memset function for huge memory, if the microcontroller<br>
Ndoes not support a huge type, HMEMSET shall be defined to a 'normal' memset function */
N#ifndef HMEMSET
N#define HMEMSET                                   memset
N#endif
N
N/** 
NHMEMCPY: Should be defined to the memcpy function for huge memory, if the microcontroller<br>
Ndoes not support a huge type, HMEMCPY shall be defined to a 'normal' memcpy function */
N#ifndef HMEMCPY
N#define HMEMCPY                                   memcpy
N#endif
N
N/** 
NHMEMCMP: Should be defined to the memcmp function for huge memory, if the microcontroller<br>
Ndoes not support a huge type, HMEMCMP shall be defined to a 'normal' memcmp function */
N#ifndef HMEMCMP
N#define HMEMCMP                                   memcmp
N#endif
N
N/** 
NESCMEM: Should be defined to select the memory type of the ESC memory (e.g. near, far or huge), if the microcontroller<br>
Ndoes not support different memory types, ESCMEM shall be defined to nothing */
N#ifndef ESCMEM
N#define ESCMEM 
N#endif
N
N/** 
NESCMEMCPY: Should be defined to the memcpy function for ESCMEM memory, if the microcontroller<br>
Ndoes not support different memory types, ESCMEMCPY shall be defined to a 'normal' memcpy function */
N#ifndef ESCMEMCPY
N#define ESCMEMCPY                                 memcpy
N#endif
N
N/** 
NESCMEMSET: Should be defined to the memset function for ESCMEM memory, if the microcontroller<br>
Ndoes not support different memory types, ESCMEMSET shall be defined to a 'normal' memset function */
N#ifndef ESCMEMSET
N#define ESCMEMSET                                 memset
N#endif
N
N/** 
NESCMBXMEMCPY: Should be defined to the memcpy function for copying ESCMEM memory to or from MBXMEM memory, if the microcontroller<br>
Ndoes not support different memory types, ESCMBXMEMCPY shall be defined to a 'normal' memcpy function */
N#ifndef ESCMBXMEMCPY
N#define ESCMBXMEMCPY                              memcpy
N#endif
N
N/** 
NMBXMEM: Should be defined to select the memory type of the memory used for mailbox communication (e.g. near, far or huge), <br>
Nif the microcontroller does not support different memory types, MBXMEM shall be defined to nothing */
N#ifndef MBXMEM
N#define MBXMEM 
N#endif
N
N/** 
NMBXMEMCPY: Should be defined to the memcpy function for MBXMEM memory, if the microcontroller<br>
Ndoes not support different memory types, MBXMEMCPY shall be defined to a 'normal' memcpy function */
N#ifndef MBXMEMCPY
N#define MBXMEMCPY                                 memcpy
N#endif
N
N/** 
NMBXMEMCMP: Should be defined to the memcmp function for MBXMEM memory, if the microcontroller<br>
Ndoes not support different memory types, MBXMEMCMP shall be defined to a 'normal' memcmp function */
N#ifndef MBXMEMCMP
N#define MBXMEMCMP                                 memcmp
N#endif
N
N/** 
NMBXMEMSET: Should be defined to the memcpy function for MBXMEM memory, if the microcontroller<br>
Ndoes not support different memory types, MBXMEMSET shall be defined to a 'normal' memset function */
N#ifndef MBXMEMSET
N#define MBXMEMSET                                 memset
N#endif
N
N/** 
NMBXSTRLEN: Should be defined to the strlen function for MBXMEM memory, if the microcontroller<br>
Ndoes not support different memory types, MBXSTRLEN shall be defined to a 'normal' strlen function */
N#ifndef MBXSTRLEN
N#define MBXSTRLEN                                 strlen
N#endif
N
N/** 
NMBXSTRCPY: Should be defined to the strcpy function for MBXMEM memory, if the microcontroller<br>
Ndoes not support different memory types, MBXSTRCPY shall be defined to a 'normal' strcpy function */
N#ifndef MBXSTRCPY
N#define MBXSTRCPY                                 memcpy
N#endif
N
N/** 
NOBJCONST: Should be used to define the object dictionary in ROM (f.e. define OBJCONST const) or<br>
Nin RAM (e.g. define OBJCONST) */
N#ifndef OBJCONST
N#define OBJCONST                                  const
N#endif
N
N/** 
NVARCONST: Should be used to define the constant variables in ROM (f.e. define VARCONST const) or<br>
Nin RAM (e.g. define VARCONST) */
N#ifndef VARCONST
N#define VARCONST 
N#endif
N
N/** 
NVARVOLATILE: Should be used to prevent dummy variables to be deleted due to compiler optimization.  */
N#ifndef VARVOLATILE
N#define VARVOLATILE                               volatile
N#endif
N
N/** 
NOBJMEM: Should be defined to select the memory type of the memory used for the object dictionary (e.g. near, far or huge), <br>
Nif the microcontroller does not support different memory types, OBJMEM shall be defined to nothing */
N#ifndef OBJMEM
N#define OBJMEM 
N#endif
N
N/** 
NOBJTOMBXMEMCPY: Should be defined to the memcpy function for copying OBJMEM memory to MBXMEM memory, if the microcontroller<br>
Ndoes not support different memory types, OBJTOMBXMEMCPY shall be defined to a 'normal' memcpy function */
N#ifndef OBJTOMBXMEMCPY
N#define OBJTOMBXMEMCPY                            memcpy
N#endif
N
N/** 
NOBJTOMBXSTRCPY: Should be defined to the strcpy function for copying OBJMEM memory to MBXMEM memory, if the microcontroller<br>
Ndoes not support different memory types, OBJTOMBXSTRCPY shall be defined to a 'normal' memcpy function */
N#ifndef OBJTOMBXSTRCPY
N#define OBJTOMBXSTRCPY                            memcpy
N#endif
N
N/** 
NMBXTOOBJSTRCPY: Should be defined to the strcpy function for copying MBXMEM memory to OBJMEM memory, if the microcontroller<br>
Ndoes not support different memory types, MBXTOOBJSTRCPY shall be defined to a 'normal' memcpy function */
N#ifndef MBXTOOBJSTRCPY
N#define MBXTOOBJSTRCPY                            memcpy
N#endif
N
N/** 
NOBJMEMCPY: Should be defined to the memcpy function for OBJMEM memory, if the microcontroller<br>
Ndoes not support different memory types, OBJMEMCPY shall be defined to a 'normal' memcpy function */
N#ifndef OBJMEMCPY
N#define OBJMEMCPY                                 memcpy
N#endif
N
N/** 
NOBJSTRLEN: Should be defined to the strlen function for OBJMEM memory, if the microcontroller<br>
Ndoes not support different memory types, OBJSTRLEN shall be defined to a 'normal' strlen function */
N#ifndef OBJSTRLEN
N#define OBJSTRLEN                                 strlen
N#endif
N
N/** 
NOBJSTRCPY: Should be defined to the strcpy function for OBJMEM memory, if the microcontroller<br>
Ndoes not support different memory types, OBJSTRCPY shall be defined to a 'normal' strcpy function */
N#ifndef OBJSTRCPY
N#define OBJSTRCPY                                 memcpy
N#endif
N
N/** 
NMAKE_HUGE_PTR: Should be defined to the initialize a pointer variable with an absolute address */
N#ifndef MAKE_HUGE_PTR
N#define MAKE_HUGE_PTR 
N#endif
N
N/** 
NMAKE_PTR_TO_ESC: Should be defined to the initialize the pointer to the ESC */
N#ifndef MAKE_PTR_TO_ESC
N#define MAKE_PTR_TO_ESC 
N#endif
N
N/** 
NEMCYMEMCPY: Should be defined to the memcpy function for EMCYMEM memory, if the microcontroller<br>
Ndoes not support different memory types, EMCYMEMCPY shall be defined to a 'normal' memcpy function */
N#ifndef EMCYMEMCPY
N#define EMCYMEMCPY                                memcpy
N#endif
N
N/** 
NEMCYMEMSET: Should be defined to the memset function for EMCYMEM memory, if the microcontroller<br>
Ndoes not support different memory types, EMCYMEMSET shall be defined to a 'normal' memcset function */
N#ifndef EMCYMEMSET
N#define EMCYMEMSET                                memset
N#endif
N
N/** 
NEMCYMEM: Should be defined to select the memory type of the memory used for the emergencies (e.g. near, far or huge), <br>
Nif the microcontroller does not support different memory types, EMCYMEM shall be defined to nothing */
N#ifndef EMCYMEM
N#define EMCYMEM 
N#endif
N
N/** 
NMEMCPY: Should be defined to copy data within local memory. */
N#ifndef MEMCPY
N#define MEMCPY                                    memcpy
N#endif
N
N/** 
NALLOCMEM(size): Should be defined to the alloc function to get dynamic memory */
N#ifndef ALLOCMEM
N#define ALLOCMEM(size)                            malloc((size))
N#endif
N
N/** 
NFREEMEM(pointer): Should be defined to the free function to put back dynamic memory */
N#ifndef FREEMEM
N#define FREEMEM(pointer)                          free((pointer))
N#endif
N
N/** 
NVARMEMSET: Should be defined to the memset function for VARMEM memory, if the microcontroller<br>
Ndoes not support different memory types, EMCYMEMSET shall be defined to a 'normal' memcset function */
N#ifndef VARMEMSET
N#define VARMEMSET                                 memset
N#endif
N
N/** 
NVARMEM: Should be defined to select the memory type of the memory used for dynamic memory (e.g. near, far or huge), <br>
Nif the microcontroller does not support different memory types, VARMEM shall be defined to nothing */
N#ifndef VARMEM
N#define VARMEM 
N#endif
N
N/** 
NMEM_ADDR: Type to access local memory addresses */
N#ifndef MEM_ADDR
N#define MEM_ADDR                                  UINT8
N#endif
N
N/** 
NGET_MEM_SIZE(ByteSize): Round up the byte size to next matching memory boundary depending on "MEM_ADDR" */
N#ifndef GET_MEM_SIZE
N#define GET_MEM_SIZE(ByteSize)                    (((ByteSize)+3) >> 2)
N#endif
N
N/** 
NAPPL_AllocMailboxBuffer(size): Should be defined to a function to get a buffer for a mailbox service,<br>
Nthis is only used if the switch MAILBOX_QUEUE is set */
N#ifndef APPL_AllocMailboxBuffer
N#define APPL_AllocMailboxBuffer(size)             malloc((size))
N#endif
N
N/** 
NAPPL_FreeMailboxBuffer(pointer): Should be defined to a function to put back a buffer for a mailbox service,<br>
Nthis is only used if the switch MAILBOX_QUEUE is set */
N#ifndef APPL_FreeMailboxBuffer
N#define APPL_FreeMailboxBuffer(pointer)           free((pointer))
N#endif
N
N/** 
NSTRUCT_PACKED_START: Is defined before the typedef struct construct to pack the generic structures if necessary */
N#ifndef STRUCT_PACKED_START
N#define STRUCT_PACKED_START 
N#endif
N
N/** 
NSTRUCT_PACKED_END: Is defined after the typedef struct {} construct to pack the generic structures if necessary */
N#ifndef STRUCT_PACKED_END
N#define STRUCT_PACKED_END
N#endif
N
N/** 
NMBX_STRUCT_PACKED_START: Is defined before the typedef struct construct to pack the MAILBOX structures if necessary */
N#ifndef MBX_STRUCT_PACKED_START
N#define MBX_STRUCT_PACKED_START 
N#endif
N
N/** 
NMBX_STRUCT_PACKED_END: Is defined after the typedef struct {} construct to pack the MAILBOX structures if necessary */
N#ifndef MBX_STRUCT_PACKED_END
N#define MBX_STRUCT_PACKED_END
N#endif
N
N/** 
NOBJ_STRUCT_PACKED_START: Is defined before the typedef struct construct to pack the OBJECT structures if necessary */
N#ifndef OBJ_STRUCT_PACKED_START
N#define OBJ_STRUCT_PACKED_START 
N#endif
N
N/** 
NOBJ_STRUCT_PACKED_END: Is defined after the typedef struct {} construct to pack the OBJECT structures if necessary */
N#ifndef OBJ_STRUCT_PACKED_END
N#define OBJ_STRUCT_PACKED_END 
N#endif
N
N/** 
NOBJ_DWORD_ALIGN: Shall be set if the object structures are not Byte aligned and 32bit entries are implicitly padded to even 32bit memory addresses. */
N#ifndef OBJ_DWORD_ALIGN
N#define OBJ_DWORD_ALIGN                           1
N#endif
N
N/** 
NOBJ_WORD_ALIGN: Shall be set if the object structures are not Byte aligned and 16bit entries are implicitly padded to even 16bit memory addresses. */
N#ifndef OBJ_WORD_ALIGN
N#define OBJ_WORD_ALIGN                            0
N#endif
N
N/** 
NENTER_MBX_CRITICAL: Macro which is called when a critical mailbox section is entered */
N#ifndef ENTER_MBX_CRITICAL
N#define ENTER_MBX_CRITICAL 
N#endif
N
N/** 
NLEAVE_MBX_CRITICAL: Macro which is called when a critical mailbox section is left */
N#ifndef LEAVE_MBX_CRITICAL
N#define LEAVE_MBX_CRITICAL 
N#endif
N
N/** 
NENTER_AOE_CRITICAL: Macro which is called when a critical AoE section is entered */
N#ifndef ENTER_AOE_CRITICAL
N#define ENTER_AOE_CRITICAL 
N#endif
N
N/** 
NLEAVE_AOE_CRITICAL: Macro which is called when a critical AoE section is left */
N#ifndef LEAVE_AOE_CRITICAL
N#define LEAVE_AOE_CRITICAL 
N#endif
N
N/** 
NENTER_EMCY_CRITICAL: Macro which is called when a critical emergency section is entered */
N#ifndef ENTER_EMCY_CRITICAL
N#define ENTER_EMCY_CRITICAL 
N#endif
N
N/** 
NLEAVE_EMCY_CRITICAL: Macro which is called when a critical emergency section is left */
N#ifndef LEAVE_EMCY_CRITICAL
N#define LEAVE_EMCY_CRITICAL 
N#endif
N
N
N/*-----------------------------------------------------------------------------------------
N------	
N------	Application Specific Defines
N------	
N-----------------------------------------------------------------------------------------*/
N
N/** 
NMAX_DIAG_MSG: Number of diagnosis message ringbuffer */
N#ifndef MAX_DIAG_MSG
N#define MAX_DIAG_MSG                              0x14
N#endif
N
N/** 
NMAX_EMERGENCIES: Number of emergencies supported in parallel */
N#ifndef MAX_EMERGENCIES
N#define MAX_EMERGENCIES                           0x1
N#endif
N
N/** 
NVENDOR_ID: Object 0x1018 SI1 (Vendor ID)	 <br>
NAn unique EtherCAT Vendor ID is required. Please find all valid Vendor IDs listed at www.ethercat.org/en/vendor_id_list.html.<br>
NIf your company is not listed, please assign an ID for free at www.ethercat.org/memberarea/vendor_id.asp */
N#ifndef VENDOR_ID
N#define VENDOR_ID                                 0x8CF
N#endif
N
N/** 
NPRODUCT_CODE: Object 0x1018 SI2 (EtherCAT product code) */
N#ifndef PRODUCT_CODE
N#define PRODUCT_CODE                              0x00000001
N#endif
N
N/** 
NREVISION_NUMBER: Object 0x1018 SI3 (EtherCAT product revision number) */
N#ifndef REVISION_NUMBER
N#define REVISION_NUMBER                           0x00000001
N#endif
N
N/** 
NSERIAL_NUMBER: Object 0x1018 SI4 (EtherCAT product serial number) */
N#ifndef SERIAL_NUMBER
N#define SERIAL_NUMBER                             0x00000001
N#endif
N
N/** 
NDEVICE_PROFILE_TYPE: Slave device type (Object 0x1000)  */
N#ifndef DEVICE_PROFILE_TYPE
N#define DEVICE_PROFILE_TYPE                       0x00001389
N#endif
N
N/** 
NDEVICE_NAME: Name of the slave device (Object 0x1008) */
N#ifndef DEVICE_NAME
N#define DEVICE_NAME                               "IO_ECAT_DC00"
N#endif
N
N/** 
NDEVICE_NAME_LEN: Length of 'DEVICE_NAME' without '\0' */
N#ifndef DEVICE_NAME_LEN
N#define DEVICE_NAME_LEN                           0xC
N#endif
N
N/** 
NDEVICE_HW_VERSION: Hardware version of the slave device (Object 0x1009) */
N#ifndef DEVICE_HW_VERSION
N#define DEVICE_HW_VERSION                         "0.0.0"
N#endif
N
N/** 
NDEVICE_HW_VERSION_LEN: Length of 'DEVICE_HW_VERSION' without '\0' */
N#ifndef DEVICE_HW_VERSION_LEN
N#define DEVICE_HW_VERSION_LEN                     0x5
N#endif
N
N/** 
NDEVICE_SW_VERSION: Software version of the slave device (Object 0x100A) */
N#ifndef DEVICE_SW_VERSION
N#define DEVICE_SW_VERSION                         "1.0.0"
N#endif
N
N/** 
NDEVICE_SW_VERSION_LEN: Length of 'DEVICE_SW_VERSION' without '\0' */
N#ifndef DEVICE_SW_VERSION_LEN
N#define DEVICE_SW_VERSION_LEN                     0x5
N#endif
N
N/** 
NMIN_PD_WRITE_ADDRESS: Minimum address for the process output data (Sync Manager 2)<br>
Ninside the application memory of the EtherCAT Slave Controller which could be set by the master. The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
N#ifndef MIN_PD_WRITE_ADDRESS
N#define MIN_PD_WRITE_ADDRESS                      0x1000
N#endif
N
N/** 
NMAX_PD_WRITE_ADDRESS: Maximum address for the process output data (Sync Manager 2)<br>
Ninside the application memory of the EtherCAT Slave Controller which could be set by the master. The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
N#ifndef MAX_PD_WRITE_ADDRESS
N#define MAX_PD_WRITE_ADDRESS                      0x1FFF
N#endif
N
N/** 
NMIN_PD_READ_ADDRESS: Minimum address for the process input data (Sync Manager 3)<br>
Ninside the application memory of the EtherCAT Slave Controller which could be set by the master. The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
N#ifndef MIN_PD_READ_ADDRESS
N#define MIN_PD_READ_ADDRESS                       0x1000
N#endif
N
N/** 
NMAX_PD_READ_ADDRESS: Maximum address for the process input data (Sync Manager 3)<br>
Ninside the application memory of the EtherCAT Slave Controller which could be set by the master. The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
N#ifndef MAX_PD_READ_ADDRESS
N#define MAX_PD_READ_ADDRESS                       0x1FFF
N#endif
N
N/** 
NMIN_MBX_SIZE: Minimum mailbox size (Sync Manager 0 and 1) which could be set by the master. The SSC don't support fragmented SDO info object/entry service => at least entry info including 12byte name shall fit in the mailbox buffer */
N#ifndef MIN_MBX_SIZE
N#define MIN_MBX_SIZE                              0x0024
N#endif
N
N/** 
NMAX_MBX_SIZE: Maximum mailbox size (Sync Manager 0 and 1) which could be set by the master. */
N#ifndef MAX_MBX_SIZE
N#define MAX_MBX_SIZE                              0x0100
N#endif
N
N/** 
NMIN_MBX_WRITE_ADDRESS: Minimum address for the write (receive) mailbox (Sync Manager 0). The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
N#ifndef MIN_MBX_WRITE_ADDRESS
N#define MIN_MBX_WRITE_ADDRESS                     0x1000
N#endif
N
N/** 
NMAX_MBX_WRITE_ADDRESS: Maximum address for the write (receive) mailbox (Sync Manager 0). The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
N#ifndef MAX_MBX_WRITE_ADDRESS
N#define MAX_MBX_WRITE_ADDRESS                     0x1FFF
N#endif
N
N/** 
NMAX_PD_INPUT_SIZE: Maximum size of the process input data (Sync Manager 3) for cyclic exchange. */
N#ifndef MAX_PD_INPUT_SIZE
N#define MAX_PD_INPUT_SIZE                         0x0100 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NMIN_MBX_READ_ADDRESS: Minimum address for the read (send) mailbox (Sync Manager 1). */
N#ifndef MIN_MBX_READ_ADDRESS
N#define MIN_MBX_READ_ADDRESS                      0x1080
N#endif
N
N/** 
NMAX_MBX_READ_ADDRESS: Maximum address for the read (send) mailbox (Sync Manager 1). */
N#ifndef MAX_MBX_READ_ADDRESS
N#define MAX_MBX_READ_ADDRESS                      0x1FFF
N#endif
N
N/** 
NMAX_PD_OUTPUT_SIZE: Maximum size of the process output data (Sync Manager 2) for cyclic exchange. */
N#ifndef MAX_PD_OUTPUT_SIZE
N#define MAX_PD_OUTPUT_SIZE                        0x0100 //This define was already evaluated by ET9300 Project Handler(V. 1.5.0.0)!
N#endif
N
N/** 
NMIN_PD_CYCLE_TIME: Minimum cycle time in ns the slave is supporting (entry 0x1C3x:05).<br>
NIn case that the value is set to 0 the value of 0x1C3x:5 is calculated if 0x1C3x.8 is 1 */
N#ifndef MIN_PD_CYCLE_TIME
N#define MIN_PD_CYCLE_TIME                         0
N#endif
N
N/** 
NMAX_PD_CYCLE_TIME: Maximum cycle time in ns the slave is supporting */
N#ifndef MAX_PD_CYCLE_TIME
N#define MAX_PD_CYCLE_TIME                         0xC3500000
N#endif
N
N/** 
NPD_OUTPUT_DELAY_TIME: Minimum output delay time in ns the slave is supporting (entry 0x1C32:09) */
N#ifndef PD_OUTPUT_DELAY_TIME
N#define PD_OUTPUT_DELAY_TIME                      0x0
N#endif
N
N/** 
NPD_OUTPUT_CALC_AND_COPY_TIME: Output calc+copy time in ns the slave is supporting (entry 0x1C32:06)<br>
NIn case that the value is set to 0 the value of 0x1C32:6 is calculated if 0x1C3x.8 is 1 */
N#ifndef PD_OUTPUT_CALC_AND_COPY_TIME
N#define PD_OUTPUT_CALC_AND_COPY_TIME              0x0
N#endif
N
N/** 
NPD_INPUT_CALC_AND_COPY_TIME: Input calc+copy time in ns the slave is supporting (entry 0x1C33:06)<br>
NIn case that the value is set to 0 the value of 0x1C33:6 is calculated if 0x1C3x.8 is 1 */
N#ifndef PD_INPUT_CALC_AND_COPY_TIME
N#define PD_INPUT_CALC_AND_COPY_TIME               0x0
N#endif
N
N/** 
NPD_INPUT_DELAY_TIME: Input delay time in ns the slave is supporting (entry 0x1C33:09) */
N#ifndef PD_INPUT_DELAY_TIME
N#define PD_INPUT_DELAY_TIME                       0x0
N#endif
N
N
N
N/*-----------------------------------------------------------------------------------------
N------	
N------	Test Configuration Defines
N------	
N-----------------------------------------------------------------------------------------*/
N
N
N#endif // _ECATDEF_H_
N
L 58 ".\etherCAT\SPIDriver.h" 2
N#include "stm32f4xx_hal.h"
N
N#ifdef	__cplusplus
Sextern "C" {
N#endif
N	// *****************************************************************************
N	// *****************************************************************************
N	// Section: File Scope or Global Data Types
N	// *****************************************************************************
N	// *****************************************************************************
N	#define CMD_SERIAL_READ 0x03
N	#define CMD_FAST_READ 0x0B
N	#define CMD_DUAL_OP_READ 0x3B
N	#define CMD_DUAL_IO_READ 0xBB
N	#define CMD_QUAD_OP_READ 0x6B
N	#define CMD_QUAD_IO_READ 0xEB
N	#define CMD_SERIAL_WRITE 0x02
N	#define CMD_DUAL_DATA_WRITE 0x32
N	#define CMD_DUAL_ADDR_DATA_WRITE 0xB2
N	#define CMD_QUAD_DATA_WRITE 0x62
N	#define CMD_QUAD_ADDR_DARA_WRITE 0xE2
N
N	#define CMD_SERIAL_READ_DUMMY 0
N	#define CMD_FAST_READ_DUMMY 1
N	#define CMD_DUAL_OP_READ_DUMMY 1
N	#define CMD_DUAL_IO_READ_DUMMY 2
N	#define CMD_QUAD_OP_READ_DUMMY 1
N	#define CMD_QUAD_IO_READ_DUMMY 4
N	#define CMD_SERIAL_WRITE_DUMMY 0
N	#define CMD_DUAL_DATA_WRITE_DUMMY 0
N	#define CMD_DUAL_ADDR_DATA_WRITE_DUMMY 0
N	#define CMD_QUAD_DATA_WRITE_DUMMY 0
N	#define CMD_QUAD_ADDR_DARA_WRITE_DUMMY 0
N
N	#define ESC_CSR_CMD_REG		0x304
N	#define ESC_CSR_DATA_REG	0x300
N	#define ESC_WRITE_BYTE 		0x80
N	#define ESC_READ_BYTE 		0xC0
N	#define ESC_CSR_BUSY		0x80
N
N  
N	#define SPIWriteByte(UINT8) SPIWrite(UINT8)
N	#define SPIReadByte() SPIRead()
N
N
N    typedef union {
N        UINT16 Val;
X        unsigned short Val;
N        struct __attribute__((packed)) {
N            UINT8 LB;
X            unsigned char LB;
N            UINT8 HB;
X            unsigned char HB;
N        } byte;
N    } UINT16_VAL;
N
N    typedef union {
N        UINT32 Val;
X        unsigned int Val;
N        UINT16 w[2] __attribute__((packed));
X        unsigned short w[2] __attribute__((packed));
N        UINT8  v[4];
X        unsigned char  v[4];
N        struct __attribute__((packed)) {
N            UINT16 LW;
X            unsigned short LW;
N            UINT16 HW;
X            unsigned short HW;
N        } word;
N        struct __attribute__((packed)) {
N            UINT8 LB;
X            unsigned char LB;
N            UINT8 HB;
X            unsigned char HB;
N            UINT8 UB;
X            unsigned char UB;
N            UINT8 MB;
X            unsigned char MB;
N        } byte;
N    } UINT32_VAL;
N
N    typedef union {
N        UINT64 Val;
X        unsigned long long Val;
N        UINT16 w[4];
X        unsigned short w[4];
N        UINT8  v[8];
X        unsigned char  v[8];
N    } UINT64_VAL;
N
N#define SPI_BUFFER_SIZE 512u
N
N#define ECAT_SPI_TIMEOUT 2000u
N		
Nextern SPI_HandleTypeDef *EcatHspiPtr;
Nextern UINT8 EcatSpiReadBuffer[SPI_BUFFER_SIZE];
Xextern unsigned char EcatSpiReadBuffer[512u];
Nextern UINT8 EcatSpiWriteBuffer[SPI_BUFFER_SIZE];
Xextern unsigned char EcatSpiWriteBuffer[512u];
N	// *****************************************************************************
N	// *****************************************************************************
N	// Section: File Scope Functions
N	// *****************************************************************************
N	// *****************************************************************************
N
N	void SPIWritePDRamRegister(UINT8 *WriteBuffer, UINT16 Address, UINT16 Count);
X	void SPIWritePDRamRegister(unsigned char *WriteBuffer, unsigned short Address, unsigned short Count);
N	void SPIReadPDRamRegister(UINT8 *ReadBuffer, UINT16 Address, UINT16 Count);
X	void SPIReadPDRamRegister(unsigned char *ReadBuffer, unsigned short Address, unsigned short Count);
N    void SPIReadRegUsingCSR(UINT8 *ReadBuffer, UINT16 Address, UINT8 Count);
X    void SPIReadRegUsingCSR(unsigned char *ReadBuffer, unsigned short Address, unsigned char Count);
N    void SPIWriteRegUsingCSR( UINT8 *WriteBuffer, UINT16 Address, UINT8 Count);
X    void SPIWriteRegUsingCSR( unsigned char *WriteBuffer, unsigned short Address, unsigned char Count);
N	void SPIWriteDWord (UINT16 Address, UINT32 Val);
X	void SPIWriteDWord (unsigned short Address, unsigned int Val);
N	UINT32 SPIReadDWord (UINT16 Address);
X	unsigned int SPIReadDWord (unsigned short Address);
N    void SPIWriteBurstMode (UINT32 Val);
X    void SPIWriteBurstMode (unsigned int Val);
N    UINT32 SPIReadBurstMode (void);
X    unsigned int SPIReadBurstMode (void);
N    void SPISendAddr (UINT16 Address);
X    void SPISendAddr (unsigned short Address);
N    void PDIWriteLAN9252DirectReg( UINT32 Val, UINT16 Address);
X    void PDIWriteLAN9252DirectReg( unsigned int Val, unsigned short Address);
N    UINT32 PDIReadLAN9252DirectReg( UINT16 Address);
X    unsigned int PDIReadLAN9252DirectReg( unsigned short Address);
N    void PDIReadReg(UINT8 *ReadBuffer, UINT16 Address, UINT16 Count);
X    void PDIReadReg(unsigned char *ReadBuffer, unsigned short Address, unsigned short Count);
N    void PDIWriteReg( UINT8 *WriteBuffer, UINT16 Address, UINT16 Count);
X    void PDIWriteReg( unsigned char *WriteBuffer, unsigned short Address, unsigned short Count);
N#ifdef	__cplusplus
S}
N#endif
N
N#endif	/* PMPDRIVER_H */
N
L 35 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\main.h" 2
N#include "9252_HW.h"
L 1 ".\etherCAT\9252_HW.h" 1
N/*******************************************************************************
N LAN9252 - Hardware Abtraction Layer header file.
N
N  Company:
N    Microchip Technology Inc.
N
N  File Name:
N    9252_HW.h
N
N  Description:
N    This file contains the defines, function protypes for LAN9252 Hardware Abtraction Layer
N
N  Change History:
N    Version		Changes
N	0.1			Initial version.
N	0.2			-
N	0.3			-
N	0.4			-
N	1.0			-
N	1.3			- *Re-arranged the functions. 
N*******************************************************************************/
N
N/*******************************************************************************
NCopyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
N
NMicrochip licenses to you the right to use, modify, copy and distribute
NSoftware only when embedded on a Microchip microcontroller or digital signal
Ncontroller that is integrated into your product or third party product
N(pursuant to the sublicense terms in the accompanying license agreement).
N
NYou should refer to the license agreement accompanying this Software for
Nadditional information regarding your rights and obligations.
N
NSOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
NEITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
NMERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
NIN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
NCONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
NOTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
NINCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
NCONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
NSUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
N(INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
N *******************************************************************************/
N
N#ifndef _9252_HW_H_
N#define _9252_HW_H_
N
N///////////////////////////////////////////////////////////////////////////////
N// Includes
N
N#include  "esc.h"
L 1 ".\etherCAT\esc.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N * \addtogroup ESCRegister  ESC Register
N * @{
N */
N
N/**
N\file esc.h
N\author EthercatSSC@beckhoff.com
N\brief EtherCAT Slave Controller related defines and Types
N
N\version 5.10
N
N<br>Changes to version V5.01:<br>
NV5.10 ESC1: Update address register offset for 32Bit ESC access<br>
NV5.10 ESC2: Check if defined SM settings do not exceed the available DPRAM range (in error case AL Status 0x14 is returned)<br>
NV5.10 ESC3: Handle DC cControl register values in case of 32Bit ESC access (a Sync activation mask need to defined/used)<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N#include "ecat_def.h"
N
N#ifndef _ESC_H_
N#define _ESC_H_
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Defines and Types
N------
N-----------------------------------------------------------------------------------------*/
N
N#define SIZEOF_SM_REGISTER                      8 /**< \brief Each SyncManger has 8Byte Configuration/Status Registers*/
N#define MAX_NO_OF_SYNC_MAN                      16/**< \brief Maximum Number of SyncManager channels supported by an ESC*/
N
N#define    BL_PAGE_SIZE        512
N
N/*---------------------------------------------
N-    ESC Offsets (Detailed Information about the registers are located in the ESC Datasheets e.g. ET1100 Datasheet http://www.beckhoff.com/english.asp?download/ethercat_development_products.htm?id=71003127100387)
N-----------------------------------------------*/
N#define ESC_INFO_OFFSET                         0x0000                               /**< \brief ESC information registers startoffset*/
N
N#define ESC_COMM_INFO_OFFSET                    0x0004                               /**< \brief Communication information registers startoffset*/
N
N/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 54 to 59 deleted*/
N#define ESC_DPRAM_SIZE_OFFSET                   0x0006                              /**< \brief Register Description: Size of the supported DPRAM in KB*/
N#define ESC_SM_CHANNELS_MASK                    0xFF00                              /**< \brief Mask based on ESC offset "ESC_COMM_INFO_OFFSET"*/
N#define ESC_SM_CHANNELS_SHIFT                   8                                   /**< \brief Bit shift based on ESC offset "ESC_COMM_INFO_OFFSET"*/
N#define ESC_DPRAM_SIZE_MASK                     0x00FF
N/*ET9300 Project Handler :(#if ESC_16BIT_ACCESS #else) lines 65 to 67 deleted*/
N
N#define ESC_FEATURES_OFFSET                     0x0008                              /**< \brief Register indicating ESC features*/
N#define ESC_DC_32BIT_MASK                       0x00000008                          /**< \brief register 0x0008.3 indicates if the DC Unit supports 32Bit/64Bit DC*/
N
N/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 73 to 75 deleted*/
N
N#define ESC_SLAVE_ADDRESS_OFFSET                0x0010                              /**< \brief Register Description: Address used for node addressing (FPxx commands)*/
N
N
N
N#define ESC_AL_CONTROL_OFFSET                   0x0120                              /**< \brief Register Description: Initiate State Transition of the Device State Machine*/
N#define ESC_AL_STATUS_OFFSET                    0x0130                              /**< \brief Register Description: Actual State of the Device State Machine*/
N#define ESC_AL_STATUS_CODE_OFFSET               0x0134                              /**< \brief Register Description: AL Status Code*/
N
N#define ESC_RUN_LED_OVERRIDE                    0x0138                              /**< \brief Register Description: Set Ecat Run indication via ESC. (not all ESC types support this feature)*/
N#define ESC_ERROR_LED_OVERRIDE                  0x0139                              /**< \brief Register Description: Set Ecat Error indication via ESC. (not all ESC types support this feature)*/
N
N#define ESC_PDI_CONTROL_OFFSET                  0x0140                              /**< \brief Register Description: Specifies the process data interface*/
N/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 89 to 91 deleted*/
N#define ESC_DEVICE_EMULATION                    0x0100                              /**< \brief Device emulation bit*/
N
N#define ESC_PDI_CONFIGURATION					0x0150								/**< \brief Register Description: PDI configuration register (values defined by the ESC configuration data)*/
N#define ESC_SYNC0_MAPPED_TO_ALEVENT				0x0800								/**< \brief bit indicating if the Sync0 event is mapped to the AL Event register*/
N#define ESC_SYNC1_MAPPED_TO_ALEVENT				0x8000								/**< \brief bit indicating if the Sync1 event is mapped to the AL Event register*/
N/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS || ESC_16BIT_ACCESS #else) lines 99 to 103 deleted*/
N
N
N#define ESC_AL_EVENTMASK_OFFSET                 0x0204                              /**< \brief Register Description: AL Event masking of the AL Event Request register Events for mapping to PDI IRQ signal*/
N#define ESC_AL_EVENT_OFFSET                     0x0220                              /**< \brief Register Description: "Mirror" register for ESC events*/
N
N#define ESC_WD_DIVIDER_OFFSET                   0x0400                              /**< \brief Register Description: Number of 25 MHz tics (minus 2) that represents the basic watchdog increment. (Default value is 100us = 2498)*/
N
N#define ESC_PD_WD_TIME                          0x0420                              /**< \brief Register Description: Number of basic watchdog increments (Default value with Watchdog divider 100us means 100ms Watchdog)*/
N#define ESC_PD_WD_STATE                         0x0440                              /**< \brief Register Description: Watchdog Status of Process Data (triggered by SyncManagers)*/
N/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 113 to 115 deleted*/
N#define ESC_PD_WD_TRIGGER_MASK                  0x0001                              /**< \brief Trigger state of the process data watchdog*/
N
N#define ESC_EEPROM_CONFIG_OFFSET                0x0500                              /**< \brief Register Description: EEPROM Access Configuration*/
N/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 120 to 138 deleted*/
N/*EEPROM config and access state bit mask (based on "ESC_EEPROM_CONFIG_OFFSET") - START*/
N#define ESC_EEPROM_ASSIGN_TO_PDI_MASK           0x0001                              /**< \brief Description (0x500.0): PDI has EEPROM control*/
N#define ESC_EEPROM_LOCKED_BY_PDI_MASK           0x0100                              /**< \brief Description (0x500.8): PDI locked EEPROM access*/
N/*EEPROM config and access state bit mask (based on "ESC_EEPROM_CONFIG_OFFSET") - END*/
N
N#define ESC_EEPROM_CONTROL_OFFSET               0x0502
N/* EEPROM command and status bit masks (based on "ESC_EEPROM_CONTROL_OFFSET") - START*/
N#define ESC_EEPROM_SUPPORTED_READBYTES_MASK     0x0040                              /**< \brief Description (0x502.6): Supported number of EEPROM read bytes: 0-> 4 Bytes; 1 -> 8 Bytes*/
N#define ESC_EEPROM_CMD_MASK                     0x0700                              /**< \brief Description (0x502.8:10): Command bit mask*/
N#define ESC_EEPROM_CMD_READ_MASK                0x0100                              /**< \brief Description (0x502.8): Currently executed read command*/
N#define ESC_EEPROM_CMD_WRITE_MASK               0x0200                              /**< \brief Description (0x502.9): Initialize Write Command*/
N#define ESC_EEPROM_CMD_RELOAD_MASK              0x0400                              /**< \brief Description (0x502.10): Trigger EEPROM reload*/
N#define ESC_EEPROM_ERROR_MASK                   0x7800                              /**< \brief Description : Mask all EEPROM error bits; Checksum error (0x0502.11); EEPROM not loaded (0x0502.12); Missing EEPROM Acknowledge (0x0502.13); Write Error (0x0502.14)*/
N#define ESC_EEPROM_ERROR_CRC                    0x0800                              /**< \brief Description (0x502.11): EEPROM CRC Error*/
N#define ESC_EEPROM_ERROR_LOAD                   0x1000                              /**< \brief Description (0x502.11): EEPROM loading status (0 = OK)*/
N#define ESC_EEPROM_ERROR_CMD_ACK                0x2000                              /**< \brief Description (0x502.13): EEPROM Acknowledge/Command*/
N#define ESC_EEPROM_BUSY_MASK                    0x8000                              /**< \brief Description (0x502.15): EEPROM Busy*/
N/* EEPROM command and status bit masks (based on "ESC_EEPROM_CONTROL_OFFSET") - END*/
N#define ESC_EEPROM_ADDRESS_OFFSET               0x0504
N#define ESC_EEPROM_DATA_OFFSET                  0x0508
N
N#define ESC_SYNCMAN_REG_OFFSET                  0x0800                              /**< \brief Register Description: Start address of the SyncManager Configuration/Staus registers*/
N#define ESC_SYNCMAN_CONTROL_OFFSET              0x0804                              /**< \brief Register Description: SyncManager Setting Register*/
N
N/*ET9300 Project Handler :(#if !ESC_32BIT_ACCESS && !ESC_16BIT_ACCESS) lines 164 to 166 deleted*/
N
N#define ESC_SYNCMAN_ACTIVE_OFFSET               0x0806                              /**< \brief Register Description: SyncManager Activation Register*/
N
N/*ET9300 Project Handler :(#if !ESC_32BIT_ACCESS && !ESC_16BIT_ACCESS) lines 172 to 174 deleted*/
N
N#define    ESC_SYSTEMTIME_OFFSET                0x0910                              /**< \brief Register Description: Local copy of the System Time*/
N
N#define    ESC_DC_UNIT_CONTROL_OFFSET           0x0980                              /**< \brief Register Description: Control registers for Cycle and Sync Unit (can be predefined with the "AssignActivate" Element in the device description, for further information see ETG.2000)*/
N/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 179 to 185 deleted*/
N#define ESC_DC_SYNC_UNIT_ACTIVE_MASK            0x0100                              /**< \brief Description (0x980.8): Sync Out Unit is activated*/
N#define ESC_DC_SYNC0_ACTIVE_MASK                0x0200                              /**< \brief Description (0x980.9): Sync0 generation is activated*/
N#define ESC_DC_SYNC1_ACTIVE_MASK                0x0400                              /**< \brief Description (0x980.10): Sync1 generation is activated*/
N#define ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK       0x0800                              /**< \brief Description (0x980.11): Sync Out Unit is activated automatic when System time was written*/
N/*ET9300 Project Handler :( #else) lines 190 to 196 deleted*/
N
N#define    ESC_DC_SYNC_STATUS		            0x098C                              /**< \brief Register Description: register 0x98E and 0x98F reflecting the status of Sync0 and Sync1*/
N
N#define ESC_DC_SYNC0_CYCLETIME_OFFSET           0x09A0                              /**< \brief Register Description: 32Bit Time between two consecutive SYNC0 pulses in ns*/
N#define ESC_DC_SYNC1_CYCLETIME_OFFSET           0x09A4                              /**< \brief Register Description: 32Bit Time between two consecutive SYNC1 pulses in ns*/
N
N
N/*ET9300 Project Handler :(#if FC1100_HW) lines 205 to 207 deleted*/
N
N
N/*---------------------------------------------
N-    Sync Manager
N-----------------------------------------------*/
N/** \brief SyncManager register structure*/
Ntypedef struct STRUCT_PACKED_START
Xtypedef struct 
N{
N/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 217 to 259 deleted*/
N
N  UINT16                        PhysicalStartAddress; /**< \brief SyncManager address*/
X  unsigned short                        PhysicalStartAddress;  
N  UINT16                        Length; /**< \brief SyncManager length*/
X  unsigned short                        Length;  
N
N    UINT16                        Settings[2]; /**< \brief Register values 0x0804 : 0x0807*/
X    unsigned short                        Settings[2];  
N
N/*Defines to access :
N* - SM Control register 0x0804
N* - SM Status register 0x0805
N*
N* all defines are based on 0x0804
N*/
N
N/*SyncManger control (0x0804) access*/
N#define SM_SETTING_CONTROL_OFFSET           0 /**< \brief Offset to value of register 0x0804*/
N#define SM_SETTING_MODE_MASK                0x0002 /**< \brief SyncManager mode mask*/
N#define SM_SETTING_MODE_THREE_BUFFER_VALUE  0x0000 /**< \brief SyncManager 3Buffer mode value*/
N#define SM_SETTING_MODE_ONE_BUFFER_VALUE    0x0002 /**< \brief SyncManager 1Buffer mode value*/
N#define SM_SETTING_DIRECTION_MASK           0x000C /**< \brief SyncManager direction mask*/
N#define SM_SETTING_DIRECTION_READ_VALUE     0x0000 /**< \brief SyncManager read direction*/
N#define SM_SETTING_DIRECTION_WRITE_VALUE    0x0004 /**< \brief SyncManager write direction*/
N#define SM_SETTING_WATCHDOG_VALUE           0x0040 /**< \brief SyncManager watchdog value*/
N
N/*SyncManger status (0x0805) access*/
N#define SM_STATUS_MBX_BUFFER_FULL           0x0800 /**< \brief Indicates in one buffer mode if buffer was completely written*/
N
N/*Defines to access :
N* - SM Active register 0x0806
N* - SM PDI Control register 0x0807
N*
N* all defines are based on 0x0806
N*/
N
N/*SyncManger active (0x0806) access*/
N#define SM_SETTING_ACTIVATE_OFFSET          1 /**< \brief Offset to value of register 0x0806*/
N#define SM_SETTING_ENABLE_VALUE             0x0001 /**< \brief SyncManager enable*/
N#define SM_SETTING_REPAET_REQ_MASK          0x0002 /**< \brief SyncManager Repeat request*/
N#define SM_SETTING_REPEAT_REQ_SHIFT         0 /**< \brief SyncManager Repeat request shift*/
N
N/*SyncManger PDI Control (0x0807) access*/
N#define SM_SETTING_PDI_DISABLE              0x0100  /**< \brief Bit0 of register 0x0807 (if 1 SM is disabled from PDI)*/
N#define SM_SETTING_REPEAT_ACK               0x0200 /**< \brief Bit1 of register 0x0807*/
N/*ET9300 Project Handler :(#if ESC_16BIT_ACCESS #else) lines 303 to 354 deleted*/
N}STRUCT_PACKED_END
X}
NTSYNCMAN;
N
N
N/*ET9300 Project Handler :(#if FC1100_HW) lines 361 to 363 deleted*/
N
N#endif //_ESC_H_
N/** @}*/
L 53 ".\etherCAT\9252_HW.h" 2
N#include  "SPIDriver.h"
N#include  "PDIDriver.h"
L 1 ".\etherCAT\PDIDriver.h" 1
N/*
N * PDIDriver.h
N *
N *  Created on: 2021年10月8日
N *      Author: siasun
N */
N
N#ifndef COMMON_INCLUDE_PDIDRIVER_H_
N#define COMMON_INCLUDE_PDIDRIVER_H_
N
N#include "stm32f4xx_hal.h"
N#include "ecat_def.h"
N#include "9252_HW.h"
L 1 ".\etherCAT\9252_HW.h" 1
N/*******************************************************************************
N LAN9252 - Hardware Abtraction Layer header file.
N
N  Company:
N    Microchip Technology Inc.
N
N  File Name:
N    9252_HW.h
N
N  Description:
N    This file contains the defines, function protypes for LAN9252 Hardware Abtraction Layer
N
N  Change History:
N    Version		Changes
N	0.1			Initial version.
N	0.2			-
N	0.3			-
N	0.4			-
N	1.0			-
N	1.3			- *Re-arranged the functions. 
N*******************************************************************************/
N
N/*******************************************************************************
NCopyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
N
NMicrochip licenses to you the right to use, modify, copy and distribute
NSoftware only when embedded on a Microchip microcontroller or digital signal
Ncontroller that is integrated into your product or third party product
N(pursuant to the sublicense terms in the accompanying license agreement).
N
NYou should refer to the license agreement accompanying this Software for
Nadditional information regarding your rights and obligations.
N
NSOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
NEITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
NMERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
NIN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
NCONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
NOTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
NINCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
NCONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
NSUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
N(INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
N *******************************************************************************/
N
N#ifndef _9252_HW_H_
S#define _9252_HW_H_
S
S///////////////////////////////////////////////////////////////////////////////
S// Includes
S
S#include  "esc.h"
S#include  "SPIDriver.h"
S#include  "PDIDriver.h"
S///////////////////////////////////////////////////////////////////////////////
S//9252 HW DEFINES
S#define ECAT_REG_BASE_ADDR              0x0300
S
S#define CSR_DATA_REG_OFFSET             0x00
S#define CSR_CMD_REG_OFFSET              0x04
S#define PRAM_READ_ADDR_LEN_OFFSET       0x08
S#define PRAM_READ_CMD_OFFSET            0x0c
S#define PRAM_WRITE_ADDR_LEN_OFFSET      0x10
S#define PRAM_WRITE_CMD_OFFSET           0x14
S
S#define PRAM_SPACE_AVBL_COUNT_MASK      0x1f
S#define IS_PRAM_SPACE_AVBL_MASK         0x01
S
S
S#define CSR_DATA_REG                    ECAT_REG_BASE_ADDR+CSR_DATA_REG_OFFSET
S#define CSR_CMD_REG                     ECAT_REG_BASE_ADDR+CSR_CMD_REG_OFFSET
S#define PRAM_READ_ADDR_LEN_REG          ECAT_REG_BASE_ADDR+PRAM_READ_ADDR_LEN_OFFSET
S#define PRAM_READ_CMD_REG               ECAT_REG_BASE_ADDR+PRAM_READ_CMD_OFFSET
S#define PRAM_WRITE_ADDR_LEN_REG         ECAT_REG_BASE_ADDR+PRAM_WRITE_ADDR_LEN_OFFSET
S#define PRAM_WRITE_CMD_REG              ECAT_REG_BASE_ADDR+PRAM_WRITE_CMD_OFFSET
S
S#define PRAM_READ_FIFO_REG              0x04
S#define PRAM_WRITE_FIFO_REG             0x20
S
S#define HBI_INDEXED_DATA0_REG           0x04
S#define HBI_INDEXED_DATA1_REG           0x0c
S#define HBI_INDEXED_DATA2_REG           0x14
S
S#define HBI_INDEXED_INDEX0_REG          0x00
S#define HBI_INDEXED_INDEX1_REG          0x08
S#define HBI_INDEXED_INDEX2_REG          0x10
S
S#define HBI_INDEXED_PRAM_READ_WRITE_FIFO    0x18
S
S#define PRAM_RW_ABORT_MASK      (1 << 30)
S#define PRAM_RW_BUSY_32B        (1 << 31)
S#define PRAM_RW_BUSY_8B         (1 << 7)
S#define PRAM_SET_READ           (1 << 6)
S#define PRAM_SET_WRITE          0
S
S
S//#define 
S
S///////////////////////////////////////////////////////////////////////////////
S
S///////////////////////////////////////////////////////////////////////////////
S// Hardware timer settings
S
S#define ECAT_TIMER_INC_P_MS              1 /**< \brief 312 ticks per ms*/
S
S
S///////////////////////////////////////////////////////////////////////////////
S// Interrupt and Timer Defines
S
S#ifndef DISABLE_ESC_INT
S    #define    DISABLE_ESC_INT()           {restore_intsts = PDI_Disable_Global_Interrupt();}
S#endif
S#ifndef ENABLE_ESC_INT
S    #define    ENABLE_ESC_INT()           {PDI_Restore_Global_Interrupt(restore_intsts);}
S#endif
S
S
S//TODO
S#ifndef HW_GetTimer
S    #define HW_GetTimer()       (PDI_GetTimer()) /**< \brief Access to the hardware timer*/
S#endif
S
S#ifndef HW_ClearTimer
S    #define HW_ClearTimer()       (PDI_ClearTimer()) /**< \brief Clear the hardware timer*/
S#endif
S
S
S#define HW_EscReadWord(WordValue, Address) HW_EscRead(((MEM_ADDR *)&(WordValue)),((UINT16)(Address)),2) /**< \brief 16Bit ESC read access*/
S#define HW_EscReadDWord(DWordValue, Address) HW_EscRead(((MEM_ADDR *)&(DWordValue)),((UINT16)(Address)),4) /**< \brief 32Bit ESC read access*/
S#define HW_EscReadByte(ByteValue, Address) HW_EscRead(((MEM_ADDR *)&(ByteValue)),((UINT16)(Address)),1) /**< \brief 8Bit ESC read access*/
S#define HW_EscReadMbxMem(pData,Address,Len) HW_EscRead(((MEM_ADDR *)(pData)),((UINT16)(Address)),(Len)) /**< \brief The mailbox data is stored in the local uC memory therefore the default read function is used.*/
S
S#define HW_EscReadWordIsr(WordValue, Address) HW_EscReadIsr(((MEM_ADDR *)&(WordValue)),((UINT16)(Address)),2) /**< \brief Interrupt specific 16Bit ESC read access*/
S#define HW_EscReadDWordIsr(DWordValue, Address) HW_EscReadIsr(((MEM_ADDR *)&(DWordValue)),((UINT16)(Address)),4) /**< \brief Interrupt specific 32Bit ESC read access*/
S#define HW_EscReadByteIsr(ByteValue, Address) HW_EscReadIsr(((MEM_ADDR *)&(ByteValue)),((UINT16)(Address)),1) /**< \brief Interrupt specific 8Bit ESC read access*/
S
S
S#define HW_EscWriteWord(WordValue, Address) HW_EscWrite(((MEM_ADDR *)&(WordValue)),((UINT16)(Address)),2) /**< \brief 16Bit ESC write access*/
S#define HW_EscWriteDWord(DWordValue, Address) HW_EscWrite(((MEM_ADDR *)&(DWordValue)),((UINT16)(Address)),4) /**< \brief 32Bit ESC write access*/
S#define HW_EscWriteByte(ByteValue, Address) HW_EscWrite(((MEM_ADDR *)&(ByteValue)),((UINT16)(Address)),1) /**< \brief 8Bit ESC write access*/
S#define HW_EscWriteMbxMem(pData,Address,Len) HW_EscWrite(((MEM_ADDR *)(pData)),((UINT16)(Address)),(Len)) /**< \brief The mailbox data is stored in the local uC memory therefore the default write function is used.*/
S
S#define HW_EscWriteWordIsr(WordValue, Address) HW_EscWriteIsr(((MEM_ADDR *)&(WordValue)),((UINT16)(Address)),2) /**< \brief Interrupt specific 16Bit ESC write access*/
S#define HW_EscWriteDWordIsr(DWordValue, Address) HW_EscWriteIsr(((MEM_ADDR *)&(DWordValue)),((UINT16)(Address)),4) /**< \brief Interrupt specific 32Bit ESC write access*/
S#define HW_EscWriteByteIsr(ByteValue, Address) HW_EscWriteIsr(((MEM_ADDR *)&(ByteValue)),((UINT16)(Address)),1) /**< \brief Interrupt specific 8Bit ESC write access*/
S
S///////////////////////////////////////////////////////////////////////////////
S
S#if _9252_HW_
S    #define PROTO
S#else
S    #define PROTO extern
S#endif
S
S///////////////////////////////////////////////////////////////////////////////
S// Global variables extern
SPROTO volatile unsigned int restore_intsts;
S
S///////////////////////////////////////////////////////////////////////////////
S// Global functions prototype
S
SPROTO UINT8 LAN9252_Init(void);
SPROTO void HW_Release(void);
S
SPROTO UINT16 HW_GetALEventRegister(void);
SPROTO UINT16 HW_GetALEventRegister_Isr(void);
S
SPROTO void HW_ResetALEventMask(UINT16 intMask);
SPROTO void HW_SetALEventMask(UINT16 intMask);
S
SPROTO void HW_EscRead( MEM_ADDR * pData, UINT16 Address, UINT16 Len );
SPROTO void HW_EscReadIsr( MEM_ADDR *pData, UINT16 Address, UINT16 Len );
S
SPROTO void HW_EscWrite( MEM_ADDR *pData, UINT16 Address, UINT16 Len );
SPROTO void HW_EscWriteIsr( MEM_ADDR *pData, UINT16 Address, UINT16 Len );
S
SPROTO void HW_DisableSyncManChannel(UINT8 channel);
SPROTO void HW_EnableSyncManChannel(UINT8 channel);
SPROTO TSYNCMAN ESCMEM *HW_GetSyncMan(UINT8 channel);
SPROTO void HW_SetLed(UINT8 RunLed,UINT8 ErrLed);
S
SPROTO UINT32 PDI_GetTimer();
SPROTO void PDI_ClearTimer();
S
SPROTO void PDI_Restore_Global_Interrupt(UINT32 int_sts);
SPROTO UINT32 PDI_Disable_Global_Interrupt();
S
S#undef    PROTO
S
N#endif
L 14 ".\etherCAT\PDIDriver.h" 2
Nextern uint8_t PDI_Isr_enable;
N
Nvoid PDI_Enable_Global_interrupt(void);
Nvoid PDI_IRQ_Interrupt(void);
Nvoid PDI_Init_SYNC_Interrupts(void);
Nvoid PDI_Timer_Interrupt(void);
N#endif /* COMMON_INCLUDE_PDIDRIVER_H_ */
L 55 ".\etherCAT\9252_HW.h" 2
N///////////////////////////////////////////////////////////////////////////////
N//9252 HW DEFINES
N#define ECAT_REG_BASE_ADDR              0x0300
N
N#define CSR_DATA_REG_OFFSET             0x00
N#define CSR_CMD_REG_OFFSET              0x04
N#define PRAM_READ_ADDR_LEN_OFFSET       0x08
N#define PRAM_READ_CMD_OFFSET            0x0c
N#define PRAM_WRITE_ADDR_LEN_OFFSET      0x10
N#define PRAM_WRITE_CMD_OFFSET           0x14
N
N#define PRAM_SPACE_AVBL_COUNT_MASK      0x1f
N#define IS_PRAM_SPACE_AVBL_MASK         0x01
N
N
N#define CSR_DATA_REG                    ECAT_REG_BASE_ADDR+CSR_DATA_REG_OFFSET
N#define CSR_CMD_REG                     ECAT_REG_BASE_ADDR+CSR_CMD_REG_OFFSET
N#define PRAM_READ_ADDR_LEN_REG          ECAT_REG_BASE_ADDR+PRAM_READ_ADDR_LEN_OFFSET
N#define PRAM_READ_CMD_REG               ECAT_REG_BASE_ADDR+PRAM_READ_CMD_OFFSET
N#define PRAM_WRITE_ADDR_LEN_REG         ECAT_REG_BASE_ADDR+PRAM_WRITE_ADDR_LEN_OFFSET
N#define PRAM_WRITE_CMD_REG              ECAT_REG_BASE_ADDR+PRAM_WRITE_CMD_OFFSET
N
N#define PRAM_READ_FIFO_REG              0x04
N#define PRAM_WRITE_FIFO_REG             0x20
N
N#define HBI_INDEXED_DATA0_REG           0x04
N#define HBI_INDEXED_DATA1_REG           0x0c
N#define HBI_INDEXED_DATA2_REG           0x14
N
N#define HBI_INDEXED_INDEX0_REG          0x00
N#define HBI_INDEXED_INDEX1_REG          0x08
N#define HBI_INDEXED_INDEX2_REG          0x10
N
N#define HBI_INDEXED_PRAM_READ_WRITE_FIFO    0x18
N
N#define PRAM_RW_ABORT_MASK      (1 << 30)
N#define PRAM_RW_BUSY_32B        (1 << 31)
N#define PRAM_RW_BUSY_8B         (1 << 7)
N#define PRAM_SET_READ           (1 << 6)
N#define PRAM_SET_WRITE          0
N
N
N//#define 
N
N///////////////////////////////////////////////////////////////////////////////
N
N///////////////////////////////////////////////////////////////////////////////
N// Hardware timer settings
N
N#define ECAT_TIMER_INC_P_MS              1 /**< \brief 312 ticks per ms*/
N
N
N///////////////////////////////////////////////////////////////////////////////
N// Interrupt and Timer Defines
N
N#ifndef DISABLE_ESC_INT
N    #define    DISABLE_ESC_INT()           {restore_intsts = PDI_Disable_Global_Interrupt();}
N#endif
N#ifndef ENABLE_ESC_INT
N    #define    ENABLE_ESC_INT()           {PDI_Restore_Global_Interrupt(restore_intsts);}
N#endif
N
N
N//TODO
N#ifndef HW_GetTimer
N    #define HW_GetTimer()       (PDI_GetTimer()) /**< \brief Access to the hardware timer*/
N#endif
N
N#ifndef HW_ClearTimer
N    #define HW_ClearTimer()       (PDI_ClearTimer()) /**< \brief Clear the hardware timer*/
N#endif
N
N
N#define HW_EscReadWord(WordValue, Address) HW_EscRead(((MEM_ADDR *)&(WordValue)),((UINT16)(Address)),2) /**< \brief 16Bit ESC read access*/
N#define HW_EscReadDWord(DWordValue, Address) HW_EscRead(((MEM_ADDR *)&(DWordValue)),((UINT16)(Address)),4) /**< \brief 32Bit ESC read access*/
N#define HW_EscReadByte(ByteValue, Address) HW_EscRead(((MEM_ADDR *)&(ByteValue)),((UINT16)(Address)),1) /**< \brief 8Bit ESC read access*/
N#define HW_EscReadMbxMem(pData,Address,Len) HW_EscRead(((MEM_ADDR *)(pData)),((UINT16)(Address)),(Len)) /**< \brief The mailbox data is stored in the local uC memory therefore the default read function is used.*/
N
N#define HW_EscReadWordIsr(WordValue, Address) HW_EscReadIsr(((MEM_ADDR *)&(WordValue)),((UINT16)(Address)),2) /**< \brief Interrupt specific 16Bit ESC read access*/
N#define HW_EscReadDWordIsr(DWordValue, Address) HW_EscReadIsr(((MEM_ADDR *)&(DWordValue)),((UINT16)(Address)),4) /**< \brief Interrupt specific 32Bit ESC read access*/
N#define HW_EscReadByteIsr(ByteValue, Address) HW_EscReadIsr(((MEM_ADDR *)&(ByteValue)),((UINT16)(Address)),1) /**< \brief Interrupt specific 8Bit ESC read access*/
N
N
N#define HW_EscWriteWord(WordValue, Address) HW_EscWrite(((MEM_ADDR *)&(WordValue)),((UINT16)(Address)),2) /**< \brief 16Bit ESC write access*/
N#define HW_EscWriteDWord(DWordValue, Address) HW_EscWrite(((MEM_ADDR *)&(DWordValue)),((UINT16)(Address)),4) /**< \brief 32Bit ESC write access*/
N#define HW_EscWriteByte(ByteValue, Address) HW_EscWrite(((MEM_ADDR *)&(ByteValue)),((UINT16)(Address)),1) /**< \brief 8Bit ESC write access*/
N#define HW_EscWriteMbxMem(pData,Address,Len) HW_EscWrite(((MEM_ADDR *)(pData)),((UINT16)(Address)),(Len)) /**< \brief The mailbox data is stored in the local uC memory therefore the default write function is used.*/
N
N#define HW_EscWriteWordIsr(WordValue, Address) HW_EscWriteIsr(((MEM_ADDR *)&(WordValue)),((UINT16)(Address)),2) /**< \brief Interrupt specific 16Bit ESC write access*/
N#define HW_EscWriteDWordIsr(DWordValue, Address) HW_EscWriteIsr(((MEM_ADDR *)&(DWordValue)),((UINT16)(Address)),4) /**< \brief Interrupt specific 32Bit ESC write access*/
N#define HW_EscWriteByteIsr(ByteValue, Address) HW_EscWriteIsr(((MEM_ADDR *)&(ByteValue)),((UINT16)(Address)),1) /**< \brief Interrupt specific 8Bit ESC write access*/
N
N///////////////////////////////////////////////////////////////////////////////
N
N#if _9252_HW_
S    #define PROTO
N#else
N    #define PROTO extern
N#endif
N
N///////////////////////////////////////////////////////////////////////////////
N// Global variables extern
NPROTO volatile unsigned int restore_intsts;
Xextern volatile unsigned int restore_intsts;
N
N///////////////////////////////////////////////////////////////////////////////
N// Global functions prototype
N
NPROTO UINT8 LAN9252_Init(void);
Xextern unsigned char LAN9252_Init(void);
NPROTO void HW_Release(void);
Xextern void HW_Release(void);
N
NPROTO UINT16 HW_GetALEventRegister(void);
Xextern unsigned short HW_GetALEventRegister(void);
NPROTO UINT16 HW_GetALEventRegister_Isr(void);
Xextern unsigned short HW_GetALEventRegister_Isr(void);
N
NPROTO void HW_ResetALEventMask(UINT16 intMask);
Xextern void HW_ResetALEventMask(unsigned short intMask);
NPROTO void HW_SetALEventMask(UINT16 intMask);
Xextern void HW_SetALEventMask(unsigned short intMask);
N
NPROTO void HW_EscRead( MEM_ADDR * pData, UINT16 Address, UINT16 Len );
Xextern void HW_EscRead( unsigned char * pData, unsigned short Address, unsigned short Len );
NPROTO void HW_EscReadIsr( MEM_ADDR *pData, UINT16 Address, UINT16 Len );
Xextern void HW_EscReadIsr( unsigned char *pData, unsigned short Address, unsigned short Len );
N
NPROTO void HW_EscWrite( MEM_ADDR *pData, UINT16 Address, UINT16 Len );
Xextern void HW_EscWrite( unsigned char *pData, unsigned short Address, unsigned short Len );
NPROTO void HW_EscWriteIsr( MEM_ADDR *pData, UINT16 Address, UINT16 Len );
Xextern void HW_EscWriteIsr( unsigned char *pData, unsigned short Address, unsigned short Len );
N
NPROTO void HW_DisableSyncManChannel(UINT8 channel);
Xextern void HW_DisableSyncManChannel(unsigned char channel);
NPROTO void HW_EnableSyncManChannel(UINT8 channel);
Xextern void HW_EnableSyncManChannel(unsigned char channel);
NPROTO TSYNCMAN ESCMEM *HW_GetSyncMan(UINT8 channel);
Xextern TSYNCMAN  *HW_GetSyncMan(unsigned char channel);
NPROTO void HW_SetLed(UINT8 RunLed,UINT8 ErrLed);
Xextern void HW_SetLed(unsigned char RunLed,unsigned char ErrLed);
N
NPROTO UINT32 PDI_GetTimer();
Xextern unsigned int PDI_GetTimer();
NPROTO void PDI_ClearTimer();
Xextern void PDI_ClearTimer();
N
NPROTO void PDI_Restore_Global_Interrupt(UINT32 int_sts);
Xextern void PDI_Restore_Global_Interrupt(unsigned int int_sts);
NPROTO UINT32 PDI_Disable_Global_Interrupt();
Xextern unsigned int PDI_Disable_Global_Interrupt();
N
N#undef    PROTO
N
N#endif
L 36 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\main.h" 2
N#include "ecatappl.h"
L 1 ".\etherCAT\ecatappl.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N \addtogroup EcatAppl EtherCAT application
N * @{
N */
N
N/**
N\file ecatappl.h
N\author EthercatSSC@beckhoff.com
N
N\version 5.12
N
N<br>Changes to version V5.11:<br>
NV5.12 EEPROM1: get read size from register 0x502.6<br>
N<br>Changes to version V5.10:<br>
NV5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
N<br>Changes to version V5.01:<br>
NV5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
N              Compare DC UINT configuration (by ESC Config data) vs. DC activation register settings<br>
N              Update 0x1C3x entries<br>
NV5.10 ECAT4: Update alignment macro for 8 to 15 bit alignments (16 and 32 Bit controllers)<br>
N             Bugfix calculate LED blink frequency<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N/*-----------------------------------------------------------------------------------------
N------
N------    Description
N------
N------    ecatappl.h
N------
N------    EtherCAT Slave Application
N------                                                                                                                                                                 ------
N-----------------------------------------------------------------------------------------*/
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N
N#include "ecat_def.h"
N
N
N#ifndef _ECATAPPL_H_
N#define _ECATAPPL_H_
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Defines and Types
N------
N-----------------------------------------------------------------------------------------*/
N
N/*Set to unsigned short to handle bit entries correct*/
N#define     BOOLEAN(x)                 UINT16 x:1 /**< \brief Macro to define BOOLEAN object entry*/
N#define     BIT1(x)                    UINT16 x:1 /**< \brief Macro to define BIT1 object entry*/
N#define     BIT2(x)                    UINT16 x:2 /**< \brief Macro to define BIT2 object entry*/
N#define     BIT3(x)                    UINT16 x:3 /**< \brief Macro to define BIT3 object entry*/
N#define     BIT4(x)                    UINT16 x:4 /**< \brief Macro to define BIT4 object entry*/
N#define     BIT5(x)                    UINT16 x:5 /**< \brief Macro to define BIT5 object entry*/
N#define     BIT6(x)                    UINT16 x:6 /**< \brief Macro to define BIT5 object entry*/
N#define     BIT7(x)                    UINT16 x:7 /**< \brief Macro to define BIT6 object entry*/
N#define     BIT8(x)                    UINT16 x:8 /**< \brief Macro to define BIT7 object entry*/
N#define     ALIGN0(x)
N#define     ALIGN1(x)                  UINT16 x:1; /**< \brief Macro to define ALIGN1 object entry*/
N#define     ALIGN2(x)                  UINT16 x:2; /**< \brief Macro to define ALIGN2 object entry*/
N#define     ALIGN3(x)                  UINT16 x:3; /**< \brief Macro to define ALIGN3 object entry*/
N#define     ALIGN4(x)                  UINT16 x:4; /**< \brief Macro to define ALIGN4 object entry*/
N#define     ALIGN5(x)                  UINT16 x:5; /**< \brief Macro to define ALIGN5 object entry*/
N#define     ALIGN6(x)                  UINT16 x:6; /**< \brief Macro to define ALIGN6 object entry*/
N#define     ALIGN7(x)                  UINT16 x:7; /**< \brief Macro to define ALIGN7 object entry*/
N#define     ALIGN8(x)                  UINT16 x:8; /**< \brief Macro to define ALIGN8 object entry*/
N#define     ALIGN9(x)                  UINT16 x:9; /**< \brief Macro to define ALIGN9 object entry*/
N#define     ALIGN10(x)                 UINT16 x:10; /**< \brief Macro to define ALIGN10 object entry*/
N#define     ALIGN11(x)                 UINT16 x:11; /**< \brief Macro to define ALIGN11 object entry*/
N#define     ALIGN12(x)                 UINT16 x:12; /**< \brief Macro to define ALIGN12 object entry*/
N#define     ALIGN13(x)                 UINT16 x:13; /**< \brief Macro to define ALIGN13 object entry*/
N#define     ALIGN14(x)                 UINT16 x:14; /**< \brief Macro to define ALIGN14 object entry*/
N#define     ALIGN15(x)                 UINT16 x:15; /**< \brief Macro to define ALIGN15 object entry*/
N/*ET9300 Project Handler :(#if CONTROLLER_16BIT || CONTROLLER_32BIT #else) lines 85 to 121 deleted*/
N#endif //_ECATAPPL_H_
N
N#if defined(_ECATAPPL_) && (_ECATAPPL_ == 1)
X#if 0L && (_ECATAPPL_ == 1)
S    #define PROTO
N#else
N    #define PROTO extern
N#endif
N
N#define ESC_RD 0
N#define ESC_WR 1
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Variables
N------
N-----------------------------------------------------------------------------------------*/
N
N
N/*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 138 to 140 deleted*/
N
NPROTO BOOL bEcatWaitForInputUpdate; /**< \brief Wait for input update*/
Xextern unsigned char bEcatWaitForInputUpdate;  
NPROTO BOOL bEtherCATRunLed; /**< \brief Current run LED value*/
Xextern unsigned char bEtherCATRunLed;  
NPROTO BOOL bEtherCATErrorLed; /**< \brief Current error LED value*/
Xextern unsigned char bEtherCATErrorLed;  
NPROTO BOOL bRunApplication; /**< \brief Indicates if the stack shall be running (if false the Hardware will be released)*/
Xextern unsigned char bRunApplication;  
N
N
N
N/*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 149 to 151 deleted*/
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Functions
N------
N-----------------------------------------------------------------------------------------*/
N
N
N
N
NPROTO    void       ECAT_CheckTimer(void);
Xextern    void       ECAT_CheckTimer(void);
NPROTO    void       PDI_Isr(void);
Xextern    void       PDI_Isr(void);
NPROTO    void       Sync0_Isr(void);
Xextern    void       Sync0_Isr(void);
NPROTO    void       Sync1_Isr(void);
Xextern    void       Sync1_Isr(void);
NPROTO    void       ECAT_Application(void);
Xextern    void       ECAT_Application(void);
NPROTO    void       PDO_ResetOutputs(void);
Xextern    void       PDO_ResetOutputs(void);
NPROTO    void       PDO_ReadInputs(void);
Xextern    void       PDO_ReadInputs(void);
NPROTO    void       PDO_InputMapping(void);
Xextern    void       PDO_InputMapping(void);
N
N/*ET9300 Project Handler :(#if UC_SET_ECAT_LED) lines 172 to 174 deleted*/
NPROTO    void       CalcSMCycleTime(void);
Xextern    void       CalcSMCycleTime(void);
NPROTO    UINT16     ESC_EepromAccess(UINT32 wordaddress, UINT16 wordsize, UINT16 MBXMEM *pData, UINT8 access);
Xextern    unsigned short     ESC_EepromAccess(unsigned int wordaddress, unsigned short wordsize, unsigned short  *pData, unsigned char access);
NPROTO    UINT16     ESC_EepromWriteCRC(void);
Xextern    unsigned short     ESC_EepromWriteCRC(void);
N
N/*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 183 to 185 deleted*/
N
N
N
N#undef PROTO
N/** @}*/
L 37 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\main.h" 2
N#include "applInterface.h"
L 1 ".\etherCAT\applInterface.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N\addtogroup EcatAppl EtherCAT application
N@{
N*/
N
N/**
N\file applInterface.h
N\author EthercatSSC@beckhoff.com
N\brief Definition of the application interface functions
N
N\version 5.13
N
N<br>Changes to version V5.12:<br>
NV5.13 COE4: update default entry name handling in case of 16Bit characters, add CoE Read/write indication functions<br>
N<br>Changes to version V5.11:<br>
NV5.12 APPL1: add optional application function called from the main loop (after mbx and esm are executed)<br>
NV5.12 EEPROM3: implement a store EEPROM timeout handler<br>
NV5.12 EOE1: move icmp sample to the sampleappl,add EoE application interface functions<br>
NV5.12 FOE1: update new interface,move the FoE sample to sampleappl,add FoE application callback functions<br>
N<br>Changes to version - :<br>
NV5.10.1 : Start file change log
N*/
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N
N
N#ifndef _APPL_INTERFACE_H_
N#define _APPL_INTERFACE_H_
N
N#include "ecat_def.h"
N#include <stdlib.h>
N#include <string.h>
N#include "esc.h"
L 1 ".\etherCAT\esc.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N * \addtogroup ESCRegister  ESC Register
N * @{
N */
N
N/**
N\file esc.h
N\author EthercatSSC@beckhoff.com
N\brief EtherCAT Slave Controller related defines and Types
N
N\version 5.10
N
N<br>Changes to version V5.01:<br>
NV5.10 ESC1: Update address register offset for 32Bit ESC access<br>
NV5.10 ESC2: Check if defined SM settings do not exceed the available DPRAM range (in error case AL Status 0x14 is returned)<br>
NV5.10 ESC3: Handle DC cControl register values in case of 32Bit ESC access (a Sync activation mask need to defined/used)<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N#include "ecat_def.h"
N
N#ifndef _ESC_H_
S#define _ESC_H_
S
S/*-----------------------------------------------------------------------------------------
S------
S------    Defines and Types
S------
S-----------------------------------------------------------------------------------------*/
S
S#define SIZEOF_SM_REGISTER                      8 /**< \brief Each SyncManger has 8Byte Configuration/Status Registers*/
S#define MAX_NO_OF_SYNC_MAN                      16/**< \brief Maximum Number of SyncManager channels supported by an ESC*/
S
S#define    BL_PAGE_SIZE        512
S
S/*---------------------------------------------
S-    ESC Offsets (Detailed Information about the registers are located in the ESC Datasheets e.g. ET1100 Datasheet http://www.beckhoff.com/english.asp?download/ethercat_development_products.htm?id=71003127100387)
S-----------------------------------------------*/
S#define ESC_INFO_OFFSET                         0x0000                               /**< \brief ESC information registers startoffset*/
S
S#define ESC_COMM_INFO_OFFSET                    0x0004                               /**< \brief Communication information registers startoffset*/
S
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 54 to 59 deleted*/
S#define ESC_DPRAM_SIZE_OFFSET                   0x0006                              /**< \brief Register Description: Size of the supported DPRAM in KB*/
S#define ESC_SM_CHANNELS_MASK                    0xFF00                              /**< \brief Mask based on ESC offset "ESC_COMM_INFO_OFFSET"*/
S#define ESC_SM_CHANNELS_SHIFT                   8                                   /**< \brief Bit shift based on ESC offset "ESC_COMM_INFO_OFFSET"*/
S#define ESC_DPRAM_SIZE_MASK                     0x00FF
S/*ET9300 Project Handler :(#if ESC_16BIT_ACCESS #else) lines 65 to 67 deleted*/
S
S#define ESC_FEATURES_OFFSET                     0x0008                              /**< \brief Register indicating ESC features*/
S#define ESC_DC_32BIT_MASK                       0x00000008                          /**< \brief register 0x0008.3 indicates if the DC Unit supports 32Bit/64Bit DC*/
S
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 73 to 75 deleted*/
S
S#define ESC_SLAVE_ADDRESS_OFFSET                0x0010                              /**< \brief Register Description: Address used for node addressing (FPxx commands)*/
S
S
S
S#define ESC_AL_CONTROL_OFFSET                   0x0120                              /**< \brief Register Description: Initiate State Transition of the Device State Machine*/
S#define ESC_AL_STATUS_OFFSET                    0x0130                              /**< \brief Register Description: Actual State of the Device State Machine*/
S#define ESC_AL_STATUS_CODE_OFFSET               0x0134                              /**< \brief Register Description: AL Status Code*/
S
S#define ESC_RUN_LED_OVERRIDE                    0x0138                              /**< \brief Register Description: Set Ecat Run indication via ESC. (not all ESC types support this feature)*/
S#define ESC_ERROR_LED_OVERRIDE                  0x0139                              /**< \brief Register Description: Set Ecat Error indication via ESC. (not all ESC types support this feature)*/
S
S#define ESC_PDI_CONTROL_OFFSET                  0x0140                              /**< \brief Register Description: Specifies the process data interface*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 89 to 91 deleted*/
S#define ESC_DEVICE_EMULATION                    0x0100                              /**< \brief Device emulation bit*/
S
S#define ESC_PDI_CONFIGURATION					0x0150								/**< \brief Register Description: PDI configuration register (values defined by the ESC configuration data)*/
S#define ESC_SYNC0_MAPPED_TO_ALEVENT				0x0800								/**< \brief bit indicating if the Sync0 event is mapped to the AL Event register*/
S#define ESC_SYNC1_MAPPED_TO_ALEVENT				0x8000								/**< \brief bit indicating if the Sync1 event is mapped to the AL Event register*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS || ESC_16BIT_ACCESS #else) lines 99 to 103 deleted*/
S
S
S#define ESC_AL_EVENTMASK_OFFSET                 0x0204                              /**< \brief Register Description: AL Event masking of the AL Event Request register Events for mapping to PDI IRQ signal*/
S#define ESC_AL_EVENT_OFFSET                     0x0220                              /**< \brief Register Description: "Mirror" register for ESC events*/
S
S#define ESC_WD_DIVIDER_OFFSET                   0x0400                              /**< \brief Register Description: Number of 25 MHz tics (minus 2) that represents the basic watchdog increment. (Default value is 100us = 2498)*/
S
S#define ESC_PD_WD_TIME                          0x0420                              /**< \brief Register Description: Number of basic watchdog increments (Default value with Watchdog divider 100us means 100ms Watchdog)*/
S#define ESC_PD_WD_STATE                         0x0440                              /**< \brief Register Description: Watchdog Status of Process Data (triggered by SyncManagers)*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 113 to 115 deleted*/
S#define ESC_PD_WD_TRIGGER_MASK                  0x0001                              /**< \brief Trigger state of the process data watchdog*/
S
S#define ESC_EEPROM_CONFIG_OFFSET                0x0500                              /**< \brief Register Description: EEPROM Access Configuration*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 120 to 138 deleted*/
S/*EEPROM config and access state bit mask (based on "ESC_EEPROM_CONFIG_OFFSET") - START*/
S#define ESC_EEPROM_ASSIGN_TO_PDI_MASK           0x0001                              /**< \brief Description (0x500.0): PDI has EEPROM control*/
S#define ESC_EEPROM_LOCKED_BY_PDI_MASK           0x0100                              /**< \brief Description (0x500.8): PDI locked EEPROM access*/
S/*EEPROM config and access state bit mask (based on "ESC_EEPROM_CONFIG_OFFSET") - END*/
S
S#define ESC_EEPROM_CONTROL_OFFSET               0x0502
S/* EEPROM command and status bit masks (based on "ESC_EEPROM_CONTROL_OFFSET") - START*/
S#define ESC_EEPROM_SUPPORTED_READBYTES_MASK     0x0040                              /**< \brief Description (0x502.6): Supported number of EEPROM read bytes: 0-> 4 Bytes; 1 -> 8 Bytes*/
S#define ESC_EEPROM_CMD_MASK                     0x0700                              /**< \brief Description (0x502.8:10): Command bit mask*/
S#define ESC_EEPROM_CMD_READ_MASK                0x0100                              /**< \brief Description (0x502.8): Currently executed read command*/
S#define ESC_EEPROM_CMD_WRITE_MASK               0x0200                              /**< \brief Description (0x502.9): Initialize Write Command*/
S#define ESC_EEPROM_CMD_RELOAD_MASK              0x0400                              /**< \brief Description (0x502.10): Trigger EEPROM reload*/
S#define ESC_EEPROM_ERROR_MASK                   0x7800                              /**< \brief Description : Mask all EEPROM error bits; Checksum error (0x0502.11); EEPROM not loaded (0x0502.12); Missing EEPROM Acknowledge (0x0502.13); Write Error (0x0502.14)*/
S#define ESC_EEPROM_ERROR_CRC                    0x0800                              /**< \brief Description (0x502.11): EEPROM CRC Error*/
S#define ESC_EEPROM_ERROR_LOAD                   0x1000                              /**< \brief Description (0x502.11): EEPROM loading status (0 = OK)*/
S#define ESC_EEPROM_ERROR_CMD_ACK                0x2000                              /**< \brief Description (0x502.13): EEPROM Acknowledge/Command*/
S#define ESC_EEPROM_BUSY_MASK                    0x8000                              /**< \brief Description (0x502.15): EEPROM Busy*/
S/* EEPROM command and status bit masks (based on "ESC_EEPROM_CONTROL_OFFSET") - END*/
S#define ESC_EEPROM_ADDRESS_OFFSET               0x0504
S#define ESC_EEPROM_DATA_OFFSET                  0x0508
S
S#define ESC_SYNCMAN_REG_OFFSET                  0x0800                              /**< \brief Register Description: Start address of the SyncManager Configuration/Staus registers*/
S#define ESC_SYNCMAN_CONTROL_OFFSET              0x0804                              /**< \brief Register Description: SyncManager Setting Register*/
S
S/*ET9300 Project Handler :(#if !ESC_32BIT_ACCESS && !ESC_16BIT_ACCESS) lines 164 to 166 deleted*/
S
S#define ESC_SYNCMAN_ACTIVE_OFFSET               0x0806                              /**< \brief Register Description: SyncManager Activation Register*/
S
S/*ET9300 Project Handler :(#if !ESC_32BIT_ACCESS && !ESC_16BIT_ACCESS) lines 172 to 174 deleted*/
S
S#define    ESC_SYSTEMTIME_OFFSET                0x0910                              /**< \brief Register Description: Local copy of the System Time*/
S
S#define    ESC_DC_UNIT_CONTROL_OFFSET           0x0980                              /**< \brief Register Description: Control registers for Cycle and Sync Unit (can be predefined with the "AssignActivate" Element in the device description, for further information see ETG.2000)*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 179 to 185 deleted*/
S#define ESC_DC_SYNC_UNIT_ACTIVE_MASK            0x0100                              /**< \brief Description (0x980.8): Sync Out Unit is activated*/
S#define ESC_DC_SYNC0_ACTIVE_MASK                0x0200                              /**< \brief Description (0x980.9): Sync0 generation is activated*/
S#define ESC_DC_SYNC1_ACTIVE_MASK                0x0400                              /**< \brief Description (0x980.10): Sync1 generation is activated*/
S#define ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK       0x0800                              /**< \brief Description (0x980.11): Sync Out Unit is activated automatic when System time was written*/
S/*ET9300 Project Handler :( #else) lines 190 to 196 deleted*/
S
S#define    ESC_DC_SYNC_STATUS		            0x098C                              /**< \brief Register Description: register 0x98E and 0x98F reflecting the status of Sync0 and Sync1*/
S
S#define ESC_DC_SYNC0_CYCLETIME_OFFSET           0x09A0                              /**< \brief Register Description: 32Bit Time between two consecutive SYNC0 pulses in ns*/
S#define ESC_DC_SYNC1_CYCLETIME_OFFSET           0x09A4                              /**< \brief Register Description: 32Bit Time between two consecutive SYNC1 pulses in ns*/
S
S
S/*ET9300 Project Handler :(#if FC1100_HW) lines 205 to 207 deleted*/
S
S
S/*---------------------------------------------
S-    Sync Manager
S-----------------------------------------------*/
S/** \brief SyncManager register structure*/
Stypedef struct STRUCT_PACKED_START
S{
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 217 to 259 deleted*/
S
S  UINT16                        PhysicalStartAddress; /**< \brief SyncManager address*/
S  UINT16                        Length; /**< \brief SyncManager length*/
S
S    UINT16                        Settings[2]; /**< \brief Register values 0x0804 : 0x0807*/
S
S/*Defines to access :
S* - SM Control register 0x0804
S* - SM Status register 0x0805
S*
S* all defines are based on 0x0804
S*/
S
S/*SyncManger control (0x0804) access*/
S#define SM_SETTING_CONTROL_OFFSET           0 /**< \brief Offset to value of register 0x0804*/
S#define SM_SETTING_MODE_MASK                0x0002 /**< \brief SyncManager mode mask*/
S#define SM_SETTING_MODE_THREE_BUFFER_VALUE  0x0000 /**< \brief SyncManager 3Buffer mode value*/
S#define SM_SETTING_MODE_ONE_BUFFER_VALUE    0x0002 /**< \brief SyncManager 1Buffer mode value*/
S#define SM_SETTING_DIRECTION_MASK           0x000C /**< \brief SyncManager direction mask*/
S#define SM_SETTING_DIRECTION_READ_VALUE     0x0000 /**< \brief SyncManager read direction*/
S#define SM_SETTING_DIRECTION_WRITE_VALUE    0x0004 /**< \brief SyncManager write direction*/
S#define SM_SETTING_WATCHDOG_VALUE           0x0040 /**< \brief SyncManager watchdog value*/
S
S/*SyncManger status (0x0805) access*/
S#define SM_STATUS_MBX_BUFFER_FULL           0x0800 /**< \brief Indicates in one buffer mode if buffer was completely written*/
S
S/*Defines to access :
S* - SM Active register 0x0806
S* - SM PDI Control register 0x0807
S*
S* all defines are based on 0x0806
S*/
S
S/*SyncManger active (0x0806) access*/
S#define SM_SETTING_ACTIVATE_OFFSET          1 /**< \brief Offset to value of register 0x0806*/
S#define SM_SETTING_ENABLE_VALUE             0x0001 /**< \brief SyncManager enable*/
S#define SM_SETTING_REPAET_REQ_MASK          0x0002 /**< \brief SyncManager Repeat request*/
S#define SM_SETTING_REPEAT_REQ_SHIFT         0 /**< \brief SyncManager Repeat request shift*/
S
S/*SyncManger PDI Control (0x0807) access*/
S#define SM_SETTING_PDI_DISABLE              0x0100  /**< \brief Bit0 of register 0x0807 (if 1 SM is disabled from PDI)*/
S#define SM_SETTING_REPEAT_ACK               0x0200 /**< \brief Bit1 of register 0x0807*/
S/*ET9300 Project Handler :(#if ESC_16BIT_ACCESS #else) lines 303 to 354 deleted*/
S}STRUCT_PACKED_END
STSYNCMAN;
S
S
S/*ET9300 Project Handler :(#if FC1100_HW) lines 361 to 363 deleted*/
S
N#endif //_ESC_H_
N/** @}*/
L 44 ".\etherCAT\applInterface.h" 2
N#include "ecatslv.h"
L 1 ".\etherCAT\ecatslv.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N * \addtogroup ESM EtherCAT State Machine
N * @{
N */
N
N/**
N\file ecatslv.h
N\author EthercatSSC@beckhoff.com
N
N\version 5.13
N
N<br>Changes to version V5.12:<br>
NV5.13 EMCY1: update emergency diagcodes for invalid sm configuration<br>
NV5.13 ESM1: local error handling update, ECAT_StateChange triggers only transitions from Op->Any or reject/accept a pending transition<br>
N<br>Changes to version V5.11:<br>
NV5.12 COE4: add timestamp object (0x10F8) and update diagnosis handling<br>
NV5.12 ECAT6: remove mailbox SyncManager if no mailbox is supported (SM0 Output, SM1 Input)<br>
N<br>Changes to version V5.10:<br>
NV5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
NV5.11 ECAT4: enhance SM/Sync monitoring for input/output only slaves<br>
NV5.11 ECAT9: add new AL Status Codes (ALSTATUSCODE_FW_SII_NOT_MATCH/0x0006, ALSTATUSCODE_FW_UPDATE_FAILED / 0x0007)<br>
NV5.11 ESM7: "add Sync define for 0x22 (""SYNCTYPE_SM2_SYNCHRON""), support value 0x22 for 0x1C33.1 (SM2 sync)"<br>
NV5.11 HW1: "move hardware independent functions ""HW_DisableSyncManChannel()"", ""HW_EnableSyncManChannel()"", ""HW_GetSyncMan()"", ""HW_ResetALEventMask()"", ""HW_SetALEventMask()"" to ecatalv.c"<br>
N<br>Changes to version V5.01:<br>
NV5.10 COE1: Define one entry description for all 0x1C3x objects and change data type of SI11,12,13 to UINT16 (according ETG.1020)<br>
NV5.10 ECAT12: Add new AL Status Codes (0x2E,0x52,0x70)<br>
NV5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
N              Compare DC UINT configuration (by ESC Config data) vs. DC activation register settings<br>
N              Update 0x1C3x entries<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N
N#include "ecat_def.h"
N
N/*ET9300 Project Handler :(#if EL9800_HW #elif FC1100_HW #elif MCI_HW) lines 47 to 53 deleted*/
N#include  "esc.h"
L 1 ".\etherCAT\esc.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N * \addtogroup ESCRegister  ESC Register
N * @{
N */
N
N/**
N\file esc.h
N\author EthercatSSC@beckhoff.com
N\brief EtherCAT Slave Controller related defines and Types
N
N\version 5.10
N
N<br>Changes to version V5.01:<br>
NV5.10 ESC1: Update address register offset for 32Bit ESC access<br>
NV5.10 ESC2: Check if defined SM settings do not exceed the available DPRAM range (in error case AL Status 0x14 is returned)<br>
NV5.10 ESC3: Handle DC cControl register values in case of 32Bit ESC access (a Sync activation mask need to defined/used)<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N#include "ecat_def.h"
N
N#ifndef _ESC_H_
S#define _ESC_H_
S
S/*-----------------------------------------------------------------------------------------
S------
S------    Defines and Types
S------
S-----------------------------------------------------------------------------------------*/
S
S#define SIZEOF_SM_REGISTER                      8 /**< \brief Each SyncManger has 8Byte Configuration/Status Registers*/
S#define MAX_NO_OF_SYNC_MAN                      16/**< \brief Maximum Number of SyncManager channels supported by an ESC*/
S
S#define    BL_PAGE_SIZE        512
S
S/*---------------------------------------------
S-    ESC Offsets (Detailed Information about the registers are located in the ESC Datasheets e.g. ET1100 Datasheet http://www.beckhoff.com/english.asp?download/ethercat_development_products.htm?id=71003127100387)
S-----------------------------------------------*/
S#define ESC_INFO_OFFSET                         0x0000                               /**< \brief ESC information registers startoffset*/
S
S#define ESC_COMM_INFO_OFFSET                    0x0004                               /**< \brief Communication information registers startoffset*/
S
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 54 to 59 deleted*/
S#define ESC_DPRAM_SIZE_OFFSET                   0x0006                              /**< \brief Register Description: Size of the supported DPRAM in KB*/
S#define ESC_SM_CHANNELS_MASK                    0xFF00                              /**< \brief Mask based on ESC offset "ESC_COMM_INFO_OFFSET"*/
S#define ESC_SM_CHANNELS_SHIFT                   8                                   /**< \brief Bit shift based on ESC offset "ESC_COMM_INFO_OFFSET"*/
S#define ESC_DPRAM_SIZE_MASK                     0x00FF
S/*ET9300 Project Handler :(#if ESC_16BIT_ACCESS #else) lines 65 to 67 deleted*/
S
S#define ESC_FEATURES_OFFSET                     0x0008                              /**< \brief Register indicating ESC features*/
S#define ESC_DC_32BIT_MASK                       0x00000008                          /**< \brief register 0x0008.3 indicates if the DC Unit supports 32Bit/64Bit DC*/
S
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 73 to 75 deleted*/
S
S#define ESC_SLAVE_ADDRESS_OFFSET                0x0010                              /**< \brief Register Description: Address used for node addressing (FPxx commands)*/
S
S
S
S#define ESC_AL_CONTROL_OFFSET                   0x0120                              /**< \brief Register Description: Initiate State Transition of the Device State Machine*/
S#define ESC_AL_STATUS_OFFSET                    0x0130                              /**< \brief Register Description: Actual State of the Device State Machine*/
S#define ESC_AL_STATUS_CODE_OFFSET               0x0134                              /**< \brief Register Description: AL Status Code*/
S
S#define ESC_RUN_LED_OVERRIDE                    0x0138                              /**< \brief Register Description: Set Ecat Run indication via ESC. (not all ESC types support this feature)*/
S#define ESC_ERROR_LED_OVERRIDE                  0x0139                              /**< \brief Register Description: Set Ecat Error indication via ESC. (not all ESC types support this feature)*/
S
S#define ESC_PDI_CONTROL_OFFSET                  0x0140                              /**< \brief Register Description: Specifies the process data interface*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 89 to 91 deleted*/
S#define ESC_DEVICE_EMULATION                    0x0100                              /**< \brief Device emulation bit*/
S
S#define ESC_PDI_CONFIGURATION					0x0150								/**< \brief Register Description: PDI configuration register (values defined by the ESC configuration data)*/
S#define ESC_SYNC0_MAPPED_TO_ALEVENT				0x0800								/**< \brief bit indicating if the Sync0 event is mapped to the AL Event register*/
S#define ESC_SYNC1_MAPPED_TO_ALEVENT				0x8000								/**< \brief bit indicating if the Sync1 event is mapped to the AL Event register*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS || ESC_16BIT_ACCESS #else) lines 99 to 103 deleted*/
S
S
S#define ESC_AL_EVENTMASK_OFFSET                 0x0204                              /**< \brief Register Description: AL Event masking of the AL Event Request register Events for mapping to PDI IRQ signal*/
S#define ESC_AL_EVENT_OFFSET                     0x0220                              /**< \brief Register Description: "Mirror" register for ESC events*/
S
S#define ESC_WD_DIVIDER_OFFSET                   0x0400                              /**< \brief Register Description: Number of 25 MHz tics (minus 2) that represents the basic watchdog increment. (Default value is 100us = 2498)*/
S
S#define ESC_PD_WD_TIME                          0x0420                              /**< \brief Register Description: Number of basic watchdog increments (Default value with Watchdog divider 100us means 100ms Watchdog)*/
S#define ESC_PD_WD_STATE                         0x0440                              /**< \brief Register Description: Watchdog Status of Process Data (triggered by SyncManagers)*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 113 to 115 deleted*/
S#define ESC_PD_WD_TRIGGER_MASK                  0x0001                              /**< \brief Trigger state of the process data watchdog*/
S
S#define ESC_EEPROM_CONFIG_OFFSET                0x0500                              /**< \brief Register Description: EEPROM Access Configuration*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 120 to 138 deleted*/
S/*EEPROM config and access state bit mask (based on "ESC_EEPROM_CONFIG_OFFSET") - START*/
S#define ESC_EEPROM_ASSIGN_TO_PDI_MASK           0x0001                              /**< \brief Description (0x500.0): PDI has EEPROM control*/
S#define ESC_EEPROM_LOCKED_BY_PDI_MASK           0x0100                              /**< \brief Description (0x500.8): PDI locked EEPROM access*/
S/*EEPROM config and access state bit mask (based on "ESC_EEPROM_CONFIG_OFFSET") - END*/
S
S#define ESC_EEPROM_CONTROL_OFFSET               0x0502
S/* EEPROM command and status bit masks (based on "ESC_EEPROM_CONTROL_OFFSET") - START*/
S#define ESC_EEPROM_SUPPORTED_READBYTES_MASK     0x0040                              /**< \brief Description (0x502.6): Supported number of EEPROM read bytes: 0-> 4 Bytes; 1 -> 8 Bytes*/
S#define ESC_EEPROM_CMD_MASK                     0x0700                              /**< \brief Description (0x502.8:10): Command bit mask*/
S#define ESC_EEPROM_CMD_READ_MASK                0x0100                              /**< \brief Description (0x502.8): Currently executed read command*/
S#define ESC_EEPROM_CMD_WRITE_MASK               0x0200                              /**< \brief Description (0x502.9): Initialize Write Command*/
S#define ESC_EEPROM_CMD_RELOAD_MASK              0x0400                              /**< \brief Description (0x502.10): Trigger EEPROM reload*/
S#define ESC_EEPROM_ERROR_MASK                   0x7800                              /**< \brief Description : Mask all EEPROM error bits; Checksum error (0x0502.11); EEPROM not loaded (0x0502.12); Missing EEPROM Acknowledge (0x0502.13); Write Error (0x0502.14)*/
S#define ESC_EEPROM_ERROR_CRC                    0x0800                              /**< \brief Description (0x502.11): EEPROM CRC Error*/
S#define ESC_EEPROM_ERROR_LOAD                   0x1000                              /**< \brief Description (0x502.11): EEPROM loading status (0 = OK)*/
S#define ESC_EEPROM_ERROR_CMD_ACK                0x2000                              /**< \brief Description (0x502.13): EEPROM Acknowledge/Command*/
S#define ESC_EEPROM_BUSY_MASK                    0x8000                              /**< \brief Description (0x502.15): EEPROM Busy*/
S/* EEPROM command and status bit masks (based on "ESC_EEPROM_CONTROL_OFFSET") - END*/
S#define ESC_EEPROM_ADDRESS_OFFSET               0x0504
S#define ESC_EEPROM_DATA_OFFSET                  0x0508
S
S#define ESC_SYNCMAN_REG_OFFSET                  0x0800                              /**< \brief Register Description: Start address of the SyncManager Configuration/Staus registers*/
S#define ESC_SYNCMAN_CONTROL_OFFSET              0x0804                              /**< \brief Register Description: SyncManager Setting Register*/
S
S/*ET9300 Project Handler :(#if !ESC_32BIT_ACCESS && !ESC_16BIT_ACCESS) lines 164 to 166 deleted*/
S
S#define ESC_SYNCMAN_ACTIVE_OFFSET               0x0806                              /**< \brief Register Description: SyncManager Activation Register*/
S
S/*ET9300 Project Handler :(#if !ESC_32BIT_ACCESS && !ESC_16BIT_ACCESS) lines 172 to 174 deleted*/
S
S#define    ESC_SYSTEMTIME_OFFSET                0x0910                              /**< \brief Register Description: Local copy of the System Time*/
S
S#define    ESC_DC_UNIT_CONTROL_OFFSET           0x0980                              /**< \brief Register Description: Control registers for Cycle and Sync Unit (can be predefined with the "AssignActivate" Element in the device description, for further information see ETG.2000)*/
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 179 to 185 deleted*/
S#define ESC_DC_SYNC_UNIT_ACTIVE_MASK            0x0100                              /**< \brief Description (0x980.8): Sync Out Unit is activated*/
S#define ESC_DC_SYNC0_ACTIVE_MASK                0x0200                              /**< \brief Description (0x980.9): Sync0 generation is activated*/
S#define ESC_DC_SYNC1_ACTIVE_MASK                0x0400                              /**< \brief Description (0x980.10): Sync1 generation is activated*/
S#define ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK       0x0800                              /**< \brief Description (0x980.11): Sync Out Unit is activated automatic when System time was written*/
S/*ET9300 Project Handler :( #else) lines 190 to 196 deleted*/
S
S#define    ESC_DC_SYNC_STATUS		            0x098C                              /**< \brief Register Description: register 0x98E and 0x98F reflecting the status of Sync0 and Sync1*/
S
S#define ESC_DC_SYNC0_CYCLETIME_OFFSET           0x09A0                              /**< \brief Register Description: 32Bit Time between two consecutive SYNC0 pulses in ns*/
S#define ESC_DC_SYNC1_CYCLETIME_OFFSET           0x09A4                              /**< \brief Register Description: 32Bit Time between two consecutive SYNC1 pulses in ns*/
S
S
S/*ET9300 Project Handler :(#if FC1100_HW) lines 205 to 207 deleted*/
S
S
S/*---------------------------------------------
S-    Sync Manager
S-----------------------------------------------*/
S/** \brief SyncManager register structure*/
Stypedef struct STRUCT_PACKED_START
S{
S/*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 217 to 259 deleted*/
S
S  UINT16                        PhysicalStartAddress; /**< \brief SyncManager address*/
S  UINT16                        Length; /**< \brief SyncManager length*/
S
S    UINT16                        Settings[2]; /**< \brief Register values 0x0804 : 0x0807*/
S
S/*Defines to access :
S* - SM Control register 0x0804
S* - SM Status register 0x0805
S*
S* all defines are based on 0x0804
S*/
S
S/*SyncManger control (0x0804) access*/
S#define SM_SETTING_CONTROL_OFFSET           0 /**< \brief Offset to value of register 0x0804*/
S#define SM_SETTING_MODE_MASK                0x0002 /**< \brief SyncManager mode mask*/
S#define SM_SETTING_MODE_THREE_BUFFER_VALUE  0x0000 /**< \brief SyncManager 3Buffer mode value*/
S#define SM_SETTING_MODE_ONE_BUFFER_VALUE    0x0002 /**< \brief SyncManager 1Buffer mode value*/
S#define SM_SETTING_DIRECTION_MASK           0x000C /**< \brief SyncManager direction mask*/
S#define SM_SETTING_DIRECTION_READ_VALUE     0x0000 /**< \brief SyncManager read direction*/
S#define SM_SETTING_DIRECTION_WRITE_VALUE    0x0004 /**< \brief SyncManager write direction*/
S#define SM_SETTING_WATCHDOG_VALUE           0x0040 /**< \brief SyncManager watchdog value*/
S
S/*SyncManger status (0x0805) access*/
S#define SM_STATUS_MBX_BUFFER_FULL           0x0800 /**< \brief Indicates in one buffer mode if buffer was completely written*/
S
S/*Defines to access :
S* - SM Active register 0x0806
S* - SM PDI Control register 0x0807
S*
S* all defines are based on 0x0806
S*/
S
S/*SyncManger active (0x0806) access*/
S#define SM_SETTING_ACTIVATE_OFFSET          1 /**< \brief Offset to value of register 0x0806*/
S#define SM_SETTING_ENABLE_VALUE             0x0001 /**< \brief SyncManager enable*/
S#define SM_SETTING_REPAET_REQ_MASK          0x0002 /**< \brief SyncManager Repeat request*/
S#define SM_SETTING_REPEAT_REQ_SHIFT         0 /**< \brief SyncManager Repeat request shift*/
S
S/*SyncManger PDI Control (0x0807) access*/
S#define SM_SETTING_PDI_DISABLE              0x0100  /**< \brief Bit0 of register 0x0807 (if 1 SM is disabled from PDI)*/
S#define SM_SETTING_REPEAT_ACK               0x0200 /**< \brief Bit1 of register 0x0807*/
S/*ET9300 Project Handler :(#if ESC_16BIT_ACCESS #else) lines 303 to 354 deleted*/
S}STRUCT_PACKED_END
STSYNCMAN;
S
S
S/*ET9300 Project Handler :(#if FC1100_HW) lines 361 to 363 deleted*/
S
N#endif //_ESC_H_
N/** @}*/
L 50 ".\etherCAT\ecatslv.h" 2
N#include "9252_HW.h"
N
N#ifndef _ECATSLV_H_
N#define _ECATSLV_H_
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Defines and Types
N------
N-----------------------------------------------------------------------------------------*/
N
N#ifndef OBJGETNEXTSTR
N    /* the old definition was not working with all compilers */
N    /* old:    #define    OBJGETNEXTSTR(p)    ( (OBJCONST CHAR OBJMEM * )( ((UINT32) p) + OBJSTRLEN( (OBJCONST CHAR OBJMEM *) p ) + 1 ) ) */
N    #define    OBJGETNEXTSTR(p)    ( (OBJCONST CHAR OBJMEM * )(  &((p)[OBJSTRLEN( (OBJCONST CHAR OBJMEM *) (p) ) + 1]) ) ) /**< \brief Macro to get next name within the objetc name string*/
N#endif
N
N/*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 75 to 115 deleted*/
N#ifndef LO_BYTE
N    #define    LO_BYTE                            0 /**< \brief LowByte within an WORD*/
N#endif
N
N#ifndef HI_BYTE
N    #define    HI_BYTE                            1 /**< \brief HighByte within an WORD*/
N#endif
N
N#ifndef LOLO_BYTE
N    #define    LOLO_BYTE                          0 /**< \brief LowLowByte within an DWORD*/
N#endif
N
N#ifndef LOHI_BYTE
N    #define    LOHI_BYTE                          1 /**< \brief LowHighByte within an DWORD*/
N#endif
N
N#ifndef HILO_BYTE
N    #define    HILO_BYTE                         2 /**< \brief HighLowByte within an DWORD*/
N#endif
N
N#ifndef HIHI_BYTE
N    #define    HIHI_BYTE                          3 /**< \brief HighHighByte within an DWORD*/
N#endif
N
N#ifndef LO_WORD
N    #define    LO_WORD                            0 /**< \brief LowWord within an DWORD*/
N#endif
N
N#ifndef HI_WORD
N    #define    HI_WORD                            1 /**< \brief HighWord within an DWORD*/
N#endif
N
N#ifndef SWAPWORD
N    #define    SWAPWORD(x)                        (x) /**< \brief Macro to swap a WORD*/
N#endif
N
N#ifndef SWAPDWORD
N    #define    SWAPDWORD(x)                     (x) /**< \brief Macro to swap a DWORD*/
N#endif
N
N#ifndef LOBYTE
N    #define    LOBYTE(x)                        ((x)&0xFF) /**< \brief LowByte mask*/
N#endif
N
N#ifndef HIBYTE
N    #define    HIBYTE(x)                        (((x)&0xFF00)>>8)/**< \brief HighwByte mask*/
N#endif
N
N#ifndef LOLOBYTE
N    #define    LOLOBYTE(x)                        ((x)&0xFF)/**< \brief LowLowByte mask*/
N#endif
N
N#ifndef LOHIBYTE
N    #define    LOHIBYTE(x)                        (((x)&0xFF00)>>8)/**< \brief LowHighByte mask*/
N#endif
N
N#ifndef HILOBYTE
N    #define    HILOBYTE(x)                        (((x)&0xFF0000)>>16)/**< \brief HighLowByte mask*/
N#endif
N
N#ifndef HIHIBYTE
N    #define    HIHIBYTE(x)                        (((x)&0xFF000000)>>24)/**< \brief HighHighByte mask*/
N#endif
N
N#ifndef LOWORD
N    #define    LOWORD(x)                        ((x)&0xFFFF)/**< \brief LowWord mask*/
N#endif
N
N#ifndef HIWORD
N    #define    HIWORD(x)                        (((x)&0xFFFF0000)>>16)/**< \brief HighByte mask*/
N#endif
N
N#ifndef BIT2BYTE
N    #define    BIT2BYTE(x)        (((x)+7)>>3) /**< \brief Macro to convert Bit size to Byte size (round up)*/
N#endif
N
N#ifndef BYTE2BIT
N    #define    BYTE2BIT(x)        ((x)<<3) /**< \brief Macro to convert Byte size to Bit size*/
N#endif
N
N#ifndef BIT2WORD
N    #define    BIT2WORD(x)        (((x)+15)>>4) /**< \brief Macro to convert Bit size to Word size (round up)*/
N#endif
N
N#ifndef BYTE2WORD
N    #define    BYTE2WORD(x)    (((x)+1)>>1) /**< \brief Macro to convert Bytes size to Word size (round up)*/
N#endif
N
N#ifndef ROUNDUPBYTE2WORD
N    #define    ROUNDUPBYTE2WORD(x)    ((((x)+1)>>1)<<1) /**< \brief Round up Byte size to even number of Words*/
N#endif
N
N
N/*---------------------------------------------
N-    State defines
N-----------------------------------------------*/
N#define     STATE_INIT                        ((UINT8) 0x01) /**< \brief State INIT*/
N#define     STATE_PREOP                       ((UINT8) 0x02) /**< \brief State PreOP*/
N#define     STATE_BOOT                        ((UINT8) 0x03) /**< \brief State BOOT*/
N#define     STATE_SAFEOP                      ((UINT8) 0x04) /**< \brief State SafeOP*/
N#define     STATE_OP                          ((UINT8) 0x08) /**< \brief State OP*/
N
N#define     STATE_MASK                        ((UINT8) 0x0F) /**< \brief State mask*/
N#define     STATE_CHANGE                      ((UINT8) 0x10) /**< \brief State change (Error indication/acknowledge) mask and value*/
N#define     STATE_DEVID                       ((UINT8) 0x20) /**< \brief Request/response Explicit device ID*/
N#define     STATE_VALID(x)                    ((((x) & STATE_MASK) == STATE_INIT) || (((x) & STATE_MASK) == STATE_PREOP) || (((x) & STATE_MASK) == STATE_SAFEOP) || (((x) & STATE_MASK) == STATE_OP)) /**< \brief Check if one of the mandatory supported state values are set*/
N
N#define     BOOT_2_INIT                       ((UINT8)((STATE_BOOT) << 4) | (STATE_INIT)) /**< \brief State transition BOOT to INIT*/
N#define     BOOT_2_PREOP                      ((UINT8)((STATE_BOOT) << 4) | (STATE_PREOP)) /**< \brief State transition BOOT to INIT*/
N#define     BOOT_2_SAFEOP                     ((UINT8)((STATE_BOOT) << 4) | (STATE_SAFEOP)) /**< \brief State transition BOOT to INIT*/
N#define     BOOT_2_OP                         ((UINT8)((STATE_BOOT) << 4) | (STATE_OP)) /**< \brief State transition BOOT to INIT*/
N
N#define     INIT_2_BOOT                       ((UINT8)((STATE_INIT) << 4) | (STATE_BOOT)) /**< \brief State transition INIT to BOOT*/
N#define     PREOP_2_BOOT                      ((UINT8)((STATE_PREOP) << 4) | (STATE_BOOT)) /**< \brief State transition PREOP to BOOT*/
N#define     SAFEOP_2_BOOT                     ((UINT8)((STATE_SAFEOP) << 4) | (STATE_BOOT)) /**< \brief State transition SAFEOP to BOOT*/
N#define     OP_2_BOOT                         ((UINT8)((STATE_OP) << 4) | (STATE_BOOT)) /**< \brief State transition OP to BOOT*/
N
N#define     INIT_2_INIT                       ((UINT8)((STATE_INIT) << 4) | (STATE_INIT)) /**< \brief State transition INIT to INIT*/
N#define     INIT_2_PREOP                      ((UINT8)((STATE_INIT) << 4) | (STATE_PREOP)) /**< \brief State transition INIT to PREOP*/
N#define     INIT_2_SAFEOP                     ((UINT8)((STATE_INIT) << 4) | (STATE_SAFEOP)) /**< \brief State transition INIT to SAFEOP*/
N#define     INIT_2_OP                         ((UINT8)((STATE_INIT) << 4) | (STATE_OP)) /**< \brief State transition INIT to OP*/
N
N#define     PREOP_2_INIT                      ((UINT8)((STATE_PREOP) << 4) | (STATE_INIT)) /**< \brief State transition PREOP to INIT*/
N#define     PREOP_2_PREOP                     ((UINT8)((STATE_PREOP) << 4) | (STATE_PREOP)) /**< \brief State transition PREOP to PREOP*/
N#define     PREOP_2_SAFEOP                    ((UINT8)((STATE_PREOP) << 4) | (STATE_SAFEOP)) /**< \brief State transition PREOP to SAFEOP*/
N#define     PREOP_2_OP                        ((UINT8)((STATE_PREOP) << 4) | (STATE_OP)) /**< \brief State transition PREOP to OP*/
N
N#define     SAFEOP_2_INIT                     ((UINT8)((STATE_SAFEOP) << 4) | (STATE_INIT)) /**< \brief State transition SAFEOP to INIT*/
N#define     SAFEOP_2_PREOP                    ((UINT8)((STATE_SAFEOP) << 4) | (STATE_PREOP)) /**< \brief State transition SAFEOP to PREOP*/
N#define     SAFEOP_2_SAFEOP                   ((UINT8)((STATE_SAFEOP) << 4) | (STATE_SAFEOP)) /**< \brief State transition SAFEOP to SAFEOP*/
N#define     SAFEOP_2_OP                       ((UINT8)((STATE_SAFEOP) << 4) |( STATE_OP)) /**< \brief State transition SAFEOP to OP*/
N
N#define     OP_2_INIT                         ((UINT8)((STATE_OP) << 4) | (STATE_INIT)) /**< \brief State transition OP to INIT*/
N#define     OP_2_PREOP                        ((UINT8)((STATE_OP) << 4) | (STATE_PREOP)) /**< \brief State transition OP to PREOP*/
N#define     OP_2_SAFEOP                       ((UINT8)((STATE_OP) << 4) | (STATE_SAFEOP)) /**< \brief State transition OP to SAFEOP*/
N#define     OP_2_OP                           ((UINT8)((STATE_OP) << 4) | (STATE_OP)) /**< \brief State transition OP to OP*/
N
N
N/*-------------------------------------------------------------------------------------------------------------------------
N
N ESM transition error codes
N
N*/
N/*ECATCHANGE_START(V5.13) EMCY1*/
N#define    SYNCMANCHSIZE                                            0x00 /**< \brief Emergency and Diagnosis code for an invalid  SyncManager size*/
N#define    SYNCMANCHADDRESS                                         0x01 /**< \brief Emergency and Diagnosis code for an invalid SyncManager address*/
N#define    SYNCMANCHSETTINGS                                        0x02 /**< \brief Emergency and Diagnosis code for an invalid SyncManager settings*/
N#define    ERROR_SYNCMANCH(code, channel)                    ((code)+((channel)<<2)) /**< \brief Macro to add SyncManager channel*/
N
N/*ECATCHANGE_END(V5.13) EMCY1*/
N#define    ERROR_SYNCMANCHADDRESS(channel)                    ((SYNCMANCHADDRESS)+((channel)<<2)) /**< \brief Macro to add SyncManager channel*/
N#define    ERROR_SYNCMANCHSIZE(channel)                          ((SYNCMANCHSIZE)+((channel)<<2)) /**< \brief Macro to add SyncManager channel*/
N#define    ERROR_SYNCMANCHSETTINGS(channel)                    ((SYNCMANCHSETTINGS)+((channel)<<2)) /**< \brief Macro to add SyncManager channel*/
N#define    ERROR_SYNCTYPES                                        0x80 /**< \brief Emergency and Diagnosis code for an invalid Sync types*/
N#define    ERROR_DCSYNCCONTROL                                    0x81 /**< \brief Emergency and Diagnosis code for an invalid DC Sync control*/
N#define    ERROR_DCSYNC0CYCLETIME                                0x82 /**< \brief Emergency and Diagnosis code for an invalid Sync0 cycle time*/
N#define    ERROR_DCSYNC1CYCLETIME                                0x83 /**< \brief Emergency and Diagnosis code for an invalid Sync1 cycle time*/
N#define    ERROR_DCCYCLEPARAMETER                                0x84 /**< \brief Emergency and Diagnosis code for an invalid Cycle parameter*/
N#define    ERROR_DCLATCHCONTROL                                    0x85 /**< \brief Emergency and Diagnosis code for an invalid Latch control*/
N
N#define    ERROR_INVALIDSTATE                                    0xF0 /**< \brief Emergency and Diagnosis code for an invalid State*/
N#define    ERROR_NOMEMORY                                            0xF1 /**< \brief Emergency and Diagnosis code for no memory*/
N#define    ERROR_OBJECTDICTIONARY                                0xF2 /**< \brief Emergency and Diagnosis code for generic object dictionary error*/
N#define    ERROR_NOSYNCMANACCESS                                0xF3 /**< \brief Emergency and Diagnosis code for no SyncManager access*/
N#define    ERROR_NOOFRXPDOS                                        0xF4 /**< \brief Emergency and Diagnosis code for no RxPDOs*/
N#define    ERROR_NOOFTXPDOS                                        0xF5 /**< \brief Emergency and Diagnosis code for no TxPDOs*/
N#define    ERROR_STATECHANGE                                        0xF6 /**< \brief Emergency and Diagnosis code state change error*/
N
N#define    NOERROR_NOSTATECHANGE                                0xFE /**< \brief Indicates no state change*/
N#define    NOERROR_INWORK                                            0xFF /**< \brief Indication for no error but operation is pending*/
N
N#define    EMCY_SM_ERRORCODE                                        0xA000 /**< \brief Emergency and Diagnosis code for an SyncManager error*/
N#define    EMCY_SM_DEVICESPECIFIC                                0xFF00 /**< \brief Emergency and Diagnosis code for a device specific error*/
N
N
N/*---------------------------------------------
N-    AL Status Codes
N-----------------------------------------------*/
N#define    ALSTATUSCODE_NOERROR                        0x0000 /**< \brief No error*/
N#define    ALSTATUSCODE_UNSPECIFIEDERROR               0x0001 /**< \brief Unspecified error*/
N#define    ALSTATUSCODE_NOMEMORY                       0x0002 /**< \brief No Memory*/
N#define    ALSTATUSCODE_INVALID_REVISION               0x0004 /**< \brief Output/Input mapping is not valid for this hardware or software revision (0x1018:03)*/
N#define    ALSTATUSCODE_FW_SII_NOT_MATCH               0x0006 /**< \brief Firmware and EEPROM do not match. Slave needs BOOT-INIT transition*/
N#define    ALSTATUSCODE_FW_UPDATE_FAILED               0x0007 /**< \brief Firmware update not successful. Old firmware still running*/
N#define    ALSTATUSCODE_INVALIDALCONTROL               0x0011 /**< \brief Invalid requested state change*/
N#define    ALSTATUSCODE_UNKNOWNALCONTROL               0x0012 /**< \brief Unknown requested state*/
N#define    ALSTATUSCODE_BOOTNOTSUPP                    0x0013 /**< \brief Bootstrap not supported*/
N#define    ALSTATUSCODE_NOVALIDFIRMWARE                0x0014 /**< \brief No valid firmware*/
N#define    ALSTATUSCODE_INVALIDMBXCFGINBOOT            0x0015 /**< \brief Invalid mailbox configuration (BOOT state)*/
N#define    ALSTATUSCODE_INVALIDMBXCFGINPREOP           0x0016 /**< \brief Invalid mailbox configuration (PreOP state)*/
N#define    ALSTATUSCODE_INVALIDSMCFG                   0x0017 /**< \brief Invalid sync manager configuration*/
N#define    ALSTATUSCODE_NOVALIDINPUTS                  0x0018 /**< \brief No valid inputs available*/
N#define    ALSTATUSCODE_NOVALIDOUTPUTS                 0x0019 /**< \brief No valid outputs*/
N#define    ALSTATUSCODE_SYNCERROR                      0x001A /**< \brief Synchronization error*/
N#define    ALSTATUSCODE_SMWATCHDOG                     0x001B /**< \brief Sync manager watchdog*/
N#define    ALSTATUSCODE_SYNCTYPESNOTCOMPATIBLE         0x001C /**< \brief Invalid Sync Manager Types*/
N#define    ALSTATUSCODE_INVALIDSMOUTCFG                0x001D /**< \brief Invalid Output Configuration*/
N#define    ALSTATUSCODE_INVALIDSMINCFG                 0x001E /**< \brief Invalid Input Configuration*/
N#define    ALSTATUSCODE_INVALIDWDCFG                   0x001F /**< \brief Invalid Watchdog Configuration*/
N#define    ALSTATUSCODE_WAITFORCOLDSTART               0x0020 /**< \brief Slave needs cold start*/
N#define    ALSTATUSCODE_WAITFORINIT                    0x0021 /**< \brief Slave needs INIT*/
N#define    ALSTATUSCODE_WAITFORPREOP                   0x0022 /**< \brief Slave needs PREOP*/
N#define    ALSTATUSCODE_WAITFORSAFEOP                  0x0023 /**< \brief Slave needs SAFEOP*/
N#define    ALSTATUSCODE_INVALIDINPUTMAPPING            0x0024 /**< \brief Invalid Input Mapping*/
N#define    ALSTATUSCODE_INVALIDOUTPUTMAPPING           0x0025 /**< \brief Invalid Output Mapping*/
N#define    ALSTATUSCODE_INCONSISTENTSETTINGS           0x0026 /**< \brief Inconsistent Settings*/
N#define    ALSTATUSCODE_FREERUNNOTSUPPORTED            0x0027 /**< \brief FreeRun not supported*/
N#define    ALSTATUSCODE_SYNCHRONNOTSUPPORTED           0x0028 /**< \brief SyncMode not supported*/
N#define    ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE        0x0029 /**< \brief FreeRun needs 3Buffer Mode*/
N#define    ALSTATUSCODE_BACKGROUNDWATCHDOG             0x002A /**< \brief Background Watchdog*/
N#define    ALSTATUSCODE_NOVALIDINPUTSANDOUTPUTS        0x002B /**< \brief No Valid Inputs and Outputs*/
N#define    ALSTATUSCODE_FATALSYNCERROR                 0x002C /**< \brief Fatal Sync Error*/
N#define    ALSTATUSCODE_NOSYNCERROR                    0x002D /**< \brief No Sync Error*/
N#define    ALSTATUSCODE_CYCLETIMETOOSMALL              0x002E /**< \brief EtherCAT cycle time smaller Minimum Cycle Time supported by slave*/
N#define    ALSTATUSCODE_DCINVALIDSYNCCFG               0x0030 /**< \brief Invalid DC SYNCH Configuration*/
N#define    ALSTATUSCODE_DCINVALIDLATCHCFG              0x0031 /**< \brief Invalid DC Latch Configuration*/
N#define    ALSTATUSCODE_DCPLLSYNCERROR                 0x0032 /**< \brief PLL Error*/
N#define    ALSTATUSCODE_DCSYNCIOERROR                  0x0033 /**< \brief DC Sync IO Error*/
N#define    ALSTATUSCODE_DCSYNCMISSEDERROR              0x0034 /**< \brief DC Sync Timeout Error*/
N#define    ALSTATUSCODE_DCINVALIDSYNCCYCLETIME         0x0035 /**< \brief DC Invalid Sync Cycle Time*/
N#define    ALSTATUSCODE_DCSYNC0CYCLETIME               0x0036 /**< \brief DC Sync0 Cycle Time*/
N#define    ALSTATUSCODE_DCSYNC1CYCLETIME               0x0037 /**< \brief DC Sync1 Cycle Time*/
N#define    ALSTATUSCODE_MBX_AOE                        0x0041 /**< \brief MBX_AOE*/
N#define    ALSTATUSCODE_MBX_EOE                        0x0042 /**< \brief MBX_EOE*/
N#define    ALSTATUSCODE_MBX_COE                        0x0043 /**< \brief MBX_COE*/
N#define    ALSTATUSCODE_MBX_FOE                        0x0044 /**< \brief MBX_FOE*/
N#define    ALSTATUSCODE_MBX_SOE                        0x0045 /**< \brief MBX_SOE*/
N#define    ALSTATUSCODE_MBX_VOE                        0x004F /**< \brief MBX_VOE*/
N#define    ALSTATUSCODE_EE_NOACCESS                    0x0050 /**< \brief EEPROM no access*/
N#define    ALSTATUSCODE_EE_ERROR                       0x0051 /**< \brief EEPROM Error*/
N#define    ALSTATUSCODE_EXT_HARDWARE_NOT_READY         0x0052 /**< \brief External hardware not ready. This AL Status Code should be used if the EtherCAT-Slave refused the state transition due to an external connection to another device or signal is missing*/
N#define    ALSTATUSCODE_DEVICE_IDENT_VALUE_UPDATED     0x0061 /**< \brief In legacy identification mode (dip switch mapped to register 0x12) this error is returned if the EEPROM ID value does not match to dipswitch value*/
N#define    ALSTATUSCODE_MODULE_ID_LIST_NOT_MATCH       0x0070 /**< \brief Detected Module Ident List (0xF030) and Configured Module Ident List (0xF050) does not match*/
N#define    ALSTATUSCODE_SUPPLY_VOLTAGE_TOO_LOW         0x0080 /**< \brief The slave supply voltage is too low*/
N#define    ALSTATUSCODE_SUPPLY_VOLTAGE_TOO_HIGH        0x0081 /**< \brief The slave supply voltage is too high*/
N#define    ALSTATUSCODE_TEMPERATURE_TOO_LOW            0x0082 /**< \brief The slave temperature is too low*/
N#define    ALSTATUSCODE_TEMPERATURE_TOO_HIGH           0x0083 /**< \brief The slave temperature is too high*/
N                                                              
N
N                                                              
N/*---------------------------------------------
N-    Configured Sync Type (0x1C32.1 / 0x1C33.1)
N-----------------------------------------------*/
N#define     SYNCTYPE_FREERUN            0x0000 /**< \brief Sync type FreeRun*/
N#define     SYNCTYPE_SM_SYNCHRON        0x0001 /**< \brief SyncManager synchron (synchron to the corresponding SM, 0x1C32.1 -> SM2 ; 0x1C33.1 -> SM3)  */
N#define     SYNCTYPE_SM2_SYNCHRON       0x0022 /**< \brief SyncManager2 synchron (only used for 0x1C33.1)*/
N#define     SYNCTYPE_DCSYNC0            0x0002 /**< \brief Sync type Sync0 synchron*/
N#define     SYNCTYPE_DCSYNC1            0x0003 /**< \brief Sync type Sync1 synchron*/
N
N
N/*---------------------------------------------
N-    AL Event masks
N-----------------------------------------------*/
N#define     AL_CONTROL_EVENT                    ((UINT16) 0x01) /**< \brief AL Control event*/
N#define     SYNC0_EVENT                         ((UINT16) 0x04) /**< \brief Sync0 event*/
N#define     SYNC1_EVENT                         ((UINT16) 0x08) /**< \brief Sync1 event*/
N#define     SM_CHANGE_EVENT                     ((UINT16) 0x10) /**< \brief SyncManager changed event*/
N#define     EEPROM_CMD_PENDING                  ((UINT16) 0x20) /**< \brief EEPROM command pending*/
N#define     MAILBOX_WRITE_EVENT                 ((UINT16) 0x0100) /**< \brief MBoxOut write event*/
N#define     MAILBOX_READ_EVENT                  ((UINT16) 0x0200) /**< \brief MBoxIn read event*/
N#define     PROCESS_OUTPUT_EVENT                ((UINT16) 0x0400) /**< \brief Output process data write event*/
N#define     PROCESS_INPUT_EVENT                 ((UINT16) 0x0800) /**< \brief Input process data read event*/
N/*ET9300 Project Handler :(#if MAILBOX_SUPPORTED #else) lines 380 to 383 deleted*/
N
N#define    MAILBOX_WRITE                        0 /**< \brief SyncManager ID for MBoxOut (master to slave)*/
N#define    MAILBOX_READ                         1 /**< \brief SyncManager ID for MBoxIn (slave to master)*/
N#define    PROCESS_DATA_OUT                     2 /**< \brief SyncManager ID for output process data (master to slave)*/
N#define    PROCESS_DATA_IN                      3 /**< \brief SyncManager ID for input process data (slave to master)*/
N/*ET9300 Project Handler :(#if MAILBOX_SUPPORTED #else) lines 390 to 393 deleted*/
N
N
N
N
N/*ET9300 Project Handler :(#if UC_SET_ECAT_LED) lines 398 to 414 deleted*/
N#define    LED_OFF                      0x00 /**< \brief LED off*/
N#define    LED_FLICKERING               0x0E /**< \brief LED flickering*/
N#define    LED_BLINKING                 0x0D /**< \brief LED blinking*/
N#define    LED_SINGLEFLASH              0x01 /**< \brief LED single flash*/
N#define    LED_DOUBLEFLASH              0x02 /**< \brief LED double flash*/
N#define    LED_ON                       0x0F /**< \brief LED on*/
N#define    LED_OVERRIDE                 0x10 /**< \brief LED override (required to force the LED value within the ESC)*/
N
N
N#define    MEMORY_START_ADDRESS            0x1000 /**< \brief ESC DPRAM start address*/
N
N
N#ifndef    DC_SYNC_ACTIVE
N    #define    DC_SYNC_ACTIVE                ESC_DC_SYNC0_ACTIVE_MASK /**< \brief Expected activated Sync signals by the master*/
N#endif
N#ifndef    DC_EVENT_MASK
N    #define    DC_EVENT_MASK                PROCESS_OUTPUT_EVENT /**< \brief AL Event mask (value of register 0x204) in case of DC synchronisation*/
N/*ET9300 Project Handler :(#if MAX_PD_OUTPUT_SIZE > 0 #else) lines 434 to 436 deleted*/
N#endif
N
N
N#endif //_ECATSLV_H_
N
N#if defined(_ECATSLV_) && (_ECATSLV_ == 1)
X#if 0L && (_ECATSLV_ == 1)
S    #define PROTO
N#else
N    #define PROTO extern
N#endif
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Variables
N------
N-----------------------------------------------------------------------------------------*/
NPROTO    BOOL                           bBootMode; /**< \brief Indicates in slave is in BOOT mode*/
Xextern    unsigned char                           bBootMode;  
NPROTO    BOOL                           bEcatOutputUpdateRunning;  /**< \brief Indicates the OP state, will be set in StartOutputHandler
Xextern    unsigned char                           bEcatOutputUpdateRunning;  
N                                                                                and reset in StopOutputHandler*/
N
NPROTO    BOOL                            bEcatInputUpdateRunning;  /**< \brief Indicates the SAFEOP or OP state, will be set in StartInputHandler 
Xextern    unsigned char                            bEcatInputUpdateRunning;  
N                                                                                and reset in Stop InputHandler*/
N
NPROTO    BOOL                           bEcatFirstOutputsReceived; /**< \brief Indicates if outputs were received (SM2-event)
Xextern    unsigned char                           bEcatFirstOutputsReceived; 
N                                                                                or inputs were read (SM3-event, if the output size is 0),
N                                                                                has to be set by the application and reset in StopOutputHandler*/
N
NPROTO    BOOL                           bWdTrigger; /**< \brief Indicates that the SM2 WD trigger bit (0x814 bit6) is set.*/
Xextern    unsigned char                           bWdTrigger;  
N
NPROTO    BOOL                           bDcSyncActive; /**< \brief Indicates that the Distributed Clocks synchronization is active,*/
Xextern    unsigned char                           bDcSyncActive;  
N
NPROTO    INT16                          EsmTimeoutCounter; /**< \brief Counter used to detect an ESM timeout.
Xextern    short                          EsmTimeoutCounter; 
N                                                           -1 indicates a deactivated counter and 0 is expired*/
N
N#define MAX_SM_EVENT_MISSED             4 /**< \brief threshold of max missed counter value (0x1C32.11 / 0x1C33.11)*/
N
NPROTO BOOL                              bDcRunning; /**< \brief Indicates if Sync0 events are received*/
Xextern unsigned char                              bDcRunning;  
N
NPROTO UINT16                            u16SmSync0Counter; /**< /brief Incremented by one on every Sync0 event and reset to 0 on every SM event. It is used to check the SM/Sync0 sequence */
Xextern unsigned short                            u16SmSync0Counter;  
NPROTO UINT16                            u16SmSync0Value; /**< /brief Allowed Sync0 events within one SM cycle. If 0 the Sequence check is disabled */
Xextern unsigned short                            u16SmSync0Value;  
N
NPROTO BOOL                              bSmSyncSequenceValid; /**< \brief Set to true if SM/Sync0 sequence is valid*/
Xextern unsigned char                              bSmSyncSequenceValid;  
N
NPROTO INT16                             i16WaitForPllRunningTimeout; /**< \brief The time bPllRunnig shall be true while state change from SafeOp to Op*/
Xextern short                             i16WaitForPllRunningTimeout;  
N
NPROTO INT16                             i16WaitForPllRunningCnt; /**< \brief Incremented with every valid Sync-SyncManger cycle */
Xextern short                             i16WaitForPllRunningCnt;  
N
NPROTO UINT16                            Sync0WdCounter; /**< \brief Sync0 watchdog counter*/
Xextern unsigned short                            Sync0WdCounter;  
NPROTO UINT16                            Sync0WdValue; /**< \brief Sync0 watchdog value*/
Xextern unsigned short                            Sync0WdValue;  
N
NPROTO UINT16                            Sync1WdCounter; /**< \brief Sync1 watchdog counter*/
Xextern unsigned short                            Sync1WdCounter;  
NPROTO UINT16                            Sync1WdValue; /**< \brief Sync1 watchdog value*/
Xextern unsigned short                            Sync1WdValue;  
N
NPROTO UINT16                            LatchInputSync0Value; /**< \brief Sync0 event on which the inputs shall be latched and copied to the ESC buffer. If the inputs shall be latched base don Sync1 the value is set to 0.*/
Xextern unsigned short                            LatchInputSync0Value;  
NPROTO UINT16                            LatchInputSync0Counter; /**< \brief Sync0 counter used to get the Sync0 event to latch the Inputs. */
Xextern unsigned short                            LatchInputSync0Counter;  
N
NPROTO BOOL b32BitDc;
Xextern unsigned char b32BitDc;
N
N/*ET9300 Project Handler :(#if !COE_SUPPORTED) lines 500 to 502 deleted*/
N
N
NPROTO BOOL                              bEscIntEnabled; /**< \brief Indicates that the ESC interrupt is enabled (SM2/3 or SYNC0/1-event),
Xextern unsigned char                              bEscIntEnabled; 
N                                                                     will be set in StartInputHandler and reset in StopInputHandler*/
N
NPROTO BOOL                              b3BufferMode; /**< \brief Indicates that inputs and outputs are running in 3-Buffer-Mode*/
Xextern unsigned char                              b3BufferMode;  
N
N/*ECATCHANGE_START(V5.13) ESM1*/
NPROTO UINT16                            u16LocalErrorCode; /**< \brief Reason for local error*/
Xextern unsigned short                            u16LocalErrorCode;  
NPROTO UINT8                             u8LocalErrorState; /**< \brief State of the current local error (lower state could be set by the master)*/
Xextern unsigned char                             u8LocalErrorState;  
N/*ECATCHANGE_END(V5.13) ESM1*/
NPROTO BOOL                              bApplEsmPending; /**< \brief Indicates if the local application ESM function need to be called from Al_ConntrolRes (is true if NOERR_INWORK is returned by generic ESM function)*/
Xextern unsigned char                              bApplEsmPending;  
NPROTO BOOL                              bEcatWaitForAlControlRes; /**< \brief Contains the information that the state machine waits for an acknowledge
Xextern unsigned char                              bEcatWaitForAlControlRes; 
N                                                                             for the last AL_ControlInd from the application/generic stack*/
N
NPROTO UINT16                            nEcatStateTrans; /**< \brief Current state transition*/
Xextern unsigned short                            nEcatStateTrans;  
N
NPROTO UINT8                             u8EcatErrorLed; /**< \brief Current value of the error LED*/
Xextern unsigned char                             u8EcatErrorLed;  
N
NPROTO UINT8                             u8EcatRunLed; /**< \brief Current value of the run LED*/
Xextern unsigned char                             u8EcatRunLed;  
N
NPROTO UINT16                            nPdInputSize; /**< \brief Contains the input size (SM3 size)/SM2 if no outputs are supported, has to be written by the application*/
Xextern unsigned short                            nPdInputSize;  
N
NPROTO UINT16                            nPdOutputSize; /**< \brief Contains the output size (SM2 size), has to be written by the application*/
Xextern unsigned short                            nPdOutputSize;  
N
NPROTO UINT8                             nMaxSyncMan; /**< \brief Contains the maximum number of Sync Manager channels, will be initialized in ECAT_Main*/
Xextern unsigned char                             nMaxSyncMan;  
N
NPROTO UINT16                            nMaxEscAddress; /**< \brief Max supported address by the ESC (register(0x1000) + size of the supported DPRAM in Byte)*/
Xextern unsigned short                            nMaxEscAddress;  
N
NPROTO UINT8                             nAlStatus; /**< \brief Contains the actual AL Status, will be written in AL_ControlInd*/
Xextern unsigned char                             nAlStatus;  
N
NPROTO BOOL                              bExplicitDevIdRequested; /**< \brief Indicates if 0x0120.5 is set*/
Xextern unsigned char                              bExplicitDevIdRequested;  
N
NPROTO UINT16                            EcatWdValue; /**< \brief Contains the value of the watchdog in ms, will be written in StartInputHandler. 
Xextern unsigned short                            EcatWdValue; 
N                                                                    In case that the ESC watchdog feature is used this variable just indicates if the watchdog is enabled or disabled*/
N/*ET9300 Project Handler :(#if !ESC_SM_WD_SUPPORTED) lines 542 to 546 deleted*/
NPROTO    UINT16                         nEscAddrOutputData; /**< \brief Contains the SM address for the output process data*/
Xextern    unsigned short                         nEscAddrOutputData;  
NPROTO    UINT16                         nEscAddrInputData; /**< \brief Contains the SM address for the input process data*/
Xextern    unsigned short                         nEscAddrInputData;  
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Functions
N------
N-----------------------------------------------------------------------------------------*/
NPROTO void EnableSyncManChannel(UINT8 channel);
Xextern void EnableSyncManChannel(unsigned char channel);
NPROTO void DisableSyncManChannel(UINT8 channel);
Xextern void DisableSyncManChannel(unsigned char channel);
NPROTO TSYNCMAN ESCMEM *GetSyncMan(UINT8 channel);
Xextern TSYNCMAN  *GetSyncMan(unsigned char channel);
NPROTO void SetALStatus(UINT8 alStatus, UINT16 alStatusCode);
Xextern void SetALStatus(unsigned char alStatus, unsigned short alStatusCode);
NPROTO void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode);
Xextern void AL_ControlInd(unsigned char alControl, unsigned short alStatusCode);
N/*ET9300 Project Handler :(#if !ESC_SM_WD_SUPPORTED) lines 565 to 569 deleted*/
NPROTO void DC_CheckWatchdog(void);
Xextern void DC_CheckWatchdog(void);
NPROTO    void CheckIfEcatError(void);
Xextern    void CheckIfEcatError(void);
NPROTO void ECAT_Init(void);
Xextern void ECAT_Init(void);
N
NPROTO void ECAT_Main(void);
Xextern void ECAT_Main(void);
N
N#undef PROTO
N/** @}*/
L 45 ".\etherCAT\applInterface.h" 2
N#include "objdef.h"
L 1 ".\etherCAT\objdef.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N * \addtogroup CoE CAN Application Profile over EtherCAT
N * @{
N */
N
N/**
N\file objdef.h
N\author EthercatSSC@beckhoff.com
N\brief CAN application profile over EtherCAT object dictionary
N
N\version 5.11
N
N<br>Changes to version V5.10:<br>
NV5.11 COE2: update synctype supported flag for freerun<br>
NV5.11 COE3: change 0x10F3.2 (Sync Error limit) from UINT32 to UINT16 (according to the ETG.1020)<br>
NV5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
N<br>Changes to version V5.01:<br>
NV5.10 COE1: Define one entry description for all 0x1C3x objects and change data type of SI11,12,13 to UINT16 (according ETG.1020)<br>
NV5.10 COE2: Change return value of Get ObjectSize to UINT32<br>
N            Change object size to UINT32<br>
NV5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
N              Compare DC UINT configuration (by ESC Config data) vs. DC activation register settings<br>
N              Update 0x1C3x entries<br>
NV5.10 ECAT8: Update Datatype defines according ETG.1020<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N#include "sdoserv.h"
L 1 ".\etherCAT\sdoserv.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N * \addtogroup CoE CAN Application Profile over EtherCAT
N * @{
N */
N
N
N/**
N\file sdoserv.h
N\author EthercatSSC@beckhoff.com
N\brief SDO Service definitions
N
N\version 5.12
N
N<br>Changes to version V5.11:<br>
NV5.12 ECAT2: big endian changes<br>
NV5.12 MBX3: handle incomplete mailbox communication<br>
N<br>Changes to version V5.10:<br>
NV5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
NV5.11 SDO10: add new SDO abort code 0x6010004 (complete access not supported)<br>
N<br>Changes to version V5.01:<br>
NV5.10 SDO3: Add new SDO Abort Code (0x06090033)<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N#include "ecatcoe.h"
L 1 ".\etherCAT\ecatcoe.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N * \addtogroup CoE CAN Application Profile over EtherCAT
N * @{
N */
N
N/**
N\file ecatcoe.h
N\author EthercatSSC@beckhoff.com
N
N\version 5.11
N
N<br>Changes to version V5.01:<br>
NV5.11 COE4: "change prototype of ""COE_ContinueInd()"" return <> 0 if a failure occurred"<br>
NV5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N#include "mailbox.h"
L 1 ".\etherCAT\mailbox.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N * \addtogroup Mailbox Mailbox Functions
N * @{
N */
N
N/**
N\file mailbox.h
N\author EthercatSSC@beckhoff.com
N
N\version 5.12
N
N<br>Changes to version V5.11:<br>
NV5.12 ECAT2: big endian changes<br>
NV5.12 MBX3: handle incomplete mailbox communication<br>
N<br>Changes to version V5.01:<br>
NV5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
NV5.11 MBX1: "return value of ""MBX_StartMailboxHandler()"" changed to UINT16"<br>
NV5.11 MBX3: set application triggered emergency and EoE data to pending if no mailbox queue is supported and another mailbox request is currently handled, Handle only one mailbox request at a time (in case that MAILBPX_QUEUE is disabled)<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N#include "ecat_def.h"
N
N
N#ifndef _MAILBOX_H_
N#define _MAILBOX_H_
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Defines and Types
N------
N-----------------------------------------------------------------------------------------*/
N#define     MBX_TYPE_AOE                        1 /**< \brief Mailbox type AoE*/
N#define     MBX_TYPE_EOE                        2 /**< \brief Mailbox type EoE*/
N#define     MBX_TYPE_COE                        3 /**< \brief Mailbox type CoE*/
N#define     MBX_TYPE_FOE                        4 /**< \brief Mailbox type FoE*/
N#define     MBX_TYPE_SOE                        5 /**< \brief Mailbox type SoE*/
N#define     MBX_TYPE_VOE                        15 /**< \brief Mailbox type VoE*/
N
N#define     EMCY_SERVICE                        ((UINT8) 0x0001) /**< \brief Emergency service*/
N#define     COE_SERVICE                         ((UINT8) 0x0002) /**< \brief CoE service*/
N#define     SOE_SERVICE                         ((UINT8) 0x0004) /**< \brief SoE service*/
N#define     EOE_SERVICE                         ((UINT8) 0x0008) /**< \brief EoE service*/
N#define     AOE_SERVICE                         ((UINT8) 0x0010) /**< \brief AoE service*/
N#define     VOE_SERVICE                         ((UINT8) 0x0020) /**< \brief VoE service*/
N#define     FOE_SERVICE                         ((UINT8) 0x0040) /**< \brief FoE service*/
N#define     FRAGMENTS_FOLLOW                    ((UINT8) 0x0080) /**< \brief Fragments follow service*/
N
N#ifndef    ENTER_MBX_CRITICAL
S    #define    ENTER_MBX_CRITICAL /**< \brief Enter mailbox critical section*/
N#endif
N
N#ifndef    LEAVE_MBX_CRITICAL
S    #define    LEAVE_MBX_CRITICAL /**< \brief Leave mailbox critical section*/
N#endif
N
N#ifndef    MAX_MBX_QUEUE_SIZE
N    #define    MAX_MBX_QUEUE_SIZE    10 /**< \brief Mailbox queue size*/
N#endif
N
N
N/*---------------------------------------------
N-    Command Codes for the mailbox type 0
N-----------------------------------------------*/
N#define    MBXSERVICE_MBXERRORCMD          0x01 /**< \brief Mailbox error command*/
N
N
N/*---------------------------------------------
N-    Error Codes for a mailbox error response
N-----------------------------------------------*/
N#define    MBXERR_SYNTAX                   0x01 /**< \brief Mailbox error "syntax"*/
N#define    MBXERR_UNSUPPORTEDPROTOCOL      0x02 /**< \brief Mailbox error "unsupported protocol"*/
N#define    MBXERR_INVALIDCHANNEL           0x03 /**< \brief Mailbox error "invalid channel"*/
N#define    MBXERR_SERVICENOTSUPPORTED      0x04 /**< \brief Mailbox error "service not supported"*/
N#define    MBXERR_INVALIDHEADER            0x05 /**< \brief Mailbox error "invalid header"*/
N#define    MBXERR_SIZETOOSHORT             0x06 /**< \brief Mailbox error "Size too short"*/
N#define    MBXERR_NOMOREMEMORY             0x07 /**< \brief Mailbox error "No memory"*/
N#define    MBXERR_INVALIDSIZE              0x08 /**< \brief Mailbox error "Invalid size"*/
N#define    MBXERR_SERVICEINWORK            0x09 /**< \brief Mailbox error "Service in work"*/
N
N
N/**
N * \brief Mailbox header
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16                          Length; /**< \brief Length*/
X    unsigned short                          Length;  
N    UINT16                          Address; /**< \brief Address*/
X    unsigned short                          Address;  
N
N    UINT16                          Flags[1]; /**< \brief Flags*/
X    unsigned short                          Flags[1];  
N/*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 105 to 112 deleted*/
N    #define    MBX_OFFS_TYPE        0 /**< \brief Protocol type offset*/
N    #define    MBX_MASK_TYPE        0x0F00 /**< \brief Protocol type mask*/
N    #define    MBX_SHIFT_TYPE       8 /**< \brief Protocol type shift*/
N    #define    MBX_OFFS_COUNTER     0 /**< \brief Protocol counter offset*/
N    #define    MBX_MASK_COUNTER     0xF000 /**< \brief Protocol counter mask*/
N    #define    MBX_SHIFT_COUNTER    12 /**< \brief Protocol counter shift*/
N/*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 120 to 133 deleted*/
N}MBX_STRUCT_PACKED_END
X}
NTMBXHEADER;
N
N
N#define     MBX_HEADER_SIZE         6 /**< \brief Mailbox header size*/
N
N
N#define     MAX_MBX_DATA_SIZE       (MAX_MBX_SIZE - MBX_HEADER_SIZE) /**< \brief Mailbox data size*/
N
N/**
N * \brief Mailbox datagram
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    TMBXHEADER                      MbxHeader; /**< \brief Mailbox header*/
N    UINT16                          Data[(MAX_MBX_DATA_SIZE >> 1)]; /**< \brief Mailbox data*/
X    unsigned short                          Data[((0x0100 - 6) >> 1)];  
N}MBX_STRUCT_PACKED_END
X}
NTMBX;
N
N
N/**
N * \brief Mailbox queue
N */
Ntypedef struct
N{
N    UINT16    firstInQueue; /**< \brief First in Queue*/
X    unsigned short    firstInQueue;  
N    UINT16    lastInQueue; /**< \brief Last in Queue*/
X    unsigned short    lastInQueue;  
N    UINT16    maxQueueSize; /**< \brief Max queue size*/
X    unsigned short    maxQueueSize;  
N    TMBX MBXMEM * queue[(MAX_MBX_QUEUE_SIZE)+1]; /**< \brief Queue buffer*/
X    TMBX  * queue[(10)+1];  
N} TMBXQUEUE;
N
N
N
N#endif //_MAILBOX_H_
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Variables
N------
N-----------------------------------------------------------------------------------------*/
N#if defined(_MAILBOX_) && (_MAILBOX_ == 1)
X#if 0L && (_MAILBOX_ == 1)
S    #define PROTO
N#else
N    #define PROTO extern
N#endif
N
NPROTO BOOL                    bReceiveMbxIsLocked; /**< \brief Receive mailbox is locked (MBoxOut, default SM0)*/
Xextern unsigned char                    bReceiveMbxIsLocked;  
NPROTO BOOL                    bSendMbxIsFull; /**< \brief Send mailbox is full (MBoxIn, default SM1)*/
Xextern unsigned char                    bSendMbxIsFull;  
NPROTO BOOL                    bMbxRunning; /**< \brief Mailbox running (At least PreOP state)*/
Xextern unsigned char                    bMbxRunning;  
NPROTO BOOL                    bMbxRepeatToggle; /**< \brief Mailbox repeat toggle*/
Xextern unsigned char                    bMbxRepeatToggle;  
NPROTO UINT16                  u16SendMbxSize; /**< \brief Send mailbox size (default SM1)*/
Xextern unsigned short                  u16SendMbxSize;  
NPROTO UINT16                  u16ReceiveMbxSize; /**< \brief Receive mailbox size (default SM0)*/
Xextern unsigned short                  u16ReceiveMbxSize;  
NPROTO UINT16                  u16EscAddrReceiveMbx; /**< \brief Receive mailbox address (default SM0)*/
Xextern unsigned short                  u16EscAddrReceiveMbx;  
NPROTO UINT16                  u16EscAddrSendMbx; /**< \brief Send mailbox address (default SM1)*/
Xextern unsigned short                  u16EscAddrSendMbx;  
NPROTO UINT8                   u8MbxWriteCounter; /**< \brief Write mailbox counter*/
Xextern unsigned char                   u8MbxWriteCounter;  
NPROTO UINT8                   u8MbxReadCounter; /**< \brief Read mailbox counter*/
Xextern unsigned char                   u8MbxReadCounter;  
N/*ET9300 Project Handler :(#if !MAILBOX_QUEUE) lines 193 to 195 deleted*/
NPROTO UINT8                   u8MailboxSendReqStored; /**< \brief Mailbox send request stored*/
Xextern unsigned char                   u8MailboxSendReqStored;  
NPROTO TMBX MBXMEM *           psWriteMbx; /**< \brief Pointer to write mailbox buffer*/
Xextern TMBX  *           psWriteMbx;  
NPROTO TMBX MBXMEM *           psReadMbx; /**< \brief Pointer to read mailbox buffer*/
Xextern TMBX  *           psReadMbx;  
NPROTO TMBX MBXMEM *           psRepeatMbx; /**< \brief Pointer to repeat mailbox buffer*/
Xextern TMBX  *           psRepeatMbx;  
NPROTO TMBX MBXMEM *           psStoreMbx; /**< \brief Pointer to store mailbox buffer*/
Xextern TMBX  *           psStoreMbx;  
N/*ET9300 Project Handler :(#if !MAILBOX_QUEUE) lines 201 to 203 deleted*/
NPROTO TMBXQUEUE MBXMEM        sMbxSendQueue; /**< \brief Send mailbox queue*/
Xextern TMBXQUEUE         sMbxSendQueue;  
NPROTO TMBXQUEUE MBXMEM        sMbxReceiveQueue; /**< \brief Receive mailbox queue*/
Xextern TMBXQUEUE         sMbxReceiveQueue;  
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Functions
N------
N-----------------------------------------------------------------------------------------*/
N
NPROTO   void     MBX_Init(void);
Xextern   void     MBX_Init(void);
NPROTO   UINT16    MBX_StartMailboxHandler(void);
Xextern   unsigned short    MBX_StartMailboxHandler(void);
NPROTO   void     MBX_StopMailboxHandler(void);
Xextern   void     MBX_StopMailboxHandler(void);
NPROTO   void     MBX_MailboxWriteInd(TMBX MBXMEM *pMbx);
Xextern   void     MBX_MailboxWriteInd(TMBX  *pMbx);
NPROTO   void     MBX_MailboxReadInd(void);
Xextern   void     MBX_MailboxReadInd(void);
NPROTO   void     MBX_MailboxRepeatReq(void);
Xextern   void     MBX_MailboxRepeatReq(void);
NPROTO   UINT8    MBX_MailboxSendReq(TMBX MBXMEM * pMbx, UINT8 flags);
Xextern   unsigned char    MBX_MailboxSendReq(TMBX  * pMbx, unsigned char flags);
NPROTO   void     MBX_CheckAndCopyMailbox(void);
Xextern   void     MBX_CheckAndCopyMailbox(void);
NPROTO   UINT8    MBX_CopyToSendMailbox(TMBX MBXMEM *pMbx);
Xextern   unsigned char    MBX_CopyToSendMailbox(TMBX  *pMbx);
NPROTO   void     MBX_Main(void);
Xextern   void     MBX_Main(void);
N
N#undef PROTO
N/** @}*/
L 31 ".\etherCAT\ecatcoe.h" 2
N
N#ifndef _ECATCOE_H_
N#define _ECATCOE_H_
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Defines and Types
N------
N-----------------------------------------------------------------------------------------*/
N
N/*---------------------------------------------
N-    Error codes
N-----------------------------------------------*/
N#define     ERROR_COEINVALIDSERVICE     0x01 /**< \brief Invalid SDO service*/
N#define     ERROR_COENOTSUPPORTED       0x02 /**< \brief Not supported service*/
N
N
N/*---------------------------------------------
N-    COE services
N-----------------------------------------------*/
N#define     COESERVICE_EMERGENCY        0x01 /**< \brief CoE Emergency*/
N#define     COESERVICE_SDOREQUEST       0x02 /**< \brief CoE SDO request*/
N#define     COESERVICE_SDORESPONSE      0x03 /**< \brief CoE SDO response*/
N#define     COESERVICE_TXPDO            0x04 /**< \brief CoE TxPDO*/
N#define     COESERVICE_RXPDO            0x05 /**< \brief CoE RxPDO*/
N#define     COESERVICE_TXPDOREMREQ      0x06 /**< \brief CoE TxPDO map request*/
N#define     COESERVICE_RXPDOREMREQ      0x07 /**< \brief CoE RxPDO map request*/
N#define     COESERVICE_SDOINFO          0x08 /**< \brief CoE SDO Info*/
N
N
N
N/*---------------------------------------------
N-    COE Structures
N-----------------------------------------------*/
N/*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 64 to 67 deleted*/
N#define     COEHEADER_COESERVICESHIFT   12 /**< \brief CoE service shift (within CoE header)*/
N#define     COEHEADER_COESERVICEMASK    0xF000 /**< \brief CoE service mask (within CoE header)*/
N
N#define     COE_HEADER_SIZE             2 /**< \brief CoE header size*/
N
Ntypedef UINT16 TCOEHEADER; /**< \brief CoE header*/
Xtypedef unsigned short TCOEHEADER;  
N
N
N/**
N * \brief CoE Mailbox header
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER        MbxHeader; /**< \brief mailbox header*/
N  TCOEHEADER        CoeHeader; /**< \brief CoE header*/
N  UINT16            Data[((MAX_MBX_DATA_SIZE)-(COE_HEADER_SIZE)) >> 1]; /**< \brief CoE data*/
X  unsigned short            Data[(((0x0100 - 6))-(2)) >> 1];  
N}MBX_STRUCT_PACKED_END
X}
NTCOEMBX;
N
N
N#endif //_ECATCOE_H_
N
N#if defined(_ECATCOE_) && (_ECATCOE_ == 1)
X#if 0L && (_ECATCOE_ == 1)
S    #define PROTO
N#else
N    #define PROTO extern
N#endif
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Variables
N------
N-----------------------------------------------------------------------------------------*/
NPROTO    TMBX MBXMEM * VARMEM pCoeSendStored;                /** if the mailbox service could not be sent (or stored),
Xextern    TMBX  *  pCoeSendStored;                
N                                                                the CoE service will be stored in this variable
N                                                                and will be sent automatically from the mailbox handler
N                                                                (COE_ContinueInd) when the send mailbox will be read
N                                                                the next time from the master */
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Functions
N------
N-----------------------------------------------------------------------------------------*/
N
NPROTO   void     COE_Init(void);
Xextern   void     COE_Init(void);
NPROTO   UINT8    COE_ServiceInd(TCOEMBX MBXMEM *pCoeMbx);
Xextern   unsigned char    COE_ServiceInd(TCOEMBX  *pCoeMbx);
NPROTO   UINT8     COE_ContinueInd(TMBX MBXMEM * pMbx);
Xextern   unsigned char     COE_ContinueInd(TMBX  * pMbx);
N
N#undef PROTO
N/** @}*/
L 39 ".\etherCAT\sdoserv.h" 2
N
N
N#ifndef _SDOSERV_H_
N#define _SDOSERV_H_
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Defines and Types
N------
N-----------------------------------------------------------------------------------------*/
N
N/**
N * \addtogroup SdoErrorCodes SDO Error Codes
N * @{
N */
N#define     ERROR_SDOINVALIDCOMMAND             0x1101 /**< \brief  Invalid SDO command*/
N#define     ERROR_SDOINVALIDHEADER              0x1102 /**< \brief  Invalid SDO header*/
N#define     ERROR_SDONOTSUPPORTED               0x1103 /**< \brief  SDO service not supported*/
N/** @}*/
N
N
N/**
N * \addtogroup SdoHeaderData SDO Header and Data
N * @{
N */
N#define     SDOHEADER_SIZEINDICATOR             ((UINT8) 0x01) /**< \brief Size Indicator size of data in Data Set Size specified*/
N#define     SDOHEADER_TRANSFERTYPE              ((UINT8) 0x02) /**< \brief Transfer Type<br>1: Expedited<br>0: Normal*/
N#define     SDOHEADER_DATASETSIZE               ((UINT8) 0x0C) /**< \brief Data Set Size (used for Expedited transfer)*/
N#define     SDOHEADER_COMPLETEACCESS            ((UINT8) 0x10) /**< \brief Complete Access indication<br>0: Only specified entry will be transferred<br>1: Whole object (with or without Subindex0) will be transferred)*/ 
N#define     SDOHEADER_COMMAND                   ((UINT8) 0xE0) /**< \brief SDO Command*/
N#define     SDOHEADERSHIFT_SIZEINDICATOR        ((UINT8) 0) /**< \brief Shift for Size Indicator*/
N#define     SDOHEADERSHIFT_TRANSFERTYPE         ((UINT8) 1) /**< \brief Shift for Transfer Type*/
N#define     SDOHEADERSHIFT_DATASETSIZE          ((UINT8) 2) /**< \brief Shift for Data Set Size*/
N#define     SDOHEADERSHIFT_INDEXACCESS          ((UINT8) 4) /**< \brief Shift for Complete Access*/
N#define     SDOHEADERSHIFT_COMMAND              ((UINT8) 5) /**< \brief Shift for SDO Command*/
N/** @}*/
N
N
N/**
N * \addtogroup SdoServices SDO Services
N * @{
N */
N#define     SDOSERVICE_INITIATEDOWNLOADREQ      ((UINT8) (0x01 << (SDOHEADERSHIFT_COMMAND))) /**< \brief SDO download request*/
N#define     SDOSERVICE_INITIATEDOWNLOADRES      ((UINT8) (0x03 << (SDOHEADERSHIFT_COMMAND))) /**< \brief SDO download response*/
N#define     SDOSERVICE_DOWNLOADSEGMENTREQ       ((UINT8) (0x00 << (SDOHEADERSHIFT_COMMAND))) /**< \brief SDO segmented download request*/
N#define     SDOSERVICE_DOWNLOADSEGMENTRES       ((UINT8) (0x01 << (SDOHEADERSHIFT_COMMAND))) /**< \brief SDO segmented download response*/
N#define     SDOSERVICE_INITIATEUPLOADREQ        ((UINT8) (0x02 << (SDOHEADERSHIFT_COMMAND))) /**< \brief SDO upload request*/
N#define     SDOSERVICE_INITIATEUPLOADRES        ((UINT8) (0x02 << (SDOHEADERSHIFT_COMMAND))) /**< \brief SDO upload response*/
N#define     SDOSERVICE_UPLOADSEGMENTREQ         ((UINT8) (0x03 << (SDOHEADERSHIFT_COMMAND))) /**< \brief SDO segmented upload request*/
N#define     SDOSERVICE_UPLOADSEGMENTRES         ((UINT8) (0x00 << (SDOHEADERSHIFT_COMMAND))) /**< \brief SDO segmented upload response*/
N#define     SDOSERVICE_ABORTTRANSFER            ((UINT8) (((UINT8) 0x04) << (SDOHEADERSHIFT_COMMAND))) /**< \brief SDO abort*/
N/** @}*/
N
N
N/**
N * \addtogroup SdoHeaderData SDO Header and Data
N * @{
N */
N/**
N * Structure to handle the basic SDO header
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16 Sdo[2]; /**< \brief 32Bit SDO header buffer*/
X    unsigned short Sdo[2];  
N/*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 103 to 115 deleted*/
N            #define     SDOHEADER_COMMANDOFFSET             0 /**< \brief Memory offset for the command*/
N            #define     SDOHEADER_INDEXLOOFFSET             0 /**< \brief Memory offset for the low Byte of the object index*/
N            #define     SDOHEADER_INDEXHIOFFSET             1 /**< \brief Memory offset for the high Byte of the object index*/
N            #define     SDOHEADER_SUBINDEXOFFSET            1 /**< \brief Memory offset for subindex*/
N            #define     SDOHEADER_COMMANDMASK               0xFF /**< \brief Mask to get the command Byte*/
N            #define     SDOHEADER_COMMANDSHIFT              0 /***< \brief Shift to get the command byte*/
N            #define     SDOHEADER_INDEXLOSHIFT              8 /**< \brief Shift to get the low Byte of the object index*/
N            #define     SDOHEADER_INDEXLOMASK               0x00FF /** < \brief Mask to get the low byte of the object index */
N            #define     SDOHEADER_INDEXHIMASK               0xFF /**< \brief Mask to get the high byte of the object index*/
N            #define     SDOHEADER_SUBINDEXSHIFT             8 /**< \brief Shift to get the subindex*/
N            #define     SDOHEADER_SUBINDEXMASK              0xFF /**< \brief Mask to get the subindex*/
N/*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 128 to 145 deleted*/
N}MBX_STRUCT_PACKED_END
X}
NTINITSDOHEADER;
N
N
N#define INITSDO_HEADER_SIZE     4 /**< \brief Size of the SDO header*/
N
N
N/**
N *Complete SDO datagram including mailbox header, CoE header and SDO header
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
N}MBX_STRUCT_PACKED_END
X}
NTINITSDOMBX;
N
N
N#define     MAX_EXPEDITED_DATA          4 /**< \brief Maximum number of Bytes handled via an expedited transfer*/
N#define     MIN_SEGMENTED_DATA          ((UINT16) 7) /**< \brief Minimum number of Bytes required for a segmented transfer*/
N#define     EXPEDITED_FRAME_SIZE        ( COE_HEADER_SIZE + INITSDO_HEADER_SIZE + (MAX_EXPEDITED_DATA) ) /**< \brief Size of an expedited mailbox datagram*/
N#define     DOWNLOAD_NORM_REQ_SIZE      ( COE_HEADER_SIZE + INITSDO_HEADER_SIZE + 4 ) /**< \brief Size of an normal download request*/
N/* HBu 06.02.06: names of defines changed */
N/* HBu 21.03.06: the SDO_Download-Response has to have always 8 bytes */
N#define     DOWNLOAD_NORM_RES_SIZE      ( COE_HEADER_SIZE + INITSDO_HEADER_SIZE + 4 ) /**< \brief Frame size of an normal download response*/
N#define     UPLOAD_NORM_RES_SIZE        ( COE_HEADER_SIZE + INITSDO_HEADER_SIZE + 4 ) /**< \brief Frame size of an normal upload response*/
N#define     SEGMENT_NORM_HEADER_SIZE    ( COE_HEADER_SIZE + 1 ) /**< \brief Minimum SDO header size*/
N#define     SEGMENT_NORM_RES_SIZE       ( (SEGMENT_NORM_HEADER_SIZE) + (MIN_SEGMENTED_DATA) ) /**< \brief Minimum SDO size*/
N#define     SEGMENT_MBX_SIZE            ( MBX_HEADER_SIZE + (SEGMENT_NORM_HEADER_SIZE) )/**< \brief Minimum mailbox datagram*/
N
N
N/**
N * Segmented SDO header including data
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16      SegHeader; /**< \brief 8Bit header buffer and first 8Bit of the Data*/
X    unsigned short      SegHeader;  
N/*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 185 to 196 deleted*/
N#define    SEGHEADER_MASK                    ((UINT16) 0xFF) /**< \brief SDO header mask*/
N#define    SEGHEADER_NOMOREFOLLOWS           ((UINT16) 0x01) /**< \brief More segments follow flag*/
N#define    SEGHEADER_SEGDATASIZE             ((UINT16) 0x0E) /**< \brief Segmented data size*/
N#define    SEGHEADER_TOGGLE                  ((UINT16) 0x10) /**< \brief Toogle flag*/
N#define    SEGHEADER_COMMAND                 ((UINT16) 0xE0) /**< \brief Command identifier*/
N#define    SEGHEADERSHIFT_SEGDATASIZE        ((UINT16) 1) /**< \brief Shift for Segmented data size*/
N#define    SEGHEADERSHIFT_TOGGLE             ((UINT16) 4) /**< \brief Shift for toggle flag*/
N#define    SEGHEADERSHIFT_COMMAND            ((UINT16) 5) /**< \brief Shift for command identifier*/
N#define    SEGHDATA_MASK                     ((UINT16) 0xFF00) /**< \brief Data mask*/
N#define    SEGDATASHIFT                      ((UINT16) 8) /**< \brief Shift for first data Byte*/
N    UINT16      Data[(((MAX_MBX_DATA_SIZE)-(SEGMENT_NORM_HEADER_SIZE) - 1 ) >> 1)];  /**< \brief Data buffer (second and following Bytes, the first byte is located in the header variable)*/
X    unsigned short      Data[((((0x0100 - 6))-(( 2 + 1 )) - 1 ) >> 1)];   
N/*ET9300 Project Handler :(#if MBX_16BIT_ACCESS #else) lines 209 to 220 deleted*/
N}MBX_STRUCT_PACKED_END
X}
NTSDOSEGHEADERDATA;
N
N
N/**
N *Expedited download request
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
N  UINT16                Data[(MAX_EXPEDITED_DATA) >> 1]; /**< \brief Data buffer*/
X  unsigned short                Data[(4) >> 1];  
N}MBX_STRUCT_PACKED_END
X}
NTINITSDODOWNLOADEXPREQMBX;
N
N/**
N *Normal download request
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
N  UINT16                CompleteSize[2]; /**< \brief Complete object size*/
X  unsigned short                CompleteSize[2];  
N  UINT16                Data[(((MAX_MBX_DATA_SIZE)-(DOWNLOAD_NORM_REQ_SIZE)) >> 1)]; /**< \brief Data buffer*/
X  unsigned short                Data[((((0x0100 - 6))-(( 2 + 4 + 4 ))) >> 1)];  
N}MBX_STRUCT_PACKED_END
X}
NTINITSDODOWNLOADNORMREQMBX;
N
N
N/**
N *Expedited and normal download response:
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
N}MBX_STRUCT_PACKED_END
X}
NTINITSDODOWNLOADRESMBX;
N
N
N/**
N *Segmented download request
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TSDOSEGHEADERDATA     SdoHeader; /**< \brief SDO header (data is included in header)*/
N}MBX_STRUCT_PACKED_END
X}
NTDOWNLOADSDOSEGREQMBX;
N
N
N/**
N *Segmented download response
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  UINT8                 SegHeader; /**< \brief SDO header*/
X  unsigned char                 SegHeader;  
N}MBX_STRUCT_PACKED_END
X}
NTDOWNLOADSDOSEGRESMBX;
N
N
N/**
N *Expedited and normal upload request
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
N}MBX_STRUCT_PACKED_END
X}
NTINITSDOUPLOADREQMBX;
N
N
N/**
N *Expedited upload response
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
N  UINT16                Data[((MAX_EXPEDITED_DATA) >> 1)]; /**< \brief Data buffer*/
X  unsigned short                Data[((4) >> 1)];  
N}MBX_STRUCT_PACKED_END
X}
NTINITSDOUPLOADEXPRESMBX;
N
N
N/**
N *Normal upload response
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
N  UINT16                CompleteSize[2]; /**< \brief Complete object size*/
X  unsigned short                CompleteSize[2];  
N  UINT16                Data[(((MAX_MBX_DATA_SIZE)-(UPLOAD_NORM_RES_SIZE)) >> 1)]; /**< \brief Data buffer*/
X  unsigned short                Data[((((0x0100 - 6))-(( 2 + 4 + 4 ))) >> 1)];  
N}MBX_STRUCT_PACKED_END
X}
NTINITSDOUPLOADNORMRESMBX;
N
N
N/**
N *Segmented upload request
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  UINT8                 SegHeader; /**< \brief SDO header*/
X  unsigned char                 SegHeader;  
N}MBX_STRUCT_PACKED_END
X}
NTUPLOADSDOSEGREQMBX;
N
N/**
N *Segmented upload response
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TSDOSEGHEADERDATA     SdoHeader; /**< \brief SDO header (data is included in header)*/
N}MBX_STRUCT_PACKED_END
X}
NTUPLOADSDOSEGRESMBX;
N
N
N/**
N *Abort request
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER            MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER            CoeHeader; /**< \brief CoE header*/
N  TINITSDOHEADER        SdoHeader; /**< \brief SDO header*/
N  UINT32             AbortCode; /**< \brief SDO abort code*/
X  unsigned int             AbortCode;  
N}MBX_STRUCT_PACKED_END
X}
NTABORTSDOTRANSFERREQMBX;
N
N
N#define ABORT_NORM_RES_SIZE    (SIZEOF(TABORTSDOTRANSFERREQMBX) - SIZEOF(TMBXHEADER))/**< \brief Size of the SDO Abort datagram (without the mailbox header)*/
N/** @}*/
N
N
N/**
N * \addtogroup SDOAbort SDO Abort Codes
N * @{
N */
N#define     ABORT_NOERROR                                                   0x00000000 /**< \brief No SDO error*/
N#define     ABORT_TOGGLE_BIT_NOT_CHANGED                                    0x05030000 /**< \brief Toggle bit not changed*/
N#define     ABORT_SDO_PROTOCOL_TIMEOUT                                      0x05040000 /**< \brief SDO timeout*/
N#define     ABORT_COMMAND_SPECIFIER_UNKNOWN                                 0x05040001 /**< \brief Command specifier unknown*/
N#define     ABORT_OUT_OF_MEMORY                                             0x05040005 /**< \brief Out of memory*/
N#define     ABORT_UNSUPPORTED_ACCESS                                        0x06010000 /**< \brief Unsupported Access*/
N#define     ABORT_WRITE_ONLY_ENTRY                                          0x06010001 /**< \brief Write only entry*/
N#define     ABORT_READ_ONLY_ENTRY                                           0x06010002 /**< \brief Read only entry*/
N#define     ABORT_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0                           0x06010003 /**< \brief Entry can not be written because Subindex0 is not 0*/
N#define     ABORT_COMPLETE_ACCESS_NOT_SUPPORTED                             0x06010004 /**< \brief The object can not be accessed via complete access*/
N#define     ABORT_OBJECT_NOT_EXISTING                                       0x06020000 /**< \brief Object not existing*/
N#define     ABORT_OBJECT_CANT_BE_PDOMAPPED                                  0x06040041 /**< \brief Object can not be mapped to PDO*/
N#define     ABORT_MAPPED_OBJECTS_EXCEED_PDO                                 0x06040042 /**< \brief Mapped Object exceeds PDO*/
N#define     ABORT_PARAM_IS_INCOMPATIBLE                                     0x06040043 /**< \brief Parameter is incompatible*/
N#define     ABORT_INTERNAL_DEVICE_INCOMPATIBILITY                           0x06040047 /**< \brief Device incompatibility*/
N#define     ABORT_HARDWARE_ERROR                                            0x06060000 /**< \brief Hardware error*/
N#define     ABORT_PARAM_LENGTH_ERROR                                        0x06070010 /**< \brief Parameter length error*/
N#define     ABORT_PARAM_LENGTH_TOO_LONG                                     0x06070012 /**< \brief Parameter is too long*/
N#define     ABORT_PARAM_LENGTH_TOO_SHORT                                    0x06070013 /**< \brief Parameter is too short*/
N#define     ABORT_SUBINDEX_NOT_EXISTING                                     0x06090011 /**< \brief Subindex (Entry) not exists*/
N#define     ABORT_VALUE_EXCEEDED                                            0x06090030 /**< \brief Value exceeds*/
N#define     ABORT_VALUE_TOO_GREAT                                           0x06090031 /**< \brief Value is too great*/
N#define     ABORT_VALUE_TOO_SMALL                                           0x06090032 /**< \brief Value is too small*/
N#define     ABORT_MODULE_ID_LIST_NOT_MATCH                                  0x06090033 /**< \brief Detected Module Ident List (0xF030) and Configured Module Ident list (0xF050) does not match*/
N#define     ABORT_MAX_VALUE_IS_LESS_THAN_MIN_VALUE                          0x06090036 /**< \brief Value is less than minimum value*/
N#define     ABORT_GENERAL_ERROR                                             0x08000000 /**< \brief General error*/
N#define     ABORT_DATA_CANNOT_BE_READ_OR_STORED                             0x08000020 /**< \brief Data can not be read or written*/
N#define     ABORT_DATA_CANNOT_BE_READ_OR_STORED_BECAUSE_OF_LOCAL_CONTROL    0x08000021 /**< \brief Data can not be accessed because of local control*/
N#define     ABORT_DATA_CANNOT_BE_READ_OR_STORED_IN_THIS_STATE               0x08000022 /**< \brief Data can not be read or written in the current state*/
N#define     ABORT_NO_OBJECT_DICTIONARY_IS_PRESENT                           0x08000023 /**< \brief Object is not in the object dictionary*/
N
N
N/**
N * \addtogroup SDOAbortIndex SDO Abort Codes Identifier
N * @{
N * Internal the SDO abort codes are handled in an array.
N */
N#define     ABORTIDX_TOGGLE_BIT_NOT_CHANGED                                 0x01 /**< \brief Index of "Toggle bit not changed"*/
N#define     ABORTIDX_SDO_PROTOCOL_TIMEOUT                                   0x02 /**< \brief Index of "SDO timeout"*/
N#define     ABORTIDX_COMMAND_SPECIFIER_UNKNOWN                              0x03 /**< \brief Index of "Command specifier unknown"*/
N#define     ABORTIDX_OUT_OF_MEMORY                                          0x04 /**< \brief Index of "Out of memory"*/
N#define     ABORTIDX_UNSUPPORTED_ACCESS                                     0x05 /**< \brief Index of "Unsupported Access"*/
N#define     ABORTIDX_WRITE_ONLY_ENTRY                                       0x06 /**< \brief Index of "Write only entry"*/
N#define     ABORTIDX_READ_ONLY_ENTRY                                        0x07 /**< \brief Index of "Read only entry"*/
N#define     ABORTIDX_OBJECT_NOT_EXISTING                                    0x08 /**< \brief Index of "Object not existing"*/
N#define     ABORTIDX_OBJECT_CANT_BE_PDOMAPPED                               0x09 /**< \brief Index of "Object can not be mapped to PDO"*/
N#define     ABORTIDX_MAPPED_OBJECTS_EXCEED_PDO                              0x0A /**< \brief Index of "Mapped Object exceeds PDO"*/
N#define     ABORTIDX_PARAM_IS_INCOMPATIBLE                                  0x0B /**< \brief Index of "Parameter is incompatible"*/
N#define     ABORTIDX_INTERNAL_DEVICE_INCOMPATIBILITY                        0x0C /**< \brief Index of "Device incompatibility"*/
N#define     ABORTIDX_HARDWARE_ERROR                                         0x0D /**< \brief Index of "Hardware error"*/
N#define     ABORTIDX_PARAM_LENGTH_ERROR                                     0x0E /**< \brief Index of "Parameter length error"*/
N#define     ABORTIDX_PARAM_LENGTH_TOO_LONG                                  0x0F /**< \brief Index of "Parameter is too long"*/
N#define     ABORTIDX_PARAM_LENGTH_TOO_SHORT                                 0x10 /**< \brief Index of "Parameter is too short"*/
N#define     ABORTIDX_SUBINDEX_NOT_EXISTING                                  0x11 /**< \brief Index of "Subindex (Entry) not exists"*/
N#define     ABORTIDX_VALUE_EXCEEDED                                         0x12 /**< \brief Index of "Value exceeds"*/
N#define     ABORTIDX_VALUE_TOO_GREAT                                        0x13 /**< \brief Index of "Value is too great"*/
N#define     ABORTIDX_VALUE_TOO_SMALL                                        0x14 /**< \brief Index of "Value is too small"*/
N#define     ABORTIDX_MODULE_ID_LIST_NOT_MATCH                               0x15 /**< \brief  Index of "Unequal Module Id list"*/
N#define     ABORTIDX_MAX_VALUE_IS_LESS_THAN_MIN_VALUE                       0x16 /**< \brief Index of "Value is less than minimum value"*/
N#define     ABORTIDX_GENERAL_ERROR                                          0x17 /**< \brief Index of "General error"*/
N#define     ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED                          0x18 /**< \brief Index of "Data can not be read or written"*/
N#define     ABORTIDX_DATA_CANNOT_BE_ACCESSED_BECAUSE_OF_LOCAL_CONTROL       0x19 /**< \brief Index of "Data can not be accessed because of local control"*/
N#define     ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED            0x1A /**< \brief Index of "Data can not be read or written in the current state"*/
N#define     ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT                        0x1B /**< \brief Index of "Object is not in the object dictionary"*/
N#define     ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0                        0x1C /**< \brief Index of "Entry can not be written because Subindex0 is not 0"*/
N#define     ABORTIDX_COMPLETE_ACCESS_NOT_SUPPORTED                          0x1D /**< \brief The object can not be accessed via complete access*/
N#define     ABORTIDX_WORKING                                                0xFF /**< \brief Index of application is handling the SDO request*/
N/** @}*/
N/** @}*/
N
N
N/**
N *\addtogroup SdoServices SDO Services
N * @{
N */
N#define    SDOINFOSERVICE_OBJDICTIONARYLIST_Q           0x01 /**< \brief SDO Info Get object list request*/
N#define    SDOINFOSERVICE_OBJDICTIONARYLIST_S           0x02 /**< \brief SDO Info Get object list response*/
N#define    SDOINFOSERVICE_OBJDESCRIPTION_Q              0x03 /**< \brief SDO Info Get object description request*/
N#define    SDOINFOSERVICE_OBJDESCRIPTION_S              0x04 /**< \brief SDO Info Get object description response*/
N#define    SDOINFOSERVICE_ENTRYDESCRIPTION_Q            0x05 /**< \brief SDO Info Get entry description request*/
N#define    SDOINFOSERVICE_ENTRYDESCRIPTION_S            0x06 /**< \brief SDO Info Get entry description request*/
N#define    SDOINFOSERVICE_ERROR_Q                       0x07 /**< \brief SDO Info Error*/
N#define    SDOINFOSERVICE_INCOMPLETE                    0x80 /**< \brief SDO Info Incomplete flag*/
N/** @}*/
N
N
N/**
N *\addtogroup SdoHeaderData SDO Header and Data
N * @{
N */
N/**
N * SDO Info Object list
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16                ListType; /**< \brief List type variable*/
X    unsigned short                ListType;  
N        #define    INFO_LIST_TYPE_LENGTH    0 /**< \brief Length of all list types*/
N        #define    INFO_LIST_TYPE_ALL       1 /**< \brief All objects*/
N        #define    INFO_LIST_TYPE_RXPDO     2 /**< \brief Only RxPDO mappable objects*/
N        #define    INFO_LIST_TYPE_TXPDO     3 /**< \brief Only TxPDO mappable objects*/
N        #define    INFO_LIST_TYPE_BACKUP    4 /**< \brief Only backup objects*/
N        #define    INFO_LIST_TYPE_SET       5 /**< \brief Only setting objects*/
N        #define    INFO_LIST_TYPE_MAX       5 /**< \brief Max list identifier*/
N}MBX_STRUCT_PACKED_END
X}
NTSDOINFOLIST;
N
N
N/**
N * Object description
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16            DataType; /**< \brief Object data type*/
X    unsigned short            DataType;  
N    UINT16            ObjFlags; /**< \brief Object flags (including object code and max subindex)*/
X    unsigned short            ObjFlags;  
N
N    /*Object Code and MaxSubindex will be set manually in the object dictionary. The value is always created in little endian format*/
N    #define    OBJFLAGS_MAXSUBINDEXMASK    0x00FF /**< \brief Max subindex mask*/
N    #define    OBJFLAGS_MAXSUBINDEXSHIFT   0 /**< \brief Max subindex shift*/
N    #define    OBJFLAGS_OBJCODEMASK        0x0F00 /**< \brief Mask Object code mask*/
N    #define    OBJFLAGS_OBJCODESHIFT       8 /**< \brief Object code shift*/
N
N    #define    OBJCODE_VAR                 0x07 /**< \brief Object code VARIABLE*/
N    #define    OBJCODE_ARR                 0x08 /**< \brief Object code ARRAY*/
N    #define    OBJCODE_REC                 0x09 /**< \brief Object code RECORD*/
N
N//        char                Name[];                // rest of mailbox data
N}MBX_STRUCT_PACKED_END
X}
NTSDOINFOOBJDESC;
N
N
N#define SDO_INFO_OBJ_DESC_SIZE      SIZEOF(TSDOINFOOBJDESC) /**< \brief Object description size*/
N
N
N/**
N * SDO Info object description service data
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16            Index; /**< \brief Object index*/
X    unsigned short            Index;  
N    TSDOINFOOBJDESC   Res; /**< \brief Description data*/
N}MBX_STRUCT_PACKED_END
X}
NTSDOINFOOBJ;
N
N
N#define SDO_INFO_OBJ_DESC_RES_SIZE  SIZEOF(TSDOINFOOBJ)/**< \brief Size of the object description service data*/
N
N
N/**
N * SDO Info entry description
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16                DataType; /**< \brief Entry data type*/
X    unsigned short                DataType;  
N    UINT16                BitLength; /**< \brief Entry bit size*/
X    unsigned short                BitLength;  
N    UINT16                ObjAccess; /**< \brief Entry access rights*/
X    unsigned short                ObjAccess;  
N                                     /**<
N                                     Bit 0: Read Access in Pre-Op
N                                     <br>Bit 1: Read Access in Safe-Op
N                                     <br>Bit 2: Read Access in Op
N                                     <br>Bit 3: Write Access in Pre-Op
N                                     <br>Bit 4: Write Access in Safe-Op
N                                     <br>Bit 5: Write Access in Op
N                                     <br>Bit 6: mappable in RxPDO
N                                     <br>Bit 7: mappable in TxPDO
N                                     <br>Bit 8: entry will be included in backup
N                                     <br>Bit 9: entry will be included in settings*/
N
N        #define    ACCESS_READWRITE             0x003F /**< \brief Read/write in all states*/
N        #define    ACCESS_READ                  0x0007 /**< \brief Read only in all states*/
N        #define    ACCESS_READ_PREOP            0x0001 /**< \brief Read only in PreOP*/
N        #define    ACCESS_READ_SAFEOP           0x0002 /**< \brief Read only in SafeOP*/
N        #define    ACCESS_READ_OP               0x0004 /**< \brief Read only in OP*/
N        #define    ACCESS_WRITE                 0x0038 /**< \brief Write only in all states*/
N        #define    ACCESS_WRITE_PREOP           0x0008 /**< \brief Write only in PreOP*/
N        #define    ACCESS_WRITE_SAFEOP          0x0010 /**< \brief Write only in SafeOP*/
N        #define    ACCESS_WRITE_OP              0x0020 /**< \brief Write only in OP*/
N        #define    OBJACCESS_NOPDOMAPPING       0x0000 /**< \brief Not PDO mappable*/
N        #define    OBJACCESS_RXPDOMAPPING       0x0040 /**< \brief Mappable in RxPDOs*/
N        #define    OBJACCESS_TXPDOMAPPING       0x0080 /**< \brief Mappable in TxPDOs*/
N        #define    OBJACCESS_BACKUP             0x0100 /**< \brief Backup entry*/
N        #define    OBJACCESS_SETTINGS           0x0200 /**< \brief Setting Entry*/
N        #define    OBJACCESS_SAFEINPUTS         0x0400 /**< \brief Safe input*/
N        #define    OBJACCESS_SAFEOUTPUTS        0x0800 /**< \brief Safe output*/
N        #define    OBJACCESS_SAFEPARAMETER      0x1000 /**< \brief Safe parameter*/
N}MBX_STRUCT_PACKED_END
X}
NTSDOINFOENTRYDESC;
N
N
N/**
N * SDO Info entry description service data
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16                Index; /**< \brief Index of the parent object*/
X    unsigned short                Index;  
N    UINT16                 Info; /**< \brief Info data including the subindex and identifier for the payload data*/
X    unsigned short                 Info;  
N/*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 565 to 570 deleted*/
N        #define     ENTRY_MASK_SUBINDEX     0x00FF /**< \brief Subindex mask*/
N        #define     ENTRY_SUBINDEX_SHIFT    0 /**< \brief Subindex shift*/
N        #define     ENTRY_MASK_VALUEINFO    0xFF00 /**< \brief Value info mask*/
N        #define     ENTRY_VALUEINFO_SHIFT   8 /**< \brief Value info shift*/
N
N    TSDOINFOENTRYDESC    Res; /**< \brief Entry description data*/
N}MBX_STRUCT_PACKED_END
X}
NTSDOINFOENTRY;
N
N
N/**
N * SDO info Error
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT32                ErrorCode; /**< \brief SDO Info error code*/
X    unsigned int                ErrorCode;  
N}MBX_STRUCT_PACKED_END
X}
NTSDOINFOERROR;
N
N
N#define SDO_INFO_ERROR_SIZE     SIZEOF(TSDOINFOERROR)/**< \brief SDO Info error size*/
N
N
N/**
N *SDO Info header
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16 InfoHead; /**< \brief Opcode, Incomplete flag and 8 reserved bits*/
X    unsigned short InfoHead;  
N/*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 601 to 606 deleted*/
N        #define     INFOHEAD_OPCODE_MASK            0x007F /**< \brief Opcode mask*/
N        #define     INFOHEAD_OPCODE_SHIFT           0 /**< \brief Opcode shift*/
N        #define     INFOHEADER_INCOMPLETE_MASK      0x0080 /**< \brief Incomplete mask*/
N        #define     INFOHEADER_INCOMPLETE_SHIFT     0 /**< \brief Incomplete shift, the incomplete value "SDOINFOSERVICE_INCOMPLETE" is defined as a UINT8 => no shift required*/
N
N    UINT16                FragmentsLeft; /**< \brief Number of fragments which will follow*/
X    unsigned short                FragmentsLeft;  
N
N    union MBX_STRUCT_PACKED_START
X    union 
N    {
N        TSDOINFOLIST    List;/**< \brief List data*/
N        TSDOINFOOBJ     Obj;/**< \brief Object Description data*/
N        TSDOINFOENTRY   Entry;/**< \brief Entry description data*/
N        TSDOINFOERROR   Error;/**< \brief Error data*/
N        UINT16          Data[1];/**< \brief Unspecified data*/
X        unsigned short          Data[1]; 
N    }MBX_STRUCT_PACKED_END
X    }
N    Data;/**< \brief Service data*/
N
N}MBX_STRUCT_PACKED_END
X}
NTSDOINFOHEADER;
N
N
N/**
N * SDO Info complete datagram
N */
Ntypedef struct MBX_STRUCT_PACKED_START
Xtypedef struct 
N{
N  TMBXHEADER        MbxHeader; /**< \brief Mailbox header*/
N  TCOEHEADER        CoeHeader; /**< \brief CoE header*/
N  TSDOINFOHEADER    SdoHeader; /**< \brief SDO Info header and data*/
N}MBX_STRUCT_PACKED_END
X}
NTSDOINFORMATION;
N
N
N#define     SIZEOF_SDOINFOHEAD                  4 /**< \brief SDO Info header size*/
N#define     SIZEOF_SDOINFO                      ( (COE_HEADER_SIZE) + (SIZEOF_SDOINFOHEAD )) /**< \brief SDO Info and CoE Size*/
N#define     SIZEOF_SDOINFOSTRUCT                ( (MBX_HEADER_SIZE) + (COE_HEADER_SIZE) + (SIZEOF_SDOINFOHEAD) ) /**< \brief Complete SDO Info datagram size*/
N#define     SIZEOF_SDOINFOLISTHEAD              2 /**< \brief SDO Info list header size*/
N#define     SIZEOF_SDOINFOLISTSTRUCT            (( COE_HEADER_SIZE) + (SIZEOF_SDOINFOHEAD) + (SIZEOF_SDOINFOLISTHEAD) ) /**< \brief Complete SDO Info list size*/
N#define     SIZEOF_SDOINFOOBJSTRUCT             ( (COE_HEADER_SIZE) + (SIZEOF_SDOINFOHEAD) + (SDO_INFO_OBJ_DESC_RES_SIZE) ) /**< \brief Complete SDO Info object description response size*/
N#define     SIZEOF_SDOINFOENTRYREQHEAD          4 /**< \brief SDO Info entry description request size*/
N#define     SIZEOF_SDOINFOENTRYREQSTRUCT        ( (COE_HEADER_SIZE) + (SIZEOF_SDOINFOHEAD) + (SIZEOF_SDOINFOENTRYREQHEAD) ) /**< \brief SDO Info entry description request size*/
N#define     SIZEOF_SDOINFOERRORSTRUCT           ( (COE_HEADER_SIZE) + (SIZEOF_SDOINFOHEAD) + (SDO_INFO_ERROR_SIZE) ) /**< \brief SDO Info error size*/
N
N
N#define SDO_INFO_HEADER_BYTE_SIZE         ((SIZEOF_SDOINFOSTRUCT)+(SIZEOF_SDOINFOLISTHEAD)) /**< \brief SDO Info size*/
N/** @}*/
N
N
N/**
N * \addtogroup SdoPendingHandler SDO Pending Response
N * @{
N * If this feature is enabled (SDO_RES_INTERFACE 1) a SDO request may set to pending and is completed afterwards.
N * This can be used to forward the read/write request an additional thread, uController.
N */
N#define     SDO_PENDING_WRITE       0x1 /**< \brief SDO write request is pending*/
N#define     SDO_PENDING_SEG_WRITE   0x2 /**< \brief SDO segmented write request is pending*/
N#define     SDO_PENDING_READ        0x3 /**< \brief SDO read request is pending*/
N#define     SDO_PENDING_SEG_READ    0x4 /**< \brief SDO segmented read request is pending*/
N/** @}*/
N
N
N#endif //_SDOSRV_H_
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Variables
N------
N-----------------------------------------------------------------------------------------*/
N#if defined(_SDOSERV_) && (_SDOSERV_ == 1)
X#if 0L && (_SDOSERV_ == 1)
S    #define PROTO
N#else
N    #define PROTO extern
N#endif
N
N/**
N * \addtogroup SdoPendingHandler SDO Pending Response
N *@{
N */
NPROTO UINT8         u8PendingSdo; /**< \brief Identifier for the pending SDO service (see SDO_PENDING_XXX defines)*/
Xextern unsigned char         u8PendingSdo;  
NPROTO BOOL          bStoreCompleteAccess; /**< \brief Indicates if the pending SDO service is an complete access*/
Xextern unsigned char          bStoreCompleteAccess;  
NPROTO UINT8         u8StoreSubindex; /**< \brief Contains the subindex for the pending SDO request*/
Xextern unsigned char         u8StoreSubindex;  
NPROTO UINT16        u16StoreIndex; /**< \brief Contains the Index for the pending SDO request*/
Xextern unsigned short        u16StoreIndex;  
NPROTO UINT32        u32StoreDataSize; /**< \brief Complete data size to be handled*/
Xextern unsigned int        u32StoreDataSize;  
NPROTO UINT16 MBXMEM *pStoreData; /**< \brief Pointer to the buffer to be handled*/
Xextern unsigned short  *pStoreData;  
NPROTO UINT8 (* pSdoPendFunc)( UINT16 Index, UINT8 Subindex, UINT32 Size, UINT16 MBXMEM * pData, UINT8 bCompleteAccess ); /**< \brief Function pointer for the SDO pending request handler*/
Xextern unsigned char (* pSdoPendFunc)( unsigned short Index, unsigned char Subindex, unsigned int Size, unsigned short  * pData, unsigned char bCompleteAccess );  
N/** @}*/
N
N
NPROTO MEM_ADDR      VARMEM                aSdoInfoHeader[GET_MEM_SIZE(SDO_INFO_HEADER_BYTE_SIZE)]; /**< \brief SDO Info buffer*/
Xextern unsigned char                      aSdoInfoHeader[(((((( (6) + (2) + (4) ))+(2)))+3) >> 2)];  
N
N
N/**
N * \addtogroup SegmentedSdo Segmented SDO
N * @{
N */
NPROTO UINT16 VARMEM * VARMEM                pSdoSegData; /**< \brief Pointer to the buffer handling to full object/entry data*/
Xextern unsigned short  *                 pSdoSegData;  
NPROTO UINT16          VARMEM                nSdoInfoFragmentsLeft; /**< \brief Number of fragments which need to be transmitted*/
Xextern unsigned short                          nSdoInfoFragmentsLeft;  
N/** @}*/
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Functions
N------
N-----------------------------------------------------------------------------------------*/
NPROTO    UINT8 SDOS_SdoInfoInd(TSDOINFORMATION MBXMEM *pSdoInfoInd);
Xextern    unsigned char SDOS_SdoInfoInd(TSDOINFORMATION  *pSdoInfoInd);
NPROTO    UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd);
Xextern    unsigned char SDOS_SdoInd(TINITSDOMBX  *pSdoInd);
N
NPROTO    void  SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData);
Xextern    void  SDOS_SdoRes(unsigned char abort, unsigned int objLength, unsigned short  *pData);
NPROTO    void  SDOS_ClearPendingResponse(void);
Xextern    void  SDOS_ClearPendingResponse(void);
N
N
N#undef PROTO
N/** @}*/
L 41 ".\etherCAT\objdef.h" 2
N
N
N#ifndef _OBJDEF_H_
N#define _OBJDEF_H_
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Defines and Types
N------
N-----------------------------------------------------------------------------------------*/
N
N/*---------------------------------------------
N-    DataTypes
N-----------------------------------------------*/
N#define     DEFTYPE_NULL                0x0000 /**< \brief Null*/
N#define     DEFTYPE_BOOLEAN             0x0001 /**< \brief BOOLEAN*/
N#define     DEFTYPE_INTEGER8            0x0002 /**< \brief INTEGER8*/
N#define     DEFTYPE_INTEGER16           0x0003 /**< \brief INTEGER16*/
N#define     DEFTYPE_INTEGER24           0x0010 /**< \brief INTEGER24*/
N#define     DEFTYPE_INTEGER32           0x0004 /**< \brief INTEGER32*/
N#define     DEFTYPE_INTEGER40           0x0012 /**< \brief INTEGER40*/
N#define     DEFTYPE_INTEGER48           0x0013 /**< \brief INTEGER48*/
N#define     DEFTYPE_INTEGER56           0x0014 /**< \brief INTEGER56*/
N#define     DEFTYPE_UNSIGNED8           0x0005 /**< \brief UNSIGNED8*/
N#define     DEFTYPE_UNSIGNED16          0x0006 /**< \brief UNSIGNED16*/
N#define     DEFTYPE_UNSIGNED24          0x0016 /**< \brief UNSIGNED24*/
N#define     DEFTYPE_UNSIGNED32          0x0007 /**< \brief UNSIGNED32*/
N#define     DEFTYPE_REAL32              0x0008 /**< \brief REAL32*/
N#define     DEFTYPE_VISIBLESTRING       0x0009 /**< \brief VISIBLE_STRING*/
N#define     DEFTYPE_OCTETSTRING         0x000A /**< \brief OCTET_STRING*/
N#define     DEFTYPE_UNICODE_STRING      0x000B /**< \brief UNICODE_STRING*/
N#define     DEFTYPE_TIME_OF_DAY         0x000C /**< \brief TIME_OF_DAY*/
N#define     DEFTYPE_TIME_DIFFERENCE     0x000D /**< \brief TIME_DIFFERENCE*/
N#define     DEFTYPE_INTEGER24           0x0010 /**< \brief INTEGER24*/
N#define     DEFTYPE_REAL64              0x0011 /**< \brief REAL64*/
N#define     DEFTYPE_INTEGER40           0x0012 /**< \brief INTEGER40*/
N#define     DEFTYPE_INTEGER48           0x0013 /**< \brief INTEGER48*/
N#define     DEFTYPE_INTEGER56           0x0014 /**< \brief INTEGER56*/
N#define     DEFTYPE_INTEGER64           0x0015 /**< \brief INTEGER64*/
N#define     DEFTYPE_UNSIGNED24          0x0016 /**< \brief UNSIGNED24*/
N#define     DEFTYPE_UNSIGNED40          0x0018 /**< \brief UNSIGNED40*/
N#define     DEFTYPE_UNSIGNED48          0x0019 /**< \brief UNSIGNED48*/
N#define     DEFTYPE_UNSIGNED56          0x001A /**< \brief UNSIGNED56*/
N#define     DEFTYPE_UNSIGNED64          0x001B /**< \brief UNSIGNED64*/
N#define     DEFTYPE_GUID                0x001D /**< \brief DEFTYPE_GUID*/
N#define     DEFTYPE_BYTE                0x001E /**< \brief DEFTYPE_BYTE*/
N#define     DEFTYPE_WORD                0x001F /**< \brief DEFTYPE_WORD*/
N#define     DEFTYPE_DWORD               0x0020 /**< \brief DEFTYPE_DWORD*/
N#define     DEFTYPE_PDOMAPPING          0x0021 /**< \brief PDO_MAPPING*/
N#define     DEFTYPE_IDENTITY            0x0023 /**< \brief IDENTITY*/
N#define     DEFTYPE_COMMAND             0x0025 /**< \brief COMMAND_PAR*/
N#define     DEFTYPE_PDOCOMPAR           0x0027 /**< \brief PDO_PARAMETER*/
N#define     DEFTYPE_ENUM                0x0028 /**< \brief DEFTYPE_ENUM */
N#define     DEFTYPE_SMPAR               0x0029 /**< \brief SM_SYNCHRONISATION*/ 
N#define     DEFTYPE_RECORD              0x002A /**< \brief DEFTYPE_RECORD */
N#define     DEFTYPE_BACKUP              0x002B /**< \brief BACKUP_PARAMETER*/
N#define     DEFTYPE_MDP                 0x002C /**< \brief MODULAR_DEVICE_PROFILE*/
N#define     DEFTYPE_BITARR8             0x002D /**< \brief BITARR8*/
N#define     DEFTYPE_BITARR16            0x002E /**< \brief BITARR16*/
N#define     DEFTYPE_BITARR32            0x002F /**< \brief BITARR32*/
N#define     DEFTYPE_BIT1                0x0030 /**< \brief BIT1*/
N#define     DEFTYPE_BIT2                0x0031 /**< \brief BIT2*/
N#define     DEFTYPE_BIT3                0x0032 /**< \brief BIT3*/
N#define     DEFTYPE_BIT4                0x0033 /**< \brief BIT4*/
N#define     DEFTYPE_BIT5                0x0034 /**< \brief BIT5*/
N#define     DEFTYPE_BIT6                0x0035 /**< \brief BIT6*/
N#define     DEFTYPE_BIT7                0x0036 /**< \brief BIT7*/
N#define     DEFTYPE_BIT8                0x0037 /**< \brief BIT8*/
N#define     DEFTYPE_ARRAY_OF_INT        0x0260 /**< \brief DEFTYPE_ARRAY_OF_INT*/
N#define     DEFTYPE_ARRAY_OF_SINT       0x0261 /**< \brief DEFTYPE_ARRAY_OF_SINT*/
N#define     DEFTYPE_ARRAY_OF_DINT       0x0262 /**< \brief DEFTYPE_ARRAY_OF_DINT*/
N#define     DEFTYPE_ARRAY_OF_UDINT      0x0263 /**< \brief DEFTYPE_ARRAY_OF_UDINT*/
N#define     DEFTYPE_ERRORHANDLING       0x0281 /**< \brief DEFTYPE_ERRORHANDLING*/
N#define     DEFTYPE_DIAGHISTORY         0x0282 /**< \brief DEFTYPE_DIAGHISTORY*/
N#define     DEFTYPE_SYNCSTATUS          0x0283 /**< \brief DEFTYPE_SYNCSTATUS*/
N#define     DEFTYPE_SYNCSETTINGS        0x0284 /**< \brief DEFTYPE_SYNCSETTINGS*/
N#define     DEFTYPE_FSOEFRAME           0x0285 /**< \brief DEFTYPE_FSOEFRAME*/
N#define     DEFTYPE_FSOECOMMPAR         0x0286 /**< \brief DEFTYPE_FSOECOMMPAR*/
N
N
N/*---------------------------------------------
N-    Flags for supported Synctypes (0x1C32.4 / 0x1C33.4)
N-----------------------------------------------*/
N
N#define     SYNCTYPE_FREERUNSUPP        0x0001 /**< \brief FreeRun supported*/
N#define     SYNCTYPE_SYNCHRONSUPP       0x0002 /**< \brief SyncManager synchron supported*/
N#define     SYNCTYPE_DCSYNC0SUPP        0x0004 /**< \brief Sync0 synchron supported*/
N#define     SYNCTYPE_DCSYNC1SUPP        0x0008 /**< \brief Sync1 synchron supported*/
N#define     SYNCTYPE_SUBCYCLESUPP       0x0010 /**< \brief Subordinated Application with fixed Sync0 supported*/
N#define     SYNCTYPE_LOCALSHIFTSUPP     0x0020 /**< \brief Event shift with local timer supported. Output shift : 0x1C32.4 ; Input shift : 0x1C33.4 (not supported by the default SSC)*/
N#define     SYNCTYPE_SHIFTBYSYNC1SUPP   0x0040 /**< \brief Event shift with Sync1 event supported. Output shift : 0x1C32.4 ; Input shift : 0x1C33.4*/
N#define     SYNCTYPE_MEASURE_DELAYSUPP  0x0200 /**< \brief Delay times should be measured (not supported by the default SSC, only the cycle time can be measured (1ms resolution)*/
N#define     SYNCTYPE_FIXED_DELAYSUPP    0x0400 /**< \brief Delay times are fixed*/
N#define     SYNCTYPE_TIMESVARIABLE      0x4000 /**< \brief Dynamic Cycle Times supported*/
N
N
N#define     IS_PDO_ASSIGN(x)            ((x >= 0x1C10) && (x <= 0x1C2F)) /**< \brief Macro to check if object index is SyncManager assign object*/
N#define     IS_RX_PDO(x)                (((x) >= 0x1600) && ((x) <= 0x17FF)) /**< \brief Macro to check if object index RxPDO mapping object*/
N#define     IS_TX_PDO(x)                (((x) >= 0x1A00) && ((x) <= 0x1BFF)) /**< \brief Macro to check if object index TxPDO mapping object*/
N
N
N/**
N * \brief Object dictionary entry structure
N */
Ntypedef struct OBJ_ENTRY
N{
N    struct OBJ_ENTRY                      *pPrev; /**< \brief Previous entry(object) in the object dictionary list*/
N    struct OBJ_ENTRY                      *pNext; /**< \brief Next entry(object) in the object dictionary list*/
N
N    UINT16                                Index; /**< \brief Object index*/
X    unsigned short                                Index;  
N    TSDOINFOOBJDESC                       ObjDesc; /**< \brief Object access, type and code*/
N    OBJCONST TSDOINFOENTRYDESC OBJMEM     *pEntryDesc; /**< \brief pointer to object entry descriptions*/
X    const TSDOINFOENTRYDESC      *pEntryDesc;  
N    OBJCONST UCHAR OBJMEM                 *pName; /**< \brief Pointer to object and entry names*/
X    const unsigned char                  *pName;  
N    void MBXMEM                           *pVarPtr; /**< \brief Pointer to object buffer*/
X    void                            *pVarPtr;  
N    UINT8 (* Read)( UINT16 Index, UINT8 Subindex, UINT32 Size, UINT16 MBXMEM * pData, UINT8 bCompleteAccess ); /**< \brief Function pointer to read function (if NULL default read function will be used)*/
X    unsigned char (* Read)( unsigned short Index, unsigned char Subindex, unsigned int Size, unsigned short  * pData, unsigned char bCompleteAccess );  
N    UINT8 (* Write)( UINT16 Index, UINT8 Subindex, UINT32 Size, UINT16 MBXMEM * pData, UINT8 bCompleteAccess ); /**< \brief Function pointer to write function (if NULL default write function will be used)*/
X    unsigned char (* Write)( unsigned short Index, unsigned char Subindex, unsigned int Size, unsigned short  * pData, unsigned char bCompleteAccess );  
N    UINT16                                 NonVolatileOffset; /**< \brief Offset within the non volatile memory (need to be defined for backup objects)*/
X    unsigned short                                 NonVolatileOffset;  
N}
NTOBJECT;
N
N
N/**
N * Object 0x1C3x (SyncManager Parameter) data structure
N */
Ntypedef struct OBJ_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16    subindex0;/**< \brief SubIndex0*/
X    unsigned short    subindex0; 
N    UINT16    u16SyncType; /**< \brief SunbIndex 001: Sync type*/
X    unsigned short    u16SyncType;  
N    UINT32    u32CycleTime;/**< \brief SunbIndex 002: Cycle time */
X    unsigned int    u32CycleTime; 
N    UINT32    u32Subindex003;/**< \brief SunbIndex 003: Shift time (not supported, variable is only used as a place holder)*/
X    unsigned int    u32Subindex003; 
N    UINT16    u16SyncTypesSupported;/**< \brief SunbIndex 004: Supported Sync types*/
X    unsigned short    u16SyncTypesSupported; 
N    UINT32    u32MinCycleTime;/**< \brief SunbIndex 005: Min cycle time*/
X    unsigned int    u32MinCycleTime; 
N    UINT32    u32CalcAndCopyTime;/**< \brief SunbIndex 006: Calc and Copy time*/
X    unsigned int    u32CalcAndCopyTime; 
N    UINT32    u32Si7Reserved;/**< \brief SunbIndex 007: 32Bit Reserved*/
X    unsigned int    u32Si7Reserved; 
N    UINT16    u16GetCycleTime;/**< \brief SunbIndex 008: Get cycle time*/
X    unsigned short    u16GetCycleTime; 
N    UINT32    u32DelayTime; /**< \brief SunbIndex 009: Delay time*/
X    unsigned int    u32DelayTime;  
N    UINT32    u32Sync0CycleTime; /**< \brief SunbIndex 010: Sync0 cycle time*/
X    unsigned int    u32Sync0CycleTime;  
N    UINT16    u16SmEventMissedCounter; /**< \brief SunbIndex 011: SyncManager event missed counter*/
X    unsigned short    u16SmEventMissedCounter;  
N    UINT16    u16CycleExceededCounter; /**< \brief SunbIndex 012: Cycle exceed counter*/
X    unsigned short    u16CycleExceededCounter;  
N    UINT16    u16ShiftTooShort; /**< \brief SunbIndex 013: Shift too short*/
X    unsigned short    u16ShiftTooShort;  
N    UINT16    u16Si14Reserved; /**< \brief SubIndex14 not supported*/
X    unsigned short    u16Si14Reserved;  
N    UINT32    u32Si15Reserved; /**< \brief SubIndex15 not supported*/
X    unsigned int    u32Si15Reserved;  
N    UINT32    u32Si16Reserved; /**< \brief SubIndex16 not supported*/
X    unsigned int    u32Si16Reserved;  
N    UINT32    u32Si17Reserved; /**< \brief SubIndex17 not supported*/
X    unsigned int    u32Si17Reserved;  
N    UINT32    u32Si18Reserved; /**< \brief SubIndex18 not supported*/
X    unsigned int    u32Si18Reserved;  
N    UINT8    u8SyncError; /**< \brief Sync Error*/
X    unsigned char    u8SyncError;  
N}OBJ_STRUCT_PACKED_END
X}
NTSYNCMANPAR;
N
N/**
N * Cycle diagnosis
N */
Ntypedef struct OBJ_STRUCT_PACKED_START
Xtypedef struct 
N{
N    UINT16    syncFailedCounter; /**< \brief Sync Failed Counter*/
X    unsigned short    syncFailedCounter;  
N}OBJ_STRUCT_PACKED_END
X}
NTCYCLEDIAG;
N
N
N/**
N * Object 0x10F1 (Error Settings Object) data structure
N */
Ntypedef struct OBJ_STRUCT_PACKED_START {
Xtypedef struct  {
N   UINT16   u16SubIndex0; /**< \brief SubIndex0*/
X   unsigned short   u16SubIndex0;  
N   UINT32   u32LocalErrorReaction; /**< \brief Local error reaction*/
X   unsigned int   u32LocalErrorReaction;  
N   UINT16   u16SyncErrorCounterLimit; /**< \brief Sync error counter limit*/
X   unsigned short   u16SyncErrorCounterLimit;  
N} OBJ_STRUCT_PACKED_END
X} 
NTOBJ10F1;
N
N#endif //_OBJDEF_H_
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global variables
N------
N-----------------------------------------------------------------------------------------*/
N#if defined(_OBJDEF_) && (_OBJDEF_ == 1)
X#if 0L && (_OBJDEF_ == 1)
S    #define PROTO
N#else
N    #define PROTO extern
N#endif
N
N/**
N * Indicates if the synchronisation was written by the user on startup (by writing 0x1C3x.1).
N * If it was not written the sync mode will be set based on the DC registers 0x980:0x981
N */
NPROTO BOOL bSyncSetByUser;
Xextern unsigned char bSyncSetByUser;
N
N/**
N  * \brief Cycle diagnosis variable
N  */
NPROTO TCYCLEDIAG sCycleDiag;
Xextern TCYCLEDIAG sCycleDiag;
N
N
N/**
N  * \brief Object 0x1C32 (SyncManager 2 Parameter) object variable
N  */
NPROTO TSYNCMANPAR MBXMEM sSyncManOutPar;
Xextern TSYNCMANPAR  sSyncManOutPar;
N
N
N/**
N  * \brief Object 0x1C33 (SyncManager 3 Parameter) object variable
N  */
NPROTO TSYNCMANPAR MBXMEM sSyncManInPar;
Xextern TSYNCMANPAR  sSyncManInPar;
N
N
N/**
N * \brief Object 0x10F1 (Error Settings) object variable
N *
N * SubIndex0 : 2
N * Local error reaction : 1
N * Sync error counter limit : MAX_SM_EVENT_MISSED
N */
NPROTO TOBJ10F1 sErrorSettings
Xextern TOBJ10F1 sErrorSettings
N#if defined(_OBJDEF_) && (_OBJDEF_ == 1)
X#if 0L && (_OBJDEF_ == 1)
S= {2, 0x01, MAX_SM_EVENT_MISSED}
N#endif
N;
N
N
N/**
N * \brief Default entry name "SubIndex 000"
N */
NPROTO    CHAR OBJMEM         aSubindexDesc[13]
Xextern    char          aSubindexDesc[13]
N#if defined(_OBJDEF_) && (_OBJDEF_ == 1)
X#if 0L && (_OBJDEF_ == 1)
S = { "SubIndex 000" }
N#endif
N;
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global functions
N------
N-----------------------------------------------------------------------------------------*/
N
NPROTO    OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index );
Xextern    const TOBJECT  *  OBJ_GetObjectHandle( unsigned short index );
NPROTO    UINT32  OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 bCompleteAccess);
Xextern    unsigned int  OBJ_GetObjectLength( unsigned short index, unsigned char subindex, const TOBJECT  * pObjEntry, unsigned char bCompleteAccess);
NPROTO    UINT16  OBJ_GetNoOfObjects(UINT8 listType);
Xextern    unsigned short  OBJ_GetNoOfObjects(unsigned char listType);
NPROTO    UINT16  OBJ_GetObjectList(UINT16 listType, UINT16 *pIndex, UINT16 size, UINT16 MBXMEM *pData,UINT8 *pAbort);
Xextern    unsigned short  OBJ_GetObjectList(unsigned short listType, unsigned short *pIndex, unsigned short size, unsigned short  *pData,unsigned char *pAbort);
NPROTO    UINT16  OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData );
Xextern    unsigned short  OBJ_GetDesc( unsigned short index, unsigned char subindex, const TOBJECT  * pObjEntry, unsigned short  * pData );
NPROTO    OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Subindex);
Xextern    const TSDOINFOENTRYDESC  * OBJ_GetEntryDesc(const TOBJECT  * pObjEntry, unsigned char Subindex);
NPROTO    OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry);
Xextern    const TSDOINFOOBJDESC  * OBJ_GetObjDesc(const TOBJECT  * pObjEntry);
NPROTO    UINT16  OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry);
Xextern    unsigned short  OBJ_GetEntryOffset(unsigned char subindex, const TOBJECT  * pObjEntry);
NPROTO    UINT8   CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType);
Xextern    unsigned char   CheckSyncTypeValue(unsigned short index, unsigned short NewSyncType);
NPROTO    UINT8   OBJ_Read(UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess);
Xextern    unsigned char   OBJ_Read(unsigned short index, unsigned char subindex, unsigned int objSize, const TOBJECT  * pObjEntry, unsigned short  * pData, unsigned char bCompleteAccess);
NPROTO    UINT8   OBJ_Write(UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess);
Xextern    unsigned char   OBJ_Write(unsigned short index, unsigned char subindex, unsigned int dataSize, const TOBJECT  * pObjEntry, unsigned short  * pData, unsigned char bCompleteAccess);
NPROTO    void    COE_WriteBackupEntry(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry);
Xextern    void    COE_WriteBackupEntry(unsigned char subindex, const TOBJECT  * pObjEntry);
N
N#undef PROTO
N/** @}*/
L 46 ".\etherCAT\applInterface.h" 2
N#include "ecatappl.h"
L 1 ".\etherCAT\ecatappl.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N \addtogroup EcatAppl EtherCAT application
N * @{
N */
N
N/**
N\file ecatappl.h
N\author EthercatSSC@beckhoff.com
N
N\version 5.12
N
N<br>Changes to version V5.11:<br>
NV5.12 EEPROM1: get read size from register 0x502.6<br>
N<br>Changes to version V5.10:<br>
NV5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
N<br>Changes to version V5.01:<br>
NV5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
N              Compare DC UINT configuration (by ESC Config data) vs. DC activation register settings<br>
N              Update 0x1C3x entries<br>
NV5.10 ECAT4: Update alignment macro for 8 to 15 bit alignments (16 and 32 Bit controllers)<br>
N             Bugfix calculate LED blink frequency<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N/*-----------------------------------------------------------------------------------------
N------
N------    Description
N------
N------    ecatappl.h
N------
N------    EtherCAT Slave Application
N------                                                                                                                                                                 ------
N-----------------------------------------------------------------------------------------*/
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N
N#include "ecat_def.h"
N
N
N#ifndef _ECATAPPL_H_
S#define _ECATAPPL_H_
S
S/*-----------------------------------------------------------------------------------------
S------
S------    Defines and Types
S------
S-----------------------------------------------------------------------------------------*/
S
S/*Set to unsigned short to handle bit entries correct*/
S#define     BOOLEAN(x)                 UINT16 x:1 /**< \brief Macro to define BOOLEAN object entry*/
S#define     BIT1(x)                    UINT16 x:1 /**< \brief Macro to define BIT1 object entry*/
S#define     BIT2(x)                    UINT16 x:2 /**< \brief Macro to define BIT2 object entry*/
S#define     BIT3(x)                    UINT16 x:3 /**< \brief Macro to define BIT3 object entry*/
S#define     BIT4(x)                    UINT16 x:4 /**< \brief Macro to define BIT4 object entry*/
S#define     BIT5(x)                    UINT16 x:5 /**< \brief Macro to define BIT5 object entry*/
S#define     BIT6(x)                    UINT16 x:6 /**< \brief Macro to define BIT5 object entry*/
S#define     BIT7(x)                    UINT16 x:7 /**< \brief Macro to define BIT6 object entry*/
S#define     BIT8(x)                    UINT16 x:8 /**< \brief Macro to define BIT7 object entry*/
S#define     ALIGN0(x)
S#define     ALIGN1(x)                  UINT16 x:1; /**< \brief Macro to define ALIGN1 object entry*/
S#define     ALIGN2(x)                  UINT16 x:2; /**< \brief Macro to define ALIGN2 object entry*/
S#define     ALIGN3(x)                  UINT16 x:3; /**< \brief Macro to define ALIGN3 object entry*/
S#define     ALIGN4(x)                  UINT16 x:4; /**< \brief Macro to define ALIGN4 object entry*/
S#define     ALIGN5(x)                  UINT16 x:5; /**< \brief Macro to define ALIGN5 object entry*/
S#define     ALIGN6(x)                  UINT16 x:6; /**< \brief Macro to define ALIGN6 object entry*/
S#define     ALIGN7(x)                  UINT16 x:7; /**< \brief Macro to define ALIGN7 object entry*/
S#define     ALIGN8(x)                  UINT16 x:8; /**< \brief Macro to define ALIGN8 object entry*/
S#define     ALIGN9(x)                  UINT16 x:9; /**< \brief Macro to define ALIGN9 object entry*/
S#define     ALIGN10(x)                 UINT16 x:10; /**< \brief Macro to define ALIGN10 object entry*/
S#define     ALIGN11(x)                 UINT16 x:11; /**< \brief Macro to define ALIGN11 object entry*/
S#define     ALIGN12(x)                 UINT16 x:12; /**< \brief Macro to define ALIGN12 object entry*/
S#define     ALIGN13(x)                 UINT16 x:13; /**< \brief Macro to define ALIGN13 object entry*/
S#define     ALIGN14(x)                 UINT16 x:14; /**< \brief Macro to define ALIGN14 object entry*/
S#define     ALIGN15(x)                 UINT16 x:15; /**< \brief Macro to define ALIGN15 object entry*/
S/*ET9300 Project Handler :(#if CONTROLLER_16BIT || CONTROLLER_32BIT #else) lines 85 to 121 deleted*/
N#endif //_ECATAPPL_H_
N
N#if defined(_ECATAPPL_) && (_ECATAPPL_ == 1)
X#if 0L && (_ECATAPPL_ == 1)
S    #define PROTO
N#else
N    #define PROTO extern
N#endif
N
N#define ESC_RD 0
N#define ESC_WR 1
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Variables
N------
N-----------------------------------------------------------------------------------------*/
N
N
N/*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 138 to 140 deleted*/
N
NPROTO BOOL bEcatWaitForInputUpdate; /**< \brief Wait for input update*/
Xextern unsigned char bEcatWaitForInputUpdate;  
NPROTO BOOL bEtherCATRunLed; /**< \brief Current run LED value*/
Xextern unsigned char bEtherCATRunLed;  
NPROTO BOOL bEtherCATErrorLed; /**< \brief Current error LED value*/
Xextern unsigned char bEtherCATErrorLed;  
NPROTO BOOL bRunApplication; /**< \brief Indicates if the stack shall be running (if false the Hardware will be released)*/
Xextern unsigned char bRunApplication;  
N
N
N
N/*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 149 to 151 deleted*/
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Functions
N------
N-----------------------------------------------------------------------------------------*/
N
N
N
N
NPROTO    void       ECAT_CheckTimer(void);
Xextern    void       ECAT_CheckTimer(void);
NPROTO    void       PDI_Isr(void);
Xextern    void       PDI_Isr(void);
NPROTO    void       Sync0_Isr(void);
Xextern    void       Sync0_Isr(void);
NPROTO    void       Sync1_Isr(void);
Xextern    void       Sync1_Isr(void);
NPROTO    void       ECAT_Application(void);
Xextern    void       ECAT_Application(void);
NPROTO    void       PDO_ResetOutputs(void);
Xextern    void       PDO_ResetOutputs(void);
NPROTO    void       PDO_ReadInputs(void);
Xextern    void       PDO_ReadInputs(void);
NPROTO    void       PDO_InputMapping(void);
Xextern    void       PDO_InputMapping(void);
N
N/*ET9300 Project Handler :(#if UC_SET_ECAT_LED) lines 172 to 174 deleted*/
NPROTO    void       CalcSMCycleTime(void);
Xextern    void       CalcSMCycleTime(void);
NPROTO    UINT16     ESC_EepromAccess(UINT32 wordaddress, UINT16 wordsize, UINT16 MBXMEM *pData, UINT8 access);
Xextern    unsigned short     ESC_EepromAccess(unsigned int wordaddress, unsigned short wordsize, unsigned short  *pData, unsigned char access);
NPROTO    UINT16     ESC_EepromWriteCRC(void);
Xextern    unsigned short     ESC_EepromWriteCRC(void);
N
N/*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 183 to 185 deleted*/
N
N
N
N#undef PROTO
N/** @}*/
L 47 ".\etherCAT\applInterface.h" 2
N
N/*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 49 to 51 deleted*/
N
N
N/*ET9300 Project Handler :(#if EOE_SUPPORTED) lines 54 to 56 deleted*/
N
N#include "foeappl.h"
L 1 ".\etherCAT\foeappl.h" 1
N/*
N* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
N* The corresponding license agreement applies. This hint shall not be removed.
N* https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
N*/
N
N/**
N * \addtogroup FoE FileTransfer over EtherCAT
N * @{
N */
N
N/**
N\file foeappl.h
N\author EthercatSSC@beckhoff.com
N
N\version 5.12
N
N<br>Changes to version V5.01:<br>
NV5.12 FOE1: update new interface,move the FoE sample to sampleappl,add FoE application callback functions<br>
N<br>Changes to version - :<br>
NV5.01 : Start file change log
N */
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Includes
N------
N-----------------------------------------------------------------------------------------*/
N#include "ecat_def.h"
N
N#ifndef _FOEAPPL_H_
N#define _FOEAPPL_H_
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Defines and Types
N------
N-----------------------------------------------------------------------------------------*/
N/*---------------------------------------------
N-    Error Codes
N-----------------------------------------------*/
N#define    ECAT_FOE_ERRCODE_NOTDEFINED          0x8000 /**< \brief Not defined*/
N#define    ECAT_FOE_ERRCODE_NOTFOUND            0x8001 /**< \brief The file requested by an FoE upload service could not be found on the server*/
N#define    ECAT_FOE_ERRCODE_ACCESS              0x8002 /**< \brief Read or write access to this file not allowed (e.g. due to local control).*/
N#define    ECAT_FOE_ERRCODE_DISKFULL            0x8003 /**< \brief Disk to store file is full or memory allocation exceeded*/
N#define    ECAT_FOE_ERRCODE_ILLEGAL             0x8004 /**< \brief Illegal FoE operation, e.g. service identifier invalid*/
N#define    ECAT_FOE_ERRCODE_PACKENO             0x8005 /**< \brief FoE packet number invalid*/
N#define    ECAT_FOE_ERRCODE_EXISTS              0x8006 /**< \brief The file which is requested to be downloaded does already exist*/
N#define    ECAT_FOE_ERRCODE_NOUSER              0x8007 /**< \brief No User*/
N#define    ECAT_FOE_ERRCODE_BOOTSTRAPONLY       0x8008 /**< \brief FoE only supported in Bootstrap*/
N#define    ECAT_FOE_ERRCODE_NOTINBOOTSTRAP      0x8009 /**< \brief This file may not be accessed in BOOTSTRAP state*/
N#define    ECAT_FOE_ERRCODE_NORIGHTS            0x800A /**< \brief Password invalid*/
N#define    ECAT_FOE_ERRCODE_PROGERROR           0x800B /**< \brief Generic programming error. Should only be returned if  error reason cannot be distinguished*/
N#define    ECAT_FOE_ERRCODE_INVALID_CHECKSUM    0x800C /**< \brief checksum included in the file is invalid*/
N#define    ECAT_FOE_ERRCODE_INVALID_FIRMWARE    0x800D /**< \brief The hardware does not support the downloaded firmware*/
N#define    ECAT_FOE_ERRCODE_NO_FILE             0x800F /**< \brief Do not use (identical with 0x8001)*/
N#define    ECAT_FOE_ERRCODE_NO_FILE_HEADER      0x8010 /**< \brief Missing file header of error in file header*/
N#define    ECAT_FOE_ERRCODE_FLASH_ERROR         0x8011 /**< \brief Flash cannot be accessed*/
N
N#endif //_FOEAPPL_H_
N
N#ifdef _FOEAPPL_
S    #define PROTO
N#else
N    #define PROTO extern
N#endif
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Variables
N------
N-----------------------------------------------------------------------------------------*/
N
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Global Functions
N------
N-----------------------------------------------------------------------------------------*/
NPROTO    UINT16     FOE_Read(UINT16 MBXMEM * pName, UINT16 nameSize, UINT16 MBXMEM * pData, UINT32 password);
Xextern    unsigned short     FOE_Read(unsigned short  * pName, unsigned short nameSize, unsigned short  * pData, unsigned int password);
NPROTO    UINT16     FOE_Write(UINT16 MBXMEM * pName, UINT16 nameSize, UINT32 password);
Xextern    unsigned short     FOE_Write(unsigned short  * pName, unsigned short nameSize, unsigned int password);
NPROTO    UINT16     FOE_Data(UINT16 MBXMEM * pData, UINT16 Size);
Xextern    unsigned short     FOE_Data(unsigned short  * pData, unsigned short Size);
NPROTO    UINT16     FOE_Ack(UINT32 fileOffset, UINT16 MBXMEM * pData);
Xextern    unsigned short     FOE_Ack(unsigned int fileOffset, unsigned short  * pData);
NPROTO    UINT16     FOE_Busy(UINT16 done, UINT32 fileOffset, UINT16 MBXMEM * pData);
Xextern    unsigned short     FOE_Busy(unsigned short done, unsigned int fileOffset, unsigned short  * pData);
NPROTO    void       FOE_Error(UINT32 errorCode);
Xextern    void       FOE_Error(unsigned int errorCode);
N
N#undef PROTO
N/** @}*/
L 54 ".\etherCAT\applInterface.h" 2
N
N#endif /*#ifndef _APPL_INTERFACE_H_*/
N
N#if defined(_APPL_INTERFACE_) && (_APPL_INTERFACE_ == 1)
X#if 0L && (_APPL_INTERFACE_ == 1)
S   #define PROTO
N#else
N    #define PROTO extern
N#endif
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Function pointer which are used to call optional functions from the application
N------
N-----------------------------------------------------------------------------------------*/
N
N/*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 76 to 122 deleted*/
N
N
N/*ET9300 Project Handler :(#if EOE_SUPPORTED) lines 125 to 152 deleted*/
N
N
N
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\param     pName         Pointer to the name of the file (the pointer is null if the function is called due to a previous busy state)
N\param     nameSize      Length of the file name (the value is 0 if the function is called due to a previous busy state)
N\param     password      Password for the file read (the value is 0 if the function is called due to a previous busy state)
N\param     maxBlockSize  Maximum size of a data block (copied to pData)
N\param     pData         Destination pointer for the first FoE fragment
N                        
N
N
N\return                  block size:
N                            < FOE_MAXBUSY-101    (0x7F95)
N                         busy:
N                            FOE_MAXBUSY-100 (0%)    (0x7FFA - 0x64)
N                            ...
N                            FOE_MAXBUSY (100%) (0x7FFA)
N                         error:
N                            ECAT_FOE_ERRCODE_NOTDEFINED (0x8000)
N                            ECAT_FOE_ERRCODE_NOTFOUND (0x8001)
N                            ECAT_FOE_ERRCODE_ACCESS    (0x8002)
N                            ECAT_FOE_ERRCODE_DISKFULL (0x8003)
N                            ECAT_FOE_ERRCODE_ILLEGAL (0x8004)
N                            ECAT_FOE_ERRCODE_EXISTS    (0x8006)
N                            ECAT_FOE_ERRCODE_NOUSER    (0x8007)
N
N\brief    The function is called when a file read request was received. The Foe fragments shall always have the length of "maxBlockSize" till the last file fragment.
N\brief    In case that the file size is a multiple of "maxBlockSize" 0 shall be returned after the last fragment.
N\brief	   The function pointer is reset in MainInit() so it shall be set afterwards
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO UINT16 (*pAPPL_FoeRead)(UINT16 MBXMEM * pName, UINT16 nameSize, UINT32 password, UINT16 maxBlockSize, UINT16 *pData);
Xextern unsigned short (*pAPPL_FoeRead)(unsigned short  * pName, unsigned short nameSize, unsigned int password, unsigned short maxBlockSize, unsigned short *pData);
N
N
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\param     offset        File offset which shall be transmitted next
N\param     maxBlockSize  Maximum size of a data block (copied to pData)
N\param     pData         Destination pointer for the next foe fragment
N
N
N
N\return                  block size:
N                            < FOE_MAXBUSY-101    (0x7F95)
N                        busy:
N                            FOE_MAXBUSY-100 (0%)    (0x7FFA - 0x64)
N                            ...
N                            FOE_MAXBUSY (100%) (0x7FFA)
N                        error:
N                            ECAT_FOE_ERRCODE_NOTDEFINED (0x8000)
N                            ECAT_FOE_ERRCODE_NOTFOUND (0x8001)
N                            ECAT_FOE_ERRCODE_ACCESS    (0x8002)
N                            ECAT_FOE_ERRCODE_DISKFULL (0x8003)
N                            ECAT_FOE_ERRCODE_ILLEGAL (0x8004)
N                            ECAT_FOE_ERRCODE_EXISTS    (0x8006)
N                            ECAT_FOE_ERRCODE_NOUSER    (0x8007)
N
N\brief    The function is called to transmit FoE read data 2 .. n (the slave received an acknowledge on a previous accepted file read request). The Foe fragments shall always have the length of "maxBlockSize" till the last file fragment.
N\brief    In case that the file size is a multiple of "maxBlockSize" 0 shall be returned after the last fragment.
N\brief	   The function pointer is reset in MainInit() so it shall be set afterwards
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO UINT16(*pAPPL_FoeReadData)(UINT32 offset, UINT16 maxBlockSize, UINT16 *pData);
Xextern unsigned short(*pAPPL_FoeReadData)(unsigned int offset, unsigned short maxBlockSize, unsigned short *pData);
N
N
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\param     errorCode     Error code send by the EtherCAT master
N
N
N\brief    The function is called when the master has send an FoE Abort.
N\brief	   The function pointer is reset in MainInit() so it shall be set afterwards
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO void(*pAPPL_FoeError)(UINT32 errorCode);
Xextern void(*pAPPL_FoeError)(unsigned int errorCode);
N
N
N
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\param     pName         Pointer to the name of the file
N\param     nameSize      Length of the file name
N\param     password      Password for the file read
N
N\return                 okay, or an error code
N                        0 (okay)
N                        ECAT_FOE_ERRCODE_NOTDEFINED (0x8000)
N                        ECAT_FOE_ERRCODE_NOTFOUND (0x8001)
N                        ECAT_FOE_ERRCODE_ACCESS    (0x8002)
N                        ECAT_FOE_ERRCODE_DISKFULL (0x8003)
N                        ECAT_FOE_ERRCODE_ILLEGAL (0x8004)
N                        ECAT_FOE_ERRCODE_EXISTS    (0x8006)
N                        ECAT_FOE_ERRCODE_NOUSER    (0x8007)
N
N\brief    This function is called on a received FoE write request.
N\brief    (no busy response shall be returned by this function. If the slave requires some time to handle the incoming data the function pAPPL_FoeData() shall return a busy)
N\brief	   The function pointer is reset in MainInit() so it shall be set afterwards
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO UINT16 (*pAPPL_FoeWrite)(UINT16 MBXMEM * pName, UINT16 nameSize, UINT32 password);
Xextern unsigned short (*pAPPL_FoeWrite)(unsigned short  * pName, unsigned short nameSize, unsigned int password);
N
N
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\param     pData            Received file data
N\param 	   Size             Length of received file data
N\param 	   bDataFollowing   TRUE if more FoE Data requests are following
N
N\return                     okay, busy or an error code
N                            0 (okay)
N                            FOE_MAXBUSY-100 (0%)    (0x7FFa - 100)
N                            FOE_MAXBUSY (100%) (0x7FFA)
N                            ECAT_FOE_ERRCODE_NOTDEFINED (0x8000)
N                            ECAT_FOE_ERRCODE_ACCESS    (0x8002)
N                            ECAT_FOE_ERRCODE_DISKFULL (0x8003)
N                            ECAT_FOE_ERRCODE_ILLEGAL (0x8004)
N                            ECAT_FOE_ERRCODE_NOUSER    (0x8007)
N
N\brief    This function is called on a FoE Data request
N\brief	   The function pointer is reset in MainInit() so it shall be set afterwards
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO UINT16(*pAPPL_FoeWriteData)(UINT16 MBXMEM * pData, UINT16 Size, BOOL bDataFollowing);
Xextern unsigned short(*pAPPL_FoeWriteData)(unsigned short  * pData, unsigned short Size, unsigned char bDataFollowing);
N
N/* ECATCHANGE_START(V5.13) COE4*/
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\param     Index            Index of the object to be read
N\param     Subindex         Subindex of the object entry to be read
N\param     CompleteAccess   Indicates if the object is read with complete access
N
N\brief    The function is called before an object/entry is read
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO void(*pAPPL_CoeReadInd)(UINT16 Index, UINT8 Subindex, BOOL CompleteAccess);
Xextern void(*pAPPL_CoeReadInd)(unsigned short Index, unsigned char Subindex, unsigned char CompleteAccess);
N
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\param     Index            Index of the object which was written
N\param     Subindex         Subindex of the object entry which was written
N\param     CompleteAccess   Indicates if the object was written with complete access
N
N\brief    The function is called after an object/entry was successfully written
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO void(*pAPPL_CoeWriteInd)(UINT16 Index, UINT8 Subindex, BOOL CompleteAccess);
Xextern void(*pAPPL_CoeWriteInd)(unsigned short Index, unsigned char Subindex, unsigned char CompleteAccess);
N
N/* ECATCHANGE_END(V5.13) COE4*/
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\brief    This function is called by the SSC from the main loop
N\brief	   The function pointer is reset in MainInit() so it shall be set afterwards
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO void(*pAPPL_MainLoop)();
Xextern void(*pAPPL_MainLoop)();
N
N/*-----------------------------------------------------------------------------------------
N------
N------    Functions provided by the SSC to be called from the application
N------
N-----------------------------------------------------------------------------------------*/
N
N
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\return   0 if successful or greater 0 in case of an error
N
N\brief    Initialize the generic slave stack.
N\brief    This function should be called after the platform including operating system and
N\brief    ESC is ready to use.
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO UINT16 MainInit(void);
Xextern unsigned short MainInit(void);
N
N
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\brief    This function handles the low priority function like EtherCAT state machine
N\brief    handling, mailbox protocols and if no synchronization is enabled also the
N\brief    application.
N\brief    This function shall be called cyclically from the application.
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO void MainLoop(void);
Xextern void MainLoop(void);
N
N
N/////////////////////////////////////////////////////////////////////////////////////////
N/**
N\param    alStatus       requested AL Status 
N\param    alStatusCode   requested AL Status Code
N
N\brief    This function shall be called by the application to trigger state transition in case
N\brief    of an application error or to complete a pending transition.
N\brief    If the function was called due to an error it shall be again if the error is gone.
N\brief    NOTE: state requests to a higher state than the current state are not allowed.
N*////////////////////////////////////////////////////////////////////////////////////////
NPROTO void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode);
Xextern void ECAT_StateChange(unsigned char alStatus, unsigned short alStatusCode);
N
N
N/*ET9300 Project Handler :(#if EOE_SUPPORTED) lines 348 to 361 deleted*/
N
N#undef PROTO
L 38 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\main.h" 2
N#include "ADS1115Driver.h"
L 1 ".\Power\ADS1115Driver.h" 1
N/**
N  ******************************************************************************
N  * @file    ADS1115Driver.h
N  * @author  Xi Liang
N  * @brief   ADS1115 I2C module driver.
N  *         
N  @verbatim
N  ******************************************************************************
N  */
N#ifndef __ADS1115DRIVER_H
N#define __ADS1115DRIVER_H
N
N
N#include "stm32f4xx_hal.h"
N#include "data_def.h"
N#include "TemperatureDriver.h"
L 1 ".\Power\TemperatureDriver.h" 1
N#ifndef __TEMPERATUREDRIVER_H
N#define __TEMPERATUREDRIVER_H
N
N
N
N#include "stm32f4xx_hal.h"
N#include "data_def.h"
N
N
Nuint8_t look_up_table(uint16_t *a,uint8_t ArrayLong,uint16_t data);
Nfloat num_to_temperature(uint8_t num);
Nvoid save_ntc_data(uint16_t data);			//直插
Nvoid save_ntc2_data(uint16_t data);		//smd
N
N
N
N#endif
L 17 ".\Power\ADS1115Driver.h" 2
N
N
N#define ADS1115_Voltage_48V
N
N#define ADS1115_I2C_TIMEOUT_IN_MS 500u
N
N//Warning! 7 bits ADDR should must be shifted to the left
N//ADDR PIN ->GND
N/*1001000y*/
N#define ADS1115_ADDR_0  (72u << 1)
N
N//ADDR PIN ->VDD
N/*1001001y*/
N#define ADS1115_ADDR_1  (73u << 1)
N
N//ADDR PIN ->SDA
N/*1001010Y*/
N#define ADS1115_ADDR_2  (74u << 1)
N
N//ADDR PIN ->SCL
N/*1001011Y*/
N#define ADS1115_ADDR_3  (75u << 1)
N
N#define ADS1115_CONVERSION_REG      0x00	//Convertion register
N#define ADS1115_CONFIG_REG          0x01	//Config register
N#define ADS1115_Lo_THRESH_REG       0x02	//Lo_thresh register
N#define ADS1115_Ho_THRESH_REG       0x03	//Hi_thresh register
N
N#define ADS1115_CONFIG_REG_OS_NO_EFFECT 0u
N#define ADS1115_CONFIG_REG_OS_START_SINGLE_CONVERSION ((uint16_t)1u << 15u)
N
N#define ADS1115_CONFIG_REG_MUX_AIN0_AIN1 0u
N#define ADS1115_CONFIG_REG_MUX_AIN0_AIN3 ((uint16_t)1u << 12u)
N#define ADS1115_CONFIG_REG_MUX_AIN1_AIN3 ((uint16_t)2u << 12u)
N#define ADS1115_CONFIG_REG_MUX_AIN2_AIN3 ((uint16_t)3u << 12u)
N#define ADS1115_CONFIG_REG_MUX_AIN0_GND ((uint16_t)4u << 12u)
N#define ADS1115_CONFIG_REG_MUX_AIN1_GND ((uint16_t)5u << 12u)
N#define ADS1115_CONFIG_REG_MUX_AIN2_GND ((uint16_t)6u << 12u)
N#define ADS1115_CONFIG_REG_MUX_AIN3_GND ((uint16_t)7u << 12u)
N
N#define ADS1115_CONFIG_REG_FSR_6p114	(0u)
N#define ADS1115_CONFIG_REG_FSR_4p096	((uint16_t)1u << 9u)
N#define ADS1115_CONFIG_REG_FSR_2p048	((uint16_t)2u << 9u)
N#define ADS1115_CONFIG_REG_FSR_1p024	((uint16_t)3u << 9u)
N#define ADS1115_CONFIG_REG_FSR_0p512	((uint16_t)4u << 9u)
N#define ADS1115_CONFIG_REG_FSR_0p256_1	((uint16_t)5u << 9u)
N#define ADS1115_CONFIG_REG_FSR_0p256_2	((uint16_t)6u << 9u)
N#define ADS1115_CONFIG_REG_FSR_0p256_3	((uint16_t)7u << 9u)
N
N#define ADS1115_CONFIG_REG_MODE_CONTINUOUS	(0u)
N#define ADS1115_CONFIG_REG_MODE_SINGLE_SHOT	((uint16_t)(1u) << 8u)
N
N#define ADS1115_CONFIG_REG_DR_SPS_8	(0u)
N#define ADS1115_CONFIG_REG_DR_SPS_16	((uint16_t)1u << 5u)
N#define ADS1115_CONFIG_REG_DR_SPS_32	((uint16_t)2u << 5u)
N#define ADS1115_CONFIG_REG_DR_SPS_64	((uint16_t)3u << 5u)
N#define ADS1115_CONFIG_REG_DR_SPS_128	((uint16_t)4u << 5u)
N#define ADS1115_CONFIG_REG_DR_SPS_250	((uint16_t)5u << 5u)
N#define ADS1115_CONFIG_REG_DR_SPS_475	((uint16_t)6u << 5u)
N#define ADS1115_CONFIG_REG_DR_SPS_860	((uint16_t)7u << 5u)
N
N#define ADS1115_CONFIG_REG_COMP_MODE_TRANDITIONAL 0u
N#define ADS1115_CONFIG_REG_COMP_MODE_WINDOW ((uint16_t)(1) << 4u)
N
N#define ADS1115_CONFIG_REG_COMP_POL_ACT_LOW (0u)
N#define ADS1115_CONFIG_REG_COMP_POL_ACT_HIGH ((uint16_t)(1) << 3u)
N
N#define ADS1115_CONFIG_REG_COMP_QUE_ONE 0u
N#define ADS1115_CONFIG_REG_COMP_QUE_TWO (1u)
N#define ADS1115_CONFIG_REG_COMP_QUE_FOUR (2u)
N#define ADS1115_CONFIG_REG_COMP_QUE_DISABLE (3u)
N
N
N#define ADC_Accuracy 		32768   //定义ADC精度，ADS1115单端输入时15位
N
Nextern I2C_HandleTypeDef * I2C_Ptr_48V_NTC;
Nextern I2C_HandleTypeDef * I2C_Ptr_24V;
Nextern I2C_HandleTypeDef * I2C_Ptr_AI;
N
Ntypedef union
N{
N	struct 
N	{
N		uint16_t COMP_QUE 		:2;
N		uint16_t COMP_LAT 		:1;
N		uint16_t COMP_POL 		:1;
N		uint16_t COMP_MODE  	:1;
N		uint16_t DR         	:3;
N		uint16_t MODE     		:1;
N		uint16_t PGA        	:3;
N		uint16_t MUX        	:3;
N		uint16_t OS         	:1;
N	}BIT;
N	uint16_t ALL;
N}ADS1115_CFG;
N
Ntypedef struct tag_ADS1115_DRIVER
N{
N	I2C_HandleTypeDef * I2C_Handle;
N	uint8_t ADDR;
N	ADS1115_CFG ConfigRegData;
N	int16_t SampleValue;
N	uint32_t *StartConversionTimerPtr;
N	uint32_t ConversionTime;
N	uint32_t ConfigErrorCnt;
N	uint32_t ConversionErrorCnt;
N	int16_t SampleValueMax;
N	int16_t SampleValueMin;
N	uint8_t SampleBuffer[2u];
N	HAL_StatusTypeDef ConfigResult;
N	HAL_StatusTypeDef ConversionTransmitResult;
N	HAL_StatusTypeDef ConversionReceiveResult;	
N}ADS1115_DRIVER;
N
Nextern ADS1115_DRIVER ADS1115_NTC;
Nextern ADS1115_DRIVER ADS1115_Voltage48V;
Nextern ADS1115_DRIVER ADS1115_Current48V;
Nextern ADS1115_DRIVER ADS1115_Voltage24V;
Nextern ADS1115_DRIVER ADS1115_Current24V;
Nextern ADS1115_DRIVER ADS1115_AnalogVoltageInput0;
Nextern ADS1115_DRIVER ADS1115_AnalogVoltageInput1;
Nextern ADS1115_DRIVER ADS1115_AnalogCurrentInput0;
Nextern ADS1115_DRIVER ADS1115_AnalogCurrentInput1;
Nvoid ADS1115_Driver_Initilization(void);
Nvoid ADS1115_Driver_MainLoop(void);
N
N#endif
L 39 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\main.h" 2
N#include "Command.h"
L 1 ".\Power\Command.h" 1
N/**
N  ******************************************************************************
N  * @file    Command.h
N  * @author  Xi Liang/Liu Gui Qing
N  * @brief   Power Command module driver.
N  *         
N  @verbatim
N  ******************************************************************************
N  */
N	
N#ifndef __COMMAND_H
N#define __COMMAND_H
N
N
N#include "stm32f4xx_hal.h"
N#include "data_def.h"
N#include "PowerMenu.h"
L 1 ".\Power\PowerMenu.h" 1
N/**
N  ******************************************************************************
N  * @file    PowerMenu.h
N  * @author  Xi Liang/Liu Gui Qing
N  * @brief   Power Menu Driver.
N  *         
N  @verbatim
N  ******************************************************************************
N  */
N	
N#ifndef __POWERMENU_H
S#define __POWERMENU_H
S
S
S#include "data_def.h"
S#include "main.h"
S#include "ADS1115Driver.h"
S#include "Command.h"
S
S
S
S
Svoid close_all_dr_save_state(void);
Svoid first_open_dr_save_state(void);
Svoid Reload_State_All_Value(void);
Svoid Reload_Config_All_Value(void);
Svoid work_mode_operation(void);
Sstatic void PowerOnCharge(void);
Svoid force_shutdown(uint8_t nxt_mode);
Svoid softwarepoweroff_mode_operation(void);
Svoid shutdown_mode_operation(void);
S
S
S
N#endif
L 18 ".\Power\Command.h" 2
N
N#define POWER_COMMAND_TXRX_BUFFER_SIZE 32u
N
N#define POWER_COMMAND_HEADER_SIZE (4u)
N#define POWER_COMMAND_END_SIZE (4u)
N#define POWER_COMMAND_CMD_SIZE (1u)
N#define POWER_COMMAND_LENGTH_SIZE (1u)
N#define POWER_COMMAND_INFO_MAX_SIZE (16u)
N#define POWER_COMMAND_CRC_SIZE (2u)
N//#define POWER_COMMAND_DMA_SIZE (POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_END_SIZE + \
N																	POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
N																	POWER_COMMAND_INFO_MAX_SIZE + POWER_COMMAND_CRC_SIZE)
X
N																	
N#define POWER_COMMAND_MAX_SIZE (POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_END_SIZE + \
N																	POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
N																	POWER_COMMAND_INFO_MAX_SIZE + POWER_COMMAND_CRC_SIZE)
X#define POWER_COMMAND_MAX_SIZE (POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_END_SIZE + 																	POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + 																	POWER_COMMAND_INFO_MAX_SIZE + POWER_COMMAND_CRC_SIZE)
N
N#define SOI 0xFFAAAAFFu
N#define EOI 0xEE5555EEu
N
N#define SM2SU_PERIODIC_TRANSMIT_IN_MS 500u
N#define SM2SU_PERIODIC_TRANSMIT_TIMEOUT_IN_MS 1000u
N#define POWER_COMMAND_TRANSMIT_TIMEOUT_IN_MS 500u
N
Ntypedef struct tag_POWER_COMMAND_PROTOCOL
N{
N		uint8_t HEADER[POWER_COMMAND_HEADER_SIZE];
X		uint8_t HEADER[(4u)];
N		uint8_t CMD;
N		uint8_t LENGTH;
N		uint8_t INFO[POWER_COMMAND_INFO_MAX_SIZE];	
X		uint8_t INFO[(16u)];	
N		uint16_t CRC16;
N		uint8_t END[POWER_COMMAND_END_SIZE];
X		uint8_t END[(4u)];
N}POWER_COMMAND_PROTOCOL;
N
Ntypedef union 
N{
N		uint8_t ByteAccess[POWER_COMMAND_MAX_SIZE];
X		uint8_t ByteAccess[((4u) + (4u) + (1u) + (1u) + (16u) + (2u))];
N		uint16_t WordAccess[POWER_COMMAND_MAX_SIZE >> 1];
X		uint16_t WordAccess[((4u) + (4u) + (1u) + (1u) + (16u) + (2u)) >> 1];
N		uint32_t	LongAccess[POWER_COMMAND_MAX_SIZE >> 2];
X		uint32_t	LongAccess[((4u) + (4u) + (1u) + (1u) + (16u) + (2u)) >> 2];
N		POWER_COMMAND_PROTOCOL  ContentDefAccess;
N}POWER_COMMAND;
N
Ntypedef struct tag_POWER_COMMAND_RECEIVED 
N{
N	uint8_t RequireCode;
N	POWER_COMMAND PowerCommand;
N	
N	
N}POWER_COMMAND_RECEIVED;
N
Ntypedef void (*SM2SU_REQ_CALL)(uint8_t ReqCd, uint8_t *pData, uint16_t *pSize, uint16_t InfoLength);
N
Ntypedef struct	tag_SM2SU_REQ_DPCH{
N	uint8_t	SM2SU_REQ_CD;
N	SM2SU_REQ_CALL	pFunc;
N	uint16_t InfoLength;
N} SM2SU_REQ_DPCH;
N
Ntypedef uint8_t (*SU2SM_REQ_CALL)(POWER_COMMAND_RECEIVED *pData);
N
Ntypedef struct	tag_SU2SM_REQ_DPCH{
N	uint8_t	SU2SM_REQ_CD;
N	SU2SM_REQ_CALL	pFunc;
N} SU2SM_REQ_DPCH;
N
N//	SM->SU
N//	require code used by Power_Command_Transmit()
N#define SM2SU_REQ_CD_PERIODIC_TRANSMISSION 1u
N#define SM2SU_REQ_CD_REPLY_CONTROL_COMMAND 2u
N#define SM2SU_REQ_CD_POWER_OFF_REQUIRE 3u
N#define SM2SU_REQ_CD_REPLY_POWER_OFF_COMMAND 4u
N#define SM2SU_REQ_CD_REPLY_REBOOT_COMMAND 5u
N#define SM2SU_REQ_CD_COMPULSORY_POWER_OFF_COMMAND 6u
N#define SM2SU_REQ_MAX 6u
N
N//	SU->SM
N//	require code used by Power_Command_Receive()
N#define SU2SM_REQ_CD_PERIODIC_TRANSMISSION_COMMAND 1u
N#define SU2SM_REQ_CD_CONTROL_COMMAND 2u
N#define SU2SM_REQ_CD_REPLY_POWER_OFF_REQUIRE 3u
N#define SU2SM_REQ_CD_POWER_OFF_COMMAND 4u
N#define SU2SM_REQ_CD_REBOOT_COMMAND 5u
N#define SU2SM_REQ_CD_REPLY_COMPULSORY_POWER_OFF_COMMAND 6u
N#define SU2SM_REQ_MAX 6u
N
N
Nextern POWER_COMMAND_RECEIVED PowerCommandReceived;
Nextern uint8_t PowerCommandRxBuffer[POWER_COMMAND_TXRX_BUFFER_SIZE];
Xextern uint8_t PowerCommandRxBuffer[32u];
Nextern uint8_t PowerCommandTxBuffer[POWER_COMMAND_TXRX_BUFFER_SIZE];
Xextern uint8_t PowerCommandTxBuffer[32u];
N
Nextern UART_HandleTypeDef * Uart_HandlePtr;
Nextern DMA_HandleTypeDef * Udma_UartRx_HandlePtr;
Nextern DMA_HandleTypeDef * Udma_Uarttx_HandlePtr;
N
NHAL_StatusTypeDef Power_Command_Transmit(uint8_t ReqCode);
Nvoid Power_Command_Initilization(void);
Nvoid Power_Command_Main_Loop(void);
Nvoid SU2SM_RxIdleEventCallback(UART_HandleTypeDef *huart, uint16_t Size);
N
N#endif
L 40 "C:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc\main.h" 2
N/* USER CODE END Includes */
N
N/* Exported types ------------------------------------------------------------*/
N/* USER CODE BEGIN ET */
N
N/* USER CODE END ET */
N
N/* Exported constants --------------------------------------------------------*/
N/* USER CODE BEGIN EC */
N
N/* USER CODE END EC */
N
N/* Exported macro ------------------------------------------------------------*/
N/* USER CODE BEGIN EM */
N
N/* USER CODE END EM */
N
N/* Exported functions prototypes ---------------------------------------------*/
Nvoid Error_Handler(void);
N
N/* USER CODE BEGIN EFP */
N
N/* USER CODE END EFP */
N
N/* Private defines -----------------------------------------------------------*/
N#define SYNC0_Pin GPIO_PIN_2
N#define SYNC0_GPIO_Port GPIOE
N#define SYNC0_EXTI_IRQn EXTI2_IRQn
N#define SYNC1_Pin GPIO_PIN_3
N#define SYNC1_GPIO_Port GPIOE
N#define SYNC1_EXTI_IRQn EXTI3_IRQn
N#define AI_IU_SW1_Pin GPIO_PIN_6
N#define AI_IU_SW1_GPIO_Port GPIOE
N#define V24V_OUT4_Pin GPIO_PIN_2
N#define V24V_OUT4_GPIO_Port GPIOF
N#define LED6_Pin GPIO_PIN_3
N#define LED6_GPIO_Port GPIOF
N#define PHY_RESET_Pin GPIO_PIN_4
N#define PHY_RESET_GPIO_Port GPIOF
N#define ET_RESETN_Pin GPIO_PIN_5
N#define ET_RESETN_GPIO_Port GPIOF
N#define LED3_Pin GPIO_PIN_8
N#define LED3_GPIO_Port GPIOF
N#define LED4_Pin GPIO_PIN_9
N#define LED4_GPIO_Port GPIOF
N#define LED5_Pin GPIO_PIN_10
N#define LED5_GPIO_Port GPIOF
N#define IRQ_Pin GPIO_PIN_1
N#define IRQ_GPIO_Port GPIOA
N#define IRQ_EXTI_IRQn EXTI1_IRQn
N#define RS485_RE_Pin GPIO_PIN_4
N#define RS485_RE_GPIO_Port GPIOA
N#define LED2_Pin GPIO_PIN_4
N#define LED2_GPIO_Port GPIOC
N#define LED1_Pin GPIO_PIN_5
N#define LED1_GPIO_Port GPIOC
N#define AI_IU_SW2_Pin GPIO_PIN_1
N#define AI_IU_SW2_GPIO_Port GPIOB
N#define SAFE_48V_SWITCH_Pin GPIO_PIN_11
N#define SAFE_48V_SWITCH_GPIO_Port GPIOF
N#define POWER24V_ON_Pin GPIO_PIN_12
N#define POWER24V_ON_GPIO_Port GPIOF
N#define ES_SHUTDOWN_Pin GPIO_PIN_13
N#define ES_SHUTDOWN_GPIO_Port GPIOF
N#define ACPower_OK_Pin GPIO_PIN_1
N#define ACPower_OK_GPIO_Port GPIOG
N#define ST_OUT_24_Pin GPIO_PIN_10
N#define ST_OUT_24_GPIO_Port GPIOE
N#define ST_OUT_23_Pin GPIO_PIN_11
N#define ST_OUT_23_GPIO_Port GPIOE
N#define ST_OUT_22_Pin GPIO_PIN_12
N#define ST_OUT_22_GPIO_Port GPIOE
N#define ST_OUT_20_Pin GPIO_PIN_13
N#define ST_OUT_20_GPIO_Port GPIOE
N#define ST_OUT_21_Pin GPIO_PIN_14
N#define ST_OUT_21_GPIO_Port GPIOE
N#define POWEROFF_REMOTEIN_Pin GPIO_PIN_15
N#define POWEROFF_REMOTEIN_GPIO_Port GPIOE
N#define ST_OUT_19_Pin GPIO_PIN_12
N#define ST_OUT_19_GPIO_Port GPIOB
N#define ST_OUT_18_Pin GPIO_PIN_13
N#define ST_OUT_18_GPIO_Port GPIOB
N#define ST_OUT_17_Pin GPIO_PIN_14
N#define ST_OUT_17_GPIO_Port GPIOB
N#define ST_OUT_8_Pin GPIO_PIN_15
N#define ST_OUT_8_GPIO_Port GPIOB
N#define ST_OUT_7_Pin GPIO_PIN_8
N#define ST_OUT_7_GPIO_Port GPIOD
N#define ST_OUT_6_Pin GPIO_PIN_9
N#define ST_OUT_6_GPIO_Port GPIOD
N#define ST_OUT_5_Pin GPIO_PIN_10
N#define ST_OUT_5_GPIO_Port GPIOD
N#define ST_IN_23_Pin GPIO_PIN_11
N#define ST_IN_23_GPIO_Port GPIOD
N#define ST_IN_22_Pin GPIO_PIN_12
N#define ST_IN_22_GPIO_Port GPIOD
N#define ST_IN_21_Pin GPIO_PIN_13
N#define ST_IN_21_GPIO_Port GPIOD
N#define ST_IN_24_Pin GPIO_PIN_14
N#define ST_IN_24_GPIO_Port GPIOD
N#define ST_IN_20_Pin GPIO_PIN_15
N#define ST_IN_20_GPIO_Port GPIOD
N#define ST_IN_19_Pin GPIO_PIN_2
N#define ST_IN_19_GPIO_Port GPIOG
N#define ST_IN_18_Pin GPIO_PIN_3
N#define ST_IN_18_GPIO_Port GPIOG
N#define LAN9252_CS_Pin GPIO_PIN_4
N#define LAN9252_CS_GPIO_Port GPIOG
N#define ST_IN_17_Pin GPIO_PIN_5
N#define ST_IN_17_GPIO_Port GPIOG
N#define ST_OUT_4_Pin GPIO_PIN_6
N#define ST_OUT_4_GPIO_Port GPIOG
N#define ST_OUT_3_Pin GPIO_PIN_7
N#define ST_OUT_3_GPIO_Port GPIOG
N#define ST_OUT_2_Pin GPIO_PIN_8
N#define ST_OUT_2_GPIO_Port GPIOG
N#define ST_OUT_1_Pin GPIO_PIN_8
N#define ST_OUT_1_GPIO_Port GPIOC
N#define ST_IN_8_Pin GPIO_PIN_6
N#define ST_IN_8_GPIO_Port GPIOD
N#define ST_IN_7_Pin GPIO_PIN_7
N#define ST_IN_7_GPIO_Port GPIOD
N#define ST_IN_6_Pin GPIO_PIN_9
N#define ST_IN_6_GPIO_Port GPIOG
N#define ST_IN_5_Pin GPIO_PIN_10
N#define ST_IN_5_GPIO_Port GPIOG
N#define ST_IN_1_Pin GPIO_PIN_11
N#define ST_IN_1_GPIO_Port GPIOG
N#define ST_IN_2_Pin GPIO_PIN_12
N#define ST_IN_2_GPIO_Port GPIOG
N#define ST_IN_3_Pin GPIO_PIN_13
N#define ST_IN_3_GPIO_Port GPIOG
N#define ST_IN_4_Pin GPIO_PIN_14
N#define ST_IN_4_GPIO_Port GPIOG
N#define POWERON_REMOTEIN_Pin GPIO_PIN_8
N#define POWERON_REMOTEIN_GPIO_Port GPIOB
N#define V24V_OUT1_Pin GPIO_PIN_9
N#define V24V_OUT1_GPIO_Port GPIOB
N#define POWERON_KEYIN_Pin GPIO_PIN_0
N#define POWERON_KEYIN_GPIO_Port GPIOE
N#define OC_PROTECT_Pin GPIO_PIN_1
N#define OC_PROTECT_GPIO_Port GPIOE
N/* USER CODE BEGIN Private defines */
N
N/* USER CODE END Private defines */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MAIN_H */
L 17 "Power\PowerMenu.h" 2
N#include "ADS1115Driver.h"
N#include "Command.h"
N
N
N
N
Nvoid close_all_dr_save_state(void);
Nvoid first_open_dr_save_state(void);
Nvoid Reload_State_All_Value(void);
Nvoid Reload_Config_All_Value(void);
Nvoid work_mode_operation(void);
Nstatic void PowerOnCharge(void);
Nvoid force_shutdown(uint8_t nxt_mode);
Nvoid softwarepoweroff_mode_operation(void);
Nvoid shutdown_mode_operation(void);
N
N
N
N#endif
L 12 "Power\PowerMenu.c" 2
N
N
Nextern POWER_MANAGE_PACKED power_manage;
Nextern UART_HandleTypeDef huart1;
N
Nuint8_t sampling_flag = 1;  //默认电阻接入电路，需要检测热量
N
N
N
Nvoid close_all_dr_save_state(void)
N{
N	power_manage.p_state_h.VAL = 0x00u;
N  power_manage.p_state_l.VAL = 0x00u;
N	
N		
N	HAL_GPIO_WritePin(GPIOB, V24V_OUT1_Pin, GPIO_PIN_RESET);
X	HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x0400UL)), ((uint16_t)0x0200), GPIO_PIN_RESET);
N  HAL_GPIO_WritePin(GPIOF, V24V_OUT4_Pin|POWER24V_ON_Pin, GPIO_PIN_RESET);
X  HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1400UL)), ((uint16_t)0x0004)|((uint16_t)0x1000), GPIO_PIN_RESET);
N	HAL_GPIO_WritePin(GPIOF, ES_SHUTDOWN_Pin, GPIO_PIN_SET);
X	HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1400UL)), ((uint16_t)0x2000), GPIO_PIN_SET);
N}
N
Nvoid force_shutdown(uint8_t nxt_mode) 
N{
N  close_all_dr_save_state();
N	
N	HAL_GPIO_WritePin(OC_PROTECT_GPIO_Port, OC_PROTECT_Pin, GPIO_PIN_RESET);
X	HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0002), GPIO_PIN_RESET);
N	power_manage.p_state_h.STATE_DEFINE_H.DC48_OC = 0;
N	power_manage.p_state_h.STATE_DEFINE_H.SYSTEM_RUN = 0;
N	
N	power_manage.work_mode = nxt_mode;
N}
N
Nvoid first_open_dr_save_state(void)
N{
N	power_manage.p_state_h.VAL = 0x05u;
N  power_manage.p_state_l.VAL = 0x7fu; 
N	
N	HAL_GPIO_WritePin(GPIOB, V24V_OUT1_Pin, GPIO_PIN_SET);
X	HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x0400UL)), ((uint16_t)0x0200), GPIO_PIN_SET);
N  HAL_GPIO_WritePin(GPIOF, V24V_OUT4_Pin|POWER24V_ON_Pin, GPIO_PIN_SET);
X  HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1400UL)), ((uint16_t)0x0004)|((uint16_t)0x1000), GPIO_PIN_SET);
N}
N
Nvoid Reload_State_All_Value(void)
N{	
N	close_all_dr_save_state();
N	power_manage.p_breakdown_h.VAL = 0x00u;
N	power_manage.p_breakdown_l.VAL = 0x00u;
N	HAL_GPIO_WritePin(OC_PROTECT_GPIO_Port, OC_PROTECT_Pin, GPIO_PIN_RESET);
X	HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0002), GPIO_PIN_RESET);
N	power_manage.work_mode = 0u;
N}
N
Nvoid Reload_Config_All_Value(void)
N{
N	power_manage.upload_time = 500;
N}
N
Nstatic uint32_t SAFE_48V_SWITCH_ON_TIMER = 0u;
Nstatic uint8_t SAFE_48V_SWITCH_ON_STATE = 0u;
Nstatic void PowerOnCharge(void)
N{
N		uint32_t now = 0u;
N		uint32_t elapse = 0u;
N		if(HAL_GPIO_ReadPin(SAFE_48V_SWITCH_GPIO_Port,SAFE_48V_SWITCH_Pin) == GPIO_PIN_SET)
X		if(HAL_GPIO_ReadPin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1400UL)),((uint16_t)0x0800)) == GPIO_PIN_SET)
N		{
N			SAFE_48V_SWITCH_ON_STATE = 0u;
N		}
N		
N		switch(SAFE_48V_SWITCH_ON_STATE)
N		{
N			case 1u:
N					HAL_GPIO_WritePin(OC_PROTECT_GPIO_Port, OC_PROTECT_Pin, GPIO_PIN_RESET);
X					HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0002), GPIO_PIN_RESET);
N					now = HAL_GetTick();
N					elapse = now - SAFE_48V_SWITCH_ON_TIMER;
N					if(elapse >= 1500u)
N					{
N						SAFE_48V_SWITCH_ON_STATE = 2u;
N					}
N				break;
N			case 2u:
N					HAL_GPIO_WritePin(OC_PROTECT_GPIO_Port, OC_PROTECT_Pin, GPIO_PIN_SET);
X					HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0002), GPIO_PIN_SET);
N			    power_manage.work_mode = POWER_STATUS_48VSTART;
N				break;
N			case 0u:
N			default:
N					HAL_GPIO_WritePin(OC_PROTECT_GPIO_Port, OC_PROTECT_Pin, GPIO_PIN_RESET);
X					HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0002), GPIO_PIN_RESET);
N					if(HAL_GPIO_ReadPin(SAFE_48V_SWITCH_GPIO_Port,SAFE_48V_SWITCH_Pin) == GPIO_PIN_RESET)
X					if(HAL_GPIO_ReadPin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1400UL)),((uint16_t)0x0800)) == GPIO_PIN_RESET)
N					{
N							SAFE_48V_SWITCH_ON_STATE = 1u;
N							SAFE_48V_SWITCH_ON_TIMER = HAL_GetTick();
N					}
N				break;
N		}
N}
N
Nstatic uint32_t SAFE_48V_SWITCH_OFF_TIMER = 0u;
Nstatic uint8_t SAFE_48V_SWITCH_OFF_STATE = 0u;
Nstatic void PowerAccessCharge(void)
N{
N		uint32_t now = 0u;
N		uint32_t elapse = 0u;
N		if(HAL_GPIO_ReadPin(SAFE_48V_SWITCH_GPIO_Port,SAFE_48V_SWITCH_Pin) == GPIO_PIN_RESET)
X		if(HAL_GPIO_ReadPin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1400UL)),((uint16_t)0x0800)) == GPIO_PIN_RESET)
N		{
N			SAFE_48V_SWITCH_OFF_STATE = 0u;
N		}
N		
N		switch(SAFE_48V_SWITCH_OFF_STATE)
N		{
N			case 1u:
N					HAL_GPIO_WritePin(OC_PROTECT_GPIO_Port, OC_PROTECT_Pin, GPIO_PIN_SET);
X					HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0002), GPIO_PIN_SET);
N					now = HAL_GetTick();
N					elapse = now - SAFE_48V_SWITCH_OFF_TIMER;
N					if(elapse >= 100u)
N					{
N						SAFE_48V_SWITCH_OFF_STATE = 2u;
N					}
N				break;
N			case 2u:
N					HAL_GPIO_WritePin(OC_PROTECT_GPIO_Port, OC_PROTECT_Pin, GPIO_PIN_RESET);
X					HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0002), GPIO_PIN_RESET);
N			    power_manage.work_mode = POWER_STATUS_48VNOSTART;
N				break;
N			case 0u:
N			default:
N					HAL_GPIO_WritePin(OC_PROTECT_GPIO_Port, OC_PROTECT_Pin, GPIO_PIN_SET);
X					HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0002), GPIO_PIN_SET);
N					if(HAL_GPIO_ReadPin(SAFE_48V_SWITCH_GPIO_Port,SAFE_48V_SWITCH_Pin) == GPIO_PIN_SET)
X					if(HAL_GPIO_ReadPin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1400UL)),((uint16_t)0x0800)) == GPIO_PIN_SET)
N					{
N							SAFE_48V_SWITCH_OFF_STATE = 1u;
N							SAFE_48V_SWITCH_OFF_TIMER = HAL_GetTick();
N					}
N				break;
N		}
N}
N
Nvoid shutdown_mode_operation(void)
N{
N	HAL_StatusTypeDef TransmitResult;
N	uint32_t ShutdownnowTime;
N	uint32_t ShutdownelapseTime;
N	static uint8_t ShutdownState = 0u;
N	static uint32_t ShutdownTime = 0u;
N	
N	switch(ShutdownState)
N	{
N		case 0u:	
N		  TransmitResult = Power_Command_Transmit((uint8_t)SM2SU_REQ_CD_POWER_OFF_REQUIRE);
X		  TransmitResult = Power_Command_Transmit((uint8_t)3u);
N	    if(TransmitResult == HAL_OK)
N			{
N				ShutdownTime = HAL_GetTick();
N				ShutdownState = 1u;
N			}
N			break;
N		case 1u:
N			ShutdownnowTime = HAL_GetTick();
N	    ShutdownelapseTime = ShutdownnowTime - ShutdownTime; 
N		  if(ShutdownelapseTime >= 5000)
N		  {
N			  force_shutdown(POWER_STATUS_IDLE);
N				ShutdownState = 0u;
N		  }		
N			break;
N		default:
N			break;		
N	}
N}
N
Nvoid softwarepoweroff_mode_operation(void)
N{
N	HAL_StatusTypeDef TransmitResult;
N	uint32_t softwarepoweroffnowTime;
N	uint32_t softwarepoweroffelapseTime;
N	static uint8_t softwarepoweroffState = 0u;
N	static uint32_t softwarepoweroffTime = 0u;
N	
N	switch(softwarepoweroffState)
N	{
N		case 0u:	
N		  TransmitResult = Power_Command_Transmit((uint8_t)SM2SU_REQ_CD_REPLY_POWER_OFF_COMMAND);
X		  TransmitResult = Power_Command_Transmit((uint8_t)4u);
N	    if(TransmitResult == HAL_OK)
N			{
N				softwarepoweroffTime = HAL_GetTick();
N				softwarepoweroffState = 1u;
N			}
N			break;
N		case 1u:
N			softwarepoweroffnowTime = HAL_GetTick();
N	    softwarepoweroffelapseTime = softwarepoweroffnowTime - softwarepoweroffTime; 
N		  if(softwarepoweroffelapseTime >= 5000)
N		  {
N			  force_shutdown(POWER_STATUS_IDLE);
N				softwarepoweroffState = 0u;
N		  }		
N			break;
N		default:
N			break;		
N	}
N}
N
Nvoid work_mode_operation(void)
N{
N	
N	if(power_manage.AI_SW1 == 1) /* 电压 */
N	{
N		HAL_GPIO_WritePin(AI_IU_SW1_GPIO_Port, AI_IU_SW1_Pin, GPIO_PIN_RESET);
X		HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0040), GPIO_PIN_RESET);
N	}
N	else if(power_manage.AI_SW1 == 0) /* 电流 */
N	{
N	  HAL_GPIO_WritePin(AI_IU_SW1_GPIO_Port, AI_IU_SW1_Pin, GPIO_PIN_SET);
X	  HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x1000UL)), ((uint16_t)0x0040), GPIO_PIN_SET);
N	}
N	
N	if(power_manage.AI_SW2 == 1)
N	{
N		HAL_GPIO_WritePin(AI_IU_SW2_GPIO_Port, AI_IU_SW2_Pin, GPIO_PIN_RESET);
X		HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x0400UL)), ((uint16_t)0x0002), GPIO_PIN_RESET);
N	}
N	else if(power_manage.AI_SW2 == 0)
N	{
N	  HAL_GPIO_WritePin(AI_IU_SW2_GPIO_Port, AI_IU_SW2_Pin, GPIO_PIN_SET);
X	  HAL_GPIO_WritePin(((GPIO_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x0400UL)), ((uint16_t)0x0002), GPIO_PIN_SET);
N	}
N	
N	switch(power_manage.work_mode)
N	{
N		case POWER_STATUS_IDLE:
N			sampling_flag = 1u;
N		  break;
N		case POWER_STATUS_POWERON:
N			sampling_flag = 1u;
N		  first_open_dr_save_state();
N		  power_manage.p_state_h.STATE_DEFINE_H.SYSTEM_RUN = 1u;
N	    power_manage.work_mode = POWER_STATUS_48VNOSTART;
N		  break;
N		case POWER_STATUS_48VNOSTART:
N		  PowerOnCharge();
N			break;
N		case POWER_STATUS_48VSTART:
N		  PowerAccessCharge();
N			break;
N		case POWER_STATUS_SHUTDWON:
N      shutdown_mode_operation();
N	    break;
N		case POWER_STATUS_SOFTWAREPOWEROFF:
N      softwarepoweroff_mode_operation();
N			break;
N		default:
N			break;	
N	}
N}
N
