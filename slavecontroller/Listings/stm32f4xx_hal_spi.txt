; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_hal_spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hal_spi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\stm32f4xx_hal_spi.crf D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_spi.c]
                          THUMB

                          AREA ||i.HAL_SPI_Abort||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort PROC
;;;1993     */
;;;1994   HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
000000  b53e              PUSH     {r1-r5,lr}
;;;1995   {
000002  4604              MOV      r4,r0
;;;1996     HAL_StatusTypeDef errorcode;
;;;1997     __IO uint32_t count;
;;;1998     __IO uint32_t resetcount;
;;;1999   
;;;2000     /* Initialized local variable  */
;;;2001     errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2002     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000006  4857              LDR      r0,|L1.356|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  2118              MOVS     r1,#0x18
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  f44f717a          MOV      r1,#0x3e8
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  2164              MOVS     r1,#0x64
00001a  4348              MULS     r0,r1,r0
00001c  9001              STR      r0,[sp,#4]
;;;2003     count = resetcount;
00001e  9801              LDR      r0,[sp,#4]
000020  9002              STR      r0,[sp,#8]
;;;2004   
;;;2005     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;2006     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
000022  6820              LDR      r0,[r4,#0]
000024  6840              LDR      r0,[r0,#4]
000026  f0200020          BIC      r0,r0,#0x20
00002a  6821              LDR      r1,[r4,#0]
00002c  6048              STR      r0,[r1,#4]
;;;2007   
;;;2008     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;2009     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
00002e  6820              LDR      r0,[r4,#0]
000030  6840              LDR      r0,[r0,#4]
000032  f0000080          AND      r0,r0,#0x80
000036  2880              CMP      r0,#0x80
000038  d113              BNE      |L1.98|
;;;2010     {
;;;2011       hspi->TxISR = SPI_AbortTx_ISR;
00003a  484b              LDR      r0,|L1.360|
00003c  6460              STR      r0,[r4,#0x44]
;;;2012       /* Wait HAL_SPI_STATE_ABORT state */
;;;2013       do
00003e  bf00              NOP      
                  |L1.64|
;;;2014       {
;;;2015         if (count == 0U)
000040  9802              LDR      r0,[sp,#8]
000042  b920              CBNZ     r0,|L1.78|
;;;2016         {
;;;2017           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000044  6d60              LDR      r0,[r4,#0x54]
000046  f0400040          ORR      r0,r0,#0x40
00004a  6560              STR      r0,[r4,#0x54]
;;;2018           break;
00004c  e006              B        |L1.92|
                  |L1.78|
;;;2019         }
;;;2020         count--;
00004e  9802              LDR      r0,[sp,#8]
000050  1e40              SUBS     r0,r0,#1
000052  9002              STR      r0,[sp,#8]
;;;2021       } while (hspi->State != HAL_SPI_STATE_ABORT);
000054  f8940051          LDRB     r0,[r4,#0x51]
000058  2807              CMP      r0,#7
00005a  d1f1              BNE      |L1.64|
                  |L1.92|
00005c  bf00              NOP                            ;2018
;;;2022       /* Reset Timeout Counter */
;;;2023       count = resetcount;
00005e  9801              LDR      r0,[sp,#4]
000060  9002              STR      r0,[sp,#8]
                  |L1.98|
;;;2024     }
;;;2025   
;;;2026     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
000062  6820              LDR      r0,[r4,#0]
000064  6840              LDR      r0,[r0,#4]
000066  f0000040          AND      r0,r0,#0x40
00006a  2840              CMP      r0,#0x40
00006c  d113              BNE      |L1.150|
;;;2027     {
;;;2028       hspi->RxISR = SPI_AbortRx_ISR;
00006e  483f              LDR      r0,|L1.364|
000070  6420              STR      r0,[r4,#0x40]
;;;2029       /* Wait HAL_SPI_STATE_ABORT state */
;;;2030       do
000072  bf00              NOP      
                  |L1.116|
;;;2031       {
;;;2032         if (count == 0U)
000074  9802              LDR      r0,[sp,#8]
000076  b920              CBNZ     r0,|L1.130|
;;;2033         {
;;;2034           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000078  6d60              LDR      r0,[r4,#0x54]
00007a  f0400040          ORR      r0,r0,#0x40
00007e  6560              STR      r0,[r4,#0x54]
;;;2035           break;
000080  e006              B        |L1.144|
                  |L1.130|
;;;2036         }
;;;2037         count--;
000082  9802              LDR      r0,[sp,#8]
000084  1e40              SUBS     r0,r0,#1
000086  9002              STR      r0,[sp,#8]
;;;2038       } while (hspi->State != HAL_SPI_STATE_ABORT);
000088  f8940051          LDRB     r0,[r4,#0x51]
00008c  2807              CMP      r0,#7
00008e  d1f1              BNE      |L1.116|
                  |L1.144|
000090  bf00              NOP                            ;2035
;;;2039       /* Reset Timeout Counter */
;;;2040       count = resetcount;
000092  9801              LDR      r0,[sp,#4]
000094  9002              STR      r0,[sp,#8]
                  |L1.150|
;;;2041     }
;;;2042   
;;;2043     /* Disable the SPI DMA Tx request if enabled */
;;;2044     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
000096  6820              LDR      r0,[r4,#0]
000098  6840              LDR      r0,[r0,#4]
00009a  f0000002          AND      r0,r0,#2
00009e  2802              CMP      r0,#2
0000a0  d122              BNE      |L1.232|
;;;2045     {
;;;2046       /* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;2047       if (hspi->hdmatx != NULL)
0000a2  6ca0              LDR      r0,[r4,#0x48]
0000a4  b300              CBZ      r0,|L1.232|
;;;2048       {
;;;2049         /* Set the SPI DMA Abort callback :
;;;2050         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;2051         hspi->hdmatx->XferAbortCallback = NULL;
0000a6  2000              MOVS     r0,#0
0000a8  6ca1              LDR      r1,[r4,#0x48]
0000aa  6508              STR      r0,[r1,#0x50]
;;;2052   
;;;2053         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2054         if (HAL_DMA_Abort(hspi->hdmatx) != HAL_OK)
0000ac  6ca0              LDR      r0,[r4,#0x48]
0000ae  f7fffffe          BL       HAL_DMA_Abort
0000b2  b108              CBZ      r0,|L1.184|
;;;2055         {
;;;2056           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000b4  2040              MOVS     r0,#0x40
0000b6  6560              STR      r0,[r4,#0x54]
                  |L1.184|
;;;2057         }
;;;2058   
;;;2059         /* Disable Tx DMA Request */
;;;2060         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6840              LDR      r0,[r0,#4]
0000bc  f0200002          BIC      r0,r0,#2
0000c0  6821              LDR      r1,[r4,#0]
0000c2  6048              STR      r0,[r1,#4]
;;;2061   
;;;2062         /* Wait until TXE flag is set */
;;;2063         do
0000c4  bf00              NOP      
                  |L1.198|
;;;2064         {
;;;2065           if (count == 0U)
0000c6  9802              LDR      r0,[sp,#8]
0000c8  b920              CBNZ     r0,|L1.212|
;;;2066           {
;;;2067             SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
0000ca  6d60              LDR      r0,[r4,#0x54]
0000cc  f0400040          ORR      r0,r0,#0x40
0000d0  6560              STR      r0,[r4,#0x54]
;;;2068             break;
0000d2  e008              B        |L1.230|
                  |L1.212|
;;;2069           }
;;;2070           count--;
0000d4  9802              LDR      r0,[sp,#8]
0000d6  1e40              SUBS     r0,r0,#1
0000d8  9002              STR      r0,[sp,#8]
;;;2071         } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
0000da  6820              LDR      r0,[r4,#0]
0000dc  6880              LDR      r0,[r0,#8]
0000de  f0000002          AND      r0,r0,#2
0000e2  2800              CMP      r0,#0
0000e4  d0ef              BEQ      |L1.198|
                  |L1.230|
0000e6  bf00              NOP                            ;2068
                  |L1.232|
;;;2072       }
;;;2073     }
;;;2074   
;;;2075     /* Disable the SPI DMA Rx request if enabled */
;;;2076     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000e8  6820              LDR      r0,[r4,#0]
0000ea  6840              LDR      r0,[r0,#4]
0000ec  f0000001          AND      r0,r0,#1
0000f0  b1b0              CBZ      r0,|L1.288|
;;;2077     {
;;;2078       /* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;2079       if (hspi->hdmarx != NULL)
0000f2  6ce0              LDR      r0,[r4,#0x4c]
0000f4  b1a0              CBZ      r0,|L1.288|
;;;2080       {
;;;2081         /* Set the SPI DMA Abort callback :
;;;2082         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;2083         hspi->hdmarx->XferAbortCallback = NULL;
0000f6  2000              MOVS     r0,#0
0000f8  6ce1              LDR      r1,[r4,#0x4c]
0000fa  6508              STR      r0,[r1,#0x50]
;;;2084   
;;;2085         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2086         if (HAL_DMA_Abort(hspi->hdmarx) != HAL_OK)
0000fc  6ce0              LDR      r0,[r4,#0x4c]
0000fe  f7fffffe          BL       HAL_DMA_Abort
000102  b108              CBZ      r0,|L1.264|
;;;2087         {
;;;2088           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000104  2040              MOVS     r0,#0x40
000106  6560              STR      r0,[r4,#0x54]
                  |L1.264|
;;;2089         }
;;;2090   
;;;2091         /* Disable peripheral */
;;;2092         __HAL_SPI_DISABLE(hspi);
000108  6820              LDR      r0,[r4,#0]
00010a  6800              LDR      r0,[r0,#0]
00010c  f0200040          BIC      r0,r0,#0x40
000110  6821              LDR      r1,[r4,#0]
000112  6008              STR      r0,[r1,#0]
;;;2093   
;;;2094         /* Disable Rx DMA Request */
;;;2095         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
000114  6820              LDR      r0,[r4,#0]
000116  6840              LDR      r0,[r0,#4]
000118  f0200001          BIC      r0,r0,#1
00011c  6821              LDR      r1,[r4,#0]
00011e  6048              STR      r0,[r1,#4]
                  |L1.288|
;;;2096       }
;;;2097     }
;;;2098     /* Reset Tx and Rx transfer counters */
;;;2099     hspi->RxXferCount = 0U;
000120  2000              MOVS     r0,#0
000122  87e0              STRH     r0,[r4,#0x3e]
;;;2100     hspi->TxXferCount = 0U;
000124  86e0              STRH     r0,[r4,#0x36]
;;;2101   
;;;2102     /* Check error during Abort procedure */
;;;2103     if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
000126  6d60              LDR      r0,[r4,#0x54]
000128  2840              CMP      r0,#0x40
00012a  d101              BNE      |L1.304|
;;;2104     {
;;;2105       /* return HAL_Error in case of error during Abort procedure */
;;;2106       errorcode = HAL_ERROR;
00012c  2501              MOVS     r5,#1
00012e  e001              B        |L1.308|
                  |L1.304|
;;;2107     }
;;;2108     else
;;;2109     {
;;;2110       /* Reset errorCode */
;;;2111       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
000130  2000              MOVS     r0,#0
000132  6560              STR      r0,[r4,#0x54]
                  |L1.308|
;;;2112     }
;;;2113   
;;;2114     /* Clear the Error flags in the SR register */
;;;2115     __HAL_SPI_CLEAR_OVRFLAG(hspi);
000134  bf00              NOP      
000136  2000              MOVS     r0,#0
000138  9000              STR      r0,[sp,#0]
00013a  6820              LDR      r0,[r4,#0]
00013c  68c0              LDR      r0,[r0,#0xc]
00013e  9000              STR      r0,[sp,#0]
000140  6820              LDR      r0,[r4,#0]
000142  6880              LDR      r0,[r0,#8]
000144  9000              STR      r0,[sp,#0]
000146  bf00              NOP      
000148  bf00              NOP      
;;;2116     __HAL_SPI_CLEAR_FREFLAG(hspi);
00014a  bf00              NOP      
00014c  2000              MOVS     r0,#0
00014e  9000              STR      r0,[sp,#0]
000150  6820              LDR      r0,[r4,#0]
000152  6880              LDR      r0,[r0,#8]
000154  9000              STR      r0,[sp,#0]
000156  bf00              NOP      
000158  bf00              NOP      
;;;2117   
;;;2118     /* Restore hspi->state to ready */
;;;2119     hspi->State = HAL_SPI_STATE_READY;
00015a  2001              MOVS     r0,#1
00015c  f8840051          STRB     r0,[r4,#0x51]
;;;2120   
;;;2121     return errorcode;
000160  4628              MOV      r0,r5
;;;2122   }
000162  bd3e              POP      {r1-r5,pc}
;;;2123   
                          ENDP

                  |L1.356|
                          DCD      SystemCoreClock
                  |L1.360|
                          DCD      SPI_AbortTx_ISR
                  |L1.364|
                          DCD      SPI_AbortRx_ISR

                          AREA ||i.HAL_SPI_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_AbortCpltCallback PROC
;;;2600     */
;;;2601   __weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2602   {
;;;2603     /* Prevent unused argument(s) compilation warning */
;;;2604     UNUSED(hspi);
;;;2605   
;;;2606     /* NOTE : This function should not be modified, when the callback is needed,
;;;2607               the HAL_SPI_AbortCpltCallback can be implemented in the user file.
;;;2608      */
;;;2609   }
;;;2610   
                          ENDP


                          AREA ||i.HAL_SPI_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort_IT PROC
;;;2138     */
;;;2139   HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2140   {
000002  4604              MOV      r4,r0
;;;2141     HAL_StatusTypeDef errorcode;
;;;2142     uint32_t abortcplt ;
;;;2143     __IO uint32_t count;
;;;2144     __IO uint32_t resetcount;
;;;2145   
;;;2146     /* Initialized local variable  */
;;;2147     errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2148     abortcplt = 1U;
000006  2601              MOVS     r6,#1
;;;2149     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000008  4858              LDR      r0,|L3.364|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  2118              MOVS     r1,#0x18
00000e  fbb0f0f1          UDIV     r0,r0,r1
000012  f44f717a          MOV      r1,#0x3e8
000016  fbb0f0f1          UDIV     r0,r0,r1
00001a  2164              MOVS     r1,#0x64
00001c  4348              MULS     r0,r1,r0
00001e  9001              STR      r0,[sp,#4]
;;;2150     count = resetcount;
000020  9801              LDR      r0,[sp,#4]
000022  9002              STR      r0,[sp,#8]
;;;2151   
;;;2152     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;2153     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
000024  6820              LDR      r0,[r4,#0]
000026  6840              LDR      r0,[r0,#4]
000028  f0200020          BIC      r0,r0,#0x20
00002c  6821              LDR      r1,[r4,#0]
00002e  6048              STR      r0,[r1,#4]
;;;2154   
;;;2155     /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
;;;2156     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
000030  6820              LDR      r0,[r4,#0]
000032  6840              LDR      r0,[r0,#4]
000034  f0000080          AND      r0,r0,#0x80
000038  2880              CMP      r0,#0x80
00003a  d113              BNE      |L3.100|
;;;2157     {
;;;2158       hspi->TxISR = SPI_AbortTx_ISR;
00003c  484c              LDR      r0,|L3.368|
00003e  6460              STR      r0,[r4,#0x44]
;;;2159       /* Wait HAL_SPI_STATE_ABORT state */
;;;2160       do
000040  bf00              NOP      
                  |L3.66|
;;;2161       {
;;;2162         if (count == 0U)
000042  9802              LDR      r0,[sp,#8]
000044  b920              CBNZ     r0,|L3.80|
;;;2163         {
;;;2164           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000046  6d60              LDR      r0,[r4,#0x54]
000048  f0400040          ORR      r0,r0,#0x40
00004c  6560              STR      r0,[r4,#0x54]
;;;2165           break;
00004e  e006              B        |L3.94|
                  |L3.80|
;;;2166         }
;;;2167         count--;
000050  9802              LDR      r0,[sp,#8]
000052  1e40              SUBS     r0,r0,#1
000054  9002              STR      r0,[sp,#8]
;;;2168       } while (hspi->State != HAL_SPI_STATE_ABORT);
000056  f8940051          LDRB     r0,[r4,#0x51]
00005a  2807              CMP      r0,#7
00005c  d1f1              BNE      |L3.66|
                  |L3.94|
00005e  bf00              NOP                            ;2165
;;;2169       /* Reset Timeout Counter */
;;;2170       count = resetcount;
000060  9801              LDR      r0,[sp,#4]
000062  9002              STR      r0,[sp,#8]
                  |L3.100|
;;;2171     }
;;;2172   
;;;2173     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
000064  6820              LDR      r0,[r4,#0]
000066  6840              LDR      r0,[r0,#4]
000068  f0000040          AND      r0,r0,#0x40
00006c  2840              CMP      r0,#0x40
00006e  d113              BNE      |L3.152|
;;;2174     {
;;;2175       hspi->RxISR = SPI_AbortRx_ISR;
000070  4840              LDR      r0,|L3.372|
000072  6420              STR      r0,[r4,#0x40]
;;;2176       /* Wait HAL_SPI_STATE_ABORT state */
;;;2177       do
000074  bf00              NOP      
                  |L3.118|
;;;2178       {
;;;2179         if (count == 0U)
000076  9802              LDR      r0,[sp,#8]
000078  b920              CBNZ     r0,|L3.132|
;;;2180         {
;;;2181           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
00007a  6d60              LDR      r0,[r4,#0x54]
00007c  f0400040          ORR      r0,r0,#0x40
000080  6560              STR      r0,[r4,#0x54]
;;;2182           break;
000082  e006              B        |L3.146|
                  |L3.132|
;;;2183         }
;;;2184         count--;
000084  9802              LDR      r0,[sp,#8]
000086  1e40              SUBS     r0,r0,#1
000088  9002              STR      r0,[sp,#8]
;;;2185       } while (hspi->State != HAL_SPI_STATE_ABORT);
00008a  f8940051          LDRB     r0,[r4,#0x51]
00008e  2807              CMP      r0,#7
000090  d1f1              BNE      |L3.118|
                  |L3.146|
000092  bf00              NOP                            ;2182
;;;2186       /* Reset Timeout Counter */
;;;2187       count = resetcount;
000094  9801              LDR      r0,[sp,#4]
000096  9002              STR      r0,[sp,#8]
                  |L3.152|
;;;2188     }
;;;2189   
;;;2190     /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
;;;2191        before any call to DMA Abort functions */
;;;2192     /* DMA Tx Handle is valid */
;;;2193     if (hspi->hdmatx != NULL)
000098  6ca0              LDR      r0,[r4,#0x48]
00009a  b160              CBZ      r0,|L3.182|
;;;2194     {
;;;2195       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;2196          Otherwise, set it to NULL */
;;;2197       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
00009c  6820              LDR      r0,[r4,#0]
00009e  6840              LDR      r0,[r0,#4]
0000a0  f0000002          AND      r0,r0,#2
0000a4  2802              CMP      r0,#2
0000a6  d103              BNE      |L3.176|
;;;2198       {
;;;2199         hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
0000a8  4833              LDR      r0,|L3.376|
0000aa  6ca1              LDR      r1,[r4,#0x48]
0000ac  6508              STR      r0,[r1,#0x50]
0000ae  e002              B        |L3.182|
                  |L3.176|
;;;2200       }
;;;2201       else
;;;2202       {
;;;2203         hspi->hdmatx->XferAbortCallback = NULL;
0000b0  2000              MOVS     r0,#0
0000b2  6ca1              LDR      r1,[r4,#0x48]
0000b4  6508              STR      r0,[r1,#0x50]
                  |L3.182|
;;;2204       }
;;;2205     }
;;;2206     /* DMA Rx Handle is valid */
;;;2207     if (hspi->hdmarx != NULL)
0000b6  6ce0              LDR      r0,[r4,#0x4c]
0000b8  b158              CBZ      r0,|L3.210|
;;;2208     {
;;;2209       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;2210          Otherwise, set it to NULL */
;;;2211       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6840              LDR      r0,[r0,#4]
0000be  f0000001          AND      r0,r0,#1
0000c2  b118              CBZ      r0,|L3.204|
;;;2212       {
;;;2213         hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
0000c4  482d              LDR      r0,|L3.380|
0000c6  6ce1              LDR      r1,[r4,#0x4c]
0000c8  6508              STR      r0,[r1,#0x50]
0000ca  e002              B        |L3.210|
                  |L3.204|
;;;2214       }
;;;2215       else
;;;2216       {
;;;2217         hspi->hdmarx->XferAbortCallback = NULL;
0000cc  2000              MOVS     r0,#0
0000ce  6ce1              LDR      r1,[r4,#0x4c]
0000d0  6508              STR      r0,[r1,#0x50]
                  |L3.210|
;;;2218       }
;;;2219     }
;;;2220   
;;;2221     /* Disable the SPI DMA Tx request if enabled */
;;;2222     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
0000d2  6820              LDR      r0,[r4,#0]
0000d4  6840              LDR      r0,[r0,#4]
0000d6  f0000002          AND      r0,r0,#2
0000da  2802              CMP      r0,#2
0000dc  d10c              BNE      |L3.248|
;;;2223     {
;;;2224       /* Abort the SPI DMA Tx Stream/Channel */
;;;2225       if (hspi->hdmatx != NULL)
0000de  6ca0              LDR      r0,[r4,#0x48]
0000e0  b150              CBZ      r0,|L3.248|
;;;2226       {
;;;2227         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2228         if (HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
0000e2  6ca0              LDR      r0,[r4,#0x48]
0000e4  f7fffffe          BL       HAL_DMA_Abort_IT
0000e8  b128              CBZ      r0,|L3.246|
;;;2229         {
;;;2230           hspi->hdmatx->XferAbortCallback = NULL;
0000ea  2000              MOVS     r0,#0
0000ec  6ca1              LDR      r1,[r4,#0x48]
0000ee  6508              STR      r0,[r1,#0x50]
;;;2231           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000f0  2040              MOVS     r0,#0x40
0000f2  6560              STR      r0,[r4,#0x54]
0000f4  e000              B        |L3.248|
                  |L3.246|
;;;2232         }
;;;2233         else
;;;2234         {
;;;2235           abortcplt = 0U;
0000f6  2600              MOVS     r6,#0
                  |L3.248|
;;;2236         }
;;;2237       }
;;;2238     }
;;;2239     /* Disable the SPI DMA Rx request if enabled */
;;;2240     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000f8  6820              LDR      r0,[r4,#0]
0000fa  6840              LDR      r0,[r0,#4]
0000fc  f0000001          AND      r0,r0,#1
000100  b160              CBZ      r0,|L3.284|
;;;2241     {
;;;2242       /* Abort the SPI DMA Rx Stream/Channel */
;;;2243       if (hspi->hdmarx != NULL)
000102  6ce0              LDR      r0,[r4,#0x4c]
000104  b150              CBZ      r0,|L3.284|
;;;2244       {
;;;2245         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2246         if (HAL_DMA_Abort_IT(hspi->hdmarx) !=  HAL_OK)
000106  6ce0              LDR      r0,[r4,#0x4c]
000108  f7fffffe          BL       HAL_DMA_Abort_IT
00010c  b128              CBZ      r0,|L3.282|
;;;2247         {
;;;2248           hspi->hdmarx->XferAbortCallback = NULL;
00010e  2000              MOVS     r0,#0
000110  6ce1              LDR      r1,[r4,#0x4c]
000112  6508              STR      r0,[r1,#0x50]
;;;2249           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000114  2040              MOVS     r0,#0x40
000116  6560              STR      r0,[r4,#0x54]
000118  e000              B        |L3.284|
                  |L3.282|
;;;2250         }
;;;2251         else
;;;2252         {
;;;2253           abortcplt = 0U;
00011a  2600              MOVS     r6,#0
                  |L3.284|
;;;2254         }
;;;2255       }
;;;2256     }
;;;2257   
;;;2258     if (abortcplt == 1U)
00011c  2e01              CMP      r6,#1
00011e  d122              BNE      |L3.358|
;;;2259     {
;;;2260       /* Reset Tx and Rx transfer counters */
;;;2261       hspi->RxXferCount = 0U;
000120  2000              MOVS     r0,#0
000122  87e0              STRH     r0,[r4,#0x3e]
;;;2262       hspi->TxXferCount = 0U;
000124  86e0              STRH     r0,[r4,#0x36]
;;;2263   
;;;2264       /* Check error during Abort procedure */
;;;2265       if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
000126  6d60              LDR      r0,[r4,#0x54]
000128  2840              CMP      r0,#0x40
00012a  d101              BNE      |L3.304|
;;;2266       {
;;;2267         /* return HAL_Error in case of error during Abort procedure */
;;;2268         errorcode = HAL_ERROR;
00012c  2501              MOVS     r5,#1
00012e  e001              B        |L3.308|
                  |L3.304|
;;;2269       }
;;;2270       else
;;;2271       {
;;;2272         /* Reset errorCode */
;;;2273         hspi->ErrorCode = HAL_SPI_ERROR_NONE;
000130  2000              MOVS     r0,#0
000132  6560              STR      r0,[r4,#0x54]
                  |L3.308|
;;;2274       }
;;;2275   
;;;2276       /* Clear the Error flags in the SR register */
;;;2277       __HAL_SPI_CLEAR_OVRFLAG(hspi);
000134  bf00              NOP      
000136  2000              MOVS     r0,#0
000138  9000              STR      r0,[sp,#0]
00013a  6820              LDR      r0,[r4,#0]
00013c  68c0              LDR      r0,[r0,#0xc]
00013e  9000              STR      r0,[sp,#0]
000140  6820              LDR      r0,[r4,#0]
000142  6880              LDR      r0,[r0,#8]
000144  9000              STR      r0,[sp,#0]
000146  bf00              NOP      
000148  bf00              NOP      
;;;2278       __HAL_SPI_CLEAR_FREFLAG(hspi);
00014a  bf00              NOP      
00014c  2000              MOVS     r0,#0
00014e  9000              STR      r0,[sp,#0]
000150  6820              LDR      r0,[r4,#0]
000152  6880              LDR      r0,[r0,#8]
000154  9000              STR      r0,[sp,#0]
000156  bf00              NOP      
000158  bf00              NOP      
;;;2279   
;;;2280       /* Restore hspi->State to Ready */
;;;2281       hspi->State = HAL_SPI_STATE_READY;
00015a  2001              MOVS     r0,#1
00015c  f8840051          STRB     r0,[r4,#0x51]
;;;2282   
;;;2283       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2284   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2285       hspi->AbortCpltCallback(hspi);
;;;2286   #else
;;;2287       HAL_SPI_AbortCpltCallback(hspi);
000160  4620              MOV      r0,r4
000162  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L3.358|
;;;2288   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2289     }
;;;2290   
;;;2291     return errorcode;
000166  4628              MOV      r0,r5
;;;2292   }
000168  bdfe              POP      {r1-r7,pc}
;;;2293   
                          ENDP

00016a  0000              DCW      0x0000
                  |L3.364|
                          DCD      SystemCoreClock
                  |L3.368|
                          DCD      SPI_AbortTx_ISR
                  |L3.372|
                          DCD      SPI_AbortRx_ISR
                  |L3.376|
                          DCD      SPI_DMATxAbortCallback
                  |L3.380|
                          DCD      SPI_DMARxAbortCallback

                          AREA ||i.HAL_SPI_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAPause PROC
;;;2299     */
;;;2300   HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2301   {
;;;2302     /* Process Locked */
;;;2303     __HAL_LOCK(hspi);
000002  bf00              NOP      
000004  f8910050          LDRB     r0,[r1,#0x50]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L4.16|
00000c  2002              MOVS     r0,#2
                  |L4.14|
;;;2304   
;;;2305     /* Disable the SPI DMA Tx & Rx requests */
;;;2306     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
;;;2307   
;;;2308     /* Process Unlocked */
;;;2309     __HAL_UNLOCK(hspi);
;;;2310   
;;;2311     return HAL_OK;
;;;2312   }
00000e  4770              BX       lr
                  |L4.16|
000010  2001              MOVS     r0,#1                 ;2303
000012  f8810050          STRB     r0,[r1,#0x50]         ;2303
000016  bf00              NOP                            ;2303
000018  6808              LDR      r0,[r1,#0]            ;2306
00001a  6840              LDR      r0,[r0,#4]            ;2306
00001c  f0200003          BIC      r0,r0,#3              ;2306
000020  680a              LDR      r2,[r1,#0]            ;2306
000022  6050              STR      r0,[r2,#4]            ;2306
000024  bf00              NOP                            ;2309
000026  2000              MOVS     r0,#0                 ;2309
000028  f8810050          STRB     r0,[r1,#0x50]         ;2309
00002c  bf00              NOP                            ;2309
00002e  bf00              NOP                            ;2311
000030  e7ed              B        |L4.14|
;;;2313   
                          ENDP


                          AREA ||i.HAL_SPI_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAResume PROC
;;;2319     */
;;;2320   HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2321   {
;;;2322     /* Process Locked */
;;;2323     __HAL_LOCK(hspi);
000002  bf00              NOP      
000004  f8910050          LDRB     r0,[r1,#0x50]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;2324   
;;;2325     /* Enable the SPI DMA Tx & Rx requests */
;;;2326     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
;;;2327   
;;;2328     /* Process Unlocked */
;;;2329     __HAL_UNLOCK(hspi);
;;;2330   
;;;2331     return HAL_OK;
;;;2332   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;2323
000012  f8810050          STRB     r0,[r1,#0x50]         ;2323
000016  bf00              NOP                            ;2323
000018  6808              LDR      r0,[r1,#0]            ;2326
00001a  6840              LDR      r0,[r0,#4]            ;2326
00001c  f0400003          ORR      r0,r0,#3              ;2326
000020  680a              LDR      r2,[r1,#0]            ;2326
000022  6050              STR      r0,[r2,#4]            ;2326
000024  bf00              NOP                            ;2329
000026  2000              MOVS     r0,#0                 ;2329
000028  f8810050          STRB     r0,[r1,#0x50]         ;2329
00002c  bf00              NOP                            ;2329
00002e  bf00              NOP                            ;2331
000030  e7ed              B        |L5.14|
;;;2333   
                          ENDP


                          AREA ||i.HAL_SPI_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAStop PROC
;;;2339     */
;;;2340   HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
000000  b570              PUSH     {r4-r6,lr}
;;;2341   {
000002  4604              MOV      r4,r0
;;;2342     HAL_StatusTypeDef errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2343     /* The Lock is not implemented on this API to allow the user application
;;;2344        to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
;;;2345        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;2346        and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
;;;2347        */
;;;2348   
;;;2349     /* Abort the SPI DMA tx Stream/Channel  */
;;;2350     if (hspi->hdmatx != NULL)
000006  6ca0              LDR      r0,[r4,#0x48]
000008  b140              CBZ      r0,|L6.28|
;;;2351     {
;;;2352       if (HAL_OK != HAL_DMA_Abort(hspi->hdmatx))
00000a  6ca0              LDR      r0,[r4,#0x48]
00000c  f7fffffe          BL       HAL_DMA_Abort
000010  b120              CBZ      r0,|L6.28|
;;;2353       {
;;;2354         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000012  6d60              LDR      r0,[r4,#0x54]
000014  f0400010          ORR      r0,r0,#0x10
000018  6560              STR      r0,[r4,#0x54]
;;;2355         errorcode = HAL_ERROR;
00001a  2501              MOVS     r5,#1
                  |L6.28|
;;;2356       }
;;;2357     }
;;;2358     /* Abort the SPI DMA rx Stream/Channel  */
;;;2359     if (hspi->hdmarx != NULL)
00001c  6ce0              LDR      r0,[r4,#0x4c]
00001e  b140              CBZ      r0,|L6.50|
;;;2360     {
;;;2361       if (HAL_OK != HAL_DMA_Abort(hspi->hdmarx))
000020  6ce0              LDR      r0,[r4,#0x4c]
000022  f7fffffe          BL       HAL_DMA_Abort
000026  b120              CBZ      r0,|L6.50|
;;;2362       {
;;;2363         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000028  6d60              LDR      r0,[r4,#0x54]
00002a  f0400010          ORR      r0,r0,#0x10
00002e  6560              STR      r0,[r4,#0x54]
;;;2364         errorcode = HAL_ERROR;
000030  2501              MOVS     r5,#1
                  |L6.50|
;;;2365       }
;;;2366     }
;;;2367   
;;;2368     /* Disable the SPI DMA Tx & Rx requests */
;;;2369     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000032  6820              LDR      r0,[r4,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f0200003          BIC      r0,r0,#3
00003a  6821              LDR      r1,[r4,#0]
00003c  6048              STR      r0,[r1,#4]
;;;2370     hspi->State = HAL_SPI_STATE_READY;
00003e  2001              MOVS     r0,#1
000040  f8840051          STRB     r0,[r4,#0x51]
;;;2371     return errorcode;
000044  4628              MOV      r0,r5
;;;2372   }
000046  bd70              POP      {r4-r6,pc}
;;;2373   
                          ENDP


                          AREA ||i.HAL_SPI_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DeInit PROC
;;;438      */
;;;439    HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;440    {
000002  4604              MOV      r4,r0
;;;441      /* Check the SPI handle allocation */
;;;442      if (hspi == NULL)
000004  b90c              CBNZ     r4,|L7.10|
;;;443      {
;;;444        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L7.8|
;;;445      }
;;;446    
;;;447      /* Check SPI Instance parameter */
;;;448      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;449    
;;;450      hspi->State = HAL_SPI_STATE_BUSY;
;;;451    
;;;452      /* Disable the SPI Peripheral Clock */
;;;453      __HAL_SPI_DISABLE(hspi);
;;;454    
;;;455    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;456      if (hspi->MspDeInitCallback == NULL)
;;;457      {
;;;458        hspi->MspDeInitCallback = HAL_SPI_MspDeInit; /* Legacy weak MspDeInit  */
;;;459      }
;;;460    
;;;461      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;462      hspi->MspDeInitCallback(hspi);
;;;463    #else
;;;464      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;465      HAL_SPI_MspDeInit(hspi);
;;;466    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;467    
;;;468      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;469      hspi->State = HAL_SPI_STATE_RESET;
;;;470    
;;;471      /* Release Lock */
;;;472      __HAL_UNLOCK(hspi);
;;;473    
;;;474      return HAL_OK;
;;;475    }
000008  bd10              POP      {r4,pc}
                  |L7.10|
00000a  2002              MOVS     r0,#2                 ;450
00000c  f8840051          STRB     r0,[r4,#0x51]         ;450
000010  6820              LDR      r0,[r4,#0]            ;453
000012  6800              LDR      r0,[r0,#0]            ;453
000014  f0200040          BIC      r0,r0,#0x40           ;453
000018  6821              LDR      r1,[r4,#0]            ;453
00001a  6008              STR      r0,[r1,#0]            ;453
00001c  4620              MOV      r0,r4                 ;465
00001e  f7fffffe          BL       HAL_SPI_MspDeInit
000022  2000              MOVS     r0,#0                 ;468
000024  6560              STR      r0,[r4,#0x54]         ;468
000026  f8840051          STRB     r0,[r4,#0x51]         ;469
00002a  bf00              NOP                            ;472
00002c  f8840050          STRB     r0,[r4,#0x50]         ;472
000030  bf00              NOP                            ;472
000032  bf00              NOP                            ;474
000034  e7e8              B        |L7.8|
;;;476    
                          ENDP


                          AREA ||i.HAL_SPI_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_ErrorCallback PROC
;;;2582     */
;;;2583   __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2584   {
;;;2585     /* Prevent unused argument(s) compilation warning */
;;;2586     UNUSED(hspi);
;;;2587   
;;;2588     /* NOTE : This function should not be modified, when the callback is needed,
;;;2589               the HAL_SPI_ErrorCallback should be implemented in the user file
;;;2590      */
;;;2591     /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
;;;2592               and user can use HAL_SPI_GetError() API to check the latest error occurred
;;;2593      */
;;;2594   }
;;;2595   
                          ENDP


                          AREA ||i.HAL_SPI_GetError||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetError PROC
;;;2647     */
;;;2648   uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2649   {
;;;2650     /* Return SPI ErrorCode */
;;;2651     return hspi->ErrorCode;
000002  6d48              LDR      r0,[r1,#0x54]
;;;2652   }
000004  4770              BX       lr
;;;2653   
                          ENDP


                          AREA ||i.HAL_SPI_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetState PROC
;;;2635     */
;;;2636   HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2637   {
;;;2638     /* Return SPI handle state */
;;;2639     return hspi->State;
000002  f8910051          LDRB     r0,[r1,#0x51]
;;;2640   }
000006  4770              BX       lr
;;;2641   
                          ENDP


                          AREA ||i.HAL_SPI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_SPI_IRQHandler PROC
;;;2379     */
;;;2380   void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2381   {
000002  4604              MOV      r4,r0
;;;2382     uint32_t itsource = hspi->Instance->CR2;
000004  6820              LDR      r0,[r4,#0]
000006  6846              LDR      r6,[r0,#4]
;;;2383     uint32_t itflag   = hspi->Instance->SR;
000008  6820              LDR      r0,[r4,#0]
00000a  6885              LDR      r5,[r0,#8]
;;;2384   
;;;2385     /* SPI in mode Receiver ----------------------------------------------------*/
;;;2386     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
00000c  f3c51080          UBFX     r0,r5,#6,#1
000010  b948              CBNZ     r0,|L11.38|
;;;2387         (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
000012  f0050001          AND      r0,r5,#1
000016  b130              CBZ      r0,|L11.38|
000018  f3c61080          UBFX     r0,r6,#6,#1
00001c  b118              CBZ      r0,|L11.38|
;;;2388     {
;;;2389       hspi->RxISR(hspi);
00001e  4620              MOV      r0,r4
000020  6c21              LDR      r1,[r4,#0x40]
000022  4788              BLX      r1
                  |L11.36|
;;;2390       return;
;;;2391     }
;;;2392   
;;;2393     /* SPI in mode Transmitter -------------------------------------------------*/
;;;2394     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
;;;2395     {
;;;2396       hspi->TxISR(hspi);
;;;2397       return;
;;;2398     }
;;;2399   
;;;2400     /* SPI in Error Treatment --------------------------------------------------*/
;;;2401     if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
;;;2402          || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
;;;2403     {
;;;2404       /* SPI Overrun error interrupt occurred ----------------------------------*/
;;;2405       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
;;;2406       {
;;;2407         if (hspi->State != HAL_SPI_STATE_BUSY_TX)
;;;2408         {
;;;2409           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
;;;2410           __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;2411         }
;;;2412         else
;;;2413         {
;;;2414           __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;2415           return;
;;;2416         }
;;;2417       }
;;;2418   
;;;2419       /* SPI Mode Fault error interrupt occurred -------------------------------*/
;;;2420       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
;;;2421       {
;;;2422         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
;;;2423         __HAL_SPI_CLEAR_MODFFLAG(hspi);
;;;2424       }
;;;2425   
;;;2426       /* SPI Frame error interrupt occurred ------------------------------------*/
;;;2427       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
;;;2428       {
;;;2429         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
;;;2430         __HAL_SPI_CLEAR_FREFLAG(hspi);
;;;2431       }
;;;2432   
;;;2433       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;2434       {
;;;2435         /* Disable all interrupts */
;;;2436         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
;;;2437   
;;;2438         hspi->State = HAL_SPI_STATE_READY;
;;;2439         /* Disable the SPI DMA requests if enabled */
;;;2440         if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
;;;2441         {
;;;2442           CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
;;;2443   
;;;2444           /* Abort the SPI DMA Rx channel */
;;;2445           if (hspi->hdmarx != NULL)
;;;2446           {
;;;2447             /* Set the SPI DMA Abort callback :
;;;2448             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2449             hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
;;;2450             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
;;;2451             {
;;;2452               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2453             }
;;;2454           }
;;;2455           /* Abort the SPI DMA Tx channel */
;;;2456           if (hspi->hdmatx != NULL)
;;;2457           {
;;;2458             /* Set the SPI DMA Abort callback :
;;;2459             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2460             hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
;;;2461             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
;;;2462             {
;;;2463               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2464             }
;;;2465           }
;;;2466         }
;;;2467         else
;;;2468         {
;;;2469           /* Call user error callback */
;;;2470   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2471           hspi->ErrorCallback(hspi);
;;;2472   #else
;;;2473           HAL_SPI_ErrorCallback(hspi);
;;;2474   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2475         }
;;;2476       }
;;;2477       return;
;;;2478     }
;;;2479   }
000024  bdf8              POP      {r3-r7,pc}
                  |L11.38|
000026  f3c50040          UBFX     r0,r5,#1,#1           ;2394
00002a  b130              CBZ      r0,|L11.58|
00002c  f3c610c0          UBFX     r0,r6,#7,#1           ;2394
000030  b118              CBZ      r0,|L11.58|
000032  4620              MOV      r0,r4                 ;2396
000034  6c61              LDR      r1,[r4,#0x44]         ;2396
000036  4788              BLX      r1                    ;2396
000038  e7f4              B        |L11.36|
                  |L11.58|
00003a  f3c51040          UBFX     r0,r5,#5,#1           ;2401
00003e  b930              CBNZ     r0,|L11.78|
000040  f3c51080          UBFX     r0,r5,#6,#1           ;2401
000044  b918              CBNZ     r0,|L11.78|
000046  f3c52000          UBFX     r0,r5,#8,#1           ;2402
00004a  2800              CMP      r0,#0                 ;2402
00004c  d07c              BEQ      |L11.328|
                  |L11.78|
00004e  f3c61040          UBFX     r0,r6,#5,#1           ;2402
000052  2800              CMP      r0,#0                 ;2402
000054  d07d              BEQ      |L11.338|
000056  f3c51080          UBFX     r0,r5,#6,#1           ;2405
00005a  b1f0              CBZ      r0,|L11.154|
00005c  f8940051          LDRB     r0,[r4,#0x51]         ;2407
000060  2803              CMP      r0,#3                 ;2407
000062  d00e              BEQ      |L11.130|
000064  6d60              LDR      r0,[r4,#0x54]         ;2409
000066  f0400004          ORR      r0,r0,#4              ;2409
00006a  6560              STR      r0,[r4,#0x54]         ;2409
00006c  bf00              NOP                            ;2410
00006e  2000              MOVS     r0,#0                 ;2410
000070  9000              STR      r0,[sp,#0]            ;2410
000072  6820              LDR      r0,[r4,#0]            ;2410
000074  68c0              LDR      r0,[r0,#0xc]          ;2410
000076  9000              STR      r0,[sp,#0]            ;2410
000078  6820              LDR      r0,[r4,#0]            ;2410
00007a  6880              LDR      r0,[r0,#8]            ;2410
00007c  9000              STR      r0,[sp,#0]            ;2410
00007e  bf00              NOP                            ;2410
000080  e00b              B        |L11.154|
                  |L11.130|
000082  bf00              NOP                            ;2414
000084  2000              MOVS     r0,#0                 ;2414
000086  9000              STR      r0,[sp,#0]            ;2414
000088  6820              LDR      r0,[r4,#0]            ;2414
00008a  68c0              LDR      r0,[r0,#0xc]          ;2414
00008c  9000              STR      r0,[sp,#0]            ;2414
00008e  6820              LDR      r0,[r4,#0]            ;2414
000090  6880              LDR      r0,[r0,#8]            ;2414
000092  9000              STR      r0,[sp,#0]            ;2414
000094  bf00              NOP                            ;2414
000096  bf00              NOP                            ;2414
000098  e7c4              B        |L11.36|
                  |L11.154|
00009a  f3c51040          UBFX     r0,r5,#5,#1           ;2420
00009e  b188              CBZ      r0,|L11.196|
0000a0  6d60              LDR      r0,[r4,#0x54]         ;2422
0000a2  f0400001          ORR      r0,r0,#1              ;2422
0000a6  6560              STR      r0,[r4,#0x54]         ;2422
0000a8  bf00              NOP                            ;2423
0000aa  2000              MOVS     r0,#0                 ;2423
0000ac  9000              STR      r0,[sp,#0]            ;2423
0000ae  6820              LDR      r0,[r4,#0]            ;2423
0000b0  6880              LDR      r0,[r0,#8]            ;2423
0000b2  9000              STR      r0,[sp,#0]            ;2423
0000b4  6820              LDR      r0,[r4,#0]            ;2423
0000b6  6800              LDR      r0,[r0,#0]            ;2423
0000b8  f0200040          BIC      r0,r0,#0x40           ;2423
0000bc  6821              LDR      r1,[r4,#0]            ;2423
0000be  6008              STR      r0,[r1,#0]            ;2423
0000c0  bf00              NOP                            ;2423
0000c2  bf00              NOP                            ;2423
                  |L11.196|
0000c4  f3c52000          UBFX     r0,r5,#8,#1           ;2427
0000c8  b158              CBZ      r0,|L11.226|
0000ca  6d60              LDR      r0,[r4,#0x54]         ;2429
0000cc  f0400008          ORR      r0,r0,#8              ;2429
0000d0  6560              STR      r0,[r4,#0x54]         ;2429
0000d2  bf00              NOP                            ;2430
0000d4  2000              MOVS     r0,#0                 ;2430
0000d6  9000              STR      r0,[sp,#0]            ;2430
0000d8  6820              LDR      r0,[r4,#0]            ;2430
0000da  6880              LDR      r0,[r0,#8]            ;2430
0000dc  9000              STR      r0,[sp,#0]            ;2430
0000de  bf00              NOP                            ;2430
0000e0  bf00              NOP                            ;2430
                  |L11.226|
0000e2  6d60              LDR      r0,[r4,#0x54]         ;2433
0000e4  b378              CBZ      r0,|L11.326|
0000e6  6820              LDR      r0,[r4,#0]            ;2436
0000e8  6840              LDR      r0,[r0,#4]            ;2436
0000ea  f02000e0          BIC      r0,r0,#0xe0           ;2436
0000ee  6821              LDR      r1,[r4,#0]            ;2436
0000f0  6048              STR      r0,[r1,#4]            ;2436
0000f2  2001              MOVS     r0,#1                 ;2438
0000f4  f8840051          STRB     r0,[r4,#0x51]         ;2438
0000f8  f0060002          AND      r0,r6,#2              ;2440
0000fc  2802              CMP      r0,#2                 ;2440
0000fe  d002              BEQ      |L11.262|
000100  f0060001          AND      r0,r6,#1              ;2440
000104  b308              CBZ      r0,|L11.330|
                  |L11.262|
000106  6820              LDR      r0,[r4,#0]            ;2442
000108  6840              LDR      r0,[r0,#4]            ;2442
00010a  f0200003          BIC      r0,r0,#3              ;2442
00010e  6821              LDR      r1,[r4,#0]            ;2442
000110  6048              STR      r0,[r1,#4]            ;2442
000112  6ce0              LDR      r0,[r4,#0x4c]         ;2445
000114  b150              CBZ      r0,|L11.300|
000116  4810              LDR      r0,|L11.344|
000118  6ce1              LDR      r1,[r4,#0x4c]         ;2449
00011a  6508              STR      r0,[r1,#0x50]         ;2449
00011c  6ce0              LDR      r0,[r4,#0x4c]         ;2450
00011e  f7fffffe          BL       HAL_DMA_Abort_IT
000122  b118              CBZ      r0,|L11.300|
000124  6d60              LDR      r0,[r4,#0x54]         ;2452
000126  f0400040          ORR      r0,r0,#0x40           ;2452
00012a  6560              STR      r0,[r4,#0x54]         ;2452
                  |L11.300|
00012c  6ca0              LDR      r0,[r4,#0x48]         ;2456
00012e  b150              CBZ      r0,|L11.326|
000130  4809              LDR      r0,|L11.344|
000132  6ca1              LDR      r1,[r4,#0x48]         ;2460
000134  6508              STR      r0,[r1,#0x50]         ;2460
000136  6ca0              LDR      r0,[r4,#0x48]         ;2461
000138  f7fffffe          BL       HAL_DMA_Abort_IT
00013c  b118              CBZ      r0,|L11.326|
00013e  6d60              LDR      r0,[r4,#0x54]         ;2463
000140  f0400040          ORR      r0,r0,#0x40           ;2463
000144  6560              STR      r0,[r4,#0x54]         ;2463
                  |L11.326|
000146  e003              B        |L11.336|
                  |L11.328|
000148  e003              B        |L11.338|
                  |L11.330|
00014a  4620              MOV      r0,r4                 ;2473
00014c  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L11.336|
000150  e768              B        |L11.36|
                  |L11.338|
000152  bf00              NOP      
000154  e766              B        |L11.36|
;;;2480   
                          ENDP

000156  0000              DCW      0x0000
                  |L11.344|
                          DCD      SPI_DMAAbortOnError

                          AREA ||i.HAL_SPI_Init||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Init PROC
;;;312      */
;;;313    HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;314    {
000002  4604              MOV      r4,r0
;;;315      /* Check the SPI handle allocation */
;;;316      if (hspi == NULL)
000004  b90c              CBNZ     r4,|L12.10|
;;;317      {
;;;318        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L12.8|
;;;319      }
;;;320    
;;;321      /* Check the parameters */
;;;322      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;323      assert_param(IS_SPI_MODE(hspi->Init.Mode));
;;;324      assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
;;;325      assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
;;;326      assert_param(IS_SPI_NSS(hspi->Init.NSS));
;;;327      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;328      assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
;;;329      assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
;;;330      if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
;;;331      {
;;;332        assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
;;;333        assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
;;;334    
;;;335        if (hspi->Init.Mode == SPI_MODE_MASTER)
;;;336        {
;;;337          assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;338        }
;;;339        else
;;;340        {
;;;341          /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
;;;342          hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
;;;343        }
;;;344      }
;;;345      else
;;;346      {
;;;347        assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;348    
;;;349        /* Force polarity and phase to TI protocaol requirements */
;;;350        hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
;;;351        hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
;;;352      }
;;;353    #if (USE_SPI_CRC != 0U)
;;;354      assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
;;;355      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;356      {
;;;357        assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
;;;358      }
;;;359    #else
;;;360      hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
;;;361    #endif /* USE_SPI_CRC */
;;;362    
;;;363      if (hspi->State == HAL_SPI_STATE_RESET)
;;;364      {
;;;365        /* Allocate lock resource and initialize it */
;;;366        hspi->Lock = HAL_UNLOCKED;
;;;367    
;;;368    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;369        /* Init the SPI Callback settings */
;;;370        hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
;;;371        hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
;;;372        hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */
;;;373        hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
;;;374        hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */
;;;375        hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
;;;376        hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */
;;;377        hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
;;;378    
;;;379        if (hspi->MspInitCallback == NULL)
;;;380        {
;;;381          hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */
;;;382        }
;;;383    
;;;384        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;385        hspi->MspInitCallback(hspi);
;;;386    #else
;;;387        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;388        HAL_SPI_MspInit(hspi);
;;;389    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;390      }
;;;391    
;;;392      hspi->State = HAL_SPI_STATE_BUSY;
;;;393    
;;;394      /* Disable the selected SPI peripheral */
;;;395      __HAL_SPI_DISABLE(hspi);
;;;396    
;;;397      /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
;;;398      /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
;;;399      Communication speed, First bit and CRC calculation state */
;;;400      WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
;;;401                                      (hspi->Init.Direction & (SPI_CR1_RXONLY | SPI_CR1_BIDIMODE)) |
;;;402                                      (hspi->Init.DataSize & SPI_CR1_DFF) |
;;;403                                      (hspi->Init.CLKPolarity & SPI_CR1_CPOL) |
;;;404                                      (hspi->Init.CLKPhase & SPI_CR1_CPHA) |
;;;405                                      (hspi->Init.NSS & SPI_CR1_SSM) |
;;;406                                      (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
;;;407                                      (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
;;;408                                      (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));
;;;409    
;;;410      /* Configure : NSS management, TI Mode */
;;;411      WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
;;;412    
;;;413    #if (USE_SPI_CRC != 0U)
;;;414      /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
;;;415      /* Configure : CRC Polynomial */
;;;416      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;417      {
;;;418        WRITE_REG(hspi->Instance->CRCPR, (hspi->Init.CRCPolynomial & SPI_CRCPR_CRCPOLY_Msk));
;;;419      }
;;;420    #endif /* USE_SPI_CRC */
;;;421    
;;;422    #if defined(SPI_I2SCFGR_I2SMOD)
;;;423      /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
;;;424      CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
;;;425    #endif /* SPI_I2SCFGR_I2SMOD */
;;;426    
;;;427      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;428      hspi->State     = HAL_SPI_STATE_READY;
;;;429    
;;;430      return HAL_OK;
;;;431    }
000008  bd10              POP      {r4,pc}
                  |L12.10|
00000a  6a60              LDR      r0,[r4,#0x24]         ;330
00000c  b938              CBNZ     r0,|L12.30|
00000e  6860              LDR      r0,[r4,#4]            ;335
000010  f5b07f82          CMP      r0,#0x104             ;335
000014  d100              BNE      |L12.24|
000016  e005              B        |L12.36|
                  |L12.24|
000018  2100              MOVS     r1,#0                 ;342
00001a  61e1              STR      r1,[r4,#0x1c]         ;342
00001c  e002              B        |L12.36|
                  |L12.30|
00001e  2100              MOVS     r1,#0                 ;350
000020  6121              STR      r1,[r4,#0x10]         ;350
000022  6161              STR      r1,[r4,#0x14]         ;351
                  |L12.36|
000024  2100              MOVS     r1,#0                 ;360
000026  62a1              STR      r1,[r4,#0x28]         ;360
000028  f8940051          LDRB     r0,[r4,#0x51]         ;363
00002c  b928              CBNZ     r0,|L12.58|
00002e  2000              MOVS     r0,#0                 ;366
000030  f8840050          STRB     r0,[r4,#0x50]         ;366
000034  4620              MOV      r0,r4                 ;388
000036  f7fffffe          BL       HAL_SPI_MspInit
                  |L12.58|
00003a  2002              MOVS     r0,#2                 ;392
00003c  f8840051          STRB     r0,[r4,#0x51]         ;392
000040  6820              LDR      r0,[r4,#0]            ;395
000042  6800              LDR      r0,[r0,#0]            ;395
000044  f0200040          BIC      r0,r0,#0x40           ;395
000048  6821              LDR      r1,[r4,#0]            ;395
00004a  6008              STR      r0,[r1,#0]            ;395
00004c  88a0              LDRH     r0,[r4,#4]            ;400
00004e  f4007082          AND      r0,r0,#0x104          ;400
000052  8921              LDRH     r1,[r4,#8]            ;400
000054  f4014104          AND      r1,r1,#0x8400         ;400
000058  4308              ORRS     r0,r0,r1              ;400
00005a  89a1              LDRH     r1,[r4,#0xc]          ;400
00005c  f4016100          AND      r1,r1,#0x800          ;400
000060  4308              ORRS     r0,r0,r1              ;400
000062  7c21              LDRB     r1,[r4,#0x10]         ;400
000064  f0010102          AND      r1,r1,#2              ;400
000068  4308              ORRS     r0,r0,r1              ;400
00006a  7d21              LDRB     r1,[r4,#0x14]         ;400
00006c  f0010101          AND      r1,r1,#1              ;400
000070  4308              ORRS     r0,r0,r1              ;400
000072  8b21              LDRH     r1,[r4,#0x18]         ;400
000074  f4017100          AND      r1,r1,#0x200          ;400
000078  4308              ORRS     r0,r0,r1              ;400
00007a  7f21              LDRB     r1,[r4,#0x1c]         ;400
00007c  f0010138          AND      r1,r1,#0x38           ;400
000080  4308              ORRS     r0,r0,r1              ;400
000082  2120              MOVS     r1,#0x20              ;400
000084  5d09              LDRB     r1,[r1,r4]            ;400
000086  f0010180          AND      r1,r1,#0x80           ;400
00008a  4308              ORRS     r0,r0,r1              ;400
00008c  8d21              LDRH     r1,[r4,#0x28]         ;400
00008e  f4015100          AND      r1,r1,#0x2000         ;400
000092  4308              ORRS     r0,r0,r1              ;400
000094  6821              LDR      r1,[r4,#0]            ;400
000096  6008              STR      r0,[r1,#0]            ;400
000098  2104              MOVS     r1,#4                 ;411
00009a  69a0              LDR      r0,[r4,#0x18]         ;411
00009c  ea014010          AND      r0,r1,r0,LSR #16      ;411
0000a0  f8941024          LDRB     r1,[r4,#0x24]         ;411
0000a4  f0010110          AND      r1,r1,#0x10           ;411
0000a8  4308              ORRS     r0,r0,r1              ;411
0000aa  6821              LDR      r1,[r4,#0]            ;411
0000ac  6048              STR      r0,[r1,#4]            ;411
0000ae  6820              LDR      r0,[r4,#0]            ;424
0000b0  69c0              LDR      r0,[r0,#0x1c]         ;424
0000b2  f4206000          BIC      r0,r0,#0x800          ;424
0000b6  6821              LDR      r1,[r4,#0]            ;424
0000b8  61c8              STR      r0,[r1,#0x1c]         ;424
0000ba  2000              MOVS     r0,#0                 ;427
0000bc  6560              STR      r0,[r4,#0x54]         ;427
0000be  2001              MOVS     r0,#1                 ;428
0000c0  f8840051          STRB     r0,[r4,#0x51]         ;428
0000c4  2000              MOVS     r0,#0                 ;430
0000c6  e79f              B        |L12.8|
;;;432    
                          ENDP


                          AREA ||i.HAL_SPI_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspDeInit PROC
;;;498      */
;;;499    __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;500    {
;;;501      /* Prevent unused argument(s) compilation warning */
;;;502      UNUSED(hspi);
;;;503    
;;;504      /* NOTE : This function should not be modified, when the callback is needed,
;;;505                the HAL_SPI_MspDeInit should be implemented in the user file
;;;506       */
;;;507    }
;;;508    
                          ENDP


                          AREA ||i.HAL_SPI_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspInit PROC
;;;482      */
;;;483    __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;484    {
;;;485      /* Prevent unused argument(s) compilation warning */
;;;486      UNUSED(hspi);
;;;487    
;;;488      /* NOTE : This function should not be modified, when the callback is needed,
;;;489                the HAL_SPI_MspInit should be implemented in the user file
;;;490       */
;;;491    }
;;;492    
                          ENDP


                          AREA ||i.HAL_SPI_Receive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Receive PROC
;;;935      */
;;;936    HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;937    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;938    #if (USE_SPI_CRC != 0U)
;;;939      __IO uint32_t tmpreg = 0U;
;;;940    #endif /* USE_SPI_CRC */
;;;941      uint32_t tickstart;
;;;942      HAL_StatusTypeDef errorcode = HAL_OK;
00000c  f04f0900          MOV      r9,#0
;;;943    
;;;944      if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
000010  6860              LDR      r0,[r4,#4]
000012  f5b07f82          CMP      r0,#0x104
000016  d10d              BNE      |L15.52|
000018  68a0              LDR      r0,[r4,#8]
00001a  b958              CBNZ     r0,|L15.52|
;;;945      {
;;;946        hspi->State = HAL_SPI_STATE_BUSY_RX;
00001c  2004              MOVS     r0,#4
00001e  f8840051          STRB     r0,[r4,#0x51]
;;;947        /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;948        return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
000022  4633              MOV      r3,r6
000024  4642              MOV      r2,r8
000026  4641              MOV      r1,r8
000028  4620              MOV      r0,r4
00002a  9500              STR      r5,[sp,#0]
00002c  f7fffffe          BL       HAL_SPI_TransmitReceive
                  |L15.48|
;;;949      }
;;;950    
;;;951      /* Process Locked */
;;;952      __HAL_LOCK(hspi);
;;;953    
;;;954      /* Init tickstart for timeout management*/
;;;955      tickstart = HAL_GetTick();
;;;956    
;;;957      if (hspi->State != HAL_SPI_STATE_READY)
;;;958      {
;;;959        errorcode = HAL_BUSY;
;;;960        goto error;
;;;961      }
;;;962    
;;;963      if ((pData == NULL) || (Size == 0U))
;;;964      {
;;;965        errorcode = HAL_ERROR;
;;;966        goto error;
;;;967      }
;;;968    
;;;969      /* Set the transaction information */
;;;970      hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;971      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;972      hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;973      hspi->RxXferSize  = Size;
;;;974      hspi->RxXferCount = Size;
;;;975    
;;;976      /*Init field not used in handle to zero */
;;;977      hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;978      hspi->TxXferSize  = 0U;
;;;979      hspi->TxXferCount = 0U;
;;;980      hspi->RxISR       = NULL;
;;;981      hspi->TxISR       = NULL;
;;;982    
;;;983    #if (USE_SPI_CRC != 0U)
;;;984      /* Reset CRC Calculation */
;;;985      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;986      {
;;;987        SPI_RESET_CRC(hspi);
;;;988        /* this is done to handle the CRCNEXT before the latest data */
;;;989        hspi->RxXferCount--;
;;;990      }
;;;991    #endif /* USE_SPI_CRC */
;;;992    
;;;993      /* Configure communication direction: 1Line */
;;;994      if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;995      {
;;;996        /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;997        __HAL_SPI_DISABLE(hspi);
;;;998        SPI_1LINE_RX(hspi);
;;;999      }
;;;1000   
;;;1001     /* Check if the SPI is already enabled */
;;;1002     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1003     {
;;;1004       /* Enable SPI peripheral */
;;;1005       __HAL_SPI_ENABLE(hspi);
;;;1006     }
;;;1007   
;;;1008     /* Receive data in 8 Bit mode */
;;;1009     if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
;;;1010     {
;;;1011       /* Transfer loop */
;;;1012       while (hspi->RxXferCount > 0U)
;;;1013       {
;;;1014         /* Check the RXNE flag */
;;;1015         if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;1016         {
;;;1017           /* read the received data */
;;;1018           (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1019           hspi->pRxBuffPtr += sizeof(uint8_t);
;;;1020           hspi->RxXferCount--;
;;;1021         }
;;;1022         else
;;;1023         {
;;;1024           /* Timeout management */
;;;1025           if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;1026           {
;;;1027             errorcode = HAL_TIMEOUT;
;;;1028             goto error;
;;;1029           }
;;;1030         }
;;;1031       }
;;;1032     }
;;;1033     else
;;;1034     {
;;;1035       /* Transfer loop */
;;;1036       while (hspi->RxXferCount > 0U)
;;;1037       {
;;;1038         /* Check the RXNE flag */
;;;1039         if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;1040         {
;;;1041           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1042           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1043           hspi->RxXferCount--;
;;;1044         }
;;;1045         else
;;;1046         {
;;;1047           /* Timeout management */
;;;1048           if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;1049           {
;;;1050             errorcode = HAL_TIMEOUT;
;;;1051             goto error;
;;;1052           }
;;;1053         }
;;;1054       }
;;;1055     }
;;;1056   
;;;1057   #if (USE_SPI_CRC != 0U)
;;;1058     /* Handle the CRC Transmission */
;;;1059     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1060     {
;;;1061       /* freeze the CRC before the latest data */
;;;1062       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1063   
;;;1064       /* Read the latest data */
;;;1065       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1066       {
;;;1067         /* the latest data has not been received */
;;;1068         errorcode = HAL_TIMEOUT;
;;;1069         goto error;
;;;1070       }
;;;1071   
;;;1072       /* Receive last data in 16 Bit mode */
;;;1073       if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1074       {
;;;1075         *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1076       }
;;;1077       /* Receive last data in 8 Bit mode */
;;;1078       else
;;;1079       {
;;;1080         (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1081       }
;;;1082   
;;;1083       /* Wait the CRC data */
;;;1084       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1085       {
;;;1086         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1087         errorcode = HAL_TIMEOUT;
;;;1088         goto error;
;;;1089       }
;;;1090   
;;;1091       /* Read CRC to Flush DR and RXNE flag */
;;;1092       tmpreg = READ_REG(hspi->Instance->DR);
;;;1093       /* To avoid GCC warning */
;;;1094       UNUSED(tmpreg);
;;;1095     }
;;;1096   #endif /* USE_SPI_CRC */
;;;1097   
;;;1098     /* Check the end of the transaction */
;;;1099     if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1100     {
;;;1101       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1102     }
;;;1103   
;;;1104   #if (USE_SPI_CRC != 0U)
;;;1105     /* Check if CRC error occurred */
;;;1106     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
;;;1107     {
;;;1108       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1109       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1110     }
;;;1111   #endif /* USE_SPI_CRC */
;;;1112   
;;;1113     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;1114     {
;;;1115       errorcode = HAL_ERROR;
;;;1116     }
;;;1117   
;;;1118   error :
;;;1119     hspi->State = HAL_SPI_STATE_READY;
;;;1120     __HAL_UNLOCK(hspi);
;;;1121     return errorcode;
;;;1122   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L15.52|
000034  bf00              NOP                            ;952
000036  f8940050          LDRB     r0,[r4,#0x50]         ;952
00003a  2801              CMP      r0,#1                 ;952
00003c  d101              BNE      |L15.66|
00003e  2002              MOVS     r0,#2                 ;952
000040  e7f6              B        |L15.48|
                  |L15.66|
000042  2001              MOVS     r0,#1                 ;952
000044  f8840050          STRB     r0,[r4,#0x50]         ;952
000048  bf00              NOP                            ;952
00004a  f7fffffe          BL       HAL_GetTick
00004e  4607              MOV      r7,r0                 ;955
000050  f8940051          LDRB     r0,[r4,#0x51]         ;957
000054  2801              CMP      r0,#1                 ;957
000056  d002              BEQ      |L15.94|
000058  f04f0902          MOV      r9,#2                 ;959
00005c  e07e              B        |L15.348|
                  |L15.94|
00005e  f1b80f00          CMP      r8,#0                 ;963
000062  d000              BEQ      |L15.102|
000064  b916              CBNZ     r6,|L15.108|
                  |L15.102|
000066  f04f0901          MOV      r9,#1                 ;965
00006a  e077              B        |L15.348|
                  |L15.108|
00006c  2004              MOVS     r0,#4                 ;970
00006e  f8840051          STRB     r0,[r4,#0x51]         ;970
000072  2000              MOVS     r0,#0                 ;971
000074  6560              STR      r0,[r4,#0x54]         ;971
000076  f8c48038          STR      r8,[r4,#0x38]         ;972
00007a  87a6              STRH     r6,[r4,#0x3c]         ;973
00007c  87e6              STRH     r6,[r4,#0x3e]         ;974
00007e  6320              STR      r0,[r4,#0x30]         ;977
000080  86a0              STRH     r0,[r4,#0x34]         ;978
000082  86e0              STRH     r0,[r4,#0x36]         ;979
000084  6420              STR      r0,[r4,#0x40]         ;980
000086  6460              STR      r0,[r4,#0x44]         ;981
000088  68a0              LDR      r0,[r4,#8]            ;994
00008a  f5b04f00          CMP      r0,#0x8000            ;994
00008e  d10b              BNE      |L15.168|
000090  6820              LDR      r0,[r4,#0]            ;997
000092  6800              LDR      r0,[r0,#0]            ;997
000094  f0200040          BIC      r0,r0,#0x40           ;997
000098  6821              LDR      r1,[r4,#0]            ;997
00009a  6008              STR      r0,[r1,#0]            ;997
00009c  6820              LDR      r0,[r4,#0]            ;998
00009e  6800              LDR      r0,[r0,#0]            ;998
0000a0  f4204080          BIC      r0,r0,#0x4000         ;998
0000a4  6821              LDR      r1,[r4,#0]            ;998
0000a6  6008              STR      r0,[r1,#0]            ;998
                  |L15.168|
0000a8  6820              LDR      r0,[r4,#0]            ;1002
0000aa  6800              LDR      r0,[r0,#0]            ;1002
0000ac  f0000040          AND      r0,r0,#0x40           ;1002
0000b0  2840              CMP      r0,#0x40              ;1002
0000b2  d005              BEQ      |L15.192|
0000b4  6820              LDR      r0,[r4,#0]            ;1005
0000b6  6800              LDR      r0,[r0,#0]            ;1005
0000b8  f0400040          ORR      r0,r0,#0x40           ;1005
0000bc  6821              LDR      r1,[r4,#0]            ;1005
0000be  6008              STR      r0,[r1,#0]            ;1005
                  |L15.192|
0000c0  68e0              LDR      r0,[r4,#0xc]          ;1009
0000c2  b9f8              CBNZ     r0,|L15.260|
0000c4  e01a              B        |L15.252|
                  |L15.198|
0000c6  6820              LDR      r0,[r4,#0]            ;1015
0000c8  6880              LDR      r0,[r0,#8]            ;1015
0000ca  f0000001          AND      r0,r0,#1              ;1015
0000ce  b150              CBZ      r0,|L15.230|
0000d0  6820              LDR      r0,[r4,#0]            ;1018
0000d2  7b00              LDRB     r0,[r0,#0xc]          ;1018
0000d4  6ba1              LDR      r1,[r4,#0x38]         ;1018
0000d6  7008              STRB     r0,[r1,#0]            ;1018
0000d8  6ba0              LDR      r0,[r4,#0x38]         ;1019
0000da  1c40              ADDS     r0,r0,#1              ;1019
0000dc  63a0              STR      r0,[r4,#0x38]         ;1019
0000de  8fe0              LDRH     r0,[r4,#0x3e]         ;1020
0000e0  1e40              SUBS     r0,r0,#1              ;1020
0000e2  87e0              STRH     r0,[r4,#0x3e]         ;1020
0000e4  e00a              B        |L15.252|
                  |L15.230|
0000e6  f7fffffe          BL       HAL_GetTick
0000ea  1bc0              SUBS     r0,r0,r7              ;1025
0000ec  42a8              CMP      r0,r5                 ;1025
0000ee  d301              BCC      |L15.244|
0000f0  1c68              ADDS     r0,r5,#1              ;1025
0000f2  b900              CBNZ     r0,|L15.246|
                  |L15.244|
0000f4  b915              CBNZ     r5,|L15.252|
                  |L15.246|
0000f6  f04f0903          MOV      r9,#3                 ;1027
0000fa  e02f              B        |L15.348|
                  |L15.252|
0000fc  8fe0              LDRH     r0,[r4,#0x3e]         ;1012
0000fe  2800              CMP      r0,#0                 ;1012
000100  d1e1              BNE      |L15.198|
000102  e01e              B        |L15.322|
                  |L15.260|
000104  e01a              B        |L15.316|
                  |L15.262|
000106  6820              LDR      r0,[r4,#0]            ;1039
000108  6880              LDR      r0,[r0,#8]            ;1039
00010a  f0000001          AND      r0,r0,#1              ;1039
00010e  b150              CBZ      r0,|L15.294|
000110  6820              LDR      r0,[r4,#0]            ;1041
000112  68c0              LDR      r0,[r0,#0xc]          ;1041
000114  6ba1              LDR      r1,[r4,#0x38]         ;1041
000116  8008              STRH     r0,[r1,#0]            ;1041
000118  6ba0              LDR      r0,[r4,#0x38]         ;1042
00011a  1c80              ADDS     r0,r0,#2              ;1042
00011c  63a0              STR      r0,[r4,#0x38]         ;1042
00011e  8fe0              LDRH     r0,[r4,#0x3e]         ;1043
000120  1e40              SUBS     r0,r0,#1              ;1043
000122  87e0              STRH     r0,[r4,#0x3e]         ;1043
000124  e00a              B        |L15.316|
                  |L15.294|
000126  f7fffffe          BL       HAL_GetTick
00012a  1bc0              SUBS     r0,r0,r7              ;1048
00012c  42a8              CMP      r0,r5                 ;1048
00012e  d301              BCC      |L15.308|
000130  1c68              ADDS     r0,r5,#1              ;1048
000132  b900              CBNZ     r0,|L15.310|
                  |L15.308|
000134  b915              CBNZ     r5,|L15.316|
                  |L15.310|
000136  f04f0903          MOV      r9,#3                 ;1050
00013a  e00f              B        |L15.348|
                  |L15.316|
00013c  8fe0              LDRH     r0,[r4,#0x3e]         ;1036
00013e  2800              CMP      r0,#0                 ;1036
000140  d1e1              BNE      |L15.262|
                  |L15.322|
000142  463a              MOV      r2,r7                 ;1099
000144  4629              MOV      r1,r5                 ;1099
000146  4620              MOV      r0,r4                 ;1099
000148  f7fffffe          BL       SPI_EndRxTransaction
00014c  b108              CBZ      r0,|L15.338|
00014e  2020              MOVS     r0,#0x20              ;1101
000150  6560              STR      r0,[r4,#0x54]         ;1101
                  |L15.338|
000152  6d60              LDR      r0,[r4,#0x54]         ;1113
000154  b108              CBZ      r0,|L15.346|
000156  f04f0901          MOV      r9,#1                 ;1115
                  |L15.346|
00015a  bf00              NOP                            ;1118
                  |L15.348|
00015c  2001              MOVS     r0,#1                 ;1119
00015e  f8840051          STRB     r0,[r4,#0x51]         ;1119
000162  bf00              NOP                            ;1120
000164  2000              MOVS     r0,#0                 ;1120
000166  f8840050          STRB     r0,[r4,#0x50]         ;1120
00016a  bf00              NOP                            ;1120
00016c  4648              MOV      r0,r9                 ;1121
00016e  e75f              B        |L15.48|
;;;1123   
                          ENDP


                          AREA ||i.HAL_SPI_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_DMA PROC
;;;1732     */
;;;1733   HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1734   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1735     HAL_StatusTypeDef errorcode = HAL_OK;
00000a  2700              MOVS     r7,#0
;;;1736   
;;;1737     /* Check rx dma handle */
;;;1738     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
;;;1739   
;;;1740     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
00000c  68a0              LDR      r0,[r4,#8]
00000e  b970              CBNZ     r0,|L16.46|
000010  6860              LDR      r0,[r4,#4]
000012  f5b07f82          CMP      r0,#0x104
000016  d10a              BNE      |L16.46|
;;;1741     {
;;;1742       hspi->State = HAL_SPI_STATE_BUSY_RX;
000018  2004              MOVS     r0,#4
00001a  f8840051          STRB     r0,[r4,#0x51]
;;;1743   
;;;1744       /* Check tx dma handle */
;;;1745       assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1746   
;;;1747       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1748       return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
00001e  462b              MOV      r3,r5
000020  4632              MOV      r2,r6
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_SPI_TransmitReceive_DMA
                  |L16.42|
;;;1749     }
;;;1750   
;;;1751     /* Process Locked */
;;;1752     __HAL_LOCK(hspi);
;;;1753   
;;;1754     if (hspi->State != HAL_SPI_STATE_READY)
;;;1755     {
;;;1756       errorcode = HAL_BUSY;
;;;1757       goto error;
;;;1758     }
;;;1759   
;;;1760     if ((pData == NULL) || (Size == 0U))
;;;1761     {
;;;1762       errorcode = HAL_ERROR;
;;;1763       goto error;
;;;1764     }
;;;1765   
;;;1766     /* Set the transaction information */
;;;1767     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1768     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1769     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1770     hspi->RxXferSize  = Size;
;;;1771     hspi->RxXferCount = Size;
;;;1772   
;;;1773     /*Init field not used in handle to zero */
;;;1774     hspi->RxISR       = NULL;
;;;1775     hspi->TxISR       = NULL;
;;;1776     hspi->TxXferSize  = 0U;
;;;1777     hspi->TxXferCount = 0U;
;;;1778   
;;;1779     /* Configure communication direction : 1Line */
;;;1780     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1781     {
;;;1782       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1783       __HAL_SPI_DISABLE(hspi);
;;;1784       SPI_1LINE_RX(hspi);
;;;1785     }
;;;1786   
;;;1787   #if (USE_SPI_CRC != 0U)
;;;1788     /* Reset CRC Calculation */
;;;1789     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1790     {
;;;1791       SPI_RESET_CRC(hspi);
;;;1792     }
;;;1793   #endif /* USE_SPI_CRC */
;;;1794   
;;;1795     /* Set the SPI RxDMA Half transfer complete callback */
;;;1796     hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1797   
;;;1798     /* Set the SPI Rx DMA transfer complete callback */
;;;1799     hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
;;;1800   
;;;1801     /* Set the DMA error callback */
;;;1802     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1803   
;;;1804     /* Set the DMA AbortCpltCallback */
;;;1805     hspi->hdmarx->XferAbortCallback = NULL;
;;;1806   
;;;1807     /* Enable the Rx DMA Stream/Channel  */
;;;1808     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
;;;1809                                    hspi->RxXferCount))
;;;1810     {
;;;1811       /* Update SPI error code */
;;;1812       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1813       errorcode = HAL_ERROR;
;;;1814   
;;;1815       hspi->State = HAL_SPI_STATE_READY;
;;;1816       goto error;
;;;1817     }
;;;1818   
;;;1819     /* Check if the SPI is already enabled */
;;;1820     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1821     {
;;;1822       /* Enable SPI peripheral */
;;;1823       __HAL_SPI_ENABLE(hspi);
;;;1824     }
;;;1825   
;;;1826     /* Enable the SPI Error Interrupt Bit */
;;;1827     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1828   
;;;1829     /* Enable Rx DMA Request */
;;;1830     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;1831   
;;;1832   error:
;;;1833     /* Process Unlocked */
;;;1834     __HAL_UNLOCK(hspi);
;;;1835     return errorcode;
;;;1836   }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.46|
00002e  bf00              NOP                            ;1752
000030  f8940050          LDRB     r0,[r4,#0x50]         ;1752
000034  2801              CMP      r0,#1                 ;1752
000036  d101              BNE      |L16.60|
000038  2002              MOVS     r0,#2                 ;1752
00003a  e7f6              B        |L16.42|
                  |L16.60|
00003c  2001              MOVS     r0,#1                 ;1752
00003e  f8840050          STRB     r0,[r4,#0x50]         ;1752
000042  bf00              NOP                            ;1752
000044  f8940051          LDRB     r0,[r4,#0x51]         ;1754
000048  2801              CMP      r0,#1                 ;1754
00004a  d001              BEQ      |L16.80|
00004c  2702              MOVS     r7,#2                 ;1756
00004e  e057              B        |L16.256|
                  |L16.80|
000050  b106              CBZ      r6,|L16.84|
000052  b90d              CBNZ     r5,|L16.88|
                  |L16.84|
000054  2701              MOVS     r7,#1                 ;1762
000056  e053              B        |L16.256|
                  |L16.88|
000058  2004              MOVS     r0,#4                 ;1767
00005a  f8840051          STRB     r0,[r4,#0x51]         ;1767
00005e  2000              MOVS     r0,#0                 ;1768
000060  6560              STR      r0,[r4,#0x54]         ;1768
000062  63a6              STR      r6,[r4,#0x38]         ;1769
000064  87a5              STRH     r5,[r4,#0x3c]         ;1770
000066  87e5              STRH     r5,[r4,#0x3e]         ;1771
000068  6420              STR      r0,[r4,#0x40]         ;1774
00006a  6460              STR      r0,[r4,#0x44]         ;1775
00006c  86a0              STRH     r0,[r4,#0x34]         ;1776
00006e  86e0              STRH     r0,[r4,#0x36]         ;1777
000070  68a0              LDR      r0,[r4,#8]            ;1780
000072  f5b04f00          CMP      r0,#0x8000            ;1780
000076  d10b              BNE      |L16.144|
000078  6820              LDR      r0,[r4,#0]            ;1783
00007a  6800              LDR      r0,[r0,#0]            ;1783
00007c  f0200040          BIC      r0,r0,#0x40           ;1783
000080  6821              LDR      r1,[r4,#0]            ;1783
000082  6008              STR      r0,[r1,#0]            ;1783
000084  6820              LDR      r0,[r4,#0]            ;1784
000086  6800              LDR      r0,[r0,#0]            ;1784
000088  f4204080          BIC      r0,r0,#0x4000         ;1784
00008c  6821              LDR      r1,[r4,#0]            ;1784
00008e  6008              STR      r0,[r1,#0]            ;1784
                  |L16.144|
000090  481f              LDR      r0,|L16.272|
000092  6ce1              LDR      r1,[r4,#0x4c]         ;1796
000094  6408              STR      r0,[r1,#0x40]         ;1796
000096  481f              LDR      r0,|L16.276|
000098  6ce1              LDR      r1,[r4,#0x4c]         ;1799
00009a  63c8              STR      r0,[r1,#0x3c]         ;1799
00009c  481e              LDR      r0,|L16.280|
00009e  6ce1              LDR      r1,[r4,#0x4c]         ;1802
0000a0  64c8              STR      r0,[r1,#0x4c]         ;1802
0000a2  2000              MOVS     r0,#0                 ;1805
0000a4  6ce1              LDR      r1,[r4,#0x4c]         ;1805
0000a6  6508              STR      r0,[r1,#0x50]         ;1805
0000a8  8fe3              LDRH     r3,[r4,#0x3e]         ;1808
0000aa  f8d4c000          LDR      r12,[r4,#0]           ;1808
0000ae  f10c010c          ADD      r1,r12,#0xc           ;1808
0000b2  6ba2              LDR      r2,[r4,#0x38]         ;1808
0000b4  6ce0              LDR      r0,[r4,#0x4c]         ;1808
0000b6  f7fffffe          BL       HAL_DMA_Start_IT
0000ba  b140              CBZ      r0,|L16.206|
0000bc  6d60              LDR      r0,[r4,#0x54]         ;1812
0000be  f0400010          ORR      r0,r0,#0x10           ;1812
0000c2  6560              STR      r0,[r4,#0x54]         ;1812
0000c4  2701              MOVS     r7,#1                 ;1813
0000c6  2001              MOVS     r0,#1                 ;1815
0000c8  f8840051          STRB     r0,[r4,#0x51]         ;1815
0000cc  e018              B        |L16.256|
                  |L16.206|
0000ce  6820              LDR      r0,[r4,#0]            ;1820
0000d0  6800              LDR      r0,[r0,#0]            ;1820
0000d2  f0000040          AND      r0,r0,#0x40           ;1820
0000d6  2840              CMP      r0,#0x40              ;1820
0000d8  d005              BEQ      |L16.230|
0000da  6820              LDR      r0,[r4,#0]            ;1823
0000dc  6800              LDR      r0,[r0,#0]            ;1823
0000de  f0400040          ORR      r0,r0,#0x40           ;1823
0000e2  6821              LDR      r1,[r4,#0]            ;1823
0000e4  6008              STR      r0,[r1,#0]            ;1823
                  |L16.230|
0000e6  6820              LDR      r0,[r4,#0]            ;1827
0000e8  6840              LDR      r0,[r0,#4]            ;1827
0000ea  f0400020          ORR      r0,r0,#0x20           ;1827
0000ee  6821              LDR      r1,[r4,#0]            ;1827
0000f0  6048              STR      r0,[r1,#4]            ;1827
0000f2  6820              LDR      r0,[r4,#0]            ;1830
0000f4  6840              LDR      r0,[r0,#4]            ;1830
0000f6  f0400001          ORR      r0,r0,#1              ;1830
0000fa  6821              LDR      r1,[r4,#0]            ;1830
0000fc  6048              STR      r0,[r1,#4]            ;1830
0000fe  bf00              NOP                            ;1832
                  |L16.256|
000100  bf00              NOP                            ;1834
000102  2000              MOVS     r0,#0                 ;1834
000104  f8840050          STRB     r0,[r4,#0x50]         ;1834
000108  bf00              NOP                            ;1834
00010a  4638              MOV      r0,r7                 ;1835
00010c  e78d              B        |L16.42|
;;;1837   
                          ENDP

00010e  0000              DCW      0x0000
                  |L16.272|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L16.276|
                          DCD      SPI_DMAReceiveCplt
                  |L16.280|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_IT PROC
;;;1442     */
;;;1443   HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1444   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1445     HAL_StatusTypeDef errorcode = HAL_OK;
000008  2700              MOVS     r7,#0
;;;1446   
;;;1447     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
00000a  68a0              LDR      r0,[r4,#8]
00000c  b968              CBNZ     r0,|L17.42|
00000e  6860              LDR      r0,[r4,#4]
000010  f5b07f82          CMP      r0,#0x104
000014  d109              BNE      |L17.42|
;;;1448     {
;;;1449       hspi->State = HAL_SPI_STATE_BUSY_RX;
000016  2004              MOVS     r0,#4
000018  f8840051          STRB     r0,[r4,#0x51]
;;;1450       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1451       return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
00001c  462b              MOV      r3,r5
00001e  4632              MOV      r2,r6
000020  4631              MOV      r1,r6
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_SPI_TransmitReceive_IT
                  |L17.40|
;;;1452     }
;;;1453   
;;;1454     /* Process Locked */
;;;1455     __HAL_LOCK(hspi);
;;;1456   
;;;1457     if (hspi->State != HAL_SPI_STATE_READY)
;;;1458     {
;;;1459       errorcode = HAL_BUSY;
;;;1460       goto error;
;;;1461     }
;;;1462   
;;;1463     if ((pData == NULL) || (Size == 0U))
;;;1464     {
;;;1465       errorcode = HAL_ERROR;
;;;1466       goto error;
;;;1467     }
;;;1468   
;;;1469     /* Set the transaction information */
;;;1470     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1471     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1472     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1473     hspi->RxXferSize  = Size;
;;;1474     hspi->RxXferCount = Size;
;;;1475   
;;;1476     /* Init field not used in handle to zero */
;;;1477     hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;1478     hspi->TxXferSize  = 0U;
;;;1479     hspi->TxXferCount = 0U;
;;;1480     hspi->TxISR       = NULL;
;;;1481   
;;;1482     /* Set the function for IT treatment */
;;;1483     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1484     {
;;;1485       hspi->RxISR = SPI_RxISR_16BIT;
;;;1486     }
;;;1487     else
;;;1488     {
;;;1489       hspi->RxISR = SPI_RxISR_8BIT;
;;;1490     }
;;;1491   
;;;1492     /* Configure communication direction : 1Line */
;;;1493     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1494     {
;;;1495       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1496       __HAL_SPI_DISABLE(hspi);
;;;1497       SPI_1LINE_RX(hspi);
;;;1498     }
;;;1499   
;;;1500   #if (USE_SPI_CRC != 0U)
;;;1501     /* Reset CRC Calculation */
;;;1502     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1503     {
;;;1504       SPI_RESET_CRC(hspi);
;;;1505     }
;;;1506   #endif /* USE_SPI_CRC */
;;;1507   
;;;1508     /* Enable TXE and ERR interrupt */
;;;1509     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
;;;1510   
;;;1511     /* Note : The SPI must be enabled after unlocking current process
;;;1512               to avoid the risk of SPI interrupt handle execution before current
;;;1513               process unlock */
;;;1514   
;;;1515     /* Check if the SPI is already enabled */
;;;1516     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1517     {
;;;1518       /* Enable SPI peripheral */
;;;1519       __HAL_SPI_ENABLE(hspi);
;;;1520     }
;;;1521   
;;;1522   error :
;;;1523     /* Process Unlocked */
;;;1524     __HAL_UNLOCK(hspi);
;;;1525     return errorcode;
;;;1526   }
000028  bdf0              POP      {r4-r7,pc}
                  |L17.42|
00002a  bf00              NOP                            ;1455
00002c  f8940050          LDRB     r0,[r4,#0x50]         ;1455
000030  2801              CMP      r0,#1                 ;1455
000032  d101              BNE      |L17.56|
000034  2002              MOVS     r0,#2                 ;1455
000036  e7f7              B        |L17.40|
                  |L17.56|
000038  2001              MOVS     r0,#1                 ;1455
00003a  f8840050          STRB     r0,[r4,#0x50]         ;1455
00003e  bf00              NOP                            ;1455
000040  f8940051          LDRB     r0,[r4,#0x51]         ;1457
000044  2801              CMP      r0,#1                 ;1457
000046  d001              BEQ      |L17.76|
000048  2702              MOVS     r7,#2                 ;1459
00004a  e039              B        |L17.192|
                  |L17.76|
00004c  b106              CBZ      r6,|L17.80|
00004e  b90d              CBNZ     r5,|L17.84|
                  |L17.80|
000050  2701              MOVS     r7,#1                 ;1465
000052  e035              B        |L17.192|
                  |L17.84|
000054  2004              MOVS     r0,#4                 ;1470
000056  f8840051          STRB     r0,[r4,#0x51]         ;1470
00005a  2000              MOVS     r0,#0                 ;1471
00005c  6560              STR      r0,[r4,#0x54]         ;1471
00005e  63a6              STR      r6,[r4,#0x38]         ;1472
000060  87a5              STRH     r5,[r4,#0x3c]         ;1473
000062  87e5              STRH     r5,[r4,#0x3e]         ;1474
000064  6320              STR      r0,[r4,#0x30]         ;1477
000066  86a0              STRH     r0,[r4,#0x34]         ;1478
000068  86e0              STRH     r0,[r4,#0x36]         ;1479
00006a  6460              STR      r0,[r4,#0x44]         ;1480
00006c  68e0              LDR      r0,[r4,#0xc]          ;1483
00006e  b110              CBZ      r0,|L17.118|
000070  4817              LDR      r0,|L17.208|
000072  6420              STR      r0,[r4,#0x40]         ;1485
000074  e001              B        |L17.122|
                  |L17.118|
000076  4817              LDR      r0,|L17.212|
000078  6420              STR      r0,[r4,#0x40]         ;1489
                  |L17.122|
00007a  68a0              LDR      r0,[r4,#8]            ;1493
00007c  f5b04f00          CMP      r0,#0x8000            ;1493
000080  d10b              BNE      |L17.154|
000082  6820              LDR      r0,[r4,#0]            ;1496
000084  6800              LDR      r0,[r0,#0]            ;1496
000086  f0200040          BIC      r0,r0,#0x40           ;1496
00008a  6821              LDR      r1,[r4,#0]            ;1496
00008c  6008              STR      r0,[r1,#0]            ;1496
00008e  6820              LDR      r0,[r4,#0]            ;1497
000090  6800              LDR      r0,[r0,#0]            ;1497
000092  f4204080          BIC      r0,r0,#0x4000         ;1497
000096  6821              LDR      r1,[r4,#0]            ;1497
000098  6008              STR      r0,[r1,#0]            ;1497
                  |L17.154|
00009a  6820              LDR      r0,[r4,#0]            ;1509
00009c  6840              LDR      r0,[r0,#4]            ;1509
00009e  f0400060          ORR      r0,r0,#0x60           ;1509
0000a2  6821              LDR      r1,[r4,#0]            ;1509
0000a4  6048              STR      r0,[r1,#4]            ;1509
0000a6  6820              LDR      r0,[r4,#0]            ;1516
0000a8  6800              LDR      r0,[r0,#0]            ;1516
0000aa  f0000040          AND      r0,r0,#0x40           ;1516
0000ae  2840              CMP      r0,#0x40              ;1516
0000b0  d005              BEQ      |L17.190|
0000b2  6820              LDR      r0,[r4,#0]            ;1519
0000b4  6800              LDR      r0,[r0,#0]            ;1519
0000b6  f0400040          ORR      r0,r0,#0x40           ;1519
0000ba  6821              LDR      r1,[r4,#0]            ;1519
0000bc  6008              STR      r0,[r1,#0]            ;1519
                  |L17.190|
0000be  bf00              NOP                            ;1522
                  |L17.192|
0000c0  bf00              NOP                            ;1524
0000c2  2000              MOVS     r0,#0                 ;1524
0000c4  f8840050          STRB     r0,[r4,#0x50]         ;1524
0000c8  bf00              NOP                            ;1524
0000ca  4638              MOV      r0,r7                 ;1525
0000cc  e7ac              B        |L17.40|
;;;1527   
                          ENDP

0000ce  0000              DCW      0x0000
                  |L17.208|
                          DCD      SPI_RxISR_16BIT
                  |L17.212|
                          DCD      SPI_RxISR_8BIT

                          AREA ||i.HAL_SPI_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxCpltCallback PROC
;;;2502     */
;;;2503   __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2504   {
;;;2505     /* Prevent unused argument(s) compilation warning */
;;;2506     UNUSED(hspi);
;;;2507   
;;;2508     /* NOTE : This function should not be modified, when the callback is needed,
;;;2509               the HAL_SPI_RxCpltCallback should be implemented in the user file
;;;2510      */
;;;2511   }
;;;2512   
                          ENDP


                          AREA ||i.HAL_SPI_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxHalfCpltCallback PROC
;;;2550     */
;;;2551   __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2552   {
;;;2553     /* Prevent unused argument(s) compilation warning */
;;;2554     UNUSED(hspi);
;;;2555   
;;;2556     /* NOTE : This function should not be modified, when the callback is needed,
;;;2557               the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
;;;2558      */
;;;2559   }
;;;2560   
                          ENDP


                          AREA ||i.HAL_SPI_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Transmit PROC
;;;770      */
;;;771    HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;772    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;773      uint32_t tickstart;
;;;774      HAL_StatusTypeDef errorcode = HAL_OK;
00000c  f04f0a00          MOV      r10,#0
;;;775      uint16_t initial_TxXferCount;
;;;776    
;;;777      /* Check Direction parameter */
;;;778      assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;779    
;;;780      /* Process Locked */
;;;781      __HAL_LOCK(hspi);
000010  bf00              NOP      
000012  f8940050          LDRB     r0,[r4,#0x50]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L20.32|
00001a  2002              MOVS     r0,#2
                  |L20.28|
;;;782    
;;;783      /* Init tickstart for timeout management*/
;;;784      tickstart = HAL_GetTick();
;;;785      initial_TxXferCount = Size;
;;;786    
;;;787      if (hspi->State != HAL_SPI_STATE_READY)
;;;788      {
;;;789        errorcode = HAL_BUSY;
;;;790        goto error;
;;;791      }
;;;792    
;;;793      if ((pData == NULL) || (Size == 0U))
;;;794      {
;;;795        errorcode = HAL_ERROR;
;;;796        goto error;
;;;797      }
;;;798    
;;;799      /* Set the transaction information */
;;;800      hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;801      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;802      hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;803      hspi->TxXferSize  = Size;
;;;804      hspi->TxXferCount = Size;
;;;805    
;;;806      /*Init field not used in handle to zero */
;;;807      hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;808      hspi->RxXferSize  = 0U;
;;;809      hspi->RxXferCount = 0U;
;;;810      hspi->TxISR       = NULL;
;;;811      hspi->RxISR       = NULL;
;;;812    
;;;813      /* Configure communication direction : 1Line */
;;;814      if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;815      {
;;;816        /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;817        __HAL_SPI_DISABLE(hspi);
;;;818        SPI_1LINE_TX(hspi);
;;;819      }
;;;820    
;;;821    #if (USE_SPI_CRC != 0U)
;;;822      /* Reset CRC Calculation */
;;;823      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;824      {
;;;825        SPI_RESET_CRC(hspi);
;;;826      }
;;;827    #endif /* USE_SPI_CRC */
;;;828    
;;;829      /* Check if the SPI is already enabled */
;;;830      if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;831      {
;;;832        /* Enable SPI peripheral */
;;;833        __HAL_SPI_ENABLE(hspi);
;;;834      }
;;;835    
;;;836      /* Transmit data in 16 Bit mode */
;;;837      if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;838      {
;;;839        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;840        {
;;;841          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;842          hspi->pTxBuffPtr += sizeof(uint16_t);
;;;843          hspi->TxXferCount--;
;;;844        }
;;;845        /* Transmit data in 16 Bit mode */
;;;846        while (hspi->TxXferCount > 0U)
;;;847        {
;;;848          /* Wait until TXE flag is set to send data */
;;;849          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;850          {
;;;851            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;852            hspi->pTxBuffPtr += sizeof(uint16_t);
;;;853            hspi->TxXferCount--;
;;;854          }
;;;855          else
;;;856          {
;;;857            /* Timeout management */
;;;858            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;859            {
;;;860              errorcode = HAL_TIMEOUT;
;;;861              goto error;
;;;862            }
;;;863          }
;;;864        }
;;;865      }
;;;866      /* Transmit data in 8 Bit mode */
;;;867      else
;;;868      {
;;;869        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;870        {
;;;871          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;872          hspi->pTxBuffPtr += sizeof(uint8_t);
;;;873          hspi->TxXferCount--;
;;;874        }
;;;875        while (hspi->TxXferCount > 0U)
;;;876        {
;;;877          /* Wait until TXE flag is set to send data */
;;;878          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;879          {
;;;880            *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;881            hspi->pTxBuffPtr += sizeof(uint8_t);
;;;882            hspi->TxXferCount--;
;;;883          }
;;;884          else
;;;885          {
;;;886            /* Timeout management */
;;;887            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;888            {
;;;889              errorcode = HAL_TIMEOUT;
;;;890              goto error;
;;;891            }
;;;892          }
;;;893        }
;;;894      }
;;;895    #if (USE_SPI_CRC != 0U)
;;;896      /* Enable CRC Transmission */
;;;897      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;898      {
;;;899        SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;900      }
;;;901    #endif /* USE_SPI_CRC */
;;;902    
;;;903      /* Check the end of the transaction */
;;;904      if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;905      {
;;;906        hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;907      }
;;;908    
;;;909      /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;910      if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;911      {
;;;912        __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;913      }
;;;914    
;;;915      if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;916      {
;;;917        errorcode = HAL_ERROR;
;;;918      }
;;;919    
;;;920    error:
;;;921      hspi->State = HAL_SPI_STATE_READY;
;;;922      /* Process Unlocked */
;;;923      __HAL_UNLOCK(hspi);
;;;924      return errorcode;
;;;925    }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.32|
000020  2001              MOVS     r0,#1                 ;781
000022  f8840050          STRB     r0,[r4,#0x50]         ;781
000026  bf00              NOP                            ;781
000028  f7fffffe          BL       HAL_GetTick
00002c  4607              MOV      r7,r0                 ;784
00002e  46b1              MOV      r9,r6                 ;785
000030  f8940051          LDRB     r0,[r4,#0x51]         ;787
000034  2801              CMP      r0,#1                 ;787
000036  d002              BEQ      |L20.62|
000038  f04f0a02          MOV      r10,#2                ;789
00003c  e0ad              B        |L20.410|
                  |L20.62|
00003e  f1b80f00          CMP      r8,#0                 ;793
000042  d000              BEQ      |L20.70|
000044  b916              CBNZ     r6,|L20.76|
                  |L20.70|
000046  f04f0a01          MOV      r10,#1                ;795
00004a  e0a6              B        |L20.410|
                  |L20.76|
00004c  2003              MOVS     r0,#3                 ;800
00004e  f8840051          STRB     r0,[r4,#0x51]         ;800
000052  2000              MOVS     r0,#0                 ;801
000054  6560              STR      r0,[r4,#0x54]         ;801
000056  f8c48030          STR      r8,[r4,#0x30]         ;802
00005a  86a6              STRH     r6,[r4,#0x34]         ;803
00005c  86e6              STRH     r6,[r4,#0x36]         ;804
00005e  63a0              STR      r0,[r4,#0x38]         ;807
000060  87a0              STRH     r0,[r4,#0x3c]         ;808
000062  87e0              STRH     r0,[r4,#0x3e]         ;809
000064  6460              STR      r0,[r4,#0x44]         ;810
000066  6420              STR      r0,[r4,#0x40]         ;811
000068  68a0              LDR      r0,[r4,#8]            ;814
00006a  f5b04f00          CMP      r0,#0x8000            ;814
00006e  d10b              BNE      |L20.136|
000070  6820              LDR      r0,[r4,#0]            ;817
000072  6800              LDR      r0,[r0,#0]            ;817
000074  f0200040          BIC      r0,r0,#0x40           ;817
000078  6821              LDR      r1,[r4,#0]            ;817
00007a  6008              STR      r0,[r1,#0]            ;817
00007c  6820              LDR      r0,[r4,#0]            ;818
00007e  6800              LDR      r0,[r0,#0]            ;818
000080  f4404080          ORR      r0,r0,#0x4000         ;818
000084  6821              LDR      r1,[r4,#0]            ;818
000086  6008              STR      r0,[r1,#0]            ;818
                  |L20.136|
000088  6820              LDR      r0,[r4,#0]            ;830
00008a  6800              LDR      r0,[r0,#0]            ;830
00008c  f0000040          AND      r0,r0,#0x40           ;830
000090  2840              CMP      r0,#0x40              ;830
000092  d005              BEQ      |L20.160|
000094  6820              LDR      r0,[r4,#0]            ;833
000096  6800              LDR      r0,[r0,#0]            ;833
000098  f0400040          ORR      r0,r0,#0x40           ;833
00009c  6821              LDR      r1,[r4,#0]            ;833
00009e  6008              STR      r0,[r1,#0]            ;833
                  |L20.160|
0000a0  68e0              LDR      r0,[r4,#0xc]          ;837
0000a2  f5b06f00          CMP      r0,#0x800             ;837
0000a6  d12f              BNE      |L20.264|
0000a8  6860              LDR      r0,[r4,#4]            ;839
0000aa  b110              CBZ      r0,|L20.178|
0000ac  f1b90f01          CMP      r9,#1                 ;839
0000b0  d109              BNE      |L20.198|
                  |L20.178|
0000b2  6b20              LDR      r0,[r4,#0x30]         ;841
0000b4  8800              LDRH     r0,[r0,#0]            ;841
0000b6  6821              LDR      r1,[r4,#0]            ;841
0000b8  60c8              STR      r0,[r1,#0xc]          ;841
0000ba  6b20              LDR      r0,[r4,#0x30]         ;842
0000bc  1c80              ADDS     r0,r0,#2              ;842
0000be  6320              STR      r0,[r4,#0x30]         ;842
0000c0  8ee0              LDRH     r0,[r4,#0x36]         ;843
0000c2  1e40              SUBS     r0,r0,#1              ;843
0000c4  86e0              STRH     r0,[r4,#0x36]         ;843
                  |L20.198|
0000c6  e01b              B        |L20.256|
                  |L20.200|
0000c8  6820              LDR      r0,[r4,#0]            ;849
0000ca  6880              LDR      r0,[r0,#8]            ;849
0000cc  f0000002          AND      r0,r0,#2              ;849
0000d0  2802              CMP      r0,#2                 ;849
0000d2  d10a              BNE      |L20.234|
0000d4  6b20              LDR      r0,[r4,#0x30]         ;851
0000d6  8800              LDRH     r0,[r0,#0]            ;851
0000d8  6821              LDR      r1,[r4,#0]            ;851
0000da  60c8              STR      r0,[r1,#0xc]          ;851
0000dc  6b20              LDR      r0,[r4,#0x30]         ;852
0000de  1c80              ADDS     r0,r0,#2              ;852
0000e0  6320              STR      r0,[r4,#0x30]         ;852
0000e2  8ee0              LDRH     r0,[r4,#0x36]         ;853
0000e4  1e40              SUBS     r0,r0,#1              ;853
0000e6  86e0              STRH     r0,[r4,#0x36]         ;853
0000e8  e00a              B        |L20.256|
                  |L20.234|
0000ea  f7fffffe          BL       HAL_GetTick
0000ee  1bc0              SUBS     r0,r0,r7              ;858
0000f0  42a8              CMP      r0,r5                 ;858
0000f2  d301              BCC      |L20.248|
0000f4  1c68              ADDS     r0,r5,#1              ;858
0000f6  b900              CBNZ     r0,|L20.250|
                  |L20.248|
0000f8  b915              CBNZ     r5,|L20.256|
                  |L20.250|
0000fa  f04f0a03          MOV      r10,#3                ;860
0000fe  e04c              B        |L20.410|
                  |L20.256|
000100  8ee0              LDRH     r0,[r4,#0x36]         ;846
000102  2800              CMP      r0,#0                 ;846
000104  d1e0              BNE      |L20.200|
000106  e02e              B        |L20.358|
                  |L20.264|
000108  6860              LDR      r0,[r4,#4]            ;869
00010a  b110              CBZ      r0,|L20.274|
00010c  f1b90f01          CMP      r9,#1                 ;869
000110  d109              BNE      |L20.294|
                  |L20.274|
000112  6b20              LDR      r0,[r4,#0x30]         ;871
000114  7800              LDRB     r0,[r0,#0]            ;871
000116  6821              LDR      r1,[r4,#0]            ;871
000118  7308              STRB     r0,[r1,#0xc]          ;871
00011a  6b20              LDR      r0,[r4,#0x30]         ;872
00011c  1c40              ADDS     r0,r0,#1              ;872
00011e  6320              STR      r0,[r4,#0x30]         ;872
000120  8ee0              LDRH     r0,[r4,#0x36]         ;873
000122  1e40              SUBS     r0,r0,#1              ;873
000124  86e0              STRH     r0,[r4,#0x36]         ;873
                  |L20.294|
000126  e01b              B        |L20.352|
                  |L20.296|
000128  6820              LDR      r0,[r4,#0]            ;878
00012a  6880              LDR      r0,[r0,#8]            ;878
00012c  f0000002          AND      r0,r0,#2              ;878
000130  2802              CMP      r0,#2                 ;878
000132  d10a              BNE      |L20.330|
000134  6b20              LDR      r0,[r4,#0x30]         ;880
000136  7800              LDRB     r0,[r0,#0]            ;880
000138  6821              LDR      r1,[r4,#0]            ;880
00013a  7308              STRB     r0,[r1,#0xc]          ;880
00013c  6b20              LDR      r0,[r4,#0x30]         ;881
00013e  1c40              ADDS     r0,r0,#1              ;881
000140  6320              STR      r0,[r4,#0x30]         ;881
000142  8ee0              LDRH     r0,[r4,#0x36]         ;882
000144  1e40              SUBS     r0,r0,#1              ;882
000146  86e0              STRH     r0,[r4,#0x36]         ;882
000148  e00a              B        |L20.352|
                  |L20.330|
00014a  f7fffffe          BL       HAL_GetTick
00014e  1bc0              SUBS     r0,r0,r7              ;887
000150  42a8              CMP      r0,r5                 ;887
000152  d301              BCC      |L20.344|
000154  1c68              ADDS     r0,r5,#1              ;887
000156  b900              CBNZ     r0,|L20.346|
                  |L20.344|
000158  b915              CBNZ     r5,|L20.352|
                  |L20.346|
00015a  f04f0a03          MOV      r10,#3                ;889
00015e  e01c              B        |L20.410|
                  |L20.352|
000160  8ee0              LDRH     r0,[r4,#0x36]         ;875
000162  2800              CMP      r0,#0                 ;875
000164  d1e0              BNE      |L20.296|
                  |L20.358|
000166  463a              MOV      r2,r7                 ;904
000168  4629              MOV      r1,r5                 ;904
00016a  4620              MOV      r0,r4                 ;904
00016c  f7fffffe          BL       SPI_EndRxTxTransaction
000170  b108              CBZ      r0,|L20.374|
000172  2020              MOVS     r0,#0x20              ;906
000174  6560              STR      r0,[r4,#0x54]         ;906
                  |L20.374|
000176  68a0              LDR      r0,[r4,#8]            ;910
000178  b950              CBNZ     r0,|L20.400|
00017a  bf00              NOP                            ;912
00017c  2000              MOVS     r0,#0                 ;912
00017e  9000              STR      r0,[sp,#0]            ;912
000180  6820              LDR      r0,[r4,#0]            ;912
000182  68c0              LDR      r0,[r0,#0xc]          ;912
000184  9000              STR      r0,[sp,#0]            ;912
000186  6820              LDR      r0,[r4,#0]            ;912
000188  6880              LDR      r0,[r0,#8]            ;912
00018a  9000              STR      r0,[sp,#0]            ;912
00018c  bf00              NOP                            ;912
00018e  bf00              NOP                            ;912
                  |L20.400|
000190  6d60              LDR      r0,[r4,#0x54]         ;915
000192  b108              CBZ      r0,|L20.408|
000194  f04f0a01          MOV      r10,#1                ;917
                  |L20.408|
000198  bf00              NOP                            ;920
                  |L20.410|
00019a  2001              MOVS     r0,#1                 ;921
00019c  f8840051          STRB     r0,[r4,#0x51]         ;921
0001a0  bf00              NOP                            ;923
0001a2  2000              MOVS     r0,#0                 ;923
0001a4  f8840050          STRB     r0,[r4,#0x50]         ;923
0001a8  bf00              NOP                            ;923
0001aa  4650              MOV      r0,r10                ;924
0001ac  e736              B        |L20.28|
;;;926    
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TransmitReceive PROC
;;;1133     */
;;;1134   HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1135                                             uint32_t Timeout)
;;;1136   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
00000c  9e0e              LDR      r6,[sp,#0x38]
;;;1137     uint16_t             initial_TxXferCount;
;;;1138     uint32_t             tmp_mode;
;;;1139     HAL_SPI_StateTypeDef tmp_state;
;;;1140     uint32_t             tickstart;
;;;1141   #if (USE_SPI_CRC != 0U)
;;;1142     __IO uint32_t tmpreg = 0U;
;;;1143   #endif /* USE_SPI_CRC */
;;;1144   
;;;1145     /* Variable used to alternate Rx and Tx during transfer */
;;;1146     uint32_t             txallowed = 1U;
00000e  2001              MOVS     r0,#1
000010  9002              STR      r0,[sp,#8]
;;;1147     HAL_StatusTypeDef    errorcode = HAL_OK;
000012  2000              MOVS     r0,#0
000014  9001              STR      r0,[sp,#4]
;;;1148   
;;;1149     /* Check Direction parameter */
;;;1150     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1151   
;;;1152     /* Process Locked */
;;;1153     __HAL_LOCK(hspi);
000016  bf00              NOP      
000018  f8940050          LDRB     r0,[r4,#0x50]
00001c  2801              CMP      r0,#1
00001e  d103              BNE      |L21.40|
000020  2002              MOVS     r0,#2
                  |L21.34|
;;;1154   
;;;1155     /* Init tickstart for timeout management*/
;;;1156     tickstart = HAL_GetTick();
;;;1157   
;;;1158     /* Init temporary variables */
;;;1159     tmp_state           = hspi->State;
;;;1160     tmp_mode            = hspi->Init.Mode;
;;;1161     initial_TxXferCount = Size;
;;;1162   
;;;1163     if (!((tmp_state == HAL_SPI_STATE_READY) || \
;;;1164           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1165     {
;;;1166       errorcode = HAL_BUSY;
;;;1167       goto error;
;;;1168     }
;;;1169   
;;;1170     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1171     {
;;;1172       errorcode = HAL_ERROR;
;;;1173       goto error;
;;;1174     }
;;;1175   
;;;1176     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1177     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1178     {
;;;1179       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1180     }
;;;1181   
;;;1182     /* Set the transaction information */
;;;1183     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1184     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1185     hspi->RxXferCount = Size;
;;;1186     hspi->RxXferSize  = Size;
;;;1187     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1188     hspi->TxXferCount = Size;
;;;1189     hspi->TxXferSize  = Size;
;;;1190   
;;;1191     /*Init field not used in handle to zero */
;;;1192     hspi->RxISR       = NULL;
;;;1193     hspi->TxISR       = NULL;
;;;1194   
;;;1195   #if (USE_SPI_CRC != 0U)
;;;1196     /* Reset CRC Calculation */
;;;1197     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1198     {
;;;1199       SPI_RESET_CRC(hspi);
;;;1200     }
;;;1201   #endif /* USE_SPI_CRC */
;;;1202   
;;;1203     /* Check if the SPI is already enabled */
;;;1204     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1205     {
;;;1206       /* Enable SPI peripheral */
;;;1207       __HAL_SPI_ENABLE(hspi);
;;;1208     }
;;;1209   
;;;1210     /* Transmit and Receive data in 16 Bit mode */
;;;1211     if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1212     {
;;;1213       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1214       {
;;;1215         hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1216         hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1217         hspi->TxXferCount--;
;;;1218       }
;;;1219       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1220       {
;;;1221         /* Check TXE flag */
;;;1222         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1223         {
;;;1224           hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1225           hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1226           hspi->TxXferCount--;
;;;1227           /* Next Data is a reception (Rx). Tx not allowed */
;;;1228           txallowed = 0U;
;;;1229   
;;;1230   #if (USE_SPI_CRC != 0U)
;;;1231           /* Enable CRC Transmission */
;;;1232           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1233           {
;;;1234             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1235           }
;;;1236   #endif /* USE_SPI_CRC */
;;;1237         }
;;;1238   
;;;1239         /* Check RXNE flag */
;;;1240         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1241         {
;;;1242           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1243           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1244           hspi->RxXferCount--;
;;;1245           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1246           txallowed = 1U;
;;;1247         }
;;;1248         if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
;;;1249         {
;;;1250           errorcode = HAL_TIMEOUT;
;;;1251           goto error;
;;;1252         }
;;;1253       }
;;;1254     }
;;;1255     /* Transmit and Receive data in 8 Bit mode */
;;;1256     else
;;;1257     {
;;;1258       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1259       {
;;;1260         *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;1261         hspi->pTxBuffPtr += sizeof(uint8_t);
;;;1262         hspi->TxXferCount--;
;;;1263       }
;;;1264       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1265       {
;;;1266         /* Check TXE flag */
;;;1267         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1268         {
;;;1269           *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
;;;1270           hspi->pTxBuffPtr++;
;;;1271           hspi->TxXferCount--;
;;;1272           /* Next Data is a reception (Rx). Tx not allowed */
;;;1273           txallowed = 0U;
;;;1274   
;;;1275   #if (USE_SPI_CRC != 0U)
;;;1276           /* Enable CRC Transmission */
;;;1277           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1278           {
;;;1279             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1280           }
;;;1281   #endif /* USE_SPI_CRC */
;;;1282         }
;;;1283   
;;;1284         /* Wait until RXNE flag is reset */
;;;1285         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1286         {
;;;1287           (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
;;;1288           hspi->pRxBuffPtr++;
;;;1289           hspi->RxXferCount--;
;;;1290           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1291           txallowed = 1U;
;;;1292         }
;;;1293         if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
;;;1294         {
;;;1295           errorcode = HAL_TIMEOUT;
;;;1296           goto error;
;;;1297         }
;;;1298       }
;;;1299     }
;;;1300   
;;;1301   #if (USE_SPI_CRC != 0U)
;;;1302     /* Read CRC from DR to close CRC calculation process */
;;;1303     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1304     {
;;;1305       /* Wait until TXE flag */
;;;1306       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1307       {
;;;1308         /* Error on the CRC reception */
;;;1309         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1310         errorcode = HAL_TIMEOUT;
;;;1311         goto error;
;;;1312       }
;;;1313       /* Read CRC */
;;;1314       tmpreg = READ_REG(hspi->Instance->DR);
;;;1315       /* To avoid GCC warning */
;;;1316       UNUSED(tmpreg);
;;;1317     }
;;;1318   
;;;1319     /* Check if CRC error occurred */
;;;1320     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
;;;1321     {
;;;1322       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1323       /* Clear CRC Flag */
;;;1324       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1325   
;;;1326       errorcode = HAL_ERROR;
;;;1327     }
;;;1328   #endif /* USE_SPI_CRC */
;;;1329   
;;;1330     /* Check the end of the transaction */
;;;1331     if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1332     {
;;;1333       errorcode = HAL_ERROR;
;;;1334       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1335       goto error;
;;;1336     }
;;;1337   
;;;1338     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;1339     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;1340     {
;;;1341       __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;1342     }
;;;1343   
;;;1344   error :
;;;1345     hspi->State = HAL_SPI_STATE_READY;
;;;1346     __HAL_UNLOCK(hspi);
;;;1347     return errorcode;
;;;1348   }
000022  b004              ADD      sp,sp,#0x10
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L21.40|
000028  2001              MOVS     r0,#1                 ;1153
00002a  f8840050          STRB     r0,[r4,#0x50]         ;1153
00002e  bf00              NOP                            ;1153
000030  f7fffffe          BL       HAL_GetTick
000034  4607              MOV      r7,r0                 ;1156
000036  f894b051          LDRB     r11,[r4,#0x51]        ;1159
00003a  6860              LDR      r0,[r4,#4]            ;1160
00003c  9003              STR      r0,[sp,#0xc]          ;1160
00003e  46aa              MOV      r10,r5                ;1161
000040  f1bb0f01          CMP      r11,#1                ;1163
000044  d00b              BEQ      |L21.94|
000046  9803              LDR      r0,[sp,#0xc]          ;1163
000048  f5b07f82          CMP      r0,#0x104             ;1163
00004c  d104              BNE      |L21.88|
00004e  68a0              LDR      r0,[r4,#8]            ;1163
000050  b910              CBNZ     r0,|L21.88|
000052  f1bb0f04          CMP      r11,#4                ;1163
000056  d002              BEQ      |L21.94|
                  |L21.88|
000058  2002              MOVS     r0,#2                 ;1166
00005a  9001              STR      r0,[sp,#4]            ;1166
00005c  e0db              B        |L21.534|
                  |L21.94|
00005e  f1b80f00          CMP      r8,#0                 ;1170
000062  d003              BEQ      |L21.108|
000064  f1b90f00          CMP      r9,#0                 ;1170
000068  d000              BEQ      |L21.108|
00006a  b915              CBNZ     r5,|L21.114|
                  |L21.108|
00006c  2001              MOVS     r0,#1                 ;1172
00006e  9001              STR      r0,[sp,#4]            ;1172
000070  e0d1              B        |L21.534|
                  |L21.114|
000072  f8940051          LDRB     r0,[r4,#0x51]         ;1177
000076  2804              CMP      r0,#4                 ;1177
000078  d002              BEQ      |L21.128|
00007a  2005              MOVS     r0,#5                 ;1179
00007c  f8840051          STRB     r0,[r4,#0x51]         ;1179
                  |L21.128|
000080  2000              MOVS     r0,#0                 ;1183
000082  6560              STR      r0,[r4,#0x54]         ;1183
000084  f8c49038          STR      r9,[r4,#0x38]         ;1184
000088  87e5              STRH     r5,[r4,#0x3e]         ;1185
00008a  87a5              STRH     r5,[r4,#0x3c]         ;1186
00008c  f8c48030          STR      r8,[r4,#0x30]         ;1187
000090  86e5              STRH     r5,[r4,#0x36]         ;1188
000092  86a5              STRH     r5,[r4,#0x34]         ;1189
000094  6420              STR      r0,[r4,#0x40]         ;1192
000096  6460              STR      r0,[r4,#0x44]         ;1193
000098  6820              LDR      r0,[r4,#0]            ;1204
00009a  6800              LDR      r0,[r0,#0]            ;1204
00009c  f0000040          AND      r0,r0,#0x40           ;1204
0000a0  2840              CMP      r0,#0x40              ;1204
0000a2  d005              BEQ      |L21.176|
0000a4  6820              LDR      r0,[r4,#0]            ;1207
0000a6  6800              LDR      r0,[r0,#0]            ;1207
0000a8  f0400040          ORR      r0,r0,#0x40           ;1207
0000ac  6821              LDR      r1,[r4,#0]            ;1207
0000ae  6008              STR      r0,[r1,#0]            ;1207
                  |L21.176|
0000b0  68e0              LDR      r0,[r4,#0xc]          ;1211
0000b2  f5b06f00          CMP      r0,#0x800             ;1211
0000b6  d14a              BNE      |L21.334|
0000b8  6860              LDR      r0,[r4,#4]            ;1213
0000ba  b110              CBZ      r0,|L21.194|
0000bc  f1ba0f01          CMP      r10,#1                ;1213
0000c0  d109              BNE      |L21.214|
                  |L21.194|
0000c2  6b20              LDR      r0,[r4,#0x30]         ;1215
0000c4  8800              LDRH     r0,[r0,#0]            ;1215
0000c6  6821              LDR      r1,[r4,#0]            ;1215
0000c8  60c8              STR      r0,[r1,#0xc]          ;1215
0000ca  6b20              LDR      r0,[r4,#0x30]         ;1216
0000cc  1c80              ADDS     r0,r0,#2              ;1216
0000ce  6320              STR      r0,[r4,#0x30]         ;1216
0000d0  8ee0              LDRH     r0,[r4,#0x36]         ;1217
0000d2  1e40              SUBS     r0,r0,#1              ;1217
0000d4  86e0              STRH     r0,[r4,#0x36]         ;1217
                  |L21.214|
0000d6  e033              B        |L21.320|
                  |L21.216|
0000d8  6820              LDR      r0,[r4,#0]            ;1222
0000da  6880              LDR      r0,[r0,#8]            ;1222
0000dc  f0000002          AND      r0,r0,#2              ;1222
0000e0  2802              CMP      r0,#2                 ;1222
0000e2  d110              BNE      |L21.262|
0000e4  8ee0              LDRH     r0,[r4,#0x36]         ;1222
0000e6  b170              CBZ      r0,|L21.262|
0000e8  9802              LDR      r0,[sp,#8]            ;1222
0000ea  2801              CMP      r0,#1                 ;1222
0000ec  d10b              BNE      |L21.262|
0000ee  6b20              LDR      r0,[r4,#0x30]         ;1224
0000f0  8800              LDRH     r0,[r0,#0]            ;1224
0000f2  6821              LDR      r1,[r4,#0]            ;1224
0000f4  60c8              STR      r0,[r1,#0xc]          ;1224
0000f6  6b20              LDR      r0,[r4,#0x30]         ;1225
0000f8  1c80              ADDS     r0,r0,#2              ;1225
0000fa  6320              STR      r0,[r4,#0x30]         ;1225
0000fc  8ee0              LDRH     r0,[r4,#0x36]         ;1226
0000fe  1e40              SUBS     r0,r0,#1              ;1226
000100  86e0              STRH     r0,[r4,#0x36]         ;1226
000102  2000              MOVS     r0,#0                 ;1228
000104  9002              STR      r0,[sp,#8]            ;1228
                  |L21.262|
000106  6820              LDR      r0,[r4,#0]            ;1240
000108  6880              LDR      r0,[r0,#8]            ;1240
00010a  f0000001          AND      r0,r0,#1              ;1240
00010e  b168              CBZ      r0,|L21.300|
000110  8fe0              LDRH     r0,[r4,#0x3e]         ;1240
000112  b158              CBZ      r0,|L21.300|
000114  6820              LDR      r0,[r4,#0]            ;1242
000116  68c0              LDR      r0,[r0,#0xc]          ;1242
000118  6ba1              LDR      r1,[r4,#0x38]         ;1242
00011a  8008              STRH     r0,[r1,#0]            ;1242
00011c  6ba0              LDR      r0,[r4,#0x38]         ;1243
00011e  1c80              ADDS     r0,r0,#2              ;1243
000120  63a0              STR      r0,[r4,#0x38]         ;1243
000122  8fe0              LDRH     r0,[r4,#0x3e]         ;1244
000124  1e40              SUBS     r0,r0,#1              ;1244
000126  87e0              STRH     r0,[r4,#0x3e]         ;1244
000128  2001              MOVS     r0,#1                 ;1246
00012a  9002              STR      r0,[sp,#8]            ;1246
                  |L21.300|
00012c  f7fffffe          BL       HAL_GetTick
000130  1bc0              SUBS     r0,r0,r7              ;1248
000132  42b0              CMP      r0,r6                 ;1248
000134  d304              BCC      |L21.320|
000136  1c70              ADDS     r0,r6,#1              ;1248
000138  b110              CBZ      r0,|L21.320|
00013a  2003              MOVS     r0,#3                 ;1250
00013c  9001              STR      r0,[sp,#4]            ;1250
00013e  e06a              B        |L21.534|
                  |L21.320|
000140  8ee0              LDRH     r0,[r4,#0x36]         ;1219
000142  2800              CMP      r0,#0                 ;1219
000144  d1c8              BNE      |L21.216|
000146  8fe0              LDRH     r0,[r4,#0x3e]         ;1219
000148  2800              CMP      r0,#0                 ;1219
00014a  d1c5              BNE      |L21.216|
00014c  e04a              B        |L21.484|
                  |L21.334|
00014e  6860              LDR      r0,[r4,#4]            ;1258
000150  b110              CBZ      r0,|L21.344|
000152  f1ba0f01          CMP      r10,#1                ;1258
000156  d109              BNE      |L21.364|
                  |L21.344|
000158  6b20              LDR      r0,[r4,#0x30]         ;1260
00015a  7800              LDRB     r0,[r0,#0]            ;1260
00015c  6821              LDR      r1,[r4,#0]            ;1260
00015e  7308              STRB     r0,[r1,#0xc]          ;1260
000160  6b20              LDR      r0,[r4,#0x30]         ;1261
000162  1c40              ADDS     r0,r0,#1              ;1261
000164  6320              STR      r0,[r4,#0x30]         ;1261
000166  8ee0              LDRH     r0,[r4,#0x36]         ;1262
000168  1e40              SUBS     r0,r0,#1              ;1262
00016a  86e0              STRH     r0,[r4,#0x36]         ;1262
                  |L21.364|
00016c  e034              B        |L21.472|
                  |L21.366|
00016e  6820              LDR      r0,[r4,#0]            ;1267
000170  6880              LDR      r0,[r0,#8]            ;1267
000172  f0000002          AND      r0,r0,#2              ;1267
000176  2802              CMP      r0,#2                 ;1267
000178  d110              BNE      |L21.412|
00017a  8ee0              LDRH     r0,[r4,#0x36]         ;1267
00017c  b170              CBZ      r0,|L21.412|
00017e  9802              LDR      r0,[sp,#8]            ;1267
000180  2801              CMP      r0,#1                 ;1267
000182  d10b              BNE      |L21.412|
000184  6b20              LDR      r0,[r4,#0x30]         ;1269
000186  7800              LDRB     r0,[r0,#0]            ;1269
000188  6821              LDR      r1,[r4,#0]            ;1269
00018a  7308              STRB     r0,[r1,#0xc]          ;1269
00018c  6b20              LDR      r0,[r4,#0x30]         ;1270
00018e  1c40              ADDS     r0,r0,#1              ;1270
000190  6320              STR      r0,[r4,#0x30]         ;1270
000192  8ee0              LDRH     r0,[r4,#0x36]         ;1271
000194  1e40              SUBS     r0,r0,#1              ;1271
000196  86e0              STRH     r0,[r4,#0x36]         ;1271
000198  2000              MOVS     r0,#0                 ;1273
00019a  9002              STR      r0,[sp,#8]            ;1273
                  |L21.412|
00019c  6820              LDR      r0,[r4,#0]            ;1285
00019e  6880              LDR      r0,[r0,#8]            ;1285
0001a0  f0000001          AND      r0,r0,#1              ;1285
0001a4  b168              CBZ      r0,|L21.450|
0001a6  8fe0              LDRH     r0,[r4,#0x3e]         ;1285
0001a8  b158              CBZ      r0,|L21.450|
0001aa  6820              LDR      r0,[r4,#0]            ;1287
0001ac  68c0              LDR      r0,[r0,#0xc]          ;1287
0001ae  6ba1              LDR      r1,[r4,#0x38]         ;1287
0001b0  7008              STRB     r0,[r1,#0]            ;1287
0001b2  6ba0              LDR      r0,[r4,#0x38]         ;1288
0001b4  1c40              ADDS     r0,r0,#1              ;1288
0001b6  63a0              STR      r0,[r4,#0x38]         ;1288
0001b8  8fe0              LDRH     r0,[r4,#0x3e]         ;1289
0001ba  1e40              SUBS     r0,r0,#1              ;1289
0001bc  87e0              STRH     r0,[r4,#0x3e]         ;1289
0001be  2001              MOVS     r0,#1                 ;1291
0001c0  9002              STR      r0,[sp,#8]            ;1291
                  |L21.450|
0001c2  f7fffffe          BL       HAL_GetTick
0001c6  1bc0              SUBS     r0,r0,r7              ;1293
0001c8  42b0              CMP      r0,r6                 ;1293
0001ca  d301              BCC      |L21.464|
0001cc  1c70              ADDS     r0,r6,#1              ;1293
0001ce  b900              CBNZ     r0,|L21.466|
                  |L21.464|
0001d0  b916              CBNZ     r6,|L21.472|
                  |L21.466|
0001d2  2003              MOVS     r0,#3                 ;1295
0001d4  9001              STR      r0,[sp,#4]            ;1295
0001d6  e01e              B        |L21.534|
                  |L21.472|
0001d8  8ee0              LDRH     r0,[r4,#0x36]         ;1264
0001da  2800              CMP      r0,#0                 ;1264
0001dc  d1c7              BNE      |L21.366|
0001de  8fe0              LDRH     r0,[r4,#0x3e]         ;1264
0001e0  2800              CMP      r0,#0                 ;1264
0001e2  d1c4              BNE      |L21.366|
                  |L21.484|
0001e4  463a              MOV      r2,r7                 ;1331
0001e6  4631              MOV      r1,r6                 ;1331
0001e8  4620              MOV      r0,r4                 ;1331
0001ea  f7fffffe          BL       SPI_EndRxTxTransaction
0001ee  b120              CBZ      r0,|L21.506|
0001f0  2001              MOVS     r0,#1                 ;1333
0001f2  9001              STR      r0,[sp,#4]            ;1333
0001f4  2020              MOVS     r0,#0x20              ;1334
0001f6  6560              STR      r0,[r4,#0x54]         ;1334
0001f8  e00d              B        |L21.534|
                  |L21.506|
0001fa  68a0              LDR      r0,[r4,#8]            ;1339
0001fc  b950              CBNZ     r0,|L21.532|
0001fe  bf00              NOP                            ;1341
000200  2000              MOVS     r0,#0                 ;1341
000202  9000              STR      r0,[sp,#0]            ;1341
000204  6820              LDR      r0,[r4,#0]            ;1341
000206  68c0              LDR      r0,[r0,#0xc]          ;1341
000208  9000              STR      r0,[sp,#0]            ;1341
00020a  6820              LDR      r0,[r4,#0]            ;1341
00020c  6880              LDR      r0,[r0,#8]            ;1341
00020e  9000              STR      r0,[sp,#0]            ;1341
000210  bf00              NOP                            ;1341
000212  bf00              NOP                            ;1341
                  |L21.532|
000214  bf00              NOP                            ;1344
                  |L21.534|
000216  2001              MOVS     r0,#1                 ;1345
000218  f8840051          STRB     r0,[r4,#0x51]         ;1345
00021c  bf00              NOP                            ;1346
00021e  2000              MOVS     r0,#0                 ;1346
000220  f8840050          STRB     r0,[r4,#0x50]         ;1346
000224  bf00              NOP                            ;1346
000226  9801              LDR      r0,[sp,#4]            ;1347
000228  e6fb              B        |L21.34|
;;;1349   
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_DMA PROC
;;;1847     */
;;;1848   HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1849                                                 uint16_t Size)
;;;1850   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1851     uint32_t             tmp_mode;
;;;1852     HAL_SPI_StateTypeDef tmp_state;
;;;1853     HAL_StatusTypeDef errorcode = HAL_OK;
00000c  f04f0a00          MOV      r10,#0
;;;1854   
;;;1855     /* Check rx & tx dma handles */
;;;1856     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
;;;1857     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1858   
;;;1859     /* Check Direction parameter */
;;;1860     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1861   
;;;1862     /* Process locked */
;;;1863     __HAL_LOCK(hspi);
000010  bf00              NOP      
000012  f8940050          LDRB     r0,[r4,#0x50]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L22.32|
00001a  2002              MOVS     r0,#2
                  |L22.28|
;;;1864   
;;;1865     /* Init temporary variables */
;;;1866     tmp_state           = hspi->State;
;;;1867     tmp_mode            = hspi->Init.Mode;
;;;1868   
;;;1869     if (!((tmp_state == HAL_SPI_STATE_READY) ||
;;;1870           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1871     {
;;;1872       errorcode = HAL_BUSY;
;;;1873       goto error;
;;;1874     }
;;;1875   
;;;1876     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1877     {
;;;1878       errorcode = HAL_ERROR;
;;;1879       goto error;
;;;1880     }
;;;1881   
;;;1882     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1883     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1884     {
;;;1885       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1886     }
;;;1887   
;;;1888     /* Set the transaction information */
;;;1889     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1890     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1891     hspi->TxXferSize  = Size;
;;;1892     hspi->TxXferCount = Size;
;;;1893     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1894     hspi->RxXferSize  = Size;
;;;1895     hspi->RxXferCount = Size;
;;;1896   
;;;1897     /* Init field not used in handle to zero */
;;;1898     hspi->RxISR       = NULL;
;;;1899     hspi->TxISR       = NULL;
;;;1900   
;;;1901   #if (USE_SPI_CRC != 0U)
;;;1902     /* Reset CRC Calculation */
;;;1903     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1904     {
;;;1905       SPI_RESET_CRC(hspi);
;;;1906     }
;;;1907   #endif /* USE_SPI_CRC */
;;;1908   
;;;1909     /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
;;;1910     if (hspi->State == HAL_SPI_STATE_BUSY_RX)
;;;1911     {
;;;1912       /* Set the SPI Rx DMA Half transfer complete callback */
;;;1913       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1914       hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
;;;1915     }
;;;1916     else
;;;1917     {
;;;1918       /* Set the SPI Tx/Rx DMA Half transfer complete callback */
;;;1919       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
;;;1920       hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
;;;1921     }
;;;1922   
;;;1923     /* Set the DMA error callback */
;;;1924     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1925   
;;;1926     /* Set the DMA AbortCpltCallback */
;;;1927     hspi->hdmarx->XferAbortCallback = NULL;
;;;1928   
;;;1929     /* Enable the Rx DMA Stream/Channel  */
;;;1930     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
;;;1931                                    hspi->RxXferCount))
;;;1932     {
;;;1933       /* Update SPI error code */
;;;1934       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1935       errorcode = HAL_ERROR;
;;;1936   
;;;1937       hspi->State = HAL_SPI_STATE_READY;
;;;1938       goto error;
;;;1939     }
;;;1940   
;;;1941     /* Enable Rx DMA Request */
;;;1942     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;1943   
;;;1944     /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
;;;1945     is performed in DMA reception complete callback  */
;;;1946     hspi->hdmatx->XferHalfCpltCallback = NULL;
;;;1947     hspi->hdmatx->XferCpltCallback     = NULL;
;;;1948     hspi->hdmatx->XferErrorCallback    = NULL;
;;;1949     hspi->hdmatx->XferAbortCallback    = NULL;
;;;1950   
;;;1951     /* Enable the Tx DMA Stream/Channel  */
;;;1952     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
;;;1953                                    hspi->TxXferCount))
;;;1954     {
;;;1955       /* Update SPI error code */
;;;1956       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1957       errorcode = HAL_ERROR;
;;;1958   
;;;1959       hspi->State = HAL_SPI_STATE_READY;
;;;1960       goto error;
;;;1961     }
;;;1962   
;;;1963     /* Check if the SPI is already enabled */
;;;1964     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1965     {
;;;1966       /* Enable SPI peripheral */
;;;1967       __HAL_SPI_ENABLE(hspi);
;;;1968     }
;;;1969     /* Enable the SPI Error Interrupt Bit */
;;;1970     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1971   
;;;1972     /* Enable Tx DMA Request */
;;;1973     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;1974   
;;;1975   error :
;;;1976     /* Process Unlocked */
;;;1977     __HAL_UNLOCK(hspi);
;;;1978     return errorcode;
;;;1979   }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L22.32|
000020  2001              MOVS     r0,#1                 ;1863
000022  f8840050          STRB     r0,[r4,#0x50]         ;1863
000026  bf00              NOP                            ;1863
000028  f8948051          LDRB     r8,[r4,#0x51]         ;1866
00002c  f8d49004          LDR      r9,[r4,#4]            ;1867
000030  f1b80f01          CMP      r8,#1                 ;1869
000034  d00a              BEQ      |L22.76|
000036  f5b97f82          CMP      r9,#0x104             ;1869
00003a  d104              BNE      |L22.70|
00003c  68a0              LDR      r0,[r4,#8]            ;1869
00003e  b910              CBNZ     r0,|L22.70|
000040  f1b80f04          CMP      r8,#4                 ;1869
000044  d002              BEQ      |L22.76|
                  |L22.70|
000046  f04f0a02          MOV      r10,#2                ;1872
00004a  e07d              B        |L22.328|
                  |L22.76|
00004c  b10e              CBZ      r6,|L22.82|
00004e  b107              CBZ      r7,|L22.82|
000050  b915              CBNZ     r5,|L22.88|
                  |L22.82|
000052  f04f0a01          MOV      r10,#1                ;1878
000056  e077              B        |L22.328|
                  |L22.88|
000058  f8940051          LDRB     r0,[r4,#0x51]         ;1883
00005c  2804              CMP      r0,#4                 ;1883
00005e  d002              BEQ      |L22.102|
000060  2005              MOVS     r0,#5                 ;1885
000062  f8840051          STRB     r0,[r4,#0x51]         ;1885
                  |L22.102|
000066  2000              MOVS     r0,#0                 ;1889
000068  6560              STR      r0,[r4,#0x54]         ;1889
00006a  6326              STR      r6,[r4,#0x30]         ;1890
00006c  86a5              STRH     r5,[r4,#0x34]         ;1891
00006e  86e5              STRH     r5,[r4,#0x36]         ;1892
000070  63a7              STR      r7,[r4,#0x38]         ;1893
000072  87a5              STRH     r5,[r4,#0x3c]         ;1894
000074  87e5              STRH     r5,[r4,#0x3e]         ;1895
000076  6420              STR      r0,[r4,#0x40]         ;1898
000078  6460              STR      r0,[r4,#0x44]         ;1899
00007a  f8940051          LDRB     r0,[r4,#0x51]         ;1910
00007e  2804              CMP      r0,#4                 ;1910
000080  d106              BNE      |L22.144|
000082  4835              LDR      r0,|L22.344|
000084  6ce1              LDR      r1,[r4,#0x4c]         ;1913
000086  6408              STR      r0,[r1,#0x40]         ;1913
000088  4834              LDR      r0,|L22.348|
00008a  6ce1              LDR      r1,[r4,#0x4c]         ;1914
00008c  63c8              STR      r0,[r1,#0x3c]         ;1914
00008e  e005              B        |L22.156|
                  |L22.144|
000090  4833              LDR      r0,|L22.352|
000092  6ce1              LDR      r1,[r4,#0x4c]         ;1919
000094  6408              STR      r0,[r1,#0x40]         ;1919
000096  4833              LDR      r0,|L22.356|
000098  6ce1              LDR      r1,[r4,#0x4c]         ;1920
00009a  63c8              STR      r0,[r1,#0x3c]         ;1920
                  |L22.156|
00009c  4832              LDR      r0,|L22.360|
00009e  6ce1              LDR      r1,[r4,#0x4c]         ;1924
0000a0  64c8              STR      r0,[r1,#0x4c]         ;1924
0000a2  2000              MOVS     r0,#0                 ;1927
0000a4  6ce1              LDR      r1,[r4,#0x4c]         ;1927
0000a6  6508              STR      r0,[r1,#0x50]         ;1927
0000a8  8fe3              LDRH     r3,[r4,#0x3e]         ;1930
0000aa  f8d4c000          LDR      r12,[r4,#0]           ;1930
0000ae  f10c010c          ADD      r1,r12,#0xc           ;1930
0000b2  6ba2              LDR      r2,[r4,#0x38]         ;1930
0000b4  6ce0              LDR      r0,[r4,#0x4c]         ;1930
0000b6  f7fffffe          BL       HAL_DMA_Start_IT
0000ba  b148              CBZ      r0,|L22.208|
0000bc  6d60              LDR      r0,[r4,#0x54]         ;1934
0000be  f0400010          ORR      r0,r0,#0x10           ;1934
0000c2  6560              STR      r0,[r4,#0x54]         ;1934
0000c4  f04f0a01          MOV      r10,#1                ;1935
0000c8  2001              MOVS     r0,#1                 ;1937
0000ca  f8840051          STRB     r0,[r4,#0x51]         ;1937
0000ce  e03b              B        |L22.328|
                  |L22.208|
0000d0  6820              LDR      r0,[r4,#0]            ;1942
0000d2  6840              LDR      r0,[r0,#4]            ;1942
0000d4  f0400001          ORR      r0,r0,#1              ;1942
0000d8  6821              LDR      r1,[r4,#0]            ;1942
0000da  6048              STR      r0,[r1,#4]            ;1942
0000dc  2000              MOVS     r0,#0                 ;1946
0000de  6ca1              LDR      r1,[r4,#0x48]         ;1946
0000e0  6408              STR      r0,[r1,#0x40]         ;1946
0000e2  6ca1              LDR      r1,[r4,#0x48]         ;1947
0000e4  63c8              STR      r0,[r1,#0x3c]         ;1947
0000e6  6ca1              LDR      r1,[r4,#0x48]         ;1948
0000e8  64c8              STR      r0,[r1,#0x4c]         ;1948
0000ea  6ca1              LDR      r1,[r4,#0x48]         ;1949
0000ec  6508              STR      r0,[r1,#0x50]         ;1949
0000ee  8ee3              LDRH     r3,[r4,#0x36]         ;1952
0000f0  f8d4c000          LDR      r12,[r4,#0]           ;1952
0000f4  f10c020c          ADD      r2,r12,#0xc           ;1952
0000f8  6b21              LDR      r1,[r4,#0x30]         ;1952
0000fa  6ca0              LDR      r0,[r4,#0x48]         ;1952
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  b148              CBZ      r0,|L22.278|
000102  6d60              LDR      r0,[r4,#0x54]         ;1956
000104  f0400010          ORR      r0,r0,#0x10           ;1956
000108  6560              STR      r0,[r4,#0x54]         ;1956
00010a  f04f0a01          MOV      r10,#1                ;1957
00010e  2001              MOVS     r0,#1                 ;1959
000110  f8840051          STRB     r0,[r4,#0x51]         ;1959
000114  e018              B        |L22.328|
                  |L22.278|
000116  6820              LDR      r0,[r4,#0]            ;1964
000118  6800              LDR      r0,[r0,#0]            ;1964
00011a  f0000040          AND      r0,r0,#0x40           ;1964
00011e  2840              CMP      r0,#0x40              ;1964
000120  d005              BEQ      |L22.302|
000122  6820              LDR      r0,[r4,#0]            ;1967
000124  6800              LDR      r0,[r0,#0]            ;1967
000126  f0400040          ORR      r0,r0,#0x40           ;1967
00012a  6821              LDR      r1,[r4,#0]            ;1967
00012c  6008              STR      r0,[r1,#0]            ;1967
                  |L22.302|
00012e  6820              LDR      r0,[r4,#0]            ;1970
000130  6840              LDR      r0,[r0,#4]            ;1970
000132  f0400020          ORR      r0,r0,#0x20           ;1970
000136  6821              LDR      r1,[r4,#0]            ;1970
000138  6048              STR      r0,[r1,#4]            ;1970
00013a  6820              LDR      r0,[r4,#0]            ;1973
00013c  6840              LDR      r0,[r0,#4]            ;1973
00013e  f0400002          ORR      r0,r0,#2              ;1973
000142  6821              LDR      r1,[r4,#0]            ;1973
000144  6048              STR      r0,[r1,#4]            ;1973
000146  bf00              NOP                            ;1975
                  |L22.328|
000148  bf00              NOP                            ;1977
00014a  2000              MOVS     r0,#0                 ;1977
00014c  f8840050          STRB     r0,[r4,#0x50]         ;1977
000150  bf00              NOP                            ;1977
000152  4650              MOV      r0,r10                ;1978
000154  e762              B        |L22.28|
;;;1980   
                          ENDP

000156  0000              DCW      0x0000
                  |L22.344|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L22.348|
                          DCD      SPI_DMAReceiveCplt
                  |L22.352|
                          DCD      SPI_DMAHalfTransmitReceiveCplt
                  |L22.356|
                          DCD      SPI_DMATransmitReceiveCplt
                  |L22.360|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_TransmitReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_IT PROC
;;;1536     */
;;;1537   HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1538   {
000002  4604              MOV      r4,r0
;;;1539     uint32_t             tmp_mode;
;;;1540     HAL_SPI_StateTypeDef tmp_state;
;;;1541     HAL_StatusTypeDef    errorcode = HAL_OK;
000004  2700              MOVS     r7,#0
;;;1542   
;;;1543     /* Check Direction parameter */
;;;1544     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1545   
;;;1546     /* Process locked */
;;;1547     __HAL_LOCK(hspi);
000006  bf00              NOP      
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L23.20|
000010  2002              MOVS     r0,#2
                  |L23.18|
;;;1548   
;;;1549     /* Init temporary variables */
;;;1550     tmp_state           = hspi->State;
;;;1551     tmp_mode            = hspi->Init.Mode;
;;;1552   
;;;1553     if (!((tmp_state == HAL_SPI_STATE_READY) || \
;;;1554           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1555     {
;;;1556       errorcode = HAL_BUSY;
;;;1557       goto error;
;;;1558     }
;;;1559   
;;;1560     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1561     {
;;;1562       errorcode = HAL_ERROR;
;;;1563       goto error;
;;;1564     }
;;;1565   
;;;1566     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1567     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1568     {
;;;1569       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1570     }
;;;1571   
;;;1572     /* Set the transaction information */
;;;1573     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1574     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1575     hspi->TxXferSize  = Size;
;;;1576     hspi->TxXferCount = Size;
;;;1577     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1578     hspi->RxXferSize  = Size;
;;;1579     hspi->RxXferCount = Size;
;;;1580   
;;;1581     /* Set the function for IT treatment */
;;;1582     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1583     {
;;;1584       hspi->RxISR     = SPI_2linesRxISR_16BIT;
;;;1585       hspi->TxISR     = SPI_2linesTxISR_16BIT;
;;;1586     }
;;;1587     else
;;;1588     {
;;;1589       hspi->RxISR     = SPI_2linesRxISR_8BIT;
;;;1590       hspi->TxISR     = SPI_2linesTxISR_8BIT;
;;;1591     }
;;;1592   
;;;1593   #if (USE_SPI_CRC != 0U)
;;;1594     /* Reset CRC Calculation */
;;;1595     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1596     {
;;;1597       SPI_RESET_CRC(hspi);
;;;1598     }
;;;1599   #endif /* USE_SPI_CRC */
;;;1600   
;;;1601     /* Enable TXE, RXNE and ERR interrupt */
;;;1602     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;1603   
;;;1604     /* Check if the SPI is already enabled */
;;;1605     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1606     {
;;;1607       /* Enable SPI peripheral */
;;;1608       __HAL_SPI_ENABLE(hspi);
;;;1609     }
;;;1610   
;;;1611   error :
;;;1612     /* Process Unlocked */
;;;1613     __HAL_UNLOCK(hspi);
;;;1614     return errorcode;
;;;1615   }
000012  bdf0              POP      {r4-r7,pc}
                  |L23.20|
000014  2001              MOVS     r0,#1                 ;1547
000016  f8840050          STRB     r0,[r4,#0x50]         ;1547
00001a  bf00              NOP                            ;1547
00001c  f8945051          LDRB     r5,[r4,#0x51]         ;1550
000020  6866              LDR      r6,[r4,#4]            ;1551
000022  2d01              CMP      r5,#1                 ;1553
000024  d008              BEQ      |L23.56|
000026  f5b67f82          CMP      r6,#0x104             ;1553
00002a  d103              BNE      |L23.52|
00002c  68a0              LDR      r0,[r4,#8]            ;1553
00002e  b908              CBNZ     r0,|L23.52|
000030  2d04              CMP      r5,#4                 ;1553
000032  d001              BEQ      |L23.56|
                  |L23.52|
000034  2702              MOVS     r7,#2                 ;1556
000036  e035              B        |L23.164|
                  |L23.56|
000038  b109              CBZ      r1,|L23.62|
00003a  b102              CBZ      r2,|L23.62|
00003c  b90b              CBNZ     r3,|L23.66|
                  |L23.62|
00003e  2701              MOVS     r7,#1                 ;1562
000040  e030              B        |L23.164|
                  |L23.66|
000042  f8940051          LDRB     r0,[r4,#0x51]         ;1567
000046  2804              CMP      r0,#4                 ;1567
000048  d002              BEQ      |L23.80|
00004a  2005              MOVS     r0,#5                 ;1569
00004c  f8840051          STRB     r0,[r4,#0x51]         ;1569
                  |L23.80|
000050  2000              MOVS     r0,#0                 ;1573
000052  6560              STR      r0,[r4,#0x54]         ;1573
000054  6321              STR      r1,[r4,#0x30]         ;1574
000056  86a3              STRH     r3,[r4,#0x34]         ;1575
000058  86e3              STRH     r3,[r4,#0x36]         ;1576
00005a  63a2              STR      r2,[r4,#0x38]         ;1577
00005c  87a3              STRH     r3,[r4,#0x3c]         ;1578
00005e  87e3              STRH     r3,[r4,#0x3e]         ;1579
000060  68e0              LDR      r0,[r4,#0xc]          ;1582
000062  b120              CBZ      r0,|L23.110|
000064  4813              LDR      r0,|L23.180|
000066  6420              STR      r0,[r4,#0x40]         ;1584
000068  4813              LDR      r0,|L23.184|
00006a  6460              STR      r0,[r4,#0x44]         ;1585
00006c  e003              B        |L23.118|
                  |L23.110|
00006e  4813              LDR      r0,|L23.188|
000070  6420              STR      r0,[r4,#0x40]         ;1589
000072  4813              LDR      r0,|L23.192|
000074  6460              STR      r0,[r4,#0x44]         ;1590
                  |L23.118|
000076  6820              LDR      r0,[r4,#0]            ;1602
000078  6840              LDR      r0,[r0,#4]            ;1602
00007a  f04000e0          ORR      r0,r0,#0xe0           ;1602
00007e  f8d4c000          LDR      r12,[r4,#0]           ;1602
000082  f8cc0004          STR      r0,[r12,#4]           ;1602
000086  6820              LDR      r0,[r4,#0]            ;1605
000088  6800              LDR      r0,[r0,#0]            ;1605
00008a  f0000040          AND      r0,r0,#0x40           ;1605
00008e  2840              CMP      r0,#0x40              ;1605
000090  d007              BEQ      |L23.162|
000092  6820              LDR      r0,[r4,#0]            ;1608
000094  6800              LDR      r0,[r0,#0]            ;1608
000096  f0400040          ORR      r0,r0,#0x40           ;1608
00009a  f8d4c000          LDR      r12,[r4,#0]           ;1608
00009e  f8cc0000          STR      r0,[r12,#0]           ;1608
                  |L23.162|
0000a2  bf00              NOP                            ;1611
                  |L23.164|
0000a4  bf00              NOP                            ;1613
0000a6  2000              MOVS     r0,#0                 ;1613
0000a8  f8840050          STRB     r0,[r4,#0x50]         ;1613
0000ac  bf00              NOP                            ;1613
0000ae  4638              MOV      r0,r7                 ;1614
0000b0  e7af              B        |L23.18|
;;;1616   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L23.180|
                          DCD      SPI_2linesRxISR_16BIT
                  |L23.184|
                          DCD      SPI_2linesTxISR_16BIT
                  |L23.188|
                          DCD      SPI_2linesRxISR_8BIT
                  |L23.192|
                          DCD      SPI_2linesTxISR_8BIT

                          AREA ||i.HAL_SPI_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_DMA PROC
;;;1624     */
;;;1625   HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1626   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1627     HAL_StatusTypeDef errorcode = HAL_OK;
00000a  2700              MOVS     r7,#0
;;;1628   
;;;1629     /* Check tx dma handle */
;;;1630     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1631   
;;;1632     /* Check Direction parameter */
;;;1633     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1634   
;;;1635     /* Process Locked */
;;;1636     __HAL_LOCK(hspi);
00000c  bf00              NOP      
00000e  f8940050          LDRB     r0,[r4,#0x50]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L24.28|
000016  2002              MOVS     r0,#2
                  |L24.24|
;;;1637   
;;;1638     if (hspi->State != HAL_SPI_STATE_READY)
;;;1639     {
;;;1640       errorcode = HAL_BUSY;
;;;1641       goto error;
;;;1642     }
;;;1643   
;;;1644     if ((pData == NULL) || (Size == 0U))
;;;1645     {
;;;1646       errorcode = HAL_ERROR;
;;;1647       goto error;
;;;1648     }
;;;1649   
;;;1650     /* Set the transaction information */
;;;1651     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1652     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1653     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1654     hspi->TxXferSize  = Size;
;;;1655     hspi->TxXferCount = Size;
;;;1656   
;;;1657     /* Init field not used in handle to zero */
;;;1658     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1659     hspi->TxISR       = NULL;
;;;1660     hspi->RxISR       = NULL;
;;;1661     hspi->RxXferSize  = 0U;
;;;1662     hspi->RxXferCount = 0U;
;;;1663   
;;;1664     /* Configure communication direction : 1Line */
;;;1665     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1666     {
;;;1667       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1668       __HAL_SPI_DISABLE(hspi);
;;;1669       SPI_1LINE_TX(hspi);
;;;1670     }
;;;1671   
;;;1672   #if (USE_SPI_CRC != 0U)
;;;1673     /* Reset CRC Calculation */
;;;1674     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1675     {
;;;1676       SPI_RESET_CRC(hspi);
;;;1677     }
;;;1678   #endif /* USE_SPI_CRC */
;;;1679   
;;;1680     /* Set the SPI TxDMA Half transfer complete callback */
;;;1681     hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
;;;1682   
;;;1683     /* Set the SPI TxDMA transfer complete callback */
;;;1684     hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
;;;1685   
;;;1686     /* Set the DMA error callback */
;;;1687     hspi->hdmatx->XferErrorCallback = SPI_DMAError;
;;;1688   
;;;1689     /* Set the DMA AbortCpltCallback */
;;;1690     hspi->hdmatx->XferAbortCallback = NULL;
;;;1691   
;;;1692     /* Enable the Tx DMA Stream/Channel */
;;;1693     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
;;;1694                                    hspi->TxXferCount))
;;;1695     {
;;;1696       /* Update SPI error code */
;;;1697       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1698       errorcode = HAL_ERROR;
;;;1699   
;;;1700       hspi->State = HAL_SPI_STATE_READY;
;;;1701       goto error;
;;;1702     }
;;;1703   
;;;1704     /* Check if the SPI is already enabled */
;;;1705     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1706     {
;;;1707       /* Enable SPI peripheral */
;;;1708       __HAL_SPI_ENABLE(hspi);
;;;1709     }
;;;1710   
;;;1711     /* Enable the SPI Error Interrupt Bit */
;;;1712     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1713   
;;;1714     /* Enable Tx DMA Request */
;;;1715     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;1716   
;;;1717   error :
;;;1718     /* Process Unlocked */
;;;1719     __HAL_UNLOCK(hspi);
;;;1720     return errorcode;
;;;1721   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L24.28|
00001c  2001              MOVS     r0,#1                 ;1636
00001e  f8840050          STRB     r0,[r4,#0x50]         ;1636
000022  bf00              NOP                            ;1636
000024  f8940051          LDRB     r0,[r4,#0x51]         ;1638
000028  2801              CMP      r0,#1                 ;1638
00002a  d001              BEQ      |L24.48|
00002c  2702              MOVS     r7,#2                 ;1640
00002e  e058              B        |L24.226|
                  |L24.48|
000030  b106              CBZ      r6,|L24.52|
000032  b90d              CBNZ     r5,|L24.56|
                  |L24.52|
000034  2701              MOVS     r7,#1                 ;1646
000036  e054              B        |L24.226|
                  |L24.56|
000038  2003              MOVS     r0,#3                 ;1651
00003a  f8840051          STRB     r0,[r4,#0x51]         ;1651
00003e  2000              MOVS     r0,#0                 ;1652
000040  6560              STR      r0,[r4,#0x54]         ;1652
000042  6326              STR      r6,[r4,#0x30]         ;1653
000044  86a5              STRH     r5,[r4,#0x34]         ;1654
000046  86e5              STRH     r5,[r4,#0x36]         ;1655
000048  63a0              STR      r0,[r4,#0x38]         ;1658
00004a  6460              STR      r0,[r4,#0x44]         ;1659
00004c  6420              STR      r0,[r4,#0x40]         ;1660
00004e  87a0              STRH     r0,[r4,#0x3c]         ;1661
000050  87e0              STRH     r0,[r4,#0x3e]         ;1662
000052  68a0              LDR      r0,[r4,#8]            ;1665
000054  f5b04f00          CMP      r0,#0x8000            ;1665
000058  d10b              BNE      |L24.114|
00005a  6820              LDR      r0,[r4,#0]            ;1668
00005c  6800              LDR      r0,[r0,#0]            ;1668
00005e  f0200040          BIC      r0,r0,#0x40           ;1668
000062  6821              LDR      r1,[r4,#0]            ;1668
000064  6008              STR      r0,[r1,#0]            ;1668
000066  6820              LDR      r0,[r4,#0]            ;1669
000068  6800              LDR      r0,[r0,#0]            ;1669
00006a  f4404080          ORR      r0,r0,#0x4000         ;1669
00006e  6821              LDR      r1,[r4,#0]            ;1669
000070  6008              STR      r0,[r1,#0]            ;1669
                  |L24.114|
000072  481f              LDR      r0,|L24.240|
000074  6ca1              LDR      r1,[r4,#0x48]         ;1681
000076  6408              STR      r0,[r1,#0x40]         ;1681
000078  481e              LDR      r0,|L24.244|
00007a  6ca1              LDR      r1,[r4,#0x48]         ;1684
00007c  63c8              STR      r0,[r1,#0x3c]         ;1684
00007e  481e              LDR      r0,|L24.248|
000080  6ca1              LDR      r1,[r4,#0x48]         ;1687
000082  64c8              STR      r0,[r1,#0x4c]         ;1687
000084  2000              MOVS     r0,#0                 ;1690
000086  6ca1              LDR      r1,[r4,#0x48]         ;1690
000088  6508              STR      r0,[r1,#0x50]         ;1690
00008a  8ee3              LDRH     r3,[r4,#0x36]         ;1693
00008c  f8d4c000          LDR      r12,[r4,#0]           ;1693
000090  f10c020c          ADD      r2,r12,#0xc           ;1693
000094  6b21              LDR      r1,[r4,#0x30]         ;1693
000096  6ca0              LDR      r0,[r4,#0x48]         ;1693
000098  f7fffffe          BL       HAL_DMA_Start_IT
00009c  b140              CBZ      r0,|L24.176|
00009e  6d60              LDR      r0,[r4,#0x54]         ;1697
0000a0  f0400010          ORR      r0,r0,#0x10           ;1697
0000a4  6560              STR      r0,[r4,#0x54]         ;1697
0000a6  2701              MOVS     r7,#1                 ;1698
0000a8  2001              MOVS     r0,#1                 ;1700
0000aa  f8840051          STRB     r0,[r4,#0x51]         ;1700
0000ae  e018              B        |L24.226|
                  |L24.176|
0000b0  6820              LDR      r0,[r4,#0]            ;1705
0000b2  6800              LDR      r0,[r0,#0]            ;1705
0000b4  f0000040          AND      r0,r0,#0x40           ;1705
0000b8  2840              CMP      r0,#0x40              ;1705
0000ba  d005              BEQ      |L24.200|
0000bc  6820              LDR      r0,[r4,#0]            ;1708
0000be  6800              LDR      r0,[r0,#0]            ;1708
0000c0  f0400040          ORR      r0,r0,#0x40           ;1708
0000c4  6821              LDR      r1,[r4,#0]            ;1708
0000c6  6008              STR      r0,[r1,#0]            ;1708
                  |L24.200|
0000c8  6820              LDR      r0,[r4,#0]            ;1712
0000ca  6840              LDR      r0,[r0,#4]            ;1712
0000cc  f0400020          ORR      r0,r0,#0x20           ;1712
0000d0  6821              LDR      r1,[r4,#0]            ;1712
0000d2  6048              STR      r0,[r1,#4]            ;1712
0000d4  6820              LDR      r0,[r4,#0]            ;1715
0000d6  6840              LDR      r0,[r0,#4]            ;1715
0000d8  f0400002          ORR      r0,r0,#2              ;1715
0000dc  6821              LDR      r1,[r4,#0]            ;1715
0000de  6048              STR      r0,[r1,#4]            ;1715
0000e0  bf00              NOP                            ;1717
                  |L24.226|
0000e2  bf00              NOP                            ;1719
0000e4  2000              MOVS     r0,#0                 ;1719
0000e6  f8840050          STRB     r0,[r4,#0x50]         ;1719
0000ea  bf00              NOP                            ;1719
0000ec  4638              MOV      r0,r7                 ;1720
0000ee  e793              B        |L24.24|
;;;1722   
                          ENDP

                  |L24.240|
                          DCD      SPI_DMAHalfTransmitCplt
                  |L24.244|
                          DCD      SPI_DMATransmitCplt
                  |L24.248|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_IT PROC
;;;1357     */
;;;1358   HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;1359   {
000002  4603              MOV      r3,r0
;;;1360     HAL_StatusTypeDef errorcode = HAL_OK;
000004  2400              MOVS     r4,#0
;;;1361   
;;;1362     /* Check Direction parameter */
;;;1363     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1364   
;;;1365     /* Process Locked */
;;;1366     __HAL_LOCK(hspi);
000006  bf00              NOP      
000008  f8930050          LDRB     r0,[r3,#0x50]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L25.20|
000010  2002              MOVS     r0,#2
                  |L25.18|
;;;1367   
;;;1368     if ((pData == NULL) || (Size == 0U))
;;;1369     {
;;;1370       errorcode = HAL_ERROR;
;;;1371       goto error;
;;;1372     }
;;;1373   
;;;1374     if (hspi->State != HAL_SPI_STATE_READY)
;;;1375     {
;;;1376       errorcode = HAL_BUSY;
;;;1377       goto error;
;;;1378     }
;;;1379   
;;;1380     /* Set the transaction information */
;;;1381     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1382     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1383     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1384     hspi->TxXferSize  = Size;
;;;1385     hspi->TxXferCount = Size;
;;;1386   
;;;1387     /* Init field not used in handle to zero */
;;;1388     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1389     hspi->RxXferSize  = 0U;
;;;1390     hspi->RxXferCount = 0U;
;;;1391     hspi->RxISR       = NULL;
;;;1392   
;;;1393     /* Set the function for IT treatment */
;;;1394     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1395     {
;;;1396       hspi->TxISR = SPI_TxISR_16BIT;
;;;1397     }
;;;1398     else
;;;1399     {
;;;1400       hspi->TxISR = SPI_TxISR_8BIT;
;;;1401     }
;;;1402   
;;;1403     /* Configure communication direction : 1Line */
;;;1404     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1405     {
;;;1406       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1407       __HAL_SPI_DISABLE(hspi);
;;;1408       SPI_1LINE_TX(hspi);
;;;1409     }
;;;1410   
;;;1411   #if (USE_SPI_CRC != 0U)
;;;1412     /* Reset CRC Calculation */
;;;1413     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1414     {
;;;1415       SPI_RESET_CRC(hspi);
;;;1416     }
;;;1417   #endif /* USE_SPI_CRC */
;;;1418   
;;;1419     /* Enable TXE and ERR interrupt */
;;;1420     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
;;;1421   
;;;1422   
;;;1423     /* Check if the SPI is already enabled */
;;;1424     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1425     {
;;;1426       /* Enable SPI peripheral */
;;;1427       __HAL_SPI_ENABLE(hspi);
;;;1428     }
;;;1429   
;;;1430   error :
;;;1431     __HAL_UNLOCK(hspi);
;;;1432     return errorcode;
;;;1433   }
000012  bd30              POP      {r4,r5,pc}
                  |L25.20|
000014  2001              MOVS     r0,#1                 ;1366
000016  f8830050          STRB     r0,[r3,#0x50]         ;1366
00001a  bf00              NOP                            ;1366
00001c  b101              CBZ      r1,|L25.32|
00001e  b90a              CBNZ     r2,|L25.36|
                  |L25.32|
000020  2401              MOVS     r4,#1                 ;1370
000022  e03b              B        |L25.156|
                  |L25.36|
000024  f8930051          LDRB     r0,[r3,#0x51]         ;1374
000028  2801              CMP      r0,#1                 ;1374
00002a  d001              BEQ      |L25.48|
00002c  2402              MOVS     r4,#2                 ;1376
00002e  e035              B        |L25.156|
                  |L25.48|
000030  2003              MOVS     r0,#3                 ;1381
000032  f8830051          STRB     r0,[r3,#0x51]         ;1381
000036  2000              MOVS     r0,#0                 ;1382
000038  6558              STR      r0,[r3,#0x54]         ;1382
00003a  6319              STR      r1,[r3,#0x30]         ;1383
00003c  869a              STRH     r2,[r3,#0x34]         ;1384
00003e  86da              STRH     r2,[r3,#0x36]         ;1385
000040  6398              STR      r0,[r3,#0x38]         ;1388
000042  8798              STRH     r0,[r3,#0x3c]         ;1389
000044  87d8              STRH     r0,[r3,#0x3e]         ;1390
000046  6418              STR      r0,[r3,#0x40]         ;1391
000048  68d8              LDR      r0,[r3,#0xc]          ;1394
00004a  b110              CBZ      r0,|L25.82|
00004c  4817              LDR      r0,|L25.172|
00004e  6458              STR      r0,[r3,#0x44]         ;1396
000050  e001              B        |L25.86|
                  |L25.82|
000052  4817              LDR      r0,|L25.176|
000054  6458              STR      r0,[r3,#0x44]         ;1400
                  |L25.86|
000056  6898              LDR      r0,[r3,#8]            ;1404
000058  f5b04f00          CMP      r0,#0x8000            ;1404
00005c  d10b              BNE      |L25.118|
00005e  6818              LDR      r0,[r3,#0]            ;1407
000060  6800              LDR      r0,[r0,#0]            ;1407
000062  f0200040          BIC      r0,r0,#0x40           ;1407
000066  681d              LDR      r5,[r3,#0]            ;1407
000068  6028              STR      r0,[r5,#0]            ;1407
00006a  6818              LDR      r0,[r3,#0]            ;1408
00006c  6800              LDR      r0,[r0,#0]            ;1408
00006e  f4404080          ORR      r0,r0,#0x4000         ;1408
000072  681d              LDR      r5,[r3,#0]            ;1408
000074  6028              STR      r0,[r5,#0]            ;1408
                  |L25.118|
000076  6818              LDR      r0,[r3,#0]            ;1420
000078  6840              LDR      r0,[r0,#4]            ;1420
00007a  f04000a0          ORR      r0,r0,#0xa0           ;1420
00007e  681d              LDR      r5,[r3,#0]            ;1420
000080  6068              STR      r0,[r5,#4]            ;1420
000082  6818              LDR      r0,[r3,#0]            ;1424
000084  6800              LDR      r0,[r0,#0]            ;1424
000086  f0000040          AND      r0,r0,#0x40           ;1424
00008a  2840              CMP      r0,#0x40              ;1424
00008c  d005              BEQ      |L25.154|
00008e  6818              LDR      r0,[r3,#0]            ;1427
000090  6800              LDR      r0,[r0,#0]            ;1427
000092  f0400040          ORR      r0,r0,#0x40           ;1427
000096  681d              LDR      r5,[r3,#0]            ;1427
000098  6028              STR      r0,[r5,#0]            ;1427
                  |L25.154|
00009a  bf00              NOP                            ;1430
                  |L25.156|
00009c  bf00              NOP                            ;1431
00009e  2000              MOVS     r0,#0                 ;1431
0000a0  f8830050          STRB     r0,[r3,#0x50]         ;1431
0000a4  bf00              NOP                            ;1431
0000a6  4620              MOV      r0,r4                 ;1432
0000a8  e7b3              B        |L25.18|
;;;1434   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L25.172|
                          DCD      SPI_TxISR_16BIT
                  |L25.176|
                          DCD      SPI_TxISR_8BIT

                          AREA ||i.HAL_SPI_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxCpltCallback PROC
;;;2486     */
;;;2487   __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2488   {
;;;2489     /* Prevent unused argument(s) compilation warning */
;;;2490     UNUSED(hspi);
;;;2491   
;;;2492     /* NOTE : This function should not be modified, when the callback is needed,
;;;2493               the HAL_SPI_TxCpltCallback should be implemented in the user file
;;;2494      */
;;;2495   }
;;;2496   
                          ENDP


                          AREA ||i.HAL_SPI_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxHalfCpltCallback PROC
;;;2534     */
;;;2535   __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2536   {
;;;2537     /* Prevent unused argument(s) compilation warning */
;;;2538     UNUSED(hspi);
;;;2539   
;;;2540     /* NOTE : This function should not be modified, when the callback is needed,
;;;2541               the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
;;;2542      */
;;;2543   }
;;;2544   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxCpltCallback PROC
;;;2518     */
;;;2519   __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2520   {
;;;2521     /* Prevent unused argument(s) compilation warning */
;;;2522     UNUSED(hspi);
;;;2523   
;;;2524     /* NOTE : This function should not be modified, when the callback is needed,
;;;2525               the HAL_SPI_TxRxCpltCallback should be implemented in the user file
;;;2526      */
;;;2527   }
;;;2528   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxHalfCpltCallback PROC
;;;2566     */
;;;2567   __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2568   {
;;;2569     /* Prevent unused argument(s) compilation warning */
;;;2570     UNUSED(hspi);
;;;2571   
;;;2572     /* NOTE : This function should not be modified, when the callback is needed,
;;;2573               the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
;;;2574      */
;;;2575   }
;;;2576   
                          ENDP


                          AREA ||i.SPI_2linesRxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_16BIT PROC
;;;3220     */
;;;3221   static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3222   {
000002  4604              MOV      r4,r0
;;;3223     /* Receive data in 16 Bit mode */
;;;3224     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  8008              STRH     r0,[r1,#0]
;;;3225     hspi->pRxBuffPtr += sizeof(uint16_t);
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c80              ADDS     r0,r0,#2
000010  63a0              STR      r0,[r4,#0x38]
;;;3226     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3227   
;;;3228     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b950              CBNZ     r0,|L30.50|
;;;3229     {
;;;3230   #if (USE_SPI_CRC != 0U)
;;;3231       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3232       {
;;;3233         hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
;;;3234         return;
;;;3235       }
;;;3236   #endif /* USE_SPI_CRC */
;;;3237   
;;;3238       /* Disable RXNE interrupt */
;;;3239       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f0200040          BIC      r0,r0,#0x40
000024  6821              LDR      r1,[r4,#0]
000026  6048              STR      r0,[r1,#4]
;;;3240   
;;;3241       if (hspi->TxXferCount == 0U)
000028  8ee0              LDRH     r0,[r4,#0x36]
00002a  b910              CBNZ     r0,|L30.50|
;;;3242       {
;;;3243         SPI_CloseRxTx_ISR(hspi);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L30.50|
;;;3244       }
;;;3245     }
;;;3246   }
000032  bd10              POP      {r4,pc}
;;;3247   
                          ENDP


                          AREA ||i.SPI_2linesRxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_8BIT PROC
;;;3121     */
;;;3122   static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3123   {
000002  4604              MOV      r4,r0
;;;3124     /* Receive data in 8bit mode */
;;;3125     *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  7b00              LDRB     r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  7008              STRB     r0,[r1,#0]
;;;3126     hspi->pRxBuffPtr++;
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c40              ADDS     r0,r0,#1
000010  63a0              STR      r0,[r4,#0x38]
;;;3127     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3128   
;;;3129     /* Check end of the reception */
;;;3130     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b950              CBNZ     r0,|L31.50|
;;;3131     {
;;;3132   #if (USE_SPI_CRC != 0U)
;;;3133       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3134       {
;;;3135         hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
;;;3136         return;
;;;3137       }
;;;3138   #endif /* USE_SPI_CRC */
;;;3139   
;;;3140       /* Disable RXNE  and ERR interrupt */
;;;3141       __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f0200060          BIC      r0,r0,#0x60
000024  6821              LDR      r1,[r4,#0]
000026  6048              STR      r0,[r1,#4]
;;;3142   
;;;3143       if (hspi->TxXferCount == 0U)
000028  8ee0              LDRH     r0,[r4,#0x36]
00002a  b910              CBNZ     r0,|L31.50|
;;;3144       {
;;;3145         SPI_CloseRxTx_ISR(hspi);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L31.50|
;;;3146       }
;;;3147     }
;;;3148   }
000032  bd10              POP      {r4,pc}
;;;3149   
                          ENDP


                          AREA ||i.SPI_2linesTxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_16BIT PROC
;;;3276     */
;;;3277   static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3278   {
000002  4604              MOV      r4,r0
;;;3279     /* Transmit data in 16 Bit mode */
;;;3280     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  8800              LDRH     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  60c8              STR      r0,[r1,#0xc]
;;;3281     hspi->pTxBuffPtr += sizeof(uint16_t);
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c80              ADDS     r0,r0,#2
000010  6320              STR      r0,[r4,#0x30]
;;;3282     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3283   
;;;3284     /* Enable CRC Transmission */
;;;3285     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b950              CBNZ     r0,|L32.50|
;;;3286     {
;;;3287   #if (USE_SPI_CRC != 0U)
;;;3288       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3289       {
;;;3290         /* Set CRC Next Bit to send CRC */
;;;3291         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3292         /* Disable TXE interrupt */
;;;3293         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3294         return;
;;;3295       }
;;;3296   #endif /* USE_SPI_CRC */
;;;3297   
;;;3298       /* Disable TXE interrupt */
;;;3299       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6048              STR      r0,[r1,#4]
;;;3300   
;;;3301       if (hspi->RxXferCount == 0U)
000028  8fe0              LDRH     r0,[r4,#0x3e]
00002a  b910              CBNZ     r0,|L32.50|
;;;3302       {
;;;3303         SPI_CloseRxTx_ISR(hspi);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L32.50|
;;;3304       }
;;;3305     }
;;;3306   }
000032  bd10              POP      {r4,pc}
;;;3307   
                          ENDP


                          AREA ||i.SPI_2linesTxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_8BIT PROC
;;;3184     */
;;;3185   static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3186   {
000002  4604              MOV      r4,r0
;;;3187     *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  7800              LDRB     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  7308              STRB     r0,[r1,#0xc]
;;;3188     hspi->pTxBuffPtr++;
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c40              ADDS     r0,r0,#1
000010  6320              STR      r0,[r4,#0x30]
;;;3189     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3190   
;;;3191     /* Check the end of the transmission */
;;;3192     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b950              CBNZ     r0,|L33.50|
;;;3193     {
;;;3194   #if (USE_SPI_CRC != 0U)
;;;3195       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3196       {
;;;3197         /* Set CRC Next Bit to send CRC */
;;;3198         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3199         /* Disable TXE interrupt */
;;;3200         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3201         return;
;;;3202       }
;;;3203   #endif /* USE_SPI_CRC */
;;;3204   
;;;3205       /* Disable TXE interrupt */
;;;3206       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6048              STR      r0,[r1,#4]
;;;3207   
;;;3208       if (hspi->RxXferCount == 0U)
000028  8fe0              LDRH     r0,[r4,#0x3e]
00002a  b910              CBNZ     r0,|L33.50|
;;;3209       {
;;;3210         SPI_CloseRxTx_ISR(hspi);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L33.50|
;;;3211       }
;;;3212     }
;;;3213   }
000032  bd10              POP      {r4,pc}
;;;3214   
                          ENDP


                          AREA ||i.SPI_AbortRx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_AbortRx_ISR PROC
;;;3856     */
;;;3857   static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
000000  b50c              PUSH     {r2,r3,lr}
;;;3858   {
;;;3859     __IO uint32_t tmpreg = 0U;
000002  2100              MOVS     r1,#0
000004  9101              STR      r1,[sp,#4]
;;;3860     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000006  4919              LDR      r1,|L34.108|
000008  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00000a  2218              MOVS     r2,#0x18
00000c  fbb1f1f2          UDIV     r1,r1,r2
000010  f44f727a          MOV      r2,#0x3e8
000014  fbb1f1f2          UDIV     r1,r1,r2
000018  2264              MOVS     r2,#0x64
00001a  4351              MULS     r1,r2,r1
00001c  9100              STR      r1,[sp,#0]
;;;3861   
;;;3862     /* Wait until TXE flag is set */
;;;3863     do
00001e  bf00              NOP      
                  |L34.32|
;;;3864     {
;;;3865       if (count == 0U)
000020  9900              LDR      r1,[sp,#0]
000022  b921              CBNZ     r1,|L34.46|
;;;3866       {
;;;3867         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000024  6d41              LDR      r1,[r0,#0x54]
000026  f0410140          ORR      r1,r1,#0x40
00002a  6541              STR      r1,[r0,#0x54]
;;;3868         break;
00002c  e008              B        |L34.64|
                  |L34.46|
;;;3869       }
;;;3870       count--;
00002e  9900              LDR      r1,[sp,#0]
000030  1e49              SUBS     r1,r1,#1
000032  9100              STR      r1,[sp,#0]
;;;3871     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000034  6801              LDR      r1,[r0,#0]
000036  6889              LDR      r1,[r1,#8]
000038  f0010102          AND      r1,r1,#2
00003c  2900              CMP      r1,#0
00003e  d0ef              BEQ      |L34.32|
                  |L34.64|
000040  bf00              NOP                            ;3868
;;;3872   
;;;3873     /* Disable SPI Peripheral */
;;;3874     __HAL_SPI_DISABLE(hspi);
000042  6801              LDR      r1,[r0,#0]
000044  6809              LDR      r1,[r1,#0]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6802              LDR      r2,[r0,#0]
00004c  6011              STR      r1,[r2,#0]
;;;3875   
;;;3876     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;3877     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
00004e  6801              LDR      r1,[r0,#0]
000050  6849              LDR      r1,[r1,#4]
000052  f02101e0          BIC      r1,r1,#0xe0
000056  6802              LDR      r2,[r0,#0]
000058  6051              STR      r1,[r2,#4]
;;;3878   
;;;3879     /* Flush Data Register by a blank read */
;;;3880     tmpreg = READ_REG(hspi->Instance->DR);
00005a  6801              LDR      r1,[r0,#0]
00005c  68c9              LDR      r1,[r1,#0xc]
00005e  9101              STR      r1,[sp,#4]
;;;3881     /* To avoid GCC warning */
;;;3882     UNUSED(tmpreg);
000060  bf00              NOP      
;;;3883   
;;;3884     hspi->State = HAL_SPI_STATE_ABORT;
000062  2107              MOVS     r1,#7
000064  f8801051          STRB     r1,[r0,#0x51]
;;;3885   }
000068  bd0c              POP      {r2,r3,pc}
;;;3886   
                          ENDP

00006a  0000              DCW      0x0000
                  |L34.108|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_AbortTx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_AbortTx_ISR PROC
;;;3892     */
;;;3893   static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3894   {
;;;3895     /* Disable TXEIE interrupt */
;;;3896     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE));
000002  6849              LDR      r1,[r1,#4]
000004  f0210180          BIC      r1,r1,#0x80
000008  6802              LDR      r2,[r0,#0]
00000a  6051              STR      r1,[r2,#4]
;;;3897   
;;;3898     /* Disable SPI Peripheral */
;;;3899     __HAL_SPI_DISABLE(hspi);
00000c  6801              LDR      r1,[r0,#0]
00000e  6809              LDR      r1,[r1,#0]
000010  f0210140          BIC      r1,r1,#0x40
000014  6802              LDR      r2,[r0,#0]
000016  6011              STR      r1,[r2,#0]
;;;3900   
;;;3901     hspi->State = HAL_SPI_STATE_ABORT;
000018  2107              MOVS     r1,#7
00001a  f8801051          STRB     r1,[r0,#0x51]
;;;3902   }
00001e  4770              BX       lr
;;;3903   
                          ENDP


                          AREA ||i.SPI_CloseRxTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseRxTx_ISR PROC
;;;3637     */
;;;3638   static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
000000  b57c              PUSH     {r2-r6,lr}
;;;3639   {
000002  4604              MOV      r4,r0
;;;3640     uint32_t tickstart;
;;;3641     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  482c              LDR      r0,|L36.184|
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  2118              MOVS     r1,#0x18
00000a  fbb0f0f1          UDIV     r0,r0,r1
00000e  f44f717a          MOV      r1,#0x3e8
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  2164              MOVS     r1,#0x64
000018  4348              MULS     r0,r1,r0
00001a  9001              STR      r0,[sp,#4]
;;;3642   
;;;3643     /* Init tickstart for timeout management */
;;;3644     tickstart = HAL_GetTick();
00001c  f7fffffe          BL       HAL_GetTick
000020  4605              MOV      r5,r0
;;;3645   
;;;3646     /* Disable ERR interrupt */
;;;3647     __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
000022  6820              LDR      r0,[r4,#0]
000024  6840              LDR      r0,[r0,#4]
000026  f0200020          BIC      r0,r0,#0x20
00002a  6821              LDR      r1,[r4,#0]
00002c  6048              STR      r0,[r1,#4]
;;;3648   
;;;3649     /* Wait until TXE flag is set */
;;;3650     do
00002e  bf00              NOP      
                  |L36.48|
;;;3651     {
;;;3652       if (count == 0U)
000030  9801              LDR      r0,[sp,#4]
000032  b920              CBNZ     r0,|L36.62|
;;;3653       {
;;;3654         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000034  6d60              LDR      r0,[r4,#0x54]
000036  f0400020          ORR      r0,r0,#0x20
00003a  6560              STR      r0,[r4,#0x54]
;;;3655         break;
00003c  e008              B        |L36.80|
                  |L36.62|
;;;3656       }
;;;3657       count--;
00003e  9801              LDR      r0,[sp,#4]
000040  1e40              SUBS     r0,r0,#1
000042  9001              STR      r0,[sp,#4]
;;;3658     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000044  6820              LDR      r0,[r4,#0]
000046  6880              LDR      r0,[r0,#8]
000048  f0000002          AND      r0,r0,#2
00004c  2800              CMP      r0,#0
00004e  d0ef              BEQ      |L36.48|
                  |L36.80|
000050  bf00              NOP                            ;3655
;;;3659   
;;;3660     /* Check the end of the transaction */
;;;3661     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000052  462a              MOV      r2,r5
000054  2164              MOVS     r1,#0x64
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       SPI_EndRxTxTransaction
00005c  b118              CBZ      r0,|L36.102|
;;;3662     {
;;;3663       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00005e  6d60              LDR      r0,[r4,#0x54]
000060  f0400020          ORR      r0,r0,#0x20
000064  6560              STR      r0,[r4,#0x54]
                  |L36.102|
;;;3664     }
;;;3665   
;;;3666     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3667     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000066  68a0              LDR      r0,[r4,#8]
000068  b950              CBNZ     r0,|L36.128|
;;;3668     {
;;;3669       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00006a  bf00              NOP      
00006c  2000              MOVS     r0,#0
00006e  9000              STR      r0,[sp,#0]
000070  6820              LDR      r0,[r4,#0]
000072  68c0              LDR      r0,[r0,#0xc]
000074  9000              STR      r0,[sp,#0]
000076  6820              LDR      r0,[r4,#0]
000078  6880              LDR      r0,[r0,#8]
00007a  9000              STR      r0,[sp,#0]
00007c  bf00              NOP      
00007e  bf00              NOP      
                  |L36.128|
;;;3670     }
;;;3671   
;;;3672   #if (USE_SPI_CRC != 0U)
;;;3673     /* Check if CRC error occurred */
;;;3674     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;3675     {
;;;3676       hspi->State = HAL_SPI_STATE_READY;
;;;3677       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;3678       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;3679       /* Call user error callback */
;;;3680   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3681       hspi->ErrorCallback(hspi);
;;;3682   #else
;;;3683       HAL_SPI_ErrorCallback(hspi);
;;;3684   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3685     }
;;;3686     else
;;;3687     {
;;;3688   #endif /* USE_SPI_CRC */
;;;3689       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
000080  6d60              LDR      r0,[r4,#0x54]
000082  b988              CBNZ     r0,|L36.168|
;;;3690       {
;;;3691         if (hspi->State == HAL_SPI_STATE_BUSY_RX)
000084  f8940051          LDRB     r0,[r4,#0x51]
000088  2804              CMP      r0,#4
00008a  d106              BNE      |L36.154|
;;;3692         {
;;;3693           hspi->State = HAL_SPI_STATE_READY;
00008c  2001              MOVS     r0,#1
00008e  f8840051          STRB     r0,[r4,#0x51]
;;;3694           /* Call user Rx complete callback */
;;;3695   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3696           hspi->RxCpltCallback(hspi);
;;;3697   #else
;;;3698           HAL_SPI_RxCpltCallback(hspi);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       HAL_SPI_RxCpltCallback
000098  e00c              B        |L36.180|
                  |L36.154|
;;;3699   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3700         }
;;;3701         else
;;;3702         {
;;;3703           hspi->State = HAL_SPI_STATE_READY;
00009a  2001              MOVS     r0,#1
00009c  f8840051          STRB     r0,[r4,#0x51]
;;;3704           /* Call user TxRx complete callback */
;;;3705   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3706           hspi->TxRxCpltCallback(hspi);
;;;3707   #else
;;;3708           HAL_SPI_TxRxCpltCallback(hspi);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
0000a6  e005              B        |L36.180|
                  |L36.168|
;;;3709   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3710         }
;;;3711       }
;;;3712       else
;;;3713       {
;;;3714         hspi->State = HAL_SPI_STATE_READY;
0000a8  2001              MOVS     r0,#1
0000aa  f8840051          STRB     r0,[r4,#0x51]
;;;3715         /* Call user error callback */
;;;3716   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3717         hspi->ErrorCallback(hspi);
;;;3718   #else
;;;3719         HAL_SPI_ErrorCallback(hspi);
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L36.180|
;;;3720   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3721       }
;;;3722   #if (USE_SPI_CRC != 0U)
;;;3723     }
;;;3724   #endif /* USE_SPI_CRC */
;;;3725   }
0000b4  bd7c              POP      {r2-r6,pc}
;;;3726   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L36.184|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_CloseRx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_CloseRx_ISR PROC
;;;3732     */
;;;3733   static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
000000  b538              PUSH     {r3-r5,lr}
;;;3734   {
000002  4604              MOV      r4,r0
;;;3735     /* Disable RXNE and ERR interrupt */
;;;3736     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  f0200060          BIC      r0,r0,#0x60
00000c  6821              LDR      r1,[r4,#0]
00000e  6048              STR      r0,[r1,#4]
;;;3737   
;;;3738     /* Check the end of the transaction */
;;;3739     if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000010  f7fffffe          BL       HAL_GetTick
000014  4605              MOV      r5,r0
000016  462a              MOV      r2,r5
000018  2164              MOVS     r1,#0x64
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_EndRxTransaction
000020  b118              CBZ      r0,|L37.42|
;;;3740     {
;;;3741       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000022  6d60              LDR      r0,[r4,#0x54]
000024  f0400020          ORR      r0,r0,#0x20
000028  6560              STR      r0,[r4,#0x54]
                  |L37.42|
;;;3742     }
;;;3743   
;;;3744     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3745     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
00002a  68a0              LDR      r0,[r4,#8]
00002c  b950              CBNZ     r0,|L37.68|
;;;3746     {
;;;3747       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00002e  bf00              NOP      
000030  2000              MOVS     r0,#0
000032  9000              STR      r0,[sp,#0]
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  9000              STR      r0,[sp,#0]
00003a  6820              LDR      r0,[r4,#0]
00003c  6880              LDR      r0,[r0,#8]
00003e  9000              STR      r0,[sp,#0]
000040  bf00              NOP      
000042  bf00              NOP      
                  |L37.68|
;;;3748     }
;;;3749     hspi->State = HAL_SPI_STATE_READY;
000044  2001              MOVS     r0,#1
000046  f8840051          STRB     r0,[r4,#0x51]
;;;3750   
;;;3751   #if (USE_SPI_CRC != 0U)
;;;3752     /* Check if CRC error occurred */
;;;3753     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;3754     {
;;;3755       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;3756       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;3757       /* Call user error callback */
;;;3758   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3759       hspi->ErrorCallback(hspi);
;;;3760   #else
;;;3761       HAL_SPI_ErrorCallback(hspi);
;;;3762   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3763     }
;;;3764     else
;;;3765     {
;;;3766   #endif /* USE_SPI_CRC */
;;;3767       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
00004a  6d60              LDR      r0,[r4,#0x54]
00004c  b918              CBNZ     r0,|L37.86|
;;;3768       {
;;;3769         /* Call user Rx complete callback */
;;;3770   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3771         hspi->RxCpltCallback(hspi);
;;;3772   #else
;;;3773         HAL_SPI_RxCpltCallback(hspi);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_SPI_RxCpltCallback
000054  e002              B        |L37.92|
                  |L37.86|
;;;3774   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3775       }
;;;3776       else
;;;3777       {
;;;3778         /* Call user error callback */
;;;3779   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3780         hspi->ErrorCallback(hspi);
;;;3781   #else
;;;3782         HAL_SPI_ErrorCallback(hspi);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L37.92|
;;;3783   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3784       }
;;;3785   #if (USE_SPI_CRC != 0U)
;;;3786     }
;;;3787   #endif /* USE_SPI_CRC */
;;;3788   }
00005c  bd38              POP      {r3-r5,pc}
;;;3789   
                          ENDP


                          AREA ||i.SPI_CloseTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseTx_ISR PROC
;;;3795     */
;;;3796   static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
000000  b57c              PUSH     {r2-r6,lr}
;;;3797   {
000002  4604              MOV      r4,r0
;;;3798     uint32_t tickstart;
;;;3799     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  4825              LDR      r0,|L38.156|
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  2118              MOVS     r1,#0x18
00000a  fbb0f0f1          UDIV     r0,r0,r1
00000e  f44f717a          MOV      r1,#0x3e8
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  2164              MOVS     r1,#0x64
000018  4348              MULS     r0,r1,r0
00001a  9001              STR      r0,[sp,#4]
;;;3800   
;;;3801     /* Init tickstart for timeout management*/
;;;3802     tickstart = HAL_GetTick();
00001c  f7fffffe          BL       HAL_GetTick
000020  4605              MOV      r5,r0
;;;3803   
;;;3804     /* Wait until TXE flag is set */
;;;3805     do
000022  bf00              NOP      
                  |L38.36|
;;;3806     {
;;;3807       if (count == 0U)
000024  9801              LDR      r0,[sp,#4]
000026  b920              CBNZ     r0,|L38.50|
;;;3808       {
;;;3809         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000028  6d60              LDR      r0,[r4,#0x54]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6560              STR      r0,[r4,#0x54]
;;;3810         break;
000030  e008              B        |L38.68|
                  |L38.50|
;;;3811       }
;;;3812       count--;
000032  9801              LDR      r0,[sp,#4]
000034  1e40              SUBS     r0,r0,#1
000036  9001              STR      r0,[sp,#4]
;;;3813     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000038  6820              LDR      r0,[r4,#0]
00003a  6880              LDR      r0,[r0,#8]
00003c  f0000002          AND      r0,r0,#2
000040  2800              CMP      r0,#0
000042  d0ef              BEQ      |L38.36|
                  |L38.68|
000044  bf00              NOP                            ;3810
;;;3814   
;;;3815     /* Disable TXE and ERR interrupt */
;;;3816     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
000046  6820              LDR      r0,[r4,#0]
000048  6840              LDR      r0,[r0,#4]
00004a  f02000a0          BIC      r0,r0,#0xa0
00004e  6821              LDR      r1,[r4,#0]
000050  6048              STR      r0,[r1,#4]
;;;3817   
;;;3818     /* Check the end of the transaction */
;;;3819     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000052  462a              MOV      r2,r5
000054  2164              MOVS     r1,#0x64
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       SPI_EndRxTxTransaction
00005c  b118              CBZ      r0,|L38.102|
;;;3820     {
;;;3821       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00005e  6d60              LDR      r0,[r4,#0x54]
000060  f0400020          ORR      r0,r0,#0x20
000064  6560              STR      r0,[r4,#0x54]
                  |L38.102|
;;;3822     }
;;;3823   
;;;3824     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3825     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000066  68a0              LDR      r0,[r4,#8]
000068  b950              CBNZ     r0,|L38.128|
;;;3826     {
;;;3827       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00006a  bf00              NOP      
00006c  2000              MOVS     r0,#0
00006e  9000              STR      r0,[sp,#0]
000070  6820              LDR      r0,[r4,#0]
000072  68c0              LDR      r0,[r0,#0xc]
000074  9000              STR      r0,[sp,#0]
000076  6820              LDR      r0,[r4,#0]
000078  6880              LDR      r0,[r0,#8]
00007a  9000              STR      r0,[sp,#0]
00007c  bf00              NOP      
00007e  bf00              NOP      
                  |L38.128|
;;;3828     }
;;;3829   
;;;3830     hspi->State = HAL_SPI_STATE_READY;
000080  2001              MOVS     r0,#1
000082  f8840051          STRB     r0,[r4,#0x51]
;;;3831     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000086  6d60              LDR      r0,[r4,#0x54]
000088  b118              CBZ      r0,|L38.146|
;;;3832     {
;;;3833       /* Call user error callback */
;;;3834   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3835       hspi->ErrorCallback(hspi);
;;;3836   #else
;;;3837       HAL_SPI_ErrorCallback(hspi);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_SPI_ErrorCallback
000090  e002              B        |L38.152|
                  |L38.146|
;;;3838   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3839     }
;;;3840     else
;;;3841     {
;;;3842       /* Call user Rx complete callback */
;;;3843   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3844       hspi->TxCpltCallback(hspi);
;;;3845   #else
;;;3846       HAL_SPI_TxCpltCallback(hspi);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       HAL_SPI_TxCpltCallback
                  |L38.152|
;;;3847   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3848     }
;;;3849   }
000098  bd7c              POP      {r2-r6,pc}
;;;3850   
                          ENDP

00009a  0000              DCW      0x0000
                  |L38.156|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  SPI_DMAAbortOnError PROC
;;;2975     */
;;;2976   static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2977   {
000002  4605              MOV      r5,r0
;;;2978     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2979     hspi->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  87e0              STRH     r0,[r4,#0x3e]
;;;2980     hspi->TxXferCount = 0U;
00000a  86e0              STRH     r0,[r4,#0x36]
;;;2981   
;;;2982     /* Call user error callback */
;;;2983   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2984     hspi->ErrorCallback(hspi);
;;;2985   #else
;;;2986     HAL_SPI_ErrorCallback(hspi);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2987   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2988   }
000012  bd70              POP      {r4-r6,pc}
;;;2989   
                          ENDP


                          AREA ||i.SPI_DMAError||, CODE, READONLY, ALIGN=1

                  SPI_DMAError PROC
;;;2952     */
;;;2953   static void SPI_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2954   {
000002  4605              MOV      r5,r0
;;;2955     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2956   
;;;2957     /* Stop the disable DMA transfer on SPI side */
;;;2958     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000006  6820              LDR      r0,[r4,#0]
000008  6840              LDR      r0,[r0,#4]
00000a  f0200003          BIC      r0,r0,#3
00000e  6821              LDR      r1,[r4,#0]
000010  6048              STR      r0,[r1,#4]
;;;2959   
;;;2960     SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000012  6d60              LDR      r0,[r4,#0x54]
000014  f0400010          ORR      r0,r0,#0x10
000018  6560              STR      r0,[r4,#0x54]
;;;2961     hspi->State = HAL_SPI_STATE_READY;
00001a  2001              MOVS     r0,#1
00001c  f8840051          STRB     r0,[r4,#0x51]
;;;2962     /* Call user error callback */
;;;2963   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2964     hspi->ErrorCallback(hspi);
;;;2965   #else
;;;2966     HAL_SPI_ErrorCallback(hspi);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2967   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2968   }
000026  bd70              POP      {r4-r6,pc}
;;;2969   
                          ENDP


                          AREA ||i.SPI_DMAHalfReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfReceiveCplt PROC
;;;2916     */
;;;2917   static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2918   {
000002  4604              MOV      r4,r0
;;;2919     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2920   
;;;2921     /* Call user Rx half complete callback */
;;;2922   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2923     hspi->RxHalfCpltCallback(hspi);
;;;2924   #else
;;;2925     HAL_SPI_RxHalfCpltCallback(hspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_SPI_RxHalfCpltCallback
;;;2926   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2927   }
00000c  bd70              POP      {r4-r6,pc}
;;;2928   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitCplt PROC
;;;2898     */
;;;2899   static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2900   {
000002  4604              MOV      r4,r0
;;;2901     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2902   
;;;2903     /* Call user Tx half complete callback */
;;;2904   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2905     hspi->TxHalfCpltCallback(hspi);
;;;2906   #else
;;;2907     HAL_SPI_TxHalfCpltCallback(hspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_SPI_TxHalfCpltCallback
;;;2908   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2909   }
00000c  bd70              POP      {r4-r6,pc}
;;;2910   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitReceiveCplt PROC
;;;2934     */
;;;2935   static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2936   {
000002  4604              MOV      r4,r0
;;;2937     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2938   
;;;2939     /* Call user TxRx half complete callback */
;;;2940   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2941     hspi->TxRxHalfCpltCallback(hspi);
;;;2942   #else
;;;2943     HAL_SPI_TxRxHalfCpltCallback(hspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_SPI_TxRxHalfCpltCallback
;;;2944   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2945   }
00000c  bd70              POP      {r4-r6,pc}
;;;2946   
                          ENDP


                          AREA ||i.SPI_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAReceiveCplt PROC
;;;2729     */
;;;2730   static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2731   {
000002  4605              MOV      r5,r0
;;;2732     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2733     uint32_t tickstart;
;;;2734   #if (USE_SPI_CRC != 0U)
;;;2735     __IO uint32_t tmpreg = 0U;
;;;2736   #endif /* USE_SPI_CRC */
;;;2737   
;;;2738     /* Init tickstart for timeout management*/
;;;2739     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2740   
;;;2741     /* DMA Normal Mode */
;;;2742     if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f4007080          AND      r0,r0,#0x100
000014  f5b07f80          CMP      r0,#0x100
000018  d02b              BEQ      |L44.114|
;;;2743     {
;;;2744       /* Disable ERR interrupt */
;;;2745       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f0200020          BIC      r0,r0,#0x20
000022  6821              LDR      r1,[r4,#0]
000024  6048              STR      r0,[r1,#4]
;;;2746   
;;;2747   #if (USE_SPI_CRC != 0U)
;;;2748       /* CRC handling */
;;;2749       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2750       {
;;;2751         /* Wait until RXNE flag */
;;;2752         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
;;;2753         {
;;;2754           /* Error on the CRC reception */
;;;2755           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2756         }
;;;2757         /* Read CRC */
;;;2758         tmpreg = READ_REG(hspi->Instance->DR);
;;;2759         /* To avoid GCC warning */
;;;2760         UNUSED(tmpreg);
;;;2761       }
;;;2762   #endif /* USE_SPI_CRC */
;;;2763   
;;;2764       /* Check if we are in Master RX 2 line mode */
;;;2765       if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
000026  68a0              LDR      r0,[r4,#8]
000028  b950              CBNZ     r0,|L44.64|
00002a  6860              LDR      r0,[r4,#4]
00002c  f5b07f82          CMP      r0,#0x104
000030  d106              BNE      |L44.64|
;;;2766       {
;;;2767         /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
;;;2768         CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000032  6820              LDR      r0,[r4,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f0200003          BIC      r0,r0,#3
00003a  6821              LDR      r1,[r4,#0]
00003c  6048              STR      r0,[r1,#4]
00003e  e005              B        |L44.76|
                  |L44.64|
;;;2769       }
;;;2770       else
;;;2771       {
;;;2772         /* Normal case */
;;;2773         CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
000040  6820              LDR      r0,[r4,#0]
000042  6840              LDR      r0,[r0,#4]
000044  f0200001          BIC      r0,r0,#1
000048  6821              LDR      r1,[r4,#0]
00004a  6048              STR      r0,[r1,#4]
                  |L44.76|
;;;2774       }
;;;2775   
;;;2776       /* Check the end of the transaction */
;;;2777       if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00004c  4632              MOV      r2,r6
00004e  2164              MOVS     r1,#0x64
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       SPI_EndRxTransaction
000056  b108              CBZ      r0,|L44.92|
;;;2778       {
;;;2779         hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
000058  2020              MOVS     r0,#0x20
00005a  6560              STR      r0,[r4,#0x54]
                  |L44.92|
;;;2780       }
;;;2781   
;;;2782       hspi->RxXferCount = 0U;
00005c  2000              MOVS     r0,#0
00005e  87e0              STRH     r0,[r4,#0x3e]
;;;2783       hspi->State = HAL_SPI_STATE_READY;
000060  2001              MOVS     r0,#1
000062  f8840051          STRB     r0,[r4,#0x51]
;;;2784   
;;;2785   #if (USE_SPI_CRC != 0U)
;;;2786       /* Check if CRC error occurred */
;;;2787       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
;;;2788       {
;;;2789         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2790         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;2791       }
;;;2792   #endif /* USE_SPI_CRC */
;;;2793   
;;;2794       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000066  6d60              LDR      r0,[r4,#0x54]
000068  b118              CBZ      r0,|L44.114|
;;;2795       {
;;;2796         /* Call user error callback */
;;;2797   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2798         hspi->ErrorCallback(hspi);
;;;2799   #else
;;;2800         HAL_SPI_ErrorCallback(hspi);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L44.112|
;;;2801   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2802         return;
;;;2803       }
;;;2804     }
;;;2805     /* Call user Rx complete callback */
;;;2806   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2807     hspi->RxCpltCallback(hspi);
;;;2808   #else
;;;2809     HAL_SPI_RxCpltCallback(hspi);
;;;2810   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2811   }
000070  bd70              POP      {r4-r6,pc}
                  |L44.114|
000072  4620              MOV      r0,r4                 ;2809
000074  f7fffffe          BL       HAL_SPI_RxCpltCallback
000078  bf00              NOP      
00007a  e7f9              B        |L44.112|
;;;2812   
                          ENDP


                          AREA ||i.SPI_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  SPI_DMARxAbortCallback PROC
;;;3062     */
;;;3063   static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3064   {
000002  4605              MOV      r5,r0
;;;3065     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;3066   
;;;3067     /* Disable SPI Peripheral */
;;;3068     __HAL_SPI_DISABLE(hspi);
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f0200040          BIC      r0,r0,#0x40
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;3069   
;;;3070     hspi->hdmarx->XferAbortCallback = NULL;
000012  2000              MOVS     r0,#0
000014  6ce1              LDR      r1,[r4,#0x4c]
000016  6508              STR      r0,[r1,#0x50]
;;;3071   
;;;3072     /* Disable Rx DMA Request */
;;;3073     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  f0200001          BIC      r0,r0,#1
000020  6821              LDR      r1,[r4,#0]
000022  6048              STR      r0,[r1,#4]
;;;3074   
;;;3075     /* Check Busy flag */
;;;3076     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000024  f7fffffe          BL       HAL_GetTick
000028  4606              MOV      r6,r0
00002a  4632              MOV      r2,r6
00002c  2164              MOVS     r1,#0x64
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SPI_EndRxTxTransaction
000034  b118              CBZ      r0,|L45.62|
;;;3077     {
;;;3078       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000036  6d60              LDR      r0,[r4,#0x54]
000038  f0400040          ORR      r0,r0,#0x40
00003c  6560              STR      r0,[r4,#0x54]
                  |L45.62|
;;;3079     }
;;;3080   
;;;3081     /* Check if an Abort process is still ongoing */
;;;3082     if (hspi->hdmatx != NULL)
00003e  6ca0              LDR      r0,[r4,#0x48]
000040  b118              CBZ      r0,|L45.74|
;;;3083     {
;;;3084       if (hspi->hdmatx->XferAbortCallback != NULL)
000042  6ca0              LDR      r0,[r4,#0x48]
000044  6d00              LDR      r0,[r0,#0x50]
000046  b100              CBZ      r0,|L45.74|
                  |L45.72|
;;;3085       {
;;;3086         return;
;;;3087       }
;;;3088     }
;;;3089   
;;;3090     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;3091     hspi->RxXferCount = 0U;
;;;3092     hspi->TxXferCount = 0U;
;;;3093   
;;;3094     /* Check no error during Abort procedure */
;;;3095     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
;;;3096     {
;;;3097       /* Reset errorCode */
;;;3098       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;3099     }
;;;3100   
;;;3101     /* Clear the Error flags in the SR register */
;;;3102     __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;3103     __HAL_SPI_CLEAR_FREFLAG(hspi);
;;;3104   
;;;3105     /* Restore hspi->State to Ready */
;;;3106     hspi->State  = HAL_SPI_STATE_READY;
;;;3107   
;;;3108     /* Call user Abort complete callback */
;;;3109   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3110     hspi->AbortCpltCallback(hspi);
;;;3111   #else
;;;3112     HAL_SPI_AbortCpltCallback(hspi);
;;;3113   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3114   }
000048  bdf8              POP      {r3-r7,pc}
                  |L45.74|
00004a  2000              MOVS     r0,#0                 ;3091
00004c  87e0              STRH     r0,[r4,#0x3e]         ;3091
00004e  86e0              STRH     r0,[r4,#0x36]         ;3092
000050  6d60              LDR      r0,[r4,#0x54]         ;3095
000052  2840              CMP      r0,#0x40              ;3095
000054  d001              BEQ      |L45.90|
000056  2000              MOVS     r0,#0                 ;3098
000058  6560              STR      r0,[r4,#0x54]         ;3098
                  |L45.90|
00005a  bf00              NOP                            ;3102
00005c  2000              MOVS     r0,#0                 ;3102
00005e  9000              STR      r0,[sp,#0]            ;3102
000060  6820              LDR      r0,[r4,#0]            ;3102
000062  68c0              LDR      r0,[r0,#0xc]          ;3102
000064  9000              STR      r0,[sp,#0]            ;3102
000066  6820              LDR      r0,[r4,#0]            ;3102
000068  6880              LDR      r0,[r0,#8]            ;3102
00006a  9000              STR      r0,[sp,#0]            ;3102
00006c  bf00              NOP                            ;3102
00006e  bf00              NOP                            ;3102
000070  bf00              NOP                            ;3103
000072  2000              MOVS     r0,#0                 ;3103
000074  9000              STR      r0,[sp,#0]            ;3103
000076  6820              LDR      r0,[r4,#0]            ;3103
000078  6880              LDR      r0,[r0,#8]            ;3103
00007a  9000              STR      r0,[sp,#0]            ;3103
00007c  bf00              NOP                            ;3103
00007e  bf00              NOP                            ;3103
000080  2001              MOVS     r0,#1                 ;3106
000082  f8840051          STRB     r0,[r4,#0x51]         ;3106
000086  4620              MOV      r0,r4                 ;3112
000088  f7fffffe          BL       HAL_SPI_AbortCpltCallback
00008c  bf00              NOP      
00008e  e7db              B        |L45.72|
;;;3115   
                          ENDP


                          AREA ||i.SPI_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitCplt PROC
;;;2672     */
;;;2673   static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2674   {
000002  4605              MOV      r5,r0
;;;2675     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2676     uint32_t tickstart;
;;;2677   
;;;2678     /* Init tickstart for timeout management*/
;;;2679     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2680   
;;;2681     /* DMA Normal Mode */
;;;2682     if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f4007080          AND      r0,r0,#0x100
000014  f5b07f80          CMP      r0,#0x100
000018  d02d              BEQ      |L46.118|
;;;2683     {
;;;2684       /* Disable ERR interrupt */
;;;2685       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f0200020          BIC      r0,r0,#0x20
000022  6821              LDR      r1,[r4,#0]
000024  6048              STR      r0,[r1,#4]
;;;2686   
;;;2687       /* Disable Tx DMA Request */
;;;2688       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
000026  6820              LDR      r0,[r4,#0]
000028  6840              LDR      r0,[r0,#4]
00002a  f0200002          BIC      r0,r0,#2
00002e  6821              LDR      r1,[r4,#0]
000030  6048              STR      r0,[r1,#4]
;;;2689   
;;;2690       /* Check the end of the transaction */
;;;2691       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000032  4632              MOV      r2,r6
000034  2164              MOVS     r1,#0x64
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       SPI_EndRxTxTransaction
00003c  b118              CBZ      r0,|L46.70|
;;;2692       {
;;;2693         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00003e  6d60              LDR      r0,[r4,#0x54]
000040  f0400020          ORR      r0,r0,#0x20
000044  6560              STR      r0,[r4,#0x54]
                  |L46.70|
;;;2694       }
;;;2695   
;;;2696       /* Clear overrun flag in 2 Lines communication mode because received data is not read */
;;;2697       if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000046  68a0              LDR      r0,[r4,#8]
000048  b950              CBNZ     r0,|L46.96|
;;;2698       {
;;;2699         __HAL_SPI_CLEAR_OVRFLAG(hspi);
00004a  bf00              NOP      
00004c  2000              MOVS     r0,#0
00004e  9000              STR      r0,[sp,#0]
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  9000              STR      r0,[sp,#0]
000056  6820              LDR      r0,[r4,#0]
000058  6880              LDR      r0,[r0,#8]
00005a  9000              STR      r0,[sp,#0]
00005c  bf00              NOP      
00005e  bf00              NOP      
                  |L46.96|
;;;2700       }
;;;2701   
;;;2702       hspi->TxXferCount = 0U;
000060  2000              MOVS     r0,#0
000062  86e0              STRH     r0,[r4,#0x36]
;;;2703       hspi->State = HAL_SPI_STATE_READY;
000064  2001              MOVS     r0,#1
000066  f8840051          STRB     r0,[r4,#0x51]
;;;2704   
;;;2705       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
00006a  6d60              LDR      r0,[r4,#0x54]
00006c  b118              CBZ      r0,|L46.118|
;;;2706       {
;;;2707         /* Call user error callback */
;;;2708   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2709         hspi->ErrorCallback(hspi);
;;;2710   #else
;;;2711         HAL_SPI_ErrorCallback(hspi);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L46.116|
;;;2712   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2713         return;
;;;2714       }
;;;2715     }
;;;2716     /* Call user Tx complete callback */
;;;2717   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2718     hspi->TxCpltCallback(hspi);
;;;2719   #else
;;;2720     HAL_SPI_TxCpltCallback(hspi);
;;;2721   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2722   }
000074  bdf8              POP      {r3-r7,pc}
                  |L46.118|
000076  4620              MOV      r0,r4                 ;2720
000078  f7fffffe          BL       HAL_SPI_TxCpltCallback
00007c  bf00              NOP      
00007e  e7f9              B        |L46.116|
;;;2723   
                          ENDP


                          AREA ||i.SPI_DMATransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitReceiveCplt PROC
;;;2818     */
;;;2819   static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2820   {
000002  4605              MOV      r5,r0
;;;2821     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2822     uint32_t tickstart;
;;;2823   #if (USE_SPI_CRC != 0U)
;;;2824     __IO uint32_t tmpreg = 0U;
;;;2825   #endif /* USE_SPI_CRC */
;;;2826   
;;;2827     /* Init tickstart for timeout management*/
;;;2828     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2829   
;;;2830     /* DMA Normal Mode */
;;;2831     if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f4007080          AND      r0,r0,#0x100
000014  f5b07f80          CMP      r0,#0x100
000018  d021              BEQ      |L47.94|
;;;2832     {
;;;2833       /* Disable ERR interrupt */
;;;2834       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f0200020          BIC      r0,r0,#0x20
000022  6821              LDR      r1,[r4,#0]
000024  6048              STR      r0,[r1,#4]
;;;2835   
;;;2836   #if (USE_SPI_CRC != 0U)
;;;2837       /* CRC handling */
;;;2838       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2839       {
;;;2840         /* Wait the CRC data */
;;;2841         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
;;;2842         {
;;;2843           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2844         }
;;;2845         /* Read CRC to Flush DR and RXNE flag */
;;;2846         tmpreg = READ_REG(hspi->Instance->DR);
;;;2847         /* To avoid GCC warning */
;;;2848         UNUSED(tmpreg);
;;;2849       }
;;;2850   #endif /* USE_SPI_CRC */
;;;2851   
;;;2852       /* Check the end of the transaction */
;;;2853       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000026  4632              MOV      r2,r6
000028  2164              MOVS     r1,#0x64
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SPI_EndRxTxTransaction
000030  b118              CBZ      r0,|L47.58|
;;;2854       {
;;;2855         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000032  6d60              LDR      r0,[r4,#0x54]
000034  f0400020          ORR      r0,r0,#0x20
000038  6560              STR      r0,[r4,#0x54]
                  |L47.58|
;;;2856       }
;;;2857   
;;;2858       /* Disable Rx/Tx DMA Request */
;;;2859       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00003a  6820              LDR      r0,[r4,#0]
00003c  6840              LDR      r0,[r0,#4]
00003e  f0200003          BIC      r0,r0,#3
000042  6821              LDR      r1,[r4,#0]
000044  6048              STR      r0,[r1,#4]
;;;2860   
;;;2861       hspi->TxXferCount = 0U;
000046  2000              MOVS     r0,#0
000048  86e0              STRH     r0,[r4,#0x36]
;;;2862       hspi->RxXferCount = 0U;
00004a  87e0              STRH     r0,[r4,#0x3e]
;;;2863       hspi->State = HAL_SPI_STATE_READY;
00004c  2001              MOVS     r0,#1
00004e  f8840051          STRB     r0,[r4,#0x51]
;;;2864   
;;;2865   #if (USE_SPI_CRC != 0U)
;;;2866       /* Check if CRC error occurred */
;;;2867       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
;;;2868       {
;;;2869         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2870         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;2871       }
;;;2872   #endif /* USE_SPI_CRC */
;;;2873   
;;;2874       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000052  6d60              LDR      r0,[r4,#0x54]
000054  b118              CBZ      r0,|L47.94|
;;;2875       {
;;;2876         /* Call user error callback */
;;;2877   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2878         hspi->ErrorCallback(hspi);
;;;2879   #else
;;;2880         HAL_SPI_ErrorCallback(hspi);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L47.92|
;;;2881   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2882         return;
;;;2883       }
;;;2884     }
;;;2885     /* Call user TxRx complete callback */
;;;2886   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2887     hspi->TxRxCpltCallback(hspi);
;;;2888   #else
;;;2889     HAL_SPI_TxRxCpltCallback(hspi);
;;;2890   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2891   }
00005c  bd70              POP      {r4-r6,pc}
                  |L47.94|
00005e  4620              MOV      r0,r4                 ;2889
000060  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
000064  bf00              NOP      
000066  e7f9              B        |L47.92|
;;;2892   
                          ENDP


                          AREA ||i.SPI_DMATxAbortCallback||, CODE, READONLY, ALIGN=2

                  SPI_DMATxAbortCallback PROC
;;;2997     */
;;;2998   static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b57c              PUSH     {r2-r6,lr}
;;;2999   {
000002  4605              MOV      r5,r0
;;;3000     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;3001     __IO uint32_t count;
;;;3002   
;;;3003     hspi->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6ca1              LDR      r1,[r4,#0x48]
00000a  6508              STR      r0,[r1,#0x50]
;;;3004     count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
00000c  4826              LDR      r0,|L48.168|
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  2118              MOVS     r1,#0x18
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  f44f717a          MOV      r1,#0x3e8
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  2164              MOVS     r1,#0x64
000020  4348              MULS     r0,r1,r0
000022  9001              STR      r0,[sp,#4]
;;;3005   
;;;3006     /* Disable Tx DMA Request */
;;;3007     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
000024  6820              LDR      r0,[r4,#0]
000026  6840              LDR      r0,[r0,#4]
000028  f0200002          BIC      r0,r0,#2
00002c  6821              LDR      r1,[r4,#0]
00002e  6048              STR      r0,[r1,#4]
;;;3008   
;;;3009     /* Wait until TXE flag is set */
;;;3010     do
000030  bf00              NOP      
                  |L48.50|
;;;3011     {
;;;3012       if (count == 0U)
000032  9801              LDR      r0,[sp,#4]
000034  b920              CBNZ     r0,|L48.64|
;;;3013       {
;;;3014         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000036  6d60              LDR      r0,[r4,#0x54]
000038  f0400040          ORR      r0,r0,#0x40
00003c  6560              STR      r0,[r4,#0x54]
;;;3015         break;
00003e  e008              B        |L48.82|
                  |L48.64|
;;;3016       }
;;;3017       count--;
000040  9801              LDR      r0,[sp,#4]
000042  1e40              SUBS     r0,r0,#1
000044  9001              STR      r0,[sp,#4]
;;;3018     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  f0000002          AND      r0,r0,#2
00004e  2800              CMP      r0,#0
000050  d0ef              BEQ      |L48.50|
                  |L48.82|
000052  bf00              NOP                            ;3015
;;;3019   
;;;3020     /* Check if an Abort process is still ongoing */
;;;3021     if (hspi->hdmarx != NULL)
000054  6ce0              LDR      r0,[r4,#0x4c]
000056  b118              CBZ      r0,|L48.96|
;;;3022     {
;;;3023       if (hspi->hdmarx->XferAbortCallback != NULL)
000058  6ce0              LDR      r0,[r4,#0x4c]
00005a  6d00              LDR      r0,[r0,#0x50]
00005c  b100              CBZ      r0,|L48.96|
                  |L48.94|
;;;3024       {
;;;3025         return;
;;;3026       }
;;;3027     }
;;;3028   
;;;3029     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;3030     hspi->RxXferCount = 0U;
;;;3031     hspi->TxXferCount = 0U;
;;;3032   
;;;3033     /* Check no error during Abort procedure */
;;;3034     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
;;;3035     {
;;;3036       /* Reset errorCode */
;;;3037       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;3038     }
;;;3039   
;;;3040     /* Clear the Error flags in the SR register */
;;;3041     __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;3042     __HAL_SPI_CLEAR_FREFLAG(hspi);
;;;3043   
;;;3044     /* Restore hspi->State to Ready */
;;;3045     hspi->State  = HAL_SPI_STATE_READY;
;;;3046   
;;;3047     /* Call user Abort complete callback */
;;;3048   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3049     hspi->AbortCpltCallback(hspi);
;;;3050   #else
;;;3051     HAL_SPI_AbortCpltCallback(hspi);
;;;3052   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3053   }
00005e  bd7c              POP      {r2-r6,pc}
                  |L48.96|
000060  2000              MOVS     r0,#0                 ;3030
000062  87e0              STRH     r0,[r4,#0x3e]         ;3030
000064  86e0              STRH     r0,[r4,#0x36]         ;3031
000066  6d60              LDR      r0,[r4,#0x54]         ;3034
000068  2840              CMP      r0,#0x40              ;3034
00006a  d001              BEQ      |L48.112|
00006c  2000              MOVS     r0,#0                 ;3037
00006e  6560              STR      r0,[r4,#0x54]         ;3037
                  |L48.112|
000070  bf00              NOP                            ;3041
000072  2000              MOVS     r0,#0                 ;3041
000074  9000              STR      r0,[sp,#0]            ;3041
000076  6820              LDR      r0,[r4,#0]            ;3041
000078  68c0              LDR      r0,[r0,#0xc]          ;3041
00007a  9000              STR      r0,[sp,#0]            ;3041
00007c  6820              LDR      r0,[r4,#0]            ;3041
00007e  6880              LDR      r0,[r0,#8]            ;3041
000080  9000              STR      r0,[sp,#0]            ;3041
000082  bf00              NOP                            ;3041
000084  bf00              NOP                            ;3041
000086  bf00              NOP                            ;3042
000088  2000              MOVS     r0,#0                 ;3042
00008a  9000              STR      r0,[sp,#0]            ;3042
00008c  6820              LDR      r0,[r4,#0]            ;3042
00008e  6880              LDR      r0,[r0,#8]            ;3042
000090  9000              STR      r0,[sp,#0]            ;3042
000092  bf00              NOP                            ;3042
000094  bf00              NOP                            ;3042
000096  2001              MOVS     r0,#1                 ;3045
000098  f8840051          STRB     r0,[r4,#0x51]         ;3045
00009c  4620              MOV      r0,r4                 ;3051
00009e  f7fffffe          BL       HAL_SPI_AbortCpltCallback
0000a2  bf00              NOP      
0000a4  e7db              B        |L48.94|
;;;3054   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L48.168|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_EndRxTransaction||, CODE, READONLY, ALIGN=1

                  SPI_EndRxTransaction PROC
;;;3547     */
;;;3548   static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3549   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;3550     if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
000008  6860              LDR      r0,[r4,#4]
00000a  f5b07f82          CMP      r0,#0x104
00000e  d10d              BNE      |L49.44|
000010  68a0              LDR      r0,[r4,#8]
000012  f5b04f00          CMP      r0,#0x8000
000016  d003              BEQ      |L49.32|
;;;3551                                                  || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
000018  68a0              LDR      r0,[r4,#8]
00001a  f5b06f80          CMP      r0,#0x400
00001e  d105              BNE      |L49.44|
                  |L49.32|
;;;3552     {
;;;3553       /* Disable SPI peripheral */
;;;3554       __HAL_SPI_DISABLE(hspi);
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200040          BIC      r0,r0,#0x40
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L49.44|
;;;3555     }
;;;3556   
;;;3557     /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
;;;3558     if (hspi->Init.Mode == SPI_MODE_MASTER)
00002c  6860              LDR      r0,[r4,#4]
00002e  f5b07f82          CMP      r0,#0x104
000032  d11f              BNE      |L49.116|
;;;3559     {
;;;3560       if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
000034  68a0              LDR      r0,[r4,#8]
000036  f5b06f80          CMP      r0,#0x400
00003a  d00d              BEQ      |L49.88|
;;;3561       {
;;;3562         /* Control the BSY flag */
;;;3563         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
00003c  4633              MOV      r3,r6
00003e  2200              MOVS     r2,#0
000040  2180              MOVS     r1,#0x80
000042  4620              MOV      r0,r4
000044  9500              STR      r5,[sp,#0]
000046  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00004a  b308              CBZ      r0,|L49.144|
;;;3564         {
;;;3565           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00004c  6d60              LDR      r0,[r4,#0x54]
00004e  f0400020          ORR      r0,r0,#0x20
000052  6560              STR      r0,[r4,#0x54]
;;;3566           return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L49.86|
;;;3567         }
;;;3568       }
;;;3569       else
;;;3570       {
;;;3571         /* Wait the RXNE reset */
;;;3572         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
;;;3573         {
;;;3574           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3575           return HAL_TIMEOUT;
;;;3576         }
;;;3577       }
;;;3578     }
;;;3579     else
;;;3580     {
;;;3581       /* Wait the RXNE reset */
;;;3582       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
;;;3583       {
;;;3584         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3585         return HAL_TIMEOUT;
;;;3586       }
;;;3587     }
;;;3588     return HAL_OK;
;;;3589   }
000056  bdf8              POP      {r3-r7,pc}
                  |L49.88|
000058  4633              MOV      r3,r6                 ;3572
00005a  2200              MOVS     r2,#0                 ;3572
00005c  2101              MOVS     r1,#1                 ;3572
00005e  4620              MOV      r0,r4                 ;3572
000060  9500              STR      r5,[sp,#0]            ;3572
000062  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000066  b198              CBZ      r0,|L49.144|
000068  6d60              LDR      r0,[r4,#0x54]         ;3574
00006a  f0400020          ORR      r0,r0,#0x20           ;3574
00006e  6560              STR      r0,[r4,#0x54]         ;3574
000070  2003              MOVS     r0,#3                 ;3575
000072  e7f0              B        |L49.86|
                  |L49.116|
000074  4633              MOV      r3,r6                 ;3582
000076  2200              MOVS     r2,#0                 ;3582
000078  2101              MOVS     r1,#1                 ;3582
00007a  4620              MOV      r0,r4                 ;3582
00007c  9500              STR      r5,[sp,#0]            ;3582
00007e  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000082  b128              CBZ      r0,|L49.144|
000084  6d60              LDR      r0,[r4,#0x54]         ;3584
000086  f0400020          ORR      r0,r0,#0x20           ;3584
00008a  6560              STR      r0,[r4,#0x54]         ;3584
00008c  2003              MOVS     r0,#3                 ;3585
00008e  e7e2              B        |L49.86|
                  |L49.144|
000090  2000              MOVS     r0,#0                 ;3588
000092  e7e0              B        |L49.86|
;;;3590   
                          ENDP


                          AREA ||i.SPI_EndRxTxTransaction||, CODE, READONLY, ALIGN=2

                  SPI_EndRxTxTransaction PROC
;;;3597     */
;;;3598   static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
000000  b57c              PUSH     {r2-r6,lr}
;;;3599   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3600     /* Timeout in s */
;;;3601     __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
000008  4816              LDR      r0,|L50.100|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  2118              MOVS     r1,#0x18
00000e  fbb0f0f1          UDIV     r0,r0,r1
000012  4915              LDR      r1,|L50.104|
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  f44f717a          MOV      r1,#0x3e8
00001c  4348              MULS     r0,r1,r0
00001e  9001              STR      r0,[sp,#4]
;;;3602     /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
;;;3603     if (hspi->Init.Mode == SPI_MODE_MASTER)
000020  6860              LDR      r0,[r4,#4]
000022  f5b07f82          CMP      r0,#0x104
000026  d10d              BNE      |L50.68|
;;;3604     {
;;;3605       /* Control the BSY flag */
;;;3606       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
000028  462b              MOV      r3,r5
00002a  2200              MOVS     r2,#0
00002c  2180              MOVS     r1,#0x80
00002e  4620              MOV      r0,r4
000030  9600              STR      r6,[sp,#0]
000032  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000036  b198              CBZ      r0,|L50.96|
;;;3607       {
;;;3608         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000038  6d60              LDR      r0,[r4,#0x54]
00003a  f0400020          ORR      r0,r0,#0x20
00003e  6560              STR      r0,[r4,#0x54]
;;;3609         return HAL_TIMEOUT;
000040  2003              MOVS     r0,#3
                  |L50.66|
;;;3610       }
;;;3611     }
;;;3612     else
;;;3613     {
;;;3614       /* Wait BSY flag during 1 Byte time transfer in case of Full-Duplex and Tx transfer
;;;3615       * If Timeout is reached, the transfer is considered as finish.
;;;3616       * User have to calculate the timeout value to fit with the time of 1 byte transfer.
;;;3617       * This time is directly link with the SPI clock from Master device.
;;;3618       */
;;;3619       do
;;;3620       {
;;;3621         if (count == 0U)
;;;3622         {
;;;3623           break;
;;;3624         }
;;;3625         count--;
;;;3626       } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
;;;3627     }
;;;3628   
;;;3629     return HAL_OK;
;;;3630   }
000042  bd7c              POP      {r2-r6,pc}
                  |L50.68|
000044  bf00              NOP                            ;3619
                  |L50.70|
000046  9801              LDR      r0,[sp,#4]            ;3621
000048  b900              CBNZ     r0,|L50.76|
00004a  e008              B        |L50.94|
                  |L50.76|
00004c  9801              LDR      r0,[sp,#4]            ;3625
00004e  1e40              SUBS     r0,r0,#1              ;3625
000050  9001              STR      r0,[sp,#4]            ;3625
000052  6820              LDR      r0,[r4,#0]            ;3626
000054  6880              LDR      r0,[r0,#8]            ;3626
000056  f3c010c0          UBFX     r0,r0,#7,#1           ;3626
00005a  2800              CMP      r0,#0                 ;3626
00005c  d1f3              BNE      |L50.70|
                  |L50.94|
00005e  bf00              NOP                            ;3623
                  |L50.96|
000060  2000              MOVS     r0,#0                 ;3629
000062  e7ee              B        |L50.66|
;;;3631   
                          ENDP

                  |L50.100|
                          DCD      SystemCoreClock
                  |L50.104|
                          DCD      0x000f4240

                          AREA ||i.SPI_RxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_16BIT PROC
;;;3392     */
;;;3393   static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3394   {
000002  4604              MOV      r4,r0
;;;3395     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  8008              STRH     r0,[r1,#0]
;;;3396     hspi->pRxBuffPtr += sizeof(uint16_t);
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c80              ADDS     r0,r0,#2
000010  63a0              STR      r0,[r4,#0x38]
;;;3397     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3398   
;;;3399   #if (USE_SPI_CRC != 0U)
;;;3400     /* Enable CRC Transmission */
;;;3401     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;3402     {
;;;3403       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3404     }
;;;3405   #endif /* USE_SPI_CRC */
;;;3406   
;;;3407     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b910              CBNZ     r0,|L51.34|
;;;3408     {
;;;3409   #if (USE_SPI_CRC != 0U)
;;;3410       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3411       {
;;;3412         hspi->RxISR = SPI_RxISR_16BITCRC;
;;;3413         return;
;;;3414       }
;;;3415   #endif /* USE_SPI_CRC */
;;;3416       SPI_CloseRx_ISR(hspi);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_CloseRx_ISR
                  |L51.34|
;;;3417     }
;;;3418   }
000022  bd10              POP      {r4,pc}
;;;3419   
                          ENDP


                          AREA ||i.SPI_RxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_8BIT PROC
;;;3336     */
;;;3337   static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3338   {
000002  4604              MOV      r4,r0
;;;3339     *hspi->pRxBuffPtr = (*(__IO uint8_t *)&hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  7b00              LDRB     r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  7008              STRB     r0,[r1,#0]
;;;3340     hspi->pRxBuffPtr++;
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c40              ADDS     r0,r0,#1
000010  63a0              STR      r0,[r4,#0x38]
;;;3341     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3342   
;;;3343   #if (USE_SPI_CRC != 0U)
;;;3344     /* Enable CRC Transmission */
;;;3345     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;3346     {
;;;3347       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3348     }
;;;3349   #endif /* USE_SPI_CRC */
;;;3350   
;;;3351     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b910              CBNZ     r0,|L52.34|
;;;3352     {
;;;3353   #if (USE_SPI_CRC != 0U)
;;;3354       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3355       {
;;;3356         hspi->RxISR =  SPI_RxISR_8BITCRC;
;;;3357         return;
;;;3358       }
;;;3359   #endif /* USE_SPI_CRC */
;;;3360       SPI_CloseRx_ISR(hspi);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_CloseRx_ISR
                  |L52.34|
;;;3361     }
;;;3362   }
000022  bd10              POP      {r4,pc}
;;;3363   
                          ENDP


                          AREA ||i.SPI_TxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_16BIT PROC
;;;3450     */
;;;3451   static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3452   {
000002  4604              MOV      r4,r0
;;;3453     /* Transmit data in 16 Bit mode */
;;;3454     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  8800              LDRH     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  60c8              STR      r0,[r1,#0xc]
;;;3455     hspi->pTxBuffPtr += sizeof(uint16_t);
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c80              ADDS     r0,r0,#2
000010  6320              STR      r0,[r4,#0x30]
;;;3456     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3457   
;;;3458     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b910              CBNZ     r0,|L53.34|
;;;3459     {
;;;3460   #if (USE_SPI_CRC != 0U)
;;;3461       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3462       {
;;;3463         /* Enable CRC Transmission */
;;;3464         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3465       }
;;;3466   #endif /* USE_SPI_CRC */
;;;3467       SPI_CloseTx_ISR(hspi);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_CloseTx_ISR
                  |L53.34|
;;;3468     }
;;;3469   }
000022  bd10              POP      {r4,pc}
;;;3470   
                          ENDP


                          AREA ||i.SPI_TxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_8BIT PROC
;;;3425     */
;;;3426   static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3427   {
000002  4604              MOV      r4,r0
;;;3428     *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  7800              LDRB     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  7308              STRB     r0,[r1,#0xc]
;;;3429     hspi->pTxBuffPtr++;
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c40              ADDS     r0,r0,#1
000010  6320              STR      r0,[r4,#0x30]
;;;3430     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3431   
;;;3432     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b910              CBNZ     r0,|L54.34|
;;;3433     {
;;;3434   #if (USE_SPI_CRC != 0U)
;;;3435       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3436       {
;;;3437         /* Enable CRC Transmission */
;;;3438         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3439       }
;;;3440   #endif /* USE_SPI_CRC */
;;;3441       SPI_CloseTx_ISR(hspi);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_CloseTx_ISR
                  |L54.34|
;;;3442     }
;;;3443   }
000022  bd10              POP      {r4,pc}
;;;3444   
                          ENDP


                          AREA ||i.SPI_WaitFlagStateUntilTimeout||, CODE, READONLY, ALIGN=2

                  SPI_WaitFlagStateUntilTimeout PROC
;;;3480     */
;;;3481   static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3482                                                          uint32_t Timeout, uint32_t Tickstart)
;;;3483   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;3484     __IO uint32_t count;
;;;3485     uint32_t tmp_timeout;
;;;3486     uint32_t tmp_tickstart;
;;;3487   
;;;3488     /* Adjust Timeout value  in case of end of transfer */
;;;3489     tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
000010  f7fffffe          BL       HAL_GetTick
000014  eba00009          SUB      r0,r0,r9
000018  1a37              SUBS     r7,r6,r0
;;;3490     tmp_tickstart = HAL_GetTick();
00001a  f7fffffe          BL       HAL_GetTick
00001e  4682              MOV      r10,r0
;;;3491   
;;;3492     /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
;;;3493     count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
000020  482c              LDR      r0,|L55.212|
000022  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000024  f3c030cb          UBFX     r0,r0,#15,#12
000028  4378              MULS     r0,r7,r0
00002a  9000              STR      r0,[sp,#0]
;;;3494   
;;;3495     while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
00002c  e045              B        |L55.186|
                  |L55.46|
;;;3496     {
;;;3497       if (Timeout != HAL_MAX_DELAY)
00002e  1c70              ADDS     r0,r6,#1
000030  2800              CMP      r0,#0
000032  d042              BEQ      |L55.186|
;;;3498       {
;;;3499         if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
000034  f7fffffe          BL       HAL_GetTick
000038  eba0000a          SUB      r0,r0,r10
00003c  42b8              CMP      r0,r7
00003e  d200              BCS      |L55.66|
000040  bba7              CBNZ     r7,|L55.172|
                  |L55.66|
;;;3500         {
;;;3501           /* Disable the SPI and reset the CRC: the CRC value should be cleared
;;;3502              on both master and slave sides in order to resynchronize the master
;;;3503              and slave for their respective CRC calculation */
;;;3504   
;;;3505           /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
;;;3506           __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
000042  6820              LDR      r0,[r4,#0]
000044  6840              LDR      r0,[r0,#4]
000046  f02000e0          BIC      r0,r0,#0xe0
00004a  6821              LDR      r1,[r4,#0]
00004c  6048              STR      r0,[r1,#4]
;;;3507   
;;;3508           if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
00004e  6860              LDR      r0,[r4,#4]
000050  f5b07f82          CMP      r0,#0x104
000054  d10d              BNE      |L55.114|
000056  68a0              LDR      r0,[r4,#8]
000058  f5b04f00          CMP      r0,#0x8000
00005c  d003              BEQ      |L55.102|
;;;3509                                                        || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
00005e  68a0              LDR      r0,[r4,#8]
000060  f5b06f80          CMP      r0,#0x400
000064  d105              BNE      |L55.114|
                  |L55.102|
;;;3510           {
;;;3511             /* Disable SPI peripheral */
;;;3512             __HAL_SPI_DISABLE(hspi);
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f0200040          BIC      r0,r0,#0x40
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
                  |L55.114|
;;;3513           }
;;;3514   
;;;3515           /* Reset CRC Calculation */
;;;3516           if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000072  6aa0              LDR      r0,[r4,#0x28]
000074  f5b05f00          CMP      r0,#0x2000
000078  d10d              BNE      |L55.150|
;;;3517           {
;;;3518             SPI_RESET_CRC(hspi);
00007a  bf00              NOP      
00007c  6820              LDR      r0,[r4,#0]
00007e  6800              LDR      r0,[r0,#0]
000080  f4205000          BIC      r0,r0,#0x2000
000084  6821              LDR      r1,[r4,#0]
000086  6008              STR      r0,[r1,#0]
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  f4405000          ORR      r0,r0,#0x2000
000090  6821              LDR      r1,[r4,#0]
000092  6008              STR      r0,[r1,#0]
000094  bf00              NOP      
                  |L55.150|
;;;3519           }
;;;3520   
;;;3521           hspi->State = HAL_SPI_STATE_READY;
000096  2001              MOVS     r0,#1
000098  f8840051          STRB     r0,[r4,#0x51]
;;;3522   
;;;3523           /* Process Unlocked */
;;;3524           __HAL_UNLOCK(hspi);
00009c  bf00              NOP      
00009e  2000              MOVS     r0,#0
0000a0  f8840050          STRB     r0,[r4,#0x50]
0000a4  bf00              NOP      
;;;3525   
;;;3526           return HAL_TIMEOUT;
0000a6  2003              MOVS     r0,#3
                  |L55.168|
;;;3527         }
;;;3528         /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
;;;3529         if(count == 0U)
;;;3530         {
;;;3531           tmp_timeout = 0U;
;;;3532         }
;;;3533         count--;
;;;3534       }
;;;3535     }
;;;3536   
;;;3537     return HAL_OK;
;;;3538   }
0000a8  e8bd8ff8          POP      {r3-r11,pc}
                  |L55.172|
0000ac  e7ff              B        |L55.174|
                  |L55.174|
0000ae  9800              LDR      r0,[sp,#0]            ;3529
0000b0  b900              CBNZ     r0,|L55.180|
0000b2  2700              MOVS     r7,#0                 ;3531
                  |L55.180|
0000b4  9800              LDR      r0,[sp,#0]            ;3533
0000b6  1e40              SUBS     r0,r0,#1              ;3533
0000b8  9000              STR      r0,[sp,#0]            ;3533
                  |L55.186|
0000ba  6820              LDR      r0,[r4,#0]            ;3495
0000bc  6880              LDR      r0,[r0,#8]            ;3495
0000be  4028              ANDS     r0,r0,r5              ;3495
0000c0  42a8              CMP      r0,r5                 ;3495
0000c2  d101              BNE      |L55.200|
0000c4  2001              MOVS     r0,#1                 ;3495
0000c6  e000              B        |L55.202|
                  |L55.200|
0000c8  2000              MOVS     r0,#0                 ;3495
                  |L55.202|
0000ca  4540              CMP      r0,r8                 ;3495
0000cc  d1af              BNE      |L55.46|
0000ce  2000              MOVS     r0,#0                 ;3537
0000d0  e7ea              B        |L55.168|
;;;3539   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L55.212|
                          DCD      SystemCoreClock

;*** Start embedded assembler ***

#line 1 "D:\\Keil_v5\\ARM\\PACK\\Keil\\STM32F4xx_DFP\\2.16.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____RRX|
#line 587
|__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
