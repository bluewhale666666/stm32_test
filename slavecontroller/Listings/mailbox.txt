; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mailbox.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mailbox.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\mailbox.crf etherCAT\mailbox.c]
                          THUMB

                          AREA ||i.GetOutOfMbxQueue||, CODE, READONLY, ALIGN=1

                  GetOutOfMbxQueue PROC
;;;228    
;;;229    TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)
000000  b510              PUSH     {r4,lr}
;;;230    {
000002  4601              MOV      r1,r0
;;;231        TMBX MBXMEM * pMbx;
;;;232        ENTER_MBX_CRITICAL;
;;;233    
;;;234        if (pQueue->firstInQueue != pQueue->lastInQueue)
000004  880a              LDRH     r2,[r1,#0]
000006  884b              LDRH     r3,[r1,#2]
000008  429a              CMP      r2,r3
00000a  d00e              BEQ      |L1.42|
;;;235        {
;;;236            // Queue ist nicht leer
;;;237            UINT16 firstInQueue = pQueue->firstInQueue;
00000c  880a              LDRH     r2,[r1,#0]
;;;238            pMbx = pQueue->queue[firstInQueue];
00000e  f1010308          ADD      r3,r1,#8
000012  f8530022          LDR      r0,[r3,r2,LSL #2]
;;;239            firstInQueue++;
000016  1c53              ADDS     r3,r2,#1
000018  b29a              UXTH     r2,r3
;;;240            pQueue->firstInQueue = firstInQueue;
00001a  800a              STRH     r2,[r1,#0]
;;;241            
;;;242            if (pQueue->firstInQueue == pQueue->maxQueueSize)
00001c  880b              LDRH     r3,[r1,#0]
00001e  888c              LDRH     r4,[r1,#4]
000020  42a3              CMP      r3,r4
000022  d101              BNE      |L1.40|
;;;243            {
;;;244                // Umbruch der Queue
;;;245                pQueue->firstInQueue = 0;
000024  2300              MOVS     r3,#0
000026  800b              STRH     r3,[r1,#0]
                  |L1.40|
;;;246            }
;;;247        }
000028  e000              B        |L1.44|
                  |L1.42|
;;;248        else
;;;249        {
;;;250            pMbx = 0;
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;251        }
;;;252    
;;;253    
;;;254        LEAVE_MBX_CRITICAL;
;;;255    
;;;256        return pMbx;
;;;257    }
00002c  bd10              POP      {r4,pc}
;;;258    
                          ENDP


                          AREA ||i.MBX_CheckAndCopyMailbox||, CODE, READONLY, ALIGN=2

                  MBX_CheckAndCopyMailbox PROC
;;;809    
;;;810    void MBX_CheckAndCopyMailbox( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;811    {
;;;812        UINT16 mbxLen;
;;;813    
;;;814    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1129 to 1137 deleted*/
;;;815        /* get the size of the received mailbox command and acknowledge the event*/
;;;816        HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
000002  2202              MOVS     r2,#2
000004  483d              LDR      r0,|L2.252|
000006  8801              LDRH     r1,[r0,#0]  ; u16EscAddrReceiveMbx
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       HW_EscRead
;;;817        
;;;818        /* the size has to be swapped here, all other bytes of the mailbox service will be swapped later */
;;;819        mbxLen = SWAPWORD(mbxLen);
00000e  f8bd0004          LDRH     r0,[sp,#4]
000012  9001              STR      r0,[sp,#4]
;;;820    
;;;821        if(bNoMbxMemoryAvailable == TRUE)
000014  483a              LDR      r0,|L2.256|
000016  7800              LDRB     r0,[r0,#0]  ; bNoMbxMemoryAvailable
000018  2801              CMP      r0,#1
00001a  d11a              BNE      |L2.82|
;;;822        {
;;;823            /* Return a no memory error in case of any mailbox request*/
;;;824            TMBX MBXMEM *pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
00001c  200a              MOVS     r0,#0xa
00001e  f7fffffe          BL       malloc
000022  4604              MOV      r4,r0
;;;825    
;;;826            if(pMbx != NULL)
000024  b1a4              CBZ      r4,|L2.80|
;;;827            {
;;;828                HMEMSET(pMbx,0x00,10);
000026  2000              MOVS     r0,#0
000028  6020              STR      r0,[r4,#0]
00002a  6060              STR      r0,[r4,#4]
00002c  8120              STRH     r0,[r4,#8]
;;;829    
;;;830                /* Mailbox error response: type 0 (mailbox service protocol) */
;;;831                pMbx->MbxHeader.Length     = 4;
00002e  2004              MOVS     r0,#4
000030  8020              STRH     r0,[r4,#0]
;;;832                pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
000032  88a0              LDRH     r0,[r4,#4]
000034  f4206070          BIC      r0,r0,#0xf00
000038  80a0              STRH     r0,[r4,#4]
;;;833                pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
00003a  2001              MOVS     r0,#1
00003c  80e0              STRH     r0,[r4,#6]
;;;834                pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
00003e  2107              MOVS     r1,#7
000040  8121              STRH     r1,[r4,#8]
;;;835                MBX_MailboxSendReq(pMbx, 0);
000042  2100              MOVS     r1,#0
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       MBX_MailboxSendReq
;;;836    
;;;837                APPL_FreeMailboxBuffer(pMbx);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       free
                  |L2.80|
;;;838            }
;;;839        }
000050  bf00              NOP      
                  |L2.82|
;;;840        /* the length of the mailbox data is in the first two bytes of the mailbox,
;;;841           so the length of the mailbox header has to be added */
;;;842        mbxLen += MBX_HEADER_SIZE;
000052  f8bd0004          LDRH     r0,[sp,#4]
000056  1d80              ADDS     r0,r0,#6
000058  b280              UXTH     r0,r0
00005a  9001              STR      r0,[sp,#4]
;;;843    
;;;844        /* in this example there are only two mailbox buffers available in the firmware (one for processing and
;;;845           one to stored the last sent response for a possible repeat request), so a
;;;846           received mailbox service can only be processed if a free buffer is available */
;;;847        if ( ( bSendMbxIsFull )                /* a received mailbox service will not be processed
00005c  4829              LDR      r0,|L2.260|
00005e  7800              LDRB     r0,[r0,#0]  ; bSendMbxIsFull
000060  b910              CBNZ     r0,|L2.104|
;;;848                                                        as long as the send mailbox is still full
;;;849                                                        (waits to be read from the master) */
;;;850            ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
000062  4829              LDR      r0,|L2.264|
000064  7800              LDRB     r0,[r0,#0]  ; u8MailboxSendReqStored
000066  b118              CBZ      r0,|L2.112|
                  |L2.104|
;;;851                                                        so the received mailbox service will not be processed
;;;852                                                        until all stored mailbox services are sent */
;;;853    /*ET9300 Project Handler :(#if !MAILBOX_QUEUE) lines 1179 to 1181 deleted*/
;;;854            )
;;;855        {
;;;856            /* set flag that the processing of the mailbox service will be checked in the
;;;857                function MBX_Main (called from ECAT_Main) */
;;;858            bReceiveMbxIsLocked = TRUE;
000068  2001              MOVS     r0,#1
00006a  4928              LDR      r1,|L2.268|
00006c  7008              STRB     r0,[r1,#0]
00006e  e042              B        |L2.246|
                  |L2.112|
;;;859        }
;;;860        else
;;;861        {
;;;862            /* received mailbox command can be processed, reset flag */
;;;863            bReceiveMbxIsLocked = FALSE;
000070  2000              MOVS     r0,#0
000072  4926              LDR      r1,|L2.268|
000074  7008              STRB     r0,[r1,#0]
;;;864    
;;;865            /* if the read mailbox size is too big for the buffer, set the copy size to the maximum buffer size, otherwise
;;;866               memory could be overwritten,
;;;867               the evaluation of the mailbox size will be done in the mailbox protocols called from MBX_WriteMailboxInd */
;;;868    
;;;869            if (mbxLen > u16ReceiveMbxSize)
000076  f8bd0004          LDRH     r0,[sp,#4]
00007a  4925              LDR      r1,|L2.272|
00007c  8809              LDRH     r1,[r1,#0]  ; u16ReceiveMbxSize
00007e  4288              CMP      r0,r1
000080  dd02              BLE      |L2.136|
;;;870            {
;;;871                mbxLen = u16ReceiveMbxSize;
000082  4823              LDR      r0,|L2.272|
000084  8800              LDRH     r0,[r0,#0]  ; u16ReceiveMbxSize
000086  9001              STR      r0,[sp,#4]
                  |L2.136|
;;;872            }
;;;873    
;;;874            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
000088  4821              LDR      r0,|L2.272|
00008a  8800              LDRH     r0,[r0,#0]  ; u16ReceiveMbxSize
00008c  f7fffffe          BL       malloc
000090  4920              LDR      r1,|L2.276|
000092  6008              STR      r0,[r1,#0]  ; psWriteMbx
;;;875    
;;;876            /* if there is no more memory for mailbox buffer, the mailbox should not be read */
;;;877            if (psWriteMbx == NULL)
000094  4608              MOV      r0,r1
000096  6800              LDR      r0,[r0,#0]  ; psWriteMbx
000098  b918              CBNZ     r0,|L2.162|
;;;878            {
;;;879                /* set flag that the processing of the mailbox service will be checked in the
;;;880                    function MBX_Main (called from ECAT_Main) */
;;;881                bReceiveMbxIsLocked = TRUE;
00009a  2001              MOVS     r0,#1
00009c  491b              LDR      r1,|L2.268|
00009e  7008              STRB     r0,[r1,#0]
                  |L2.160|
;;;882                return;
;;;883            }
;;;884            /* copy the mailbox header and data*/
;;;885            HW_EscReadMbxMem((MEM_ADDR MBXMEM *) psWriteMbx,u16EscAddrReceiveMbx,mbxLen);
;;;886    
;;;887    /*ET9300 Project Handler :(#if !MAILBOX_QUEUE) lines 1217 to 1219 deleted*/
;;;888    
;;;889            {
;;;890            /*Read Control and Status of SyncManager 0 to check if the buffer is unlocked*/
;;;891    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1223 to 1227 deleted*/
;;;892            VARVOLATILE UINT16 smstate = 0x00;
;;;893            HW_EscReadWord(smstate,ESC_SYNCMAN_CONTROL_OFFSET);
;;;894            smstate = SWAPWORD(smstate);
;;;895    /*ET9300 Project Handler :( #else) lines 1231 to 1234 deleted*/
;;;896    
;;;897            if(smstate & SM_STATUS_MBX_BUFFER_FULL)
;;;898            {
;;;899                /*Unlock the mailbox SyncManger buffer*/
;;;900    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1239 to 1242 deleted*/
;;;901                u16dummy = 0;
;;;902                HW_EscReadWord(u16dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 2));
;;;903    /*ET9300 Project Handler :( #else) lines 1245 to 1248 deleted*/
;;;904    
;;;905            }
;;;906    
;;;907            }
;;;908    
;;;909            /* in MBX_MailboxWriteInd the mailbox protocol will be processed */
;;;910            MBX_MailboxWriteInd( psWriteMbx );
;;;911    
;;;912        }
;;;913    }
0000a0  bd1c              POP      {r2-r4,pc}
                  |L2.162|
0000a2  f8bd2004          LDRH     r2,[sp,#4]            ;885
0000a6  4815              LDR      r0,|L2.252|
0000a8  8801              LDRH     r1,[r0,#0]            ;885  ; u16EscAddrReceiveMbx
0000aa  481a              LDR      r0,|L2.276|
0000ac  6800              LDR      r0,[r0,#0]            ;885  ; psWriteMbx
0000ae  f7fffffe          BL       HW_EscRead
0000b2  2000              MOVS     r0,#0                 ;892
0000b4  9000              STR      r0,[sp,#0]            ;892
0000b6  2202              MOVS     r2,#2                 ;893
0000b8  f6400104          MOV      r1,#0x804             ;893
0000bc  4668              MOV      r0,sp                 ;893
0000be  f7fffffe          BL       HW_EscRead
0000c2  f8bd0000          LDRH     r0,[sp,#0]            ;894
0000c6  9000              STR      r0,[sp,#0]            ;894
0000c8  f8bd0000          LDRH     r0,[sp,#0]            ;897
0000cc  f4006000          AND      r0,r0,#0x800          ;897
0000d0  b168              CBZ      r0,|L2.238|
0000d2  2000              MOVS     r0,#0                 ;901
0000d4  4910              LDR      r1,|L2.280|
0000d6  8008              STRH     r0,[r1,#0]            ;901
0000d8  4808              LDR      r0,|L2.252|
0000da  8800              LDRH     r0,[r0,#0]            ;902  ; u16EscAddrReceiveMbx
0000dc  4a0c              LDR      r2,|L2.272|
0000de  8812              LDRH     r2,[r2,#0]            ;902  ; u16ReceiveMbxSize
0000e0  4410              ADD      r0,r0,r2              ;902
0000e2  1e80              SUBS     r0,r0,#2              ;902
0000e4  b281              UXTH     r1,r0                 ;902
0000e6  2202              MOVS     r2,#2                 ;902
0000e8  480b              LDR      r0,|L2.280|
0000ea  f7fffffe          BL       HW_EscRead
                  |L2.238|
0000ee  4809              LDR      r0,|L2.276|
0000f0  6800              LDR      r0,[r0,#0]            ;910  ; psWriteMbx
0000f2  f7fffffe          BL       MBX_MailboxWriteInd
                  |L2.246|
0000f6  bf00              NOP      
0000f8  e7d2              B        |L2.160|
;;;914    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L2.252|
                          DCD      u16EscAddrReceiveMbx
                  |L2.256|
                          DCD      bNoMbxMemoryAvailable
                  |L2.260|
                          DCD      bSendMbxIsFull
                  |L2.264|
                          DCD      u8MailboxSendReqStored
                  |L2.268|
                          DCD      bReceiveMbxIsLocked
                  |L2.272|
                          DCD      u16ReceiveMbxSize
                  |L2.276|
                          DCD      psWriteMbx
                  |L2.280|
                          DCD      u16dummy

                          AREA ||i.MBX_CopyToSendMailbox||, CODE, READONLY, ALIGN=2

                  MBX_CopyToSendMailbox PROC
;;;922    
;;;923    UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )
000000  b5f8              PUSH     {r3-r7,lr}
;;;924    {
000002  4604              MOV      r4,r0
;;;925        if ( (nAlStatus & STATE_MASK) == STATE_INIT)
000004  483c              LDR      r0,|L3.248|
000006  7800              LDRB     r0,[r0,#0]  ; nAlStatus
000008  f000000f          AND      r0,r0,#0xf
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L3.20|
;;;926        {
;;;927            /* the mailbox is disabled if the slave is in the INIT state */
;;;928            return( ERROR_INVALIDSTATE );
000010  20f0              MOVS     r0,#0xf0
                  |L3.18|
;;;929        }
;;;930    
;;;931    
;;;932        if ( !bMbxRunning )
;;;933        {
;;;934            /* the mailbox is disabled if the slave is in the INIT state */
;;;935            return( ERROR_INVALIDSTATE );
;;;936        }
;;;937    
;;;938        if ( bSendMbxIsFull )
;;;939        {
;;;940            /* mailbox service cannot be sent because the send mailbox is still full */
;;;941            return MBXERR_NOMOREMEMORY;
;;;942        }
;;;943        else
;;;944        {
;;;945            /* the variable mbxSize contains the size of the mailbox data to be sent */
;;;946            UINT16 mbxSize = pMbx->MbxHeader.Length;
;;;947    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 1292 to 1295 deleted*/
;;;948    /*ECATCHANGE_START(V5.13) MBX2*/
;;;949            /*Reset the not used mailbox memory*/
;;;950            {
;;;951                UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
;;;952                UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
;;;953    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1301 to 1314 deleted*/
;;;954                /*round down to last even 16bit address*/
;;;955                LastUsedAddr = LastUsedAddr & 0xFFFE;
;;;956                LastAddrToReset = (LastAddrToReset - 2) & 0xFFFE;
;;;957                u16dummy = 0;
;;;958    
;;;959                /*clear all unused bytes*/
;;;960                while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
;;;961                {
;;;962                    HW_EscWriteWord(u16dummy, LastUsedAddr);
;;;963                    LastUsedAddr = LastUsedAddr + 2;
;;;964                }
;;;965    /*ET9300 Project Handler :( #else) lines 1326 to 1336 deleted*/
;;;966            }
;;;967    /*ECATCHANGE_END(V5.13) MBX2*/
;;;968    
;;;969            HW_EscWriteMbxMem((MEM_ADDR *)pMbx, u16EscAddrSendMbx, (mbxSize + MBX_HEADER_SIZE));
;;;970    
;;;971    
;;;972            {
;;;973            /*Read Control and Status of SyncManager 1 to check if the buffer is still marked as empty*/
;;;974    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1345 to 1349 deleted*/
;;;975            VARVOLATILE UINT16 smstate = 0x00;
;;;976            HW_EscReadWord(smstate,(ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
;;;977            smstate = SWAPWORD(smstate);
;;;978    /*ET9300 Project Handler :( #else) lines 1353 to 1356 deleted*/
;;;979    
;;;980            if(!(smstate & SM_STATUS_MBX_BUFFER_FULL))
;;;981            {
;;;982                
;;;983                UINT16 BytesLeft = u16SendMbxSize - (mbxSize + MBX_HEADER_SIZE);
;;;984    
;;;985                /*Write last Byte to trigger mailbox full flag*/
;;;986    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1366 to 1382 deleted*/
;;;987                /*Read last 2 Bytes and write them again (required if low Byte of the WORD were written before)*/
;;;988                u16dummy = 0;
;;;989                if(BytesLeft < 2)
;;;990                {
;;;991                    /*The last 2Bytes are overlapping the already written buffer*/
;;;992    
;;;993                    /*Get the valid 16Bit address*/
;;;994                    UINT32 LastDataAddress = ((mbxSize + MBX_HEADER_SIZE)/2);
;;;995                
;;;996                    /*Copy the buffer to overwrite*/
;;;997                    MEMCPY((UINT16 *)&u16dummy,(((UINT16 *)pMbx) + LastDataAddress),(2 - BytesLeft));
;;;998                }
;;;999    
;;;1000               HW_EscWriteWord(u16dummy, (u16EscAddrSendMbx + u16SendMbxSize - 2));
;;;1001   /*ET9300 Project Handler :( #else) lines 1397 to 1400 deleted*/
;;;1002           }
;;;1003           }
;;;1004   
;;;1005   /*ET9300 Project Handler :(#if !MAILBOX_QUEUE) lines 1404 to 1413 deleted*/
;;;1006           /* store last send mailbox service for a possible repeat
;;;1007               one buffer includes the last send service (psRepeatMbx),
;;;1008               the other one the actual service to be sent (psReadMbx),
;;;1009               there is no buffer available for a mailbox receive service
;;;1010               until the last sent buffer was read from the master
;;;1011               the exception is after the INIT2PREOP transition, in that
;;;1012               case there is no last sent service (psReadMbx = 0) */
;;;1013           if ( psReadMbx )
;;;1014           {
;;;1015               psWriteMbx = NULL;
;;;1016           }
;;;1017   /*ET9300 Project Handler :(#if !MAILBOX_QUEUE) lines 1425 to 1431 deleted*/
;;;1018           psReadMbx = pMbx;
;;;1019   
;;;1020           /* set flag that send mailbox is full now */
;;;1021           bSendMbxIsFull = TRUE;
;;;1022   
;;;1023   /*ET9300 Project Handler :(#if !MAILBOX_QUEUE) lines 1437 to 1440 deleted*/
;;;1024   
;;;1025           return 0;
;;;1026       }
;;;1027   }
000012  bdf8              POP      {r3-r7,pc}
                  |L3.20|
000014  4839              LDR      r0,|L3.252|
000016  7800              LDRB     r0,[r0,#0]            ;932  ; bMbxRunning
000018  b908              CBNZ     r0,|L3.30|
00001a  20f0              MOVS     r0,#0xf0              ;935
00001c  e7f9              B        |L3.18|
                  |L3.30|
00001e  4838              LDR      r0,|L3.256|
000020  7800              LDRB     r0,[r0,#0]            ;938  ; bSendMbxIsFull
000022  b108              CBZ      r0,|L3.40|
000024  2007              MOVS     r0,#7                 ;941
000026  e7f4              B        |L3.18|
                  |L3.40|
000028  8825              LDRH     r5,[r4,#0]            ;946
00002a  4836              LDR      r0,|L3.260|
00002c  8800              LDRH     r0,[r0,#0]            ;951  ; u16EscAddrSendMbx
00002e  4428              ADD      r0,r0,r5              ;951
000030  1d80              ADDS     r0,r0,#6              ;951
000032  b286              UXTH     r6,r0                 ;951
000034  4833              LDR      r0,|L3.260|
000036  8800              LDRH     r0,[r0,#0]            ;952  ; u16EscAddrSendMbx
000038  4933              LDR      r1,|L3.264|
00003a  8809              LDRH     r1,[r1,#0]            ;952  ; u16SendMbxSize
00003c  4408              ADD      r0,r0,r1              ;952
00003e  b287              UXTH     r7,r0                 ;952
000040  f64f70fe          MOV      r0,#0xfffe            ;955
000044  4006              ANDS     r6,r6,r0              ;955
000046  1eb8              SUBS     r0,r7,#2              ;956
000048  f64f71fe          MOV      r1,#0xfffe            ;956
00004c  ea000701          AND      r7,r0,r1              ;956
000050  2000              MOVS     r0,#0                 ;957
000052  492e              LDR      r1,|L3.268|
000054  8008              STRH     r0,[r1,#0]            ;957
000056  e006              B        |L3.102|
                  |L3.88|
000058  2202              MOVS     r2,#2                 ;962
00005a  4631              MOV      r1,r6                 ;962
00005c  482b              LDR      r0,|L3.268|
00005e  f7fffffe          BL       HW_EscWrite
000062  1cb0              ADDS     r0,r6,#2              ;963
000064  b286              UXTH     r6,r0                 ;963
                  |L3.102|
000066  42be              CMP      r6,r7                 ;960
000068  dbf6              BLT      |L3.88|
00006a  1da8              ADDS     r0,r5,#6              ;969
00006c  b282              UXTH     r2,r0                 ;969
00006e  4825              LDR      r0,|L3.260|
000070  8801              LDRH     r1,[r0,#0]            ;969  ; u16EscAddrSendMbx
000072  4620              MOV      r0,r4                 ;969
000074  f7fffffe          BL       HW_EscWrite
000078  2000              MOVS     r0,#0                 ;975
00007a  9000              STR      r0,[sp,#0]            ;975
00007c  2202              MOVS     r2,#2                 ;976
00007e  f640010c          MOV      r1,#0x80c             ;976
000082  4668              MOV      r0,sp                 ;976
000084  f7fffffe          BL       HW_EscRead
000088  f8bd0000          LDRH     r0,[sp,#0]            ;977
00008c  9000              STR      r0,[sp,#0]            ;977
00008e  f8bd0000          LDRH     r0,[sp,#0]            ;980
000092  f4006000          AND      r0,r0,#0x800          ;980
000096  bb08              CBNZ     r0,|L3.220|
000098  481b              LDR      r0,|L3.264|
00009a  8801              LDRH     r1,[r0,#0]            ;983  ; u16SendMbxSize
00009c  1da8              ADDS     r0,r5,#6              ;983
00009e  1a08              SUBS     r0,r1,r0              ;983
0000a0  b286              UXTH     r6,r0                 ;983
0000a2  2000              MOVS     r0,#0                 ;988
0000a4  4919              LDR      r1,|L3.268|
0000a6  8008              STRH     r0,[r1,#0]            ;988
0000a8  2e02              CMP      r6,#2                 ;989
0000aa  da0b              BGE      |L3.196|
0000ac  1da8              ADDS     r0,r5,#6              ;994
0000ae  eb0071d0          ADD      r1,r0,r0,LSR #31      ;994
0000b2  104f              ASRS     r7,r1,#1              ;994
0000b4  f1c60202          RSB      r2,r6,#2              ;997
0000b8  eb040147          ADD      r1,r4,r7,LSL #1       ;997
0000bc  4813              LDR      r0,|L3.268|
0000be  f7fffffe          BL       __aeabi_memcpy
0000c2  bf00              NOP                            ;998
                  |L3.196|
0000c4  480f              LDR      r0,|L3.260|
0000c6  8800              LDRH     r0,[r0,#0]            ;1000  ; u16EscAddrSendMbx
0000c8  4a0f              LDR      r2,|L3.264|
0000ca  8812              LDRH     r2,[r2,#0]            ;1000  ; u16SendMbxSize
0000cc  4410              ADD      r0,r0,r2              ;1000
0000ce  1e80              SUBS     r0,r0,#2              ;1000
0000d0  b281              UXTH     r1,r0                 ;1000
0000d2  2202              MOVS     r2,#2                 ;1000
0000d4  480d              LDR      r0,|L3.268|
0000d6  f7fffffe          BL       HW_EscWrite
0000da  bf00              NOP                            ;1002
                  |L3.220|
0000dc  480c              LDR      r0,|L3.272|
0000de  6800              LDR      r0,[r0,#0]            ;1013  ; psReadMbx
0000e0  b110              CBZ      r0,|L3.232|
0000e2  2000              MOVS     r0,#0                 ;1015
0000e4  490b              LDR      r1,|L3.276|
0000e6  6008              STR      r0,[r1,#0]            ;1015  ; psWriteMbx
                  |L3.232|
0000e8  4809              LDR      r0,|L3.272|
0000ea  6004              STR      r4,[r0,#0]            ;1018  ; psReadMbx
0000ec  2001              MOVS     r0,#1                 ;1021
0000ee  4904              LDR      r1,|L3.256|
0000f0  7008              STRB     r0,[r1,#0]            ;1021
0000f2  2000              MOVS     r0,#0                 ;1025
0000f4  e78d              B        |L3.18|
;;;1028   
                          ENDP

0000f6  0000              DCW      0x0000
                  |L3.248|
                          DCD      nAlStatus
                  |L3.252|
                          DCD      bMbxRunning
                  |L3.256|
                          DCD      bSendMbxIsFull
                  |L3.260|
                          DCD      u16EscAddrSendMbx
                  |L3.264|
                          DCD      u16SendMbxSize
                  |L3.268|
                          DCD      u16dummy
                  |L3.272|
                          DCD      psReadMbx
                  |L3.276|
                          DCD      psWriteMbx

                          AREA ||i.MBX_Init||, CODE, READONLY, ALIGN=2

                  MBX_Init PROC
;;;263    
;;;264    void MBX_Init(void)
000000  b508              PUSH     {r3,lr}
;;;265    {
;;;266        
;;;267        u16ReceiveMbxSize = MIN_MBX_SIZE;
000002  2024              MOVS     r0,#0x24
000004  4921              LDR      r1,|L4.140|
000006  8008              STRH     r0,[r1,#0]
;;;268        u16SendMbxSize = MAX_MBX_SIZE;
000008  f44f7080          MOV      r0,#0x100
00000c  4920              LDR      r1,|L4.144|
00000e  8008              STRH     r0,[r1,#0]
;;;269        u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
000010  0100              LSLS     r0,r0,#4
000012  4920              LDR      r1,|L4.148|
000014  8008              STRH     r0,[r1,#0]
;;;270        u16EscAddrSendMbx = MIN_MBX_READ_ADDRESS;
000016  f44f5084          MOV      r0,#0x1080
00001a  491f              LDR      r1,|L4.152|
00001c  8008              STRH     r0,[r1,#0]
;;;271    
;;;272        sMbxReceiveQueue.firstInQueue    = 0;
00001e  2000              MOVS     r0,#0
000020  491e              LDR      r1,|L4.156|
000022  8008              STRH     r0,[r1,#0]
;;;273        sMbxReceiveQueue.lastInQueue     = 0;
000024  8048              STRH     r0,[r1,#2]
;;;274        sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
000026  200a              MOVS     r0,#0xa
000028  8088              STRH     r0,[r1,#4]
;;;275        sMbxSendQueue.firstInQueue        = 0;
00002a  2000              MOVS     r0,#0
00002c  491c              LDR      r1,|L4.160|
00002e  8008              STRH     r0,[r1,#0]
;;;276        sMbxSendQueue.lastInQueue         = 0;
000030  8048              STRH     r0,[r1,#2]
;;;277        sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
000032  200a              MOVS     r0,#0xa
000034  8088              STRH     r0,[r1,#4]
;;;278        psWriteMbx  = NULL;
000036  2000              MOVS     r0,#0
000038  491a              LDR      r1,|L4.164|
00003a  6008              STR      r0,[r1,#0]  ; psWriteMbx
;;;279    /*ET9300 Project Handler :(#if MAILBOX_QUEUE #else) lines 304 to 306 deleted*/
;;;280    
;;;281    /*ET9300 Project Handler :(#if EOE_SUPPORTED) lines 308 to 310 deleted*/
;;;282    
;;;283        psRepeatMbx = NULL;
00003c  491a              LDR      r1,|L4.168|
00003e  6008              STR      r0,[r1,#0]  ; psRepeatMbx
;;;284        psReadMbx    = NULL;
000040  491a              LDR      r1,|L4.172|
000042  6008              STR      r0,[r1,#0]  ; psReadMbx
;;;285        psStoreMbx    = NULL;
000044  491a              LDR      r1,|L4.176|
000046  6008              STR      r0,[r1,#0]  ; psStoreMbx
;;;286    
;;;287        bMbxRepeatToggle    = FALSE;
000048  491a              LDR      r1,|L4.180|
00004a  7008              STRB     r0,[r1,#0]
;;;288        /*Reset Repeat acknowledge bit of SyncManager1 (0x80F bit 2)*/
;;;289    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 318 to 325 deleted*/
;;;290        {
;;;291            UINT16 sm1Activate = 0;
00004c  9000              STR      r0,[sp,#0]
;;;292            HW_EscReadWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
00004e  2202              MOVS     r2,#2
000050  f640010e          MOV      r1,#0x80e
000054  4668              MOV      r0,sp
000056  f7fffffe          BL       HW_EscRead
;;;293            sm1Activate &= SWAPWORD(~0x0200);
00005a  f8bd0000          LDRH     r0,[sp,#0]
00005e  f4207000          BIC      r0,r0,#0x200
000062  9000              STR      r0,[sp,#0]
;;;294            HW_EscWriteWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
000064  2202              MOVS     r2,#2
000066  f640010e          MOV      r1,#0x80e
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       HW_EscWrite
;;;295        }
;;;296    /*ET9300 Project Handler :( #else) lines 332 to 339 deleted*/
;;;297        bMbxRunning = FALSE;
000070  2000              MOVS     r0,#0
000072  4911              LDR      r1,|L4.184|
000074  7008              STRB     r0,[r1,#0]
;;;298        bSendMbxIsFull = FALSE;
000076  4911              LDR      r1,|L4.188|
000078  7008              STRB     r0,[r1,#0]
;;;299        bReceiveMbxIsLocked = FALSE;
00007a  4911              LDR      r1,|L4.192|
00007c  7008              STRB     r0,[r1,#0]
;;;300        u8MailboxSendReqStored    = 0;
00007e  4911              LDR      r1,|L4.196|
000080  7008              STRB     r0,[r1,#0]
;;;301        u8MbxWriteCounter = 0;
000082  4911              LDR      r1,|L4.200|
000084  7008              STRB     r0,[r1,#0]
;;;302        u8MbxReadCounter    = 0;
000086  4911              LDR      r1,|L4.204|
000088  7008              STRB     r0,[r1,#0]
;;;303    /*ET9300 Project Handler :(#if !MAILBOX_QUEUE) lines 346 to 348 deleted*/
;;;304    }
00008a  bd08              POP      {r3,pc}
;;;305    
                          ENDP

                  |L4.140|
                          DCD      u16ReceiveMbxSize
                  |L4.144|
                          DCD      u16SendMbxSize
                  |L4.148|
                          DCD      u16EscAddrReceiveMbx
                  |L4.152|
                          DCD      u16EscAddrSendMbx
                  |L4.156|
                          DCD      sMbxReceiveQueue
                  |L4.160|
                          DCD      sMbxSendQueue
                  |L4.164|
                          DCD      psWriteMbx
                  |L4.168|
                          DCD      psRepeatMbx
                  |L4.172|
                          DCD      psReadMbx
                  |L4.176|
                          DCD      psStoreMbx
                  |L4.180|
                          DCD      bMbxRepeatToggle
                  |L4.184|
                          DCD      bMbxRunning
                  |L4.188|
                          DCD      bSendMbxIsFull
                  |L4.192|
                          DCD      bReceiveMbxIsLocked
                  |L4.196|
                          DCD      u8MailboxSendReqStored
                  |L4.200|
                          DCD      u8MbxWriteCounter
                  |L4.204|
                          DCD      u8MbxReadCounter

                          AREA ||i.MBX_MailboxReadInd||, CODE, READONLY, ALIGN=2

                  MBX_MailboxReadInd PROC
;;;579    
;;;580    void MBX_MailboxReadInd(void)
000000  b510              PUSH     {r4,lr}
;;;581    {
;;;582        bSendMbxIsFull = FALSE;
000002  2000              MOVS     r0,#0
000004  4935              LDR      r1,|L5.220|
000006  7008              STRB     r0,[r1,#0]
;;;583    
;;;584    /*ET9300 Project Handler :(#if TEST_APPLICATION && EOE_SUPPORTED) lines 818 to 823 deleted*/
;;;585        // HBu 02.05.06: the pointer psRepeatMbx is only free if there is no stored
;;;586        //               mailbox service from the last repeat
;;;587        if (psRepeatMbx && psStoreMbx == NULL)
000008  4835              LDR      r0,|L5.224|
00000a  6800              LDR      r0,[r0,#0]  ; psRepeatMbx
00000c  b178              CBZ      r0,|L5.46|
00000e  4835              LDR      r0,|L5.228|
000010  6800              LDR      r0,[r0,#0]  ; psStoreMbx
000012  b960              CBNZ     r0,|L5.46|
;;;588        {
;;;589            /* the last sent service is not stored for repeat any longer */
;;;590    /*ECATCHANGE_START(V5.13) MBX3*/
;;;591            if (psReadMbx != psRepeatMbx)
000014  4834              LDR      r0,|L5.232|
000016  6800              LDR      r0,[r0,#0]  ; psReadMbx
000018  4931              LDR      r1,|L5.224|
00001a  6809              LDR      r1,[r1,#0]  ; psRepeatMbx
00001c  4288              CMP      r0,r1
00001e  d006              BEQ      |L5.46|
;;;592            {
;;;593                APPL_FreeMailboxBuffer(psRepeatMbx);
000020  482f              LDR      r0,|L5.224|
000022  6800              LDR      r0,[r0,#0]  ; psRepeatMbx
000024  f7fffffe          BL       free
;;;594                psRepeatMbx = NULL;
000028  2000              MOVS     r0,#0
00002a  492d              LDR      r1,|L5.224|
00002c  6008              STR      r0,[r1,#0]  ; psRepeatMbx
                  |L5.46|
;;;595            }
;;;596    /*ECATCHANGE_END(V5.13) MBX3*/
;;;597    
;;;598    /*ET9300 Project Handler :(#if MAILBOX_QUEUE #else) lines 838 to 840 deleted*/
;;;599        }
;;;600    
;;;601        /* the actual sent service has to be stored for repeat */
;;;602        psRepeatMbx = psReadMbx;
00002e  482e              LDR      r0,|L5.232|
000030  6800              LDR      r0,[r0,#0]  ; psReadMbx
000032  492b              LDR      r1,|L5.224|
000034  6008              STR      r0,[r1,#0]  ; psRepeatMbx
;;;603    
;;;604          if ( psStoreMbx )
000036  482b              LDR      r0,|L5.228|
000038  6800              LDR      r0,[r0,#0]  ; psStoreMbx
00003a  b138              CBZ      r0,|L5.76|
;;;605          {
;;;606            /* there was a buffer stored */
;;;607            MBX_CopyToSendMailbox(psStoreMbx);
00003c  4829              LDR      r0,|L5.228|
00003e  6800              LDR      r0,[r0,#0]  ; psStoreMbx
000040  f7fffffe          BL       MBX_CopyToSendMailbox
;;;608            /* no more buffer to be stored any more */
;;;609            psStoreMbx = NULL;
000044  2000              MOVS     r0,#0
000046  4927              LDR      r1,|L5.228|
000048  6008              STR      r0,[r1,#0]  ; psStoreMbx
00004a  e008              B        |L5.94|
                  |L5.76|
;;;610          }
;;;611          else
;;;612        {
;;;613            TMBX MBXMEM* pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
00004c  4827              LDR      r0,|L5.236|
00004e  f7fffffe          BL       GetOutOfMbxQueue
000052  4604              MOV      r4,r0
;;;614    
;;;615            
;;;616            if (pMbx)
000054  b114              CBZ      r4,|L5.92|
;;;617            {
;;;618                MBX_CopyToSendMailbox(pMbx);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       MBX_CopyToSendMailbox
                  |L5.92|
;;;619            }
;;;620        }
00005c  bf00              NOP      
                  |L5.94|
;;;621    
;;;622          if ( u8MailboxSendReqStored )
00005e  4824              LDR      r0,|L5.240|
000060  7800              LDRB     r0,[r0,#0]  ; u8MailboxSendReqStored
000062  b350              CBZ      r0,|L5.186|
;;;623        {
;;;624            /* there are mailbox services stored to be sent */
;;;625            if ( u8MailboxSendReqStored & EMCY_SERVICE )
000064  4822              LDR      r0,|L5.240|
000066  7800              LDRB     r0,[r0,#0]  ; u8MailboxSendReqStored
000068  f0000001          AND      r0,r0,#1
00006c  b168              CBZ      r0,|L5.138|
;;;626            {
;;;627                /* call EMCY function that will send the stored Emergency service */
;;;628                EMCY_ContinueInd(psWriteMbx);
00006e  4821              LDR      r0,|L5.244|
000070  6800              LDR      r0,[r0,#0]  ; psWriteMbx
000072  f7fffffe          BL       EMCY_ContinueInd
;;;629                if (EMCY_IsQueueEmpty())
000076  f7fffffe          BL       EMCY_IsQueueEmpty
00007a  b1f0              CBZ      r0,|L5.186|
;;;630                {
;;;631                    u8MailboxSendReqStored &= ~EMCY_SERVICE;
00007c  481c              LDR      r0,|L5.240|
00007e  7800              LDRB     r0,[r0,#0]  ; u8MailboxSendReqStored
000080  f0200001          BIC      r0,r0,#1
000084  491a              LDR      r1,|L5.240|
000086  7008              STRB     r0,[r1,#0]
000088  e027              B        |L5.218|
                  |L5.138|
;;;632                }
;;;633            }
;;;634            else
;;;635            if ( u8MailboxSendReqStored & COE_SERVICE )
00008a  4819              LDR      r0,|L5.240|
00008c  7800              LDRB     r0,[r0,#0]  ; u8MailboxSendReqStored
00008e  f0000002          AND      r0,r0,#2
000092  b198              CBZ      r0,|L5.188|
;;;636            {
;;;637               UINT8 result = 0;
000094  2400              MOVS     r4,#0
;;;638                /* reset the flag indicating that CoE service to be sent was stored */
;;;639                u8MailboxSendReqStored &= ~COE_SERVICE;
000096  4816              LDR      r0,|L5.240|
000098  7800              LDRB     r0,[r0,#0]  ; u8MailboxSendReqStored
00009a  f0200002          BIC      r0,r0,#2
00009e  4914              LDR      r1,|L5.240|
0000a0  7008              STRB     r0,[r1,#0]
;;;640    
;;;641                /* call CoE function that will send the stored CoE service */
;;;642                result = COE_ContinueInd(psWriteMbx);
0000a2  4814              LDR      r0,|L5.244|
0000a4  6800              LDR      r0,[r0,#0]  ; psWriteMbx
0000a6  f7fffffe          BL       COE_ContinueInd
0000aa  4604              MOV      r4,r0
;;;643    
;;;644                if (result != 0)
0000ac  b12c              CBZ      r4,|L5.186|
;;;645                {
;;;646                    /*Set the pending CoE indication is an error occurred during the continue indication*/
;;;647                    u8MailboxSendReqStored |= COE_SERVICE;
0000ae  4810              LDR      r0,|L5.240|
0000b0  7800              LDRB     r0,[r0,#0]  ; u8MailboxSendReqStored
0000b2  f0400002          ORR      r0,r0,#2
0000b6  490e              LDR      r1,|L5.240|
0000b8  7008              STRB     r0,[r1,#0]
                  |L5.186|
;;;648                }
;;;649            }
0000ba  e00e              B        |L5.218|
                  |L5.188|
;;;650            else
;;;651    /*ET9300 Project Handler :(#if SOE_SUPPORTED) lines 899 to 908 deleted*/
;;;652            if ( u8MailboxSendReqStored & FOE_SERVICE )
0000bc  480c              LDR      r0,|L5.240|
0000be  7800              LDRB     r0,[r0,#0]  ; u8MailboxSendReqStored
0000c0  f0000040          AND      r0,r0,#0x40
0000c4  b148              CBZ      r0,|L5.218|
;;;653            {
;;;654                /* reset the flag indicating that FoE service to be sent was stored */
;;;655                u8MailboxSendReqStored &= ~FOE_SERVICE;
0000c6  480a              LDR      r0,|L5.240|
0000c8  7800              LDRB     r0,[r0,#0]  ; u8MailboxSendReqStored
0000ca  f0200040          BIC      r0,r0,#0x40
0000ce  4908              LDR      r1,|L5.240|
0000d0  7008              STRB     r0,[r1,#0]
;;;656                /* call FoE function that will send the stored FoE service */
;;;657                FOE_ContinueInd(psWriteMbx);
0000d2  4808              LDR      r0,|L5.244|
0000d4  6800              LDR      r0,[r0,#0]  ; psWriteMbx
0000d6  f7fffffe          BL       FOE_ContinueInd
                  |L5.218|
;;;658            }
;;;659            else
;;;660    /*ET9300 Project Handler :(#if VOE_SUPPORTED) lines 919 to 928 deleted*/
;;;661    /*ECATCHANGE_START(V5.13) EOE1*/
;;;662    /*pending EoE commands are handled from the MBX_Main function*/
;;;663    /*ECATCHANGE_END(V5.13) EOE1*/
;;;664    
;;;665    /*ET9300 Project Handler :(#if MAILBOX_QUEUE #else) lines 934 to 944 deleted*/
;;;666            {
;;;667            }
;;;668        }
;;;669    }
0000da  bd10              POP      {r4,pc}
;;;670    
                          ENDP

                  |L5.220|
                          DCD      bSendMbxIsFull
                  |L5.224|
                          DCD      psRepeatMbx
                  |L5.228|
                          DCD      psStoreMbx
                  |L5.232|
                          DCD      psReadMbx
                  |L5.236|
                          DCD      sMbxSendQueue
                  |L5.240|
                          DCD      u8MailboxSendReqStored
                  |L5.244|
                          DCD      psWriteMbx

                          AREA ||i.MBX_MailboxRepeatReq||, CODE, READONLY, ALIGN=2

                  MBX_MailboxRepeatReq PROC
;;;676    
;;;677    void MBX_MailboxRepeatReq(void)
000000  b510              PUSH     {r4,lr}
;;;678    {
;;;679        if (psRepeatMbx)
000002  4814              LDR      r0,|L6.84|
000004  6800              LDR      r0,[r0,#0]  ; psRepeatMbx
000006  b1d8              CBZ      r0,|L6.64|
;;;680        {
;;;681            TMBX MBXMEM *pMbx = psRepeatMbx;
000008  4812              LDR      r0,|L6.84|
00000a  6804              LDR      r4,[r0,#0]  ; psRepeatMbx
;;;682            
;;;683            /* send mailbox service stored for repeat */
;;;684            /* HBu 13.10.06: if a repeat request is received (again) before the previously repeated mailbox telegram
;;;685               was read from the master (psStoreMbx != NULL) the next mailbox telegram to be sent is still in the
;;;686                read mailbox so it has not to updated exchanged */
;;;687            ENTER_MBX_CRITICAL;
;;;688    
;;;689           if (bSendMbxIsFull && psStoreMbx == NULL)
00000c  4812              LDR      r0,|L6.88|
00000e  7800              LDRB     r0,[r0,#0]  ; bSendMbxIsFull
000010  b178              CBZ      r0,|L6.50|
000012  4812              LDR      r0,|L6.92|
000014  6800              LDR      r0,[r0,#0]  ; psStoreMbx
000016  b960              CBNZ     r0,|L6.50|
;;;690            {
;;;691                /* mailbox is full, take the buffer off */
;;;692                DisableSyncManChannel(MAILBOX_READ);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       DisableSyncManChannel
;;;693    
;;;694                /* store the buffer to be sent next */
;;;695                psStoreMbx = psReadMbx;
00001e  4810              LDR      r0,|L6.96|
000020  6800              LDR      r0,[r0,#0]  ; psReadMbx
000022  490e              LDR      r1,|L6.92|
000024  6008              STR      r0,[r1,#0]  ; psStoreMbx
;;;696                /* enable the mailbox again */
;;;697                EnableSyncManChannel(MAILBOX_READ);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       EnableSyncManChannel
;;;698    
;;;699                /* HBu 15.02.06: flag has to be reset otherwise the mailbox service
;;;700                                 will not be copied by MBX_CopyToSendMailbox */
;;;701                bSendMbxIsFull = FALSE;
00002c  2000              MOVS     r0,#0
00002e  490a              LDR      r1,|L6.88|
000030  7008              STRB     r0,[r1,#0]
                  |L6.50|
;;;702            }
;;;703    
;;;704    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 983 to 987 deleted*/
;;;705    
;;;706            MBX_CopyToSendMailbox(pMbx);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       MBX_CopyToSendMailbox
;;;707            // HBu 17.06.06: psRepeatMbx has to be set to 0, when it was repeated, otherwise it would be returned twice
;;;708            // to the empty queue (MAILBOX_QUEUE=1) or a buffer get lost, if the the next repeat request will happen before
;;;709            // the repeated buffer was read
;;;710            psRepeatMbx = NULL;
000038  2000              MOVS     r0,#0
00003a  4906              LDR      r1,|L6.84|
00003c  6008              STR      r0,[r1,#0]  ; psRepeatMbx
;;;711            LEAVE_MBX_CRITICAL;
;;;712        }
00003e  bf00              NOP      
                  |L6.64|
;;;713    
;;;714        // Repeat was finished, toggle the acknowledge bit
;;;715        bMbxRepeatToggle = !bMbxRepeatToggle;
000040  4808              LDR      r0,|L6.100|
000042  7800              LDRB     r0,[r0,#0]  ; bMbxRepeatToggle
000044  b908              CBNZ     r0,|L6.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L6.76|
                  |L6.74|
00004a  2000              MOVS     r0,#0
                  |L6.76|
00004c  4905              LDR      r1,|L6.100|
00004e  7008              STRB     r0,[r1,#0]
;;;716    }
000050  bd10              POP      {r4,pc}
;;;717    
                          ENDP

000052  0000              DCW      0x0000
                  |L6.84|
                          DCD      psRepeatMbx
                  |L6.88|
                          DCD      bSendMbxIsFull
                  |L6.92|
                          DCD      psStoreMbx
                  |L6.96|
                          DCD      psReadMbx
                  |L6.100|
                          DCD      bMbxRepeatToggle

                          AREA ||i.MBX_MailboxSendReq||, CODE, READONLY, ALIGN=2

                  MBX_MailboxSendReq PROC
;;;740    
;;;741    UINT8 MBX_MailboxSendReq( TMBX MBXMEM * pMbx, UINT8 flags )
000000  b570              PUSH     {r4-r6,lr}
;;;742    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;743        UINT8 result = 0;
000006  2600              MOVS     r6,#0
;;;744    
;;;745        /* HBu 06.02.06: in INIT-state a mailbox send request shall be refused */
;;;746        if ( (nAlStatus & STATE_MASK) == STATE_INIT )
000008  481e              LDR      r0,|L7.132|
00000a  7800              LDRB     r0,[r0,#0]  ; nAlStatus
00000c  f000000f          AND      r0,r0,#0xf
000010  2801              CMP      r0,#1
000012  d101              BNE      |L7.24|
;;;747        {
;;;748            return ERROR_INVALIDSTATE;
000014  20f0              MOVS     r0,#0xf0
                  |L7.22|
;;;749        }
;;;750    
;;;751        
;;;752    
;;;753        ENTER_MBX_CRITICAL;
;;;754    
;;;755        /* the counter in the mailbox header has to be incremented with every new mailbox service to be sent
;;;756           if the mailbox data link layer is supported (software switch MAILBOX_REPEAT_SUPPORTED set)*/
;;;757        pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
;;;758        /* HBu 13.02.06: Repeat-Counter was incremented too much if the mailbox service could not be sent */
;;;759        /* u8MbxCounter holds the actual counter for the mailbox header, only the values
;;;760           1-7 are allowed if the mailbox data link layer is supported  */
;;;761        if ( (u8MbxReadCounter & 0x07) == 0 )
;;;762        {
;;;763            u8MbxReadCounter = 1;
;;;764        }
;;;765    
;;;766        pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
;;;767    
;;;768        /* try to copy the mailbox command in the ESC */
;;;769        if ( MBX_CopyToSendMailbox(pMbx) != 0 )
;;;770        {
;;;771            /* no success, send mailbox was full, set flag  */
;;;772            result = PutInMbxQueue(pMbx, &sMbxSendQueue);
;;;773            if (result != 0)
;;;774            {
;;;775                flags |= FRAGMENTS_FOLLOW;
;;;776            }
;;;777            else
;;;778            {
;;;779                u8MbxReadCounter++;
;;;780            }
;;;781    /*ET9300 Project Handler :(#if MAILBOX_QUEUE #else) lines 1067 to 1070 deleted*/
;;;782        }
;;;783        /* HBu 13.02.06: Repeat-Counter was incremented too much if the mailbox service could not be sent */
;;;784        else
;;;785        {
;;;786            u8MbxReadCounter++;
;;;787        }
;;;788    
;;;789    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 1078 to 1104 deleted*/
;;;790        if ( flags & FRAGMENTS_FOLLOW )
;;;791        {
;;;792            /* store the mailbox service that the corresponding XXX_ContinueInd function will
;;;793               be called when the send mailbox will have been read by the master because there
;;;794               are mailbox commands to be sent for this service */
;;;795            u8MailboxSendReqStored |= (flags & ((UINT8) ~FRAGMENTS_FOLLOW));
;;;796        }
;;;797    
;;;798        LEAVE_MBX_CRITICAL;
;;;799    
;;;800        return result;
;;;801    }
000016  bd70              POP      {r4-r6,pc}
                  |L7.24|
000018  88a0              LDRH     r0,[r4,#4]            ;757
00001a  f4204070          BIC      r0,r0,#0xf000         ;757
00001e  80a0              STRH     r0,[r4,#4]            ;757
000020  4819              LDR      r0,|L7.136|
000022  7800              LDRB     r0,[r0,#0]            ;761  ; u8MbxReadCounter
000024  f0000007          AND      r0,r0,#7              ;761
000028  b910              CBNZ     r0,|L7.48|
00002a  2001              MOVS     r0,#1                 ;763
00002c  4916              LDR      r1,|L7.136|
00002e  7008              STRB     r0,[r1,#0]            ;763
                  |L7.48|
000030  88a0              LDRH     r0,[r4,#4]            ;766
000032  4915              LDR      r1,|L7.136|
000034  7809              LDRB     r1,[r1,#0]            ;766  ; u8MbxReadCounter
000036  ea403001          ORR      r0,r0,r1,LSL #12      ;766
00003a  80a0              STRH     r0,[r4,#4]            ;766
00003c  4620              MOV      r0,r4                 ;769
00003e  f7fffffe          BL       MBX_CopyToSendMailbox
000042  b170              CBZ      r0,|L7.98|
000044  4911              LDR      r1,|L7.140|
000046  4620              MOV      r0,r4                 ;772
000048  f7fffffe          BL       PutInMbxQueue
00004c  4606              MOV      r6,r0                 ;772
00004e  b116              CBZ      r6,|L7.86|
000050  f0450580          ORR      r5,r5,#0x80           ;775
000054  e00a              B        |L7.108|
                  |L7.86|
000056  480c              LDR      r0,|L7.136|
000058  7800              LDRB     r0,[r0,#0]            ;779  ; u8MbxReadCounter
00005a  1c40              ADDS     r0,r0,#1              ;779
00005c  490a              LDR      r1,|L7.136|
00005e  7008              STRB     r0,[r1,#0]            ;779
000060  e004              B        |L7.108|
                  |L7.98|
000062  4809              LDR      r0,|L7.136|
000064  7800              LDRB     r0,[r0,#0]            ;786  ; u8MbxReadCounter
000066  1c40              ADDS     r0,r0,#1              ;786
000068  4907              LDR      r1,|L7.136|
00006a  7008              STRB     r0,[r1,#0]            ;786
                  |L7.108|
00006c  f0050080          AND      r0,r5,#0x80           ;790
000070  b130              CBZ      r0,|L7.128|
000072  f005007f          AND      r0,r5,#0x7f           ;795
000076  4906              LDR      r1,|L7.144|
000078  7809              LDRB     r1,[r1,#0]            ;795  ; u8MailboxSendReqStored
00007a  4308              ORRS     r0,r0,r1              ;795
00007c  4904              LDR      r1,|L7.144|
00007e  7008              STRB     r0,[r1,#0]            ;795
                  |L7.128|
000080  4630              MOV      r0,r6                 ;800
000082  e7c8              B        |L7.22|
;;;802    
                          ENDP

                  |L7.132|
                          DCD      nAlStatus
                  |L7.136|
                          DCD      u8MbxReadCounter
                  |L7.140|
                          DCD      sMbxSendQueue
                  |L7.144|
                          DCD      u8MailboxSendReqStored

                          AREA ||i.MBX_MailboxWriteInd||, CODE, READONLY, ALIGN=2

                  MBX_MailboxWriteInd PROC
;;;519    
;;;520    void MBX_MailboxWriteInd(TMBX MBXMEM *pMbx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;521    {
000004  4604              MOV      r4,r0
;;;522        UINT8 result = 0;
000006  2600              MOVS     r6,#0
;;;523        UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
000008  88a0              LDRH     r0,[r4,#4]
00000a  1305              ASRS     r5,r0,#12
;;;524        UINT16 MbxLen = SWAPWORD(pMbx->MbxHeader.Length);
00000c  8827              LDRH     r7,[r4,#0]
;;;525    
;;;526        if(MbxLen > MAX_MBX_SIZE)
00000e  f5b77f80          CMP      r7,#0x100
000012  dd0e              BLE      |L8.50|
;;;527        {
;;;528            /* Mailbox error response: size specified in mailbox header too large*/
;;;529            pMbx->MbxHeader.Length     = 4;
000014  2004              MOVS     r0,#4
000016  8020              STRH     r0,[r4,#0]
;;;530            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
000018  88a0              LDRH     r0,[r4,#4]
00001a  f4206070          BIC      r0,r0,#0xf00
00001e  80a0              STRH     r0,[r4,#4]
;;;531            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
000020  2001              MOVS     r0,#1
000022  80e0              STRH     r0,[r4,#6]
;;;532            pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
000024  2108              MOVS     r1,#8
000026  8121              STRH     r1,[r4,#8]
;;;533            MBX_MailboxSendReq(pMbx, 0);
000028  2100              MOVS     r1,#0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       MBX_MailboxSendReq
000030  e01e              B        |L8.112|
                  |L8.50|
;;;534        }
;;;535        else
;;;536        /* if the mailbox datagram counter (Bit 4-6 of Byte 5 of the mailbox header) is unequal zero,
;;;537           the master supports the mailbox data link layer,
;;;538            in that case a repeated mailbox write request will be detected, if the counter is unequal zero
;;;539            and unchanged */
;;;540        if ( mbxCounter == 0 || mbxCounter != u8MbxWriteCounter )
000032  b11d              CBZ      r5,|L8.60|
000034  480f              LDR      r0,|L8.116|
000036  7800              LDRB     r0,[r0,#0]  ; u8MbxWriteCounter
000038  4285              CMP      r5,r0
00003a  d015              BEQ      |L8.104|
                  |L8.60|
;;;541        {
;;;542    /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 745 to 769 deleted*/
;;;543            /* new mailbox service received */
;;;544            /* mbxCounter = 0: old EtherCAT master */
;;;545            /* new MBX service received, store the new mailbox counter */
;;;546            u8MbxWriteCounter = mbxCounter;
00003c  480d              LDR      r0,|L8.116|
00003e  7005              STRB     r5,[r0,#0]
;;;547    
;;;548            {
;;;549                /* check the protocol type and call the XXXX_ServiceInd-function */
;;;550    
;;;551                result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
000040  490d              LDR      r1,|L8.120|
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       PutInMbxQueue
000048  4606              MOV      r6,r0
;;;552    /*ET9300 Project Handler :(#if MAILBOX_QUEUE #else) lines 780 to 782 deleted*/
;;;553            }
;;;554    
;;;555            if ( result != 0 )
00004a  b18e              CBZ      r6,|L8.112|
;;;556            {
;;;557                /* Mailbox error response: type 0 (mailbox service protocol) */
;;;558                pMbx->MbxHeader.Length     = 4;
00004c  2004              MOVS     r0,#4
00004e  8020              STRH     r0,[r4,#0]
;;;559                pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
000050  88a0              LDRH     r0,[r4,#4]
000052  f4206070          BIC      r0,r0,#0xf00
000056  80a0              STRH     r0,[r4,#4]
;;;560                pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
000058  2001              MOVS     r0,#1
00005a  80e0              STRH     r0,[r4,#6]
;;;561                pMbx->Data[1]                        = SWAPWORD(result);
00005c  8126              STRH     r6,[r4,#8]
;;;562                MBX_MailboxSendReq(pMbx, 0);
00005e  2100              MOVS     r1,#0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       MBX_MailboxSendReq
000066  e003              B        |L8.112|
                  |L8.104|
;;;563            }
;;;564        }
;;;565        else
;;;566        {
;;;567            // the mailbox buffer has to be freed here
;;;568            APPL_FreeMailboxBuffer(pMbx);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       free
;;;569            pMbx = NULL;
00006e  2400              MOVS     r4,#0
                  |L8.112|
;;;570    
;;;571    /*ET9300 Project Handler :(#if MAILBOX_QUEUE #else) lines 802 to 805 deleted*/
;;;572        }
;;;573    }
000070  e8bd81f0          POP      {r4-r8,pc}
;;;574    
                          ENDP

                  |L8.116|
                          DCD      u8MbxWriteCounter
                  |L8.120|
                          DCD      sMbxReceiveQueue

                          AREA ||i.MBX_Main||, CODE, READONLY, ALIGN=2

                  MBX_Main PROC
;;;1034   
;;;1035   void MBX_Main(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1036   {
;;;1037       TMBX MBXMEM *pMbx = NULL;
000002  2400              MOVS     r4,#0
;;;1038   
;;;1039       do
000004  bf00              NOP      
                  |L9.6|
;;;1040       {
;;;1041           UINT8 result = 0;
000006  2500              MOVS     r5,#0
;;;1042   
;;;1043           pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
000008  4817              LDR      r0,|L9.104|
00000a  f7fffffe          BL       GetOutOfMbxQueue
00000e  4604              MOV      r4,r0
;;;1044           if ( pMbx )
000010  b11c              CBZ      r4,|L9.26|
;;;1045           {
;;;1046               result = MailboxServiceInd(pMbx);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       MailboxServiceInd
000018  4605              MOV      r5,r0
                  |L9.26|
;;;1047           }
;;;1048   
;;;1049           if ( result != 0 )
00001a  b165              CBZ      r5,|L9.54|
;;;1050           {
;;;1051               /* Mailbox error response: type 0 (mailbox service protocol) */
;;;1052               pMbx->MbxHeader.Length     = 4;
00001c  2004              MOVS     r0,#4
00001e  8020              STRH     r0,[r4,#0]
;;;1053               pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
000020  88a0              LDRH     r0,[r4,#4]
000022  f4206070          BIC      r0,r0,#0xf00
000026  80a0              STRH     r0,[r4,#4]
;;;1054               pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
000028  2001              MOVS     r0,#1
00002a  80e0              STRH     r0,[r4,#6]
;;;1055               pMbx->Data[1]                        = SWAPWORD(result);
00002c  8125              STRH     r5,[r4,#8]
;;;1056               MBX_MailboxSendReq(pMbx, 0);
00002e  2100              MOVS     r1,#0
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       MBX_MailboxSendReq
                  |L9.54|
;;;1057           }
;;;1058       }
;;;1059       while ( pMbx != NULL );
000036  2c00              CMP      r4,#0
000038  d1e5              BNE      |L9.6|
;;;1060   /*ET9300 Project Handler :(#if MAILBOX_QUEUE #else) lines 1478 to 1480 deleted*/
;;;1061   
;;;1062       //dump queued emcy message if send mailbox buffer is empty
;;;1063       if(bMbxRunning && !bSendMbxIsFull && !EMCY_IsQueueEmpty())
00003a  480c              LDR      r0,|L9.108|
00003c  7800              LDRB     r0,[r0,#0]  ; bMbxRunning
00003e  b160              CBZ      r0,|L9.90|
000040  480b              LDR      r0,|L9.112|
000042  7800              LDRB     r0,[r0,#0]  ; bSendMbxIsFull
000044  b948              CBNZ     r0,|L9.90|
000046  f7fffffe          BL       EMCY_IsQueueEmpty
00004a  b930              CBNZ     r0,|L9.90|
;;;1064       {
;;;1065           TEMCYMESSAGE EMCYMEM *pEmcy = GetOutOfSendEmcyQueue();
00004c  f7fffffe          BL       GetOutOfSendEmcyQueue
000050  4605              MOV      r5,r0
;;;1066           EMCY_SendEmergency(pEmcy);
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       EMCY_SendEmergency
;;;1067       }
000058  bf00              NOP      
                  |L9.90|
;;;1068   
;;;1069       if (bReceiveMbxIsLocked)
00005a  4806              LDR      r0,|L9.116|
00005c  7800              LDRB     r0,[r0,#0]  ; bReceiveMbxIsLocked
00005e  b108              CBZ      r0,|L9.100|
;;;1070       {
;;;1071           /* the work on the receive mailbox is locked, check if it can be unlocked (if all
;;;1072              mailbox commands has been sent */
;;;1073           MBX_CheckAndCopyMailbox();
000060  f7fffffe          BL       MBX_CheckAndCopyMailbox
                  |L9.100|
;;;1074       }
;;;1075   
;;;1076       /*ECATCHANGE_START(V5.13) EOE1*/
;;;1077       /*Try to send pending Mailbox data,
;;;1078          could be to pending previously due to local (memory) limitations which are no available*/
;;;1079       if (u8MailboxSendReqStored)
;;;1080       {
;;;1081           /* there are mailbox services stored to be sent */
;;;1082   /*ET9300 Project Handler :(#if EOE_SUPPORTED) lines 1505 to 1513 deleted*/
;;;1083       }
;;;1084   /*ECATCHANGE_END(V5.13) EOE1*/
;;;1085   }
000064  bd70              POP      {r4-r6,pc}
;;;1086   
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      sMbxReceiveQueue
                  |L9.108|
                          DCD      bMbxRunning
                  |L9.112|
                          DCD      bSendMbxIsFull
                  |L9.116|
                          DCD      bReceiveMbxIsLocked

                          AREA ||i.MBX_StartMailboxHandler||, CODE, READONLY, ALIGN=2

                  MBX_StartMailboxHandler PROC
;;;315    *////////////////////////////////////////////////////////////////////////////////////////
;;;316    UINT16 MBX_StartMailboxHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;317    {
;;;318        UINT16 result = 0;
000002  2500              MOVS     r5,#0
;;;319        
;;;320        /* get address of the receive mailbox sync manager (SM0) */
;;;321        TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       GetSyncMan
00000a  4604              MOV      r4,r0
;;;322    
;;;323    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 368 to 373 deleted*/
;;;324        /* store size of the receive mailbox */
;;;325        u16ReceiveMbxSize     = pSyncMan->Length;
00000c  8860              LDRH     r0,[r4,#2]
00000e  492b              LDR      r1,|L10.188|
000010  8008              STRH     r0,[r1,#0]
;;;326        /* store the address of the receive mailbox */
;;;327        u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
000012  8820              LDRH     r0,[r4,#0]
000014  492a              LDR      r1,|L10.192|
000016  8008              STRH     r0,[r1,#0]
;;;328    
;;;329        /* get address of the send mailbox sync manager (SM1) */
;;;330        pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       GetSyncMan
00001e  4604              MOV      r4,r0
;;;331    
;;;332    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 383 to 388 deleted*/
;;;333        /* store the size of the send mailbox */
;;;334        u16SendMbxSize = pSyncMan->Length;
000020  8860              LDRH     r0,[r4,#2]
000022  4928              LDR      r1,|L10.196|
000024  8008              STRH     r0,[r1,#0]
;;;335        /* store the address of the send mailbox */
;;;336        u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
000026  8820              LDRH     r0,[r4,#0]
000028  4927              LDR      r1,|L10.200|
00002a  8008              STRH     r0,[r1,#0]
;;;337    
;;;338        // HBu 02.05.06: it should be checked if there are overlaps in the sync manager areas
;;;339        if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
00002c  4824              LDR      r0,|L10.192|
00002e  8800              LDRH     r0,[r0,#0]  ; u16EscAddrReceiveMbx
000030  4922              LDR      r1,|L10.188|
000032  8809              LDRH     r1,[r1,#0]  ; u16ReceiveMbxSize
000034  4408              ADD      r0,r0,r1
000036  4924              LDR      r1,|L10.200|
000038  8809              LDRH     r1,[r1,#0]  ; u16EscAddrSendMbx
00003a  4288              CMP      r0,r1
00003c  dd0a              BLE      |L10.84|
00003e  4822              LDR      r0,|L10.200|
000040  8800              LDRH     r0,[r0,#0]  ; u16EscAddrSendMbx
000042  4920              LDR      r1,|L10.196|
000044  8809              LDRH     r1,[r1,#0]  ; u16SendMbxSize
000046  4408              ADD      r0,r0,r1
000048  491d              LDR      r1,|L10.192|
00004a  8809              LDRH     r1,[r1,#0]  ; u16EscAddrReceiveMbx
00004c  4288              CMP      r0,r1
00004e  dd01              BLE      |L10.84|
;;;340        {
;;;341            return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
000050  2016              MOVS     r0,#0x16
                  |L10.82|
;;;342        }
;;;343    /*ET9300 Project Handler :(#if AOE_SUPPORTED) lines 400 to 408 deleted*/
;;;344    
;;;345        u16FoeMaxSendBlockSize = (u16SendMbxSize - SIZEOF(TFOEHEADER) - MBX_HEADER_SIZE);
;;;346    
;;;347        /* enable the receive mailbox sync manager channel */
;;;348        EnableSyncManChannel(MAILBOX_WRITE);
;;;349        /* enable the send mailbox sync manager channel */
;;;350        EnableSyncManChannel(MAILBOX_READ);
;;;351    
;;;352            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
;;;353            if(psWriteMbx == NULL)
;;;354            {
;;;355                bNoMbxMemoryAvailable = TRUE;
;;;356    
;;;357                //check if at least enough memory for an mailbox error is available (other wise stop the state transition)
;;;358                psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
;;;359                if(psWriteMbx == NULL)
;;;360                {
;;;361                    result = ALSTATUSCODE_NOMEMORY;
;;;362                }
;;;363    
;;;364                APPL_FreeMailboxBuffer(psWriteMbx);
;;;365                psWriteMbx = NULL;
;;;366            }
;;;367            else
;;;368            {
;;;369                bNoMbxMemoryAvailable = FALSE;
;;;370                APPL_FreeMailboxBuffer(psWriteMbx);
;;;371                psWriteMbx = NULL;
;;;372            }
;;;373    
;;;374        return result;
;;;375    }
000052  bd70              POP      {r4-r6,pc}
                  |L10.84|
000054  481b              LDR      r0,|L10.196|
000056  8800              LDRH     r0,[r0,#0]            ;345  ; u16SendMbxSize
000058  380c              SUBS     r0,r0,#0xc            ;345
00005a  491c              LDR      r1,|L10.204|
00005c  8008              STRH     r0,[r1,#0]            ;345
00005e  2000              MOVS     r0,#0                 ;348
000060  f7fffffe          BL       EnableSyncManChannel
000064  2001              MOVS     r0,#1                 ;350
000066  f7fffffe          BL       EnableSyncManChannel
00006a  4814              LDR      r0,|L10.188|
00006c  8800              LDRH     r0,[r0,#0]            ;352  ; u16ReceiveMbxSize
00006e  f7fffffe          BL       malloc
000072  4917              LDR      r1,|L10.208|
000074  6008              STR      r0,[r1,#0]            ;352  ; psWriteMbx
000076  4608              MOV      r0,r1                 ;353
000078  6800              LDR      r0,[r0,#0]            ;353  ; psWriteMbx
00007a  b998              CBNZ     r0,|L10.164|
00007c  2001              MOVS     r0,#1                 ;355
00007e  4915              LDR      r1,|L10.212|
000080  7008              STRB     r0,[r1,#0]            ;355
000082  200a              MOVS     r0,#0xa               ;358
000084  f7fffffe          BL       malloc
000088  4911              LDR      r1,|L10.208|
00008a  6008              STR      r0,[r1,#0]            ;358  ; psWriteMbx
00008c  4608              MOV      r0,r1                 ;359
00008e  6800              LDR      r0,[r0,#0]            ;359  ; psWriteMbx
000090  b900              CBNZ     r0,|L10.148|
000092  2502              MOVS     r5,#2                 ;361
                  |L10.148|
000094  480e              LDR      r0,|L10.208|
000096  6800              LDR      r0,[r0,#0]            ;364  ; psWriteMbx
000098  f7fffffe          BL       free
00009c  2000              MOVS     r0,#0                 ;365
00009e  490c              LDR      r1,|L10.208|
0000a0  6008              STR      r0,[r1,#0]            ;365  ; psWriteMbx
0000a2  e009              B        |L10.184|
                  |L10.164|
0000a4  2000              MOVS     r0,#0                 ;369
0000a6  490b              LDR      r1,|L10.212|
0000a8  7008              STRB     r0,[r1,#0]            ;369
0000aa  4809              LDR      r0,|L10.208|
0000ac  6800              LDR      r0,[r0,#0]            ;370  ; psWriteMbx
0000ae  f7fffffe          BL       free
0000b2  2000              MOVS     r0,#0                 ;371
0000b4  4906              LDR      r1,|L10.208|
0000b6  6008              STR      r0,[r1,#0]            ;371  ; psWriteMbx
                  |L10.184|
0000b8  4628              MOV      r0,r5                 ;374
0000ba  e7ca              B        |L10.82|
;;;376    
                          ENDP

                  |L10.188|
                          DCD      u16ReceiveMbxSize
                  |L10.192|
                          DCD      u16EscAddrReceiveMbx
                  |L10.196|
                          DCD      u16SendMbxSize
                  |L10.200|
                          DCD      u16EscAddrSendMbx
                  |L10.204|
                          DCD      u16FoeMaxSendBlockSize
                  |L10.208|
                          DCD      psWriteMbx
                  |L10.212|
                          DCD      bNoMbxMemoryAvailable

                          AREA ||i.MBX_StopMailboxHandler||, CODE, READONLY, ALIGN=2

                  MBX_StopMailboxHandler PROC
;;;385    
;;;386    void MBX_StopMailboxHandler(void)
000000  b538              PUSH     {r3-r5,lr}
;;;387    {
;;;388        TMBX MBXMEM * pMbx;
;;;389    
;;;390        /* mailbox handler is stopped */
;;;391        bMbxRunning = FALSE;
000002  2000              MOVS     r0,#0
000004  4939              LDR      r1,|L11.236|
000006  7008              STRB     r0,[r1,#0]
;;;392        /* disable the receive mailbox sync manager channel */
;;;393        DisableSyncManChannel(MAILBOX_WRITE);
000008  f7fffffe          BL       DisableSyncManChannel
;;;394        /* disable the send mailbox sync manager channel */
;;;395        DisableSyncManChannel(MAILBOX_READ);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       DisableSyncManChannel
;;;396        /* initialize variables again */
;;;397    
;;;398    
;;;399        if (psRepeatMbx != NULL)
000012  4837              LDR      r0,|L11.240|
000014  6800              LDR      r0,[r0,#0]  ; psRepeatMbx
000016  b118              CBZ      r0,|L11.32|
;;;400        {
;;;401            APPL_FreeMailboxBuffer(psRepeatMbx);
000018  4835              LDR      r0,|L11.240|
00001a  6800              LDR      r0,[r0,#0]  ; psRepeatMbx
00001c  f7fffffe          BL       free
                  |L11.32|
;;;402        }
;;;403    
;;;404        if (psStoreMbx != NULL && psStoreMbx != psRepeatMbx)
000020  4834              LDR      r0,|L11.244|
000022  6800              LDR      r0,[r0,#0]  ; psStoreMbx
000024  b148              CBZ      r0,|L11.58|
000026  4833              LDR      r0,|L11.244|
000028  6800              LDR      r0,[r0,#0]  ; psStoreMbx
00002a  4931              LDR      r1,|L11.240|
00002c  6809              LDR      r1,[r1,#0]  ; psRepeatMbx
00002e  4288              CMP      r0,r1
000030  d003              BEQ      |L11.58|
;;;405        {
;;;406            APPL_FreeMailboxBuffer(psStoreMbx);
000032  4830              LDR      r0,|L11.244|
000034  6800              LDR      r0,[r0,#0]  ; psStoreMbx
000036  f7fffffe          BL       free
                  |L11.58|
;;;407        }
;;;408    
;;;409        if (psReadMbx != NULL && psReadMbx != psRepeatMbx && psReadMbx != psStoreMbx)
00003a  482f              LDR      r0,|L11.248|
00003c  6800              LDR      r0,[r0,#0]  ; psReadMbx
00003e  b178              CBZ      r0,|L11.96|
000040  482d              LDR      r0,|L11.248|
000042  6800              LDR      r0,[r0,#0]  ; psReadMbx
000044  492a              LDR      r1,|L11.240|
000046  6809              LDR      r1,[r1,#0]  ; psRepeatMbx
000048  4288              CMP      r0,r1
00004a  d009              BEQ      |L11.96|
00004c  482a              LDR      r0,|L11.248|
00004e  6800              LDR      r0,[r0,#0]  ; psReadMbx
000050  4928              LDR      r1,|L11.244|
000052  6809              LDR      r1,[r1,#0]  ; psStoreMbx
000054  4288              CMP      r0,r1
000056  d003              BEQ      |L11.96|
;;;410        {
;;;411            APPL_FreeMailboxBuffer(psReadMbx);
000058  4827              LDR      r0,|L11.248|
00005a  6800              LDR      r0,[r0,#0]  ; psReadMbx
00005c  f7fffffe          BL       free
                  |L11.96|
;;;412        }
;;;413    
;;;414    /*ET9300 Project Handler :(#if MAILBOX_QUEUE #else) lines 486 to 488 deleted*/
;;;415    
;;;416        SDOS_ClearPendingResponse();
000060  f7fffffe          BL       SDOS_ClearPendingResponse
;;;417    
;;;418    /*ET9300 Project Handler :(#if EOE_SUPPORTED) lines 494 to 496 deleted*/
;;;419    
;;;420        FOE_Init();
000064  f7fffffe          BL       FOE_Init
;;;421    
;;;422        psWriteMbx = NULL;
000068  2000              MOVS     r0,#0
00006a  4924              LDR      r1,|L11.252|
00006c  6008              STR      r0,[r1,#0]  ; psWriteMbx
;;;423        psRepeatMbx = NULL;
00006e  4920              LDR      r1,|L11.240|
000070  6008              STR      r0,[r1,#0]  ; psRepeatMbx
;;;424        psReadMbx = NULL;
000072  4921              LDR      r1,|L11.248|
000074  6008              STR      r0,[r1,#0]  ; psReadMbx
;;;425        psStoreMbx = NULL;
000076  491f              LDR      r1,|L11.244|
000078  6008              STR      r0,[r1,#0]  ; psStoreMbx
;;;426    
;;;427        bMbxRepeatToggle    = FALSE;
00007a  4921              LDR      r1,|L11.256|
00007c  7008              STRB     r0,[r1,#0]
;;;428        /*Reset Repeat acknowledge bit of SyncManager1 (0x080F bit 2)*/
;;;429    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 511 to 518 deleted*/
;;;430        {
;;;431            UINT16 sm1Activate = 0;
00007e  9000              STR      r0,[sp,#0]
;;;432            HW_EscReadWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
000080  2202              MOVS     r2,#2
000082  f640010e          MOV      r1,#0x80e
000086  4668              MOV      r0,sp
000088  f7fffffe          BL       HW_EscRead
;;;433            sm1Activate &= SWAPWORD(~0x0200);
00008c  f8bd0000          LDRH     r0,[sp,#0]
000090  f4207000          BIC      r0,r0,#0x200
000094  9000              STR      r0,[sp,#0]
;;;434            HW_EscWriteWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
000096  2202              MOVS     r2,#2
000098  f640010e          MOV      r1,#0x80e
00009c  4668              MOV      r0,sp
00009e  f7fffffe          BL       HW_EscWrite
;;;435        }
;;;436    /*ET9300 Project Handler :( #else) lines 525 to 532 deleted*/
;;;437        bSendMbxIsFull         = FALSE;
0000a2  2000              MOVS     r0,#0
0000a4  4917              LDR      r1,|L11.260|
0000a6  7008              STRB     r0,[r1,#0]
;;;438        bReceiveMbxIsLocked = FALSE;
0000a8  4917              LDR      r1,|L11.264|
0000aa  7008              STRB     r0,[r1,#0]
;;;439        u8MailboxSendReqStored    = 0;
0000ac  4917              LDR      r1,|L11.268|
0000ae  7008              STRB     r0,[r1,#0]
;;;440        u8MbxWriteCounter         = 0;
0000b0  4917              LDR      r1,|L11.272|
0000b2  7008              STRB     r0,[r1,#0]
;;;441        u8MbxReadCounter        = 0;
0000b4  4917              LDR      r1,|L11.276|
0000b6  7008              STRB     r0,[r1,#0]
;;;442    
;;;443        do
0000b8  bf00              NOP      
                  |L11.186|
;;;444        {
;;;445            pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
0000ba  4817              LDR      r0,|L11.280|
0000bc  f7fffffe          BL       GetOutOfMbxQueue
0000c0  4604              MOV      r4,r0
;;;446            if (pMbx)
0000c2  b114              CBZ      r4,|L11.202|
;;;447            {
;;;448                APPL_FreeMailboxBuffer(pMbx);
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       free
                  |L11.202|
;;;449            }
;;;450        } while (pMbx != NULL);
0000ca  2c00              CMP      r4,#0
0000cc  d1f5              BNE      |L11.186|
;;;451        
;;;452        do
0000ce  bf00              NOP      
                  |L11.208|
;;;453        {
;;;454            pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
0000d0  4812              LDR      r0,|L11.284|
0000d2  f7fffffe          BL       GetOutOfMbxQueue
0000d6  4604              MOV      r4,r0
;;;455            if (pMbx)
0000d8  b114              CBZ      r4,|L11.224|
;;;456            {
;;;457                APPL_FreeMailboxBuffer(pMbx);
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       free
                  |L11.224|
;;;458            }
;;;459        } while (pMbx != NULL);
0000e0  2c00              CMP      r4,#0
0000e2  d1f5              BNE      |L11.208|
;;;460    /*ET9300 Project Handler :(#if MAILBOX_QUEUE #else) lines 557 to 559 deleted*/
;;;461    
;;;462        EMCY_Init();
0000e4  f7fffffe          BL       EMCY_Init
;;;463    }
0000e8  bd38              POP      {r3-r5,pc}
;;;464    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L11.236|
                          DCD      bMbxRunning
                  |L11.240|
                          DCD      psRepeatMbx
                  |L11.244|
                          DCD      psStoreMbx
                  |L11.248|
                          DCD      psReadMbx
                  |L11.252|
                          DCD      psWriteMbx
                  |L11.256|
                          DCD      bMbxRepeatToggle
                  |L11.260|
                          DCD      bSendMbxIsFull
                  |L11.264|
                          DCD      bReceiveMbxIsLocked
                  |L11.268|
                          DCD      u8MailboxSendReqStored
                  |L11.272|
                          DCD      u8MbxWriteCounter
                  |L11.276|
                          DCD      u8MbxReadCounter
                  |L11.280|
                          DCD      sMbxReceiveQueue
                  |L11.284|
                          DCD      sMbxSendQueue

                          AREA ||i.MailboxServiceInd||, CODE, READONLY, ALIGN=2

                  MailboxServiceInd PROC
;;;472    
;;;473    UINT8 MailboxServiceInd(TMBX MBXMEM *pMbx)
000000  b570              PUSH     {r4-r6,lr}
;;;474    {
000002  4605              MOV      r5,r0
;;;475        UINT8 result;
;;;476    
;;;477        /*only FoE is allowed in Boot mode*/
;;;478        if(bBootMode == TRUE && (MBX_TYPE_FOE != ((pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )))
000004  4810              LDR      r0,|L12.72|
000006  7800              LDRB     r0,[r0,#0]  ; bBootMode
000008  2801              CMP      r0,#1
00000a  d106              BNE      |L12.26|
00000c  88a8              LDRH     r0,[r5,#4]
00000e  f3c02003          UBFX     r0,r0,#8,#4
000012  2804              CMP      r0,#4
000014  d001              BEQ      |L12.26|
;;;479        {
;;;480            return MBXERR_UNSUPPORTEDPROTOCOL;
000016  2002              MOVS     r0,#2
                  |L12.24|
;;;481        }
;;;482    
;;;483        switch ( (pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )
;;;484        {
;;;485    /*ET9300 Project Handler :(#if AOE_SUPPORTED) lines 588 to 594 deleted*/
;;;486        case MBX_TYPE_COE:
;;;487            /* CoE datagram received */
;;;488            result = COE_ServiceInd((TCOEMBX MBXMEM *) pMbx);
;;;489            break;
;;;490    
;;;491    /*ET9300 Project Handler :(#if SOE_SUPPORTED) lines 602 to 608 deleted*/
;;;492    /*ET9300 Project Handler :(#if EOE_SUPPORTED) lines 609 to 619 deleted*/
;;;493        case MBX_TYPE_FOE:
;;;494            /* FoE datagram received */
;;;495            result = FOE_ServiceInd((TFOEMBX MBXMEM *) pMbx);
;;;496            break;
;;;497    
;;;498    /*ET9300 Project Handler :(#if VOE_SUPPORTED) lines 627 to 633 deleted*/
;;;499        default:
;;;500    
;;;501    /*ET9300 Project Handler :(#if TEST_APPLICATION && EOE_SUPPORTED) lines 636 to 704 deleted*/
;;;502            result = MBXERR_UNSUPPORTEDPROTOCOL;
;;;503            break;
;;;504        }
;;;505    
;;;506        return result;
;;;507    }
000018  bd70              POP      {r4-r6,pc}
                  |L12.26|
00001a  88a8              LDRH     r0,[r5,#4]            ;483
00001c  f3c02003          UBFX     r0,r0,#8,#4           ;483
000020  2803              CMP      r0,#3                 ;483
000022  d002              BEQ      |L12.42|
000024  2804              CMP      r0,#4                 ;483
000026  d10a              BNE      |L12.62|
000028  e004              B        |L12.52|
                  |L12.42|
00002a  4628              MOV      r0,r5                 ;488
00002c  f7fffffe          BL       COE_ServiceInd
000030  4604              MOV      r4,r0                 ;488
000032  e006              B        |L12.66|
                  |L12.52|
000034  4628              MOV      r0,r5                 ;495
000036  f7fffffe          BL       FOE_ServiceInd
00003a  4604              MOV      r4,r0                 ;495
00003c  e001              B        |L12.66|
                  |L12.62|
00003e  2402              MOVS     r4,#2                 ;502
000040  bf00              NOP                            ;503
                  |L12.66|
000042  bf00              NOP                            ;489
000044  4620              MOV      r0,r4                 ;506
000046  e7e7              B        |L12.24|
;;;508    
                          ENDP

                  |L12.72|
                          DCD      bBootMode

                          AREA ||i.PutInMbxQueue||, CODE, READONLY, ALIGN=1

                  PutInMbxQueue PROC
;;;195    
;;;196    UINT8 PutInMbxQueue(TMBX MBXMEM * pMbx, TMBXQUEUE MBXMEM * pQueue)
000000  b510              PUSH     {r4,lr}
;;;197    {
000002  4603              MOV      r3,r0
;;;198        UINT16 lastInQueue;
;;;199        ENTER_MBX_CRITICAL;
;;;200    
;;;201    
;;;202        lastInQueue = pQueue->lastInQueue+1;
000004  8848              LDRH     r0,[r1,#2]
000006  1c40              ADDS     r0,r0,#1
000008  b282              UXTH     r2,r0
;;;203        if (lastInQueue == pQueue->maxQueueSize)
00000a  8888              LDRH     r0,[r1,#4]
00000c  4290              CMP      r0,r2
00000e  d100              BNE      |L13.18|
;;;204        {
;;;205            // Umbruch der Queue
;;;206            lastInQueue = 0;
000010  2200              MOVS     r2,#0
                  |L13.18|
;;;207        }
;;;208    
;;;209        if (pQueue->firstInQueue == lastInQueue)
000012  8808              LDRH     r0,[r1,#0]
000014  4290              CMP      r0,r2
000016  d101              BNE      |L13.28|
;;;210        {
;;;211            // Ueberlauf der Queue -> letztes Element wieder herausnehmen
;;;212            LEAVE_MBX_CRITICAL;
;;;213            return MBXERR_NOMOREMEMORY;
000018  2007              MOVS     r0,#7
                  |L13.26|
;;;214        }
;;;215    
;;;216        pQueue->queue[pQueue->lastInQueue] = pMbx;
;;;217        pQueue->lastInQueue = lastInQueue;
;;;218    
;;;219        LEAVE_MBX_CRITICAL;
;;;220    
;;;221        return 0;
;;;222    }
00001a  bd10              POP      {r4,pc}
                  |L13.28|
00001c  884c              LDRH     r4,[r1,#2]            ;216
00001e  f1010008          ADD      r0,r1,#8              ;216
000022  f8403024          STR      r3,[r0,r4,LSL #2]     ;216
000026  804a              STRH     r2,[r1,#2]            ;217
000028  2000              MOVS     r0,#0                 ;221
00002a  e7f6              B        |L13.26|
;;;223    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sMbxSendQueue
                          %        52
                  sMbxReceiveQueue
                          %        52

                          AREA ||.data||, DATA, ALIGN=2

                  bReceiveMbxIsLocked
000000  00                DCB      0x00
                  bSendMbxIsFull
000001  00                DCB      0x00
                  bMbxRunning
000002  00                DCB      0x00
                  bMbxRepeatToggle
000003  00                DCB      0x00
                  u16SendMbxSize
000004  0000              DCB      0x00,0x00
                  u16ReceiveMbxSize
000006  0000              DCB      0x00,0x00
                  u16EscAddrReceiveMbx
000008  0000              DCB      0x00,0x00
                  u16EscAddrSendMbx
00000a  0000              DCB      0x00,0x00
                  u8MbxWriteCounter
00000c  00                DCB      0x00
                  u8MbxReadCounter
00000d  00                DCB      0x00
                  u8MailboxSendReqStored
00000e  0000              DCB      0x00,0x00
                  psWriteMbx
                          DCD      0x00000000
                  psReadMbx
                          DCD      0x00000000
                  psRepeatMbx
                          DCD      0x00000000
                  psStoreMbx
                          DCD      0x00000000
                  bNoMbxMemoryAvailable
000020  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "etherCAT\\mailbox.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_mailbox_c_333c721c____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_mailbox_c_333c721c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_mailbox_c_333c721c____REVSH|
#line 402
|__asm___9_mailbox_c_333c721c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_mailbox_c_333c721c____RRX|
#line 587
|__asm___9_mailbox_c_333c721c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
