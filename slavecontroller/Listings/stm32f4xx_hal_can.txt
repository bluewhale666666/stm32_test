; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_hal_can.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hal_can.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\stm32f4xx_hal_can.crf D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_can.c]
                          THUMB

                          AREA ||i.HAL_CAN_AbortTxRequest||, CODE, READONLY, ALIGN=1

                  HAL_CAN_AbortTxRequest PROC
;;;1357     */
;;;1358   HAL_StatusTypeDef HAL_CAN_AbortTxRequest(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes)
000000  b510              PUSH     {r4,lr}
;;;1359   {
000002  4602              MOV      r2,r0
;;;1360     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8923020          LDRB     r3,[r2,#0x20]
;;;1361   
;;;1362     /* Check function parameters */
;;;1363     assert_param(IS_CAN_TX_MAILBOX_LIST(TxMailboxes));
;;;1364   
;;;1365     if ((state == HAL_CAN_STATE_READY) ||
000008  2b01              CMP      r3,#1
00000a  d001              BEQ      |L1.16|
;;;1366         (state == HAL_CAN_STATE_LISTENING))
00000c  2b02              CMP      r3,#2
00000e  d11c              BNE      |L1.74|
                  |L1.16|
;;;1367     {
;;;1368       /* Check Tx Mailbox 0 */
;;;1369       if ((TxMailboxes & CAN_TX_MAILBOX0) != 0U)
000010  f0010001          AND      r0,r1,#1
000014  b128              CBZ      r0,|L1.34|
;;;1370       {
;;;1371         /* Add cancellation request for Tx Mailbox 0 */
;;;1372         SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ0);
000016  6810              LDR      r0,[r2,#0]
000018  6880              LDR      r0,[r0,#8]
00001a  f0400080          ORR      r0,r0,#0x80
00001e  6814              LDR      r4,[r2,#0]
000020  60a0              STR      r0,[r4,#8]
                  |L1.34|
;;;1373       }
;;;1374   
;;;1375       /* Check Tx Mailbox 1 */
;;;1376       if ((TxMailboxes & CAN_TX_MAILBOX1) != 0U)
000022  f0010002          AND      r0,r1,#2
000026  b128              CBZ      r0,|L1.52|
;;;1377       {
;;;1378         /* Add cancellation request for Tx Mailbox 1 */
;;;1379         SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ1);
000028  6810              LDR      r0,[r2,#0]
00002a  6880              LDR      r0,[r0,#8]
00002c  f4404000          ORR      r0,r0,#0x8000
000030  6814              LDR      r4,[r2,#0]
000032  60a0              STR      r0,[r4,#8]
                  |L1.52|
;;;1380       }
;;;1381   
;;;1382       /* Check Tx Mailbox 2 */
;;;1383       if ((TxMailboxes & CAN_TX_MAILBOX2) != 0U)
000034  f0010004          AND      r0,r1,#4
000038  b128              CBZ      r0,|L1.70|
;;;1384       {
;;;1385         /* Add cancellation request for Tx Mailbox 2 */
;;;1386         SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ2);
00003a  6810              LDR      r0,[r2,#0]
00003c  6880              LDR      r0,[r0,#8]
00003e  f4400000          ORR      r0,r0,#0x800000
000042  6814              LDR      r4,[r2,#0]
000044  60a0              STR      r0,[r4,#8]
                  |L1.70|
;;;1387       }
;;;1388   
;;;1389       /* Return function status */
;;;1390       return HAL_OK;
000046  2000              MOVS     r0,#0
                  |L1.72|
;;;1391     }
;;;1392     else
;;;1393     {
;;;1394       /* Update error code */
;;;1395       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1396   
;;;1397       return HAL_ERROR;
;;;1398     }
;;;1399   }
000048  bd10              POP      {r4,pc}
                  |L1.74|
00004a  6a50              LDR      r0,[r2,#0x24]         ;1395
00004c  f4402080          ORR      r0,r0,#0x40000        ;1395
000050  6250              STR      r0,[r2,#0x24]         ;1395
000052  2001              MOVS     r0,#1                 ;1397
000054  e7f8              B        |L1.72|
;;;1400   
                          ENDP


                          AREA ||i.HAL_CAN_ActivateNotification||, CODE, READONLY, ALIGN=1

                  HAL_CAN_ActivateNotification PROC
;;;1658     */
;;;1659   HAL_StatusTypeDef HAL_CAN_ActivateNotification(CAN_HandleTypeDef *hcan, uint32_t ActiveITs)
000000  b510              PUSH     {r4,lr}
;;;1660   {
000002  4602              MOV      r2,r0
;;;1661     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8923020          LDRB     r3,[r2,#0x20]
;;;1662   
;;;1663     /* Check function parameters */
;;;1664     assert_param(IS_CAN_IT(ActiveITs));
;;;1665   
;;;1666     if ((state == HAL_CAN_STATE_READY) ||
000008  2b01              CMP      r3,#1
00000a  d001              BEQ      |L2.16|
;;;1667         (state == HAL_CAN_STATE_LISTENING))
00000c  2b02              CMP      r3,#2
00000e  d106              BNE      |L2.30|
                  |L2.16|
;;;1668     {
;;;1669       /* Enable the selected interrupts */
;;;1670       __HAL_CAN_ENABLE_IT(hcan, ActiveITs);
000010  6810              LDR      r0,[r2,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  4308              ORRS     r0,r0,r1
000016  6814              LDR      r4,[r2,#0]
000018  6160              STR      r0,[r4,#0x14]
;;;1671   
;;;1672       /* Return function status */
;;;1673       return HAL_OK;
00001a  2000              MOVS     r0,#0
                  |L2.28|
;;;1674     }
;;;1675     else
;;;1676     {
;;;1677       /* Update error code */
;;;1678       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1679   
;;;1680       return HAL_ERROR;
;;;1681     }
;;;1682   }
00001c  bd10              POP      {r4,pc}
                  |L2.30|
00001e  6a50              LDR      r0,[r2,#0x24]         ;1678
000020  f4402080          ORR      r0,r0,#0x40000        ;1678
000024  6250              STR      r0,[r2,#0x24]         ;1678
000026  2001              MOVS     r0,#1                 ;1680
000028  e7f8              B        |L2.28|
;;;1683   
                          ENDP


                          AREA ||i.HAL_CAN_AddTxMessage||, CODE, READONLY, ALIGN=1

                  HAL_CAN_AddTxMessage PROC
;;;1249     */
;;;1250   HAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pHeader, uint8_t aData[], uint32_t *pTxMailbox)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1251   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  461e              MOV      r6,r3
;;;1252     uint32_t transmitmailbox;
;;;1253     HAL_CAN_StateTypeDef state = hcan->State;
000008  f8947020          LDRB     r7,[r4,#0x20]
;;;1254     uint32_t tsr = READ_REG(hcan->Instance->TSR);
00000c  6820              LDR      r0,[r4,#0]
00000e  6883              LDR      r3,[r0,#8]
;;;1255   
;;;1256     /* Check the parameters */
;;;1257     assert_param(IS_CAN_IDTYPE(pHeader->IDE));
;;;1258     assert_param(IS_CAN_RTR(pHeader->RTR));
;;;1259     assert_param(IS_CAN_DLC(pHeader->DLC));
;;;1260     if (pHeader->IDE == CAN_ID_STD)
000010  68a8              LDR      r0,[r5,#8]
000012  b900              CBNZ     r0,|L3.22|
;;;1261     {
;;;1262       assert_param(IS_CAN_STDID(pHeader->StdId));
000014  e000              B        |L3.24|
                  |L3.22|
;;;1263     }
;;;1264     else
;;;1265     {
;;;1266       assert_param(IS_CAN_EXTID(pHeader->ExtId));
000016  bf00              NOP      
                  |L3.24|
;;;1267     }
;;;1268     assert_param(IS_FUNCTIONAL_STATE(pHeader->TransmitGlobalTime));
;;;1269   
;;;1270     if ((state == HAL_CAN_STATE_READY) ||
000018  2f01              CMP      r7,#1
00001a  d001              BEQ      |L3.32|
;;;1271         (state == HAL_CAN_STATE_LISTENING))
00001c  2f02              CMP      r7,#2
00001e  d17c              BNE      |L3.282|
                  |L3.32|
;;;1272     {
;;;1273       /* Check that all the Tx mailboxes are not full */
;;;1274       if (((tsr & CAN_TSR_TME0) != 0U) ||
000020  f0036080          AND      r0,r3,#0x4000000
000024  b930              CBNZ     r0,|L3.52|
;;;1275           ((tsr & CAN_TSR_TME1) != 0U) ||
000026  f0036000          AND      r0,r3,#0x8000000
00002a  b918              CBNZ     r0,|L3.52|
;;;1276           ((tsr & CAN_TSR_TME2) != 0U))
00002c  f0035080          AND      r0,r3,#0x10000000
000030  2800              CMP      r0,#0
000032  d073              BEQ      |L3.284|
                  |L3.52|
;;;1277       {
;;;1278         /* Select an empty transmit mailbox */
;;;1279         transmitmailbox = (tsr & CAN_TSR_CODE) >> CAN_TSR_CODE_Pos;
000034  f3c36101          UBFX     r1,r3,#24,#2
;;;1280   
;;;1281         /* Check transmit mailbox value */
;;;1282         if (transmitmailbox > 2U)
000038  2902              CMP      r1,#2
00003a  d905              BLS      |L3.72|
;;;1283         {
;;;1284           /* Update error code */
;;;1285           hcan->ErrorCode |= HAL_CAN_ERROR_INTERNAL;
00003c  6a60              LDR      r0,[r4,#0x24]
00003e  f4400000          ORR      r0,r0,#0x800000
000042  6260              STR      r0,[r4,#0x24]
;;;1286   
;;;1287           return HAL_ERROR;
000044  2001              MOVS     r0,#1
                  |L3.70|
;;;1288         }
;;;1289   
;;;1290         /* Store the Tx mailbox */
;;;1291         *pTxMailbox = (uint32_t)1 << transmitmailbox;
;;;1292   
;;;1293         /* Set up the Id */
;;;1294         if (pHeader->IDE == CAN_ID_STD)
;;;1295         {
;;;1296           hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->StdId << CAN_TI0R_STID_Pos) |
;;;1297                                                              pHeader->RTR);
;;;1298         }
;;;1299         else
;;;1300         {
;;;1301           hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
;;;1302                                                              pHeader->IDE |
;;;1303                                                              pHeader->RTR);
;;;1304         }
;;;1305   
;;;1306         /* Set up the DLC */
;;;1307         hcan->Instance->sTxMailBox[transmitmailbox].TDTR = (pHeader->DLC);
;;;1308   
;;;1309         /* Set up the Transmit Global Time mode */
;;;1310         if (pHeader->TransmitGlobalTime == ENABLE)
;;;1311         {
;;;1312           SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TDTR, CAN_TDT0R_TGT);
;;;1313         }
;;;1314   
;;;1315         /* Set up the data field */
;;;1316         WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDHR,
;;;1317                   ((uint32_t)aData[7] << CAN_TDH0R_DATA7_Pos) |
;;;1318                   ((uint32_t)aData[6] << CAN_TDH0R_DATA6_Pos) |
;;;1319                   ((uint32_t)aData[5] << CAN_TDH0R_DATA5_Pos) |
;;;1320                   ((uint32_t)aData[4] << CAN_TDH0R_DATA4_Pos));
;;;1321         WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDLR,
;;;1322                   ((uint32_t)aData[3] << CAN_TDL0R_DATA3_Pos) |
;;;1323                   ((uint32_t)aData[2] << CAN_TDL0R_DATA2_Pos) |
;;;1324                   ((uint32_t)aData[1] << CAN_TDL0R_DATA1_Pos) |
;;;1325                   ((uint32_t)aData[0] << CAN_TDL0R_DATA0_Pos));
;;;1326   
;;;1327         /* Request transmission */
;;;1328         SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TIR, CAN_TI0R_TXRQ);
;;;1329   
;;;1330         /* Return function status */
;;;1331         return HAL_OK;
;;;1332       }
;;;1333       else
;;;1334       {
;;;1335         /* Update error code */
;;;1336         hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
;;;1337   
;;;1338         return HAL_ERROR;
;;;1339       }
;;;1340     }
;;;1341     else
;;;1342     {
;;;1343       /* Update error code */
;;;1344       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1345   
;;;1346       return HAL_ERROR;
;;;1347     }
;;;1348   }
000046  bdf0              POP      {r4-r7,pc}
                  |L3.72|
000048  2001              MOVS     r0,#1                 ;1291
00004a  4088              LSLS     r0,r0,r1              ;1291
00004c  6030              STR      r0,[r6,#0]            ;1291
00004e  68a8              LDR      r0,[r5,#8]            ;1294
000050  b960              CBNZ     r0,|L3.108|
000052  f8b5c000          LDRH     r12,[r5,#0]           ;1296
000056  68e8              LDR      r0,[r5,#0xc]          ;1296
000058  ea405c4c          ORR      r12,r0,r12,LSL #21    ;1296
00005c  6820              LDR      r0,[r4,#0]            ;1296
00005e  f50070c0          ADD      r0,r0,#0x180          ;1296
000062  eb001001          ADD      r0,r0,r1,LSL #4       ;1296
000066  f8c0c000          STR      r12,[r0,#0]           ;1296
00006a  e00f              B        |L3.140|
                  |L3.108|
00006c  e9d5c001          LDRD     r12,r0,[r5,#4]        ;1301
000070  ea4000cc          ORR      r0,r0,r12,LSL #3      ;1301
000074  f8d5c00c          LDR      r12,[r5,#0xc]         ;1301
000078  ea40000c          ORR      r0,r0,r12             ;1301
00007c  f8d4c000          LDR      r12,[r4,#0]           ;1301
000080  f50c7cc0          ADD      r12,r12,#0x180        ;1301
000084  eb0c1c01          ADD      r12,r12,r1,LSL #4     ;1301
000088  f8cc0000          STR      r0,[r12,#0]           ;1301
                  |L3.140|
00008c  f8d5c010          LDR      r12,[r5,#0x10]        ;1307
000090  6820              LDR      r0,[r4,#0]            ;1307
000092  f50070c0          ADD      r0,r0,#0x180          ;1307
000096  eb001001          ADD      r0,r0,r1,LSL #4       ;1307
00009a  f8c0c004          STR      r12,[r0,#4]           ;1307
00009e  7d28              LDRB     r0,[r5,#0x14]         ;1310
0000a0  2801              CMP      r0,#1                 ;1310
0000a2  d10e              BNE      |L3.194|
0000a4  6820              LDR      r0,[r4,#0]            ;1312
0000a6  f50070c0          ADD      r0,r0,#0x180          ;1312
0000aa  eb001001          ADD      r0,r0,r1,LSL #4       ;1312
0000ae  6840              LDR      r0,[r0,#4]            ;1312
0000b0  f4407c80          ORR      r12,r0,#0x100         ;1312
0000b4  6820              LDR      r0,[r4,#0]            ;1312
0000b6  f50070c0          ADD      r0,r0,#0x180          ;1312
0000ba  eb001001          ADD      r0,r0,r1,LSL #4       ;1312
0000be  f8c0c004          STR      r12,[r0,#4]           ;1312
                  |L3.194|
0000c2  79d0              LDRB     r0,[r2,#7]            ;1316
0000c4  0600              LSLS     r0,r0,#24             ;1316
0000c6  f892c006          LDRB     r12,[r2,#6]           ;1316
0000ca  ea40400c          ORR      r0,r0,r12,LSL #16     ;1316
0000ce  f892c005          LDRB     r12,[r2,#5]           ;1316
0000d2  ea402c0c          ORR      r12,r0,r12,LSL #8     ;1316
0000d6  7910              LDRB     r0,[r2,#4]            ;1316
0000d8  ea4c0c00          ORR      r12,r12,r0            ;1316
0000dc  6820              LDR      r0,[r4,#0]            ;1316
0000de  f50070c0          ADD      r0,r0,#0x180          ;1316
0000e2  eb001001          ADD      r0,r0,r1,LSL #4       ;1316
0000e6  f8c0c00c          STR      r12,[r0,#0xc]         ;1316
0000ea  78d0              LDRB     r0,[r2,#3]            ;1321
0000ec  0600              LSLS     r0,r0,#24             ;1321
0000ee  f892c002          LDRB     r12,[r2,#2]           ;1321
0000f2  ea40400c          ORR      r0,r0,r12,LSL #16     ;1321
0000f6  f892c001          LDRB     r12,[r2,#1]           ;1321
0000fa  ea40200c          ORR      r0,r0,r12,LSL #8      ;1321
0000fe  f892c000          LDRB     r12,[r2,#0]           ;1321
000102  ea40000c          ORR      r0,r0,r12             ;1321
000106  f8d4c000          LDR      r12,[r4,#0]           ;1321
00010a  f50c7cc0          ADD      r12,r12,#0x180        ;1321
00010e  eb0c1c01          ADD      r12,r12,r1,LSL #4     ;1321
000112  f8cc0008          STR      r0,[r12,#8]           ;1321
000116  6820              LDR      r0,[r4,#0]            ;1328
000118  e001              B        |L3.286|
                  |L3.282|
00011a  e016              B        |L3.330|
                  |L3.284|
00011c  e00f              B        |L3.318|
                  |L3.286|
00011e  f50070c0          ADD      r0,r0,#0x180          ;1328
000122  eb001001          ADD      r0,r0,r1,LSL #4       ;1328
000126  6800              LDR      r0,[r0,#0]            ;1328
000128  f0400c01          ORR      r12,r0,#1             ;1328
00012c  6820              LDR      r0,[r4,#0]            ;1328
00012e  f50070c0          ADD      r0,r0,#0x180          ;1328
000132  eb001001          ADD      r0,r0,r1,LSL #4       ;1328
000136  f8c0c000          STR      r12,[r0,#0]           ;1328
00013a  2000              MOVS     r0,#0                 ;1331
00013c  e783              B        |L3.70|
                  |L3.318|
00013e  6a60              LDR      r0,[r4,#0x24]         ;1336
000140  f4401000          ORR      r0,r0,#0x200000       ;1336
000144  6260              STR      r0,[r4,#0x24]         ;1336
000146  2001              MOVS     r0,#1                 ;1338
000148  e77d              B        |L3.70|
                  |L3.330|
00014a  6a60              LDR      r0,[r4,#0x24]         ;1344
00014c  f4402080          ORR      r0,r0,#0x40000        ;1344
000150  6260              STR      r0,[r4,#0x24]         ;1344
000152  2001              MOVS     r0,#1                 ;1346
000154  e777              B        |L3.70|
;;;1349   
                          ENDP


                          AREA ||i.HAL_CAN_ConfigFilter||, CODE, READONLY, ALIGN=2

                  HAL_CAN_ConfigFilter PROC
;;;837      */
;;;838    HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, CAN_FilterTypeDef *sFilterConfig)
000000  b5f0              PUSH     {r4-r7,lr}
;;;839    {
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;840      uint32_t filternbrbitpos;
;;;841      CAN_TypeDef *can_ip = hcan->Instance;
000006  6821              LDR      r1,[r4,#0]
;;;842      HAL_CAN_StateTypeDef state = hcan->State;
000008  f8945020          LDRB     r5,[r4,#0x20]
;;;843    
;;;844      if ((state == HAL_CAN_STATE_READY) ||
00000c  2d01              CMP      r5,#1
00000e  d001              BEQ      |L4.20|
;;;845          (state == HAL_CAN_STATE_LISTENING))
000010  2d02              CMP      r5,#2
000012  d17e              BNE      |L4.274|
                  |L4.20|
;;;846      {
;;;847        /* Check the parameters */
;;;848        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterIdHigh));
;;;849        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterIdLow));
;;;850        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterMaskIdHigh));
;;;851        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterMaskIdLow));
;;;852        assert_param(IS_CAN_FILTER_MODE(sFilterConfig->FilterMode));
;;;853        assert_param(IS_CAN_FILTER_SCALE(sFilterConfig->FilterScale));
;;;854        assert_param(IS_CAN_FILTER_FIFO(sFilterConfig->FilterFIFOAssignment));
;;;855        assert_param(IS_CAN_FILTER_ACTIVATION(sFilterConfig->FilterActivation));
;;;856    
;;;857    #if defined(CAN3)
;;;858        /* Check the CAN instance */
;;;859        if (hcan->Instance == CAN3)
;;;860        {
;;;861          /* CAN3 is single instance with 14 dedicated filters banks */
;;;862    
;;;863          /* Check the parameters */
;;;864          assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));
;;;865        }
;;;866        else
;;;867        {
;;;868          /* CAN1 and CAN2 are dual instances with 28 common filters banks */
;;;869          /* Select master instance to access the filter banks */
;;;870          can_ip = CAN1;
;;;871    
;;;872          /* Check the parameters */
;;;873          assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->FilterBank));
;;;874          assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->SlaveStartFilterBank));
;;;875        }
;;;876    #elif defined(CAN2)
;;;877        /* CAN1 and CAN2 are dual instances with 28 common filters banks */
;;;878        /* Select master instance to access the filter banks */
;;;879        can_ip = CAN1;
000014  4942              LDR      r1,|L4.288|
;;;880    
;;;881        /* Check the parameters */
;;;882        assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->FilterBank));
;;;883        assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->SlaveStartFilterBank));
;;;884    #else
;;;885        /* CAN1 is single instance with 14 dedicated filters banks */
;;;886    
;;;887        /* Check the parameters */
;;;888        assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));
;;;889    #endif
;;;890    
;;;891        /* Initialisation mode for the filter */
;;;892        SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
000016  f5017100          ADD      r1,r1,#0x200
00001a  6808              LDR      r0,[r1,#0]
00001c  f0400001          ORR      r0,r0,#1
000020  6008              STR      r0,[r1,#0]
;;;893    
;;;894    #if defined(CAN3)
;;;895        /* Check the CAN instance */
;;;896        if (can_ip == CAN1)
;;;897        {
;;;898          /* Select the start filter number of CAN2 slave instance */
;;;899          CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);
;;;900          SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);
;;;901        }
;;;902    
;;;903    #elif defined(CAN2)
;;;904        /* Select the start filter number of CAN2 slave instance */
;;;905        CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);
000022  6808              LDR      r0,[r1,#0]
000024  f420507c          BIC      r0,r0,#0x3f00
000028  6008              STR      r0,[r1,#0]
;;;906        SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);
00002a  6808              LDR      r0,[r1,#0]
00002c  6a56              LDR      r6,[r2,#0x24]
00002e  ea402006          ORR      r0,r0,r6,LSL #8
000032  6008              STR      r0,[r1,#0]
;;;907    
;;;908    #endif
;;;909        /* Convert filter number into bit position */
;;;910        filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
000034  7d10              LDRB     r0,[r2,#0x14]
000036  f000061f          AND      r6,r0,#0x1f
00003a  2001              MOVS     r0,#1
00003c  fa00f306          LSL      r3,r0,r6
;;;911    
;;;912        /* Filter Deactivation */
;;;913        CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
000040  69c8              LDR      r0,[r1,#0x1c]
000042  4398              BICS     r0,r0,r3
000044  61c8              STR      r0,[r1,#0x1c]
000046  f5a17100          SUB      r1,r1,#0x200
;;;914    
;;;915        /* Filter Scale */
;;;916        if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
00004a  69d0              LDR      r0,[r2,#0x1c]
00004c  b9c8              CBNZ     r0,|L4.130|
;;;917        {
;;;918          /* 16-bit scale for the filter */
;;;919          CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
00004e  f8d1020c          LDR      r0,[r1,#0x20c]
000052  4398              BICS     r0,r0,r3
000054  f8c1020c          STR      r0,[r1,#0x20c]
;;;920    
;;;921          /* First 16-bit identifier and First 16-bit mask */
;;;922          /* Or First 16-bit identifier and Second 16-bit identifier */
;;;923          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
000058  8890              LDRH     r0,[r2,#4]
00005a  b280              UXTH     r0,r0
00005c  8996              LDRH     r6,[r2,#0xc]
00005e  ea404606          ORR      r6,r0,r6,LSL #16
000062  f5017010          ADD      r0,r1,#0x240
000066  6957              LDR      r7,[r2,#0x14]
000068  f8406037          STR      r6,[r0,r7,LSL #3]
;;;924            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
;;;925            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
;;;926    
;;;927          /* Second 16-bit identifier and Second 16-bit mask */
;;;928          /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;929          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
00006c  8810              LDRH     r0,[r2,#0]
00006e  b280              UXTH     r0,r0
000070  8916              LDRH     r6,[r2,#8]
000072  ea404606          ORR      r6,r0,r6,LSL #16
000076  f5017010          ADD      r0,r1,#0x240
00007a  6957              LDR      r7,[r2,#0x14]
00007c  eb0000c7          ADD      r0,r0,r7,LSL #3
000080  6046              STR      r6,[r0,#4]
                  |L4.130|
;;;930            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
;;;931            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);
;;;932        }
;;;933    
;;;934        if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
000082  69d0              LDR      r0,[r2,#0x1c]
000084  2801              CMP      r0,#1
000086  d119              BNE      |L4.188|
;;;935        {
;;;936          /* 32-bit scale for the filter */
;;;937          SET_BIT(can_ip->FS1R, filternbrbitpos);
000088  f8d1020c          LDR      r0,[r1,#0x20c]
00008c  4318              ORRS     r0,r0,r3
00008e  f8c1020c          STR      r0,[r1,#0x20c]
;;;938    
;;;939          /* 32-bit identifier or First 32-bit identifier */
;;;940          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
000092  8890              LDRH     r0,[r2,#4]
000094  b280              UXTH     r0,r0
000096  8816              LDRH     r6,[r2,#0]
000098  ea404606          ORR      r6,r0,r6,LSL #16
00009c  f5017010          ADD      r0,r1,#0x240
0000a0  6957              LDR      r7,[r2,#0x14]
0000a2  f8406037          STR      r6,[r0,r7,LSL #3]
;;;941            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
;;;942            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
;;;943    
;;;944          /* 32-bit mask or Second 32-bit identifier */
;;;945          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
0000a6  8990              LDRH     r0,[r2,#0xc]
0000a8  b280              UXTH     r0,r0
0000aa  8916              LDRH     r6,[r2,#8]
0000ac  ea404606          ORR      r6,r0,r6,LSL #16
0000b0  f5017010          ADD      r0,r1,#0x240
0000b4  6957              LDR      r7,[r2,#0x14]
0000b6  eb0000c7          ADD      r0,r0,r7,LSL #3
0000ba  6046              STR      r6,[r0,#4]
                  |L4.188|
;;;946            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
;;;947            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
;;;948        }
;;;949    
;;;950        /* Filter Mode */
;;;951        if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
0000bc  6990              LDR      r0,[r2,#0x18]
0000be  b928              CBNZ     r0,|L4.204|
;;;952        {
;;;953          /* Id/Mask mode for the filter*/
;;;954          CLEAR_BIT(can_ip->FM1R, filternbrbitpos);
0000c0  f8d10204          LDR      r0,[r1,#0x204]
0000c4  4398              BICS     r0,r0,r3
0000c6  f8c10204          STR      r0,[r1,#0x204]
0000ca  e004              B        |L4.214|
                  |L4.204|
;;;955        }
;;;956        else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;957        {
;;;958          /* Identifier list mode for the filter*/
;;;959          SET_BIT(can_ip->FM1R, filternbrbitpos);
0000cc  f8d10204          LDR      r0,[r1,#0x204]
0000d0  4318              ORRS     r0,r0,r3
0000d2  f8c10204          STR      r0,[r1,#0x204]
                  |L4.214|
;;;960        }
;;;961    
;;;962        /* Filter FIFO assignment */
;;;963        if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
0000d6  6910              LDR      r0,[r2,#0x10]
0000d8  b928              CBNZ     r0,|L4.230|
;;;964        {
;;;965          /* FIFO 0 assignation for the filter */
;;;966          CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);
0000da  f8d10214          LDR      r0,[r1,#0x214]
0000de  4398              BICS     r0,r0,r3
0000e0  f8c10214          STR      r0,[r1,#0x214]
0000e4  e004              B        |L4.240|
                  |L4.230|
;;;967        }
;;;968        else
;;;969        {
;;;970          /* FIFO 1 assignation for the filter */
;;;971          SET_BIT(can_ip->FFA1R, filternbrbitpos);
0000e6  f8d10214          LDR      r0,[r1,#0x214]
0000ea  4318              ORRS     r0,r0,r3
0000ec  f8c10214          STR      r0,[r1,#0x214]
                  |L4.240|
;;;972        }
;;;973    
;;;974        /* Filter activation */
;;;975        if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)
0000f0  6a10              LDR      r0,[r2,#0x20]
0000f2  2801              CMP      r0,#1
0000f4  d104              BNE      |L4.256|
;;;976        {
;;;977          SET_BIT(can_ip->FA1R, filternbrbitpos);
0000f6  f8d1021c          LDR      r0,[r1,#0x21c]
0000fa  4318              ORRS     r0,r0,r3
0000fc  f8c1021c          STR      r0,[r1,#0x21c]
                  |L4.256|
;;;978        }
;;;979    
;;;980        /* Leave the initialisation mode for the filter */
;;;981        CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
000100  f8d10200          LDR      r0,[r1,#0x200]
000104  f0200001          BIC      r0,r0,#1
000108  f8c10200          STR      r0,[r1,#0x200]
;;;982    
;;;983        /* Return function status */
;;;984        return HAL_OK;
00010c  2000              MOVS     r0,#0
                  |L4.270|
;;;985      }
;;;986      else
;;;987      {
;;;988        /* Update error code */
;;;989        hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;990    
;;;991        return HAL_ERROR;
;;;992      }
;;;993    }
00010e  bdf0              POP      {r4-r7,pc}
000110  e7ff              B        |L4.274|
                  |L4.274|
000112  6a60              LDR      r0,[r4,#0x24]         ;989
000114  f4402080          ORR      r0,r0,#0x40000        ;989
000118  6260              STR      r0,[r4,#0x24]         ;989
00011a  2001              MOVS     r0,#1                 ;991
00011c  e7f7              B        |L4.270|
;;;994    
                          ENDP

00011e  0000              DCW      0x0000
                  |L4.288|
                          DCD      0x40006400

                          AREA ||i.HAL_CAN_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_DeInit PROC
;;;458      */
;;;459    HAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef *hcan)
000000  b510              PUSH     {r4,lr}
;;;460    {
000002  4604              MOV      r4,r0
;;;461      /* Check CAN handle */
;;;462      if (hcan == NULL)
000004  b90c              CBNZ     r4,|L5.10|
;;;463      {
;;;464        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L5.8|
;;;465      }
;;;466    
;;;467      /* Check the parameters */
;;;468      assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
;;;469    
;;;470      /* Stop the CAN module */
;;;471      (void)HAL_CAN_Stop(hcan);
;;;472    
;;;473    #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;474      if (hcan->MspDeInitCallback == NULL)
;;;475      {
;;;476        hcan->MspDeInitCallback = HAL_CAN_MspDeInit; /* Legacy weak MspDeInit */
;;;477      }
;;;478    
;;;479      /* DeInit the low level hardware: CLOCK, NVIC */
;;;480      hcan->MspDeInitCallback(hcan);
;;;481    
;;;482    #else
;;;483      /* DeInit the low level hardware: CLOCK, NVIC */
;;;484      HAL_CAN_MspDeInit(hcan);
;;;485    #endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */
;;;486    
;;;487      /* Reset the CAN peripheral */
;;;488      SET_BIT(hcan->Instance->MCR, CAN_MCR_RESET);
;;;489    
;;;490      /* Reset the CAN ErrorCode */
;;;491      hcan->ErrorCode = HAL_CAN_ERROR_NONE;
;;;492    
;;;493      /* Change CAN state */
;;;494      hcan->State = HAL_CAN_STATE_RESET;
;;;495    
;;;496      /* Return function status */
;;;497      return HAL_OK;
;;;498    }
000008  bd10              POP      {r4,pc}
                  |L5.10|
00000a  4620              MOV      r0,r4                 ;471
00000c  f7fffffe          BL       HAL_CAN_Stop
000010  4620              MOV      r0,r4                 ;484
000012  f7fffffe          BL       HAL_CAN_MspDeInit
000016  6820              LDR      r0,[r4,#0]            ;488
000018  6800              LDR      r0,[r0,#0]            ;488
00001a  f4404000          ORR      r0,r0,#0x8000         ;488
00001e  6821              LDR      r1,[r4,#0]            ;488
000020  6008              STR      r0,[r1,#0]            ;488
000022  2000              MOVS     r0,#0                 ;491
000024  6260              STR      r0,[r4,#0x24]         ;491
000026  f8840020          STRB     r0,[r4,#0x20]         ;494
00002a  bf00              NOP                            ;497
00002c  e7ec              B        |L5.8|
;;;499    
                          ENDP


                          AREA ||i.HAL_CAN_DeactivateNotification||, CODE, READONLY, ALIGN=1

                  HAL_CAN_DeactivateNotification PROC
;;;1691     */
;;;1692   HAL_StatusTypeDef HAL_CAN_DeactivateNotification(CAN_HandleTypeDef *hcan, uint32_t InactiveITs)
000000  b510              PUSH     {r4,lr}
;;;1693   {
000002  4602              MOV      r2,r0
;;;1694     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8923020          LDRB     r3,[r2,#0x20]
;;;1695   
;;;1696     /* Check function parameters */
;;;1697     assert_param(IS_CAN_IT(InactiveITs));
;;;1698   
;;;1699     if ((state == HAL_CAN_STATE_READY) ||
000008  2b01              CMP      r3,#1
00000a  d001              BEQ      |L6.16|
;;;1700         (state == HAL_CAN_STATE_LISTENING))
00000c  2b02              CMP      r3,#2
00000e  d106              BNE      |L6.30|
                  |L6.16|
;;;1701     {
;;;1702       /* Disable the selected interrupts */
;;;1703       __HAL_CAN_DISABLE_IT(hcan, InactiveITs);
000010  6810              LDR      r0,[r2,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  4388              BICS     r0,r0,r1
000016  6814              LDR      r4,[r2,#0]
000018  6160              STR      r0,[r4,#0x14]
;;;1704   
;;;1705       /* Return function status */
;;;1706       return HAL_OK;
00001a  2000              MOVS     r0,#0
                  |L6.28|
;;;1707     }
;;;1708     else
;;;1709     {
;;;1710       /* Update error code */
;;;1711       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1712   
;;;1713       return HAL_ERROR;
;;;1714     }
;;;1715   }
00001c  bd10              POP      {r4,pc}
                  |L6.30|
00001e  6a50              LDR      r0,[r2,#0x24]         ;1711
000020  f4402080          ORR      r0,r0,#0x40000        ;1711
000024  6250              STR      r0,[r2,#0x24]         ;1711
000026  2001              MOVS     r0,#1                 ;1713
000028  e7f8              B        |L6.28|
;;;1716   
                          ENDP


                          AREA ||i.HAL_CAN_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_ErrorCallback PROC
;;;2336     */
;;;2337   __weak void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2338   {
;;;2339     /* Prevent unused argument(s) compilation warning */
;;;2340     UNUSED(hcan);
;;;2341   
;;;2342     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2343               the HAL_CAN_ErrorCallback could be implemented in the user file
;;;2344      */
;;;2345   }
;;;2346   
                          ENDP


                          AREA ||i.HAL_CAN_GetError||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetError PROC
;;;2408     */
;;;2409   uint32_t HAL_CAN_GetError(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;2410   {
;;;2411     /* Return CAN error code */
;;;2412     return hcan->ErrorCode;
000002  6a48              LDR      r0,[r1,#0x24]
;;;2413   }
000004  4770              BX       lr
;;;2414   
                          ENDP


                          AREA ||i.HAL_CAN_GetRxFifoFillLevel||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetRxFifoFillLevel PROC
;;;1605     */
;;;1606   uint32_t HAL_CAN_GetRxFifoFillLevel(CAN_HandleTypeDef *hcan, uint32_t RxFifo)
000000  b510              PUSH     {r4,lr}
;;;1607   {
000002  4602              MOV      r2,r0
;;;1608     uint32_t filllevel = 0U;
000004  2000              MOVS     r0,#0
;;;1609     HAL_CAN_StateTypeDef state = hcan->State;
000006  f8923020          LDRB     r3,[r2,#0x20]
;;;1610   
;;;1611     /* Check function parameters */
;;;1612     assert_param(IS_CAN_RX_FIFO(RxFifo));
;;;1613   
;;;1614     if ((state == HAL_CAN_STATE_READY) ||
00000a  2b01              CMP      r3,#1
00000c  d001              BEQ      |L9.18|
;;;1615         (state == HAL_CAN_STATE_LISTENING))
00000e  2b02              CMP      r3,#2
000010  d109              BNE      |L9.38|
                  |L9.18|
;;;1616     {
;;;1617       if (RxFifo == CAN_RX_FIFO0)
000012  b921              CBNZ     r1,|L9.30|
;;;1618       {
;;;1619         filllevel = hcan->Instance->RF0R & CAN_RF0R_FMP0;
000014  6814              LDR      r4,[r2,#0]
000016  68e4              LDR      r4,[r4,#0xc]
000018  f0040003          AND      r0,r4,#3
00001c  e003              B        |L9.38|
                  |L9.30|
;;;1620       }
;;;1621       else /* RxFifo == CAN_RX_FIFO1 */
;;;1622       {
;;;1623         filllevel = hcan->Instance->RF1R & CAN_RF1R_FMP1;
00001e  6814              LDR      r4,[r2,#0]
000020  6924              LDR      r4,[r4,#0x10]
000022  f0040003          AND      r0,r4,#3
                  |L9.38|
;;;1624       }
;;;1625     }
;;;1626   
;;;1627     /* Return Rx FIFO fill level */
;;;1628     return filllevel;
;;;1629   }
000026  bd10              POP      {r4,pc}
;;;1630   
                          ENDP


                          AREA ||i.HAL_CAN_GetRxMessage||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetRxMessage PROC
;;;1515     */
;;;1516   HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])
000000  b570              PUSH     {r4-r6,lr}
;;;1517   {
000002  4604              MOV      r4,r0
;;;1518     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8945020          LDRB     r5,[r4,#0x20]
;;;1519   
;;;1520     assert_param(IS_CAN_RX_FIFO(RxFifo));
;;;1521   
;;;1522     if ((state == HAL_CAN_STATE_READY) ||
000008  2d01              CMP      r5,#1
00000a  d001              BEQ      |L10.16|
;;;1523         (state == HAL_CAN_STATE_LISTENING))
00000c  2d02              CMP      r5,#2
00000e  d17d              BNE      |L10.268|
                  |L10.16|
;;;1524     {
;;;1525       /* Check the Rx FIFO */
;;;1526       if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
000010  b951              CBNZ     r1,|L10.40|
;;;1527       {
;;;1528         /* Check that the Rx FIFO 0 is not empty */
;;;1529         if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == 0U)
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0000003          AND      r0,r0,#3
00001a  b980              CBNZ     r0,|L10.62|
;;;1530         {
;;;1531           /* Update error code */
;;;1532           hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
00001c  6a60              LDR      r0,[r4,#0x24]
00001e  f4401000          ORR      r0,r0,#0x200000
000022  6260              STR      r0,[r4,#0x24]
;;;1533   
;;;1534           return HAL_ERROR;
000024  2001              MOVS     r0,#1
                  |L10.38|
;;;1535         }
;;;1536       }
;;;1537       else /* Rx element is assigned to Rx FIFO 1 */
;;;1538       {
;;;1539         /* Check that the Rx FIFO 1 is not empty */
;;;1540         if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == 0U)
;;;1541         {
;;;1542           /* Update error code */
;;;1543           hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
;;;1544   
;;;1545           return HAL_ERROR;
;;;1546         }
;;;1547       }
;;;1548   
;;;1549       /* Get the header */
;;;1550       pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;
;;;1551       if (pHeader->IDE == CAN_ID_STD)
;;;1552       {
;;;1553         pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;
;;;1554       }
;;;1555       else
;;;1556       {
;;;1557         pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;
;;;1558       }
;;;1559       pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR);
;;;1560       pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
;;;1561       pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
;;;1562       pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
;;;1563   
;;;1564       /* Get the data */
;;;1565       aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
;;;1566       aData[1] = (uint8_t)((CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos);
;;;1567       aData[2] = (uint8_t)((CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos);
;;;1568       aData[3] = (uint8_t)((CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos);
;;;1569       aData[4] = (uint8_t)((CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos);
;;;1570       aData[5] = (uint8_t)((CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos);
;;;1571       aData[6] = (uint8_t)((CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos);
;;;1572       aData[7] = (uint8_t)((CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos);
;;;1573   
;;;1574       /* Release the FIFO */
;;;1575       if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
;;;1576       {
;;;1577         /* Release RX FIFO 0 */
;;;1578         SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
;;;1579       }
;;;1580       else /* Rx element is assigned to Rx FIFO 1 */
;;;1581       {
;;;1582         /* Release RX FIFO 1 */
;;;1583         SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
;;;1584       }
;;;1585   
;;;1586       /* Return function status */
;;;1587       return HAL_OK;
;;;1588     }
;;;1589     else
;;;1590     {
;;;1591       /* Update error code */
;;;1592       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1593   
;;;1594       return HAL_ERROR;
;;;1595     }
;;;1596   }
000026  bd70              POP      {r4-r6,pc}
                  |L10.40|
000028  6820              LDR      r0,[r4,#0]            ;1540
00002a  6900              LDR      r0,[r0,#0x10]         ;1540
00002c  f0000003          AND      r0,r0,#3              ;1540
000030  b928              CBNZ     r0,|L10.62|
000032  6a60              LDR      r0,[r4,#0x24]         ;1543
000034  f4401000          ORR      r0,r0,#0x200000       ;1543
000038  6260              STR      r0,[r4,#0x24]         ;1543
00003a  2001              MOVS     r0,#1                 ;1545
00003c  e7f3              B        |L10.38|
                  |L10.62|
00003e  6820              LDR      r0,[r4,#0]            ;1550
000040  f50070d8          ADD      r0,r0,#0x1b0          ;1550
000044  eb001001          ADD      r0,r0,r1,LSL #4       ;1550
000048  6800              LDR      r0,[r0,#0]            ;1550
00004a  f0000004          AND      r0,r0,#4              ;1550
00004e  6090              STR      r0,[r2,#8]            ;1550
000050  6890              LDR      r0,[r2,#8]            ;1551
000052  b940              CBNZ     r0,|L10.102|
000054  6820              LDR      r0,[r4,#0]            ;1553
000056  f50070d8          ADD      r0,r0,#0x1b0          ;1553
00005a  eb001001          ADD      r0,r0,r1,LSL #4       ;1553
00005e  6800              LDR      r0,[r0,#0]            ;1553
000060  0d40              LSRS     r0,r0,#21             ;1553
000062  6010              STR      r0,[r2,#0]            ;1553
000064  e007              B        |L10.118|
                  |L10.102|
000066  6820              LDR      r0,[r4,#0]            ;1557
000068  f50070d8          ADD      r0,r0,#0x1b0          ;1557
00006c  eb001001          ADD      r0,r0,r1,LSL #4       ;1557
000070  6800              LDR      r0,[r0,#0]            ;1557
000072  08c0              LSRS     r0,r0,#3              ;1557
000074  6050              STR      r0,[r2,#4]            ;1557
                  |L10.118|
000076  6820              LDR      r0,[r4,#0]            ;1559
000078  f50070d8          ADD      r0,r0,#0x1b0          ;1559
00007c  eb001001          ADD      r0,r0,r1,LSL #4       ;1559
000080  6800              LDR      r0,[r0,#0]            ;1559
000082  f0000002          AND      r0,r0,#2              ;1559
000086  60d0              STR      r0,[r2,#0xc]          ;1559
000088  6820              LDR      r0,[r4,#0]            ;1560
00008a  f50070d8          ADD      r0,r0,#0x1b0          ;1560
00008e  eb001001          ADD      r0,r0,r1,LSL #4       ;1560
000092  6840              LDR      r0,[r0,#4]            ;1560
000094  f000000f          AND      r0,r0,#0xf            ;1560
000098  6110              STR      r0,[r2,#0x10]         ;1560
00009a  6820              LDR      r0,[r4,#0]            ;1561
00009c  f50070d8          ADD      r0,r0,#0x1b0          ;1561
0000a0  eb001001          ADD      r0,r0,r1,LSL #4       ;1561
0000a4  6840              LDR      r0,[r0,#4]            ;1561
0000a6  f400407f          AND      r0,r0,#0xff00         ;1561
0000aa  0a00              LSRS     r0,r0,#8              ;1561
0000ac  6190              STR      r0,[r2,#0x18]         ;1561
0000ae  6820              LDR      r0,[r4,#0]            ;1562
0000b0  f50070d8          ADD      r0,r0,#0x1b0          ;1562
0000b4  eb001001          ADD      r0,r0,r1,LSL #4       ;1562
0000b8  6840              LDR      r0,[r0,#4]            ;1562
0000ba  0c00              LSRS     r0,r0,#16             ;1562
0000bc  6150              STR      r0,[r2,#0x14]         ;1562
0000be  6820              LDR      r0,[r4,#0]            ;1565
0000c0  f50070d8          ADD      r0,r0,#0x1b0          ;1565
0000c4  eb001001          ADD      r0,r0,r1,LSL #4       ;1565
0000c8  6880              LDR      r0,[r0,#8]            ;1565
0000ca  7018              STRB     r0,[r3,#0]            ;1565
0000cc  6820              LDR      r0,[r4,#0]            ;1566
0000ce  f50070d8          ADD      r0,r0,#0x1b0          ;1566
0000d2  eb001001          ADD      r0,r0,r1,LSL #4       ;1566
0000d6  6880              LDR      r0,[r0,#8]            ;1566
0000d8  f400407f          AND      r0,r0,#0xff00         ;1566
0000dc  0a00              LSRS     r0,r0,#8              ;1566
0000de  7058              STRB     r0,[r3,#1]            ;1566
0000e0  6820              LDR      r0,[r4,#0]            ;1567
0000e2  f50070d8          ADD      r0,r0,#0x1b0          ;1567
0000e6  eb001001          ADD      r0,r0,r1,LSL #4       ;1567
0000ea  6880              LDR      r0,[r0,#8]            ;1567
0000ec  f400007f          AND      r0,r0,#0xff0000       ;1567
0000f0  0c00              LSRS     r0,r0,#16             ;1567
0000f2  7098              STRB     r0,[r3,#2]            ;1567
0000f4  6820              LDR      r0,[r4,#0]            ;1568
0000f6  f50070d8          ADD      r0,r0,#0x1b0          ;1568
0000fa  eb001001          ADD      r0,r0,r1,LSL #4       ;1568
0000fe  6880              LDR      r0,[r0,#8]            ;1568
000100  0e00              LSRS     r0,r0,#24             ;1568
000102  70d8              STRB     r0,[r3,#3]            ;1568
000104  6820              LDR      r0,[r4,#0]            ;1569
000106  f50070d8          ADD      r0,r0,#0x1b0          ;1569
00010a  e000              B        |L10.270|
                  |L10.268|
00010c  e02f              B        |L10.366|
                  |L10.270|
00010e  eb001001          ADD      r0,r0,r1,LSL #4       ;1569
000112  68c0              LDR      r0,[r0,#0xc]          ;1569
000114  7118              STRB     r0,[r3,#4]            ;1569
000116  6820              LDR      r0,[r4,#0]            ;1570
000118  f50070d8          ADD      r0,r0,#0x1b0          ;1570
00011c  eb001001          ADD      r0,r0,r1,LSL #4       ;1570
000120  68c0              LDR      r0,[r0,#0xc]          ;1570
000122  f400407f          AND      r0,r0,#0xff00         ;1570
000126  0a00              LSRS     r0,r0,#8              ;1570
000128  7158              STRB     r0,[r3,#5]            ;1570
00012a  6820              LDR      r0,[r4,#0]            ;1571
00012c  f50070d8          ADD      r0,r0,#0x1b0          ;1571
000130  eb001001          ADD      r0,r0,r1,LSL #4       ;1571
000134  68c0              LDR      r0,[r0,#0xc]          ;1571
000136  f400007f          AND      r0,r0,#0xff0000       ;1571
00013a  0c00              LSRS     r0,r0,#16             ;1571
00013c  7198              STRB     r0,[r3,#6]            ;1571
00013e  6820              LDR      r0,[r4,#0]            ;1572
000140  f50070d8          ADD      r0,r0,#0x1b0          ;1572
000144  eb001001          ADD      r0,r0,r1,LSL #4       ;1572
000148  68c0              LDR      r0,[r0,#0xc]          ;1572
00014a  0e00              LSRS     r0,r0,#24             ;1572
00014c  71d8              STRB     r0,[r3,#7]            ;1572
00014e  b931              CBNZ     r1,|L10.350|
000150  6820              LDR      r0,[r4,#0]            ;1578
000152  68c0              LDR      r0,[r0,#0xc]          ;1578
000154  f0400020          ORR      r0,r0,#0x20           ;1578
000158  6826              LDR      r6,[r4,#0]            ;1578
00015a  60f0              STR      r0,[r6,#0xc]          ;1578
00015c  e005              B        |L10.362|
                  |L10.350|
00015e  6820              LDR      r0,[r4,#0]            ;1583
000160  6900              LDR      r0,[r0,#0x10]         ;1583
000162  f0400020          ORR      r0,r0,#0x20           ;1583
000166  6826              LDR      r6,[r4,#0]            ;1583
000168  6130              STR      r0,[r6,#0x10]         ;1583
                  |L10.362|
00016a  2000              MOVS     r0,#0                 ;1587
00016c  e75b              B        |L10.38|
                  |L10.366|
00016e  6a60              LDR      r0,[r4,#0x24]         ;1592
000170  f4402080          ORR      r0,r0,#0x40000        ;1592
000174  6260              STR      r0,[r4,#0x24]         ;1592
000176  2001              MOVS     r0,#1                 ;1594
000178  e755              B        |L10.38|
;;;1597   
                          ENDP


                          AREA ||i.HAL_CAN_GetState||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetState PROC
;;;2373     */
;;;2374   HAL_CAN_StateTypeDef HAL_CAN_GetState(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;2375   {
;;;2376     HAL_CAN_StateTypeDef state = hcan->State;
000002  f8910020          LDRB     r0,[r1,#0x20]
;;;2377   
;;;2378     if ((state == HAL_CAN_STATE_READY) ||
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L11.14|
;;;2379         (state == HAL_CAN_STATE_LISTENING))
00000a  2802              CMP      r0,#2
00000c  d10c              BNE      |L11.40|
                  |L11.14|
;;;2380     {
;;;2381       /* Check sleep mode acknowledge flag */
;;;2382       if ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
00000e  680a              LDR      r2,[r1,#0]
000010  6852              LDR      r2,[r2,#4]
000012  f0020202          AND      r2,r2,#2
000016  b10a              CBZ      r2,|L11.28|
;;;2383       {
;;;2384         /* Sleep mode is active */
;;;2385         state = HAL_CAN_STATE_SLEEP_ACTIVE;
000018  2004              MOVS     r0,#4
00001a  e005              B        |L11.40|
                  |L11.28|
;;;2386       }
;;;2387       /* Check sleep mode request flag */
;;;2388       else if ((hcan->Instance->MCR & CAN_MCR_SLEEP) != 0U)
00001c  680a              LDR      r2,[r1,#0]
00001e  6812              LDR      r2,[r2,#0]
000020  f0020202          AND      r2,r2,#2
000024  b102              CBZ      r2,|L11.40|
;;;2389       {
;;;2390         /* Sleep mode request is pending */
;;;2391         state = HAL_CAN_STATE_SLEEP_PENDING;
000026  2003              MOVS     r0,#3
                  |L11.40|
;;;2392       }
;;;2393       else
;;;2394       {
;;;2395         /* Neither sleep mode request nor sleep mode acknowledge */
;;;2396       }
;;;2397     }
;;;2398   
;;;2399     /* Return CAN state */
;;;2400     return state;
;;;2401   }
000028  4770              BX       lr
;;;2402   
                          ENDP


                          AREA ||i.HAL_CAN_GetTxMailboxesFreeLevel||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetTxMailboxesFreeLevel PROC
;;;1406     */
;;;1407   uint32_t HAL_CAN_GetTxMailboxesFreeLevel(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;1408   {
;;;1409     uint32_t freelevel = 0U;
000002  2000              MOVS     r0,#0
;;;1410     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8912020          LDRB     r2,[r1,#0x20]
;;;1411   
;;;1412     if ((state == HAL_CAN_STATE_READY) ||
000008  2a01              CMP      r2,#1
00000a  d001              BEQ      |L12.16|
;;;1413         (state == HAL_CAN_STATE_LISTENING))
00000c  2a02              CMP      r2,#2
00000e  d111              BNE      |L12.52|
                  |L12.16|
;;;1414     {
;;;1415       /* Check Tx Mailbox 0 status */
;;;1416       if ((hcan->Instance->TSR & CAN_TSR_TME0) != 0U)
000010  680b              LDR      r3,[r1,#0]
000012  689b              LDR      r3,[r3,#8]
000014  f0036380          AND      r3,r3,#0x4000000
000018  b103              CBZ      r3,|L12.28|
;;;1417       {
;;;1418         freelevel++;
00001a  1c40              ADDS     r0,r0,#1
                  |L12.28|
;;;1419       }
;;;1420   
;;;1421       /* Check Tx Mailbox 1 status */
;;;1422       if ((hcan->Instance->TSR & CAN_TSR_TME1) != 0U)
00001c  680b              LDR      r3,[r1,#0]
00001e  689b              LDR      r3,[r3,#8]
000020  f0036300          AND      r3,r3,#0x8000000
000024  b103              CBZ      r3,|L12.40|
;;;1423       {
;;;1424         freelevel++;
000026  1c40              ADDS     r0,r0,#1
                  |L12.40|
;;;1425       }
;;;1426   
;;;1427       /* Check Tx Mailbox 2 status */
;;;1428       if ((hcan->Instance->TSR & CAN_TSR_TME2) != 0U)
000028  680b              LDR      r3,[r1,#0]
00002a  689b              LDR      r3,[r3,#8]
00002c  f0035380          AND      r3,r3,#0x10000000
000030  b103              CBZ      r3,|L12.52|
;;;1429       {
;;;1430         freelevel++;
000032  1c40              ADDS     r0,r0,#1
                  |L12.52|
;;;1431       }
;;;1432     }
;;;1433   
;;;1434     /* Return Tx Mailboxes free level */
;;;1435     return freelevel;
;;;1436   }
000034  4770              BX       lr
;;;1437   
                          ENDP


                          AREA ||i.HAL_CAN_GetTxTimestamp||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetTxTimestamp PROC
;;;1481     */
;;;1482   uint32_t HAL_CAN_GetTxTimestamp(CAN_HandleTypeDef *hcan, uint32_t TxMailbox)
000000  b530              PUSH     {r4,r5,lr}
;;;1483   {
000002  4602              MOV      r2,r0
;;;1484     uint32_t timestamp = 0U;
000004  2000              MOVS     r0,#0
;;;1485     uint32_t transmitmailbox;
;;;1486     HAL_CAN_StateTypeDef state = hcan->State;
000006  f8924020          LDRB     r4,[r2,#0x20]
;;;1487   
;;;1488     /* Check function parameters */
;;;1489     assert_param(IS_CAN_TX_MAILBOX(TxMailbox));
;;;1490   
;;;1491     if ((state == HAL_CAN_STATE_READY) ||
00000a  2c01              CMP      r4,#1
00000c  d001              BEQ      |L13.18|
;;;1492         (state == HAL_CAN_STATE_LISTENING))
00000e  2c02              CMP      r4,#2
000010  d10a              BNE      |L13.40|
                  |L13.18|
;;;1493     {
;;;1494       /* Select the Tx mailbox */
;;;1495       transmitmailbox = POSITION_VAL(TxMailbox);
000012  fa91f5a1          RBIT     r5,r1
000016  fab5f385          CLZ      r3,r5
;;;1496   
;;;1497       /* Get timestamp */
;;;1498       timestamp = (hcan->Instance->sTxMailBox[transmitmailbox].TDTR & CAN_TDT0R_TIME) >> CAN_TDT0R_TIME_Pos;
00001a  6815              LDR      r5,[r2,#0]
00001c  f50575c0          ADD      r5,r5,#0x180
000020  eb051503          ADD      r5,r5,r3,LSL #4
000024  686d              LDR      r5,[r5,#4]
000026  0c28              LSRS     r0,r5,#16
                  |L13.40|
;;;1499     }
;;;1500   
;;;1501     /* Return the timestamp */
;;;1502     return timestamp;
;;;1503   }
000028  bd30              POP      {r4,r5,pc}
;;;1504   
                          ENDP


                          AREA ||i.HAL_CAN_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_CAN_IRQHandler PROC
;;;1722     */
;;;1723   void HAL_CAN_IRQHandler(CAN_HandleTypeDef *hcan)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1724   {
000004  4604              MOV      r4,r0
;;;1725     uint32_t errorcode = HAL_CAN_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;1726     uint32_t interrupts = READ_REG(hcan->Instance->IER);
000008  6820              LDR      r0,[r4,#0]
00000a  6946              LDR      r6,[r0,#0x14]
;;;1727     uint32_t msrflags = READ_REG(hcan->Instance->MSR);
00000c  6820              LDR      r0,[r4,#0]
00000e  f8d09004          LDR      r9,[r0,#4]
;;;1728     uint32_t tsrflags = READ_REG(hcan->Instance->TSR);
000012  6820              LDR      r0,[r4,#0]
000014  6887              LDR      r7,[r0,#8]
;;;1729     uint32_t rf0rflags = READ_REG(hcan->Instance->RF0R);
000016  6820              LDR      r0,[r4,#0]
000018  f8d0a00c          LDR      r10,[r0,#0xc]
;;;1730     uint32_t rf1rflags = READ_REG(hcan->Instance->RF1R);
00001c  6820              LDR      r0,[r4,#0]
00001e  f8d0b010          LDR      r11,[r0,#0x10]
;;;1731     uint32_t esrflags = READ_REG(hcan->Instance->ESR);
000022  6820              LDR      r0,[r4,#0]
000024  f8d08018          LDR      r8,[r0,#0x18]
;;;1732   
;;;1733     /* Transmit Mailbox empty interrupt management *****************************/
;;;1734     if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)
000028  f0060001          AND      r0,r6,#1
00002c  2800              CMP      r0,#0
00002e  d055              BEQ      |L14.220|
;;;1735     {
;;;1736       /* Transmit Mailbox 0 management *****************************************/
;;;1737       if ((tsrflags & CAN_TSR_RQCP0) != 0U)
000030  f0070001          AND      r0,r7,#1
000034  b1c0              CBZ      r0,|L14.104|
;;;1738       {
;;;1739         /* Clear the Transmission Complete flag (and TXOK0,ALST0,TERR0 bits) */
;;;1740         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP0);
000036  2001              MOVS     r0,#1
000038  6821              LDR      r1,[r4,#0]
00003a  6088              STR      r0,[r1,#8]
;;;1741   
;;;1742         if ((tsrflags & CAN_TSR_TXOK0) != 0U)
00003c  f0070002          AND      r0,r7,#2
000040  b118              CBZ      r0,|L14.74|
;;;1743         {
;;;1744           /* Transmission Mailbox 0 complete callback */
;;;1745   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1746           /* Call registered callback*/
;;;1747           hcan->TxMailbox0CompleteCallback(hcan);
;;;1748   #else
;;;1749           /* Call weak (surcharged) callback */
;;;1750           HAL_CAN_TxMailbox0CompleteCallback(hcan);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_CAN_TxMailbox0CompleteCallback
000048  e00e              B        |L14.104|
                  |L14.74|
;;;1751   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1752         }
;;;1753         else
;;;1754         {
;;;1755           if ((tsrflags & CAN_TSR_ALST0) != 0U)
00004a  f0070004          AND      r0,r7,#4
00004e  b110              CBZ      r0,|L14.86|
;;;1756           {
;;;1757             /* Update error code */
;;;1758             errorcode |= HAL_CAN_ERROR_TX_ALST0;
000050  f4456500          ORR      r5,r5,#0x800
000054  e008              B        |L14.104|
                  |L14.86|
;;;1759           }
;;;1760           else if ((tsrflags & CAN_TSR_TERR0) != 0U)
000056  f0070008          AND      r0,r7,#8
00005a  b110              CBZ      r0,|L14.98|
;;;1761           {
;;;1762             /* Update error code */
;;;1763             errorcode |= HAL_CAN_ERROR_TX_TERR0;
00005c  f4455580          ORR      r5,r5,#0x1000
000060  e002              B        |L14.104|
                  |L14.98|
;;;1764           }
;;;1765           else
;;;1766           {
;;;1767             /* Transmission Mailbox 0 abort callback */
;;;1768   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1769             /* Call registered callback*/
;;;1770             hcan->TxMailbox0AbortCallback(hcan);
;;;1771   #else
;;;1772             /* Call weak (surcharged) callback */
;;;1773             HAL_CAN_TxMailbox0AbortCallback(hcan);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       HAL_CAN_TxMailbox0AbortCallback
                  |L14.104|
;;;1774   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1775           }
;;;1776         }
;;;1777       }
;;;1778   
;;;1779       /* Transmit Mailbox 1 management *****************************************/
;;;1780       if ((tsrflags & CAN_TSR_RQCP1) != 0U)
000068  f4077080          AND      r0,r7,#0x100
00006c  b1c8              CBZ      r0,|L14.162|
;;;1781       {
;;;1782         /* Clear the Transmission Complete flag (and TXOK1,ALST1,TERR1 bits) */
;;;1783         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP1);
00006e  f44f7080          MOV      r0,#0x100
000072  6821              LDR      r1,[r4,#0]
000074  6088              STR      r0,[r1,#8]
;;;1784   
;;;1785         if ((tsrflags & CAN_TSR_TXOK1) != 0U)
000076  f4077000          AND      r0,r7,#0x200
00007a  b118              CBZ      r0,|L14.132|
;;;1786         {
;;;1787           /* Transmission Mailbox 1 complete callback */
;;;1788   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1789           /* Call registered callback*/
;;;1790           hcan->TxMailbox1CompleteCallback(hcan);
;;;1791   #else
;;;1792           /* Call weak (surcharged) callback */
;;;1793           HAL_CAN_TxMailbox1CompleteCallback(hcan);
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       HAL_CAN_TxMailbox1CompleteCallback
000082  e00e              B        |L14.162|
                  |L14.132|
;;;1794   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1795         }
;;;1796         else
;;;1797         {
;;;1798           if ((tsrflags & CAN_TSR_ALST1) != 0U)
000084  f4076080          AND      r0,r7,#0x400
000088  b110              CBZ      r0,|L14.144|
;;;1799           {
;;;1800             /* Update error code */
;;;1801             errorcode |= HAL_CAN_ERROR_TX_ALST1;
00008a  f4455500          ORR      r5,r5,#0x2000
00008e  e008              B        |L14.162|
                  |L14.144|
;;;1802           }
;;;1803           else if ((tsrflags & CAN_TSR_TERR1) != 0U)
000090  f4076000          AND      r0,r7,#0x800
000094  b110              CBZ      r0,|L14.156|
;;;1804           {
;;;1805             /* Update error code */
;;;1806             errorcode |= HAL_CAN_ERROR_TX_TERR1;
000096  f4454580          ORR      r5,r5,#0x4000
00009a  e002              B        |L14.162|
                  |L14.156|
;;;1807           }
;;;1808           else
;;;1809           {
;;;1810             /* Transmission Mailbox 1 abort callback */
;;;1811   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1812             /* Call registered callback*/
;;;1813             hcan->TxMailbox1AbortCallback(hcan);
;;;1814   #else
;;;1815             /* Call weak (surcharged) callback */
;;;1816             HAL_CAN_TxMailbox1AbortCallback(hcan);
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       HAL_CAN_TxMailbox1AbortCallback
                  |L14.162|
;;;1817   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1818           }
;;;1819         }
;;;1820       }
;;;1821   
;;;1822       /* Transmit Mailbox 2 management *****************************************/
;;;1823       if ((tsrflags & CAN_TSR_RQCP2) != 0U)
0000a2  f4073080          AND      r0,r7,#0x10000
0000a6  b1c8              CBZ      r0,|L14.220|
;;;1824       {
;;;1825         /* Clear the Transmission Complete flag (and TXOK2,ALST2,TERR2 bits) */
;;;1826         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP2);
0000a8  f44f3080          MOV      r0,#0x10000
0000ac  6821              LDR      r1,[r4,#0]
0000ae  6088              STR      r0,[r1,#8]
;;;1827   
;;;1828         if ((tsrflags & CAN_TSR_TXOK2) != 0U)
0000b0  f4073000          AND      r0,r7,#0x20000
0000b4  b118              CBZ      r0,|L14.190|
;;;1829         {
;;;1830           /* Transmission Mailbox 2 complete callback */
;;;1831   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1832           /* Call registered callback*/
;;;1833           hcan->TxMailbox2CompleteCallback(hcan);
;;;1834   #else
;;;1835           /* Call weak (surcharged) callback */
;;;1836           HAL_CAN_TxMailbox2CompleteCallback(hcan);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       HAL_CAN_TxMailbox2CompleteCallback
0000bc  e00e              B        |L14.220|
                  |L14.190|
;;;1837   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1838         }
;;;1839         else
;;;1840         {
;;;1841           if ((tsrflags & CAN_TSR_ALST2) != 0U)
0000be  f4072080          AND      r0,r7,#0x40000
0000c2  b110              CBZ      r0,|L14.202|
;;;1842           {
;;;1843             /* Update error code */
;;;1844             errorcode |= HAL_CAN_ERROR_TX_ALST2;
0000c4  f4454500          ORR      r5,r5,#0x8000
0000c8  e008              B        |L14.220|
                  |L14.202|
;;;1845           }
;;;1846           else if ((tsrflags & CAN_TSR_TERR2) != 0U)
0000ca  f4072000          AND      r0,r7,#0x80000
0000ce  b110              CBZ      r0,|L14.214|
;;;1847           {
;;;1848             /* Update error code */
;;;1849             errorcode |= HAL_CAN_ERROR_TX_TERR2;
0000d0  f4453580          ORR      r5,r5,#0x10000
0000d4  e002              B        |L14.220|
                  |L14.214|
;;;1850           }
;;;1851           else
;;;1852           {
;;;1853             /* Transmission Mailbox 2 abort callback */
;;;1854   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1855             /* Call registered callback*/
;;;1856             hcan->TxMailbox2AbortCallback(hcan);
;;;1857   #else
;;;1858             /* Call weak (surcharged) callback */
;;;1859             HAL_CAN_TxMailbox2AbortCallback(hcan);
0000d6  4620              MOV      r0,r4
0000d8  f7fffffe          BL       HAL_CAN_TxMailbox2AbortCallback
                  |L14.220|
;;;1860   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1861           }
;;;1862         }
;;;1863       }
;;;1864     }
;;;1865   
;;;1866     /* Receive FIFO 0 overrun interrupt management *****************************/
;;;1867     if ((interrupts & CAN_IT_RX_FIFO0_OVERRUN) != 0U)
0000dc  f0060008          AND      r0,r6,#8
0000e0  b138              CBZ      r0,|L14.242|
;;;1868     {
;;;1869       if ((rf0rflags & CAN_RF0R_FOVR0) != 0U)
0000e2  f00a0010          AND      r0,r10,#0x10
0000e6  b120              CBZ      r0,|L14.242|
;;;1870       {
;;;1871         /* Set CAN error code to Rx Fifo 0 overrun error */
;;;1872         errorcode |= HAL_CAN_ERROR_RX_FOV0;
0000e8  f4457500          ORR      r5,r5,#0x200
;;;1873   
;;;1874         /* Clear FIFO0 Overrun Flag */
;;;1875         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
0000ec  2010              MOVS     r0,#0x10
0000ee  6821              LDR      r1,[r4,#0]
0000f0  60c8              STR      r0,[r1,#0xc]
                  |L14.242|
;;;1876       }
;;;1877     }
;;;1878   
;;;1879     /* Receive FIFO 0 full interrupt management ********************************/
;;;1880     if ((interrupts & CAN_IT_RX_FIFO0_FULL) != 0U)
0000f2  f0060004          AND      r0,r6,#4
0000f6  b140              CBZ      r0,|L14.266|
;;;1881     {
;;;1882       if ((rf0rflags & CAN_RF0R_FULL0) != 0U)
0000f8  f00a0008          AND      r0,r10,#8
0000fc  b128              CBZ      r0,|L14.266|
;;;1883       {
;;;1884         /* Clear FIFO 0 full Flag */
;;;1885         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);
0000fe  2008              MOVS     r0,#8
000100  6821              LDR      r1,[r4,#0]
000102  60c8              STR      r0,[r1,#0xc]
;;;1886   
;;;1887         /* Receive FIFO 0 full Callback */
;;;1888   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1889         /* Call registered callback*/
;;;1890         hcan->RxFifo0FullCallback(hcan);
;;;1891   #else
;;;1892         /* Call weak (surcharged) callback */
;;;1893         HAL_CAN_RxFifo0FullCallback(hcan);
000104  4620              MOV      r0,r4
000106  f7fffffe          BL       HAL_CAN_RxFifo0FullCallback
                  |L14.266|
;;;1894   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1895       }
;;;1896     }
;;;1897   
;;;1898     /* Receive FIFO 0 message pending interrupt management *********************/
;;;1899     if ((interrupts & CAN_IT_RX_FIFO0_MSG_PENDING) != 0U)
00010a  f0060002          AND      r0,r6,#2
00010e  b138              CBZ      r0,|L14.288|
;;;1900     {
;;;1901       /* Check if message is still pending */
;;;1902       if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) != 0U)
000110  6820              LDR      r0,[r4,#0]
000112  68c0              LDR      r0,[r0,#0xc]
000114  f0000003          AND      r0,r0,#3
000118  b110              CBZ      r0,|L14.288|
;;;1903       {
;;;1904         /* Receive FIFO 0 message pending Callback */
;;;1905   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1906         /* Call registered callback*/
;;;1907         hcan->RxFifo0MsgPendingCallback(hcan);
;;;1908   #else
;;;1909         /* Call weak (surcharged) callback */
;;;1910         HAL_CAN_RxFifo0MsgPendingCallback(hcan);
00011a  4620              MOV      r0,r4
00011c  f7fffffe          BL       HAL_CAN_RxFifo0MsgPendingCallback
                  |L14.288|
;;;1911   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1912       }
;;;1913     }
;;;1914   
;;;1915     /* Receive FIFO 1 overrun interrupt management *****************************/
;;;1916     if ((interrupts & CAN_IT_RX_FIFO1_OVERRUN) != 0U)
000120  f0060040          AND      r0,r6,#0x40
000124  b138              CBZ      r0,|L14.310|
;;;1917     {
;;;1918       if ((rf1rflags & CAN_RF1R_FOVR1) != 0U)
000126  f00b0010          AND      r0,r11,#0x10
00012a  b120              CBZ      r0,|L14.310|
;;;1919       {
;;;1920         /* Set CAN error code to Rx Fifo 1 overrun error */
;;;1921         errorcode |= HAL_CAN_ERROR_RX_FOV1;
00012c  f4456580          ORR      r5,r5,#0x400
;;;1922   
;;;1923         /* Clear FIFO1 Overrun Flag */
;;;1924         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
000130  2010              MOVS     r0,#0x10
000132  6821              LDR      r1,[r4,#0]
000134  6108              STR      r0,[r1,#0x10]
                  |L14.310|
;;;1925       }
;;;1926     }
;;;1927   
;;;1928     /* Receive FIFO 1 full interrupt management ********************************/
;;;1929     if ((interrupts & CAN_IT_RX_FIFO1_FULL) != 0U)
000136  f0060020          AND      r0,r6,#0x20
00013a  b140              CBZ      r0,|L14.334|
;;;1930     {
;;;1931       if ((rf1rflags & CAN_RF1R_FULL1) != 0U)
00013c  f00b0008          AND      r0,r11,#8
000140  b128              CBZ      r0,|L14.334|
;;;1932       {
;;;1933         /* Clear FIFO 1 full Flag */
;;;1934         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);
000142  2008              MOVS     r0,#8
000144  6821              LDR      r1,[r4,#0]
000146  6108              STR      r0,[r1,#0x10]
;;;1935   
;;;1936         /* Receive FIFO 1 full Callback */
;;;1937   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1938         /* Call registered callback*/
;;;1939         hcan->RxFifo1FullCallback(hcan);
;;;1940   #else
;;;1941         /* Call weak (surcharged) callback */
;;;1942         HAL_CAN_RxFifo1FullCallback(hcan);
000148  4620              MOV      r0,r4
00014a  f7fffffe          BL       HAL_CAN_RxFifo1FullCallback
                  |L14.334|
;;;1943   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1944       }
;;;1945     }
;;;1946   
;;;1947     /* Receive FIFO 1 message pending interrupt management *********************/
;;;1948     if ((interrupts & CAN_IT_RX_FIFO1_MSG_PENDING) != 0U)
00014e  f0060010          AND      r0,r6,#0x10
000152  b138              CBZ      r0,|L14.356|
;;;1949     {
;;;1950       /* Check if message is still pending */
;;;1951       if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) != 0U)
000154  6820              LDR      r0,[r4,#0]
000156  6900              LDR      r0,[r0,#0x10]
000158  f0000003          AND      r0,r0,#3
00015c  b110              CBZ      r0,|L14.356|
;;;1952       {
;;;1953         /* Receive FIFO 1 message pending Callback */
;;;1954   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1955         /* Call registered callback*/
;;;1956         hcan->RxFifo1MsgPendingCallback(hcan);
;;;1957   #else
;;;1958         /* Call weak (surcharged) callback */
;;;1959         HAL_CAN_RxFifo1MsgPendingCallback(hcan);
00015e  4620              MOV      r0,r4
000160  f7fffffe          BL       HAL_CAN_RxFifo1MsgPendingCallback
                  |L14.356|
;;;1960   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1961       }
;;;1962     }
;;;1963   
;;;1964     /* Sleep interrupt management *********************************************/
;;;1965     if ((interrupts & CAN_IT_SLEEP_ACK) != 0U)
000164  f4063000          AND      r0,r6,#0x20000
000168  b140              CBZ      r0,|L14.380|
;;;1966     {
;;;1967       if ((msrflags & CAN_MSR_SLAKI) != 0U)
00016a  f0090010          AND      r0,r9,#0x10
00016e  b128              CBZ      r0,|L14.380|
;;;1968       {
;;;1969         /* Clear Sleep interrupt Flag */
;;;1970         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);
000170  2010              MOVS     r0,#0x10
000172  6821              LDR      r1,[r4,#0]
000174  6048              STR      r0,[r1,#4]
;;;1971   
;;;1972         /* Sleep Callback */
;;;1973   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1974         /* Call registered callback*/
;;;1975         hcan->SleepCallback(hcan);
;;;1976   #else
;;;1977         /* Call weak (surcharged) callback */
;;;1978         HAL_CAN_SleepCallback(hcan);
000176  4620              MOV      r0,r4
000178  f7fffffe          BL       HAL_CAN_SleepCallback
                  |L14.380|
;;;1979   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1980       }
;;;1981     }
;;;1982   
;;;1983     /* WakeUp interrupt management *********************************************/
;;;1984     if ((interrupts & CAN_IT_WAKEUP) != 0U)
00017c  f4063080          AND      r0,r6,#0x10000
000180  b140              CBZ      r0,|L14.404|
;;;1985     {
;;;1986       if ((msrflags & CAN_MSR_WKUI) != 0U)
000182  f0090008          AND      r0,r9,#8
000186  b128              CBZ      r0,|L14.404|
;;;1987       {
;;;1988         /* Clear WakeUp Flag */
;;;1989         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);
000188  2008              MOVS     r0,#8
00018a  6821              LDR      r1,[r4,#0]
00018c  6048              STR      r0,[r1,#4]
;;;1990   
;;;1991         /* WakeUp Callback */
;;;1992   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1993         /* Call registered callback*/
;;;1994         hcan->WakeUpFromRxMsgCallback(hcan);
;;;1995   #else
;;;1996         /* Call weak (surcharged) callback */
;;;1997         HAL_CAN_WakeUpFromRxMsgCallback(hcan);
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       HAL_CAN_WakeUpFromRxMsgCallback
                  |L14.404|
;;;1998   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1999       }
;;;2000     }
;;;2001   
;;;2002     /* Error interrupts management *********************************************/
;;;2003     if ((interrupts & CAN_IT_ERROR) != 0U)
000194  f4064000          AND      r0,r6,#0x8000
000198  b388              CBZ      r0,|L14.510|
;;;2004     {
;;;2005       if ((msrflags & CAN_MSR_ERRI) != 0U)
00019a  f0090004          AND      r0,r9,#4
00019e  b378              CBZ      r0,|L14.512|
;;;2006       {
;;;2007         /* Check Error Warning Flag */
;;;2008         if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&
0001a0  f4067080          AND      r0,r6,#0x100
0001a4  b120              CBZ      r0,|L14.432|
;;;2009             ((esrflags & CAN_ESR_EWGF) != 0U))
0001a6  f0080001          AND      r0,r8,#1
0001aa  b108              CBZ      r0,|L14.432|
;;;2010         {
;;;2011           /* Set CAN error code to Error Warning */
;;;2012           errorcode |= HAL_CAN_ERROR_EWG;
0001ac  f0450501          ORR      r5,r5,#1
                  |L14.432|
;;;2013   
;;;2014           /* No need for clear of Error Warning Flag as read-only */
;;;2015         }
;;;2016   
;;;2017         /* Check Error Passive Flag */
;;;2018         if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&
0001b0  f4067000          AND      r0,r6,#0x200
0001b4  b120              CBZ      r0,|L14.448|
;;;2019             ((esrflags & CAN_ESR_EPVF) != 0U))
0001b6  f0080002          AND      r0,r8,#2
0001ba  b108              CBZ      r0,|L14.448|
;;;2020         {
;;;2021           /* Set CAN error code to Error Passive */
;;;2022           errorcode |= HAL_CAN_ERROR_EPV;
0001bc  f0450502          ORR      r5,r5,#2
                  |L14.448|
;;;2023   
;;;2024           /* No need for clear of Error Passive Flag as read-only */
;;;2025         }
;;;2026   
;;;2027         /* Check Bus-off Flag */
;;;2028         if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
0001c0  f4066080          AND      r0,r6,#0x400
0001c4  b120              CBZ      r0,|L14.464|
;;;2029             ((esrflags & CAN_ESR_BOFF) != 0U))
0001c6  f0080004          AND      r0,r8,#4
0001ca  b108              CBZ      r0,|L14.464|
;;;2030         {
;;;2031           /* Set CAN error code to Bus-Off */
;;;2032           errorcode |= HAL_CAN_ERROR_BOF;
0001cc  f0450504          ORR      r5,r5,#4
                  |L14.464|
;;;2033   
;;;2034           /* No need for clear of Error Bus-Off as read-only */
;;;2035         }
;;;2036   
;;;2037         /* Check Last Error Code Flag */
;;;2038         if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
0001d0  f4066000          AND      r0,r6,#0x800
0001d4  b1a0              CBZ      r0,|L14.512|
;;;2039             ((esrflags & CAN_ESR_LEC) != 0U))
0001d6  f0080070          AND      r0,r8,#0x70
0001da  b188              CBZ      r0,|L14.512|
;;;2040         {
;;;2041           switch (esrflags & CAN_ESR_LEC)
0001dc  f0080070          AND      r0,r8,#0x70
0001e0  2840              CMP      r0,#0x40
0001e2  d017              BEQ      |L14.532|
0001e4  dc06              BGT      |L14.500|
0001e6  2810              CMP      r0,#0x10
0001e8  d00b              BEQ      |L14.514|
0001ea  2820              CMP      r0,#0x20
0001ec  d00c              BEQ      |L14.520|
0001ee  2830              CMP      r0,#0x30
0001f0  d119              BNE      |L14.550|
0001f2  e00c              B        |L14.526|
                  |L14.500|
0001f4  2850              CMP      r0,#0x50
0001f6  d010              BEQ      |L14.538|
0001f8  2860              CMP      r0,#0x60
0001fa  d114              BNE      |L14.550|
0001fc  e010              B        |L14.544|
                  |L14.510|
0001fe  e01d              B        |L14.572|
                  |L14.512|
000200  e019              B        |L14.566|
                  |L14.514|
;;;2042           {
;;;2043             case (CAN_ESR_LEC_0):
;;;2044               /* Set CAN error code to Stuff error */
;;;2045               errorcode |= HAL_CAN_ERROR_STF;
000202  f0450508          ORR      r5,r5,#8
;;;2046               break;
000206  e00f              B        |L14.552|
                  |L14.520|
;;;2047             case (CAN_ESR_LEC_1):
;;;2048               /* Set CAN error code to Form error */
;;;2049               errorcode |= HAL_CAN_ERROR_FOR;
000208  f0450510          ORR      r5,r5,#0x10
;;;2050               break;
00020c  e00c              B        |L14.552|
                  |L14.526|
;;;2051             case (CAN_ESR_LEC_1 | CAN_ESR_LEC_0):
;;;2052               /* Set CAN error code to Acknowledgement error */
;;;2053               errorcode |= HAL_CAN_ERROR_ACK;
00020e  f0450520          ORR      r5,r5,#0x20
;;;2054               break;
000212  e009              B        |L14.552|
                  |L14.532|
;;;2055             case (CAN_ESR_LEC_2):
;;;2056               /* Set CAN error code to Bit recessive error */
;;;2057               errorcode |= HAL_CAN_ERROR_BR;
000214  f0450540          ORR      r5,r5,#0x40
;;;2058               break;
000218  e006              B        |L14.552|
                  |L14.538|
;;;2059             case (CAN_ESR_LEC_2 | CAN_ESR_LEC_0):
;;;2060               /* Set CAN error code to Bit Dominant error */
;;;2061               errorcode |= HAL_CAN_ERROR_BD;
00021a  f0450580          ORR      r5,r5,#0x80
;;;2062               break;
00021e  e003              B        |L14.552|
                  |L14.544|
;;;2063             case (CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
;;;2064               /* Set CAN error code to CRC error */
;;;2065               errorcode |= HAL_CAN_ERROR_CRC;
000220  f4457580          ORR      r5,r5,#0x100
;;;2066               break;
000224  e000              B        |L14.552|
                  |L14.550|
;;;2067             default:
;;;2068               break;
000226  bf00              NOP      
                  |L14.552|
000228  bf00              NOP                            ;2046
;;;2069           }
;;;2070   
;;;2071           /* Clear Last error code Flag */
;;;2072           CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
00022a  6820              LDR      r0,[r4,#0]
00022c  6980              LDR      r0,[r0,#0x18]
00022e  f0200070          BIC      r0,r0,#0x70
000232  6821              LDR      r1,[r4,#0]
000234  6188              STR      r0,[r1,#0x18]
                  |L14.566|
;;;2073         }
;;;2074       }
;;;2075   
;;;2076       /* Clear ERRI Flag */
;;;2077       __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
000236  2004              MOVS     r0,#4
000238  6821              LDR      r1,[r4,#0]
00023a  6048              STR      r0,[r1,#4]
                  |L14.572|
;;;2078     }
;;;2079   
;;;2080     /* Call the Error call Back in case of Errors */
;;;2081     if (errorcode != HAL_CAN_ERROR_NONE)
00023c  b12d              CBZ      r5,|L14.586|
;;;2082     {
;;;2083       /* Update error code in handle */
;;;2084       hcan->ErrorCode |= errorcode;
00023e  6a60              LDR      r0,[r4,#0x24]
000240  4328              ORRS     r0,r0,r5
000242  6260              STR      r0,[r4,#0x24]
;;;2085   
;;;2086       /* Call Error callback function */
;;;2087   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;2088       /* Call registered callback*/
;;;2089       hcan->ErrorCallback(hcan);
;;;2090   #else
;;;2091       /* Call weak (surcharged) callback */
;;;2092       HAL_CAN_ErrorCallback(hcan);
000244  4620              MOV      r0,r4
000246  f7fffffe          BL       HAL_CAN_ErrorCallback
                  |L14.586|
;;;2093   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;2094     }
;;;2095   }
00024a  e8bd9ff0          POP      {r4-r12,pc}
;;;2096   
                          ENDP


                          AREA ||i.HAL_CAN_Init||, CODE, READONLY, ALIGN=1

                  HAL_CAN_Init PROC
;;;273      */
;;;274    HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;275    {
000002  4604              MOV      r4,r0
;;;276      uint32_t tickstart;
;;;277    
;;;278      /* Check CAN handle */
;;;279      if (hcan == NULL)
000004  b90c              CBNZ     r4,|L15.10|
;;;280      {
;;;281        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L15.8|
;;;282      }
;;;283    
;;;284      /* Check the parameters */
;;;285      assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
;;;286      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TimeTriggeredMode));
;;;287      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoBusOff));
;;;288      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoWakeUp));
;;;289      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoRetransmission));
;;;290      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.ReceiveFifoLocked));
;;;291      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TransmitFifoPriority));
;;;292      assert_param(IS_CAN_MODE(hcan->Init.Mode));
;;;293      assert_param(IS_CAN_SJW(hcan->Init.SyncJumpWidth));
;;;294      assert_param(IS_CAN_BS1(hcan->Init.TimeSeg1));
;;;295      assert_param(IS_CAN_BS2(hcan->Init.TimeSeg2));
;;;296      assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));
;;;297    
;;;298    #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;299      if (hcan->State == HAL_CAN_STATE_RESET)
;;;300      {
;;;301        /* Reset callbacks to legacy functions */
;;;302        hcan->RxFifo0MsgPendingCallback  =  HAL_CAN_RxFifo0MsgPendingCallback;  /* Legacy weak RxFifo0MsgPendingCallback  */
;;;303        hcan->RxFifo0FullCallback        =  HAL_CAN_RxFifo0FullCallback;        /* Legacy weak RxFifo0FullCallback        */
;;;304        hcan->RxFifo1MsgPendingCallback  =  HAL_CAN_RxFifo1MsgPendingCallback;  /* Legacy weak RxFifo1MsgPendingCallback  */
;;;305        hcan->RxFifo1FullCallback        =  HAL_CAN_RxFifo1FullCallback;        /* Legacy weak RxFifo1FullCallback        */
;;;306        hcan->TxMailbox0CompleteCallback =  HAL_CAN_TxMailbox0CompleteCallback; /* Legacy weak TxMailbox0CompleteCallback */
;;;307        hcan->TxMailbox1CompleteCallback =  HAL_CAN_TxMailbox1CompleteCallback; /* Legacy weak TxMailbox1CompleteCallback */
;;;308        hcan->TxMailbox2CompleteCallback =  HAL_CAN_TxMailbox2CompleteCallback; /* Legacy weak TxMailbox2CompleteCallback */
;;;309        hcan->TxMailbox0AbortCallback    =  HAL_CAN_TxMailbox0AbortCallback;    /* Legacy weak TxMailbox0AbortCallback    */
;;;310        hcan->TxMailbox1AbortCallback    =  HAL_CAN_TxMailbox1AbortCallback;    /* Legacy weak TxMailbox1AbortCallback    */
;;;311        hcan->TxMailbox2AbortCallback    =  HAL_CAN_TxMailbox2AbortCallback;    /* Legacy weak TxMailbox2AbortCallback    */
;;;312        hcan->SleepCallback              =  HAL_CAN_SleepCallback;              /* Legacy weak SleepCallback              */
;;;313        hcan->WakeUpFromRxMsgCallback    =  HAL_CAN_WakeUpFromRxMsgCallback;    /* Legacy weak WakeUpFromRxMsgCallback    */
;;;314        hcan->ErrorCallback              =  HAL_CAN_ErrorCallback;              /* Legacy weak ErrorCallback              */
;;;315    
;;;316        if (hcan->MspInitCallback == NULL)
;;;317        {
;;;318          hcan->MspInitCallback = HAL_CAN_MspInit; /* Legacy weak MspInit */
;;;319        }
;;;320    
;;;321        /* Init the low level hardware: CLOCK, NVIC */
;;;322        hcan->MspInitCallback(hcan);
;;;323      }
;;;324    
;;;325    #else
;;;326      if (hcan->State == HAL_CAN_STATE_RESET)
;;;327      {
;;;328        /* Init the low level hardware: CLOCK, NVIC */
;;;329        HAL_CAN_MspInit(hcan);
;;;330      }
;;;331    #endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */
;;;332    
;;;333      /* Request initialisation */
;;;334      SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
;;;335    
;;;336      /* Get tick */
;;;337      tickstart = HAL_GetTick();
;;;338    
;;;339      /* Wait initialisation acknowledge */
;;;340      while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
;;;341      {
;;;342        if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
;;;343        {
;;;344          /* Update error code */
;;;345          hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
;;;346    
;;;347          /* Change CAN state */
;;;348          hcan->State = HAL_CAN_STATE_ERROR;
;;;349    
;;;350          return HAL_ERROR;
;;;351        }
;;;352      }
;;;353    
;;;354      /* Exit from sleep mode */
;;;355      CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
;;;356    
;;;357      /* Get tick */
;;;358      tickstart = HAL_GetTick();
;;;359    
;;;360      /* Check Sleep mode leave acknowledge */
;;;361      while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
;;;362      {
;;;363        if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
;;;364        {
;;;365          /* Update error code */
;;;366          hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
;;;367    
;;;368          /* Change CAN state */
;;;369          hcan->State = HAL_CAN_STATE_ERROR;
;;;370    
;;;371          return HAL_ERROR;
;;;372        }
;;;373      }
;;;374    
;;;375      /* Set the time triggered communication mode */
;;;376      if (hcan->Init.TimeTriggeredMode == ENABLE)
;;;377      {
;;;378        SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
;;;379      }
;;;380      else
;;;381      {
;;;382        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
;;;383      }
;;;384    
;;;385      /* Set the automatic bus-off management */
;;;386      if (hcan->Init.AutoBusOff == ENABLE)
;;;387      {
;;;388        SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
;;;389      }
;;;390      else
;;;391      {
;;;392        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
;;;393      }
;;;394    
;;;395      /* Set the automatic wake-up mode */
;;;396      if (hcan->Init.AutoWakeUp == ENABLE)
;;;397      {
;;;398        SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
;;;399      }
;;;400      else
;;;401      {
;;;402        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
;;;403      }
;;;404    
;;;405      /* Set the automatic retransmission */
;;;406      if (hcan->Init.AutoRetransmission == ENABLE)
;;;407      {
;;;408        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);
;;;409      }
;;;410      else
;;;411      {
;;;412        SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);
;;;413      }
;;;414    
;;;415      /* Set the receive FIFO locked mode */
;;;416      if (hcan->Init.ReceiveFifoLocked == ENABLE)
;;;417      {
;;;418        SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
;;;419      }
;;;420      else
;;;421      {
;;;422        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
;;;423      }
;;;424    
;;;425      /* Set the transmit FIFO priority */
;;;426      if (hcan->Init.TransmitFifoPriority == ENABLE)
;;;427      {
;;;428        SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
;;;429      }
;;;430      else
;;;431      {
;;;432        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
;;;433      }
;;;434    
;;;435      /* Set the bit timing register */
;;;436      WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
;;;437                                                hcan->Init.SyncJumpWidth  |
;;;438                                                hcan->Init.TimeSeg1       |
;;;439                                                hcan->Init.TimeSeg2       |
;;;440                                                (hcan->Init.Prescaler - 1U)));
;;;441    
;;;442      /* Initialize the error code */
;;;443      hcan->ErrorCode = HAL_CAN_ERROR_NONE;
;;;444    
;;;445      /* Initialize the CAN state */
;;;446      hcan->State = HAL_CAN_STATE_READY;
;;;447    
;;;448      /* Return function status */
;;;449      return HAL_OK;
;;;450    }
000008  bd70              POP      {r4-r6,pc}
                  |L15.10|
00000a  f8940020          LDRB     r0,[r4,#0x20]         ;326
00000e  b910              CBNZ     r0,|L15.22|
000010  4620              MOV      r0,r4                 ;329
000012  f7fffffe          BL       HAL_CAN_MspInit
                  |L15.22|
000016  6820              LDR      r0,[r4,#0]            ;334
000018  6800              LDR      r0,[r0,#0]            ;334
00001a  f0400001          ORR      r0,r0,#1              ;334
00001e  6821              LDR      r1,[r4,#0]            ;334
000020  6008              STR      r0,[r1,#0]            ;334
000022  f7fffffe          BL       HAL_GetTick
000026  4605              MOV      r5,r0                 ;337
000028  e00d              B        |L15.70|
                  |L15.42|
00002a  f7fffffe          BL       HAL_GetTick
00002e  1b40              SUBS     r0,r0,r5              ;342
000030  280a              CMP      r0,#0xa               ;342
000032  d908              BLS      |L15.70|
000034  6a60              LDR      r0,[r4,#0x24]         ;345
000036  f4403000          ORR      r0,r0,#0x20000        ;345
00003a  6260              STR      r0,[r4,#0x24]         ;345
00003c  2005              MOVS     r0,#5                 ;348
00003e  f8840020          STRB     r0,[r4,#0x20]         ;348
000042  2001              MOVS     r0,#1                 ;350
000044  e7e0              B        |L15.8|
                  |L15.70|
000046  6820              LDR      r0,[r4,#0]            ;340
000048  6840              LDR      r0,[r0,#4]            ;340
00004a  f0000001          AND      r0,r0,#1              ;340
00004e  2800              CMP      r0,#0                 ;340
000050  d0eb              BEQ      |L15.42|
000052  6820              LDR      r0,[r4,#0]            ;355
000054  6800              LDR      r0,[r0,#0]            ;355
000056  f0200002          BIC      r0,r0,#2              ;355
00005a  6821              LDR      r1,[r4,#0]            ;355
00005c  6008              STR      r0,[r1,#0]            ;355
00005e  f7fffffe          BL       HAL_GetTick
000062  4605              MOV      r5,r0                 ;358
000064  e00d              B        |L15.130|
                  |L15.102|
000066  f7fffffe          BL       HAL_GetTick
00006a  1b40              SUBS     r0,r0,r5              ;363
00006c  280a              CMP      r0,#0xa               ;363
00006e  d908              BLS      |L15.130|
000070  6a60              LDR      r0,[r4,#0x24]         ;366
000072  f4403000          ORR      r0,r0,#0x20000        ;366
000076  6260              STR      r0,[r4,#0x24]         ;366
000078  2005              MOVS     r0,#5                 ;369
00007a  f8840020          STRB     r0,[r4,#0x20]         ;369
00007e  2001              MOVS     r0,#1                 ;371
000080  e7c2              B        |L15.8|
                  |L15.130|
000082  6820              LDR      r0,[r4,#0]            ;361
000084  6840              LDR      r0,[r0,#4]            ;361
000086  f0000002          AND      r0,r0,#2              ;361
00008a  2800              CMP      r0,#0                 ;361
00008c  d1eb              BNE      |L15.102|
00008e  7e20              LDRB     r0,[r4,#0x18]         ;376
000090  2801              CMP      r0,#1                 ;376
000092  d106              BNE      |L15.162|
000094  6820              LDR      r0,[r4,#0]            ;378
000096  6800              LDR      r0,[r0,#0]            ;378
000098  f0400080          ORR      r0,r0,#0x80           ;378
00009c  6821              LDR      r1,[r4,#0]            ;378
00009e  6008              STR      r0,[r1,#0]            ;378
0000a0  e005              B        |L15.174|
                  |L15.162|
0000a2  6820              LDR      r0,[r4,#0]            ;382
0000a4  6800              LDR      r0,[r0,#0]            ;382
0000a6  f0200080          BIC      r0,r0,#0x80           ;382
0000aa  6821              LDR      r1,[r4,#0]            ;382
0000ac  6008              STR      r0,[r1,#0]            ;382
                  |L15.174|
0000ae  7e60              LDRB     r0,[r4,#0x19]         ;386
0000b0  2801              CMP      r0,#1                 ;386
0000b2  d106              BNE      |L15.194|
0000b4  6820              LDR      r0,[r4,#0]            ;388
0000b6  6800              LDR      r0,[r0,#0]            ;388
0000b8  f0400040          ORR      r0,r0,#0x40           ;388
0000bc  6821              LDR      r1,[r4,#0]            ;388
0000be  6008              STR      r0,[r1,#0]            ;388
0000c0  e005              B        |L15.206|
                  |L15.194|
0000c2  6820              LDR      r0,[r4,#0]            ;392
0000c4  6800              LDR      r0,[r0,#0]            ;392
0000c6  f0200040          BIC      r0,r0,#0x40           ;392
0000ca  6821              LDR      r1,[r4,#0]            ;392
0000cc  6008              STR      r0,[r1,#0]            ;392
                  |L15.206|
0000ce  7ea0              LDRB     r0,[r4,#0x1a]         ;396
0000d0  2801              CMP      r0,#1                 ;396
0000d2  d106              BNE      |L15.226|
0000d4  6820              LDR      r0,[r4,#0]            ;398
0000d6  6800              LDR      r0,[r0,#0]            ;398
0000d8  f0400020          ORR      r0,r0,#0x20           ;398
0000dc  6821              LDR      r1,[r4,#0]            ;398
0000de  6008              STR      r0,[r1,#0]            ;398
0000e0  e005              B        |L15.238|
                  |L15.226|
0000e2  6820              LDR      r0,[r4,#0]            ;402
0000e4  6800              LDR      r0,[r0,#0]            ;402
0000e6  f0200020          BIC      r0,r0,#0x20           ;402
0000ea  6821              LDR      r1,[r4,#0]            ;402
0000ec  6008              STR      r0,[r1,#0]            ;402
                  |L15.238|
0000ee  7ee0              LDRB     r0,[r4,#0x1b]         ;406
0000f0  2801              CMP      r0,#1                 ;406
0000f2  d106              BNE      |L15.258|
0000f4  6820              LDR      r0,[r4,#0]            ;408
0000f6  6800              LDR      r0,[r0,#0]            ;408
0000f8  f0200010          BIC      r0,r0,#0x10           ;408
0000fc  6821              LDR      r1,[r4,#0]            ;408
0000fe  6008              STR      r0,[r1,#0]            ;408
000100  e005              B        |L15.270|
                  |L15.258|
000102  6820              LDR      r0,[r4,#0]            ;412
000104  6800              LDR      r0,[r0,#0]            ;412
000106  f0400010          ORR      r0,r0,#0x10           ;412
00010a  6821              LDR      r1,[r4,#0]            ;412
00010c  6008              STR      r0,[r1,#0]            ;412
                  |L15.270|
00010e  7f20              LDRB     r0,[r4,#0x1c]         ;416
000110  2801              CMP      r0,#1                 ;416
000112  d106              BNE      |L15.290|
000114  6820              LDR      r0,[r4,#0]            ;418
000116  6800              LDR      r0,[r0,#0]            ;418
000118  f0400008          ORR      r0,r0,#8              ;418
00011c  6821              LDR      r1,[r4,#0]            ;418
00011e  6008              STR      r0,[r1,#0]            ;418
000120  e005              B        |L15.302|
                  |L15.290|
000122  6820              LDR      r0,[r4,#0]            ;422
000124  6800              LDR      r0,[r0,#0]            ;422
000126  f0200008          BIC      r0,r0,#8              ;422
00012a  6821              LDR      r1,[r4,#0]            ;422
00012c  6008              STR      r0,[r1,#0]            ;422
                  |L15.302|
00012e  7f60              LDRB     r0,[r4,#0x1d]         ;426
000130  2801              CMP      r0,#1                 ;426
000132  d106              BNE      |L15.322|
000134  6820              LDR      r0,[r4,#0]            ;428
000136  6800              LDR      r0,[r0,#0]            ;428
000138  f0400004          ORR      r0,r0,#4              ;428
00013c  6821              LDR      r1,[r4,#0]            ;428
00013e  6008              STR      r0,[r1,#0]            ;428
000140  e005              B        |L15.334|
                  |L15.322|
000142  6820              LDR      r0,[r4,#0]            ;432
000144  6800              LDR      r0,[r0,#0]            ;432
000146  f0200004          BIC      r0,r0,#4              ;432
00014a  6821              LDR      r1,[r4,#0]            ;432
00014c  6008              STR      r0,[r1,#0]            ;432
                  |L15.334|
00014e  e9d40102          LDRD     r0,r1,[r4,#8]         ;436
000152  4308              ORRS     r0,r0,r1              ;436
000154  6921              LDR      r1,[r4,#0x10]         ;436
000156  4308              ORRS     r0,r0,r1              ;436
000158  6961              LDR      r1,[r4,#0x14]         ;436
00015a  4308              ORRS     r0,r0,r1              ;436
00015c  6861              LDR      r1,[r4,#4]            ;436
00015e  1e49              SUBS     r1,r1,#1              ;436
000160  4308              ORRS     r0,r0,r1              ;436
000162  6821              LDR      r1,[r4,#0]            ;436
000164  61c8              STR      r0,[r1,#0x1c]         ;436
000166  2000              MOVS     r0,#0                 ;443
000168  6260              STR      r0,[r4,#0x24]         ;443
00016a  2001              MOVS     r0,#1                 ;446
00016c  f8840020          STRB     r0,[r4,#0x20]         ;446
000170  2000              MOVS     r0,#0                 ;449
000172  e749              B        |L15.8|
;;;451    
                          ENDP


                          AREA ||i.HAL_CAN_IsSleepActive||, CODE, READONLY, ALIGN=1

                  HAL_CAN_IsSleepActive PROC
;;;1218     */
;;;1219   uint32_t HAL_CAN_IsSleepActive(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;1220   {
;;;1221     uint32_t status = 0U;
000002  2000              MOVS     r0,#0
;;;1222     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8912020          LDRB     r2,[r1,#0x20]
;;;1223   
;;;1224     if ((state == HAL_CAN_STATE_READY) ||
000008  2a01              CMP      r2,#1
00000a  d001              BEQ      |L16.16|
;;;1225         (state == HAL_CAN_STATE_LISTENING))
00000c  2a02              CMP      r2,#2
00000e  d105              BNE      |L16.28|
                  |L16.16|
;;;1226     {
;;;1227       /* Check Sleep mode */
;;;1228       if ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
000010  680b              LDR      r3,[r1,#0]
000012  685b              LDR      r3,[r3,#4]
000014  f0030302          AND      r3,r3,#2
000018  b103              CBZ      r3,|L16.28|
;;;1229       {
;;;1230         status = 1U;
00001a  2001              MOVS     r0,#1
                  |L16.28|
;;;1231       }
;;;1232     }
;;;1233   
;;;1234     /* Return function status */
;;;1235     return status;
;;;1236   }
00001c  4770              BX       lr
;;;1237   
                          ENDP


                          AREA ||i.HAL_CAN_IsTxMessagePending||, CODE, READONLY, ALIGN=1

                  HAL_CAN_IsTxMessagePending PROC
;;;1449     */
;;;1450   uint32_t HAL_CAN_IsTxMessagePending(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes)
000000  b510              PUSH     {r4,lr}
;;;1451   {
000002  4602              MOV      r2,r0
;;;1452     uint32_t status = 0U;
000004  2000              MOVS     r0,#0
;;;1453     HAL_CAN_StateTypeDef state = hcan->State;
000006  f8923020          LDRB     r3,[r2,#0x20]
;;;1454   
;;;1455     /* Check function parameters */
;;;1456     assert_param(IS_CAN_TX_MAILBOX_LIST(TxMailboxes));
;;;1457   
;;;1458     if ((state == HAL_CAN_STATE_READY) ||
00000a  2b01              CMP      r3,#1
00000c  d001              BEQ      |L17.18|
;;;1459         (state == HAL_CAN_STATE_LISTENING))
00000e  2b02              CMP      r3,#2
000010  d107              BNE      |L17.34|
                  |L17.18|
;;;1460     {
;;;1461       /* Check pending transmission request on the selected Tx Mailboxes */
;;;1462       if ((hcan->Instance->TSR & (TxMailboxes << CAN_TSR_TME0_Pos)) != (TxMailboxes << CAN_TSR_TME0_Pos))
000012  6814              LDR      r4,[r2,#0]
000014  68a4              LDR      r4,[r4,#8]
000016  ea046481          AND      r4,r4,r1,LSL #26
00001a  ebb46f81          CMP      r4,r1,LSL #26
00001e  d000              BEQ      |L17.34|
;;;1463       {
;;;1464         status = 1U;
000020  2001              MOVS     r0,#1
                  |L17.34|
;;;1465       }
;;;1466     }
;;;1467   
;;;1468     /* Return status */
;;;1469     return status;
;;;1470   }
000022  bd10              POP      {r4,pc}
;;;1471   
                          ENDP


                          AREA ||i.HAL_CAN_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_MspDeInit PROC
;;;521      */
;;;522    __weak void HAL_CAN_MspDeInit(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;523    {
;;;524      /* Prevent unused argument(s) compilation warning */
;;;525      UNUSED(hcan);
;;;526    
;;;527      /* NOTE : This function Should not be modified, when the callback is needed,
;;;528                the HAL_CAN_MspDeInit could be implemented in the user file
;;;529       */
;;;530    }
;;;531    
                          ENDP


                          AREA ||i.HAL_CAN_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_MspInit PROC
;;;505      */
;;;506    __weak void HAL_CAN_MspInit(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;507    {
;;;508      /* Prevent unused argument(s) compilation warning */
;;;509      UNUSED(hcan);
;;;510    
;;;511      /* NOTE : This function Should not be modified, when the callback is needed,
;;;512                the HAL_CAN_MspInit could be implemented in the user file
;;;513       */
;;;514    }
;;;515    
                          ENDP


                          AREA ||i.HAL_CAN_RequestSleep||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RequestSleep PROC
;;;1138     */
;;;1139   HAL_StatusTypeDef HAL_CAN_RequestSleep(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;1140   {
;;;1141     HAL_CAN_StateTypeDef state = hcan->State;
000002  f8912020          LDRB     r2,[r1,#0x20]
;;;1142   
;;;1143     if ((state == HAL_CAN_STATE_READY) ||
000006  2a01              CMP      r2,#1
000008  d001              BEQ      |L20.14|
;;;1144         (state == HAL_CAN_STATE_LISTENING))
00000a  2a02              CMP      r2,#2
00000c  d107              BNE      |L20.30|
                  |L20.14|
;;;1145     {
;;;1146       /* Request Sleep mode */
;;;1147       SET_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
00000e  6808              LDR      r0,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f0400002          ORR      r0,r0,#2
000016  680b              LDR      r3,[r1,#0]
000018  6018              STR      r0,[r3,#0]
;;;1148   
;;;1149       /* Return function status */
;;;1150       return HAL_OK;
00001a  2000              MOVS     r0,#0
                  |L20.28|
;;;1151     }
;;;1152     else
;;;1153     {
;;;1154       /* Update error code */
;;;1155       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1156   
;;;1157       /* Return function status */
;;;1158       return HAL_ERROR;
;;;1159     }
;;;1160   }
00001c  4770              BX       lr
                  |L20.30|
00001e  6a48              LDR      r0,[r1,#0x24]         ;1155
000020  f4402080          ORR      r0,r0,#0x40000        ;1155
000024  6248              STR      r0,[r1,#0x24]         ;1155
000026  2001              MOVS     r0,#1                 ;1158
000028  e7f8              B        |L20.28|
;;;1161   
                          ENDP


                          AREA ||i.HAL_CAN_ResetError||, CODE, READONLY, ALIGN=1

                  HAL_CAN_ResetError PROC
;;;2420     */
;;;2421   HAL_StatusTypeDef HAL_CAN_ResetError(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;2422   {
;;;2423     HAL_StatusTypeDef status = HAL_OK;
000002  2000              MOVS     r0,#0
;;;2424     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8912020          LDRB     r2,[r1,#0x20]
;;;2425   
;;;2426     if ((state == HAL_CAN_STATE_READY) ||
000008  2a01              CMP      r2,#1
00000a  d001              BEQ      |L21.16|
;;;2427         (state == HAL_CAN_STATE_LISTENING))
00000c  2a02              CMP      r2,#2
00000e  d102              BNE      |L21.22|
                  |L21.16|
;;;2428     {
;;;2429       /* Reset CAN error code */
;;;2430       hcan->ErrorCode = 0U;
000010  2300              MOVS     r3,#0
000012  624b              STR      r3,[r1,#0x24]
000014  e004              B        |L21.32|
                  |L21.22|
;;;2431     }
;;;2432     else
;;;2433     {
;;;2434       /* Update error code */
;;;2435       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
000016  6a4b              LDR      r3,[r1,#0x24]
000018  f4432380          ORR      r3,r3,#0x40000
00001c  624b              STR      r3,[r1,#0x24]
;;;2436   
;;;2437       status = HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L21.32|
;;;2438     }
;;;2439   
;;;2440     /* Return the status */
;;;2441     return status;
;;;2442   }
000020  4770              BX       lr
;;;2443   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo0FullCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo0FullCallback PROC
;;;2252     */
;;;2253   __weak void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2254   {
;;;2255     /* Prevent unused argument(s) compilation warning */
;;;2256     UNUSED(hcan);
;;;2257   
;;;2258     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2259               the HAL_CAN_RxFifo0FullCallback could be implemented in the user
;;;2260               file
;;;2261      */
;;;2262   }
;;;2263   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo0MsgPendingCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo0MsgPendingCallback PROC
;;;2235     */
;;;2236   __weak void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2237   {
;;;2238     /* Prevent unused argument(s) compilation warning */
;;;2239     UNUSED(hcan);
;;;2240   
;;;2241     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2242               the HAL_CAN_RxFifo0MsgPendingCallback could be implemented in the
;;;2243               user file
;;;2244      */
;;;2245   }
;;;2246   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo1FullCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo1FullCallback PROC
;;;2286     */
;;;2287   __weak void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2288   {
;;;2289     /* Prevent unused argument(s) compilation warning */
;;;2290     UNUSED(hcan);
;;;2291   
;;;2292     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2293               the HAL_CAN_RxFifo1FullCallback could be implemented in the user
;;;2294               file
;;;2295      */
;;;2296   }
;;;2297   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo1MsgPendingCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo1MsgPendingCallback PROC
;;;2269     */
;;;2270   __weak void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2271   {
;;;2272     /* Prevent unused argument(s) compilation warning */
;;;2273     UNUSED(hcan);
;;;2274   
;;;2275     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2276               the HAL_CAN_RxFifo1MsgPendingCallback could be implemented in the
;;;2277               user file
;;;2278      */
;;;2279   }
;;;2280   
                          ENDP


                          AREA ||i.HAL_CAN_SleepCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_SleepCallback PROC
;;;2303     */
;;;2304   __weak void HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2305   {
;;;2306     /* Prevent unused argument(s) compilation warning */
;;;2307     UNUSED(hcan);
;;;2308   
;;;2309     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2310               the HAL_CAN_SleepCallback could be implemented in the user file
;;;2311      */
;;;2312   }
;;;2313   
                          ENDP


                          AREA ||i.HAL_CAN_Start||, CODE, READONLY, ALIGN=1

                  HAL_CAN_Start PROC
;;;1031     */
;;;1032   HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;1033   {
000002  4604              MOV      r4,r0
;;;1034     uint32_t tickstart;
;;;1035   
;;;1036     if (hcan->State == HAL_CAN_STATE_READY)
000004  f8940020          LDRB     r0,[r4,#0x20]
000008  2801              CMP      r0,#1
00000a  d122              BNE      |L27.82|
;;;1037     {
;;;1038       /* Change CAN peripheral state */
;;;1039       hcan->State = HAL_CAN_STATE_LISTENING;
00000c  2002              MOVS     r0,#2
00000e  f8840020          STRB     r0,[r4,#0x20]
;;;1040   
;;;1041       /* Request leave initialisation */
;;;1042       CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
000012  6820              LDR      r0,[r4,#0]
000014  6800              LDR      r0,[r0,#0]
000016  f0200001          BIC      r0,r0,#1
00001a  6821              LDR      r1,[r4,#0]
00001c  6008              STR      r0,[r1,#0]
;;;1043   
;;;1044       /* Get tick */
;;;1045       tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
000022  4605              MOV      r5,r0
;;;1046   
;;;1047       /* Wait the acknowledge */
;;;1048       while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
000024  e00d              B        |L27.66|
                  |L27.38|
;;;1049       {
;;;1050         /* Check for the Timeout */
;;;1051         if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
000026  f7fffffe          BL       HAL_GetTick
00002a  1b40              SUBS     r0,r0,r5
00002c  280a              CMP      r0,#0xa
00002e  d908              BLS      |L27.66|
;;;1052         {
;;;1053           /* Update error code */
;;;1054           hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
000030  6a60              LDR      r0,[r4,#0x24]
000032  f4403000          ORR      r0,r0,#0x20000
000036  6260              STR      r0,[r4,#0x24]
;;;1055   
;;;1056           /* Change CAN state */
;;;1057           hcan->State = HAL_CAN_STATE_ERROR;
000038  2005              MOVS     r0,#5
00003a  f8840020          STRB     r0,[r4,#0x20]
;;;1058   
;;;1059           return HAL_ERROR;
00003e  2001              MOVS     r0,#1
                  |L27.64|
;;;1060         }
;;;1061       }
;;;1062   
;;;1063       /* Reset the CAN ErrorCode */
;;;1064       hcan->ErrorCode = HAL_CAN_ERROR_NONE;
;;;1065   
;;;1066       /* Return function status */
;;;1067       return HAL_OK;
;;;1068     }
;;;1069     else
;;;1070     {
;;;1071       /* Update error code */
;;;1072       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
;;;1073   
;;;1074       return HAL_ERROR;
;;;1075     }
;;;1076   }
000040  bd70              POP      {r4-r6,pc}
                  |L27.66|
000042  6820              LDR      r0,[r4,#0]            ;1048
000044  6840              LDR      r0,[r0,#4]            ;1048
000046  f0000001          AND      r0,r0,#1              ;1048
00004a  2800              CMP      r0,#0                 ;1048
00004c  d1eb              BNE      |L27.38|
00004e  6260              STR      r0,[r4,#0x24]         ;1064
000050  e7f6              B        |L27.64|
                  |L27.82|
000052  6a60              LDR      r0,[r4,#0x24]         ;1072
000054  f4402000          ORR      r0,r0,#0x80000        ;1072
000058  6260              STR      r0,[r4,#0x24]         ;1072
00005a  2001              MOVS     r0,#1                 ;1074
00005c  e7f0              B        |L27.64|
;;;1077   
                          ENDP


                          AREA ||i.HAL_CAN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_CAN_Stop PROC
;;;1083     */
;;;1084   HAL_StatusTypeDef HAL_CAN_Stop(CAN_HandleTypeDef *hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;1085   {
000002  4604              MOV      r4,r0
;;;1086     uint32_t tickstart;
;;;1087   
;;;1088     if (hcan->State == HAL_CAN_STATE_LISTENING)
000004  f8940020          LDRB     r0,[r4,#0x20]
000008  2802              CMP      r0,#2
00000a  d128              BNE      |L28.94|
;;;1089     {
;;;1090       /* Request initialisation */
;;;1091       SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
00000c  6820              LDR      r0,[r4,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f0400001          ORR      r0,r0,#1
000014  6821              LDR      r1,[r4,#0]
000016  6008              STR      r0,[r1,#0]
;;;1092   
;;;1093       /* Get tick */
;;;1094       tickstart = HAL_GetTick();
000018  f7fffffe          BL       HAL_GetTick
00001c  4605              MOV      r5,r0
;;;1095   
;;;1096       /* Wait the acknowledge */
;;;1097       while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
00001e  e00d              B        |L28.60|
                  |L28.32|
;;;1098       {
;;;1099         /* Check for the Timeout */
;;;1100         if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
000020  f7fffffe          BL       HAL_GetTick
000024  1b40              SUBS     r0,r0,r5
000026  280a              CMP      r0,#0xa
000028  d908              BLS      |L28.60|
;;;1101         {
;;;1102           /* Update error code */
;;;1103           hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
00002a  6a60              LDR      r0,[r4,#0x24]
00002c  f4403000          ORR      r0,r0,#0x20000
000030  6260              STR      r0,[r4,#0x24]
;;;1104   
;;;1105           /* Change CAN state */
;;;1106           hcan->State = HAL_CAN_STATE_ERROR;
000032  2005              MOVS     r0,#5
000034  f8840020          STRB     r0,[r4,#0x20]
;;;1107   
;;;1108           return HAL_ERROR;
000038  2001              MOVS     r0,#1
                  |L28.58|
;;;1109         }
;;;1110       }
;;;1111   
;;;1112       /* Exit from sleep mode */
;;;1113       CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
;;;1114   
;;;1115       /* Change CAN peripheral state */
;;;1116       hcan->State = HAL_CAN_STATE_READY;
;;;1117   
;;;1118       /* Return function status */
;;;1119       return HAL_OK;
;;;1120     }
;;;1121     else
;;;1122     {
;;;1123       /* Update error code */
;;;1124       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_STARTED;
;;;1125   
;;;1126       return HAL_ERROR;
;;;1127     }
;;;1128   }
00003a  bd70              POP      {r4-r6,pc}
                  |L28.60|
00003c  6820              LDR      r0,[r4,#0]            ;1097
00003e  6840              LDR      r0,[r0,#4]            ;1097
000040  f0000001          AND      r0,r0,#1              ;1097
000044  2800              CMP      r0,#0                 ;1097
000046  d0eb              BEQ      |L28.32|
000048  6820              LDR      r0,[r4,#0]            ;1113
00004a  6800              LDR      r0,[r0,#0]            ;1113
00004c  f0200002          BIC      r0,r0,#2              ;1113
000050  6821              LDR      r1,[r4,#0]            ;1113
000052  6008              STR      r0,[r1,#0]            ;1113
000054  2001              MOVS     r0,#1                 ;1116
000056  f8840020          STRB     r0,[r4,#0x20]         ;1116
00005a  2000              MOVS     r0,#0                 ;1119
00005c  e7ed              B        |L28.58|
                  |L28.94|
00005e  6a60              LDR      r0,[r4,#0x24]         ;1124
000060  f4401080          ORR      r0,r0,#0x100000       ;1124
000064  6260              STR      r0,[r4,#0x24]         ;1124
000066  2001              MOVS     r0,#1                 ;1126
000068  e7e7              B        |L28.58|
;;;1129   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox0AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox0AbortCallback PROC
;;;2184     */
;;;2185   __weak void HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2186   {
;;;2187     /* Prevent unused argument(s) compilation warning */
;;;2188     UNUSED(hcan);
;;;2189   
;;;2190     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2191               the HAL_CAN_TxMailbox0AbortCallback could be implemented in the
;;;2192               user file
;;;2193      */
;;;2194   }
;;;2195   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox0CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox0CompleteCallback PROC
;;;2133     */
;;;2134   __weak void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2135   {
;;;2136     /* Prevent unused argument(s) compilation warning */
;;;2137     UNUSED(hcan);
;;;2138   
;;;2139     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2140               the HAL_CAN_TxMailbox0CompleteCallback could be implemented in the
;;;2141               user file
;;;2142      */
;;;2143   }
;;;2144   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox1AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox1AbortCallback PROC
;;;2201     */
;;;2202   __weak void HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2203   {
;;;2204     /* Prevent unused argument(s) compilation warning */
;;;2205     UNUSED(hcan);
;;;2206   
;;;2207     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2208               the HAL_CAN_TxMailbox1AbortCallback could be implemented in the
;;;2209               user file
;;;2210      */
;;;2211   }
;;;2212   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox1CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox1CompleteCallback PROC
;;;2150     */
;;;2151   __weak void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2152   {
;;;2153     /* Prevent unused argument(s) compilation warning */
;;;2154     UNUSED(hcan);
;;;2155   
;;;2156     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2157               the HAL_CAN_TxMailbox1CompleteCallback could be implemented in the
;;;2158               user file
;;;2159      */
;;;2160   }
;;;2161   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox2AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox2AbortCallback PROC
;;;2218     */
;;;2219   __weak void HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2220   {
;;;2221     /* Prevent unused argument(s) compilation warning */
;;;2222     UNUSED(hcan);
;;;2223   
;;;2224     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2225               the HAL_CAN_TxMailbox2AbortCallback could be implemented in the
;;;2226               user file
;;;2227      */
;;;2228   }
;;;2229   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox2CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox2CompleteCallback PROC
;;;2167     */
;;;2168   __weak void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2169   {
;;;2170     /* Prevent unused argument(s) compilation warning */
;;;2171     UNUSED(hcan);
;;;2172   
;;;2173     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2174               the HAL_CAN_TxMailbox2CompleteCallback could be implemented in the
;;;2175               user file
;;;2176      */
;;;2177   }
;;;2178   
                          ENDP


                          AREA ||i.HAL_CAN_WakeUp||, CODE, READONLY, ALIGN=2

                  HAL_CAN_WakeUp PROC
;;;1169     */
;;;1170   HAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef *hcan)
000000  b518              PUSH     {r3,r4,lr}
;;;1171   {
000002  4601              MOV      r1,r0
;;;1172     __IO uint32_t count = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1173     uint32_t timeout = 1000000U;
000008  4b13              LDR      r3,|L35.88|
;;;1174     HAL_CAN_StateTypeDef state = hcan->State;
00000a  f8912020          LDRB     r2,[r1,#0x20]
;;;1175   
;;;1176     if ((state == HAL_CAN_STATE_READY) ||
00000e  2a01              CMP      r2,#1
000010  d001              BEQ      |L35.22|
;;;1177         (state == HAL_CAN_STATE_LISTENING))
000012  2a02              CMP      r2,#2
000014  d119              BNE      |L35.74|
                  |L35.22|
;;;1178     {
;;;1179       /* Wake up request */
;;;1180       CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
000016  6808              LDR      r0,[r1,#0]
000018  6800              LDR      r0,[r0,#0]
00001a  f0200002          BIC      r0,r0,#2
00001e  680c              LDR      r4,[r1,#0]
000020  6020              STR      r0,[r4,#0]
;;;1181   
;;;1182       /* Wait sleep mode is exited */
;;;1183       do
000022  bf00              NOP      
                  |L35.36|
;;;1184       {
;;;1185         /* Increment counter */
;;;1186         count++;
000024  9800              LDR      r0,[sp,#0]
000026  1c40              ADDS     r0,r0,#1
000028  9000              STR      r0,[sp,#0]
;;;1187   
;;;1188         /* Check if timeout is reached */
;;;1189         if (count > timeout)
00002a  9800              LDR      r0,[sp,#0]
00002c  4298              CMP      r0,r3
00002e  d905              BLS      |L35.60|
;;;1190         {
;;;1191           /* Update error code */
;;;1192           hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
000030  6a48              LDR      r0,[r1,#0x24]
000032  f4403000          ORR      r0,r0,#0x20000
000036  6248              STR      r0,[r1,#0x24]
;;;1193   
;;;1194           return HAL_ERROR;
000038  2001              MOVS     r0,#1
                  |L35.58|
;;;1195         }
;;;1196       }
;;;1197       while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U);
;;;1198   
;;;1199       /* Return function status */
;;;1200       return HAL_OK;
;;;1201     }
;;;1202     else
;;;1203     {
;;;1204       /* Update error code */
;;;1205       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1206   
;;;1207       return HAL_ERROR;
;;;1208     }
;;;1209   }
00003a  bd18              POP      {r3,r4,pc}
                  |L35.60|
00003c  6808              LDR      r0,[r1,#0]            ;1197
00003e  6840              LDR      r0,[r0,#4]            ;1197
000040  f0000002          AND      r0,r0,#2              ;1197
000044  2800              CMP      r0,#0                 ;1197
000046  d1ed              BNE      |L35.36|
000048  e7f7              B        |L35.58|
                  |L35.74|
00004a  6a48              LDR      r0,[r1,#0x24]         ;1205
00004c  f4402080          ORR      r0,r0,#0x40000        ;1205
000050  6248              STR      r0,[r1,#0x24]         ;1205
000052  2001              MOVS     r0,#1                 ;1207
000054  e7f1              B        |L35.58|
;;;1210   
                          ENDP

000056  0000              DCW      0x0000
                  |L35.88|
                          DCD      0x000f4240

                          AREA ||i.HAL_CAN_WakeUpFromRxMsgCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_WakeUpFromRxMsgCallback PROC
;;;2319     */
;;;2320   __weak void HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2321   {
;;;2322     /* Prevent unused argument(s) compilation warning */
;;;2323     UNUSED(hcan);
;;;2324   
;;;2325     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2326               the HAL_CAN_WakeUpFromRxMsgCallback could be implemented in the
;;;2327               user file
;;;2328      */
;;;2329   }
;;;2330   
                          ENDP


;*** Start embedded assembler ***

#line 1 "D:\\Keil_v5\\ARM\\PACK\\Keil\\STM32F4xx_DFP\\2.16.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_can_c_fe6cb454____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_can_c_fe6cb454____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_can_c_fe6cb454____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_can_c_fe6cb454____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_can_c_fe6cb454____RRX|
#line 587
|__asm___19_stm32f4xx_hal_can_c_fe6cb454____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
