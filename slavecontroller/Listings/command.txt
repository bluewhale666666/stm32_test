; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\command.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\command.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\command.crf Power\Command.c]
                          THUMB

                          AREA ||i.Power_Command_Initilization||, CODE, READONLY, ALIGN=2

                  Power_Command_Initilization PROC
;;;124    
;;;125    void Power_Command_Initilization(void)
000000  4802              LDR      r0,|L1.12|
;;;126    {
;;;127      Uart_HandlePtr->RxEventCallback= SU2SM_RxIdleEventCallback;
000002  4903              LDR      r1,|L1.16|
000004  6809              LDR      r1,[r1,#0]  ; Uart_HandlePtr
000006  6688              STR      r0,[r1,#0x68]
;;;128    }
000008  4770              BX       lr
;;;129    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      SU2SM_RxIdleEventCallback
                  |L1.16|
                          DCD      Uart_HandlePtr

                          AREA ||i.Power_Command_Main_Loop||, CODE, READONLY, ALIGN=2

                  Power_Command_Main_Loop PROC
;;;144    
;;;145    void Power_Command_Main_Loop(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;146    {
;;;147    	uint32_t nowTime;
;;;148    	uint32_t elapseTime;
;;;149    	HAL_StatusTypeDef TransmitResult;
;;;150    	uint32_t i;
;;;151    	
;;;152    	for(i=0u; i<(uint32_t)SU2SM_REQ_MAX;i++){
000004  2400              MOVS     r4,#0
000006  e013              B        |L2.48|
                  |L2.8|
;;;153    		if(PowerCommandReceived.RequireCode == strPwrCmdRxReqMap[i].SU2SM_REQ_CD){
000008  481e              LDR      r0,|L2.132|
00000a  7800              LDRB     r0,[r0,#0]  ; PowerCommandReceived
00000c  491e              LDR      r1,|L2.136|
00000e  f8111034          LDRB     r1,[r1,r4,LSL #3]
000012  4288              CMP      r0,r1
000014  d10b              BNE      |L2.46|
;;;154    			if(strPwrCmdRxReqMap[i].pFunc(&PowerCommandReceived) != 0u)
000016  481c              LDR      r0,|L2.136|
000018  eb0000c4          ADD      r0,r0,r4,LSL #3
00001c  6841              LDR      r1,[r0,#4]
00001e  4819              LDR      r0,|L2.132|
000020  4788              BLX      r1
000022  b118              CBZ      r0,|L2.44|
;;;155    			{
;;;156    				memset((uint8_t *)&PowerCommandReceived,0u, sizeof(PowerCommandReceived));
000024  2120              MOVS     r1,#0x20
000026  4817              LDR      r0,|L2.132|
000028  f7fffffe          BL       __aeabi_memclr4
                  |L2.44|
;;;157    			}
;;;158    			break;
00002c  e002              B        |L2.52|
                  |L2.46|
00002e  1c64              ADDS     r4,r4,#1              ;152
                  |L2.48|
000030  2c06              CMP      r4,#6                 ;152
000032  d3e9              BCC      |L2.8|
                  |L2.52|
000034  bf00              NOP      
;;;159    		}
;;;160    	}
;;;161    	
;;;162    	if((power_manage.work_mode != POWER_STATUS_IDLE) && (power_manage.work_mode != POWER_STATUS_SHUTDWON) \
000036  4815              LDR      r0,|L2.140|
000038  7880              LDRB     r0,[r0,#2]  ; power_manage
00003a  b300              CBZ      r0,|L2.126|
00003c  4813              LDR      r0,|L2.140|
00003e  7880              LDRB     r0,[r0,#2]  ; power_manage
000040  2804              CMP      r0,#4
000042  d01c              BEQ      |L2.126|
;;;163    		&& (power_manage.work_mode != POWER_STATUS_SOFTWAREPOWEROFF))
000044  4811              LDR      r0,|L2.140|
000046  7880              LDRB     r0,[r0,#2]  ; power_manage
000048  2805              CMP      r0,#5
00004a  d018              BEQ      |L2.126|
;;;164    	{
;;;165    		nowTime = HAL_GetTick();
00004c  f7fffffe          BL       HAL_GetTick
000050  4605              MOV      r5,r0
;;;166    		elapseTime = nowTime - PeriodicTransmissionTime;
000052  480f              LDR      r0,|L2.144|
000054  6800              LDR      r0,[r0,#0]  ; PeriodicTransmissionTime
000056  1a2e              SUBS     r6,r5,r0
;;;167    		if (elapseTime >= SM2SU_PERIODIC_TRANSMIT_IN_MS)
000058  f5b67ffa          CMP      r6,#0x1f4
00005c  d309              BCC      |L2.114|
;;;168    		{
;;;169    			TransmitResult = Power_Command_Transmit((uint8_t)SM2SU_REQ_CD_PERIODIC_TRANSMISSION);
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       Power_Command_Transmit
000064  4607              MOV      r7,r0
;;;170    			if(TransmitResult == HAL_OK)
000066  b957              CBNZ     r7,|L2.126|
;;;171    			{
;;;172    				PeriodicTransmissionTime = HAL_GetTick();
000068  f7fffffe          BL       HAL_GetTick
00006c  4908              LDR      r1,|L2.144|
00006e  6008              STR      r0,[r1,#0]  ; PeriodicTransmissionTime
000070  e005              B        |L2.126|
                  |L2.114|
;;;173    			}
;;;174    		}
;;;175    		else if(elapseTime >= SM2SU_PERIODIC_TRANSMIT_TIMEOUT_IN_MS)
000072  f5b67f7a          CMP      r6,#0x3e8
000076  d302              BCC      |L2.126|
;;;176    		{
;;;177    			PeriodicTransmissionTimeout = TRUE;
000078  2001              MOVS     r0,#1
00007a  4906              LDR      r1,|L2.148|
00007c  7008              STRB     r0,[r1,#0]
                  |L2.126|
;;;178    		}
;;;179    		else
;;;180    		{
;;;181    			//no statement
;;;182    		}	
;;;183    	}
;;;184    	
;;;185    
;;;186    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;187    
                          ENDP

000082  0000              DCW      0x0000
                  |L2.132|
                          DCD      PowerCommandReceived
                  |L2.136|
                          DCD      strPwrCmdRxReqMap
                  |L2.140|
                          DCD      power_manage
                  |L2.144|
                          DCD      PeriodicTransmissionTime
                  |L2.148|
                          DCD      PeriodicTransmissionTimeout

                          AREA ||i.Power_Command_Receive||, CODE, READONLY, ALIGN=2

                  Power_Command_Receive PROC
;;;187    
;;;188    static void Power_Command_Receive(uint8_t * pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;189    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;190    		BOOL CommandReceived = FALSE;
000008  2700              MOVS     r7,#0
;;;191    		uint16_t crc16;
;;;192    		uint16_t InfoLength;
;;;193    
;;;194    		if(Power_Command_Receive_Buffer_Full == TRUE)
00000a  483b              LDR      r0,|L3.248|
00000c  7800              LDRB     r0,[r0,#0]  ; Power_Command_Receive_Buffer_Full
00000e  2801              CMP      r0,#1
000010  d100              BNE      |L3.20|
;;;195    		{
;;;196    			CommandReceived = TRUE;
000012  2701              MOVS     r7,#1
                  |L3.20|
;;;197    		}
;;;198    		if(Power_Command_Receive_Idle_Detected == TRUE)
000014  4839              LDR      r0,|L3.252|
000016  7800              LDRB     r0,[r0,#0]  ; Power_Command_Receive_Idle_Detected
000018  2801              CMP      r0,#1
00001a  d103              BNE      |L3.36|
;;;199    		{
;;;200    			CommandReceived = TRUE;
00001c  2701              MOVS     r7,#1
;;;201    			Power_Command_Receive_Idle_Detected = FALSE;
00001e  2000              MOVS     r0,#0
000020  4936              LDR      r1,|L3.252|
000022  7008              STRB     r0,[r1,#0]
                  |L3.36|
;;;202    		}
;;;203    		
;;;204    		if (CommandReceived == TRUE)
000024  2f01              CMP      r7,#1
000026  d165              BNE      |L3.244|
;;;205    		{
;;;206    			if((pData[0u] != 0xFFu) || \
000028  7820              LDRB     r0,[r4,#0]
00002a  28ff              CMP      r0,#0xff
00002c  d108              BNE      |L3.64|
;;;207    				(pData[1u] != 0xAAu) || \
00002e  7860              LDRB     r0,[r4,#1]
000030  28aa              CMP      r0,#0xaa
000032  d105              BNE      |L3.64|
;;;208    				(pData[2u] != 0xAAu) || \
000034  78a0              LDRB     r0,[r4,#2]
000036  28aa              CMP      r0,#0xaa
000038  d102              BNE      |L3.64|
;;;209    				(pData[3u] != 0xFFu))
00003a  78e0              LDRB     r0,[r4,#3]
00003c  28ff              CMP      r0,#0xff
00003e  d001              BEQ      |L3.68|
                  |L3.64|
;;;210    			{
;;;211    				return;
;;;212    			}
;;;213    			InfoLength = pData[5u];
;;;214    			if(InfoLength > POWER_COMMAND_MAX_SIZE)
;;;215    			{
;;;216    				return;
;;;217    			}
;;;218    			//CCITT-CRC16
;;;219    			crc16 = CRC16_CCITT(pData, (POWER_COMMAND_HEADER_SIZE + \
;;;220    																POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;221    																InfoLength));
;;;222    			if((pData[POWER_COMMAND_HEADER_SIZE + \
;;;223    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;224    					InfoLength] != (uint8_t)(crc16 & 0xff)) 	|| \
;;;225    					(pData[POWER_COMMAND_HEADER_SIZE + \
;;;226    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;227    					InfoLength + 1u] != (uint8_t)((crc16 >> 8)& 0xff)))		
;;;228    			{
;;;229    				return;
;;;230    			}						
;;;231    			switch(pData[4u])
;;;232    			{
;;;233    				case 0u:
;;;234    					return;	
;;;235    					break;
;;;236    				case 1u:
;;;237    					if(InfoLength != 0u)
;;;238    					{
;;;239    						return;
;;;240    					}
;;;241    					break;
;;;242    				case 2u:
;;;243    					if(InfoLength != 2u)
;;;244    					{
;;;245    						return;
;;;246    					}
;;;247    					break;
;;;248    				case 3u:
;;;249    				case 4u:
;;;250    				case 5u:
;;;251    				case 6u:
;;;252    					if(InfoLength != 1u)
;;;253    					{
;;;254    						return;
;;;255    					}
;;;256    					break;					
;;;257    				default:
;;;258    					return;
;;;259    					break;
;;;260    			}
;;;261    			//EOI
;;;262    			if((pData[POWER_COMMAND_HEADER_SIZE + \
;;;263    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;264    					InfoLength + POWER_COMMAND_CRC_SIZE] != 0xEEu) || \
;;;265    				(pData[POWER_COMMAND_HEADER_SIZE + \
;;;266    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;267    					InfoLength + POWER_COMMAND_CRC_SIZE + 1u] != 0x55u) || \
;;;268    				(pData[POWER_COMMAND_HEADER_SIZE + \
;;;269    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;270    					InfoLength + POWER_COMMAND_CRC_SIZE + 2u] != 0x55u) || \
;;;271    				(pData[POWER_COMMAND_HEADER_SIZE + \
;;;272    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;273    					InfoLength + POWER_COMMAND_CRC_SIZE + 3u] != 0xEEu))
;;;274    			{
;;;275    				return;
;;;276    			}
;;;277    			PowerCommandReceived.RequireCode = pData[4u];
;;;278    			memcpy(PowerCommandReceived.PowerCommand.ContentDefAccess.HEADER, pData, POWER_COMMAND_HEADER_SIZE + \
;;;279    																																	POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE);
;;;280    			PowerCommandReceived.PowerCommand.ContentDefAccess.CRC16 = crc16;
;;;281    			memcpy(PowerCommandReceived.PowerCommand.ContentDefAccess.INFO, &pData[POWER_COMMAND_HEADER_SIZE + \
;;;282    																																	POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE], InfoLength);
;;;283    			memcpy(PowerCommandReceived.PowerCommand.ContentDefAccess.END, &pData[POWER_COMMAND_HEADER_SIZE + \
;;;284    																																	POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;285    																																	InfoLength + POWER_COMMAND_CRC_SIZE],4u);
;;;286    		}
;;;287    }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L3.68|
000044  7965              LDRB     r5,[r4,#5]            ;213
000046  2d1c              CMP      r5,#0x1c              ;214
000048  d900              BLS      |L3.76|
00004a  e7f9              B        |L3.64|
                  |L3.76|
00004c  1da8              ADDS     r0,r5,#6              ;219
00004e  b2c1              UXTB     r1,r0                 ;219
000050  4620              MOV      r0,r4                 ;219
000052  f7fffffe          BL       CRC16_CCITT
000056  4606              MOV      r6,r0                 ;219
000058  1da8              ADDS     r0,r5,#6              ;222
00005a  5c20              LDRB     r0,[r4,r0]            ;222
00005c  b2f1              UXTB     r1,r6                 ;222
00005e  4288              CMP      r0,r1                 ;222
000060  d104              BNE      |L3.108|
000062  1de8              ADDS     r0,r5,#7              ;225
000064  5c20              LDRB     r0,[r4,r0]            ;225
000066  ebb02f16          CMP      r0,r6,LSR #8          ;225
00006a  d000              BEQ      |L3.110|
                  |L3.108|
00006c  e7e8              B        |L3.64|
                  |L3.110|
00006e  7920              LDRB     r0,[r4,#4]            ;231
000070  2807              CMP      r0,#7                 ;231
000072  d214              BCS      |L3.158|
000074  e8dff000          TBB      [pc,r0]               ;231
000078  0405080c          DCB      0x04,0x05,0x08,0x0c
00007c  0d0e0f00          DCB      0x0d,0x0e,0x0f,0x00
000080  e7de              B        |L3.64|
000082  b105              CBZ      r5,|L3.134|
000084  e7dc              B        |L3.64|
                  |L3.134|
000086  e00b              B        |L3.160|
000088  2d02              CMP      r5,#2                 ;243
00008a  d000              BEQ      |L3.142|
00008c  e7d8              B        |L3.64|
                  |L3.142|
00008e  e007              B        |L3.160|
000090  bf00              NOP                            ;249
000092  bf00              NOP                            ;250
000094  bf00              NOP                            ;251
000096  2d01              CMP      r5,#1                 ;252
000098  d000              BEQ      |L3.156|
00009a  e7d1              B        |L3.64|
                  |L3.156|
00009c  e000              B        |L3.160|
                  |L3.158|
00009e  e7cf              B        |L3.64|
                  |L3.160|
0000a0  bf00              NOP                            ;235
0000a2  f1050008          ADD      r0,r5,#8              ;262
0000a6  5c20              LDRB     r0,[r4,r0]            ;262
0000a8  28ee              CMP      r0,#0xee              ;262
0000aa  d10e              BNE      |L3.202|
0000ac  f1050009          ADD      r0,r5,#9              ;265
0000b0  5c20              LDRB     r0,[r4,r0]            ;265
0000b2  2855              CMP      r0,#0x55              ;265
0000b4  d109              BNE      |L3.202|
0000b6  f105000a          ADD      r0,r5,#0xa            ;268
0000ba  5c20              LDRB     r0,[r4,r0]            ;268
0000bc  2855              CMP      r0,#0x55              ;268
0000be  d104              BNE      |L3.202|
0000c0  f105000b          ADD      r0,r5,#0xb            ;271
0000c4  5c20              LDRB     r0,[r4,r0]            ;271
0000c6  28ee              CMP      r0,#0xee              ;271
0000c8  d000              BEQ      |L3.204|
                  |L3.202|
0000ca  e7b9              B        |L3.64|
                  |L3.204|
0000cc  7920              LDRB     r0,[r4,#4]            ;277
0000ce  490c              LDR      r1,|L3.256|
0000d0  7008              STRB     r0,[r1,#0]            ;277
0000d2  4608              MOV      r0,r1                 ;278
0000d4  6821              LDR      r1,[r4,#0]            ;278
0000d6  6041              STR      r1,[r0,#4]            ;278  ; PowerCommandReceived
0000d8  88a1              LDRH     r1,[r4,#4]            ;278
0000da  8101              STRH     r1,[r0,#8]            ;278
0000dc  8346              STRH     r6,[r0,#0x1a]         ;280
0000de  462a              MOV      r2,r5                 ;281
0000e0  1da1              ADDS     r1,r4,#6              ;281
0000e2  300a              ADDS     r0,r0,#0xa            ;281
0000e4  f7fffffe          BL       __aeabi_memcpy
0000e8  f1050008          ADD      r0,r5,#8              ;283
0000ec  1901              ADDS     r1,r0,r4              ;283
0000ee  4804              LDR      r0,|L3.256|
0000f0  6809              LDR      r1,[r1,#0]            ;283
0000f2  61c1              STR      r1,[r0,#0x1c]         ;283
                  |L3.244|
0000f4  bf00              NOP      
0000f6  e7a3              B        |L3.64|
;;;288    
                          ENDP

                  |L3.248|
                          DCD      Power_Command_Receive_Buffer_Full
                  |L3.252|
                          DCD      Power_Command_Receive_Idle_Detected
                  |L3.256|
                          DCD      PowerCommandReceived

                          AREA ||i.Power_Command_Transmit||, CODE, READONLY, ALIGN=2

                  Power_Command_Transmit PROC
;;;129    
;;;130    HAL_StatusTypeDef Power_Command_Transmit(uint8_t ReqCode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;131    {
000004  4605              MOV      r5,r0
;;;132    	HAL_StatusTypeDef ans = HAL_ERROR;
000006  2601              MOVS     r6,#1
;;;133    	uint32_t i;
;;;134    	
;;;135    	for(i=0u; i<(uint32_t)SM2SU_REQ_MAX;i++){
000008  2400              MOVS     r4,#0
00000a  e020              B        |L4.78|
                  |L4.12|
;;;136    		if(ReqCode == strPwrCmdTxReqMap[i].SM2SU_REQ_CD){
00000c  eb040044          ADD      r0,r4,r4,LSL #1
000010  4912              LDR      r1,|L4.92|
000012  f8110020          LDRB     r0,[r1,r0,LSL #2]
000016  42a8              CMP      r0,r5
000018  d118              BNE      |L4.76|
;;;137    			strPwrCmdTxReqMap[i].pFunc(ReqCode,PowerCommandTxBuffer, &PwrCmdTxSize, strPwrCmdTxReqMap[i].InfoLength);
00001a  eb040044          ADD      r0,r4,r4,LSL #1
00001e  eb010080          ADD      r0,r1,r0,LSL #2
000022  8903              LDRH     r3,[r0,#8]
000024  eb040044          ADD      r0,r4,r4,LSL #1
000028  eb010080          ADD      r0,r1,r0,LSL #2
00002c  4a0c              LDR      r2,|L4.96|
00002e  490d              LDR      r1,|L4.100|
000030  6847              LDR      r7,[r0,#4]
000032  4628              MOV      r0,r5
000034  47b8              BLX      r7
;;;138    			ans = HAL_UART_Transmit(Uart_HandlePtr, PowerCommandTxBuffer, PwrCmdTxSize, (uint32_t)POWER_COMMAND_TRANSMIT_TIMEOUT_IN_MS);
000036  f44f73fa          MOV      r3,#0x1f4
00003a  4809              LDR      r0,|L4.96|
00003c  8802              LDRH     r2,[r0,#0]  ; PwrCmdTxSize
00003e  4909              LDR      r1,|L4.100|
000040  4809              LDR      r0,|L4.104|
000042  6800              LDR      r0,[r0,#0]  ; Uart_HandlePtr
000044  f7fffffe          BL       HAL_UART_Transmit
000048  4606              MOV      r6,r0
;;;139    			break;
00004a  e002              B        |L4.82|
                  |L4.76|
00004c  1c64              ADDS     r4,r4,#1              ;135
                  |L4.78|
00004e  2c06              CMP      r4,#6                 ;135
000050  d3dc              BCC      |L4.12|
                  |L4.82|
000052  bf00              NOP      
;;;140    		}
;;;141    	}
;;;142    	return(ans);
000054  4630              MOV      r0,r6
;;;143    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;144    
                          ENDP

00005a  0000              DCW      0x0000
                  |L4.92|
                          DCD      strPwrCmdTxReqMap
                  |L4.96|
                          DCD      PwrCmdTxSize
                  |L4.100|
                          DCD      PowerCommandTxBuffer
                  |L4.104|
                          DCD      Uart_HandlePtr

                          AREA ||i.SM2SU_Req_Call_Compulsory_Power_Off_Command||, CODE, READONLY, ALIGN=1

                  SM2SU_Req_Call_Compulsory_Power_Off_Command PROC
;;;475    
;;;476    static void SM2SU_Req_Call_Compulsory_Power_Off_Command(uint8_t ReqCd, uint8_t *pData, uint16_t *pSize, uint16_t InfoLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;477    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;478    	if(ReqCd != SM2SU_REQ_CD_COMPULSORY_POWER_OFF_COMMAND)
00000c  2c06              CMP      r4,#6
00000e  d003              BEQ      |L5.24|
;;;479    	{
;;;480    		*(pData) = NULL;
000010  2000              MOVS     r0,#0
000012  7028              STRB     r0,[r5,#0]
;;;481    		*(pSize) = 0u;
000014  8030              STRH     r0,[r6,#0]
000016  e005              B        |L5.36|
                  |L5.24|
;;;482    	}
;;;483    	else
;;;484    	{
;;;485    		//TODO
;;;486    		//INFO
;;;487    		//pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE] = ;
;;;488    		//pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + 1u] = ;
;;;489    		
;;;490    		SM2SU_Req_Call_Encapsulation_Func(ReqCd, pData, pSize, InfoLength);
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SM2SU_Req_Call_Encapsulation_Func
                  |L5.36|
;;;491    	}
;;;492    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;493    
                          ENDP


                          AREA ||i.SM2SU_Req_Call_Encapsulation_Func||, CODE, READONLY, ALIGN=1

                  SM2SU_Req_Call_Encapsulation_Func PROC
;;;338    
;;;339    static void SM2SU_Req_Call_Encapsulation_Func(uint8_t ReqCd, uint8_t *pData, uint16_t *pSize, uint16_t InfoLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;340    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;341    		uint16_t crc16;
;;;342    	
;;;343    		*(pSize) = (POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_END_SIZE + \
00000c  f105000c          ADD      r0,r5,#0xc
000010  8038              STRH     r0,[r7,#0]
;;;344    																	POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;345    																	InfoLength + POWER_COMMAND_CRC_SIZE);
;;;346    		//SOI
;;;347    		pData[0u] = 0xFFu;
000012  20ff              MOVS     r0,#0xff
000014  7020              STRB     r0,[r4,#0]
;;;348    		pData[1u] = 0xAAu;
000016  20aa              MOVS     r0,#0xaa
000018  7060              STRB     r0,[r4,#1]
;;;349    		pData[2u] = 0xAAu;
00001a  70a0              STRB     r0,[r4,#2]
;;;350    		pData[3u] = 0xFFu;
00001c  20ff              MOVS     r0,#0xff
00001e  70e0              STRB     r0,[r4,#3]
;;;351    		//CMD
;;;352    		pData[POWER_COMMAND_HEADER_SIZE] = ReqCd;
000020  7126              STRB     r6,[r4,#4]
;;;353    		//LENGTH
;;;354    		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE] = InfoLength;
000022  7165              STRB     r5,[r4,#5]
;;;355    
;;;356    		//INFO
;;;357    		//updated in corresponding function
;;;358    	
;;;359    		//CCITT-CRC16
;;;360    		crc16 = CRC16_CCITT(pData, (POWER_COMMAND_HEADER_SIZE + \
000024  1da8              ADDS     r0,r5,#6
000026  b2c1              UXTB     r1,r0
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       CRC16_CCITT
00002e  4680              MOV      r8,r0
;;;361    																POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;362    																InfoLength));
;;;363    		pData[POWER_COMMAND_HEADER_SIZE + \
000030  1da8              ADDS     r0,r5,#6
000032  f8048000          STRB     r8,[r4,r0]
;;;364    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;365    					InfoLength] = (uint8_t)(crc16 & 0xff); 	
;;;366    		pData[POWER_COMMAND_HEADER_SIZE + \
000036  ea4f2118          LSR      r1,r8,#8
00003a  1de8              ADDS     r0,r5,#7
00003c  5421              STRB     r1,[r4,r0]
;;;367    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;368    					InfoLength + 1u] = (uint8_t)((crc16 >> 8)& 0xff);
;;;369    	
;;;370    		//EOI
;;;371    		pData[POWER_COMMAND_HEADER_SIZE + \
00003e  21ee              MOVS     r1,#0xee
000040  1c40              ADDS     r0,r0,#1
000042  5421              STRB     r1,[r4,r0]
;;;372    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;373    					InfoLength + POWER_COMMAND_CRC_SIZE] = 0xEEu;
;;;374    		pData[POWER_COMMAND_HEADER_SIZE + \
000044  2155              MOVS     r1,#0x55
000046  1c40              ADDS     r0,r0,#1
000048  5421              STRB     r1,[r4,r0]
;;;375    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;376    					InfoLength + POWER_COMMAND_CRC_SIZE + 1u] = 0x55u;
;;;377    		pData[POWER_COMMAND_HEADER_SIZE + \
00004a  1c40              ADDS     r0,r0,#1
00004c  5421              STRB     r1,[r4,r0]
;;;378    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;379    					InfoLength + POWER_COMMAND_CRC_SIZE + 2u] = 0x55u;
;;;380    		pData[POWER_COMMAND_HEADER_SIZE + \
00004e  21ee              MOVS     r1,#0xee
000050  1c40              ADDS     r0,r0,#1
000052  5421              STRB     r1,[r4,r0]
;;;381    					POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + \
;;;382    					InfoLength + POWER_COMMAND_CRC_SIZE + 3u] = 0xEEu;
;;;383    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;384    
                          ENDP


                          AREA ||i.SM2SU_Req_Call_Periodic_Transmission||, CODE, READONLY, ALIGN=2

                  SM2SU_Req_Call_Periodic_Transmission PROC
;;;385    
;;;386    static void SM2SU_Req_Call_Periodic_Transmission(uint8_t ReqCd, uint8_t *pData, uint16_t *pSize, uint16_t InfoLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;387    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;388    	if(ReqCd != SM2SU_REQ_CD_PERIODIC_TRANSMISSION)
00000c  2d01              CMP      r5,#1
00000e  d003              BEQ      |L7.24|
;;;389    	{
;;;390    		*(pData) = NULL;
000010  2000              MOVS     r0,#0
000012  7020              STRB     r0,[r4,#0]
;;;391    		*(pSize) = 0u;
000014  8030              STRH     r0,[r6,#0]
000016  e011              B        |L7.60|
                  |L7.24|
;;;392    	}
;;;393    	else
;;;394    	{
;;;395    		//TODO
;;;396    		//INFO
;;;397    		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE] = power_manage.p_state_l.VAL;
000018  4809              LDR      r0,|L7.64|
00001a  7dc0              LDRB     r0,[r0,#0x17]  ; power_manage
00001c  71a0              STRB     r0,[r4,#6]
;;;398    		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + 1u] = power_manage.p_state_h.VAL;
00001e  4808              LDR      r0,|L7.64|
000020  7d80              LDRB     r0,[r0,#0x16]  ; power_manage
000022  71e0              STRB     r0,[r4,#7]
;;;399    		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + 2u] = power_manage.p_breakdown_l.VAL;
000024  4806              LDR      r0,|L7.64|
000026  7e40              LDRB     r0,[r0,#0x19]  ; power_manage
000028  7220              STRB     r0,[r4,#8]
;;;400    		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + 3u] = power_manage.p_breakdown_h.VAL;
00002a  4805              LDR      r0,|L7.64|
00002c  7e00              LDRB     r0,[r0,#0x18]  ; power_manage
00002e  7260              STRB     r0,[r4,#9]
;;;401    		
;;;402    		SM2SU_Req_Call_Encapsulation_Func(ReqCd, pData, pSize, InfoLength);
000030  463b              MOV      r3,r7
000032  4632              MOV      r2,r6
000034  4621              MOV      r1,r4
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       SM2SU_Req_Call_Encapsulation_Func
                  |L7.60|
;;;403    	}
;;;404    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;405    
                          ENDP

                  |L7.64|
                          DCD      power_manage

                          AREA ||i.SM2SU_Req_Call_Power_Off_Require||, CODE, READONLY, ALIGN=1

                  SM2SU_Req_Call_Power_Off_Require PROC
;;;424    
;;;425    static void SM2SU_Req_Call_Power_Off_Require(uint8_t ReqCd, uint8_t *pData, uint16_t *pSize, uint16_t InfoLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;426    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;427    	if(ReqCd != SM2SU_REQ_CD_POWER_OFF_REQUIRE)
00000c  2d03              CMP      r5,#3
00000e  d003              BEQ      |L8.24|
;;;428    	{
;;;429    		*(pData) = NULL;
000010  2000              MOVS     r0,#0
000012  7020              STRB     r0,[r4,#0]
;;;430    		*(pSize) = 0u;
000014  8030              STRH     r0,[r6,#0]
000016  e007              B        |L8.40|
                  |L8.24|
;;;431    	}
;;;432    	else
;;;433    	{
;;;434    		//TODO
;;;435    		//INFO
;;;436    		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE] = 0x01;
000018  2001              MOVS     r0,#1
00001a  71a0              STRB     r0,[r4,#6]
;;;437    		
;;;438    		SM2SU_Req_Call_Encapsulation_Func(ReqCd, pData, pSize, InfoLength);
00001c  463b              MOV      r3,r7
00001e  4632              MOV      r2,r6
000020  4621              MOV      r1,r4
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       SM2SU_Req_Call_Encapsulation_Func
                  |L8.40|
;;;439    	}
;;;440    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;441    
                          ENDP


                          AREA ||i.SM2SU_Req_Call_Reply_Control_Command||, CODE, READONLY, ALIGN=1

                  SM2SU_Req_Call_Reply_Control_Command PROC
;;;406    /* RC暂不需要该指令 */
;;;407    static void SM2SU_Req_Call_Reply_Control_Command(uint8_t ReqCd, uint8_t *pData, uint16_t *pSize, uint16_t InfoLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;408    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;409    	if(ReqCd != SM2SU_REQ_CD_REPLY_CONTROL_COMMAND)
00000c  2c02              CMP      r4,#2
00000e  d003              BEQ      |L9.24|
;;;410    	{
;;;411    		*(pData) = NULL;
000010  2000              MOVS     r0,#0
000012  7028              STRB     r0,[r5,#0]
;;;412    		*(pSize) = 0u;
000014  8030              STRH     r0,[r6,#0]
000016  e005              B        |L9.36|
                  |L9.24|
;;;413    	}
;;;414    	else
;;;415    	{
;;;416    		//TODO
;;;417    		//INFO
;;;418    //		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE] = ;
;;;419    //		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE + 1u] = ;
;;;420    		
;;;421    		SM2SU_Req_Call_Encapsulation_Func(ReqCd, pData, pSize, InfoLength);
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SM2SU_Req_Call_Encapsulation_Func
                  |L9.36|
;;;422    	}
;;;423    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;424    
                          ENDP


                          AREA ||i.SM2SU_Req_Call_Reply_Power_Off_Command||, CODE, READONLY, ALIGN=1

                  SM2SU_Req_Call_Reply_Power_Off_Command PROC
;;;441    
;;;442    static void SM2SU_Req_Call_Reply_Power_Off_Command(uint8_t ReqCd, uint8_t *pData, uint16_t *pSize, uint16_t InfoLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;443    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;444    	if(ReqCd != SM2SU_REQ_CD_REPLY_POWER_OFF_COMMAND)
00000c  2d04              CMP      r5,#4
00000e  d003              BEQ      |L10.24|
;;;445    	{
;;;446    		*(pData) = NULL;
000010  2000              MOVS     r0,#0
000012  7020              STRB     r0,[r4,#0]
;;;447    		*(pSize) = 0u;
000014  8030              STRH     r0,[r6,#0]
000016  e007              B        |L10.40|
                  |L10.24|
;;;448    	}
;;;449    	else
;;;450    	{
;;;451    		//TODO
;;;452    		//INFO
;;;453    		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE] = 0x01;
000018  2001              MOVS     r0,#1
00001a  71a0              STRB     r0,[r4,#6]
;;;454    		
;;;455    		SM2SU_Req_Call_Encapsulation_Func(ReqCd, pData, pSize, InfoLength);
00001c  463b              MOV      r3,r7
00001e  4632              MOV      r2,r6
000020  4621              MOV      r1,r4
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       SM2SU_Req_Call_Encapsulation_Func
                  |L10.40|
;;;456    	}
;;;457    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;458    
                          ENDP


                          AREA ||i.SM2SU_Req_Call_Reply_Reboot_Command||, CODE, READONLY, ALIGN=1

                  SM2SU_Req_Call_Reply_Reboot_Command PROC
;;;458    
;;;459    static void SM2SU_Req_Call_Reply_Reboot_Command(uint8_t ReqCd, uint8_t *pData, uint16_t *pSize, uint16_t InfoLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;460    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;461    	if(ReqCd != SM2SU_REQ_CD_REPLY_REBOOT_COMMAND)
00000c  2d05              CMP      r5,#5
00000e  d003              BEQ      |L11.24|
;;;462    	{
;;;463    		*(pData) = NULL;
000010  2000              MOVS     r0,#0
000012  7020              STRB     r0,[r4,#0]
;;;464    		*(pSize) = 0u;
000014  8030              STRH     r0,[r6,#0]
000016  e007              B        |L11.40|
                  |L11.24|
;;;465    	}
;;;466    	else
;;;467    	{
;;;468    		//TODO
;;;469    		//INFO
;;;470    		pData[POWER_COMMAND_HEADER_SIZE + POWER_COMMAND_CMD_SIZE + POWER_COMMAND_LENGTH_SIZE] = 0x01;
000018  2001              MOVS     r0,#1
00001a  71a0              STRB     r0,[r4,#6]
;;;471    		
;;;472    		SM2SU_Req_Call_Encapsulation_Func(ReqCd, pData, pSize, InfoLength);
00001c  463b              MOV      r3,r7
00001e  4632              MOV      r2,r6
000020  4621              MOV      r1,r4
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       SM2SU_Req_Call_Encapsulation_Func
                  |L11.40|
;;;473    	}
;;;474    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;475    
                          ENDP


                          AREA ||i.SU2SM_Req_Call_Control_Command||, CODE, READONLY, ALIGN=1

                  SU2SM_Req_Call_Control_Command PROC
;;;294    
;;;295    static uint8_t SU2SM_Req_Call_Control_Command(POWER_COMMAND_RECEIVED *pData)
000000  4601              MOV      r1,r0
;;;296    {
;;;297    		//TODO
;;;298    	return 1u;
000002  2001              MOVS     r0,#1
;;;299    }
000004  4770              BX       lr
;;;300    
                          ENDP


                          AREA ||i.SU2SM_Req_Call_Power_Off_Command||, CODE, READONLY, ALIGN=2

                  SU2SM_Req_Call_Power_Off_Command PROC
;;;308    
;;;309    static uint8_t SU2SM_Req_Call_Power_Off_Command(POWER_COMMAND_RECEIVED *pData)
000000  4601              MOV      r1,r0
;;;310    {
;;;311      	//TODO
;;;312    	if((power_manage.work_mode == POWER_STATUS_48VNOSTART) || (power_manage.work_mode == POWER_STATUS_48VSTART))
000002  4806              LDR      r0,|L13.28|
000004  7880              LDRB     r0,[r0,#2]  ; power_manage
000006  2802              CMP      r0,#2
000008  d003              BEQ      |L13.18|
00000a  4804              LDR      r0,|L13.28|
00000c  7880              LDRB     r0,[r0,#2]  ; power_manage
00000e  2803              CMP      r0,#3
000010  d102              BNE      |L13.24|
                  |L13.18|
;;;313    	{
;;;314    	  power_manage.work_mode = POWER_STATUS_SOFTWAREPOWEROFF;
000012  2005              MOVS     r0,#5
000014  4a01              LDR      r2,|L13.28|
000016  7090              STRB     r0,[r2,#2]
                  |L13.24|
;;;315    	}
;;;316    	 
;;;317    		return 1u;
000018  2001              MOVS     r0,#1
;;;318    }
00001a  4770              BX       lr
;;;319    
                          ENDP

                  |L13.28|
                          DCD      power_manage

                          AREA ||i.SU2SM_Req_Call_Reboot_Command||, CODE, READONLY, ALIGN=2

                  SU2SM_Req_Call_Reboot_Command PROC
;;;320    
;;;321    static uint8_t SU2SM_Req_Call_Reboot_Command(POWER_COMMAND_RECEIVED *pData)
000000  4601              MOV      r1,r0
;;;322    {
;;;323    	//TODO
;;;324    	if((power_manage.work_mode == POWER_STATUS_48VNOSTART) || (power_manage.work_mode == POWER_STATUS_48VSTART))
000002  4806              LDR      r0,|L14.28|
000004  7880              LDRB     r0,[r0,#2]  ; power_manage
000006  2802              CMP      r0,#2
000008  d003              BEQ      |L14.18|
00000a  4804              LDR      r0,|L14.28|
00000c  7880              LDRB     r0,[r0,#2]  ; power_manage
00000e  2803              CMP      r0,#3
000010  d102              BNE      |L14.24|
                  |L14.18|
;;;325    	{
;;;326    	   Reboot_Flag = TRUE;
000012  2001              MOVS     r0,#1
000014  4a02              LDR      r2,|L14.32|
000016  7010              STRB     r0,[r2,#0]
                  |L14.24|
;;;327    	}
;;;328    	
;;;329    		return 1u;
000018  2001              MOVS     r0,#1
;;;330    }
00001a  4770              BX       lr
;;;331    
                          ENDP

                  |L14.28|
                          DCD      power_manage
                  |L14.32|
                          DCD      Reboot_Flag

                          AREA ||i.SU2SM_Req_Call_Reply_Compulsory_Power_Off_Command||, CODE, READONLY, ALIGN=1

                  SU2SM_Req_Call_Reply_Compulsory_Power_Off_Command PROC
;;;332    
;;;333    static uint8_t SU2SM_Req_Call_Reply_Compulsory_Power_Off_Command(POWER_COMMAND_RECEIVED *pData)
000000  4601              MOV      r1,r0
;;;334    {
;;;335    		//TODO
;;;336    		return 1u;
000002  2001              MOVS     r0,#1
;;;337    }
000004  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.SU2SM_Req_Call_Reply_Periodic_Transmission||, CODE, READONLY, ALIGN=1

                  SU2SM_Req_Call_Reply_Periodic_Transmission PROC
;;;288    
;;;289    static uint8_t SU2SM_Req_Call_Reply_Periodic_Transmission(POWER_COMMAND_RECEIVED *pData)
000000  4601              MOV      r1,r0
;;;290    {
;;;291    	//TODO
;;;292    	return 1u;
000002  2001              MOVS     r0,#1
;;;293    }
000004  4770              BX       lr
;;;294    
                          ENDP


                          AREA ||i.SU2SM_Req_Call_Reply_Power_Off_Require||, CODE, READONLY, ALIGN=1

                  SU2SM_Req_Call_Reply_Power_Off_Require PROC
;;;301    
;;;302    static uint8_t SU2SM_Req_Call_Reply_Power_Off_Require(POWER_COMMAND_RECEIVED *pData)
000000  4601              MOV      r1,r0
;;;303    {
;;;304    		//TODO
;;;305    		return 1u;
000002  2001              MOVS     r0,#1
;;;306    }
000004  4770              BX       lr
;;;307    
                          ENDP


                          AREA ||i.SU2SM_RxIdleEventCallback||, CODE, READONLY, ALIGN=2

                  SU2SM_RxIdleEventCallback PROC
;;;493    
;;;494    void SU2SM_RxIdleEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;495    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;496    		uint16_t i;
;;;497    		uint16_t length;
;;;498        if (huart->RxXferCount == 0U)
000006  8df0              LDRH     r0,[r6,#0x2e]
000008  b918              CBNZ     r0,|L18.18|
;;;499        {
;;;500    				//called in UART_Receive_IT()
;;;501    				//Buffer Full
;;;502    			Power_Command_Receive_Buffer_Full = TRUE;
00000a  2001              MOVS     r0,#1
00000c  490f              LDR      r1,|L18.76|
00000e  7008              STRB     r0,[r1,#0]
000010  e002              B        |L18.24|
                  |L18.18|
;;;503    		}
;;;504    		else
;;;505    		{
;;;506    				//Called in HAL_UART_IRQHandler()
;;;507    				//IDLE event detected
;;;508    			Power_Command_Receive_Idle_Detected = TRUE;
000012  2001              MOVS     r0,#1
000014  490e              LDR      r1,|L18.80|
000016  7008              STRB     r0,[r1,#0]
                  |L18.24|
;;;509    		}
;;;510    		if(Size > POWER_COMMAND_MAX_SIZE)
000018  2c1c              CMP      r4,#0x1c
00001a  d904              BLS      |L18.38|
;;;511    		{
;;;512    			Power_Command_Receive_Length_Error_Detected = TRUE;
00001c  2001              MOVS     r0,#1
00001e  490d              LDR      r1,|L18.84|
000020  7008              STRB     r0,[r1,#0]
;;;513    			length = POWER_COMMAND_MAX_SIZE;				
000022  251c              MOVS     r5,#0x1c
000024  e000              B        |L18.40|
                  |L18.38|
;;;514    		}
;;;515    		else
;;;516    		{
;;;517    			length = Size;
000026  4625              MOV      r5,r4
                  |L18.40|
;;;518    		}
;;;519    		Power_Command_Receive(PowerCommandRxBuffer,length);
000028  4629              MOV      r1,r5
00002a  480b              LDR      r0,|L18.88|
00002c  f7fffffe          BL       Power_Command_Receive
;;;520    		memset(PowerCommandRxBuffer,0u, POWER_COMMAND_TXRX_BUFFER_SIZE);
000030  2120              MOVS     r1,#0x20
000032  4809              LDR      r0,|L18.88|
000034  f7fffffe          BL       __aeabi_memclr4
;;;521    		//reset Buffer Countern and Pointer 
;;;522    		if (HAL_UARTEx_ReceiveToIdle_IT(huart, PowerCommandRxBuffer, POWER_COMMAND_TXRX_BUFFER_SIZE) != HAL_OK)
000038  2220              MOVS     r2,#0x20
00003a  4907              LDR      r1,|L18.88|
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       HAL_UARTEx_ReceiveToIdle_IT
000042  b110              CBZ      r0,|L18.74|
;;;523    		{
;;;524    				Power_Command_ReceiveToIdle_Restart_Error = TRUE;				
000044  2001              MOVS     r0,#1
000046  4905              LDR      r1,|L18.92|
000048  7008              STRB     r0,[r1,#0]
                  |L18.74|
;;;525    		}	
;;;526    }
00004a  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L18.76|
                          DCD      Power_Command_Receive_Buffer_Full
                  |L18.80|
                          DCD      Power_Command_Receive_Idle_Detected
                  |L18.84|
                          DCD      Power_Command_Receive_Length_Error_Detected
                  |L18.88|
                          DCD      PowerCommandRxBuffer
                  |L18.92|
                          DCD      Power_Command_ReceiveToIdle_Restart_Error

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  PowerCommandRxBuffer
                          %        32
                  PowerCommandTxBuffer
                          %        32
                  PowerCommandReceived
                          %        32

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  strPwrCmdRxReqMap
000000  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      SU2SM_Req_Call_Reply_Periodic_Transmission
000008  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      SU2SM_Req_Call_Control_Command
000010  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      SU2SM_Req_Call_Reply_Power_Off_Require
000018  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      SU2SM_Req_Call_Power_Off_Command
000020  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      SU2SM_Req_Call_Reboot_Command
000028  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      SU2SM_Req_Call_Reply_Compulsory_Power_Off_Command
                  strPwrCmdTxReqMap
000030  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      SM2SU_Req_Call_Periodic_Transmission
000038  0010              DCW      0x0010
00003a  0000              DCB      0x00,0x00
00003c  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      SM2SU_Req_Call_Reply_Control_Command
000044  0002              DCW      0x0002
000046  0000              DCB      0x00,0x00
000048  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      SM2SU_Req_Call_Power_Off_Require
000050  0001              DCW      0x0001
000052  0000              DCB      0x00,0x00
000054  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      SM2SU_Req_Call_Reply_Power_Off_Command
00005c  0001              DCW      0x0001
00005e  0000              DCB      0x00,0x00
000060  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      SM2SU_Req_Call_Reply_Reboot_Command
000068  0001              DCW      0x0001
00006a  0000              DCB      0x00,0x00
00006c  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      SM2SU_Req_Call_Compulsory_Power_Off_Command
000074  0001              DCW      0x0001
000076  0000              DCB      0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  crc_table
000000  00001021          DCW      0x0000,0x1021
000004  20423063          DCW      0x2042,0x3063
000008  408450a5          DCW      0x4084,0x50a5
00000c  60c670e7          DCW      0x60c6,0x70e7
000010  81089129          DCW      0x8108,0x9129
000014  a14ab16b          DCW      0xa14a,0xb16b
000018  c18cd1ad          DCW      0xc18c,0xd1ad
00001c  e1cef1ef          DCW      0xe1ce,0xf1ef
000020  12310210          DCW      0x1231,0x0210
000024  32732252          DCW      0x3273,0x2252
000028  52b54294          DCW      0x52b5,0x4294
00002c  72f762d6          DCW      0x72f7,0x62d6
000030  93398318          DCW      0x9339,0x8318
000034  b37ba35a          DCW      0xb37b,0xa35a
000038  d3bdc39c          DCW      0xd3bd,0xc39c
00003c  f3ffe3de          DCW      0xf3ff,0xe3de
000040  24623443          DCW      0x2462,0x3443
000044  04201401          DCW      0x0420,0x1401
000048  64e674c7          DCW      0x64e6,0x74c7
00004c  44a45485          DCW      0x44a4,0x5485
000050  a56ab54b          DCW      0xa56a,0xb54b
000054  85289509          DCW      0x8528,0x9509
000058  e5eef5cf          DCW      0xe5ee,0xf5cf
00005c  c5acd58d          DCW      0xc5ac,0xd58d
000060  36532672          DCW      0x3653,0x2672
000064  16110630          DCW      0x1611,0x0630
000068  76d766f6          DCW      0x76d7,0x66f6
00006c  569546b4          DCW      0x5695,0x46b4
000070  b75ba77a          DCW      0xb75b,0xa77a
000074  97198738          DCW      0x9719,0x8738
000078  f7dfe7fe          DCW      0xf7df,0xe7fe
00007c  d79dc7bc          DCW      0xd79d,0xc7bc
000080  48c458e5          DCW      0x48c4,0x58e5
000084  688678a7          DCW      0x6886,0x78a7
000088  08401861          DCW      0x0840,0x1861
00008c  28023823          DCW      0x2802,0x3823
000090  c9ccd9ed          DCW      0xc9cc,0xd9ed
000094  e98ef9af          DCW      0xe98e,0xf9af
000098  89489969          DCW      0x8948,0x9969
00009c  a90ab92b          DCW      0xa90a,0xb92b
0000a0  5af54ad4          DCW      0x5af5,0x4ad4
0000a4  7ab76a96          DCW      0x7ab7,0x6a96
0000a8  1a710a50          DCW      0x1a71,0x0a50
0000ac  3a332a12          DCW      0x3a33,0x2a12
0000b0  dbfdcbdc          DCW      0xdbfd,0xcbdc
0000b4  fbbfeb9e          DCW      0xfbbf,0xeb9e
0000b8  9b798b58          DCW      0x9b79,0x8b58
0000bc  bb3bab1a          DCW      0xbb3b,0xab1a
0000c0  6ca67c87          DCW      0x6ca6,0x7c87
0000c4  4ce45cc5          DCW      0x4ce4,0x5cc5
0000c8  2c223c03          DCW      0x2c22,0x3c03
0000cc  0c601c41          DCW      0x0c60,0x1c41
0000d0  edaefd8f          DCW      0xedae,0xfd8f
0000d4  cdecddcd          DCW      0xcdec,0xddcd
0000d8  ad2abd0b          DCW      0xad2a,0xbd0b
0000dc  8d689d49          DCW      0x8d68,0x9d49
0000e0  7e976eb6          DCW      0x7e97,0x6eb6
0000e4  5ed54ef4          DCW      0x5ed5,0x4ef4
0000e8  3e132e32          DCW      0x3e13,0x2e32
0000ec  1e510e70          DCW      0x1e51,0x0e70
0000f0  ff9fefbe          DCW      0xff9f,0xefbe
0000f4  dfddcffc          DCW      0xdfdd,0xcffc
0000f8  bf1baf3a          DCW      0xbf1b,0xaf3a
0000fc  9f598f78          DCW      0x9f59,0x8f78
000100  918881a9          DCW      0x9188,0x81a9
000104  b1caa1eb          DCW      0xb1ca,0xa1eb
000108  d10cc12d          DCW      0xd10c,0xc12d
00010c  f14ee16f          DCW      0xf14e,0xe16f
000110  108000a1          DCW      0x1080,0x00a1
000114  30c220e3          DCW      0x30c2,0x20e3
000118  50044025          DCW      0x5004,0x4025
00011c  70466067          DCW      0x7046,0x6067
000120  83b99398          DCW      0x83b9,0x9398
000124  a3fbb3da          DCW      0xa3fb,0xb3da
000128  c33dd31c          DCW      0xc33d,0xd31c
00012c  e37ff35e          DCW      0xe37f,0xf35e
000130  02b11290          DCW      0x02b1,0x1290
000134  22f332d2          DCW      0x22f3,0x32d2
000138  42355214          DCW      0x4235,0x5214
00013c  62777256          DCW      0x6277,0x7256
000140  b5eaa5cb          DCW      0xb5ea,0xa5cb
000144  95a88589          DCW      0x95a8,0x8589
000148  f56ee54f          DCW      0xf56e,0xe54f
00014c  d52cc50d          DCW      0xd52c,0xc50d
000150  34e224c3          DCW      0x34e2,0x24c3
000154  14a00481          DCW      0x14a0,0x0481
000158  74666447          DCW      0x7466,0x6447
00015c  54244405          DCW      0x5424,0x4405
000160  a7dbb7fa          DCW      0xa7db,0xb7fa
000164  879997b8          DCW      0x8799,0x97b8
000168  e75ff77e          DCW      0xe75f,0xf77e
00016c  c71dd73c          DCW      0xc71d,0xd73c
000170  26d336f2          DCW      0x26d3,0x36f2
000174  069116b0          DCW      0x0691,0x16b0
000178  66577676          DCW      0x6657,0x7676
00017c  46155634          DCW      0x4615,0x5634
000180  d94cc96d          DCW      0xd94c,0xc96d
000184  f90ee92f          DCW      0xf90e,0xe92f
000188  99c889e9          DCW      0x99c8,0x89e9
00018c  b98aa9ab          DCW      0xb98a,0xa9ab
000190  58444865          DCW      0x5844,0x4865
000194  78066827          DCW      0x7806,0x6827
000198  18c008e1          DCW      0x18c0,0x08e1
00019c  388228a3          DCW      0x3882,0x28a3
0001a0  cb7ddb5c          DCW      0xcb7d,0xdb5c
0001a4  eb3ffb1e          DCW      0xeb3f,0xfb1e
0001a8  8bf99bd8          DCW      0x8bf9,0x9bd8
0001ac  abbbbb9a          DCW      0xabbb,0xbb9a
0001b0  4a755a54          DCW      0x4a75,0x5a54
0001b4  6a377a16          DCW      0x6a37,0x7a16
0001b8  0af11ad0          DCW      0x0af1,0x1ad0
0001bc  2ab33a92          DCW      0x2ab3,0x3a92
0001c0  fd2eed0f          DCW      0xfd2e,0xed0f
0001c4  dd6ccd4d          DCW      0xdd6c,0xcd4d
0001c8  bdaaad8b          DCW      0xbdaa,0xad8b
0001cc  9de88dc9          DCW      0x9de8,0x8dc9
0001d0  7c266c07          DCW      0x7c26,0x6c07
0001d4  5c644c45          DCW      0x5c64,0x4c45
0001d8  3ca22c83          DCW      0x3ca2,0x2c83
0001dc  1ce00cc1          DCW      0x1ce0,0x0cc1
0001e0  ef1fff3e          DCW      0xef1f,0xff3e
0001e4  cf5ddf7c          DCW      0xcf5d,0xdf7c
0001e8  af9bbfba          DCW      0xaf9b,0xbfba
0001ec  8fd99ff8          DCW      0x8fd9,0x9ff8
0001f0  6e177e36          DCW      0x6e17,0x7e36
0001f4  4e555e74          DCW      0x4e55,0x5e74
0001f8  2e933eb2          DCW      0x2e93,0x3eb2
0001fc  0ed11ef0          DCW      0x0ed1,0x1ef0
                  Reboot_Flag
000200  00000000          DCB      0x00,0x00,0x00,0x00
                  Uart_HandlePtr
                          DCD      0x00000000
                  Udma_UartRx_HandlePtr
                          DCD      0x00000000
                  Udma_Uarttx_HandlePtr
                          DCD      0x00000000
                  PeriodicTransmissionTime
                          DCD      0x00000000
                  PeriodicTransmissionTimeout
000214  0000              DCB      0x00,0x00
                  PwrCmdTxSize
000216  0000              DCW      0x0000
                  Power_Command_Receive_Idle_Detected
000218  00                DCB      0x00
                  Power_Command_Receive_Buffer_Full
000219  00                DCB      0x00
                  Power_Command_Receive_Length_Error_Detected
00021a  00                DCB      0x00
                  Power_Command_ReceiveToIdle_Restart_Error
00021b  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "Power\\Command.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_Command_c_0049b171____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_Command_c_0049b171____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_Command_c_0049b171____REVSH|
#line 402
|__asm___9_Command_c_0049b171____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_Command_c_0049b171____RRX|
#line 587
|__asm___9_Command_c_0049b171____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
