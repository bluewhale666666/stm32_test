; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\9252_hw.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\9252_hw.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\9252_hw.crf etherCAT\9252_HW.c]
                          THUMB

                          AREA ||i.GetInterruptRegister||, CODE, READONLY, ALIGN=2

                  GetInterruptRegister PROC
;;;108    
;;;109    static void GetInterruptRegister(void)
000000  b508              PUSH     {r3,lr}
;;;110    {
;;;111        volatile unsigned int int_status;
;;;112        int_status = PDI_Disable_Global_Interrupt();
000002  f7fffffe          BL       PDI_Disable_Global_Interrupt
000006  9000              STR      r0,[sp,#0]
;;;113        HW_EscReadIsr((MEM_ADDR *)&EscALEvent.Word, 0x220, 2);
000008  2202              MOVS     r2,#2
00000a  f44f7108          MOV      r1,#0x220
00000e  4803              LDR      r0,|L1.28|
000010  f7fffffe          BL       HW_EscReadIsr
;;;114        PDI_Restore_Global_Interrupt(int_status);
000014  9800              LDR      r0,[sp,#0]
000016  f7fffffe          BL       PDI_Restore_Global_Interrupt
;;;115    }
00001a  bd08              POP      {r3,pc}
;;;116    
                          ENDP

                  |L1.28|
                          DCD      EscALEvent

                          AREA ||i.HW_DisableSyncManChannel||, CODE, READONLY, ALIGN=1

                  HW_DisableSyncManChannel PROC
;;;600    
;;;601    void HW_DisableSyncManChannel(UINT8 channel)
000000  b538              PUSH     {r3-r5,lr}
;;;602    {
000002  4604              MOV      r4,r0
;;;603        UINT16 Offset;
;;;604    
;;;605    
;;;606        volatile UINT32 smStatus = SM_SETTING_PDI_DISABLE;
000004  f44f7080          MOV      r0,#0x100
000008  9000              STR      r0,[sp,#0]
;;;607        smStatus = SWAPDWORD(smStatus);
00000a  9800              LDR      r0,[sp,#0]
00000c  9000              STR      r0,[sp,#0]
;;;608    
;;;609        Offset = (ESC_SYNCMAN_CONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
00000e  00e0              LSLS     r0,r4,#3
000010  f6000504          ADD      r5,r0,#0x804
;;;610    
;;;611        HW_EscWriteDWord(smStatus,Offset);
000014  2204              MOVS     r2,#4
000016  4629              MOV      r1,r5
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       HW_EscWrite
;;;612    
;;;613        /*wait until SyncManager is disabled*/
;;;614        do
00001e  bf00              NOP      
                  |L2.32|
;;;615        {
;;;616            HW_EscReadDWord(smStatus, Offset);
000020  2204              MOVS     r2,#4
000022  4629              MOV      r1,r5
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       HW_EscRead
;;;617    
;;;618            smStatus = SWAPDWORD(smStatus);
00002a  9800              LDR      r0,[sp,#0]
00002c  9000              STR      r0,[sp,#0]
;;;619    
;;;620        }while(!(smStatus & SM_SETTING_PDI_DISABLE));
00002e  9800              LDR      r0,[sp,#0]
000030  f4007080          AND      r0,r0,#0x100
000034  2800              CMP      r0,#0
000036  d0f3              BEQ      |L2.32|
;;;621    }
000038  bd38              POP      {r3-r5,pc}
;;;622    
                          ENDP


                          AREA ||i.HW_EnableSyncManChannel||, CODE, READONLY, ALIGN=1

                  HW_EnableSyncManChannel PROC
;;;634    
;;;635    void HW_EnableSyncManChannel(UINT8 channel)
000000  b538              PUSH     {r3-r5,lr}
;;;636    {
000002  4604              MOV      r4,r0
;;;637        UINT16 Offset;
;;;638    
;;;639        volatile UINT32 smStatus = 0x00000000;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;640    
;;;641        Offset = (ESC_SYNCMAN_CONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
000008  00e0              LSLS     r0,r4,#3
00000a  f6000504          ADD      r5,r0,#0x804
;;;642    
;;;643        HW_EscWriteDWord(smStatus,Offset);
00000e  2204              MOVS     r2,#4
000010  4629              MOV      r1,r5
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       HW_EscWrite
;;;644    
;;;645        /*wait until SyncManager is enabled*/
;;;646        do
000018  bf00              NOP      
                  |L3.26|
;;;647        {
;;;648            HW_EscReadDWord(smStatus,Offset);
00001a  2204              MOVS     r2,#4
00001c  4629              MOV      r1,r5
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       HW_EscRead
;;;649    
;;;650            smStatus = SWAPDWORD(smStatus);
000024  9800              LDR      r0,[sp,#0]
000026  9000              STR      r0,[sp,#0]
;;;651    
;;;652        }while((smStatus & SM_SETTING_PDI_DISABLE));
000028  9800              LDR      r0,[sp,#0]
00002a  f4007080          AND      r0,r0,#0x100
00002e  2800              CMP      r0,#0
000030  d1f3              BNE      |L3.26|
;;;653    }
000032  bd38              POP      {r3-r5,pc}
;;;654    
                          ENDP


                          AREA ||i.HW_EscRead||, CODE, READONLY, ALIGN=1

                  HW_EscRead PROC
;;;356    
;;;357    void HW_EscRead( MEM_ADDR *pData, UINT16 Address, UINT16 Len )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;358    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;359        volatile unsigned int int_status;
;;;360        UINT16 i;
;;;361        UINT8 *pTmpData = (UINT8 *)pData;
00000a  46b8              MOV      r8,r7
;;;362    
;;;363        /* loop for all bytes to be read */
;;;364        while ( Len > 0 )
00000c  e02d              B        |L4.106|
                  |L4.14|
;;;365        {
;;;366            if (Address >= MIN_PD_READ_ADDRESS)
00000e  f5b55f80          CMP      r5,#0x1000
000012  db01              BLT      |L4.24|
;;;367            {
;;;368                i = Len;
000014  4634              MOV      r4,r6
000016  e018              B        |L4.74|
                  |L4.24|
;;;369            }
;;;370            else
;;;371            {
;;;372                i= (Len > 4) ? 4 : Len;
000018  2e04              CMP      r6,#4
00001a  dd01              BLE      |L4.32|
00001c  2004              MOVS     r0,#4
00001e  e000              B        |L4.34|
                  |L4.32|
000020  4630              MOV      r0,r6
                  |L4.34|
000022  4604              MOV      r4,r0
;;;373    
;;;374                if(Address & 01)
000024  f0050001          AND      r0,r5,#1
000028  b108              CBZ      r0,|L4.46|
;;;375                {
;;;376                   i=1;
00002a  2401              MOVS     r4,#1
00002c  e00d              B        |L4.74|
                  |L4.46|
;;;377                }
;;;378                else if (Address & 02)
00002e  f0050002          AND      r0,r5,#2
000032  b138              CBZ      r0,|L4.68|
;;;379                {
;;;380                   i= (i&1) ? 1:2;
000034  f0040001          AND      r0,r4,#1
000038  b108              CBZ      r0,|L4.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L4.64|
                  |L4.62|
00003e  2002              MOVS     r0,#2
                  |L4.64|
000040  4604              MOV      r4,r0
000042  e002              B        |L4.74|
                  |L4.68|
;;;381                }
;;;382                else if (i == 03)
000044  2c03              CMP      r4,#3
000046  d100              BNE      |L4.74|
;;;383                {
;;;384                    i=1;
000048  2401              MOVS     r4,#1
                  |L4.74|
;;;385                }
;;;386            }
;;;387    
;;;388            int_status = PDI_Disable_Global_Interrupt();
00004a  f7fffffe          BL       PDI_Disable_Global_Interrupt
00004e  9000              STR      r0,[sp,#0]
;;;389            PDIReadReg(pTmpData, Address, i);
000050  4622              MOV      r2,r4
000052  4629              MOV      r1,r5
000054  4640              MOV      r0,r8
000056  f7fffffe          BL       PDIReadReg
;;;390            PDI_Restore_Global_Interrupt(int_status);
00005a  9800              LDR      r0,[sp,#0]
00005c  f7fffffe          BL       PDI_Restore_Global_Interrupt
;;;391    
;;;392            Len -= i;
000060  1b30              SUBS     r0,r6,r4
000062  b286              UXTH     r6,r0
;;;393            pTmpData += i;
000064  44a0              ADD      r8,r8,r4
;;;394            Address += i;
000066  1928              ADDS     r0,r5,r4
000068  b285              UXTH     r5,r0
                  |L4.106|
00006a  2e00              CMP      r6,#0                 ;364
00006c  dccf              BGT      |L4.14|
;;;395        }
;;;396    
;;;397    }
00006e  e8bd83f8          POP      {r3-r9,pc}
;;;398    
                          ENDP


                          AREA ||i.HW_EscReadIsr||, CODE, READONLY, ALIGN=1

                  HW_EscReadIsr PROC
;;;423    
;;;424    void HW_EscReadIsr( MEM_ADDR *pData, UINT16 Address, UINT16 Len )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;425    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;426    
;;;427       UINT16 i;
;;;428       UINT8 *pTmpData = (UINT8 *)pData;
00000a  46b8              MOV      r8,r7
;;;429    
;;;430        /* send the address and command to the ESC */
;;;431    
;;;432        /* loop for all bytes to be read */
;;;433       while ( Len > 0 )
00000c  e027              B        |L5.94|
                  |L5.14|
;;;434       {
;;;435    
;;;436            if (Address >= MIN_PD_READ_ADDRESS)
00000e  f5b55f80          CMP      r5,#0x1000
000012  db01              BLT      |L5.24|
;;;437            {
;;;438                i = Len;
000014  4634              MOV      r4,r6
000016  e018              B        |L5.74|
                  |L5.24|
;;;439            }
;;;440            else
;;;441            {
;;;442                i= (Len > 4) ? 4 : Len;
000018  2e04              CMP      r6,#4
00001a  dd01              BLE      |L5.32|
00001c  2004              MOVS     r0,#4
00001e  e000              B        |L5.34|
                  |L5.32|
000020  4630              MOV      r0,r6
                  |L5.34|
000022  4604              MOV      r4,r0
;;;443    
;;;444                if(Address & 01)
000024  f0050001          AND      r0,r5,#1
000028  b108              CBZ      r0,|L5.46|
;;;445                {
;;;446                   i=1;
00002a  2401              MOVS     r4,#1
00002c  e00d              B        |L5.74|
                  |L5.46|
;;;447                }
;;;448                else if (Address & 02)
00002e  f0050002          AND      r0,r5,#2
000032  b138              CBZ      r0,|L5.68|
;;;449                {
;;;450                   i= (i&1) ? 1:2;
000034  f0040001          AND      r0,r4,#1
000038  b108              CBZ      r0,|L5.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L5.64|
                  |L5.62|
00003e  2002              MOVS     r0,#2
                  |L5.64|
000040  4604              MOV      r4,r0
000042  e002              B        |L5.74|
                  |L5.68|
;;;451                }
;;;452                else if (i == 03)
000044  2c03              CMP      r4,#3
000046  d100              BNE      |L5.74|
;;;453                {
;;;454                    i=1;
000048  2401              MOVS     r4,#1
                  |L5.74|
;;;455                }
;;;456            }
;;;457    
;;;458            PDIReadReg(pTmpData, Address,i);
00004a  4622              MOV      r2,r4
00004c  4629              MOV      r1,r5
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       PDIReadReg
;;;459    
;;;460            Len -= i;
000054  1b30              SUBS     r0,r6,r4
000056  b286              UXTH     r6,r0
;;;461            pTmpData += i;
000058  44a0              ADD      r8,r8,r4
;;;462            Address += i;
00005a  1928              ADDS     r0,r5,r4
00005c  b285              UXTH     r5,r0
                  |L5.94|
00005e  2e00              CMP      r6,#0                 ;433
000060  dcd5              BGT      |L5.14|
;;;463        }
;;;464       
;;;465    }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;466    
                          ENDP


                          AREA ||i.HW_EscWrite||, CODE, READONLY, ALIGN=1

                  HW_EscWrite PROC
;;;481    
;;;482    void HW_EscWrite( MEM_ADDR *pData, UINT16 Address, UINT16 Len )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;483    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;484        volatile unsigned int int_status;
;;;485        UINT16 i;
;;;486        UINT8 *pTmpData = (UINT8 *)pData;
00000a  46b8              MOV      r8,r7
;;;487    
;;;488        /* loop for all bytes to be written */
;;;489        while ( Len )
00000c  e02d              B        |L6.106|
                  |L6.14|
;;;490        {
;;;491    
;;;492            if (Address >= MIN_PD_WRITE_ADDRESS)
00000e  f5b55f80          CMP      r5,#0x1000
000012  db01              BLT      |L6.24|
;;;493            {
;;;494                i = Len;
000014  4634              MOV      r4,r6
000016  e018              B        |L6.74|
                  |L6.24|
;;;495            }
;;;496            else
;;;497            {
;;;498                i= (Len > 4) ? 4 : Len;
000018  2e04              CMP      r6,#4
00001a  dd01              BLE      |L6.32|
00001c  2004              MOVS     r0,#4
00001e  e000              B        |L6.34|
                  |L6.32|
000020  4630              MOV      r0,r6
                  |L6.34|
000022  4604              MOV      r4,r0
;;;499    
;;;500                if(Address & 01)
000024  f0050001          AND      r0,r5,#1
000028  b108              CBZ      r0,|L6.46|
;;;501                {
;;;502                   i=1;
00002a  2401              MOVS     r4,#1
00002c  e00d              B        |L6.74|
                  |L6.46|
;;;503                }
;;;504                else if (Address & 02)
00002e  f0050002          AND      r0,r5,#2
000032  b138              CBZ      r0,|L6.68|
;;;505                {
;;;506                   i= (i&1) ? 1:2;
000034  f0040001          AND      r0,r4,#1
000038  b108              CBZ      r0,|L6.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L6.64|
                  |L6.62|
00003e  2002              MOVS     r0,#2
                  |L6.64|
000040  4604              MOV      r4,r0
000042  e002              B        |L6.74|
                  |L6.68|
;;;507                }
;;;508                else if (i == 03)
000044  2c03              CMP      r4,#3
000046  d100              BNE      |L6.74|
;;;509                {
;;;510                    i=1;
000048  2401              MOVS     r4,#1
                  |L6.74|
;;;511                }
;;;512            }
;;;513    
;;;514            int_status = PDI_Disable_Global_Interrupt();
00004a  f7fffffe          BL       PDI_Disable_Global_Interrupt
00004e  9000              STR      r0,[sp,#0]
;;;515           
;;;516            /* start transmission */
;;;517            PDIWriteReg(pTmpData, Address, i);
000050  4622              MOV      r2,r4
000052  4629              MOV      r1,r5
000054  4640              MOV      r0,r8
000056  f7fffffe          BL       PDIWriteReg
;;;518            PDI_Restore_Global_Interrupt(int_status);
00005a  9800              LDR      r0,[sp,#0]
00005c  f7fffffe          BL       PDI_Restore_Global_Interrupt
;;;519    
;;;520              
;;;521            /* next address */
;;;522            Len -= i;
000060  1b30              SUBS     r0,r6,r4
000062  b286              UXTH     r6,r0
;;;523            pTmpData += i;
000064  44a0              ADD      r8,r8,r4
;;;524            Address += i;
000066  1928              ADDS     r0,r5,r4
000068  b285              UXTH     r5,r0
                  |L6.106|
00006a  2e00              CMP      r6,#0                 ;489
00006c  d1cf              BNE      |L6.14|
;;;525    
;;;526        }
;;;527    }
00006e  e8bd83f8          POP      {r3-r9,pc}
;;;528    
                          ENDP


                          AREA ||i.HW_EscWriteIsr||, CODE, READONLY, ALIGN=1

                  HW_EscWriteIsr PROC
;;;544    
;;;545    void HW_EscWriteIsr( MEM_ADDR *pData, UINT16 Address, UINT16 Len )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;546    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;547    
;;;548        UINT16 i ;
;;;549        UINT8 *pTmpData = (UINT8 *)pData;
00000a  46b8              MOV      r8,r7
;;;550    
;;;551      
;;;552        /* loop for all bytes to be written */
;;;553        while ( Len )
00000c  e027              B        |L7.94|
                  |L7.14|
;;;554        {
;;;555    
;;;556            if (Address >= MIN_PD_WRITE_ADDRESS)
00000e  f5b55f80          CMP      r5,#0x1000
000012  db01              BLT      |L7.24|
;;;557            {
;;;558                i = Len;
000014  4634              MOV      r4,r6
000016  e018              B        |L7.74|
                  |L7.24|
;;;559            }
;;;560            else
;;;561            {
;;;562                i= (Len > 4) ? 4 : Len;
000018  2e04              CMP      r6,#4
00001a  dd01              BLE      |L7.32|
00001c  2004              MOVS     r0,#4
00001e  e000              B        |L7.34|
                  |L7.32|
000020  4630              MOV      r0,r6
                  |L7.34|
000022  4604              MOV      r4,r0
;;;563    
;;;564                if(Address & 01)
000024  f0050001          AND      r0,r5,#1
000028  b108              CBZ      r0,|L7.46|
;;;565                {
;;;566                   i=1;
00002a  2401              MOVS     r4,#1
00002c  e00d              B        |L7.74|
                  |L7.46|
;;;567                }
;;;568                else if (Address & 02)
00002e  f0050002          AND      r0,r5,#2
000032  b138              CBZ      r0,|L7.68|
;;;569                {
;;;570                   i= (i&1) ? 1:2;
000034  f0040001          AND      r0,r4,#1
000038  b108              CBZ      r0,|L7.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L7.64|
                  |L7.62|
00003e  2002              MOVS     r0,#2
                  |L7.64|
000040  4604              MOV      r4,r0
000042  e002              B        |L7.74|
                  |L7.68|
;;;571                }
;;;572                else if (i == 03)
000044  2c03              CMP      r4,#3
000046  d100              BNE      |L7.74|
;;;573                {
;;;574                    i=1;
000048  2401              MOVS     r4,#1
                  |L7.74|
;;;575                }
;;;576            }
;;;577            
;;;578           /* start transmission */
;;;579           PDIWriteReg(pTmpData, Address, i);
00004a  4622              MOV      r2,r4
00004c  4629              MOV      r1,r5
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       PDIWriteReg
;;;580           
;;;581           /* next address */
;;;582            Len -= i;
000054  1b30              SUBS     r0,r6,r4
000056  b286              UXTH     r6,r0
;;;583            pTmpData += i;
000058  44a0              ADD      r8,r8,r4
;;;584            Address += i;
00005a  1928              ADDS     r0,r5,r4
00005c  b285              UXTH     r5,r0
                  |L7.94|
00005e  2e00              CMP      r6,#0                 ;553
000060  d1d5              BNE      |L7.14|
;;;585        }
;;;586    
;;;587    }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;588    
                          ENDP


                          AREA ||i.HW_GetALEventRegister||, CODE, READONLY, ALIGN=2

                  HW_GetALEventRegister PROC
;;;264    
;;;265    UINT16 HW_GetALEventRegister(void)
000000  b510              PUSH     {r4,lr}
;;;266    {
;;;267        GetInterruptRegister();
000002  f7fffffe          BL       GetInterruptRegister
;;;268        return EscALEvent.Word;
000006  4801              LDR      r0,|L8.12|
000008  8800              LDRH     r0,[r0,#0]  ; EscALEvent
;;;269    }
00000a  bd10              POP      {r4,pc}
;;;270    
                          ENDP

                  |L8.12|
                          DCD      EscALEvent

                          AREA ||i.HW_GetALEventRegister_Isr||, CODE, READONLY, ALIGN=2

                  HW_GetALEventRegister_Isr PROC
;;;283      
;;;284    UINT16 HW_GetALEventRegister_Isr(void)
000000  b510              PUSH     {r4,lr}
;;;285    {
;;;286        ISR_GetInterruptRegister();
000002  f7fffffe          BL       ISR_GetInterruptRegister
;;;287        return EscALEvent.Word;
000006  4801              LDR      r0,|L9.12|
000008  8800              LDRH     r0,[r0,#0]  ; EscALEvent
;;;288    }
00000a  bd10              POP      {r4,pc}
;;;289    
                          ENDP

                  |L9.12|
                          DCD      EscALEvent

                          AREA ||i.HW_GetSyncMan||, CODE, READONLY, ALIGN=2

                  HW_GetSyncMan PROC
;;;668    
;;;669    TSYNCMAN ESCMEM * HW_GetSyncMan(UINT8 channel)
000000  b510              PUSH     {r4,lr}
;;;670    {
000002  4604              MOV      r4,r0
;;;671        // get a temporary structure of the Sync Manager
;;;672        HW_EscRead( (MEM_ADDR *)&TmpSyncMan, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
000004  f44f6000          MOV      r0,#0x800
000008  eb0001c4          ADD      r1,r0,r4,LSL #3
00000c  2208              MOVS     r2,#8
00000e  4802              LDR      r0,|L10.24|
000010  f7fffffe          BL       HW_EscRead
;;;673    
;;;674        return &TmpSyncMan;
000014  4800              LDR      r0,|L10.24|
;;;675    }
000016  bd10              POP      {r4,pc}
;;;676    
                          ENDP

                  |L10.24|
                          DCD      TmpSyncMan

                          AREA ||i.HW_Release||, CODE, READONLY, ALIGN=1

                  HW_Release PROC
;;;247    
;;;248    void HW_Release(void)
000000  4770              BX       lr
;;;249    {
;;;250    
;;;251    }
;;;252    
                          ENDP


                          AREA ||i.HW_ResetALEventMask||, CODE, READONLY, ALIGN=2

                  HW_ResetALEventMask PROC
;;;301      
;;;302    void HW_ResetALEventMask(UINT16 intMask)
000000  b51c              PUSH     {r2-r4,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304        volatile unsigned int int_status;
;;;305        UINT16 mask;
;;;306        
;;;307        HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
000004  2202              MOVS     r2,#2
000006  f44f7101          MOV      r1,#0x204
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       HW_EscRead
;;;308    
;;;309        mask &= intMask;
000010  f8bd0000          LDRH     r0,[sp,#0]
000014  4020              ANDS     r0,r0,r4
000016  9000              STR      r0,[sp,#0]
;;;310        int_status = PDI_Disable_Global_Interrupt();
000018  f7fffffe          BL       PDI_Disable_Global_Interrupt
00001c  9001              STR      r0,[sp,#4]
;;;311        HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
00001e  2202              MOVS     r2,#2
000020  f44f7101          MOV      r1,#0x204
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       HW_EscWrite
;;;312        HW_EscReadWord(nAlEventMask, ESC_AL_EVENTMASK_OFFSET);
00002a  2202              MOVS     r2,#2
00002c  f44f7101          MOV      r1,#0x204
000030  4803              LDR      r0,|L12.64|
000032  f7fffffe          BL       HW_EscRead
;;;313        PDI_Restore_Global_Interrupt(int_status);
000036  9801              LDR      r0,[sp,#4]
000038  f7fffffe          BL       PDI_Restore_Global_Interrupt
;;;314    }
00003c  bd1c              POP      {r2-r4,pc}
;;;315    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      nAlEventMask

                          AREA ||i.HW_SetALEventMask||, CODE, READONLY, ALIGN=2

                  HW_SetALEventMask PROC
;;;327      
;;;328    void HW_SetALEventMask(UINT16 intMask)
000000  b51c              PUSH     {r2-r4,lr}
;;;329    {
000002  4604              MOV      r4,r0
;;;330        volatile unsigned int int_status;
;;;331        UINT16 mask;
;;;332    
;;;333        HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
000004  2202              MOVS     r2,#2
000006  f44f7101          MOV      r1,#0x204
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       HW_EscRead
;;;334    
;;;335        mask |= intMask;
000010  f8bd0000          LDRH     r0,[sp,#0]
000014  4320              ORRS     r0,r0,r4
000016  9000              STR      r0,[sp,#0]
;;;336        int_status = PDI_Disable_Global_Interrupt();
000018  f7fffffe          BL       PDI_Disable_Global_Interrupt
00001c  9001              STR      r0,[sp,#4]
;;;337        HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
00001e  2202              MOVS     r2,#2
000020  f44f7101          MOV      r1,#0x204
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       HW_EscWrite
;;;338        HW_EscReadWord(nAlEventMask, ESC_AL_EVENTMASK_OFFSET);
00002a  2202              MOVS     r2,#2
00002c  f44f7101          MOV      r1,#0x204
000030  4803              LDR      r0,|L13.64|
000032  f7fffffe          BL       HW_EscRead
;;;339        PDI_Restore_Global_Interrupt(int_status);
000036  9801              LDR      r0,[sp,#4]
000038  f7fffffe          BL       PDI_Restore_Global_Interrupt
;;;340    }
00003c  bd1c              POP      {r2-r4,pc}
;;;341    
                          ENDP

00003e  0000              DCW      0x0000
                  |L13.64|
                          DCD      nAlEventMask

                          AREA ||i.ISR_GetInterruptRegister||, CODE, READONLY, ALIGN=2

                  ISR_GetInterruptRegister PROC
;;;130    
;;;131    static void ISR_GetInterruptRegister(void)
000000  b510              PUSH     {r4,lr}
;;;132    {
;;;133         HW_EscReadIsr((MEM_ADDR *)&EscALEvent.Word, 0x220, 2);
000002  2202              MOVS     r2,#2
000004  f44f7108          MOV      r1,#0x220
000008  4801              LDR      r0,|L14.16|
00000a  f7fffffe          BL       HW_EscReadIsr
;;;134    }
00000e  bd10              POP      {r4,pc}
;;;135    
                          ENDP

                  |L14.16|
                          DCD      EscALEvent

                          AREA ||i.LAN9252_Init||, CODE, READONLY, ALIGN=2

                  LAN9252_Init PROC
;;;165      
;;;166    UINT8 LAN9252_Init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;167    {
;;;168    
;;;169        UINT16 intMask;
;;;170        UINT32 data;
;;;171        
;;;172        //Read BYTE-ORDER register 0x64.
;;;173        do
000002  bf00              NOP      
                  |L15.4|
;;;174        {
;;;175            data = PDIReadLAN9252DirectReg( LAN9252_BYTE_ORDER_REG);
000004  2064              MOVS     r0,#0x64
000006  f7fffffe          BL       PDIReadLAN9252DirectReg
00000a  9000              STR      r0,[sp,#0]
;;;176        }while(0x87654321 != data);
00000c  4930              LDR      r1,|L15.208|
00000e  9800              LDR      r0,[sp,#0]
000010  4288              CMP      r0,r1
000012  d1f7              BNE      |L15.4|
;;;177    
;;;178        do
000014  bf00              NOP      
                  |L15.22|
;;;179        {
;;;180            intMask = 0x93;
000016  2093              MOVS     r0,#0x93
000018  9001              STR      r0,[sp,#4]
;;;181            HW_EscWriteWord(intMask, ESC_AL_EVENTMASK_OFFSET);
00001a  2202              MOVS     r2,#2
00001c  f44f7101          MOV      r1,#0x204
000020  a801              ADD      r0,sp,#4
000022  f7fffffe          BL       HW_EscWrite
;;;182           
;;;183            intMask = 0;
000026  2000              MOVS     r0,#0
000028  9001              STR      r0,[sp,#4]
;;;184            HW_EscReadWord(intMask, ESC_AL_EVENTMASK_OFFSET);
00002a  2202              MOVS     r2,#2
00002c  f44f7101          MOV      r1,#0x204
000030  a801              ADD      r0,sp,#4
000032  f7fffffe          BL       HW_EscRead
;;;185        } while (intMask != 0x93);
000036  f8bd0004          LDRH     r0,[sp,#4]
00003a  2893              CMP      r0,#0x93
00003c  d1eb              BNE      |L15.22|
;;;186    
;;;187    		//Enable PDI access to MII management
;;;188    		data = 0x01;
00003e  2001              MOVS     r0,#1
000040  9000              STR      r0,[sp,#0]
;;;189    		HW_EscWriteWord(data, 0x517);
000042  2202              MOVS     r2,#2
000044  f2405117          MOV      r1,#0x517
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       HW_EscWrite
;;;190    		
;;;191    		//Select PHY0
;;;192    		data = 0x0000;
00004e  2000              MOVS     r0,#0
000050  9000              STR      r0,[sp,#0]
;;;193    		HW_EscWriteWord(data, 0x512);	
000052  2202              MOVS     r2,#2
000054  f2405112          MOV      r1,#0x512
000058  4668              MOV      r0,sp
00005a  f7fffffe          BL       HW_EscWrite
;;;194    		
;;;195    		//Disable Auto-Negotiation and force link speed to 100mbps / full duplex
;;;196    		data = 0x2100;
00005e  f44f5004          MOV      r0,#0x2100
000062  9000              STR      r0,[sp,#0]
;;;197    		HW_EscWriteWord(data, 0x514);
000064  2202              MOVS     r2,#2
000066  f2405114          MOV      r1,#0x514
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       HW_EscWrite
;;;198    		
;;;199    		//Enable write operation, MDPI control only
;;;200    		data = 0x0201;
000070  f2402001          MOV      r0,#0x201
000074  9000              STR      r0,[sp,#0]
;;;201    		HW_EscWriteWord(data, 0x510);		
000076  2202              MOVS     r2,#2
000078  f44f61a2          MOV      r1,#0x510
00007c  4668              MOV      r0,sp
00007e  f7fffffe          BL       HW_EscWrite
;;;202    		
;;;203    		//Enable PDI access to MII management
;;;204    		data = 0x00;
000082  2000              MOVS     r0,#0
000084  9000              STR      r0,[sp,#0]
;;;205    		HW_EscWriteWord(data, 0x517);
000086  2202              MOVS     r2,#2
000088  f2405117          MOV      r1,#0x517
00008c  4668              MOV      r0,sp
00008e  f7fffffe          BL       HW_EscWrite
;;;206    				
;;;207        //IRQ enable,IRQ polarity, IRQ buffer type in Interrupt Configuration register.
;;;208        //Wrte 0x54 - 0x00000101
;;;209        data = 0x00000101;
000092  f2401001          MOV      r0,#0x101
000096  9000              STR      r0,[sp,#0]
;;;210        PDIWriteLAN9252DirectReg(data, LAN9252_CSR_INT_CONF);
000098  2154              MOVS     r1,#0x54
00009a  9800              LDR      r0,[sp,#0]
00009c  f7fffffe          BL       PDIWriteLAN9252DirectReg
;;;211        
;;;212        //Write in Interrupt Enable register -->
;;;213        //Write 0x5c - 0x00000001
;;;214        data = 0x00000001;
0000a0  2001              MOVS     r0,#1
0000a2  9000              STR      r0,[sp,#0]
;;;215        PDIWriteLAN9252DirectReg(data, LAN9252_CSR_INT_EN);
0000a4  215c              MOVS     r1,#0x5c
0000a6  9800              LDR      r0,[sp,#0]
0000a8  f7fffffe          BL       PDIWriteLAN9252DirectReg
;;;216    
;;;217        //Read Interrupt Status register
;;;218        data = PDIReadLAN9252DirectReg(LAN9252_CSR_INT_STS);
0000ac  2058              MOVS     r0,#0x58
0000ae  f7fffffe          BL       PDIReadLAN9252DirectReg
0000b2  9000              STR      r0,[sp,#0]
;;;219    
;;;220    
;;;221    #ifdef DC_SUPPORTED
;;;222        PDI_Init_SYNC_Interrupts();
0000b4  f7fffffe          BL       PDI_Init_SYNC_Interrupts
;;;223    #endif
;;;224    
;;;225        PDI_Timer_Interrupt();    
0000b8  f7fffffe          BL       PDI_Timer_Interrupt
;;;226        HW_ResetALEventMask(0);
0000bc  2000              MOVS     r0,#0
0000be  f7fffffe          BL       HW_ResetALEventMask
;;;227        PDI_IRQ_Interrupt();
0000c2  f7fffffe          BL       PDI_IRQ_Interrupt
;;;228        
;;;229        /* enable all interrupts */
;;;230        PDI_Enable_Global_interrupt();
0000c6  f7fffffe          BL       PDI_Enable_Global_interrupt
;;;231       
;;;232        return 0;
0000ca  2000              MOVS     r0,#0
;;;233    
;;;234    }
0000cc  bd1c              POP      {r2-r4,pc}
;;;235    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L15.208|
                          DCD      0x87654321

                          AREA ||.data||, DATA, ALIGN=2

                  restore_intsts
                          DCD      0x00000000
                  EscALEvent
000004  0000              DCB      0x00,0x00
                  nAlEventMask
000006  0000              DCB      0x00,0x00
                  TmpSyncMan
                          %        8

;*** Start embedded assembler ***

#line 1 "etherCAT\\9252_HW.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_9252_HW_c_5e2a7c30____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_9252_HW_c_5e2a7c30____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_9252_HW_c_5e2a7c30____REVSH|
#line 402
|__asm___9_9252_HW_c_5e2a7c30____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_9252_HW_c_5e2a7c30____RRX|
#line 587
|__asm___9_9252_HW_c_5e2a7c30____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
