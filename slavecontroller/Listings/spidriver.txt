; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\spidriver.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spidriver.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\spidriver.crf etherCAT\SPIDriver.c]
                          THUMB

                          AREA ||i.CSHIGH||, CODE, READONLY, ALIGN=2

                  CSHIGH PROC
;;;513    
;;;514    void CSHIGH(void)
000000  4808              LDR      r0,|L1.36|
;;;515    {
;;;516    	 //atomic
;;;517    	 GPIOG->ODR |= ((uint32_t)1u << 4u);
000002  6800              LDR      r0,[r0,#0]
000004  f0400010          ORR      r0,r0,#0x10
000008  4906              LDR      r1,|L1.36|
00000a  6008              STR      r0,[r1,#0]
;;;518    	 EcatHspiPtr->Instance->CR1 |= 0x0010;
00000c  4806              LDR      r0,|L1.40|
00000e  6800              LDR      r0,[r0,#0]  ; EcatHspiPtr
000010  6800              LDR      r0,[r0,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0400010          ORR      r0,r0,#0x10
000018  4903              LDR      r1,|L1.40|
00001a  6809              LDR      r1,[r1,#0]  ; EcatHspiPtr
00001c  6809              LDR      r1,[r1,#0]
00001e  6008              STR      r0,[r1,#0]
;;;519    }
000020  4770              BX       lr
;;;520    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x40021814
                  |L1.40|
                          DCD      EcatHspiPtr

                          AREA ||i.CSLOW||, CODE, READONLY, ALIGN=2

                  CSLOW PROC
;;;520    
;;;521    void CSLOW(void)
000000  4809              LDR      r0,|L2.40|
;;;522    {
;;;523    	 //atomic
;;;524    	 GPIOG->ODR &= 0xffefu;
000002  6800              LDR      r0,[r0,#0]
000004  f64f71ef          MOV      r1,#0xffef
000008  4008              ANDS     r0,r0,r1
00000a  4907              LDR      r1,|L2.40|
00000c  6008              STR      r0,[r1,#0]
;;;525    	 EcatHspiPtr->Instance->CR1 &= 0xffefu;
00000e  4807              LDR      r0,|L2.44|
000010  6800              LDR      r0,[r0,#0]  ; EcatHspiPtr
000012  6800              LDR      r0,[r0,#0]
000014  6800              LDR      r0,[r0,#0]
000016  f64f71ef          MOV      r1,#0xffef
00001a  4008              ANDS     r0,r0,r1
00001c  4903              LDR      r1,|L2.44|
00001e  6809              LDR      r1,[r1,#0]  ; EcatHspiPtr
000020  6809              LDR      r1,[r1,#0]
000022  6008              STR      r0,[r1,#0]
;;;526    }
000024  4770              BX       lr
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x40021814
                  |L2.44|
                          DCD      EcatHspiPtr

                          AREA ||i.PDIReadLAN9252DirectReg||, CODE, READONLY, ALIGN=1

                  PDIReadLAN9252DirectReg PROC
;;;494    *****************************************************************************/
;;;495    UINT32 PDIReadLAN9252DirectReg( UINT16 Address)
000000  b570              PUSH     {r4-r6,lr}
;;;496    {   
000002  4604              MOV      r4,r0
;;;497        UINT32 data;
;;;498        data = SPIReadDWord (Address);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SPIReadDWord
00000a  4605              MOV      r5,r0
;;;499        return data;
00000c  4628              MOV      r0,r5
;;;500    }
00000e  bd70              POP      {r4-r6,pc}
;;;501    
                          ENDP


                          AREA ||i.PDIReadReg||, CODE, READONLY, ALIGN=1

                  PDIReadReg PROC
;;;454    *****************************************************************************/
;;;455    void PDIReadReg(UINT8 *ReadBuffer, UINT16 Address, UINT16 Count)
000000  b570              PUSH     {r4-r6,lr}
;;;456    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;457        if (Address >= 0x1000)
000008  f5b45f80          CMP      r4,#0x1000
00000c  db05              BLT      |L4.26|
;;;458        {
;;;459             SPIReadPDRamRegister(ReadBuffer, Address,Count);
00000e  462a              MOV      r2,r5
000010  4621              MOV      r1,r4
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       SPIReadPDRamRegister
000018  e004              B        |L4.36|
                  |L4.26|
;;;460        }
;;;461        else
;;;462        {
;;;463             SPIReadRegUsingCSR(ReadBuffer, Address,Count);
00001a  b2ea              UXTB     r2,r5
00001c  4621              MOV      r1,r4
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       SPIReadRegUsingCSR
                  |L4.36|
;;;464        }
;;;465    }
000024  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP


                          AREA ||i.PDIWriteLAN9252DirectReg||, CODE, READONLY, ALIGN=1

                  PDIWriteLAN9252DirectReg PROC
;;;508    *****************************************************************************/
;;;509    void PDIWriteLAN9252DirectReg( UINT32 Val, UINT16 Address)
000000  b570              PUSH     {r4-r6,lr}
;;;510    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;511        SPIWriteDWord (Address, Val);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       SPIWriteDWord
;;;512    }
00000e  bd70              POP      {r4-r6,pc}
;;;513    
                          ENDP


                          AREA ||i.PDIWriteReg||, CODE, READONLY, ALIGN=1

                  PDIWriteReg PROC
;;;473    *****************************************************************************/
;;;474    void PDIWriteReg( UINT8 *WriteBuffer, UINT16 Address, UINT16 Count)
000000  b570              PUSH     {r4-r6,lr}
;;;475    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;476       
;;;477       if (Address >= 0x1000)
000008  f5b45f80          CMP      r4,#0x1000
00000c  db05              BLT      |L6.26|
;;;478       {
;;;479    		SPIWritePDRamRegister(WriteBuffer, Address,Count);
00000e  462a              MOV      r2,r5
000010  4621              MOV      r1,r4
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       SPIWritePDRamRegister
000018  e004              B        |L6.36|
                  |L6.26|
;;;480       }
;;;481       else
;;;482       {
;;;483    		SPIWriteRegUsingCSR(WriteBuffer, Address,Count);
00001a  b2ea              UXTB     r2,r5
00001c  4621              MOV      r1,r4
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       SPIWriteRegUsingCSR
                  |L6.36|
;;;484       }
;;;485        
;;;486    }
000024  bd70              POP      {r4-r6,pc}
;;;487    
                          ENDP


                          AREA ||i.SPIReadDWord||, CODE, READONLY, ALIGN=2

                  SPIReadDWord PROC
;;;61     *****************************************************************************/
;;;62     UINT32 SPIReadDWord (UINT16 Address)
000000  b53e              PUSH     {r1-r5,lr}
;;;63     {
000002  4605              MOV      r5,r0
;;;64         UINT32_VAL dwResult;
;;;65         UINT16_VAL wAddr;
;;;66     		UINT8 i;
;;;67     	
;;;68         wAddr.Val  = Address;
000004  9501              STR      r5,[sp,#4]
;;;69         //buffer Clear
;;;70         for (i=0;i<8u;i++)
000006  2400              MOVS     r4,#0
000008  e006              B        |L7.24|
                  |L7.10|
;;;71         {
;;;72             EcatSpiReadBuffer[i] = 0u;
00000a  2000              MOVS     r0,#0
00000c  4912              LDR      r1,|L7.88|
00000e  5508              STRB     r0,[r1,r4]
;;;73             EcatSpiWriteBuffer[i] = 0u;
000010  4912              LDR      r1,|L7.92|
000012  5508              STRB     r0,[r1,r4]
000014  1c60              ADDS     r0,r4,#1              ;70
000016  b2c4              UXTB     r4,r0                 ;70
                  |L7.24|
000018  2c08              CMP      r4,#8                 ;70
00001a  d3f6              BCC      |L7.10|
;;;74         }
;;;75     		//Write buffer update
;;;76         //Write Command
;;;77         EcatSpiWriteBuffer[0u] = (uint8_t)CMD_FAST_READ;
00001c  200b              MOVS     r0,#0xb
00001e  490f              LDR      r1,|L7.92|
000020  7008              STRB     r0,[r1,#0]
;;;78         EcatSpiWriteBuffer[1u] = wAddr.byte.HB;
000022  f89d0005          LDRB     r0,[sp,#5]
000026  7048              STRB     r0,[r1,#1]
;;;79         EcatSpiWriteBuffer[2u] = wAddr.byte.LB;
000028  f89d0004          LDRB     r0,[sp,#4]
00002c  7088              STRB     r0,[r1,#2]
;;;80         EcatSpiWriteBuffer[3u] = (uint8_t)CMD_FAST_READ_DUMMY;
00002e  2001              MOVS     r0,#1
000030  70c8              STRB     r0,[r1,#3]
;;;81     
;;;82     //		HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_RESET);
;;;83     		CSLOW();
000032  f7fffffe          BL       CSLOW
;;;84         HAL_SPI_TransmitReceive(EcatHspiPtr, EcatSpiWriteBuffer, EcatSpiReadBuffer, 8u, ECAT_SPI_TIMEOUT);
000036  f44f60fa          MOV      r0,#0x7d0
00003a  2308              MOVS     r3,#8
00003c  4a06              LDR      r2,|L7.88|
00003e  4907              LDR      r1,|L7.92|
000040  9000              STR      r0,[sp,#0]
000042  4807              LDR      r0,|L7.96|
000044  6800              LDR      r0,[r0,#0]  ; EcatHspiPtr
000046  f7fffffe          BL       HAL_SPI_TransmitReceive
;;;85     		CSHIGH();
00004a  f7fffffe          BL       CSHIGH
;;;86     //		__HAL_SPI_DISABLE(EcatHspiPtr);
;;;87     //		HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_SET);
;;;88     
;;;89     	  dwResult.Val = *((UINT32 *)(&EcatSpiReadBuffer[4u]));
00004e  4802              LDR      r0,|L7.88|
000050  6840              LDR      r0,[r0,#4]  ; EcatSpiReadBuffer
000052  9002              STR      r0,[sp,#8]
;;;90     
;;;91         return dwResult.Val;
000054  9802              LDR      r0,[sp,#8]
;;;92     }
000056  bd3e              POP      {r1-r5,pc}
;;;93     
                          ENDP

                  |L7.88|
                          DCD      EcatSpiReadBuffer
                  |L7.92|
                          DCD      EcatSpiWriteBuffer
                  |L7.96|
                          DCD      EcatHspiPtr

                          AREA ||i.SPIReadPDRamRegister||, CODE, READONLY, ALIGN=2

                  SPIReadPDRamRegister PROC
;;;264    *****************************************************************************/
;;;265    void SPIReadPDRamRegister(UINT8 *ReadBuffer, UINT16 Address, UINT16 Count)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;266    {
000004  b087              SUB      sp,sp,#0x1c
000006  4682              MOV      r10,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
;;;267        UINT64_VAL param32_1 = {0};
00000c  2000              MOVS     r0,#0
00000e  9004              STR      r0,[sp,#0x10]
000010  9005              STR      r0,[sp,#0x14]
;;;268        UINT8 i = 0,nlength, nBytePosition;
000012  2500              MOVS     r5,#0
;;;269        UINT8 nReadSpaceAvblCount;
;;;270        UINT16 RefAddr = Address;
000014  9602              STR      r6,[sp,#8]
;;;271        UINT16_VAL wAddr;
;;;272        UINT16 j;
;;;273    		UINT16 size;
;;;274    		
;;;275    	/*Reset/Abort any previous commands.*/
;;;276        param32_1.Val = PRAM_RW_ABORT_MASK;                                                 
000016  f04f4080          MOV      r0,#0x40000000
00001a  2100              MOVS     r1,#0
00001c  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;277    
;;;278        SPIWriteDWord (PRAM_READ_CMD_REG, param32_1.Val);
000020  f44f7043          MOV      r0,#0x30c
000024  9904              LDR      r1,[sp,#0x10]
000026  f7fffffe          BL       SPIWriteDWord
;;;279    
;;;280        /*The host should not modify this field unless the PRAM Read Busy
;;;281        (PRAM_READ_BUSY) bit is a 0.*/
;;;282    	do
00002a  bf00              NOP      
                  |L8.44|
;;;283        {
;;;284            param32_1.Val = SPIReadDWord (PRAM_READ_CMD_REG);
00002c  f44f7043          MOV      r0,#0x30c
000030  f7fffffe          BL       SPIReadDWord
000034  2100              MOVS     r1,#0
000036  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;285    
;;;286        }while((param32_1.v[3] & PRAM_RW_BUSY_8B));
00003a  f89d0013          LDRB     r0,[sp,#0x13]
00003e  f0000080          AND      r0,r0,#0x80
000042  2800              CMP      r0,#0
000044  d1f2              BNE      |L8.44|
;;;287        
;;;288        /*Write Address and Length Register (PRAM_READ_ADDR_LEN) with the
;;;289        starting UINT8 address and length) and Set PRAM Read Busy (PRAM_READ_BUSY) bit(-EtherCAT Process RAM Read Command Register)
;;;290        to start read operatrion*/
;;;291    	param32_1.w[0] = Address;
000046  f8ad6010          STRH     r6,[sp,#0x10]
;;;292        param32_1.w[1] = Count;
00004a  f8ad4012          STRH     r4,[sp,#0x12]
;;;293        param32_1.w[2] = 0x0;
00004e  f8ad0014          STRH     r0,[sp,#0x14]
;;;294        param32_1.w[3] = 0x8000;
000052  f44f4000          MOV      r0,#0x8000
000056  f8ad0016          STRH     r0,[sp,#0x16]
;;;295        
;;;296    	SPIWriteBytes (PRAM_READ_ADDR_LEN_REG, (UINT8*)&param32_1.Val,8);   
00005a  2208              MOVS     r2,#8
00005c  a904              ADD      r1,sp,#0x10
00005e  f44f7042          MOV      r0,#0x308
000062  f7fffffe          BL       SPIWriteBytes
;;;297    
;;;298        /*Read PRAM Read Data Available (PRAM_READ_AVAIL) bit is set*/
;;;299        do
000066  bf00              NOP      
                  |L8.104|
;;;300        {
;;;301            param32_1.Val = SPIReadDWord (PRAM_READ_CMD_REG);
000068  f44f7043          MOV      r0,#0x30c
00006c  f7fffffe          BL       SPIReadDWord
000070  2100              MOVS     r1,#0
000072  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;302    
;;;303        }while(!(param32_1.v[0] & IS_PRAM_SPACE_AVBL_MASK));
000076  f89d0010          LDRB     r0,[sp,#0x10]
00007a  f0000001          AND      r0,r0,#1
00007e  2800              CMP      r0,#0
000080  d0f2              BEQ      |L8.104|
;;;304    
;;;305        nReadSpaceAvblCount = param32_1.v[1] & PRAM_SPACE_AVBL_COUNT_MASK;
000082  f89d0011          LDRB     r0,[sp,#0x11]
000086  f000001f          AND      r0,r0,#0x1f
00008a  9003              STR      r0,[sp,#0xc]
;;;306    
;;;307        /*Fifo registers are aliased address. In indexed it will read indexed data reg 0x04, but it will point to reg 0
;;;308         In other modes read 0x04 FIFO register since all registers are aliased*/
;;;309    
;;;310        /*get the UINT8 lenth for first read*/
;;;311        //Auto increment is supported in SPIO
;;;312        param32_1.Val = SPIReadDWord (PRAM_READ_FIFO_REG);
00008c  2004              MOVS     r0,#4
00008e  f7fffffe          BL       SPIReadDWord
000092  2100              MOVS     r1,#0
000094  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;313        nReadSpaceAvblCount--;
000098  9803              LDR      r0,[sp,#0xc]
00009a  1e40              SUBS     r0,r0,#1
00009c  b2c0              UXTB     r0,r0
00009e  9003              STR      r0,[sp,#0xc]
;;;314        nBytePosition = (Address & 0x03);
0000a0  f0060803          AND      r8,r6,#3
;;;315        nlength = (4-nBytePosition) > Count ? Count:(4-nBytePosition);
0000a4  f1c80004          RSB      r0,r8,#4
0000a8  42a0              CMP      r0,r4
0000aa  dd01              BLE      |L8.176|
0000ac  4620              MOV      r0,r4
0000ae  e001              B        |L8.180|
                  |L8.176|
0000b0  f1c80004          RSB      r0,r8,#4
                  |L8.180|
0000b4  b2c7              UXTB     r7,r0
;;;316        memcpy(ReadBuffer+i ,&param32_1.v[nBytePosition],nlength);
0000b6  aa04              ADD      r2,sp,#0x10
0000b8  eb020108          ADD      r1,r2,r8
0000bc  eb0a0005          ADD      r0,r10,r5
0000c0  463a              MOV      r2,r7
0000c2  f7fffffe          BL       __aeabi_memcpy
;;;317        Count-=nlength;
0000c6  1be0              SUBS     r0,r4,r7
0000c8  b284              UXTH     r4,r0
;;;318        i+=nlength;
0000ca  19e8              ADDS     r0,r5,r7
0000cc  b2c5              UXTB     r5,r0
;;;319    
;;;320        wAddr.Val  = PRAM_READ_FIFO_REG;
0000ce  2004              MOVS     r0,#4
0000d0  9001              STR      r0,[sp,#4]
;;;321        size = Count + 4u;
0000d2  1d20              ADDS     r0,r4,#4
0000d4  fa1ff980          UXTH     r9,r0
;;;322    
;;;323        if (size > (uint32_t)SPI_BUFFER_SIZE)
0000d8  f5b97f00          CMP      r9,#0x200
0000dc  d82d              BHI      |L8.314|
;;;324        {
;;;325            //Size overflow
;;;326        }
;;;327        else
;;;328        {
;;;329            //buffer Clear
;;;330            for (j=0;j<size;j++)
0000de  f04f0b00          MOV      r11,#0
0000e2  e008              B        |L8.246|
                  |L8.228|
;;;331            {
;;;332    						EcatSpiReadBuffer[i] = 0u;
0000e4  2000              MOVS     r0,#0
0000e6  4916              LDR      r1,|L8.320|
0000e8  5548              STRB     r0,[r1,r5]
;;;333    						EcatSpiWriteBuffer[i] = 0u;
0000ea  4916              LDR      r1,|L8.324|
0000ec  5548              STRB     r0,[r1,r5]
0000ee  f10b0001          ADD      r0,r11,#1             ;330
0000f2  fa1ffb80          UXTH     r11,r0                ;330
                  |L8.246|
0000f6  45cb              CMP      r11,r9                ;330
0000f8  dbf4              BLT      |L8.228|
;;;334            }
;;;335            //Write buffer update
;;;336            //Write Command
;;;337            EcatSpiWriteBuffer[0u] = (uint8_t)CMD_FAST_READ;
0000fa  200b              MOVS     r0,#0xb
0000fc  4911              LDR      r1,|L8.324|
0000fe  7008              STRB     r0,[r1,#0]
;;;338            EcatSpiWriteBuffer[1u] = wAddr.byte.HB;
000100  f89d0005          LDRB     r0,[sp,#5]
000104  7048              STRB     r0,[r1,#1]
;;;339            EcatSpiWriteBuffer[2u] = wAddr.byte.LB;
000106  f89d0004          LDRB     r0,[sp,#4]
00010a  7088              STRB     r0,[r1,#2]
;;;340            EcatSpiWriteBuffer[3u] = (uint8_t)CMD_FAST_READ_DUMMY;
00010c  2001              MOVS     r0,#1
00010e  70c8              STRB     r0,[r1,#3]
;;;341    
;;;342    //				HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_RESET);
;;;343    				CSLOW();
000110  f7fffffe          BL       CSLOW
;;;344    				HAL_SPI_TransmitReceive(EcatHspiPtr, EcatSpiWriteBuffer, EcatSpiReadBuffer, size, ECAT_SPI_TIMEOUT);
000114  f44f60fa          MOV      r0,#0x7d0
000118  464b              MOV      r3,r9
00011a  4a09              LDR      r2,|L8.320|
00011c  4909              LDR      r1,|L8.324|
00011e  9000              STR      r0,[sp,#0]
000120  4809              LDR      r0,|L8.328|
000122  6800              LDR      r0,[r0,#0]  ; EcatHspiPtr
000124  f7fffffe          BL       HAL_SPI_TransmitReceive
;;;345    				CSHIGH();
000128  f7fffffe          BL       CSHIGH
;;;346    				//__HAL_SPI_DISABLE(EcatHspiPtr);
;;;347    //				HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_SET);
;;;348    				
;;;349            memcpy((ReadBuffer+i) ,&(EcatSpiReadBuffer[4u]),Count);
00012c  eb0a0005          ADD      r0,r10,r5
000130  4622              MOV      r2,r4
000132  4903              LDR      r1,|L8.320|
000134  1d09              ADDS     r1,r1,#4
000136  f7fffffe          BL       __aeabi_memcpy
                  |L8.314|
;;;350        }
;;;351        return;
;;;352    }
00013a  b007              ADD      sp,sp,#0x1c
00013c  e8bd8ff0          POP      {r4-r11,pc}
;;;353            
                          ENDP

                  |L8.320|
                          DCD      EcatSpiReadBuffer
                  |L8.324|
                          DCD      EcatSpiWriteBuffer
                  |L8.328|
                          DCD      EcatHspiPtr

                          AREA ||i.SPIReadRegUsingCSR||, CODE, READONLY, ALIGN=1

                  SPIReadRegUsingCSR PROC
;;;192    *****************************************************************************/
;;;193    void SPIReadRegUsingCSR(UINT8 *ReadBuffer, UINT16 Address, UINT8 Count)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;194    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;195        UINT32_VAL param32_1 = {0};
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;196        UINT8 i = 0;
00000e  2400              MOVS     r4,#0
;;;197        UINT16_VAL wAddr;
;;;198        wAddr.Val = Address;
000010  9700              STR      r7,[sp,#0]
;;;199    
;;;200        param32_1.v[0] = wAddr.byte.LB;
000012  f89d0000          LDRB     r0,[sp,#0]
000016  f88d0004          STRB     r0,[sp,#4]
;;;201        param32_1.v[1] = wAddr.byte.HB;
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f88d0005          STRB     r0,[sp,#5]
;;;202        param32_1.v[2] = Count;
000022  f88d5006          STRB     r5,[sp,#6]
;;;203        param32_1.v[3] = ESC_READ_BYTE;
000026  20c0              MOVS     r0,#0xc0
000028  f88d0007          STRB     r0,[sp,#7]
;;;204    
;;;205        SPIWriteDWord (ESC_CSR_CMD_REG, param32_1.Val);
00002c  f44f7041          MOV      r0,#0x304
000030  9901              LDR      r1,[sp,#4]
000032  f7fffffe          BL       SPIWriteDWord
;;;206    
;;;207        do
000036  bf00              NOP      
                  |L9.56|
;;;208        {
;;;209            param32_1.Val = SPIReadDWord (ESC_CSR_CMD_REG);
000038  f44f7041          MOV      r0,#0x304
00003c  f7fffffe          BL       SPIReadDWord
000040  9001              STR      r0,[sp,#4]
;;;210    		
;;;211        }while(param32_1.v[3] & ESC_CSR_BUSY);
000042  f89d0007          LDRB     r0,[sp,#7]
000046  f0000080          AND      r0,r0,#0x80
00004a  2800              CMP      r0,#0
00004c  d1f4              BNE      |L9.56|
;;;212    
;;;213        param32_1.Val = SPIReadDWord (ESC_CSR_DATA_REG);
00004e  f44f7040          MOV      r0,#0x300
000052  f7fffffe          BL       SPIReadDWord
000056  9001              STR      r0,[sp,#4]
;;;214    
;;;215        
;;;216        for(i=0;i<Count;i++)
000058  2400              MOVS     r4,#0
00005a  e004              B        |L9.102|
                  |L9.92|
;;;217             ReadBuffer[i] = param32_1.v[i];
00005c  a801              ADD      r0,sp,#4
00005e  5d00              LDRB     r0,[r0,r4]
000060  5530              STRB     r0,[r6,r4]
000062  1c60              ADDS     r0,r4,#1              ;216
000064  b2c4              UXTB     r4,r0                 ;216
                  |L9.102|
000066  42ac              CMP      r4,r5                 ;216
000068  dbf8              BLT      |L9.92|
;;;218       
;;;219        return;
;;;220    }
00006a  e8bd81fc          POP      {r2-r8,pc}
;;;221    
                          ENDP


                          AREA ||i.SPIWriteBytes||, CODE, READONLY, ALIGN=2

                  SPIWriteBytes PROC
;;;101    *****************************************************************************/
;;;102    static void SPIWriteBytes(UINT16 Address, UINT8 *Val, UINT8 nLenght)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;103    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;104        UINT8 *dwData;
;;;105        UINT16_VAL wAddr;
;;;106    		UINT8 i;
;;;107    		UINT16 size;
;;;108    
;;;109    		wAddr.Val  = Address;
00000a  9601              STR      r6,[sp,#4]
;;;110        dwData = Val;
00000c  46b9              MOV      r9,r7
;;;111        size = nLenght + 3u;
00000e  f1080503          ADD      r5,r8,#3
;;;112    
;;;113        if (size > (uint32_t)SPI_BUFFER_SIZE)
000012  f5b57f00          CMP      r5,#0x200
000016  d829              BHI      |L10.108|
;;;114        {
;;;115            //Size overflow
;;;116        }
;;;117        else
;;;118        {
;;;119            //buffer Clear
;;;120            for (i=0;i<size;i++)
000018  2400              MOVS     r4,#0
00001a  e006              B        |L10.42|
                  |L10.28|
;;;121            {
;;;122    						EcatSpiReadBuffer[i] = 0u;
00001c  2000              MOVS     r0,#0
00001e  4914              LDR      r1,|L10.112|
000020  5508              STRB     r0,[r1,r4]
;;;123    						EcatSpiWriteBuffer[i] = 0u;
000022  4914              LDR      r1,|L10.116|
000024  5508              STRB     r0,[r1,r4]
000026  1c60              ADDS     r0,r4,#1              ;120
000028  b2c4              UXTB     r4,r0                 ;120
                  |L10.42|
00002a  42ac              CMP      r4,r5                 ;120
00002c  dbf6              BLT      |L10.28|
;;;124            }
;;;125            //Write buffer update
;;;126            //Write Command
;;;127            EcatSpiWriteBuffer[0u] = (uint8_t)CMD_SERIAL_WRITE;
00002e  2002              MOVS     r0,#2
000030  4910              LDR      r1,|L10.116|
000032  7008              STRB     r0,[r1,#0]
;;;128            EcatSpiWriteBuffer[1u] = (wAddr.byte.HB|(uint8_t)ADDRESS_AUTO_INCREMENT);
000034  f89d0005          LDRB     r0,[sp,#5]
000038  f0400040          ORR      r0,r0,#0x40
00003c  7048              STRB     r0,[r1,#1]
;;;129            EcatSpiWriteBuffer[2u] = wAddr.byte.LB;
00003e  f89d0004          LDRB     r0,[sp,#4]
000042  7088              STRB     r0,[r1,#2]
;;;130            memcpy(&EcatSpiWriteBuffer[3u], dwData, nLenght);
000044  4642              MOV      r2,r8
000046  4649              MOV      r1,r9
000048  480a              LDR      r0,|L10.116|
00004a  1cc0              ADDS     r0,r0,#3
00004c  f7fffffe          BL       __aeabi_memcpy
;;;131    				
;;;132    //				HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_RESET);
;;;133    				CSLOW();
000050  f7fffffe          BL       CSLOW
;;;134    				HAL_SPI_TransmitReceive(EcatHspiPtr, EcatSpiWriteBuffer, EcatSpiReadBuffer, size, ECAT_SPI_TIMEOUT);
000054  f44f60fa          MOV      r0,#0x7d0
000058  462b              MOV      r3,r5
00005a  4a05              LDR      r2,|L10.112|
00005c  4905              LDR      r1,|L10.116|
00005e  9000              STR      r0,[sp,#0]
000060  4805              LDR      r0,|L10.120|
000062  6800              LDR      r0,[r0,#0]  ; EcatHspiPtr
000064  f7fffffe          BL       HAL_SPI_TransmitReceive
;;;135    				CSHIGH();
000068  f7fffffe          BL       CSHIGH
                  |L10.108|
;;;136    //				__HAL_SPI_DISABLE(EcatHspiPtr);
;;;137    //				HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_SET);
;;;138        }
;;;139    }
00006c  e8bd87fc          POP      {r2-r10,pc}
;;;140    
                          ENDP

                  |L10.112|
                          DCD      EcatSpiReadBuffer
                  |L10.116|
                          DCD      EcatSpiWriteBuffer
                  |L10.120|
                          DCD      EcatHspiPtr

                          AREA ||i.SPIWriteDWord||, CODE, READONLY, ALIGN=2

                  SPIWriteDWord PROC
;;;147    *****************************************************************************/
;;;148    void SPIWriteDWord (UINT16 Address, UINT32 Val)
000000  b5fe              PUSH     {r1-r7,lr}
;;;149    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;150        UINT32_VAL dwData;
;;;151        UINT16_VAL wAddr;
;;;152    	  UINT16 i;
;;;153    		UINT16 size;
;;;154    		
;;;155        wAddr.Val  = Address;
000006  9501              STR      r5,[sp,#4]
;;;156        dwData.Val = Val;
000008  9602              STR      r6,[sp,#8]
;;;157    		size = 7u;
00000a  2707              MOVS     r7,#7
;;;158    
;;;159        //buffer Clear
;;;160        for (i=0;i<size;i++)
00000c  2400              MOVS     r4,#0
00000e  e006              B        |L11.30|
                  |L11.16|
;;;161        {
;;;162    				EcatSpiReadBuffer[i] = 0u;
000010  2000              MOVS     r0,#0
000012  4916              LDR      r1,|L11.108|
000014  5508              STRB     r0,[r1,r4]
;;;163    				EcatSpiWriteBuffer[i] = 0u;
000016  4916              LDR      r1,|L11.112|
000018  5508              STRB     r0,[r1,r4]
00001a  1c60              ADDS     r0,r4,#1              ;160
00001c  b284              UXTH     r4,r0                 ;160
                  |L11.30|
00001e  42bc              CMP      r4,r7                 ;160
000020  dbf6              BLT      |L11.16|
;;;164        }
;;;165    
;;;166        //Write buffer update
;;;167        //Write Command
;;;168        EcatSpiWriteBuffer[0u] = (uint8_t)CMD_SERIAL_WRITE;
000022  2002              MOVS     r0,#2
000024  4912              LDR      r1,|L11.112|
000026  7008              STRB     r0,[r1,#0]
;;;169        //Write Address
;;;170        EcatSpiWriteBuffer[1u] = wAddr.byte.HB;
000028  f89d0005          LDRB     r0,[sp,#5]
00002c  7048              STRB     r0,[r1,#1]
;;;171        EcatSpiWriteBuffer[2u] = wAddr.byte.LB;
00002e  f89d0004          LDRB     r0,[sp,#4]
000032  7088              STRB     r0,[r1,#2]
;;;172        //Write Bytes
;;;173        EcatSpiWriteBuffer[3u] = dwData.byte.LB;
000034  f89d0008          LDRB     r0,[sp,#8]
000038  70c8              STRB     r0,[r1,#3]
;;;174        EcatSpiWriteBuffer[4u] = dwData.byte.HB;
00003a  f89d0009          LDRB     r0,[sp,#9]
00003e  7108              STRB     r0,[r1,#4]
;;;175        EcatSpiWriteBuffer[5u] = dwData.byte.UB;
000040  f89d000a          LDRB     r0,[sp,#0xa]
000044  7148              STRB     r0,[r1,#5]
;;;176        EcatSpiWriteBuffer[6u] = dwData.byte.MB;
000046  f89d000b          LDRB     r0,[sp,#0xb]
00004a  7188              STRB     r0,[r1,#6]
;;;177    
;;;178    //		HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_RESET);
;;;179    		CSLOW();
00004c  f7fffffe          BL       CSLOW
;;;180        HAL_SPI_TransmitReceive(EcatHspiPtr, EcatSpiWriteBuffer, EcatSpiReadBuffer, size, ECAT_SPI_TIMEOUT);
000050  f44f60fa          MOV      r0,#0x7d0
000054  463b              MOV      r3,r7
000056  4a05              LDR      r2,|L11.108|
000058  4905              LDR      r1,|L11.112|
00005a  9000              STR      r0,[sp,#0]
00005c  4805              LDR      r0,|L11.116|
00005e  6800              LDR      r0,[r0,#0]  ; EcatHspiPtr
000060  f7fffffe          BL       HAL_SPI_TransmitReceive
;;;181    		CSHIGH();
000064  f7fffffe          BL       CSHIGH
;;;182    		//__HAL_SPI_DISABLE(EcatHspiPtr);
;;;183    //		HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_SET);
;;;184    }
000068  bdfe              POP      {r1-r7,pc}
;;;185    
                          ENDP

00006a  0000              DCW      0x0000
                  |L11.108|
                          DCD      EcatSpiReadBuffer
                  |L11.112|
                          DCD      EcatSpiWriteBuffer
                  |L11.116|
                          DCD      EcatHspiPtr

                          AREA ||i.SPIWritePDRamRegister||, CODE, READONLY, ALIGN=2

                  SPIWritePDRamRegister PROC
;;;360    *****************************************************************************/
;;;361    void SPIWritePDRamRegister(UINT8 *WriteBuffer, UINT16 Address, UINT16 Count)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;362    {
000004  b087              SUB      sp,sp,#0x1c
000006  4681              MOV      r9,r0
000008  468a              MOV      r10,r1
00000a  4614              MOV      r4,r2
;;;363        UINT64_VAL param32_1 = {0};
00000c  2000              MOVS     r0,#0
00000e  9004              STR      r0,[sp,#0x10]
000010  9005              STR      r0,[sp,#0x14]
;;;364        UINT8 i = 0,nlength, nBytePosition,nWrtSpcAvlCount;
000012  2500              MOVS     r5,#0
;;;365        UINT16_VAL wAddr;
;;;366        UINT16 j;
;;;367        UINT16 size;
;;;368        /*Reset or Abort any previous commands.*/
;;;369        param32_1.Val = PRAM_RW_ABORT_MASK;                                                
000014  f04f4180          MOV      r1,#0x40000000
000018  e9cd1004          STRD     r1,r0,[sp,#0x10]
;;;370    
;;;371        SPIWriteDWord (PRAM_WRITE_CMD_REG, param32_1.Val);
00001c  f44f7045          MOV      r0,#0x314
000020  9904              LDR      r1,[sp,#0x10]
000022  f7fffffe          BL       SPIWriteDWord
;;;372    
;;;373        /*Make sure there is no previous write is pending
;;;374        (PRAM Write Busy) bit is a 0 */
;;;375        do
000026  bf00              NOP      
                  |L12.40|
;;;376        {
;;;377            param32_1.Val = SPIReadDWord (PRAM_WRITE_CMD_REG);
000028  f44f7045          MOV      r0,#0x314
00002c  f7fffffe          BL       SPIReadDWord
000030  2100              MOVS     r1,#0
000032  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;378    
;;;379        }while((param32_1.v[3] & PRAM_RW_BUSY_8B));
000036  f89d0013          LDRB     r0,[sp,#0x13]
00003a  f0000080          AND      r0,r0,#0x80
00003e  2800              CMP      r0,#0
000040  d1f2              BNE      |L12.40|
;;;380    
;;;381        /*Write Address and Length Register (ECAT_PRAM_WR_ADDR_LEN) with the
;;;382        starting UINT8 address and length) and write to the EtherCAT Process RAM Write Command Register (ECAT_PRAM_WR_CMD) with the  PRAM Write Busy
;;;383        (PRAM_WRITE_BUSY) bit set*/
;;;384    	param32_1.w[0] = Address;
000042  f8ada010          STRH     r10,[sp,#0x10]
;;;385        param32_1.w[1] = Count;
000046  f8ad4012          STRH     r4,[sp,#0x12]
;;;386        param32_1.w[2] = 0x0;
00004a  f8ad0014          STRH     r0,[sp,#0x14]
;;;387        param32_1.w[3] = 0x8000;
00004e  f44f4000          MOV      r0,#0x8000
000052  f8ad0016          STRH     r0,[sp,#0x16]
;;;388        
;;;389       SPIWriteBytes (PRAM_WRITE_ADDR_LEN_REG, (UINT8*)&param32_1.Val,8);
000056  2208              MOVS     r2,#8
000058  a904              ADD      r1,sp,#0x10
00005a  f44f7044          MOV      r0,#0x310
00005e  f7fffffe          BL       SPIWriteBytes
;;;390    
;;;391       /*Read PRAM write Data Available (PRAM_READ_AVAIL) bit is set*/
;;;392    	do
000062  bf00              NOP      
                  |L12.100|
;;;393        {
;;;394           param32_1.Val = SPIReadDWord (PRAM_WRITE_CMD_REG);
000064  f44f7045          MOV      r0,#0x314
000068  f7fffffe          BL       SPIReadDWord
00006c  2100              MOVS     r1,#0
00006e  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;395    
;;;396        }while(!(param32_1.v[0] & IS_PRAM_SPACE_AVBL_MASK));
000072  f89d0010          LDRB     r0,[sp,#0x10]
000076  f0000001          AND      r0,r0,#1
00007a  2800              CMP      r0,#0
00007c  d0f2              BEQ      |L12.100|
;;;397    
;;;398        /*Check write data available count*/
;;;399        nWrtSpcAvlCount = param32_1.v[1] & PRAM_SPACE_AVBL_COUNT_MASK;
00007e  f89d0011          LDRB     r0,[sp,#0x11]
000082  f000001f          AND      r0,r0,#0x1f
000086  9003              STR      r0,[sp,#0xc]
;;;400    
;;;401        /*Write data to Write FIFO) */ 
;;;402        /*get the byte lenth for first read*/
;;;403        nBytePosition = (Address & 0x03);
000088  f00a0703          AND      r7,r10,#3
;;;404    
;;;405        nlength = (4-nBytePosition) > Count ? Count:(4-nBytePosition);
00008c  f1c70004          RSB      r0,r7,#4
000090  42a0              CMP      r0,r4
000092  dd01              BLE      |L12.152|
000094  4620              MOV      r0,r4
000096  e001              B        |L12.156|
                  |L12.152|
000098  f1c70004          RSB      r0,r7,#4
                  |L12.156|
00009c  b2c6              UXTB     r6,r0
;;;406    
;;;407        param32_1.Val = 0;
00009e  2100              MOVS     r1,#0
0000a0  9104              STR      r1,[sp,#0x10]
0000a2  9105              STR      r1,[sp,#0x14]
;;;408        memcpy(&param32_1.v[nBytePosition],WriteBuffer+i, nlength);
0000a4  eb090105          ADD      r1,r9,r5
0000a8  aa04              ADD      r2,sp,#0x10
0000aa  19d0              ADDS     r0,r2,r7
0000ac  4632              MOV      r2,r6
0000ae  f7fffffe          BL       __aeabi_memcpy
;;;409    
;;;410        SPIWriteDWord (PRAM_WRITE_FIFO_REG,param32_1.Val);
0000b2  2020              MOVS     r0,#0x20
0000b4  9904              LDR      r1,[sp,#0x10]
0000b6  f7fffffe          BL       SPIWriteDWord
;;;411    
;;;412        nWrtSpcAvlCount--;
0000ba  9803              LDR      r0,[sp,#0xc]
0000bc  1e40              SUBS     r0,r0,#1
0000be  b2c0              UXTB     r0,r0
0000c0  9003              STR      r0,[sp,#0xc]
;;;413        Count-=nlength;
0000c2  1ba0              SUBS     r0,r4,r6
0000c4  b284              UXTH     r4,r0
;;;414        i+=nlength;
0000c6  19a8              ADDS     r0,r5,r6
0000c8  b2c5              UXTB     r5,r0
;;;415    		
;;;416        wAddr.Val  = PRAM_WRITE_FIFO_REG;
0000ca  2020              MOVS     r0,#0x20
0000cc  9002              STR      r0,[sp,#8]
;;;417        size = Count + 3u;
0000ce  1ce0              ADDS     r0,r4,#3
0000d0  fa1ff880          UXTH     r8,r0
;;;418    
;;;419        if (size > (uint32_t)SPI_BUFFER_SIZE)
0000d4  f5b87f00          CMP      r8,#0x200
0000d8  d82b              BHI      |L12.306|
;;;420        {
;;;421            //Size overflow
;;;422        }
;;;423        else
;;;424        {
;;;425            //buffer Clear
;;;426            for (j=0;j<size;j++)
0000da  f04f0b00          MOV      r11,#0
0000de  e008              B        |L12.242|
                  |L12.224|
;;;427            {
;;;428    						EcatSpiReadBuffer[i] = 0u;
0000e0  2000              MOVS     r0,#0
0000e2  4915              LDR      r1,|L12.312|
0000e4  5548              STRB     r0,[r1,r5]
;;;429    						EcatSpiWriteBuffer[i] = 0u;
0000e6  4915              LDR      r1,|L12.316|
0000e8  5548              STRB     r0,[r1,r5]
0000ea  f10b0001          ADD      r0,r11,#1             ;426
0000ee  fa1ffb80          UXTH     r11,r0                ;426
                  |L12.242|
0000f2  45c3              CMP      r11,r8                ;426
0000f4  dbf4              BLT      |L12.224|
;;;430            }
;;;431            //Write buffer update
;;;432            //Write Command
;;;433            EcatSpiWriteBuffer[0u] = (uint8_t)CMD_SERIAL_WRITE;
0000f6  2002              MOVS     r0,#2
0000f8  4910              LDR      r1,|L12.316|
0000fa  7008              STRB     r0,[r1,#0]
;;;434            EcatSpiWriteBuffer[1u] = wAddr.byte.HB;
0000fc  f89d0009          LDRB     r0,[sp,#9]
000100  7048              STRB     r0,[r1,#1]
;;;435            EcatSpiWriteBuffer[2u] = wAddr.byte.LB;
000102  f89d0008          LDRB     r0,[sp,#8]
000106  7088              STRB     r0,[r1,#2]
;;;436            memcpy(&EcatSpiWriteBuffer[3u], (WriteBuffer+i), Count);
000108  eb090105          ADD      r1,r9,r5
00010c  4622              MOV      r2,r4
00010e  480b              LDR      r0,|L12.316|
000110  1cc0              ADDS     r0,r0,#3
000112  f7fffffe          BL       __aeabi_memcpy
;;;437    
;;;438    //				HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_RESET);
;;;439    				CSLOW();
000116  f7fffffe          BL       CSLOW
;;;440            HAL_SPI_TransmitReceive(EcatHspiPtr, EcatSpiWriteBuffer, EcatSpiReadBuffer, size, ECAT_SPI_TIMEOUT);
00011a  f44f60fa          MOV      r0,#0x7d0
00011e  4643              MOV      r3,r8
000120  4a05              LDR      r2,|L12.312|
000122  4906              LDR      r1,|L12.316|
000124  9000              STR      r0,[sp,#0]
000126  4806              LDR      r0,|L12.320|
000128  6800              LDR      r0,[r0,#0]  ; EcatHspiPtr
00012a  f7fffffe          BL       HAL_SPI_TransmitReceive
;;;441    				CSHIGH();
00012e  f7fffffe          BL       CSHIGH
                  |L12.306|
;;;442    				//__HAL_SPI_DISABLE(EcatHspiPtr);
;;;443    //				HAL_GPIO_WritePin(GPIOG,4u,GPIO_PIN_SET);
;;;444        }
;;;445        return;
;;;446    }
000132  b007              ADD      sp,sp,#0x1c
000134  e8bd8ff0          POP      {r4-r11,pc}
;;;447    
                          ENDP

                  |L12.312|
                          DCD      EcatSpiReadBuffer
                  |L12.316|
                          DCD      EcatSpiWriteBuffer
                  |L12.320|
                          DCD      EcatHspiPtr

                          AREA ||i.SPIWriteRegUsingCSR||, CODE, READONLY, ALIGN=1

                  SPIWriteRegUsingCSR PROC
;;;228    *****************************************************************************/
;;;229    void SPIWriteRegUsingCSR( UINT8 *WriteBuffer, UINT16 Address, UINT8 Count)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;230    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;231        UINT32_VAL param32_1 = {0};
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;232        UINT8 i = 0;
00000e  2400              MOVS     r4,#0
;;;233        UINT16_VAL wAddr;
;;;234    
;;;235        for(i=0;i<Count;i++)
000010  bf00              NOP      
000012  e004              B        |L13.30|
                  |L13.20|
;;;236             param32_1.v[i] = WriteBuffer[i];
000014  5d30              LDRB     r0,[r6,r4]
000016  a901              ADD      r1,sp,#4
000018  5508              STRB     r0,[r1,r4]
00001a  1c60              ADDS     r0,r4,#1              ;235
00001c  b2c4              UXTB     r4,r0                 ;235
                  |L13.30|
00001e  42ac              CMP      r4,r5                 ;235
000020  dbf8              BLT      |L13.20|
;;;237    
;;;238        SPIWriteDWord (ESC_CSR_DATA_REG, param32_1.Val);
000022  f44f7040          MOV      r0,#0x300
000026  9901              LDR      r1,[sp,#4]
000028  f7fffffe          BL       SPIWriteDWord
;;;239    
;;;240    
;;;241        wAddr.Val = Address;
00002c  9700              STR      r7,[sp,#0]
;;;242    
;;;243        param32_1.v[0] = wAddr.byte.LB;
00002e  f89d0000          LDRB     r0,[sp,#0]
000032  f88d0004          STRB     r0,[sp,#4]
;;;244        param32_1.v[1] = wAddr.byte.HB;
000036  f89d0001          LDRB     r0,[sp,#1]
00003a  f88d0005          STRB     r0,[sp,#5]
;;;245        param32_1.v[2] = Count;
00003e  f88d5006          STRB     r5,[sp,#6]
;;;246        param32_1.v[3] = ESC_WRITE_BYTE;
000042  2080              MOVS     r0,#0x80
000044  f88d0007          STRB     r0,[sp,#7]
;;;247    
;;;248        SPIWriteDWord (0x304, param32_1.Val);
000048  f44f7041          MOV      r0,#0x304
00004c  9901              LDR      r1,[sp,#4]
00004e  f7fffffe          BL       SPIWriteDWord
;;;249        do
000052  bf00              NOP      
                  |L13.84|
;;;250        {
;;;251            param32_1.Val = SPIReadDWord (0x304);
000054  f44f7041          MOV      r0,#0x304
000058  f7fffffe          BL       SPIReadDWord
00005c  9001              STR      r0,[sp,#4]
;;;252    
;;;253        }while(param32_1.v[3] & ESC_CSR_BUSY);
00005e  f89d0007          LDRB     r0,[sp,#7]
000062  f0000080          AND      r0,r0,#0x80
000066  2800              CMP      r0,#0
000068  d1f4              BNE      |L13.84|
;;;254    
;;;255        return;
;;;256    }
00006a  e8bd81fc          POP      {r2-r8,pc}
;;;257    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  EcatSpiReadBuffer
                          %        512
                  EcatSpiWriteBuffer
                          %        512

                          AREA ||.data||, DATA, ALIGN=2

                  EcatHspiPtr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "etherCAT\\SPIDriver.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_SPIDriver_c_bfde8955____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_SPIDriver_c_bfde8955____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_SPIDriver_c_bfde8955____REVSH|
#line 402
|__asm___11_SPIDriver_c_bfde8955____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_SPIDriver_c_bfde8955____RRX|
#line 587
|__asm___11_SPIDriver_c_bfde8955____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
