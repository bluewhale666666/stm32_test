; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_hal_cortex.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hal_cortex.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\stm32f4xx_hal_cortex.crf D:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_cortex.c]
                          THUMB

                          AREA ||i.HAL_MPU_ConfigRegion||, CODE, READONLY, ALIGN=2

                  HAL_MPU_ConfigRegion PROC
;;;299      */
;;;300    void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
000000  7841              LDRB     r1,[r0,#1]
;;;301    {
;;;302      /* Check the parameters */
;;;303      assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
;;;304      assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
;;;305    
;;;306      /* Set the Region number */
;;;307      MPU->RNR = MPU_Init->Number;
000002  4a15              LDR      r2,|L1.88|
000004  6011              STR      r1,[r2,#0]
;;;308    
;;;309      if ((MPU_Init->Enable) != RESET)
000006  7801              LDRB     r1,[r0,#0]
000008  b1f9              CBZ      r1,|L1.74|
;;;310      {
;;;311        /* Check the parameters */
;;;312        assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
;;;313        assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
;;;314        assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
;;;315        assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
;;;316        assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
;;;317        assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
;;;318        assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
;;;319        assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
;;;320        
;;;321        MPU->RBAR = MPU_Init->BaseAddress;
00000a  1d12              ADDS     r2,r2,#4
00000c  6841              LDR      r1,[r0,#4]
00000e  6011              STR      r1,[r2,#0]
;;;322        MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
000010  7b01              LDRB     r1,[r0,#0xc]
000012  0709              LSLS     r1,r1,#28
000014  7ac2              LDRB     r2,[r0,#0xb]
000016  ea416102          ORR      r1,r1,r2,LSL #24
00001a  7a82              LDRB     r2,[r0,#0xa]
00001c  ea4141c2          ORR      r1,r1,r2,LSL #19
000020  7b42              LDRB     r2,[r0,#0xd]
000022  ea414182          ORR      r1,r1,r2,LSL #18
000026  7b82              LDRB     r2,[r0,#0xe]
000028  ea414142          ORR      r1,r1,r2,LSL #17
00002c  7bc2              LDRB     r2,[r0,#0xf]
00002e  ea414102          ORR      r1,r1,r2,LSL #16
000032  7a42              LDRB     r2,[r0,#9]
000034  ea412102          ORR      r1,r1,r2,LSL #8
000038  7a02              LDRB     r2,[r0,#8]
00003a  ea410142          ORR      r1,r1,r2,LSL #1
00003e  7802              LDRB     r2,[r0,#0]
000040  4311              ORRS     r1,r1,r2
000042  4a05              LDR      r2,|L1.88|
000044  3208              ADDS     r2,r2,#8
000046  6011              STR      r1,[r2,#0]
000048  e005              B        |L1.86|
                  |L1.74|
;;;323                    ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
;;;324                    ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
;;;325                    ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
;;;326                    ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
;;;327                    ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
;;;328                    ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
;;;329                    ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
;;;330                    ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
;;;331      }
;;;332      else
;;;333      {
;;;334        MPU->RBAR = 0x00U;
00004a  2100              MOVS     r1,#0
00004c  4a02              LDR      r2,|L1.88|
00004e  1d12              ADDS     r2,r2,#4
000050  6011              STR      r1,[r2,#0]
;;;335        MPU->RASR = 0x00U;
000052  1d12              ADDS     r2,r2,#4
000054  6011              STR      r1,[r2,#0]
                  |L1.86|
;;;336      }
;;;337    }
000056  4770              BX       lr
;;;338    #endif /* __MPU_PRESENT */
                          ENDP

                  |L1.88|
                          DCD      0xe000ed98

                          AREA ||i.HAL_MPU_Disable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Disable PROC
;;;257      */
;;;258    void HAL_MPU_Disable(void)
000000  bf00              NOP      
;;;259    {
;;;260      /* Make sure outstanding transfers are done */
;;;261      __DMB();
000002  bf00              NOP      
000004  bf00              NOP      
000006  f3bf8f5f          DMB      
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;262    
;;;263      /* Disable fault exceptions */
;;;264      SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
000010  4805              LDR      r0,|L2.40|
000012  6800              LDR      r0,[r0,#0]
000014  f4203080          BIC      r0,r0,#0x10000
000018  4903              LDR      r1,|L2.40|
00001a  6008              STR      r0,[r1,#0]
;;;265      
;;;266      /* Disable the MPU and clear the control register*/
;;;267      MPU->CTRL = 0U;
00001c  2000              MOVS     r0,#0
00001e  4902              LDR      r1,|L2.40|
000020  3170              ADDS     r1,r1,#0x70
000022  6008              STR      r0,[r1,#0]
;;;268    }
000024  4770              BX       lr
;;;269    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0xe000ed24

                          AREA ||i.HAL_MPU_Enable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Enable PROC
;;;280      */
;;;281    void HAL_MPU_Enable(uint32_t MPU_Control)
000000  f0400101          ORR      r1,r0,#1
;;;282    {
;;;283      /* Enable the MPU */
;;;284      MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
000004  4a0d              LDR      r2,|L3.60|
000006  6011              STR      r1,[r2,#0]
;;;285      
;;;286      /* Enable fault exceptions */
;;;287      SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
000008  490c              LDR      r1,|L3.60|
00000a  3970              SUBS     r1,r1,#0x70
00000c  6809              LDR      r1,[r1,#0]
00000e  f4413180          ORR      r1,r1,#0x10000
000012  4a0a              LDR      r2,|L3.60|
000014  3a70              SUBS     r2,r2,#0x70
000016  6011              STR      r1,[r2,#0]
;;;288      
;;;289      /* Ensure MPU setting take effects */
;;;290      __DSB();
000018  bf00              NOP      
00001a  bf00              NOP      
00001c  bf00              NOP      
00001e  f3bf8f4f          DSB      
000022  bf00              NOP      
000024  bf00              NOP      
000026  bf00              NOP      
;;;291      __ISB();
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  f3bf8f6f          ISB      
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
;;;292    }
000038  4770              BX       lr
;;;293    
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      0xe000ed94

                          AREA ||i.HAL_NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_ClearPendingIRQ PROC
;;;419      */
;;;420    void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  4a03              LDR      r2,|L4.24|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;421    {
;;;422      /* Check the parameters */
;;;423      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;424      
;;;425      /* Clear pending interrupt */
;;;426      NVIC_ClearPendingIRQ(IRQn);
;;;427    }
000014  4770              BX       lr
;;;428    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0xe000e280

                          AREA ||i.HAL_NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_DisableIRQ PROC
;;;202      */
;;;203    void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  4a03              LDR      r2,|L5.24|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;204    {
;;;205      /* Check the parameters */
;;;206      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;207      
;;;208      /* Disable interrupt */
;;;209      NVIC_DisableIRQ(IRQn);
;;;210    }
000014  4770              BX       lr
;;;211    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0xe000e180

                          AREA ||i.HAL_NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_EnableIRQ PROC
;;;186      */
;;;187    void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  0942              LSRS     r2,r0,#5
00000c  0092              LSLS     r2,r2,#2
00000e  f10222e0          ADD      r2,r2,#0xe000e000
000012  f8c21100          STR      r1,[r2,#0x100]
000016  bf00              NOP      
;;;188    {
;;;189      /* Check the parameters */
;;;190      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;191      
;;;192      /* Enable interrupt */
;;;193      NVIC_EnableIRQ(IRQn);
;;;194    }
000018  4770              BX       lr
;;;195    
                          ENDP


                          AREA ||i.HAL_NVIC_GetActive||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetActive PROC
;;;436      */
;;;437    uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;438    {
000002  4601              MOV      r1,r0
;;;439      /* Check the parameters */
;;;440      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;441      
;;;442      /* Return 1 if active else 0 */
;;;443      return NVIC_GetActive(IRQn);
000004  4608              MOV      r0,r1
000006  4a07              LDR      r2,|L7.36|
000008  0943              LSRS     r3,r0,#5
00000a  f8522023          LDR      r2,[r2,r3,LSL #2]
00000e  f000041f          AND      r4,r0,#0x1f
000012  2301              MOVS     r3,#1
000014  40a3              LSLS     r3,r3,r4
000016  401a              ANDS     r2,r2,r3
000018  b10a              CBZ      r2,|L7.30|
00001a  2201              MOVS     r2,#1
00001c  e000              B        |L7.32|
                  |L7.30|
00001e  2200              MOVS     r2,#0
                  |L7.32|
000020  4610              MOV      r0,r2
;;;444    }
000022  bd10              POP      {r4,pc}
;;;445    
                          ENDP

                  |L7.36|
                          DCD      0xe000e300

                          AREA ||i.HAL_NVIC_GetPendingIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPendingIRQ PROC
;;;403      */
;;;404    uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;405    {
000002  4601              MOV      r1,r0
;;;406      /* Check the parameters */
;;;407      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;408      
;;;409      /* Return 1 if pending else 0 */
;;;410      return NVIC_GetPendingIRQ(IRQn);
000004  4608              MOV      r0,r1
000006  4a07              LDR      r2,|L8.36|
000008  0943              LSRS     r3,r0,#5
00000a  f8522023          LDR      r2,[r2,r3,LSL #2]
00000e  f000041f          AND      r4,r0,#0x1f
000012  2301              MOVS     r3,#1
000014  40a3              LSLS     r3,r3,r4
000016  401a              ANDS     r2,r2,r3
000018  b10a              CBZ      r2,|L8.30|
00001a  2201              MOVS     r2,#1
00001c  e000              B        |L8.32|
                  |L8.30|
00001e  2200              MOVS     r2,#0
                  |L8.32|
000020  4610              MOV      r0,r2
;;;411    }
000022  bd10              POP      {r4,pc}
;;;412    
                          ENDP

                  |L8.36|
                          DCD      0xe000e200

                          AREA ||i.HAL_NVIC_GetPriority||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPriority PROC
;;;370      */
;;;371    void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;372    {
000004  4604              MOV      r4,r0
;;;373      /* Check the parameters */
;;;374      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;375     /* Get priority for Cortex-M system or device specific interrupts */
;;;376      NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
000006  4620              MOV      r0,r4
000008  2800              CMP      r0,#0
00000a  da08              BGE      |L9.30|
00000c  4f1f              LDR      r7,|L9.140|
00000e  f0000c0f          AND      r12,r0,#0xf
000012  f1ac0c04          SUB      r12,r12,#4
000016  f817700c          LDRB     r7,[r7,r12]
00001a  093f              LSRS     r7,r7,#4
00001c  e002              B        |L9.36|
                  |L9.30|
00001e  4f1c              LDR      r7,|L9.144|
000020  5c3f              LDRB     r7,[r7,r0]
000022  093f              LSRS     r7,r7,#4
                  |L9.36|
000024  463d              MOV      r5,r7
000026  460e              MOV      r6,r1
000028  f0060007          AND      r0,r6,#7
00002c  f1c00807          RSB      r8,r0,#7
000030  f1b80f04          CMP      r8,#4
000034  d902              BLS      |L9.60|
000036  f04f0804          MOV      r8,#4
00003a  e001              B        |L9.64|
                  |L9.60|
00003c  f1c00807          RSB      r8,r0,#7
                  |L9.64|
000040  46c4              MOV      r12,r8
000042  f1000804          ADD      r8,r0,#4
000046  f1b80f07          CMP      r8,#7
00004a  d202              BCS      |L9.82|
00004c  f04f0800          MOV      r8,#0
000050  e001              B        |L9.86|
                  |L9.82|
000052  f1a00803          SUB      r8,r0,#3
                  |L9.86|
000056  4647              MOV      r7,r8
000058  fa25f807          LSR      r8,r5,r7
00005c  f04f0901          MOV      r9,#1
000060  fa09f90c          LSL      r9,r9,r12
000064  f1a90901          SUB      r9,r9,#1
000068  ea080809          AND      r8,r8,r9
00006c  f8c28000          STR      r8,[r2,#0]
000070  f04f0801          MOV      r8,#1
000074  fa08f807          LSL      r8,r8,r7
000078  f1a80801          SUB      r8,r8,#1
00007c  ea080805          AND      r8,r8,r5
000080  f8c38000          STR      r8,[r3,#0]
000084  bf00              NOP      
;;;377    }
000086  e8bd83f0          POP      {r4-r9,pc}
;;;378    
                          ENDP

00008a  0000              DCW      0x0000
                  |L9.140|
                          DCD      0xe000ed18
                  |L9.144|
                          DCD      0xe000e400

                          AREA ||i.HAL_NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPriorityGrouping PROC
;;;343      */
;;;344    uint32_t HAL_NVIC_GetPriorityGrouping(void)
000000  b510              PUSH     {r4,lr}
;;;345    {
;;;346      /* Get the PRIGROUP[10:8] field value */
;;;347      return NVIC_GetPriorityGrouping();
000002  f7fffffe          BL       NVIC_GetPriorityGrouping
;;;348    }
000006  bd10              POP      {r4,pc}
;;;349    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPendingIRQ PROC
;;;385      */
;;;386    void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  4a03              LDR      r2,|L11.24|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;387    {
;;;388      /* Check the parameters */
;;;389      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;390      
;;;391      /* Set interrupt pending */
;;;392      NVIC_SetPendingIRQ(IRQn);
;;;393    }
000014  4770              BX       lr
;;;394    
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0xe000e200

                          AREA ||i.HAL_NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_SetPriority PROC
;;;164      */
;;;165    void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;166    { 
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;167      uint32_t prioritygroup = 0x00U;
00000a  2700              MOVS     r7,#0
;;;168      
;;;169      /* Check the parameters */
;;;170      assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
;;;171      assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
;;;172      
;;;173      prioritygroup = NVIC_GetPriorityGrouping();
00000c  f7fffffe          BL       NVIC_GetPriorityGrouping
000010  4607              MOV      r7,r0
;;;174      
;;;175      NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
000012  4639              MOV      r1,r7
000014  462a              MOV      r2,r5
000016  4633              MOV      r3,r6
000018  f0010007          AND      r0,r1,#7
00001c  f1c00a07          RSB      r10,r0,#7
000020  f1ba0f04          CMP      r10,#4
000024  d902              BLS      |L12.44|
000026  f04f0a04          MOV      r10,#4
00002a  e001              B        |L12.48|
                  |L12.44|
00002c  f1c00a07          RSB      r10,r0,#7
                  |L12.48|
000030  46d1              MOV      r9,r10
000032  f1000a04          ADD      r10,r0,#4
000036  f1ba0f07          CMP      r10,#7
00003a  d202              BCS      |L12.66|
00003c  f04f0a00          MOV      r10,#0
000040  e001              B        |L12.70|
                  |L12.66|
000042  f1a00a03          SUB      r10,r0,#3
                  |L12.70|
000046  46d4              MOV      r12,r10
000048  f04f0a01          MOV      r10,#1
00004c  fa0afa09          LSL      r10,r10,r9
000050  f1aa0a01          SUB      r10,r10,#1
000054  ea0a0a02          AND      r10,r10,r2
000058  fa0afa0c          LSL      r10,r10,r12
00005c  f04f0b01          MOV      r11,#1
000060  fa0bfb0c          LSL      r11,r11,r12
000064  f1ab0b01          SUB      r11,r11,#1
000068  ea0b0b03          AND      r11,r11,r3
00006c  ea4a040b          ORR      r4,r10,r11
000070  4621              MOV      r1,r4
000072  4640              MOV      r0,r8
000074  f7fffffe          BL       NVIC_SetPriority
;;;176    }
000078  e8bd9ff0          POP      {r4-r12,pc}
;;;177    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriorityGrouping PROC
;;;142      */
;;;143    void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
000000  bf00              NOP      
000002  f0000207          AND      r2,r0,#7
000006  4b06              LDR      r3,|L13.32|
000008  6819              LDR      r1,[r3,#0]
00000a  f64f03ff          MOV      r3,#0xf8ff
00000e  4019              ANDS     r1,r1,r3
000010  4b04              LDR      r3,|L13.36|
000012  430b              ORRS     r3,r3,r1
000014  ea432102          ORR      r1,r3,r2,LSL #8
000018  4b01              LDR      r3,|L13.32|
00001a  6019              STR      r1,[r3,#0]
00001c  bf00              NOP      
;;;144    {
;;;145      /* Check the parameters */
;;;146      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;147      
;;;148      /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
;;;149      NVIC_SetPriorityGrouping(PriorityGroup);
;;;150    }
00001e  4770              BX       lr
;;;151    
                          ENDP

                  |L13.32|
                          DCD      0xe000ed0c
                  |L13.36|
                          DCD      0x05fa0000

                          AREA ||i.HAL_NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SystemReset PROC
;;;215      */
;;;216    void HAL_NVIC_SystemReset(void)
000000  bf00              NOP      
000002  bf00              NOP      
000004  bf00              NOP      
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f3bf8f4f          DSB      
00000e  bf00              NOP      
000010  bf00              NOP      
000012  bf00              NOP      
000014  4809              LDR      r0,|L14.60|
000016  6800              LDR      r0,[r0,#0]
000018  f40060e0          AND      r0,r0,#0x700
00001c  4908              LDR      r1,|L14.64|
00001e  4308              ORRS     r0,r0,r1
000020  1d00              ADDS     r0,r0,#4
000022  4906              LDR      r1,|L14.60|
000024  6008              STR      r0,[r1,#0]
000026  bf00              NOP      
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  f3bf8f4f          DSB      
000030  bf00              NOP      
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
                  |L14.56|
000038  bf00              NOP      
00003a  e7fd              B        |L14.56|
;;;217    {
;;;218      /* System Reset */
;;;219      NVIC_SystemReset();
;;;220    }
;;;221    
                          ENDP

                  |L14.60|
                          DCD      0xe000ed0c
                  |L14.64|
                          DCD      0x05fa0000

                          AREA ||i.HAL_SYSTICK_CLKSourceConfig||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_CLKSourceConfig PROC
;;;453      */
;;;454    void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
000000  2804              CMP      r0,#4
;;;455    {
;;;456      /* Check the parameters */
;;;457      assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
;;;458      if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
000002  d108              BNE      |L15.22|
;;;459      {
;;;460        SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
000004  f04f21e0          MOV      r1,#0xe000e000
000008  6909              LDR      r1,[r1,#0x10]
00000a  f0410104          ORR      r1,r1,#4
00000e  f04f22e0          MOV      r2,#0xe000e000
000012  6111              STR      r1,[r2,#0x10]
000014  e007              B        |L15.38|
                  |L15.22|
;;;461      }
;;;462      else
;;;463      {
;;;464        SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
000016  f04f21e0          MOV      r1,#0xe000e000
00001a  6909              LDR      r1,[r1,#0x10]
00001c  f0210104          BIC      r1,r1,#4
000020  f04f22e0          MOV      r2,#0xe000e000
000024  6111              STR      r1,[r2,#0x10]
                  |L15.38|
;;;465      }
;;;466    }
000026  4770              BX       lr
;;;467    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Callback||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Callback PROC
;;;480      */
;;;481    __weak void HAL_SYSTICK_Callback(void)
000000  4770              BX       lr
;;;482    {
;;;483      /* NOTE : This function Should not be modified, when the callback is needed,
;;;484                the HAL_SYSTICK_Callback could be implemented in the user file
;;;485       */
;;;486    }
;;;487    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Config||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Config PROC
;;;228      */
;;;229    uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
000000  b570              PUSH     {r4-r6,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231       return SysTick_Config(TicksNumb);
000004  4625              MOV      r5,r4
000006  1e68              SUBS     r0,r5,#1
000008  f1b07f80          CMP      r0,#0x1000000
00000c  d301              BCC      |L17.18|
00000e  2001              MOVS     r0,#1
000010  e00f              B        |L17.50|
                  |L17.18|
000012  1e68              SUBS     r0,r5,#1
000014  f04f21e0          MOV      r1,#0xe000e000
000018  6148              STR      r0,[r1,#0x14]
00001a  210f              MOVS     r1,#0xf
00001c  f04f30ff          MOV      r0,#0xffffffff
000020  f7fffffe          BL       NVIC_SetPriority
000024  2000              MOVS     r0,#0
000026  f04f21e0          MOV      r1,#0xe000e000
00002a  6188              STR      r0,[r1,#0x18]
00002c  2007              MOVS     r0,#7
00002e  6108              STR      r0,[r1,#0x10]
000030  2000              MOVS     r0,#0
                  |L17.50|
;;;232    }
000032  bd70              POP      {r4-r6,pc}
;;;233    /**
                          ENDP


                          AREA ||i.HAL_SYSTICK_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_IRQHandler PROC
;;;471      */
;;;472    void HAL_SYSTICK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;473    {
;;;474      HAL_SYSTICK_Callback();
000002  f7fffffe          BL       HAL_SYSTICK_Callback
;;;475    }
000006  bd10              POP      {r4,pc}
;;;476    
                          ENDP


                          AREA ||i.NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  NVIC_GetPriorityGrouping PROC
;;;1614    */
;;;1615   __STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L19.12|
;;;1616   {
;;;1617     return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;1618   }
000008  4770              BX       lr
;;;1619   
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      0xe000ed0c

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;1697    */
;;;1698   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;1699   {
;;;1700     if ((int32_t)(IRQn) < 0)
000002  2800              CMP      r0,#0
000004  da07              BGE      |L20.22|
;;;1701     {
;;;1702       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000006  070a              LSLS     r2,r1,#28
000008  0e14              LSRS     r4,r2,#24
00000a  4a05              LDR      r2,|L20.32|
00000c  f000030f          AND      r3,r0,#0xf
000010  1f1b              SUBS     r3,r3,#4
000012  54d4              STRB     r4,[r2,r3]
000014  e003              B        |L20.30|
                  |L20.22|
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000016  070a              LSLS     r2,r1,#28
000018  0e13              LSRS     r3,r2,#24
00001a  4a02              LDR      r2,|L20.36|
00001c  5413              STRB     r3,[r2,r0]
                  |L20.30|
;;;1707     }
;;;1708   }
00001e  bd10              POP      {r4,pc}
;;;1709   
                          ENDP

                  |L20.32|
                          DCD      0xe000ed18
                  |L20.36|
                          DCD      0xe000e400

;*** Start embedded assembler ***

#line 1 "D:\\Keil_v5\\ARM\\PACK\\Keil\\STM32F4xx_DFP\\2.16.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_cortex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_cortex_c_2992dbc0____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_cortex_c_2992dbc0____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_cortex_c_2992dbc0____REVSH|
#line 402
|__asm___22_stm32f4xx_hal_cortex_c_2992dbc0____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_cortex_c_2992dbc0____RRX|
#line 587
|__asm___22_stm32f4xx_hal_cortex_c_2992dbc0____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
