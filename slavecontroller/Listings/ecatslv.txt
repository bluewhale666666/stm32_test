; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\ecatslv.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ecatslv.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\etherCAT -I.\Power -I.\CRC -IC:\Users\LENOVO\Desktop\slavecontroller\RTE -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx -IC:\Users\LENOVO\Desktop\slavecontroller\RTE\Device\STM32F407ZETx\STCubeGenerated\Inc -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.16.0\Drivers\STM32F4xx_HAL_Driver\Inc -ISTCubeGenerated\Inc -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F407xx --omf_browse=.\objects\ecatslv.crf etherCAT\ecatslv.c]
                          THUMB

                          AREA ||i.AL_ControlInd||, CODE, READONLY, ALIGN=2

                  AL_ControlInd PROC
;;;1730   
;;;1731   void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1732   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;1733       UINT16        result = 0;
000008  2400              MOVS     r4,#0
;;;1734       UINT8            bErrAck = 0;
00000a  46a0              MOV      r8,r4
;;;1735       UINT8         stateTrans;
;;;1736       /*deactivate ESM timeout counter*/
;;;1737       EsmTimeoutCounter = -1;
00000c  1e60              SUBS     r0,r4,#1
00000e  49fb              LDR      r1,|L1.1020|
000010  8008              STRH     r0,[r1,#0]
;;;1738       bApplEsmPending = TRUE;
000012  2001              MOVS     r0,#1
000014  49fa              LDR      r1,|L1.1024|
000016  7008              STRB     r0,[r1,#0]
;;;1739   
;;;1740       /* reset the Error Flag in case of acknowledge by the Master */
;;;1741       if ( alControl & STATE_CHANGE )
000018  f0050010          AND      r0,r5,#0x10
00001c  b140              CBZ      r0,|L1.48|
;;;1742       {
;;;1743           bErrAck = 1;
00001e  f04f0801          MOV      r8,#1
;;;1744           nAlStatus &= ~STATE_CHANGE;
000022  48f8              LDR      r0,|L1.1028|
000024  7800              LDRB     r0,[r0,#0]  ; nAlStatus
000026  f0200010          BIC      r0,r0,#0x10
00002a  49f6              LDR      r1,|L1.1028|
00002c  7008              STRB     r0,[r1,#0]
00002e  e010              B        |L1.82|
                  |L1.48|
;;;1745           /*enable SM2 is moved to state transition block. First check SM Settings.*/
;;;1746       }
;;;1747       else if ((nAlStatus & STATE_CHANGE)
000030  48f4              LDR      r0,|L1.1028|
000032  7800              LDRB     r0,[r0,#0]  ; nAlStatus
000034  f0000010          AND      r0,r0,#0x10
000038  b128              CBZ      r0,|L1.70|
;;;1748           // HBu 17.04.08: the error has to be acknowledged before when sending the same (or a higher) state
;;;1749           //               (the error was acknowledged with the same state before independent of the acknowledge flag)
;;;1750           /*Error Acknowledge with 0xX1 is allowed*/
;;;1751           && (alControl & STATE_MASK) != STATE_INIT)
00003a  f005000f          AND      r0,r5,#0xf
00003e  2801              CMP      r0,#1
000040  d001              BEQ      |L1.70|
                  |L1.66|
;;;1752       {
;;;1753           /* the error flag (Bit 4) is set in the AL-Status and the ErrAck bit (Bit 4)
;;;1754              is not set in the AL-Control, so the state cannot be set to a higher state
;;;1755              and the new state request will be ignored */
;;;1756           return;
;;;1757       }
;;;1758       else
;;;1759       {
;;;1760           nAlStatus &= STATE_MASK;
;;;1761       }
;;;1762   
;;;1763       
;;;1764   
;;;1765       /* generate a variable for the state transition
;;;1766         (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
;;;1767       alControl &= STATE_MASK;
;;;1768       stateTrans = nAlStatus;
;;;1769       stateTrans <<= 4;
;;;1770       stateTrans += alControl;
;;;1771   
;;;1772       /* check the SYNCM settings depending on the state transition */
;;;1773       switch ( stateTrans )
;;;1774       {
;;;1775       case INIT_2_PREOP:
;;;1776       case OP_2_PREOP:
;;;1777       case SAFEOP_2_PREOP:
;;;1778       case PREOP_2_PREOP:
;;;1779           /* in PREOP only the SYNCM settings for SYNCM0 and SYNCM1 (mailbox)
;;;1780              are checked, if result is unequal 0, the slave will stay in or
;;;1781              switch to INIT and set the ErrorInd Bit (bit 4) of the AL-Status */
;;;1782           result = CheckSmSettings(MAILBOX_READ+1);
;;;1783           break;
;;;1784       case PREOP_2_SAFEOP:
;;;1785           {
;;;1786           /* before checking the SYNCM settings for SYNCM2 and SYNCM3 (process data)
;;;1787              the expected length of input data (nPdInputSize) and output data (nPdOutputSize)
;;;1788               could be adapted (changed by PDO-Assign and/or PDO-Mapping)
;;;1789               if result is unequal 0, the slave will stay in PREOP and set
;;;1790               the ErrorInd Bit (bit 4) of the AL-Status */
;;;1791           result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
;;;1792   
;;;1793               if (result != 0)
;;;1794               {
;;;1795                   break;
;;;1796               }
;;;1797   /*ET9300 Project Handler :(#if (MAX_PD_OUTPUT_SIZE == 0) || (MAX_PD_INPUT_SIZE == 0)) lines 2527 to 2543 deleted*/
;;;1798           }
;;;1799       case SAFEOP_2_OP:
;;;1800       case OP_2_SAFEOP:
;;;1801       case SAFEOP_2_SAFEOP:
;;;1802       case OP_2_OP:
;;;1803           /* in SAFEOP or OP the SYNCM settings for all SYNCM are checked
;;;1804              if result is unequal 0, the slave will stay in or
;;;1805              switch to PREOP and set the ErrorInd Bit (bit 4) of the AL-Status */
;;;1806           result = CheckSmSettings(nMaxSyncMan);
;;;1807           break;
;;;1808   
;;;1809       }
;;;1810   
;;;1811       if ( result == 0 )
;;;1812       {
;;;1813           /* execute the corresponding local management service(s) depending on the state transition */
;;;1814           nEcatStateTrans = 0;
;;;1815           switch ( stateTrans )
;;;1816           {
;;;1817           case INIT_2_BOOT    :
;;;1818               /* if the application has to execute code when going to BOOT this shall be done at this place */
;;;1819               bBootMode = TRUE;
;;;1820   
;;;1821               if ( CheckSmSettings(MAILBOX_READ+1) != 0 )
;;;1822               {
;;;1823                   bBootMode = FALSE;
;;;1824                   result = ALSTATUSCODE_INVALIDMBXCFGINBOOT;
;;;1825                   break;
;;;1826               }
;;;1827   /*ECATCHANGE_START(V5.13) ECAT1*/
;;;1828   /*ECATCHANGE_END(V5.13) ECAT1*/
;;;1829               /* disable all events in BOOT state */
;;;1830               ResetALEventMask(0);
;;;1831   
;;;1832               /* MBX_StartMailboxHandler (in mailbox.c) checks if the areas of the mailbox
;;;1833                  sync managers SM0 and SM1 overlap each other
;;;1834                 if result is unequal 0, the slave will stay in INIT
;;;1835                 and sets the ErrorInd Bit (bit 4) of the AL-Status */
;;;1836               result = MBX_StartMailboxHandler();
;;;1837               if (result == 0)
;;;1838               {
;;;1839                   bApplEsmPending = FALSE;
;;;1840                   /* additionally there could be an application specific check (in ecatappl.c)
;;;1841                       if the state transition from INIT to BOOT should be done
;;;1842                       if result is NOERROR_INWORK, the slave will stay in INIT until timeout 
;;;1843                       or transition is complete by AL_ControlRes*/
;;;1844               
;;;1845                   result = APPL_StartMailboxHandler();
;;;1846                   if ( result == 0 )
;;;1847                   {
;;;1848                       /*transition successful*/
;;;1849                       bMbxRunning = TRUE;
;;;1850                   }
;;;1851               }
;;;1852   
;;;1853               if(result != 0 && result != NOERROR_INWORK)
;;;1854               {
;;;1855                   /*Stop APPL Mbx handler if the APPL start handler was called before*/
;;;1856                       if (!bApplEsmPending)
;;;1857                       {
;;;1858                           APPL_StopMailboxHandler();
;;;1859                       }
;;;1860   
;;;1861                    MBX_StopMailboxHandler();
;;;1862               }
;;;1863   /*ET9300 Project Handler :(#if MAILBOX_SUPPORTED #else) lines 2614 to 2616 deleted*/
;;;1864   
;;;1865               BL_Start( STATE_BOOT );
;;;1866   
;;;1867               if (result != 0)
;;;1868               {
;;;1869                   bBootMode = FALSE;
;;;1870               }
;;;1871   /*ET9300 Project Handler :(#if BOOTSTRAPMODE_SUPPORTED #else) lines 2624 to 2626 deleted*/
;;;1872   
;;;1873   
;;;1874   
;;;1875               break;
;;;1876   
;;;1877           case BOOT_2_INIT    :
;;;1878               if(bBootMode)
;;;1879               {
;;;1880                   bBootMode = FALSE;
;;;1881   /*ECATCHANGE_START(V5.13) ECAT1*/
;;;1882   /*ECATCHANGE_END(V5.13) ECAT1*/
;;;1883                   /* disable all events in BOOT state */
;;;1884                   ResetALEventMask(0);
;;;1885                   MBX_StopMailboxHandler();
;;;1886                   result = APPL_StopMailboxHandler();
;;;1887               }
;;;1888   
;;;1889               BL_Stop();
;;;1890   /*ET9300 Project Handler :(#if BOOTSTRAPMODE_SUPPORTED #else) lines 2650 to 2652 deleted*/
;;;1891   
;;;1892               BackToInitTransition();
;;;1893   
;;;1894   
;;;1895   
;;;1896               break;
;;;1897           case INIT_2_PREOP :
;;;1898   
;;;1899              UpdateEEPROMLoadedState();
;;;1900   
;;;1901               if (EepromLoaded == FALSE)
;;;1902               {
;;;1903                   //return an error if the EEPROM was not loaded correct  (device restart is required after the new EEPORM update)
;;;1904                   result = ALSTATUSCODE_EE_ERROR;
;;;1905               }
;;;1906               if (result == 0)
;;;1907               {
;;;1908               /* MBX_StartMailboxHandler (in mailbox.c) checks if the areas of the mailbox
;;;1909                  sync managers SYNCM0 and SYNCM1 overlap each other
;;;1910                 if result is unequal 0, the slave will stay in INIT
;;;1911                 and sets the ErrorInd Bit (bit 4) of the AL-Status */
;;;1912               result = MBX_StartMailboxHandler();
;;;1913               if (result == 0)
;;;1914               {
;;;1915                   bApplEsmPending = FALSE;
;;;1916                   /* additionally there could be an application specific check (in ecatappl.c)
;;;1917                      if the state transition from INIT to PREOP should be done
;;;1918                    if result is unequal 0, the slave will stay in INIT
;;;1919                    and sets the ErrorInd Bit (bit 4) of the AL-Status */
;;;1920                   result = APPL_StartMailboxHandler();
;;;1921                   if ( result == 0 )
;;;1922                   {
;;;1923                       bMbxRunning = TRUE;
;;;1924                   }
;;;1925               }
;;;1926   
;;;1927               if(result != 0 && result != NOERROR_INWORK)
;;;1928               {
;;;1929                   /*Stop APPL Mbx handler if APPL Start Mbx handler was called before*/
;;;1930                       if (!bApplEsmPending)
;;;1931                       {
;;;1932                           APPL_StopMailboxHandler();
;;;1933                       }
;;;1934   
;;;1935                    MBX_StopMailboxHandler();
;;;1936               }
;;;1937   
;;;1938               }
;;;1939   /*ET9300 Project Handler :(#if MAILBOX_SUPPORTED #else) lines 2702 to 2704 deleted*/
;;;1940               break;
;;;1941   
;;;1942           case PREOP_2_SAFEOP:
;;;1943               /* start the input handler (function is defined above) */
;;;1944               result = StartInputHandler();
;;;1945               if ( result == 0 )
;;;1946               {
;;;1947                   bApplEsmPending = FALSE;
;;;1948                   result = APPL_StartInputHandler(&u16ALEventMask);
;;;1949   
;;;1950                   if(result == 0)
;;;1951                   {
;;;1952   /*ECATCHANGE_START(V5.13) ECAT1*/
;;;1953   /*ECATCHANGE_END(V5.13) ECAT1*/
;;;1954                       /* initialize the AL Event Mask register (0x204) */
;;;1955                       SetALEventMask( u16ALEventMask );
;;;1956   
;;;1957                       bEcatInputUpdateRunning = TRUE;
;;;1958                   }
;;;1959               }
;;;1960   
;;;1961               /*if one start input handler returned an error stop the input handler*/
;;;1962               if(result != 0 && result != NOERROR_INWORK)
;;;1963               {
;;;1964                   if(!bApplEsmPending)
;;;1965                   {
;;;1966                       /*Call only the APPL stop handler if the APPL start handler was called before*/
;;;1967                       /*The application can react to the state transition in the function APPL_StopInputHandler */
;;;1968                       APPL_StopInputHandler();
;;;1969                   }
;;;1970   
;;;1971                   StopInputHandler();
;;;1972               }
;;;1973               break;
;;;1974   
;;;1975           case SAFEOP_2_OP:
;;;1976   /*ECATCHANGE_START(V5.13) ESM2*/
;;;1977               /*enable SM if error was acknowledged*/
;;;1978               if (bErrAck)
;;;1979               {
;;;1980                   if (nPdOutputSize > 0)
;;;1981                   {
;;;1982                       EnableSyncManChannel(PROCESS_DATA_OUT);
;;;1983                   }
;;;1984                   else
;;;1985                       if (nPdInputSize > 0)
;;;1986                       {
;;;1987                           EnableSyncManChannel(PROCESS_DATA_IN);
;;;1988                       }
;;;1989               }
;;;1990               /*ECATCHANGE_END(V5.13) ESM2*/
;;;1991   
;;;1992               /* start the output handler (function is defined above) */
;;;1993               result = StartOutputHandler();
;;;1994               if(result == 0)
;;;1995               {
;;;1996                   bApplEsmPending = FALSE;
;;;1997                   result = APPL_StartOutputHandler();
;;;1998   
;;;1999                   if(result == 0)
;;;2000                   {
;;;2001                       /*Device is in OPERATINAL*/
;;;2002                       bEcatOutputUpdateRunning = TRUE;
;;;2003                   }
;;;2004   
;;;2005               }
;;;2006   
;;;2007               if ( result != 0 && result != NOERROR_INWORK)
;;;2008               {
;;;2009                       if (!bApplEsmPending)
;;;2010                       {
;;;2011                           APPL_StopOutputHandler();
;;;2012                       }
;;;2013   
;;;2014                   StopOutputHandler();
;;;2015               }
;;;2016   
;;;2017               break;
;;;2018   
;;;2019           case OP_2_SAFEOP:
;;;2020               /* stop the output handler (function is defined above) */
;;;2021               APPL_StopOutputHandler();
;;;2022   
;;;2023               StopOutputHandler();
;;;2024   
;;;2025               bApplEsmPending = FALSE;
;;;2026   
;;;2027               break;
;;;2028   
;;;2029           case OP_2_PREOP:
;;;2030               /* stop the output handler (function is defined above) */
;;;2031               result = APPL_StopOutputHandler();
;;;2032   
;;;2033               StopOutputHandler();
;;;2034   
;;;2035               bApplEsmPending = FALSE;
;;;2036   
;;;2037               if (result != 0)
;;;2038               {
;;;2039                   break;
;;;2040               }
;;;2041   
;;;2042               stateTrans = SAFEOP_2_PREOP;
;;;2043   
;;;2044           case SAFEOP_2_PREOP:
;;;2045               /* stop the input handler (function is defined above) */
;;;2046               APPL_StopInputHandler();
;;;2047              
;;;2048               StopInputHandler();
;;;2049   
;;;2050               bApplEsmPending = FALSE;
;;;2051   
;;;2052               break;
;;;2053   
;;;2054           case OP_2_INIT:
;;;2055               /* stop the output handler (function is defined above) */
;;;2056               result = APPL_StopOutputHandler();
;;;2057   
;;;2058               StopOutputHandler();
;;;2059   
;;;2060               bApplEsmPending = FALSE;
;;;2061   
;;;2062               if (result != 0)
;;;2063               {
;;;2064                   break;
;;;2065               }
;;;2066               
;;;2067               stateTrans = SAFEOP_2_INIT;
;;;2068   
;;;2069           case SAFEOP_2_INIT:
;;;2070               /* stop the input handler (function is defined above) */
;;;2071               result = APPL_StopInputHandler();
;;;2072               
;;;2073               StopInputHandler();
;;;2074   
;;;2075               bApplEsmPending = FALSE;
;;;2076   
;;;2077               if (result != 0)
;;;2078               {
;;;2079                   break;
;;;2080               }
;;;2081               stateTrans = PREOP_2_INIT;
;;;2082   
;;;2083           case PREOP_2_INIT:
;;;2084               MBX_StopMailboxHandler();
;;;2085               result = APPL_StopMailboxHandler();
;;;2086   
;;;2087               BackToInitTransition();
;;;2088               break;
;;;2089   /*ET9300 Project Handler :(#if !BOOTLOADER_SAMPLE #else) lines 2865 to 2872 deleted*/
;;;2090           case INIT_2_INIT:
;;;2091               BackToInitTransition();
;;;2092           case PREOP_2_PREOP:
;;;2093           case SAFEOP_2_SAFEOP:
;;;2094           case OP_2_OP:
;;;2095               if(bErrAck)
;;;2096               {
;;;2097                   APPL_AckErrorInd(stateTrans);
;;;2098               }
;;;2099   
;;;2100   
;;;2101                   /*no local error flag is currently active, enable SM*/
;;;2102                   if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
;;;2103                   {
;;;2104                       if(nPdOutputSize > 0)
;;;2105                       {
;;;2106                           EnableSyncManChannel(PROCESS_DATA_OUT);
;;;2107                       }
;;;2108                       else 
;;;2109                       if(nPdInputSize > 0)
;;;2110                       {
;;;2111                           EnableSyncManChannel(PROCESS_DATA_IN);
;;;2112                       }
;;;2113                   }
;;;2114               
;;;2115               result = NOERROR_NOSTATECHANGE;
;;;2116               break;
;;;2117   
;;;2118           case INIT_2_SAFEOP:
;;;2119           case INIT_2_OP:
;;;2120           case PREOP_2_OP:
;;;2121           case PREOP_2_BOOT:
;;;2122           case SAFEOP_2_BOOT:
;;;2123           case OP_2_BOOT:
;;;2124           case BOOT_2_PREOP:
;;;2125           case BOOT_2_SAFEOP:
;;;2126           case BOOT_2_OP:
;;;2127               result = ALSTATUSCODE_INVALIDALCONTROL;
;;;2128               break;
;;;2129   
;;;2130           default:
;;;2131               result = ALSTATUSCODE_UNKNOWNALCONTROL;
;;;2132               break;
;;;2133           }
;;;2134       }
;;;2135       else
;;;2136       {
;;;2137           /* the checking of the sync manager settings was not successful
;;;2138               switch back the state to PREOP or INIT */
;;;2139           switch (nAlStatus)
;;;2140           {
;;;2141           case STATE_OP:
;;;2142               /* stop the output handler (function is defined above) */
;;;2143               APPL_StopOutputHandler();
;;;2144               StopOutputHandler();
;;;2145           case STATE_SAFEOP:
;;;2146               /* stop the input handler (function is defined above) */
;;;2147               APPL_StopInputHandler();
;;;2148   
;;;2149               StopInputHandler();
;;;2150           case STATE_PREOP:
;;;2151               if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
;;;2152               {
;;;2153                   /* the mailbox sync manager settings were wrong, switch back to INIT */
;;;2154                   MBX_StopMailboxHandler();
;;;2155                   APPL_StopMailboxHandler();
;;;2156   
;;;2157                   /*Disable SM0 (MBX Out)*/
;;;2158                   DisableSyncManChannel(MAILBOX_WRITE);
;;;2159   
;;;2160                   /*Disable SM1 (MBX In)*/
;;;2161                   DisableSyncManChannel(MAILBOX_READ);
;;;2162   /*ET9300 Project Handler :(#if MAILBOX_SUPPORTED #else) lines 2956 to 2958 deleted*/
;;;2163   
;;;2164                   nAlStatus = STATE_INIT;
;;;2165               }
;;;2166               else
;;;2167               {
;;;2168                   nAlStatus = STATE_PREOP;
;;;2169               }
;;;2170           }
;;;2171       }
;;;2172   
;;;2173       if ( result == NOERROR_INWORK )
;;;2174       {
;;;2175           /* state transition is still in work
;;;2176               ECAT_StateChange must be called from the application */
;;;2177           bEcatWaitForAlControlRes = TRUE;
;;;2178           /* state transition has to be stored */
;;;2179           nEcatStateTrans = stateTrans;
;;;2180   
;;;2181           /*Init ESM timeout counter (will be decremented with the local 1ms timer)*/
;;;2182           switch(nEcatStateTrans)
;;;2183           {
;;;2184               case INIT_2_PREOP:
;;;2185               case INIT_2_BOOT:
;;;2186                   EsmTimeoutCounter = PREOPTIMEOUT;
;;;2187               break;
;;;2188               case PREOP_2_SAFEOP:
;;;2189               case SAFEOP_2_OP:
;;;2190                   EsmTimeoutCounter = SAFEOP2OPTIMEOUT;
;;;2191                   break;
;;;2192              default:
;;;2193                   EsmTimeoutCounter = 200; //Set default timeout value to 200ms
;;;2194                   break;
;;;2195           }
;;;2196           EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.
;;;2197   
;;;2198       }
;;;2199       else if ( alControl != (nAlStatus & STATE_MASK) )
;;;2200       {
;;;2201           /* The slave state has changed */
;;;2202   
;;;2203           if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
;;;2204           {
;;;2205               /* the local application requested to leave the state OP so we have to disable the SM2
;;;2206                  and make the state change from OP to SAFEOP by calling StopOutputHandler */
;;;2207   
;;;2208               //only execute StopOutputHandler() if Output update is still running
;;;2209               if(bEcatOutputUpdateRunning)
;;;2210               {
;;;2211                   APPL_StopOutputHandler();
;;;2212   
;;;2213                   StopOutputHandler();
;;;2214               }
;;;2215   
;;;2216               if(nPdOutputSize > 0)
;;;2217               {
;;;2218                   /* disable the Sync Manager Channel 2 (outputs) */
;;;2219                   DisableSyncManChannel(PROCESS_DATA_OUT);
;;;2220               }
;;;2221               else
;;;2222                   if(nPdInputSize > 0)
;;;2223               {
;;;2224                   /*disable Sync Manager 3 (inputs) if no outputs available*/
;;;2225                   DisableSyncManChannel(PROCESS_DATA_IN);
;;;2226               }
;;;2227   
;;;2228           }
;;;2229           if ( result != 0 )
;;;2230           {
;;;2231                   if (nAlStatus == STATE_OP)
;;;2232                   {
;;;2233                       nAlStatus = STATE_SAFEOP;
;;;2234                   }
;;;2235               /* save the failed status to be able to decide, if the AL Status Code shall be
;;;2236                  reset in case of a coming successful state transition */
;;;2237               nAlStatus |= STATE_CHANGE;
;;;2238           }
;;;2239           else
;;;2240           {
;;;2241               /* state transition was successful */
;;;2242               if ( alStatusCode != 0 )
;;;2243               {
;;;2244                   /* state change request from the user */
;;;2245                   result = alStatusCode;
;;;2246                   alControl |= STATE_CHANGE;
;;;2247               }
;;;2248               /* acknowledge the new state */
;;;2249               nAlStatus = alControl;
;;;2250           }
;;;2251   
;;;2252           bEcatWaitForAlControlRes = FALSE;
;;;2253   
;;;2254           /* write the AL Status register */
;;;2255           SetALStatus(nAlStatus, result);
;;;2256       }
;;;2257       else
;;;2258       {
;;;2259           /* Error acknowledgement without a state transition */
;;;2260   
;;;2261            bEcatWaitForAlControlRes = FALSE;
;;;2262   
;;;2263           /* AL-Status has to be updated and AL-Status-Code has to be reset
;;;2264              if the the error bit was acknowledged */
;;;2265           SetALStatus(nAlStatus, 0);
;;;2266       }
;;;2267       /*ECATCHANGE_START(V5.13) CIA402 4*/
;;;2268       /*decouple CIA402 state machine from ESM*/
;;;2269       /*ECATCHANGE_END(V5.13) CIA402 4*/
;;;2270   
;;;2271   }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L1.70|
000046  48ef              LDR      r0,|L1.1028|
000048  7800              LDRB     r0,[r0,#0]            ;1760  ; nAlStatus
00004a  f000000f          AND      r0,r0,#0xf            ;1760
00004e  49ed              LDR      r1,|L1.1028|
000050  7008              STRB     r0,[r1,#0]            ;1760
                  |L1.82|
000052  f005050f          AND      r5,r5,#0xf            ;1767
000056  48eb              LDR      r0,|L1.1028|
000058  7806              LDRB     r6,[r0,#0]            ;1768  ; nAlStatus
00005a  0730              LSLS     r0,r6,#28             ;1769
00005c  0e06              LSRS     r6,r0,#24             ;1769
00005e  1970              ADDS     r0,r6,r5              ;1770
000060  b2c6              UXTB     r6,r0                 ;1770
000062  2e44              CMP      r6,#0x44              ;1773
000064  d024              BEQ      |L1.176|
000066  dc08              BGT      |L1.122|
000068  2e12              CMP      r6,#0x12              ;1773
00006a  d00f              BEQ      |L1.140|
00006c  2e22              CMP      r6,#0x22              ;1773
00006e  d010              BEQ      |L1.146|
000070  2e24              CMP      r6,#0x24              ;1773
000072  d013              BEQ      |L1.156|
000074  2e42              CMP      r6,#0x42              ;1773
000076  d122              BNE      |L1.190|
000078  e00a              B        |L1.144|
                  |L1.122|
00007a  2e48              CMP      r6,#0x48              ;1773
00007c  d016              BEQ      |L1.172|
00007e  2e82              CMP      r6,#0x82              ;1773
000080  d005              BEQ      |L1.142|
000082  2e84              CMP      r6,#0x84              ;1773
000084  d013              BEQ      |L1.174|
000086  2e88              CMP      r6,#0x88              ;1773
000088  d119              BNE      |L1.190|
00008a  e012              B        |L1.178|
                  |L1.140|
00008c  bf00              NOP                            ;1776
                  |L1.142|
00008e  bf00              NOP                            ;1777
                  |L1.144|
000090  bf00              NOP                            ;1778
                  |L1.146|
000092  2002              MOVS     r0,#2                 ;1782
000094  f7fffffe          BL       CheckSmSettings
000098  4604              MOV      r4,r0                 ;1782
00009a  e010              B        |L1.190|
                  |L1.156|
00009c  49da              LDR      r1,|L1.1032|
00009e  48db              LDR      r0,|L1.1036|
0000a0  f7fffffe          BL       APPL_GenerateMapping
0000a4  4604              MOV      r4,r0                 ;1791
0000a6  b104              CBZ      r4,|L1.170|
0000a8  e009              B        |L1.190|
                  |L1.170|
0000aa  bf00              NOP                            ;1799
                  |L1.172|
0000ac  bf00              NOP                            ;1800
                  |L1.174|
0000ae  bf00              NOP                            ;1801
                  |L1.176|
0000b0  bf00              NOP                            ;1802
                  |L1.178|
0000b2  48d7              LDR      r0,|L1.1040|
0000b4  7800              LDRB     r0,[r0,#0]            ;1806  ; nMaxSyncMan
0000b6  f7fffffe          BL       CheckSmSettings
0000ba  4604              MOV      r4,r0                 ;1806
0000bc  bf00              NOP                            ;1807
                  |L1.190|
0000be  bf00              NOP                            ;1783
0000c0  2c00              CMP      r4,#0                 ;1811
0000c2  d17d              BNE      |L1.448|
0000c4  2000              MOVS     r0,#0                 ;1814
0000c6  49d3              LDR      r1,|L1.1044|
0000c8  8008              STRH     r0,[r1,#0]            ;1814
0000ca  4630              MOV      r0,r6                 ;1815
0000cc  2e34              CMP      r6,#0x34              ;1815
0000ce  d078              BEQ      |L1.450|
0000d0  dc1e              BGT      |L1.272|
0000d2  2822              CMP      r0,#0x22              ;1815
0000d4  d076              BEQ      |L1.452|
0000d6  dc0e              BGT      |L1.246|
0000d8  2814              CMP      r0,#0x14              ;1815
0000da  d074              BEQ      |L1.454|
0000dc  dc06              BGT      |L1.236|
0000de  2811              CMP      r0,#0x11              ;1815
0000e0  d072              BEQ      |L1.456|
0000e2  2812              CMP      r0,#0x12              ;1815
0000e4  d079              BEQ      |L1.474|
0000e6  2813              CMP      r0,#0x13              ;1815
                  |L1.232|
0000e8  d170              BNE      |L1.460|
0000ea  e02a              B        |L1.322|
                  |L1.236|
0000ec  2818              CMP      r0,#0x18              ;1815
0000ee  d06e              BEQ      |L1.462|
0000f0  2821              CMP      r0,#0x21              ;1815
0000f2  d1f9              BNE      |L1.232|
0000f4  e115              B        |L1.802|
                  |L1.246|
0000f6  2828              CMP      r0,#0x28              ;1815
0000f8  d06a              BEQ      |L1.464|
0000fa  dc04              BGT      |L1.262|
0000fc  2823              CMP      r0,#0x23              ;1815
0000fe  d068              BEQ      |L1.466|
000100  2824              CMP      r0,#0x24              ;1815
000102  d1f1              BNE      |L1.232|
000104  e08e              B        |L1.548|
                  |L1.262|
000106  2831              CMP      r0,#0x31              ;1815
000108  d04a              BEQ      |L1.416|
00010a  2832              CMP      r0,#0x32              ;1815
00010c  d1ec              BNE      |L1.232|
00010e  e137              B        |L1.896|
                  |L1.272|
000110  2848              CMP      r0,#0x48              ;1815
000112  d07d              BEQ      |L1.528|
000114  dc0c              BGT      |L1.304|
000116  2842              CMP      r0,#0x42              ;1815
000118  d07b              BEQ      |L1.530|
00011a  dc04              BGT      |L1.294|
00011c  2838              CMP      r0,#0x38              ;1815
00011e  d079              BEQ      |L1.532|
000120  2841              CMP      r0,#0x41              ;1815
000122  d1e1              BNE      |L1.232|
000124  e0ef              B        |L1.774|
                  |L1.294|
000126  2843              CMP      r0,#0x43              ;1815
000128  d075              BEQ      |L1.534|
00012a  2844              CMP      r0,#0x44              ;1815
00012c  d1dc              BNE      |L1.232|
00012e  e104              B        |L1.826|
                  |L1.304|
000130  3881              SUBS     r0,r0,#0x81           ;1815
000132  2808              CMP      r0,#8                 ;1815
000134  d24a              BCS      |L1.460|
000136  e8dff000          TBB      [pc,r0]               ;1815
00013a  dac6              DCB      0xda,0xc6
00013c  f1be4949          DCB      0xf1,0xbe,0x49,0x49
000140  49f0              DCB      0x49,0xf0
                  |L1.322|
000142  2001              MOVS     r0,#1                 ;1819
000144  49b4              LDR      r1,|L1.1048|
000146  7008              STRB     r0,[r1,#0]            ;1819
000148  2002              MOVS     r0,#2                 ;1821
00014a  f7fffffe          BL       CheckSmSettings
00014e  b120              CBZ      r0,|L1.346|
000150  2000              MOVS     r0,#0                 ;1823
000152  49b1              LDR      r1,|L1.1048|
000154  7008              STRB     r0,[r1,#0]            ;1823
000156  2415              MOVS     r4,#0x15              ;1824
000158  e118              B        |L1.908|
                  |L1.346|
00015a  2000              MOVS     r0,#0                 ;1830
00015c  f7fffffe          BL       ResetALEventMask
000160  f7fffffe          BL       MBX_StartMailboxHandler
000164  4604              MOV      r4,r0                 ;1836
000166  b94c              CBNZ     r4,|L1.380|
000168  2000              MOVS     r0,#0                 ;1839
00016a  49a5              LDR      r1,|L1.1024|
00016c  7008              STRB     r0,[r1,#0]            ;1839
00016e  f7fffffe          BL       APPL_StartMailboxHandler
000172  4604              MOV      r4,r0                 ;1845
000174  b914              CBNZ     r4,|L1.380|
000176  2001              MOVS     r0,#1                 ;1849
000178  49a8              LDR      r1,|L1.1052|
00017a  7008              STRB     r0,[r1,#0]            ;1849
                  |L1.380|
00017c  b144              CBZ      r4,|L1.400|
00017e  2cff              CMP      r4,#0xff              ;1853
000180  d006              BEQ      |L1.400|
000182  489f              LDR      r0,|L1.1024|
000184  7800              LDRB     r0,[r0,#0]            ;1856  ; bApplEsmPending
000186  b908              CBNZ     r0,|L1.396|
000188  f7fffffe          BL       APPL_StopMailboxHandler
                  |L1.396|
00018c  f7fffffe          BL       MBX_StopMailboxHandler
                  |L1.400|
000190  2003              MOVS     r0,#3                 ;1865
000192  f7fffffe          BL       BL_Start
000196  b114              CBZ      r4,|L1.414|
000198  2000              MOVS     r0,#0                 ;1869
00019a  499f              LDR      r1,|L1.1048|
00019c  7008              STRB     r0,[r1,#0]            ;1869
                  |L1.414|
00019e  e0f5              B        |L1.908|
                  |L1.416|
0001a0  489d              LDR      r0,|L1.1048|
0001a2  7800              LDRB     r0,[r0,#0]            ;1878  ; bBootMode
0001a4  b148              CBZ      r0,|L1.442|
0001a6  2000              MOVS     r0,#0                 ;1880
0001a8  499b              LDR      r1,|L1.1048|
0001aa  7008              STRB     r0,[r1,#0]            ;1880
0001ac  f7fffffe          BL       ResetALEventMask
0001b0  f7fffffe          BL       MBX_StopMailboxHandler
0001b4  f7fffffe          BL       APPL_StopMailboxHandler
0001b8  4604              MOV      r4,r0                 ;1886
                  |L1.442|
0001ba  f7fffffe          BL       BL_Stop
0001be  e009              B        |L1.468|
                  |L1.448|
0001c0  e0e5              B        |L1.910|
                  |L1.450|
0001c2  e0de              B        |L1.898|
                  |L1.452|
0001c4  e0b8              B        |L1.824|
                  |L1.454|
0001c6  e0d5              B        |L1.884|
                  |L1.456|
0001c8  e0b3              B        |L1.818|
0001ca  e006              B        |L1.474|
                  |L1.460|
0001cc  e0dc              B        |L1.904|
                  |L1.462|
0001ce  e0d2              B        |L1.886|
                  |L1.464|
0001d0  e0d2              B        |L1.888|
                  |L1.466|
0001d2  e0d2              B        |L1.890|
                  |L1.468|
0001d4  f7fffffe          BL       BackToInitTransition
0001d8  e0d8              B        |L1.908|
                  |L1.474|
0001da  f7fffffe          BL       UpdateEEPROMLoadedState
0001de  4890              LDR      r0,|L1.1056|
0001e0  7800              LDRB     r0,[r0,#0]            ;1901  ; EepromLoaded
0001e2  b900              CBNZ     r0,|L1.486|
0001e4  2451              MOVS     r4,#0x51              ;1904
                  |L1.486|
0001e6  b9e4              CBNZ     r4,|L1.546|
0001e8  f7fffffe          BL       MBX_StartMailboxHandler
0001ec  4604              MOV      r4,r0                 ;1912
0001ee  b94c              CBNZ     r4,|L1.516|
0001f0  2000              MOVS     r0,#0                 ;1915
0001f2  4983              LDR      r1,|L1.1024|
0001f4  7008              STRB     r0,[r1,#0]            ;1915
0001f6  f7fffffe          BL       APPL_StartMailboxHandler
0001fa  4604              MOV      r4,r0                 ;1920
0001fc  b914              CBNZ     r4,|L1.516|
0001fe  2001              MOVS     r0,#1                 ;1923
000200  4986              LDR      r1,|L1.1052|
000202  7008              STRB     r0,[r1,#0]            ;1923
                  |L1.516|
000204  b16c              CBZ      r4,|L1.546|
000206  2cff              CMP      r4,#0xff              ;1927
000208  d00b              BEQ      |L1.546|
00020a  487d              LDR      r0,|L1.1024|
00020c  7800              LDRB     r0,[r0,#0]            ;1930  ; bApplEsmPending
00020e  e003              B        |L1.536|
                  |L1.528|
000210  e026              B        |L1.608|
                  |L1.530|
000212  e064              B        |L1.734|
                  |L1.532|
000214  e0b6              B        |L1.900|
                  |L1.534|
000216  e0b1              B        |L1.892|
                  |L1.536|
000218  b908              CBNZ     r0,|L1.542|
00021a  f7fffffe          BL       APPL_StopMailboxHandler
                  |L1.542|
00021e  f7fffffe          BL       MBX_StopMailboxHandler
                  |L1.546|
000222  e0b3              B        |L1.908|
                  |L1.548|
000224  f7fffffe          BL       StartInputHandler
000228  4604              MOV      r4,r0                 ;1944
00022a  b974              CBNZ     r4,|L1.586|
00022c  2000              MOVS     r0,#0                 ;1947
00022e  4974              LDR      r1,|L1.1024|
000230  7008              STRB     r0,[r1,#0]            ;1947
000232  487c              LDR      r0,|L1.1060|
000234  f7fffffe          BL       APPL_StartInputHandler
000238  4604              MOV      r4,r0                 ;1948
00023a  b934              CBNZ     r4,|L1.586|
00023c  4879              LDR      r0,|L1.1060|
00023e  8800              LDRH     r0,[r0,#0]            ;1955  ; u16ALEventMask
000240  f7fffffe          BL       SetALEventMask
000244  2001              MOVS     r0,#1                 ;1957
000246  4978              LDR      r1,|L1.1064|
000248  7008              STRB     r0,[r1,#0]            ;1957
                  |L1.586|
00024a  b144              CBZ      r4,|L1.606|
00024c  2cff              CMP      r4,#0xff              ;1962
00024e  d006              BEQ      |L1.606|
000250  486b              LDR      r0,|L1.1024|
000252  7800              LDRB     r0,[r0,#0]            ;1964  ; bApplEsmPending
000254  b908              CBNZ     r0,|L1.602|
000256  f7fffffe          BL       APPL_StopInputHandler
                  |L1.602|
00025a  f7fffffe          BL       StopInputHandler
                  |L1.606|
00025e  e095              B        |L1.908|
                  |L1.608|
000260  f1b80f00          CMP      r8,#0                 ;1978
000264  d00e              BEQ      |L1.644|
000266  4868              LDR      r0,|L1.1032|
000268  8800              LDRH     r0,[r0,#0]            ;1980  ; nPdOutputSize
00026a  2800              CMP      r0,#0                 ;1980
00026c  dd03              BLE      |L1.630|
00026e  2002              MOVS     r0,#2                 ;1982
000270  f7fffffe          BL       EnableSyncManChannel
000274  e006              B        |L1.644|
                  |L1.630|
000276  4865              LDR      r0,|L1.1036|
000278  8800              LDRH     r0,[r0,#0]            ;1985  ; nPdInputSize
00027a  2800              CMP      r0,#0                 ;1985
00027c  dd02              BLE      |L1.644|
00027e  2003              MOVS     r0,#3                 ;1987
000280  f7fffffe          BL       EnableSyncManChannel
                  |L1.644|
000284  f7fffffe          BL       StartOutputHandler
000288  4604              MOV      r4,r0                 ;1993
00028a  b94c              CBNZ     r4,|L1.672|
00028c  2000              MOVS     r0,#0                 ;1996
00028e  495c              LDR      r1,|L1.1024|
000290  7008              STRB     r0,[r1,#0]            ;1996
000292  f7fffffe          BL       APPL_StartOutputHandler
000296  4604              MOV      r4,r0                 ;1997
000298  b914              CBNZ     r4,|L1.672|
00029a  2001              MOVS     r0,#1                 ;2002
00029c  4963              LDR      r1,|L1.1068|
00029e  7008              STRB     r0,[r1,#0]            ;2002
                  |L1.672|
0002a0  b144              CBZ      r4,|L1.692|
0002a2  2cff              CMP      r4,#0xff              ;2007
0002a4  d006              BEQ      |L1.692|
0002a6  4856              LDR      r0,|L1.1024|
0002a8  7800              LDRB     r0,[r0,#0]            ;2009  ; bApplEsmPending
0002aa  b908              CBNZ     r0,|L1.688|
0002ac  f7fffffe          BL       APPL_StopOutputHandler
                  |L1.688|
0002b0  f7fffffe          BL       StopOutputHandler
                  |L1.692|
0002b4  e06a              B        |L1.908|
0002b6  f7fffffe          BL       APPL_StopOutputHandler
0002ba  f7fffffe          BL       StopOutputHandler
0002be  2000              MOVS     r0,#0                 ;2025
0002c0  494f              LDR      r1,|L1.1024|
0002c2  7008              STRB     r0,[r1,#0]            ;2025
0002c4  e062              B        |L1.908|
0002c6  f7fffffe          BL       APPL_StopOutputHandler
0002ca  4604              MOV      r4,r0                 ;2031
0002cc  f7fffffe          BL       StopOutputHandler
0002d0  2000              MOVS     r0,#0                 ;2035
0002d2  494b              LDR      r1,|L1.1024|
0002d4  7008              STRB     r0,[r1,#0]            ;2035
0002d6  b104              CBZ      r4,|L1.730|
0002d8  e058              B        |L1.908|
                  |L1.730|
0002da  2642              MOVS     r6,#0x42              ;2042
0002dc  bf00              NOP                            ;2044
                  |L1.734|
0002de  f7fffffe          BL       APPL_StopInputHandler
0002e2  f7fffffe          BL       StopInputHandler
0002e6  2000              MOVS     r0,#0                 ;2050
0002e8  4945              LDR      r1,|L1.1024|
0002ea  7008              STRB     r0,[r1,#0]            ;2050
0002ec  e04e              B        |L1.908|
0002ee  f7fffffe          BL       APPL_StopOutputHandler
0002f2  4604              MOV      r4,r0                 ;2056
0002f4  f7fffffe          BL       StopOutputHandler
0002f8  2000              MOVS     r0,#0                 ;2060
0002fa  4941              LDR      r1,|L1.1024|
0002fc  7008              STRB     r0,[r1,#0]            ;2060
0002fe  b104              CBZ      r4,|L1.770|
000300  e044              B        |L1.908|
                  |L1.770|
000302  2641              MOVS     r6,#0x41              ;2067
000304  bf00              NOP                            ;2069
                  |L1.774|
000306  f7fffffe          BL       APPL_StopInputHandler
00030a  4604              MOV      r4,r0                 ;2071
00030c  f7fffffe          BL       StopInputHandler
000310  2000              MOVS     r0,#0                 ;2075
000312  493b              LDR      r1,|L1.1024|
000314  7008              STRB     r0,[r1,#0]            ;2075
000316  b114              CBZ      r4,|L1.798|
000318  e038              B        |L1.908|
00031a  e00f              B        |L1.828|
00031c  e02f              B        |L1.894|
                  |L1.798|
00031e  2621              MOVS     r6,#0x21              ;2081
000320  bf00              NOP                            ;2083
                  |L1.802|
000322  f7fffffe          BL       MBX_StopMailboxHandler
000326  f7fffffe          BL       APPL_StopMailboxHandler
00032a  4604              MOV      r4,r0                 ;2085
00032c  f7fffffe          BL       BackToInitTransition
000330  e02c              B        |L1.908|
                  |L1.818|
000332  f7fffffe          BL       BackToInitTransition
000336  bf00              NOP                            ;2092
                  |L1.824|
000338  bf00              NOP                            ;2093
                  |L1.826|
00033a  bf00              NOP                            ;2094
                  |L1.828|
00033c  f1b80f00          CMP      r8,#0                 ;2095
000340  d002              BEQ      |L1.840|
000342  4630              MOV      r0,r6                 ;2097
000344  f7fffffe          BL       APPL_AckErrorInd
                  |L1.840|
000348  482e              LDR      r0,|L1.1028|
00034a  7800              LDRB     r0,[r0,#0]            ;2102  ; nAlStatus
00034c  f000000c          AND      r0,r0,#0xc            ;2102
000350  b170              CBZ      r0,|L1.880|
000352  482d              LDR      r0,|L1.1032|
000354  8800              LDRH     r0,[r0,#0]            ;2104  ; nPdOutputSize
000356  2800              CMP      r0,#0                 ;2104
000358  dd03              BLE      |L1.866|
00035a  2002              MOVS     r0,#2                 ;2106
00035c  f7fffffe          BL       EnableSyncManChannel
000360  e006              B        |L1.880|
                  |L1.866|
000362  482a              LDR      r0,|L1.1036|
000364  8800              LDRH     r0,[r0,#0]            ;2109  ; nPdInputSize
000366  2800              CMP      r0,#0                 ;2109
000368  dd02              BLE      |L1.880|
00036a  2003              MOVS     r0,#3                 ;2111
00036c  f7fffffe          BL       EnableSyncManChannel
                  |L1.880|
000370  24fe              MOVS     r4,#0xfe              ;2115
000372  e00b              B        |L1.908|
                  |L1.884|
000374  bf00              NOP                            ;2119
                  |L1.886|
000376  bf00              NOP                            ;2120
                  |L1.888|
000378  bf00              NOP                            ;2121
                  |L1.890|
00037a  bf00              NOP                            ;2122
                  |L1.892|
00037c  bf00              NOP                            ;2123
                  |L1.894|
00037e  bf00              NOP                            ;2124
                  |L1.896|
000380  bf00              NOP                            ;2125
                  |L1.898|
000382  bf00              NOP                            ;2126
                  |L1.900|
000384  2411              MOVS     r4,#0x11              ;2127
000386  e001              B        |L1.908|
                  |L1.904|
000388  2412              MOVS     r4,#0x12              ;2131
00038a  bf00              NOP                            ;2132
                  |L1.908|
00038c  e024              B        |L1.984|
                  |L1.910|
00038e  481d              LDR      r0,|L1.1028|
000390  7800              LDRB     r0,[r0,#0]            ;2139  ; nAlStatus
000392  2802              CMP      r0,#2                 ;2139
000394  d00d              BEQ      |L1.946|
000396  2804              CMP      r0,#4                 ;2139
000398  d006              BEQ      |L1.936|
00039a  2808              CMP      r0,#8                 ;2139
00039c  d11c              BNE      |L1.984|
00039e  f7fffffe          BL       APPL_StopOutputHandler
0003a2  f7fffffe          BL       StopOutputHandler
0003a6  bf00              NOP                            ;2145
                  |L1.936|
0003a8  f7fffffe          BL       APPL_StopInputHandler
0003ac  f7fffffe          BL       StopInputHandler
0003b0  bf00              NOP                            ;2150
                  |L1.946|
0003b2  2c16              CMP      r4,#0x16              ;2151
0003b4  d10d              BNE      |L1.978|
0003b6  f7fffffe          BL       MBX_StopMailboxHandler
0003ba  f7fffffe          BL       APPL_StopMailboxHandler
0003be  2000              MOVS     r0,#0                 ;2158
0003c0  f7fffffe          BL       DisableSyncManChannel
0003c4  2001              MOVS     r0,#1                 ;2161
0003c6  f7fffffe          BL       DisableSyncManChannel
0003ca  2001              MOVS     r0,#1                 ;2164
0003cc  490d              LDR      r1,|L1.1028|
0003ce  7008              STRB     r0,[r1,#0]            ;2164
0003d0  e002              B        |L1.984|
                  |L1.978|
0003d2  2002              MOVS     r0,#2                 ;2168
0003d4  490b              LDR      r1,|L1.1028|
0003d6  7008              STRB     r0,[r1,#0]            ;2168
                  |L1.984|
0003d8  2cff              CMP      r4,#0xff              ;2173
0003da  d149              BNE      |L1.1136|
0003dc  2001              MOVS     r0,#1                 ;2177
0003de  4914              LDR      r1,|L1.1072|
0003e0  7008              STRB     r0,[r1,#0]            ;2177
0003e2  480c              LDR      r0,|L1.1044|
0003e4  8006              STRH     r6,[r0,#0]            ;2179
0003e6  8800              LDRH     r0,[r0,#0]            ;2182  ; nEcatStateTrans
0003e8  2812              CMP      r0,#0x12              ;2182
0003ea  d023              BEQ      |L1.1076|
0003ec  2813              CMP      r0,#0x13              ;2182
0003ee  d022              BEQ      |L1.1078|
0003f0  2824              CMP      r0,#0x24              ;2182
0003f2  d025              BEQ      |L1.1088|
0003f4  2848              CMP      r0,#0x48              ;2182
0003f6  d129              BNE      |L1.1100|
0003f8  e023              B        |L1.1090|
0003fa  0000              DCW      0x0000
                  |L1.1020|
                          DCD      EsmTimeoutCounter
                  |L1.1024|
                          DCD      bApplEsmPending
                  |L1.1028|
                          DCD      nAlStatus
                  |L1.1032|
                          DCD      nPdOutputSize
                  |L1.1036|
                          DCD      nPdInputSize
                  |L1.1040|
                          DCD      nMaxSyncMan
                  |L1.1044|
                          DCD      nEcatStateTrans
                  |L1.1048|
                          DCD      bBootMode
                  |L1.1052|
                          DCD      bMbxRunning
                  |L1.1056|
                          DCD      EepromLoaded
                  |L1.1060|
                          DCD      u16ALEventMask
                  |L1.1064|
                          DCD      bEcatInputUpdateRunning
                  |L1.1068|
                          DCD      bEcatOutputUpdateRunning
                  |L1.1072|
                          DCD      bEcatWaitForAlControlRes
                  |L1.1076|
000434  bf00              NOP                            ;2185
                  |L1.1078|
000436  f44f60fa          MOV      r0,#0x7d0             ;2186
00043a  4933              LDR      r1,|L1.1288|
00043c  8008              STRH     r0,[r1,#0]            ;2186
00043e  e009              B        |L1.1108|
                  |L1.1088|
000440  bf00              NOP                            ;2189
                  |L1.1090|
000442  f2423028          MOV      r0,#0x2328            ;2190
000446  4930              LDR      r1,|L1.1288|
000448  8008              STRH     r0,[r1,#0]            ;2190
00044a  e003              B        |L1.1108|
                  |L1.1100|
00044c  20c8              MOVS     r0,#0xc8              ;2193
00044e  492e              LDR      r1,|L1.1288|
000450  8008              STRH     r0,[r1,#0]            ;2193
000452  bf00              NOP                            ;2194
                  |L1.1108|
000454  bf00              NOP                            ;2187
000456  482c              LDR      r0,|L1.1288|
000458  f9b00000          LDRSH    r0,[r0,#0]            ;2196  ; EsmTimeoutCounter
00045c  210a              MOVS     r1,#0xa               ;2196
00045e  fb90f0f1          SDIV     r0,r0,r1              ;2196
000462  4929              LDR      r1,|L1.1288|
000464  8809              LDRH     r1,[r1,#0]            ;2196  ; EsmTimeoutCounter
000466  1a08              SUBS     r0,r1,r0              ;2196
000468  b200              SXTH     r0,r0                 ;2196
00046a  4927              LDR      r1,|L1.1288|
00046c  8008              STRH     r0,[r1,#0]            ;2196
00046e  e049              B        |L1.1284|
                  |L1.1136|
000470  4826              LDR      r0,|L1.1292|
000472  7800              LDRB     r0,[r0,#0]            ;2199  ; nAlStatus
000474  f000000f          AND      r0,r0,#0xf            ;2199
000478  42a8              CMP      r0,r5                 ;2199
00047a  d03b              BEQ      |L1.1268|
00047c  b904              CBNZ     r4,|L1.1152|
00047e  b1df              CBZ      r7,|L1.1208|
                  |L1.1152|
000480  4822              LDR      r0,|L1.1292|
000482  7800              LDRB     r0,[r0,#0]            ;2203  ; nAlStatus
000484  4328              ORRS     r0,r0,r5              ;2203
000486  f0000008          AND      r0,r0,#8              ;2203
00048a  b1a8              CBZ      r0,|L1.1208|
00048c  4820              LDR      r0,|L1.1296|
00048e  7800              LDRB     r0,[r0,#0]            ;2209  ; bEcatOutputUpdateRunning
000490  b118              CBZ      r0,|L1.1178|
000492  f7fffffe          BL       APPL_StopOutputHandler
000496  f7fffffe          BL       StopOutputHandler
                  |L1.1178|
00049a  481e              LDR      r0,|L1.1300|
00049c  8800              LDRH     r0,[r0,#0]            ;2216  ; nPdOutputSize
00049e  2800              CMP      r0,#0                 ;2216
0004a0  dd03              BLE      |L1.1194|
0004a2  2002              MOVS     r0,#2                 ;2219
0004a4  f7fffffe          BL       DisableSyncManChannel
0004a8  e006              B        |L1.1208|
                  |L1.1194|
0004aa  481b              LDR      r0,|L1.1304|
0004ac  8800              LDRH     r0,[r0,#0]            ;2222  ; nPdInputSize
0004ae  2800              CMP      r0,#0                 ;2222
0004b0  dd02              BLE      |L1.1208|
0004b2  2003              MOVS     r0,#3                 ;2225
0004b4  f7fffffe          BL       DisableSyncManChannel
                  |L1.1208|
0004b8  b16c              CBZ      r4,|L1.1238|
0004ba  4814              LDR      r0,|L1.1292|
0004bc  7800              LDRB     r0,[r0,#0]            ;2231  ; nAlStatus
0004be  2808              CMP      r0,#8                 ;2231
0004c0  d102              BNE      |L1.1224|
0004c2  2004              MOVS     r0,#4                 ;2233
0004c4  4911              LDR      r1,|L1.1292|
0004c6  7008              STRB     r0,[r1,#0]            ;2233
                  |L1.1224|
0004c8  4810              LDR      r0,|L1.1292|
0004ca  7800              LDRB     r0,[r0,#0]            ;2237  ; nAlStatus
0004cc  f0400010          ORR      r0,r0,#0x10           ;2237
0004d0  490e              LDR      r1,|L1.1292|
0004d2  7008              STRB     r0,[r1,#0]            ;2237
0004d4  e005              B        |L1.1250|
                  |L1.1238|
0004d6  b117              CBZ      r7,|L1.1246|
0004d8  463c              MOV      r4,r7                 ;2245
0004da  f0450510          ORR      r5,r5,#0x10           ;2246
                  |L1.1246|
0004de  480b              LDR      r0,|L1.1292|
0004e0  7005              STRB     r5,[r0,#0]            ;2249
                  |L1.1250|
0004e2  2000              MOVS     r0,#0                 ;2252
0004e4  490d              LDR      r1,|L1.1308|
0004e6  7008              STRB     r0,[r1,#0]            ;2252
0004e8  4621              MOV      r1,r4                 ;2255
0004ea  4808              LDR      r0,|L1.1292|
0004ec  7800              LDRB     r0,[r0,#0]            ;2255  ; nAlStatus
0004ee  f7fffffe          BL       SetALStatus
0004f2  e007              B        |L1.1284|
                  |L1.1268|
0004f4  2000              MOVS     r0,#0                 ;2261
0004f6  4909              LDR      r1,|L1.1308|
0004f8  7008              STRB     r0,[r1,#0]            ;2261
0004fa  2100              MOVS     r1,#0                 ;2265
0004fc  4803              LDR      r0,|L1.1292|
0004fe  7800              LDRB     r0,[r0,#0]            ;2265  ; nAlStatus
000500  f7fffffe          BL       SetALStatus
                  |L1.1284|
000504  bf00              NOP      
000506  e59c              B        |L1.66|
;;;2272   
                          ENDP

                  |L1.1288|
                          DCD      EsmTimeoutCounter
                  |L1.1292|
                          DCD      nAlStatus
                  |L1.1296|
                          DCD      bEcatOutputUpdateRunning
                  |L1.1300|
                          DCD      nPdOutputSize
                  |L1.1304|
                          DCD      nPdInputSize
                  |L1.1308|
                          DCD      bEcatWaitForAlControlRes

                          AREA ||i.AL_ControlRes||, CODE, READONLY, ALIGN=2

                  AL_ControlRes PROC
;;;2279     *////////////////////////////////////////////////////////////////////////////////////////
;;;2280   void AL_ControlRes(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2281   {
;;;2282       if(bEcatWaitForAlControlRes)
000002  4884              LDR      r0,|L2.532|
000004  7800              LDRB     r0,[r0,#0]  ; bEcatWaitForAlControlRes
000006  2800              CMP      r0,#0
000008  d074              BEQ      |L2.244|
;;;2283       {
;;;2284           UINT16 result = 0;
00000a  2400              MOVS     r4,#0
;;;2285           UINT8 Status = 0;
00000c  2500              MOVS     r5,#0
;;;2286           UINT16 StatusCode = 0;
00000e  2600              MOVS     r6,#0
;;;2287   
;;;2288           if(EsmTimeoutCounter == 0)
000010  4881              LDR      r0,|L2.536|
000012  8800              LDRH     r0,[r0,#0]  ; EsmTimeoutCounter
000014  2800              CMP      r0,#0
000016  d16f              BNE      |L2.248|
;;;2289           {
;;;2290               Status =  (UINT8)(nEcatStateTrans >> 4);
000018  4880              LDR      r0,|L2.540|
00001a  8800              LDRH     r0,[r0,#0]  ; nEcatStateTrans
00001c  f3c01507          UBFX     r5,r0,#4,#8
;;;2291   
;;;2292               /* ESM timeout expired*/
;;;2293               switch(nEcatStateTrans)
000020  487e              LDR      r0,|L2.540|
000022  8800              LDRH     r0,[r0,#0]  ; nEcatStateTrans
000024  2812              CMP      r0,#0x12
000026  d006              BEQ      |L2.54|
000028  2813              CMP      r0,#0x13
00002a  d005              BEQ      |L2.56|
00002c  2824              CMP      r0,#0x24
00002e  d015              BEQ      |L2.92|
000030  2848              CMP      r0,#0x48
000032  d15e              BNE      |L2.242|
000034  e024              B        |L2.128|
                  |L2.54|
;;;2294               {
;;;2295                   case INIT_2_PREOP:
;;;2296                   case INIT_2_BOOT:
000036  bf00              NOP      
                  |L2.56|
;;;2297   
;;;2298                           if (!bApplEsmPending)
000038  4879              LDR      r0,|L2.544|
00003a  7800              LDRB     r0,[r0,#0]  ; bApplEsmPending
00003c  b908              CBNZ     r0,|L2.66|
;;;2299                           {
;;;2300                               APPL_StopMailboxHandler();
00003e  f7fffffe          BL       APPL_StopMailboxHandler
                  |L2.66|
;;;2301                           }
;;;2302   
;;;2303                       MBX_StopMailboxHandler();
000042  f7fffffe          BL       MBX_StopMailboxHandler
;;;2304                       /*ECATCHANGE_START(V5.13) ESM1*/
;;;2305                       if((u8LocalErrorState & STATE_MASK) == STATE_INIT)
000046  4877              LDR      r0,|L2.548|
000048  7800              LDRB     r0,[r0,#0]  ; u8LocalErrorState
00004a  f000000f          AND      r0,r0,#0xf
00004e  2801              CMP      r0,#1
000050  d102              BNE      |L2.88|
;;;2306                           /*ECATCHANGE_END(V5.13) ESM1*/
;;;2307                       {
;;;2308                           /*Set application specified error*/
;;;2309                           StatusCode = u16LocalErrorCode;
000052  4875              LDR      r0,|L2.552|
000054  8806              LDRH     r6,[r0,#0]  ; u16LocalErrorCode
000056  e000              B        |L2.90|
                  |L2.88|
;;;2310                       }
;;;2311                       else
;;;2312                       {
;;;2313                           /*Set unspecified error*/
;;;2314                           StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
000058  2601              MOVS     r6,#1
                  |L2.90|
;;;2315                       }
;;;2316                   break;
00005a  e04a              B        |L2.242|
                  |L2.92|
;;;2317                   case PREOP_2_SAFEOP:
;;;2318   
;;;2319                           if (!bApplEsmPending)
00005c  4870              LDR      r0,|L2.544|
00005e  7800              LDRB     r0,[r0,#0]  ; bApplEsmPending
000060  b908              CBNZ     r0,|L2.102|
;;;2320                           {
;;;2321                               APPL_StopInputHandler();
000062  f7fffffe          BL       APPL_StopInputHandler
                  |L2.102|
;;;2322                           }
;;;2323   
;;;2324                       StopInputHandler();
000066  f7fffffe          BL       StopInputHandler
;;;2325                       
;;;2326                       /*ECATCHANGE_START(V5.13) ESM1*/
;;;2327                       if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
00006a  486e              LDR      r0,|L2.548|
00006c  7800              LDRB     r0,[r0,#0]  ; u8LocalErrorState
00006e  f000000f          AND      r0,r0,#0xf
000072  2802              CMP      r0,#2
000074  d102              BNE      |L2.124|
;;;2328                           /*ECATCHANGE_END(V5.13) ESM1*/
;;;2329                       {
;;;2330                           /*Set application specified error*/
;;;2331                           StatusCode = u16LocalErrorCode;
000076  486c              LDR      r0,|L2.552|
000078  8806              LDRH     r6,[r0,#0]  ; u16LocalErrorCode
00007a  e000              B        |L2.126|
                  |L2.124|
;;;2332                       }
;;;2333                       else
;;;2334                       {
;;;2335                           /*Set unspecified error*/
;;;2336                           StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
00007c  2601              MOVS     r6,#1
                  |L2.126|
;;;2337                       }
;;;2338                   break;
00007e  e038              B        |L2.242|
                  |L2.128|
;;;2339                   case SAFEOP_2_OP:
;;;2340                       if(bDcSyncActive)
000080  486a              LDR      r0,|L2.556|
000082  7800              LDRB     r0,[r0,#0]  ; bDcSyncActive
000084  b1c0              CBZ      r0,|L2.184|
;;;2341                       {
;;;2342                           /*SafeOP to OP timeout expired check which AL status code need to be written*/
;;;2343                           if(!bDcRunning)
000086  486a              LDR      r0,|L2.560|
000088  7800              LDRB     r0,[r0,#0]  ; bDcRunning
00008a  b908              CBNZ     r0,|L2.144|
;;;2344                           {
;;;2345                               /*no Sync0 signal received*/
;;;2346                               StatusCode = ALSTATUSCODE_NOSYNCERROR;
00008c  262d              MOVS     r6,#0x2d
00008e  e027              B        |L2.224|
                  |L2.144|
;;;2347                           }
;;;2348                           else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
000090  4868              LDR      r0,|L2.564|
000092  7800              LDRB     r0,[r0,#0]  ; bEcatFirstOutputsReceived
000094  b928              CBNZ     r0,|L2.162|
000096  4868              LDR      r0,|L2.568|
000098  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
00009a  2800              CMP      r0,#0
00009c  dd01              BLE      |L2.162|
;;;2349                           {
;;;2350                               /*no process data received*/
;;;2351                               StatusCode = ALSTATUSCODE_SMWATCHDOG;
00009e  261b              MOVS     r6,#0x1b
0000a0  e01e              B        |L2.224|
                  |L2.162|
;;;2352                           }
;;;2353   /*ECATCHANGE_START(V5.13) ESM3*/
;;;2354                           else if (!bSmSyncSequenceValid)
0000a2  4866              LDR      r0,|L2.572|
0000a4  7800              LDRB     r0,[r0,#0]  ; bSmSyncSequenceValid
0000a6  b908              CBNZ     r0,|L2.172|
;;;2355                           {
;;;2356                               /*SM/Sync Sequence is not valid*/
;;;2357                               StatusCode = ALSTATUSCODE_SYNCERROR;
0000a8  261a              MOVS     r6,#0x1a
0000aa  e019              B        |L2.224|
                  |L2.172|
;;;2358                           }
;;;2359                           else
;;;2360                           {
;;;2361                               /*Set valid state transition even if timeout expired*/
;;;2362                               Status = STATE_OP;
0000ac  2508              MOVS     r5,#8
;;;2363                               StatusCode = 0;
0000ae  2600              MOVS     r6,#0
;;;2364                               /* Slave is OPERATIONAL */
;;;2365                               bEcatOutputUpdateRunning = TRUE;
0000b0  2001              MOVS     r0,#1
0000b2  4963              LDR      r1,|L2.576|
0000b4  7008              STRB     r0,[r1,#0]
0000b6  e013              B        |L2.224|
                  |L2.184|
;;;2366                           }
;;;2367   /*ECATCHANGE_END(V5.13) ESM3*/
;;;2368                       }
;;;2369                       else
;;;2370                       {
;;;2371                           if (nPdOutputSize > 0)
0000b8  485f              LDR      r0,|L2.568|
0000ba  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
0000bc  2800              CMP      r0,#0
0000be  dd01              BLE      |L2.196|
;;;2372                           {
;;;2373                               StatusCode = ALSTATUSCODE_SMWATCHDOG;
0000c0  261b              MOVS     r6,#0x1b
0000c2  e00d              B        |L2.224|
                  |L2.196|
;;;2374                           }
;;;2375                           else
;;;2376                           {
;;;2377                               /*ECATCHANGE_START(V5.13) ESM1*/
;;;2378                               if ((u8LocalErrorState & STATE_MASK) == STATE_SAFEOP)
0000c4  4857              LDR      r0,|L2.548|
0000c6  7800              LDRB     r0,[r0,#0]  ; u8LocalErrorState
0000c8  f000000f          AND      r0,r0,#0xf
0000cc  2804              CMP      r0,#4
0000ce  d102              BNE      |L2.214|
;;;2379                               {
;;;2380                                   /*Set application specified error*/
;;;2381                                   StatusCode = u16LocalErrorCode;
0000d0  4855              LDR      r0,|L2.552|
0000d2  8806              LDRH     r6,[r0,#0]  ; u16LocalErrorCode
0000d4  e004              B        |L2.224|
                  |L2.214|
;;;2382                               }
;;;2383                               else
;;;2384                                   /*ECATCHANGE_END(V5.13) ESM1*/
;;;2385                               {
;;;2386                                   /*Set valid state transition even if timeout expired*/
;;;2387                                   Status = STATE_OP;
0000d6  2508              MOVS     r5,#8
;;;2388                                   StatusCode = 0;
0000d8  2600              MOVS     r6,#0
;;;2389                                   /* Slave is OPERATIONAL */
;;;2390                                   bEcatOutputUpdateRunning = TRUE;
0000da  2001              MOVS     r0,#1
0000dc  4958              LDR      r1,|L2.576|
0000de  7008              STRB     r0,[r1,#0]
                  |L2.224|
;;;2391                               }
;;;2392                           }
;;;2393                       }
;;;2394   
;;;2395                       /*Stop handler on failed transition*/
;;;2396                       if(StatusCode != 0)
0000e0  b136              CBZ      r6,|L2.240|
;;;2397                       {
;;;2398                               if (!bApplEsmPending)
0000e2  484f              LDR      r0,|L2.544|
0000e4  7800              LDRB     r0,[r0,#0]  ; bApplEsmPending
0000e6  b908              CBNZ     r0,|L2.236|
;;;2399                               {
;;;2400                                   APPL_StopOutputHandler();
0000e8  f7fffffe          BL       APPL_StopOutputHandler
                  |L2.236|
;;;2401                               }
;;;2402   
;;;2403                           StopOutputHandler();
0000ec  f7fffffe          BL       StopOutputHandler
                  |L2.240|
;;;2404                       }
;;;2405                   break;
0000f0  bf00              NOP      
                  |L2.242|
0000f2  e081              B        |L2.504|
                  |L2.244|
0000f4  e08c              B        |L2.528|
0000f6  e7ff              B        |L2.248|
                  |L2.248|
;;;2406               }
;;;2407           } //ESM timeout
;;;2408           else
;;;2409           {
;;;2410               /*Call application specific transition function and complete transition it the function returns 0*/
;;;2411               switch(nEcatStateTrans)
0000f8  4848              LDR      r0,|L2.540|
0000fa  8800              LDRH     r0,[r0,#0]  ; nEcatStateTrans
0000fc  2812              CMP      r0,#0x12
0000fe  d006              BEQ      |L2.270|
000100  2813              CMP      r0,#0x13
000102  d005              BEQ      |L2.272|
000104  2824              CMP      r0,#0x24
000106  d01c              BEQ      |L2.322|
000108  2848              CMP      r0,#0x48
00010a  d174              BNE      |L2.502|
00010c  e030              B        |L2.368|
                  |L2.270|
;;;2412               {
;;;2413                   case INIT_2_PREOP:
;;;2414                   case INIT_2_BOOT:
00010e  bf00              NOP      
                  |L2.272|
;;;2415                       if(bApplEsmPending)
000110  4843              LDR      r0,|L2.544|
000112  7800              LDRB     r0,[r0,#0]  ; bApplEsmPending
000114  b1a0              CBZ      r0,|L2.320|
;;;2416                       {
;;;2417                           bApplEsmPending = FALSE;
000116  2000              MOVS     r0,#0
000118  4941              LDR      r1,|L2.544|
00011a  7008              STRB     r0,[r1,#0]
;;;2418                           /*APPL_StartMailboxHandler() need to be called*/
;;;2419                           result = APPL_StartMailboxHandler();
00011c  f7fffffe          BL       APPL_StartMailboxHandler
000120  4604              MOV      r4,r0
;;;2420   
;;;2421                           if(result == 0)
000122  b93c              CBNZ     r4,|L2.308|
;;;2422                           {
;;;2423                               /*The application specific transition was successful => set active mailbox handler indication*/
;;;2424                               bMbxRunning = TRUE;
000124  2001              MOVS     r0,#1
000126  4947              LDR      r1,|L2.580|
000128  7008              STRB     r0,[r1,#0]
;;;2425                               Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
00012a  483c              LDR      r0,|L2.540|
00012c  7800              LDRB     r0,[r0,#0]  ; nEcatStateTrans
00012e  f000050f          AND      r5,r0,#0xf
000132  e005              B        |L2.320|
                  |L2.308|
;;;2426                           }
;;;2427                           else
;;;2428                           {
;;;2429                               /*The application specific transition failed.
;;;2430                               (In pending case the application need to complete the transition)*/
;;;2431   
;;;2432                               if(result != NOERROR_INWORK)
000134  2cff              CMP      r4,#0xff
000136  d003              BEQ      |L2.320|
;;;2433                               {
;;;2434                                   APPL_StopMailboxHandler();
000138  f7fffffe          BL       APPL_StopMailboxHandler
;;;2435                                   MBX_StopMailboxHandler();
00013c  f7fffffe          BL       MBX_StopMailboxHandler
                  |L2.320|
;;;2436                               }
;;;2437                           }
;;;2438                       }
;;;2439                   break;
000140  e059              B        |L2.502|
                  |L2.322|
;;;2440                   case PREOP_2_SAFEOP:
;;;2441                       if(bApplEsmPending)
000142  4837              LDR      r0,|L2.544|
000144  7800              LDRB     r0,[r0,#0]  ; bApplEsmPending
000146  b190              CBZ      r0,|L2.366|
;;;2442                       {
;;;2443                           bApplEsmPending = FALSE;
000148  2000              MOVS     r0,#0
00014a  4935              LDR      r1,|L2.544|
00014c  7008              STRB     r0,[r1,#0]
;;;2444                           result = APPL_StartInputHandler(&u16ALEventMask);
00014e  483e              LDR      r0,|L2.584|
000150  f7fffffe          BL       APPL_StartInputHandler
000154  4604              MOV      r4,r0
;;;2445   
;;;2446                           if(result == 0)
000156  b924              CBNZ     r4,|L2.354|
;;;2447                           {
;;;2448                               bEcatInputUpdateRunning = TRUE;
000158  2001              MOVS     r0,#1
00015a  493c              LDR      r1,|L2.588|
00015c  7008              STRB     r0,[r1,#0]
;;;2449                               Status = STATE_SAFEOP;
00015e  2504              MOVS     r5,#4
000160  e005              B        |L2.366|
                  |L2.354|
;;;2450                           }
;;;2451                           else
;;;2452                           {
;;;2453                               /*The application specific transition failed.
;;;2454                               (In pending case the application need to complete the transition)*/
;;;2455   
;;;2456                               if(result != NOERROR_INWORK)
000162  2cff              CMP      r4,#0xff
000164  d003              BEQ      |L2.366|
;;;2457                               {
;;;2458                                   APPL_StopInputHandler();
000166  f7fffffe          BL       APPL_StopInputHandler
;;;2459                                   StopInputHandler();
00016a  f7fffffe          BL       StopInputHandler
                  |L2.366|
;;;2460                               }
;;;2461                           }
;;;2462                       }
;;;2463                   break;
00016e  e042              B        |L2.502|
                  |L2.368|
;;;2464                   case SAFEOP_2_OP:
;;;2465                      if(bApplEsmPending)
000170  482b              LDR      r0,|L2.544|
000172  7800              LDRB     r0,[r0,#0]  ; bApplEsmPending
000174  b328              CBZ      r0,|L2.450|
;;;2466                       {
;;;2467                           if(bDcSyncActive)
000176  482d              LDR      r0,|L2.556|
000178  7800              LDRB     r0,[r0,#0]  ; bDcSyncActive
00017a  b318              CBZ      r0,|L2.452|
;;;2468                           {
;;;2469                               if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i16WaitForPllRunningCnt)
00017c  4834              LDR      r0,|L2.592|
00017e  f9b00000          LDRSH    r0,[r0,#0]  ; i16WaitForPllRunningTimeout
000182  2800              CMP      r0,#0
000184  dd36              BLE      |L2.500|
000186  4832              LDR      r0,|L2.592|
000188  f9b00000          LDRSH    r0,[r0,#0]  ; i16WaitForPllRunningTimeout
00018c  4931              LDR      r1,|L2.596|
00018e  f9b11000          LDRSH    r1,[r1,#0]  ; i16WaitForPllRunningCnt
000192  4288              CMP      r0,r1
000194  dc2e              BGT      |L2.500|
;;;2470                               {
;;;2471                                   /*Pll sequence valid for 200ms (set in APPL_StartOutputHandler() )
;;;2472                                   acknowledge state transition to OP */
;;;2473   
;;;2474                                   i16WaitForPllRunningTimeout = 0;
000196  2000              MOVS     r0,#0
000198  492d              LDR      r1,|L2.592|
00019a  8008              STRH     r0,[r1,#0]
;;;2475                                   i16WaitForPllRunningCnt = 0;
00019c  492d              LDR      r1,|L2.596|
00019e  8008              STRH     r0,[r1,#0]
;;;2476   
;;;2477                                   bApplEsmPending = FALSE;
0001a0  491f              LDR      r1,|L2.544|
0001a2  7008              STRB     r0,[r1,#0]
;;;2478                                   result = APPL_StartOutputHandler();
0001a4  f7fffffe          BL       APPL_StartOutputHandler
0001a8  4604              MOV      r4,r0
;;;2479   
;;;2480                                   if(result == 0)
0001aa  b924              CBNZ     r4,|L2.438|
;;;2481                                   {
;;;2482                                       /* Slave is OPERATIONAL */
;;;2483                                       bEcatOutputUpdateRunning = TRUE;
0001ac  2001              MOVS     r0,#1
0001ae  4924              LDR      r1,|L2.576|
0001b0  7008              STRB     r0,[r1,#0]
;;;2484                                       Status = STATE_OP;
0001b2  2508              MOVS     r5,#8
0001b4  e01e              B        |L2.500|
                  |L2.438|
;;;2485                                   }
;;;2486                                   else
;;;2487                                   {
;;;2488                                       if(result != NOERROR_INWORK)
0001b6  2cff              CMP      r4,#0xff
0001b8  d01c              BEQ      |L2.500|
;;;2489                                       {
;;;2490                                           APPL_StopOutputHandler();
0001ba  f7fffffe          BL       APPL_StopOutputHandler
;;;2491                                           StopOutputHandler();
0001be  f7fffffe          BL       StopOutputHandler
                  |L2.450|
0001c2  e017              B        |L2.500|
                  |L2.452|
;;;2492                                       }
;;;2493                                   }
;;;2494                               }
;;;2495                           }
;;;2496                           else
;;;2497                           {
;;;2498                               if(nPdOutputSize == 0 || bEcatFirstOutputsReceived)
0001c4  481c              LDR      r0,|L2.568|
0001c6  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
0001c8  b110              CBZ      r0,|L2.464|
0001ca  481a              LDR      r0,|L2.564|
0001cc  7800              LDRB     r0,[r0,#0]  ; bEcatFirstOutputsReceived
0001ce  b188              CBZ      r0,|L2.500|
                  |L2.464|
;;;2499                               {
;;;2500                                   bApplEsmPending = FALSE;  
0001d0  2000              MOVS     r0,#0
0001d2  4913              LDR      r1,|L2.544|
0001d4  7008              STRB     r0,[r1,#0]
;;;2501                                   result = APPL_StartOutputHandler();
0001d6  f7fffffe          BL       APPL_StartOutputHandler
0001da  4604              MOV      r4,r0
;;;2502   
;;;2503                                   if(result == 0)
0001dc  b924              CBNZ     r4,|L2.488|
;;;2504                                   {
;;;2505                                       /* Slave is OPERATIONAL */
;;;2506                                       bEcatOutputUpdateRunning = TRUE;
0001de  2001              MOVS     r0,#1
0001e0  4917              LDR      r1,|L2.576|
0001e2  7008              STRB     r0,[r1,#0]
;;;2507                                       Status = STATE_OP;
0001e4  2508              MOVS     r5,#8
0001e6  e005              B        |L2.500|
                  |L2.488|
;;;2508                                   }
;;;2509                                   else
;;;2510                                   {
;;;2511                                       if(result != NOERROR_INWORK)
0001e8  2cff              CMP      r4,#0xff
0001ea  d003              BEQ      |L2.500|
;;;2512                                       {
;;;2513                                           APPL_StopOutputHandler();
0001ec  f7fffffe          BL       APPL_StopOutputHandler
;;;2514                                           StopOutputHandler();
0001f0  f7fffffe          BL       StopOutputHandler
                  |L2.500|
;;;2515                                       }
;;;2516                                   }
;;;2517                               }
;;;2518                           }       
;;;2519                       }             
;;;2520                   break;
0001f4  bf00              NOP      
                  |L2.502|
0001f6  bf00              NOP                            ;2439
                  |L2.504|
;;;2521               }//Switch - transition
;;;2522           }
;;;2523   
;;;2524           if(Status != 0)
0001f8  b14d              CBZ      r5,|L2.526|
;;;2525           {
;;;2526               /*Pending state transition finished => write AL Status and AL Status Code*/
;;;2527               bEcatWaitForAlControlRes = FALSE;
0001fa  2000              MOVS     r0,#0
0001fc  4905              LDR      r1,|L2.532|
0001fe  7008              STRB     r0,[r1,#0]
;;;2528   
;;;2529               if (StatusCode != 0)
000200  b10e              CBZ      r6,|L2.518|
;;;2530               {
;;;2531                   Status |= STATE_CHANGE;
000202  f0450510          ORR      r5,r5,#0x10
                  |L2.518|
;;;2532               }
;;;2533   
;;;2534               SetALStatus(Status,StatusCode);
000206  4631              MOV      r1,r6
000208  4628              MOV      r0,r5
00020a  f7fffffe          BL       SetALStatus
                  |L2.526|
;;;2535           }
;;;2536       }// Pending state transition (bEcatWaitForAlControlRes == true)
00020e  bf00              NOP      
                  |L2.528|
;;;2537   }
000210  bd70              POP      {r4-r6,pc}
;;;2538   
                          ENDP

000212  0000              DCW      0x0000
                  |L2.532|
                          DCD      bEcatWaitForAlControlRes
                  |L2.536|
                          DCD      EsmTimeoutCounter
                  |L2.540|
                          DCD      nEcatStateTrans
                  |L2.544|
                          DCD      bApplEsmPending
                  |L2.548|
                          DCD      u8LocalErrorState
                  |L2.552|
                          DCD      u16LocalErrorCode
                  |L2.556|
                          DCD      bDcSyncActive
                  |L2.560|
                          DCD      bDcRunning
                  |L2.564|
                          DCD      bEcatFirstOutputsReceived
                  |L2.568|
                          DCD      nPdOutputSize
                  |L2.572|
                          DCD      bSmSyncSequenceValid
                  |L2.576|
                          DCD      bEcatOutputUpdateRunning
                  |L2.580|
                          DCD      bMbxRunning
                  |L2.584|
                          DCD      u16ALEventMask
                  |L2.588|
                          DCD      bEcatInputUpdateRunning
                  |L2.592|
                          DCD      i16WaitForPllRunningTimeout
                  |L2.596|
                          DCD      i16WaitForPllRunningCnt

                          AREA ||i.BackToInitTransition||, CODE, READONLY, ALIGN=2

                  BackToInitTransition PROC
;;;1604   
;;;1605   void BackToInitTransition(void)
000000  2000              MOVS     r0,#0
;;;1606   {
;;;1607       /* Reset indication that the user has written a sync mode*/
;;;1608       bSyncSetByUser = FALSE;
000002  4901              LDR      r1,|L3.8|
000004  7008              STRB     r0,[r1,#0]
;;;1609   }
000006  4770              BX       lr
;;;1610   
                          ENDP

                  |L3.8|
                          DCD      bSyncSetByUser

                          AREA ||i.CheckIfEcatError||, CODE, READONLY, ALIGN=2

                  CheckIfEcatError PROC
;;;2626   *////////////////////////////////////////////////////////////////////////////////////////
;;;2627   void CheckIfEcatError(void)
000000  b508              PUSH     {r3,lr}
;;;2628   {
;;;2629      /*if the watchdog is enabled check the process data watchdog in the ESC
;;;2630      and set the AL status code 0x1B if the watchdog expired*/
;;;2631      if (EcatWdValue != 0)
000002  481d              LDR      r0,|L4.120|
000004  8800              LDRH     r0,[r0,#0]  ; EcatWdValue
000006  b1f8              CBZ      r0,|L4.72|
;;;2632      {
;;;2633         /*watchdog time is set => watchdog is active*/
;;;2634   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 3520 to 3526 deleted*/
;;;2635         UINT16 WdStatusOK = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2636   
;;;2637         HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
00000c  2202              MOVS     r2,#2
00000e  f44f6188          MOV      r1,#0x440
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       HW_EscRead
;;;2638         WdStatusOK = SWAPWORD(WdStatusOK);
000018  f8bd0000          LDRH     r0,[sp,#0]
00001c  9000              STR      r0,[sp,#0]
;;;2639   
;;;2640         if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
00001e  f8bd0000          LDRH     r0,[sp,#0]
000022  f0000001          AND      r0,r0,#1
000026  b970              CBNZ     r0,|L4.70|
000028  4814              LDR      r0,|L4.124|
00002a  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
00002c  2800              CMP      r0,#0
00002e  dd0a              BLE      |L4.70|
;;;2641         {
;;;2642            /*The device is in OP state*/
;;;2643   
;;;2644            if (bEcatOutputUpdateRunning
000030  4813              LDR      r0,|L4.128|
000032  7800              LDRB     r0,[r0,#0]  ; bEcatOutputUpdateRunning
000034  b120              CBZ      r0,|L4.64|
;;;2645   /*ET9300 Project Handler :(#if !OP_PD_REQUIRED) lines 3539 to 3541 deleted*/
;;;2646               )
;;;2647            {
;;;2648               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
000036  211b              MOVS     r1,#0x1b
000038  2004              MOVS     r0,#4
00003a  f7fffffe          BL       AL_ControlInd
                  |L4.62|
;;;2649               return;
;;;2650            }
;;;2651   
;;;2652            else
;;;2653            {
;;;2654               bEcatFirstOutputsReceived = FALSE;
;;;2655            }
;;;2656         }
;;;2657      }
;;;2658   
;;;2659      if(bDcSyncActive)
;;;2660      {
;;;2661          if(bEcatOutputUpdateRunning)
;;;2662          {
;;;2663              /*Slave is in OP state*/
;;;2664              if(!bDcRunning)
;;;2665              {
;;;2666                  AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
;;;2667                  return;
;;;2668              }
;;;2669              else if(!bSmSyncSequenceValid)
;;;2670              {
;;;2671                  AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
;;;2672                  return;
;;;2673              }
;;;2674           
;;;2675          }
;;;2676      }
;;;2677   }
00003e  bd08              POP      {r3,pc}
                  |L4.64|
000040  2000              MOVS     r0,#0                 ;2654
000042  4910              LDR      r1,|L4.132|
000044  7008              STRB     r0,[r1,#0]            ;2654
                  |L4.70|
000046  bf00              NOP                            ;2657
                  |L4.72|
000048  480f              LDR      r0,|L4.136|
00004a  7800              LDRB     r0,[r0,#0]            ;2659  ; bDcSyncActive
00004c  b190              CBZ      r0,|L4.116|
00004e  480c              LDR      r0,|L4.128|
000050  7800              LDRB     r0,[r0,#0]            ;2661  ; bEcatOutputUpdateRunning
000052  b178              CBZ      r0,|L4.116|
000054  480d              LDR      r0,|L4.140|
000056  7800              LDRB     r0,[r0,#0]            ;2664  ; bDcRunning
000058  b920              CBNZ     r0,|L4.100|
00005a  212c              MOVS     r1,#0x2c              ;2666
00005c  2004              MOVS     r0,#4                 ;2666
00005e  f7fffffe          BL       AL_ControlInd
000062  e7ec              B        |L4.62|
                  |L4.100|
000064  480a              LDR      r0,|L4.144|
000066  7800              LDRB     r0,[r0,#0]            ;2669  ; bSmSyncSequenceValid
000068  b920              CBNZ     r0,|L4.116|
00006a  211a              MOVS     r1,#0x1a              ;2671
00006c  2004              MOVS     r0,#4                 ;2671
00006e  f7fffffe          BL       AL_ControlInd
000072  e7e4              B        |L4.62|
                  |L4.116|
000074  bf00              NOP      
000076  e7e2              B        |L4.62|
;;;2678   /////////////////////////////////////////////////////////////////////////////////////////
                          ENDP

                  |L4.120|
                          DCD      EcatWdValue
                  |L4.124|
                          DCD      nPdOutputSize
                  |L4.128|
                          DCD      bEcatOutputUpdateRunning
                  |L4.132|
                          DCD      bEcatFirstOutputsReceived
                  |L4.136|
                          DCD      bDcSyncActive
                  |L4.140|
                          DCD      bDcRunning
                  |L4.144|
                          DCD      bSmSyncSequenceValid

                          AREA ||i.CheckSmSettings||, CODE, READONLY, ALIGN=2

                  CheckSmSettings PROC
;;;576    
;;;577    UINT8    CheckSmSettings(UINT8 maxChannel)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;578    {
000004  4680              MOV      r8,r0
;;;579        UINT8 i;
;;;580        UINT8 result = 0;
000006  2700              MOVS     r7,#0
;;;581        TSYNCMAN ESCMEM *pSyncMan;
;;;582        UINT16 SMLength = 0;
000008  2500              MOVS     r5,#0
;;;583        UINT16 SMAddress = 0;
00000a  2600              MOVS     r6,#0
;;;584    
;;;585    
;;;586            //Check if max address defines are within the available ESC address range
;;;587            if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
00000c  4899              LDR      r0,|L5.628|
00000e  8800              LDRH     r0,[r0,#0]  ; nMaxEscAddress
000010  f64171ff          MOV      r1,#0x1fff
000014  4288              CMP      r0,r1
000016  db0b              BLT      |L5.48|
;;;588                || (nMaxEscAddress < MAX_PD_READ_ADDRESS)
000018  4896              LDR      r0,|L5.628|
00001a  8800              LDRH     r0,[r0,#0]  ; nMaxEscAddress
00001c  4288              CMP      r0,r1
00001e  db07              BLT      |L5.48|
;;;589                || (nMaxEscAddress < MAX_MBX_WRITE_ADDRESS)
000020  4894              LDR      r0,|L5.628|
000022  8800              LDRH     r0,[r0,#0]  ; nMaxEscAddress
000024  4288              CMP      r0,r1
000026  db03              BLT      |L5.48|
;;;590                || (nMaxEscAddress < MAX_MBX_READ_ADDRESS))
000028  4892              LDR      r0,|L5.628|
00002a  8800              LDRH     r0,[r0,#0]  ; nMaxEscAddress
00002c  4288              CMP      r0,r1
00002e  da02              BGE      |L5.54|
                  |L5.48|
;;;591            {
;;;592                /*The defines for maximum SM addresses are invalid for the used ESC (change the defines in the file ecat_def.h or the SSC Tool)
;;;593                It may be also required to adapt the SM settings in the ESI file*/
;;;594    
;;;595    
;;;596                    return ALSTATUSCODE_NOVALIDFIRMWARE;
000030  2014              MOVS     r0,#0x14
                  |L5.50|
;;;597            }
;;;598    
;;;599        /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
;;;600        pSyncMan = GetSyncMan(MAILBOX_WRITE);
;;;601    
;;;602    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 858 to 874 deleted*/
;;;603        SMLength = pSyncMan->Length;
;;;604        SMAddress = pSyncMan->PhysicalStartAddress;
;;;605    
;;;606    /*ET9300 Project Handler :(#if CHECK_SM_PARAM_ALIGNMENT) lines 878 to 891 deleted*/
;;;607    
;;;608    
;;;609        if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
;;;610        {
;;;611            /* receive mailbox is not enabled */
;;;612            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;613        }
;;;614        else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_WRITE_VALUE)
;;;615        {
;;;616            /* receive mailbox is not writable by the master*/
;;;617            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;618        }
;;;619        else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
;;;620        {
;;;621            /* receive mailbox is not in one buffer mode */
;;;622            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;623        }
;;;624        else if (SMLength < MIN_MBX_SIZE)
;;;625        {
;;;626            /* receive mailbox size is too small */
;;;627            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;628        }
;;;629        else if (SMLength > MAX_MBX_SIZE)
;;;630        {
;;;631            /* receive mailbox size is too great */
;;;632            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;633        }
;;;634        else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
;;;635        {
;;;636            /* receive mailbox address is too small */
;;;637            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;638        }
;;;639        else if (SMAddress > MAX_MBX_WRITE_ADDRESS)
;;;640        {
;;;641            /* receive mailbox address is too great */
;;;642            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;643        }
;;;644    
;;;645    /*ET9300 Project Handler :(#if TEST_APPLICATION && COE_SUPPORTED) lines 931 to 937 deleted*/
;;;646    
;;;647        if ( result == 0 )
;;;648        {
;;;649            /* check the Sync Manager Parameter for the Send Mailbox (Sync Manager Channel 1) */
;;;650            pSyncMan = GetSyncMan(MAILBOX_READ);
;;;651    
;;;652    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 944 to 960 deleted*/
;;;653        SMLength = pSyncMan->Length;
;;;654        SMAddress = pSyncMan->PhysicalStartAddress;
;;;655    
;;;656    /*ET9300 Project Handler :(#if CHECK_SM_PARAM_ALIGNMENT) lines 964 to 977 deleted*/
;;;657    
;;;658        if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
;;;659        {
;;;660            /* send mailbox is not enabled */
;;;661            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;662        }
;;;663        else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_READ_VALUE)
;;;664        {
;;;665            /* receive mailbox is not readable by the master*/
;;;666            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;667        }
;;;668        else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
;;;669        {
;;;670            /* receive mailbox is not in one buffer mode */
;;;671            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;672        }
;;;673        else if (SMLength < MIN_MBX_SIZE)
;;;674        {
;;;675            /* send mailbox size is too small */
;;;676            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;677        }
;;;678        else if (SMLength > MAX_MBX_SIZE)
;;;679        {
;;;680            /* send mailbox size is too great */
;;;681            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;682        }
;;;683        else if (SMAddress < MIN_MBX_READ_ADDRESS)
;;;684        {
;;;685            /* send mailbox address is too small */
;;;686            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;687        }
;;;688        else if (SMAddress > MAX_MBX_READ_ADDRESS)
;;;689        {
;;;690            /* send mailbox address is too great */
;;;691            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
;;;692        }
;;;693        }
;;;694    
;;;695        if ( result == 0 && maxChannel > PROCESS_DATA_IN )
;;;696        {
;;;697            /* b3BufferMode is only set, if inputs and outputs are running in 3-Buffer-Mode when leaving this function */
;;;698            b3BufferMode = TRUE;
;;;699            /* check the Sync Manager Parameter for the Inputs (Sync Manager Channel 2 (0 in case if no mailbox is supported)) */
;;;700            pSyncMan = GetSyncMan(PROCESS_DATA_IN);
;;;701    
;;;702    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1025 to 1041 deleted*/
;;;703        SMLength = pSyncMan->Length;
;;;704        SMAddress = pSyncMan->PhysicalStartAddress;
;;;705    
;;;706    /*ET9300 Project Handler :(#if CHECK_SM_PARAM_ALIGNMENT) lines 1045 to 1058 deleted*/
;;;707    
;;;708    
;;;709        if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
;;;710        {
;;;711            /* the SM3 size is 0 and the SM3 is active */
;;;712            result = SYNCMANCHSETTINGS + 1;
;;;713        }
;;;714            else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
;;;715            {
;;;716                /* Sync Manager Channel 3 is active, input size has to greater 0 */
;;;717                    if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
;;;718                    {
;;;719                        /* sizes don't match */
;;;720                        result = SYNCMANCHSIZE + 1;
;;;721                    }
;;;722                    else
;;;723                    {
;;;724                        /* sizes matches */
;;;725                        if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_READ_VALUE)
;;;726                        {
;;;727                            /* settings match */
;;;728                            if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (SMAddress <= MAX_PD_READ_ADDRESS))
;;;729                                || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
;;;730                                )
;;;731                            {
;;;732                                /* addresses match */
;;;733    
;;;734                                    if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
;;;735                                    {
;;;736                                        /* inputs are running in 1-Buffer-Mode, reset flag b3BufferMode */
;;;737                                        b3BufferMode = FALSE;
;;;738                                    }
;;;739                            }
;;;740                            else
;;;741                            {
;;;742                                /* input address is out of the allowed area or has changed in SAFEOP or OP */
;;;743                                result = SYNCMANCHADDRESS + 1;
;;;744                            }
;;;745                        }
;;;746                        else
;;;747                        {
;;;748                            /* input settings do not match */
;;;749                            result = SYNCMANCHSETTINGS + 1;
;;;750                        }
;;;751                    }
;;;752            }
;;;753            else if (SMLength != 0 || nPdInputSize != 0)
;;;754            {
;;;755                /* input size is not zero although the SM3 channel is not enabled */
;;;756                result = SYNCMANCHSIZE + 1;
;;;757            }
;;;758    
;;;759    /*ET9300 Project Handler :(#if TEST_APPLICATION && COE_SUPPORTED) lines 1113 to 1119 deleted*/
;;;760    
;;;761    /*ET9300 Project Handler :(#if MAX_PD_INPUT_SIZE > 0 #else) lines 1121 to 1127 deleted*/
;;;762    
;;;763            if ( result != 0 )
;;;764            {
;;;765    /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1131 to 1133 deleted*/
;;;766                /* state transition refused, send an Emergency with the error and the correct settings */
;;;767                SendSmFailedEmergency(PROCESS_DATA_IN, result);
;;;768                result = ALSTATUSCODE_INVALIDSMINCFG;
;;;769            }
;;;770        }
;;;771    
;;;772    
;;;773    //    else
;;;774        if (result == 0 && maxChannel > PROCESS_DATA_OUT)
;;;775        {
;;;776    /*ET9300 Project Handler :(#if MAX_PD_INPUT_SIZE == 0) lines 1145 to 1148 deleted*/
;;;777            /* check the Sync Manager Parameter for the Outputs (Sync Manager Channel 2) */
;;;778            pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
;;;779    
;;;780    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1152 to 1168 deleted*/
;;;781        SMLength = pSyncMan->Length;
;;;782        SMAddress = pSyncMan->PhysicalStartAddress;
;;;783    
;;;784    /*ET9300 Project Handler :(#if CHECK_SM_PARAM_ALIGNMENT) lines 1172 to 1185 deleted*/
;;;785    
;;;786    
;;;787        if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
;;;788        {
;;;789            /* the SM2 size is 0 and the SM2 is active */
;;;790            result = SYNCMANCHSETTINGS + 1;
;;;791        }
;;;792            else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
;;;793            {
;;;794                /* Sync Manager Channel 2 is active, output size has to greater 0 */
;;;795                if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUTPUT_SIZE))
;;;796                {
;;;797                    /* sizes match */
;;;798                    if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
;;;799                    {
;;;800                        /* settings match */
;;;801                        if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( SMAddress <= MAX_PD_WRITE_ADDRESS ) )
;;;802                           ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
;;;803                            )
;;;804                        {
;;;805                            /* addresses match */
;;;806                            {
;;;807                                /* check, if watchdog trigger is enabled */
;;;808                                if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
;;;809                                {
;;;810                                    bWdTrigger = TRUE;
;;;811                                }
;;;812                                else
;;;813                                {
;;;814                                    bWdTrigger = FALSE;
;;;815                                }
;;;816    
;;;817                                if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
;;;818                                {
;;;819                                    /* outputs are running in 1-Buffer-Mode, reset flag b3BufferMode */
;;;820                                    b3BufferMode = FALSE;
;;;821                                    }
;;;822                            }
;;;823                        }
;;;824                        else
;;;825                        {
;;;826                            /* output address is out of the allowed area or has changed in SAFEOP or OP */
;;;827                            result = SYNCMANCHADDRESS + 1;
;;;828                        }
;;;829                    }
;;;830                    else
;;;831                    {
;;;832                        /* output settings do not match */
;;;833                        result = SYNCMANCHSETTINGS + 1;
;;;834                    }
;;;835                }
;;;836                else
;;;837                {
;;;838                    /* output sizes don't match */
;;;839                    result = SYNCMANCHSIZE + 1;
;;;840                }
;;;841            }
;;;842            else if (SMLength != 0 || nPdOutputSize != 0)
;;;843            {
;;;844                /* output size is not zero although the SM2 channel is not enabled */
;;;845                result = SYNCMANCHSIZE + 1;
;;;846            }
;;;847    /*ET9300 Project Handler :(#if MAX_PD_OUTPUT_SIZE > 0 #else) lines 1250 to 1256 deleted*/
;;;848    
;;;849    /*ET9300 Project Handler :(#if TEST_APPLICATION && COE_SUPPORTED) lines 1258 to 1265 deleted*/
;;;850            if ( result != 0 )
;;;851            {
;;;852    /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1268 to 1270 deleted*/
;;;853                /* state transition refused, send an Emergency with the error and the correct settings */
;;;854                SendSmFailedEmergency(PROCESS_DATA_OUT, result);
;;;855                result = ALSTATUSCODE_INVALIDSMOUTCFG;
;;;856            }
;;;857        }
;;;858    
;;;859    
;;;860        if ( result == 0 )
;;;861        {
;;;862            /* the Enable-Byte of the rest of the SM channels has to be read to acknowledge the SM-Change-Interrupt */
;;;863            for (i = maxChannel; i < nMaxSyncMan; i++)
;;;864            {
;;;865                pSyncMan = GetSyncMan(i);
;;;866    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1285 to 1287 deleted*/
;;;867                SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
;;;868            }
;;;869        }
;;;870        return result;
;;;871    }
000032  e8bd87f0          POP      {r4-r10,pc}
                  |L5.54|
000036  2000              MOVS     r0,#0                 ;600
000038  f7fffffe          BL       GetSyncMan
00003c  4604              MOV      r4,r0                 ;600
00003e  8865              LDRH     r5,[r4,#2]            ;603
000040  8826              LDRH     r6,[r4,#0]            ;604
000042  79a0              LDRB     r0,[r4,#6]            ;609
000044  f0000001          AND      r0,r0,#1              ;609
000048  b908              CBNZ     r0,|L5.78|
00004a  2716              MOVS     r7,#0x16              ;612
00004c  e01f              B        |L5.142|
                  |L5.78|
00004e  7920              LDRB     r0,[r4,#4]            ;614
000050  f000000c          AND      r0,r0,#0xc            ;614
000054  2804              CMP      r0,#4                 ;614
000056  d001              BEQ      |L5.92|
000058  2716              MOVS     r7,#0x16              ;617
00005a  e018              B        |L5.142|
                  |L5.92|
00005c  7920              LDRB     r0,[r4,#4]            ;619
00005e  f0000002          AND      r0,r0,#2              ;619
000062  2802              CMP      r0,#2                 ;619
000064  d001              BEQ      |L5.106|
000066  2716              MOVS     r7,#0x16              ;622
000068  e011              B        |L5.142|
                  |L5.106|
00006a  2d24              CMP      r5,#0x24              ;624
00006c  da01              BGE      |L5.114|
00006e  2716              MOVS     r7,#0x16              ;627
000070  e00d              B        |L5.142|
                  |L5.114|
000072  f5b57f80          CMP      r5,#0x100             ;629
000076  dd01              BLE      |L5.124|
000078  2716              MOVS     r7,#0x16              ;632
00007a  e008              B        |L5.142|
                  |L5.124|
00007c  f5b65f80          CMP      r6,#0x1000            ;634
000080  da01              BGE      |L5.134|
000082  2716              MOVS     r7,#0x16              ;637
000084  e003              B        |L5.142|
                  |L5.134|
000086  f5b65f00          CMP      r6,#0x2000            ;639
00008a  db00              BLT      |L5.142|
00008c  2716              MOVS     r7,#0x16              ;642
                  |L5.142|
00008e  bb07              CBNZ     r7,|L5.210|
000090  2001              MOVS     r0,#1                 ;650
000092  f7fffffe          BL       GetSyncMan
000096  4604              MOV      r4,r0                 ;650
000098  8865              LDRH     r5,[r4,#2]            ;653
00009a  8826              LDRH     r6,[r4,#0]            ;654
00009c  79a0              LDRB     r0,[r4,#6]            ;658
00009e  f0000001          AND      r0,r0,#1              ;658
0000a2  b908              CBNZ     r0,|L5.168|
0000a4  2716              MOVS     r7,#0x16              ;661
0000a6  e01e              B        |L5.230|
                  |L5.168|
0000a8  7920              LDRB     r0,[r4,#4]            ;663
0000aa  f000000c          AND      r0,r0,#0xc            ;663
0000ae  b108              CBZ      r0,|L5.180|
0000b0  2716              MOVS     r7,#0x16              ;666
0000b2  e018              B        |L5.230|
                  |L5.180|
0000b4  7920              LDRB     r0,[r4,#4]            ;668
0000b6  f0000002          AND      r0,r0,#2              ;668
0000ba  2802              CMP      r0,#2                 ;668
0000bc  d001              BEQ      |L5.194|
0000be  2716              MOVS     r7,#0x16              ;671
0000c0  e011              B        |L5.230|
                  |L5.194|
0000c2  2d24              CMP      r5,#0x24              ;673
0000c4  da01              BGE      |L5.202|
0000c6  2716              MOVS     r7,#0x16              ;676
0000c8  e00d              B        |L5.230|
                  |L5.202|
0000ca  f5b57f80          CMP      r5,#0x100             ;678
0000ce  dd01              BLE      |L5.212|
0000d0  2716              MOVS     r7,#0x16              ;681
                  |L5.210|
0000d2  e008              B        |L5.230|
                  |L5.212|
0000d4  f5b65f84          CMP      r6,#0x1080            ;683
0000d8  da01              BGE      |L5.222|
0000da  2716              MOVS     r7,#0x16              ;686
0000dc  e003              B        |L5.230|
                  |L5.222|
0000de  f5b65f00          CMP      r6,#0x2000            ;688
0000e2  db00              BLT      |L5.230|
0000e4  2716              MOVS     r7,#0x16              ;691
                  |L5.230|
0000e6  2f00              CMP      r7,#0                 ;695
0000e8  d151              BNE      |L5.398|
0000ea  f1b80f03          CMP      r8,#3                 ;695
0000ee  dd4e              BLE      |L5.398|
0000f0  2001              MOVS     r0,#1                 ;698
0000f2  4961              LDR      r1,|L5.632|
0000f4  7008              STRB     r0,[r1,#0]            ;698
0000f6  2003              MOVS     r0,#3                 ;700
0000f8  f7fffffe          BL       GetSyncMan
0000fc  4604              MOV      r4,r0                 ;700
0000fe  8865              LDRH     r5,[r4,#2]            ;703
000100  8826              LDRH     r6,[r4,#0]            ;704
000102  79a0              LDRB     r0,[r4,#6]            ;709
000104  f0000001          AND      r0,r0,#1              ;709
000108  b110              CBZ      r0,|L5.272|
00010a  b90d              CBNZ     r5,|L5.272|
00010c  2703              MOVS     r7,#3                 ;712
00010e  e038              B        |L5.386|
                  |L5.272|
000110  79a0              LDRB     r0,[r4,#6]            ;714
000112  f0000001          AND      r0,r0,#1              ;714
000116  b370              CBZ      r0,|L5.374|
000118  4858              LDR      r0,|L5.636|
00011a  8800              LDRH     r0,[r0,#0]            ;717  ; nPdInputSize
00011c  4285              CMP      r5,r0                 ;717
00011e  d105              BNE      |L5.300|
000120  4856              LDR      r0,|L5.636|
000122  8800              LDRH     r0,[r0,#0]            ;717  ; nPdInputSize
000124  b110              CBZ      r0,|L5.300|
000126  f5b57f80          CMP      r5,#0x100             ;717
00012a  dd01              BLE      |L5.304|
                  |L5.300|
00012c  2701              MOVS     r7,#1                 ;720
00012e  e028              B        |L5.386|
                  |L5.304|
000130  7920              LDRB     r0,[r4,#4]            ;725
000132  f000000c          AND      r0,r0,#0xc            ;725
000136  b9e0              CBNZ     r0,|L5.370|
000138  4851              LDR      r0,|L5.640|
00013a  7800              LDRB     r0,[r0,#0]            ;728  ; nAlStatus
00013c  2802              CMP      r0,#2                 ;728
00013e  d105              BNE      |L5.332|
000140  f5b65f80          CMP      r6,#0x1000            ;728
000144  db02              BLT      |L5.332|
000146  f5b65f00          CMP      r6,#0x2000            ;728
00014a  db07              BLT      |L5.348|
                  |L5.332|
00014c  484c              LDR      r0,|L5.640|
00014e  7800              LDRB     r0,[r0,#0]            ;729  ; nAlStatus
000150  2802              CMP      r0,#2                 ;729
000152  d00c              BEQ      |L5.366|
000154  484b              LDR      r0,|L5.644|
000156  8800              LDRH     r0,[r0,#0]            ;729  ; nEscAddrInputData
000158  4286              CMP      r6,r0                 ;729
00015a  d108              BNE      |L5.366|
                  |L5.348|
00015c  7920              LDRB     r0,[r4,#4]            ;734
00015e  f0000002          AND      r0,r0,#2              ;734
000162  2802              CMP      r0,#2                 ;734
000164  d10d              BNE      |L5.386|
000166  2000              MOVS     r0,#0                 ;737
000168  4943              LDR      r1,|L5.632|
00016a  7008              STRB     r0,[r1,#0]            ;737
00016c  e009              B        |L5.386|
                  |L5.366|
00016e  2702              MOVS     r7,#2                 ;743
000170  e007              B        |L5.386|
                  |L5.370|
000172  2703              MOVS     r7,#3                 ;749
000174  e005              B        |L5.386|
                  |L5.374|
000176  e7ff              B        |L5.376|
                  |L5.376|
000178  b915              CBNZ     r5,|L5.384|
00017a  4840              LDR      r0,|L5.636|
00017c  8800              LDRH     r0,[r0,#0]            ;753  ; nPdInputSize
00017e  b100              CBZ      r0,|L5.386|
                  |L5.384|
000180  2701              MOVS     r7,#1                 ;756
                  |L5.386|
000182  b127              CBZ      r7,|L5.398|
000184  4639              MOV      r1,r7                 ;767
000186  2003              MOVS     r0,#3                 ;767
000188  f7fffffe          BL       SendSmFailedEmergency
00018c  271e              MOVS     r7,#0x1e              ;768
                  |L5.398|
00018e  bbe7              CBNZ     r7,|L5.522|
000190  f1b80f02          CMP      r8,#2                 ;774
000194  dd59              BLE      |L5.586|
000196  2002              MOVS     r0,#2                 ;778
000198  f7fffffe          BL       GetSyncMan
00019c  4604              MOV      r4,r0                 ;778
00019e  8865              LDRH     r5,[r4,#2]            ;781
0001a0  8826              LDRH     r6,[r4,#0]            ;782
0001a2  79a0              LDRB     r0,[r4,#6]            ;787
0001a4  f0000001          AND      r0,r0,#1              ;787
0001a8  b110              CBZ      r0,|L5.432|
0001aa  b90d              CBNZ     r5,|L5.432|
0001ac  2703              MOVS     r7,#3                 ;790
0001ae  e046              B        |L5.574|
                  |L5.432|
0001b0  79a0              LDRB     r0,[r4,#6]            ;792
0001b2  f0000001          AND      r0,r0,#1              ;792
0001b6  b348              CBZ      r0,|L5.524|
0001b8  4833              LDR      r0,|L5.648|
0001ba  8800              LDRH     r0,[r0,#0]            ;795  ; nPdOutputSize
0001bc  4285              CMP      r5,r0                 ;795
0001be  d137              BNE      |L5.560|
0001c0  4831              LDR      r0,|L5.648|
0001c2  8800              LDRH     r0,[r0,#0]            ;795  ; nPdOutputSize
0001c4  b378              CBZ      r0,|L5.550|
0001c6  f5b57f80          CMP      r5,#0x100             ;795
0001ca  dc31              BGT      |L5.560|
0001cc  7920              LDRB     r0,[r4,#4]            ;798
0001ce  f000000c          AND      r0,r0,#0xc            ;798
0001d2  2804              CMP      r0,#4                 ;798
0001d4  d12a              BNE      |L5.556|
0001d6  482a              LDR      r0,|L5.640|
0001d8  7800              LDRB     r0,[r0,#0]            ;801  ; nAlStatus
0001da  2802              CMP      r0,#2                 ;801
0001dc  d105              BNE      |L5.490|
0001de  f5b65f80          CMP      r6,#0x1000            ;801
0001e2  db02              BLT      |L5.490|
0001e4  f5b65f00          CMP      r6,#0x2000            ;801
0001e8  db07              BLT      |L5.506|
                  |L5.490|
0001ea  4825              LDR      r0,|L5.640|
0001ec  7800              LDRB     r0,[r0,#0]            ;802  ; nAlStatus
0001ee  2802              CMP      r0,#2                 ;802
0001f0  d01a              BEQ      |L5.552|
0001f2  4826              LDR      r0,|L5.652|
0001f4  8800              LDRH     r0,[r0,#0]            ;802  ; nEscAddrOutputData
0001f6  4286              CMP      r6,r0                 ;802
0001f8  d116              BNE      |L5.552|
                  |L5.506|
0001fa  7920              LDRB     r0,[r4,#4]            ;808
0001fc  f0000040          AND      r0,r0,#0x40           ;808
000200  b128              CBZ      r0,|L5.526|
000202  2001              MOVS     r0,#1                 ;810
000204  4922              LDR      r1,|L5.656|
000206  7008              STRB     r0,[r1,#0]            ;810
000208  e004              B        |L5.532|
                  |L5.522|
00020a  e01e              B        |L5.586|
                  |L5.524|
00020c  e012              B        |L5.564|
                  |L5.526|
00020e  2000              MOVS     r0,#0                 ;814
000210  491f              LDR      r1,|L5.656|
000212  7008              STRB     r0,[r1,#0]            ;814
                  |L5.532|
000214  7920              LDRB     r0,[r4,#4]            ;817
000216  f0000002          AND      r0,r0,#2              ;817
00021a  2802              CMP      r0,#2                 ;817
00021c  d10f              BNE      |L5.574|
00021e  2000              MOVS     r0,#0                 ;820
000220  4915              LDR      r1,|L5.632|
000222  7008              STRB     r0,[r1,#0]            ;820
000224  e00b              B        |L5.574|
                  |L5.550|
000226  e003              B        |L5.560|
                  |L5.552|
000228  2702              MOVS     r7,#2                 ;827
00022a  e008              B        |L5.574|
                  |L5.556|
00022c  2703              MOVS     r7,#3                 ;833
00022e  e006              B        |L5.574|
                  |L5.560|
000230  2701              MOVS     r7,#1                 ;839
000232  e004              B        |L5.574|
                  |L5.564|
000234  b915              CBNZ     r5,|L5.572|
000236  4814              LDR      r0,|L5.648|
000238  8800              LDRH     r0,[r0,#0]            ;842  ; nPdOutputSize
00023a  b100              CBZ      r0,|L5.574|
                  |L5.572|
00023c  2701              MOVS     r7,#1                 ;845
                  |L5.574|
00023e  b127              CBZ      r7,|L5.586|
000240  4639              MOV      r1,r7                 ;854
000242  2002              MOVS     r0,#2                 ;854
000244  f7fffffe          BL       SendSmFailedEmergency
000248  271d              MOVS     r7,#0x1d              ;855
                  |L5.586|
00024a  b987              CBNZ     r7,|L5.622|
00024c  46c1              MOV      r9,r8                 ;863
00024e  e00a              B        |L5.614|
                  |L5.592|
000250  4648              MOV      r0,r9                 ;865
000252  f7fffffe          BL       GetSyncMan
000256  4604              MOV      r4,r0                 ;865
000258  88e0              LDRH     r0,[r4,#6]            ;867
00025a  490e              LDR      r1,|L5.660|
00025c  8008              STRH     r0,[r1,#0]            ;867
00025e  f1090001          ADD      r0,r9,#1              ;863
000262  f00009ff          AND      r9,r0,#0xff           ;863
                  |L5.614|
000266  480c              LDR      r0,|L5.664|
000268  7800              LDRB     r0,[r0,#0]            ;863  ; nMaxSyncMan
00026a  4581              CMP      r9,r0                 ;863
00026c  dbf0              BLT      |L5.592|
                  |L5.622|
00026e  4638              MOV      r0,r7                 ;870
000270  e6df              B        |L5.50|
;;;872    
                          ENDP

000272  0000              DCW      0x0000
                  |L5.628|
                          DCD      nMaxEscAddress
                  |L5.632|
                          DCD      b3BufferMode
                  |L5.636|
                          DCD      nPdInputSize
                  |L5.640|
                          DCD      nAlStatus
                  |L5.644|
                          DCD      nEscAddrInputData
                  |L5.648|
                          DCD      nPdOutputSize
                  |L5.652|
                          DCD      nEscAddrOutputData
                  |L5.656|
                          DCD      bWdTrigger
                  |L5.660|
                          DCD      SMActivate
                  |L5.664|
                          DCD      nMaxSyncMan

                          AREA ||i.DC_CheckWatchdog||, CODE, READONLY, ALIGN=2

                  DC_CheckWatchdog PROC
;;;2547   *////////////////////////////////////////////////////////////////////////////////////////
;;;2548   void DC_CheckWatchdog(void)
000000  b510              PUSH     {r4,lr}
;;;2549   {
;;;2550       DISABLE_ESC_INT();
000002  f7fffffe          BL       PDI_Disable_Global_Interrupt
000006  4938              LDR      r1,|L6.232|
000008  6008              STR      r0,[r1,#0]  ; restore_intsts
;;;2551   
;;;2552       if(bDcSyncActive && bEcatInputUpdateRunning)
00000a  4838              LDR      r0,|L6.236|
00000c  7800              LDRB     r0,[r0,#0]  ; bDcSyncActive
00000e  2800              CMP      r0,#0
000010  d065              BEQ      |L6.222|
000012  4837              LDR      r0,|L6.240|
000014  7800              LDRB     r0,[r0,#0]  ; bEcatInputUpdateRunning
000016  2800              CMP      r0,#0
000018  d061              BEQ      |L6.222|
;;;2553       {
;;;2554           /*If Sync0 watchdog is enabled and expired*/
;;;2555           if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
00001a  4836              LDR      r0,|L6.244|
00001c  8800              LDRH     r0,[r0,#0]  ; Sync0WdValue
00001e  2800              CMP      r0,#0
000020  dd09              BLE      |L6.54|
000022  4835              LDR      r0,|L6.248|
000024  8800              LDRH     r0,[r0,#0]  ; Sync0WdCounter
000026  4933              LDR      r1,|L6.244|
000028  8809              LDRH     r1,[r1,#0]  ; Sync0WdValue
00002a  4288              CMP      r0,r1
00002c  db03              BLT      |L6.54|
;;;2556           {
;;;2557                   /*Sync0 watchdog expired*/
;;;2558                   bDcRunning = FALSE;        
00002e  2000              MOVS     r0,#0
000030  4932              LDR      r1,|L6.252|
000032  7008              STRB     r0,[r1,#0]
000034  e00d              B        |L6.82|
                  |L6.54|
;;;2559           }
;;;2560           else
;;;2561           {
;;;2562               if(Sync0WdCounter < Sync0WdValue)
000036  4830              LDR      r0,|L6.248|
000038  8800              LDRH     r0,[r0,#0]  ; Sync0WdCounter
00003a  492e              LDR      r1,|L6.244|
00003c  8809              LDRH     r1,[r1,#0]  ; Sync0WdValue
00003e  4288              CMP      r0,r1
000040  da04              BGE      |L6.76|
;;;2563               {
;;;2564                   Sync0WdCounter ++;
000042  482d              LDR      r0,|L6.248|
000044  8800              LDRH     r0,[r0,#0]  ; Sync0WdCounter
000046  1c40              ADDS     r0,r0,#1
000048  492b              LDR      r1,|L6.248|
00004a  8008              STRH     r0,[r1,#0]
                  |L6.76|
;;;2565               }
;;;2566   
;;;2567               bDcRunning = TRUE;
00004c  2001              MOVS     r0,#1
00004e  492b              LDR      r1,|L6.252|
000050  7008              STRB     r0,[r1,#0]
                  |L6.82|
;;;2568           }
;;;2569   
;;;2570           if(bDcRunning)
000052  482a              LDR      r0,|L6.252|
000054  7800              LDRB     r0,[r0,#0]  ; bDcRunning
000056  b190              CBZ      r0,|L6.126|
;;;2571           {
;;;2572               /*Check the Sync1 cycle if Sync1 Wd is enabled*/
;;;2573               if(Sync1WdValue > 0)
000058  4829              LDR      r0,|L6.256|
00005a  8800              LDRH     r0,[r0,#0]  ; Sync1WdValue
00005c  2800              CMP      r0,#0
00005e  dd0e              BLE      |L6.126|
;;;2574               {
;;;2575                   if(Sync1WdCounter < Sync1WdValue)
000060  4828              LDR      r0,|L6.260|
000062  8800              LDRH     r0,[r0,#0]  ; Sync1WdCounter
000064  4926              LDR      r1,|L6.256|
000066  8809              LDRH     r1,[r1,#0]  ; Sync1WdValue
000068  4288              CMP      r0,r1
00006a  da05              BGE      |L6.120|
;;;2576                   {
;;;2577                       Sync1WdCounter ++;
00006c  4825              LDR      r0,|L6.260|
00006e  8800              LDRH     r0,[r0,#0]  ; Sync1WdCounter
000070  1c40              ADDS     r0,r0,#1
000072  4924              LDR      r1,|L6.260|
000074  8008              STRH     r0,[r1,#0]
000076  e002              B        |L6.126|
                  |L6.120|
;;;2578                   }
;;;2579                   else
;;;2580                   {
;;;2581                       /*Sync1 watchdog expired*/
;;;2582                       bDcRunning = FALSE;
000078  2000              MOVS     r0,#0
00007a  4920              LDR      r1,|L6.252|
00007c  7008              STRB     r0,[r1,#0]
                  |L6.126|
;;;2583                   }
;;;2584               }
;;;2585           }
;;;2586           if(bDcRunning)
00007e  481f              LDR      r0,|L6.252|
000080  7800              LDRB     r0,[r0,#0]  ; bDcRunning
000082  b330              CBZ      r0,|L6.210|
;;;2587           {
;;;2588   /*ECATCHANGE_START(V5.13) ESM4*/
;;;2589              if((sErrorSettings.u16SyncErrorCounterLimit == 0) || (sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit))
000084  4820              LDR      r0,|L6.264|
000086  8900              LDRH     r0,[r0,#8]  ; sErrorSettings
000088  b128              CBZ      r0,|L6.150|
00008a  4820              LDR      r0,|L6.268|
00008c  8d00              LDRH     r0,[r0,#0x28]  ; sSyncManOutPar
00008e  491e              LDR      r1,|L6.264|
000090  8909              LDRH     r1,[r1,#8]  ; sErrorSettings
000092  4288              CMP      r0,r1
000094  da0e              BGE      |L6.180|
                  |L6.150|
;;;2590   /*ET9300 Project Handler :(#elif(MAX_PD_INPUT_SIZE > 0)) lines 3467 to 3469 deleted*/
;;;2591   /*ECATCHANGE_END(V5.13) ESM4*/
;;;2592   /*ET9300 Project Handler :(#if COE_SUPPORTED && !_PIC18 #else) lines 3471 to 3473 deleted*/
;;;2593               {
;;;2594                   bSmSyncSequenceValid = TRUE;
000096  2001              MOVS     r0,#1
000098  491d              LDR      r1,|L6.272|
00009a  7008              STRB     r0,[r1,#0]
;;;2595   
;;;2596                   /*Wait for PLL is active increment the Pll valid counter*/
;;;2597                   if (i16WaitForPllRunningTimeout > 0)
00009c  481d              LDR      r0,|L6.276|
00009e  f9b00000          LDRSH    r0,[r0,#0]  ; i16WaitForPllRunningTimeout
0000a2  2800              CMP      r0,#0
0000a4  dd1b              BLE      |L6.222|
;;;2598                   {
;;;2599                       i16WaitForPllRunningCnt++;
0000a6  481c              LDR      r0,|L6.280|
0000a8  8800              LDRH     r0,[r0,#0]  ; i16WaitForPllRunningCnt
0000aa  1c40              ADDS     r0,r0,#1
0000ac  b200              SXTH     r0,r0
0000ae  491a              LDR      r1,|L6.280|
0000b0  8008              STRH     r0,[r1,#0]
0000b2  e014              B        |L6.222|
                  |L6.180|
;;;2600                   }
;;;2601               }
;;;2602               else if (bSmSyncSequenceValid)
0000b4  4816              LDR      r0,|L6.272|
0000b6  7800              LDRB     r0,[r0,#0]  ; bSmSyncSequenceValid
0000b8  b188              CBZ      r0,|L6.222|
;;;2603               {
;;;2604                       bSmSyncSequenceValid = FALSE;
0000ba  2000              MOVS     r0,#0
0000bc  4914              LDR      r1,|L6.272|
0000be  7008              STRB     r0,[r1,#0]
;;;2605   
;;;2606                   /*Wait for PLL is active reset the Pll valid counter*/
;;;2607                   if (i16WaitForPllRunningTimeout > 0)
0000c0  4814              LDR      r0,|L6.276|
0000c2  f9b00000          LDRSH    r0,[r0,#0]  ; i16WaitForPllRunningTimeout
0000c6  2800              CMP      r0,#0
0000c8  dd09              BLE      |L6.222|
;;;2608                   {
;;;2609                       i16WaitForPllRunningCnt = 0;
0000ca  2000              MOVS     r0,#0
0000cc  4912              LDR      r1,|L6.280|
0000ce  8008              STRH     r0,[r1,#0]
0000d0  e005              B        |L6.222|
                  |L6.210|
;;;2610                   }
;;;2611               }
;;;2612           }
;;;2613           else if(bSmSyncSequenceValid)
0000d2  480f              LDR      r0,|L6.272|
0000d4  7800              LDRB     r0,[r0,#0]  ; bSmSyncSequenceValid
0000d6  b110              CBZ      r0,|L6.222|
;;;2614           {
;;;2615              bSmSyncSequenceValid = FALSE;
0000d8  2000              MOVS     r0,#0
0000da  490d              LDR      r1,|L6.272|
0000dc  7008              STRB     r0,[r1,#0]
                  |L6.222|
;;;2616           }
;;;2617       }
;;;2618       ENABLE_ESC_INT();
0000de  4802              LDR      r0,|L6.232|
0000e0  6800              LDR      r0,[r0,#0]  ; restore_intsts
0000e2  f7fffffe          BL       PDI_Restore_Global_Interrupt
;;;2619   }
0000e6  bd10              POP      {r4,pc}
;;;2620   
                          ENDP

                  |L6.232|
                          DCD      restore_intsts
                  |L6.236|
                          DCD      bDcSyncActive
                  |L6.240|
                          DCD      bEcatInputUpdateRunning
                  |L6.244|
                          DCD      Sync0WdValue
                  |L6.248|
                          DCD      Sync0WdCounter
                  |L6.252|
                          DCD      bDcRunning
                  |L6.256|
                          DCD      Sync1WdValue
                  |L6.260|
                          DCD      Sync1WdCounter
                  |L6.264|
                          DCD      sErrorSettings
                  |L6.268|
                          DCD      sSyncManOutPar
                  |L6.272|
                          DCD      bSmSyncSequenceValid
                  |L6.276|
                          DCD      i16WaitForPllRunningTimeout
                  |L6.280|
                          DCD      i16WaitForPllRunningCnt

                          AREA ||i.DisableSyncManChannel||, CODE, READONLY, ALIGN=1

                  DisableSyncManChannel PROC
;;;380    *////////////////////////////////////////////////////////////////////////////////////////
;;;381    void DisableSyncManChannel(UINT8 channel)
000000  b538              PUSH     {r3-r5,lr}
;;;382    {
000002  4604              MOV      r4,r0
;;;383        UINT16 Offset;
;;;384    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 488 to 507 deleted*/
;;;385        //The register 0x806 is only readable from PDI => writing 0 is valid
;;;386        VARVOLATILE UINT16 smStatus = SM_SETTING_PDI_DISABLE;
000004  f44f7080          MOV      r0,#0x100
000008  9000              STR      r0,[sp,#0]
;;;387        Offset = (ESC_SYNCMAN_ACTIVE_OFFSET + (SIZEOF_SM_REGISTER*channel));
00000a  00e0              LSLS     r0,r4,#3
00000c  f6000506          ADD      r5,r0,#0x806
;;;388    
;;;389    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 512 to 514 deleted*/
;;;390    
;;;391        HW_EscWriteWord(smStatus,Offset);
000010  2202              MOVS     r2,#2
000012  4629              MOV      r1,r5
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       HW_EscWrite
;;;392        
;;;393        /*wait until SyncManager is disabled*/
;;;394        do
00001a  bf00              NOP      
                  |L7.28|
;;;395        {
;;;396            HW_EscReadWord(smStatus, Offset);
00001c  2202              MOVS     r2,#2
00001e  4629              MOV      r1,r5
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       HW_EscRead
;;;397    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 522 to 524 deleted*/
;;;398        }while(!(smStatus & SM_SETTING_PDI_DISABLE));
000026  f8bd0000          LDRH     r0,[sp,#0]
00002a  f4007080          AND      r0,r0,#0x100
00002e  2800              CMP      r0,#0
000030  d0f4              BEQ      |L7.28|
;;;399    /*ET9300 Project Handler :( #else) lines 526 to 537 deleted*/
;;;400    }
000032  bd38              POP      {r3-r5,pc}
;;;401    
                          ENDP


                          AREA ||i.ECAT_Init||, CODE, READONLY, ALIGN=2

                  ECAT_Init PROC
;;;2841   
;;;2842   void ECAT_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;2843   {
;;;2844       UINT8 i;
;;;2845       /*Get Maximum Number of SyncManagers and supported DPRAM size*/
;;;2846   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 3756 to 3768 deleted*/
;;;2847       {
;;;2848       UINT16 TmpVar = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;2849   
;;;2850       HW_EscReadWord(TmpVar, ESC_COMM_INFO_OFFSET);
000006  2202              MOVS     r2,#2
000008  2104              MOVS     r1,#4
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       HW_EscRead
;;;2851   
;;;2852       TmpVar = SWAPWORD(TmpVar);
000010  f8bd0000          LDRH     r0,[sp,#0]
000014  9000              STR      r0,[sp,#0]
;;;2853       nMaxSyncMan = (UINT8) ((TmpVar & ESC_SM_CHANNELS_MASK)>> ESC_SM_CHANNELS_SHIFT);
000016  f8bd0000          LDRH     r0,[sp,#0]
00001a  0a00              LSRS     r0,r0,#8
00001c  4930              LDR      r1,|L8.224|
00001e  7008              STRB     r0,[r1,#0]
;;;2854   
;;;2855       HW_EscReadWord(TmpVar, ESC_DPRAM_SIZE_OFFSET);
000020  2202              MOVS     r2,#2
000022  2106              MOVS     r1,#6
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       HW_EscRead
;;;2856       TmpVar = SWAPWORD(TmpVar);
00002a  f8bd0000          LDRH     r0,[sp,#0]
00002e  9000              STR      r0,[sp,#0]
;;;2857   
;;;2858       //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
;;;2859       nMaxEscAddress = (UINT16) ((TmpVar & ESC_DPRAM_SIZE_MASK) << 10) + 0xFFF;
000030  f8bd0000          LDRH     r0,[sp,#0]
000034  f64071ff          MOV      r1,#0xfff
000038  eb012080          ADD      r0,r1,r0,LSL #10
00003c  4929              LDR      r1,|L8.228|
00003e  8008              STRH     r0,[r1,#0]
;;;2860       }
;;;2861   /*ET9300 Project Handler :( #else) lines 3783 to 3789 deleted*/
;;;2862   
;;;2863   /*ECATCHANGE_START(V5.13) ECAT2*/
;;;2864       u16IdValue = 0;
000040  2000              MOVS     r0,#0
000042  4929              LDR      r1,|L8.232|
000044  8008              STRH     r0,[r1,#0]
;;;2865   /*ECATCHANGE_END(V5.13) ECAT2*/
;;;2866   
;;;2867       /* Get EEPROM loaded information */
;;;2868       UpdateEEPROMLoadedState();
000046  f7fffffe          BL       UpdateEEPROMLoadedState
;;;2869   
;;;2870       /* disable all Sync Manager channels */
;;;2871       for (i = 0; i < nMaxSyncMan; i++)
00004a  2400              MOVS     r4,#0
00004c  e004              B        |L8.88|
                  |L8.78|
;;;2872       {
;;;2873           DisableSyncManChannel(i);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       DisableSyncManChannel
000054  1c60              ADDS     r0,r4,#1              ;2871
000056  b2c4              UXTB     r4,r0                 ;2871
                  |L8.88|
000058  4821              LDR      r0,|L8.224|
00005a  7800              LDRB     r0,[r0,#0]            ;2871  ; nMaxSyncMan
00005c  4284              CMP      r4,r0                 ;2871
00005e  dbf6              BLT      |L8.78|
;;;2874       }
;;;2875   
;;;2876       /* initialize the mailbox handler */
;;;2877       MBX_Init();
000060  f7fffffe          BL       MBX_Init
;;;2878   
;;;2879       /* initialize variables */
;;;2880       bBootMode = FALSE;
000064  2000              MOVS     r0,#0
000066  4921              LDR      r1,|L8.236|
000068  7008              STRB     r0,[r1,#0]
;;;2881       bApplEsmPending = FALSE;
00006a  4921              LDR      r1,|L8.240|
00006c  7008              STRB     r0,[r1,#0]
;;;2882       bEcatWaitForAlControlRes = FALSE;
00006e  4921              LDR      r1,|L8.244|
000070  7008              STRB     r0,[r1,#0]
;;;2883       bEcatFirstOutputsReceived = FALSE;
000072  4921              LDR      r1,|L8.248|
000074  7008              STRB     r0,[r1,#0]
;;;2884        bEcatOutputUpdateRunning = FALSE;
000076  4921              LDR      r1,|L8.252|
000078  7008              STRB     r0,[r1,#0]
;;;2885        bEcatInputUpdateRunning = FALSE;
00007a  4921              LDR      r1,|L8.256|
00007c  7008              STRB     r0,[r1,#0]
;;;2886        bExplicitDevIdRequested = FALSE;
00007e  4921              LDR      r1,|L8.260|
000080  7008              STRB     r0,[r1,#0]
;;;2887       bWdTrigger = FALSE;
000082  4921              LDR      r1,|L8.264|
000084  7008              STRB     r0,[r1,#0]
;;;2888       EcatWdValue = 0;
000086  4921              LDR      r1,|L8.268|
000088  8008              STRH     r0,[r1,#0]
;;;2889   /*ET9300 Project Handler :(#if !ESC_SM_WD_SUPPORTED) lines 3829 to 3831 deleted*/
;;;2890       Sync0WdCounter = 0;
00008a  4921              LDR      r1,|L8.272|
00008c  8008              STRH     r0,[r1,#0]
;;;2891       Sync0WdValue = 0;
00008e  4921              LDR      r1,|L8.276|
000090  8008              STRH     r0,[r1,#0]
;;;2892       Sync1WdCounter = 0;
000092  4921              LDR      r1,|L8.280|
000094  8008              STRH     r0,[r1,#0]
;;;2893       Sync1WdValue = 0;
000096  4921              LDR      r1,|L8.284|
000098  8008              STRH     r0,[r1,#0]
;;;2894       bDcSyncActive = FALSE;
00009a  4921              LDR      r1,|L8.288|
00009c  7008              STRB     r0,[r1,#0]
;;;2895   
;;;2896       /*ECATCHANGE_START(V5.13) ESM1*/
;;;2897       u8LocalErrorState = 0;
00009e  4921              LDR      r1,|L8.292|
0000a0  7008              STRB     r0,[r1,#0]
;;;2898       /*ECATCHANGE_END(V5.13) ESM1*/
;;;2899       u16LocalErrorCode = 0x00;
0000a2  4921              LDR      r1,|L8.296|
0000a4  8008              STRH     r0,[r1,#0]
;;;2900   
;;;2901       u16ALEventMask = 0;
0000a6  4921              LDR      r1,|L8.300|
0000a8  8008              STRH     r0,[r1,#0]
;;;2902       nPdOutputSize = 0;
0000aa  4921              LDR      r1,|L8.304|
0000ac  8008              STRH     r0,[r1,#0]
;;;2903       nPdInputSize = 0;
0000ae  4921              LDR      r1,|L8.308|
0000b0  8008              STRH     r0,[r1,#0]
;;;2904   
;;;2905       /* initialize the AL Status register */
;;;2906       nAlStatus    = STATE_INIT;
0000b2  2001              MOVS     r0,#1
0000b4  4920              LDR      r1,|L8.312|
0000b6  7008              STRB     r0,[r1,#0]
;;;2907       SetALStatus(nAlStatus, 0);
0000b8  2100              MOVS     r1,#0
0000ba  481f              LDR      r0,|L8.312|
0000bc  7800              LDRB     r0,[r0,#0]  ; nAlStatus
0000be  f7fffffe          BL       SetALStatus
;;;2908       nEcatStateTrans = 0;
0000c2  2000              MOVS     r0,#0
0000c4  491d              LDR      r1,|L8.316|
0000c6  8008              STRH     r0,[r1,#0]
;;;2909       u8EcatErrorLed = LED_OFF;
0000c8  491d              LDR      r1,|L8.320|
0000ca  7008              STRB     r0,[r1,#0]
;;;2910   
;;;2911       bEscIntEnabled = FALSE;
0000cc  491d              LDR      r1,|L8.324|
0000ce  7008              STRB     r0,[r1,#0]
;;;2912   
;;;2913       /* initialize the emergency handler */
;;;2914       EMCY_Init();
0000d0  f7fffffe          BL       EMCY_Init
;;;2915       /* initialize the COE part */
;;;2916       COE_Init();
0000d4  f7fffffe          BL       COE_Init
;;;2917   /*ET9300 Project Handler :(#if AOE_SUPPORTED) lines 3867 to 3870 deleted*/
;;;2918   
;;;2919   /*ECATCHANGE_START(V5.13) ECAT1*/
;;;2920   /*ECATCHANGE_END(V5.13) ECAT1*/
;;;2921       /*reset AL event mask*/
;;;2922       ResetALEventMask(0);
0000d8  2000              MOVS     r0,#0
0000da  f7fffffe          BL       ResetALEventMask
;;;2923   }
0000de  bd38              POP      {r3-r5,pc}
;;;2924   
                          ENDP

                  |L8.224|
                          DCD      nMaxSyncMan
                  |L8.228|
                          DCD      nMaxEscAddress
                  |L8.232|
                          DCD      u16IdValue
                  |L8.236|
                          DCD      bBootMode
                  |L8.240|
                          DCD      bApplEsmPending
                  |L8.244|
                          DCD      bEcatWaitForAlControlRes
                  |L8.248|
                          DCD      bEcatFirstOutputsReceived
                  |L8.252|
                          DCD      bEcatOutputUpdateRunning
                  |L8.256|
                          DCD      bEcatInputUpdateRunning
                  |L8.260|
                          DCD      bExplicitDevIdRequested
                  |L8.264|
                          DCD      bWdTrigger
                  |L8.268|
                          DCD      EcatWdValue
                  |L8.272|
                          DCD      Sync0WdCounter
                  |L8.276|
                          DCD      Sync0WdValue
                  |L8.280|
                          DCD      Sync1WdCounter
                  |L8.284|
                          DCD      Sync1WdValue
                  |L8.288|
                          DCD      bDcSyncActive
                  |L8.292|
                          DCD      u8LocalErrorState
                  |L8.296|
                          DCD      u16LocalErrorCode
                  |L8.300|
                          DCD      u16ALEventMask
                  |L8.304|
                          DCD      nPdOutputSize
                  |L8.308|
                          DCD      nPdInputSize
                  |L8.312|
                          DCD      nAlStatus
                  |L8.316|
                          DCD      nEcatStateTrans
                  |L8.320|
                          DCD      u8EcatErrorLed
                  |L8.324|
                          DCD      bEscIntEnabled

                          AREA ||i.ECAT_Main||, CODE, READONLY, ALIGN=2

                  ECAT_Main PROC
;;;2929   
;;;2930   void ECAT_Main(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;2931   {
;;;2932       UINT16 ALEventReg;
;;;2933       UINT16 EscAlControl = 0x0000;
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
;;;2934   /*ECATCHANGE_START(V5.13) MBX1*/
;;;2935   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 3891 to 3894 deleted*/
;;;2936       UINT16 sm1Activate = SM_SETTING_ENABLE_VALUE;
000006  2001              MOVS     r0,#1
000008  9001              STR      r0,[sp,#4]
;;;2937       UINT16 sm1Status = 0; /*SM1 status need to be read (not MBX_READ_EVENT) to handle readframes with invalid CRCs*/
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;2938   /*ET9300 Project Handler :( #else) lines 3897 to 3900 deleted*/
;;;2939   /*ECATCHANGE_END(V5.13) MBX1*/
;;;2940   
;;;2941   
;;;2942       /* check if services are stored in the mailbox */
;;;2943       MBX_Main();
00000e  f7fffffe          BL       MBX_Main
;;;2944   
;;;2945   /*ET9300 Project Handler :(#if COE_SUPPORTED && TEST_APPLICATION) lines 3909 to 3949 deleted*/
;;;2946   
;;;2947       if ( bMbxRunning )
000012  485e              LDR      r0,|L9.396|
000014  7800              LDRB     r0,[r0,#0]  ; bMbxRunning
000016  b188              CBZ      r0,|L9.60|
;;;2948       {
;;;2949           /* Slave is at least in PREOP, Mailbox is running */
;;;2950   
;;;2951   /*ECATCHANGE_START(V5.13) MBX1*/
;;;2952   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 3956 to 3961 deleted*/
;;;2953           /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was received */
;;;2954           HW_EscReadWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
000018  2202              MOVS     r2,#2
00001a  f640010e          MOV      r1,#0x80e
00001e  a801              ADD      r0,sp,#4
000020  f7fffffe          BL       HW_EscRead
;;;2955           sm1Activate = SWAPWORD(sm1Activate);
000024  f8bd0004          LDRH     r0,[sp,#4]
000028  9001              STR      r0,[sp,#4]
;;;2956   
;;;2957           HW_EscReadWord(sm1Status, (ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
00002a  2202              MOVS     r2,#2
00002c  f640010c          MOV      r1,#0x80c
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       HW_EscRead
;;;2958           sm1Status = SWAPWORD(sm1Status);
000036  f8bd0000          LDRH     r0,[sp,#0]
00003a  9000              STR      r0,[sp,#0]
                  |L9.60|
;;;2959   /*ET9300 Project Handler :( #else) lines 3968 to 3973 deleted*/
;;;2960   /*ECATCHANGE_END(V5.13) MBX1*/
;;;2961       }
;;;2962   
;;;2963       /* Read AL Event-Register from ESC */
;;;2964       ALEventReg = HW_GetALEventRegister();
00003c  f7fffffe          BL       HW_GetALEventRegister
000040  4604              MOV      r4,r0
;;;2965       ALEventReg = SWAPWORD(ALEventReg);
000042  bf00              NOP      
;;;2966   
;;;2967   /*ET9300 Project Handler :(#if ESC_EEPROM_EMULATION) lines 3982 to 3987 deleted*/
;;;2968   
;;;2969       if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
000044  f0040001          AND      r0,r4,#1
000048  b338              CBZ      r0,|L9.154|
00004a  4851              LDR      r0,|L9.400|
00004c  7800              LDRB     r0,[r0,#0]  ; bEcatWaitForAlControlRes
00004e  bb20              CBNZ     r0,|L9.154|
;;;2970       {
;;;2971           /* AL Control event is set, get the AL Control register sent by the Master to acknowledge the event
;;;2972             (that the corresponding bit in the AL Event register will be reset) */
;;;2973   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 3993 to 3998 deleted*/
;;;2974   
;;;2975           HW_EscReadWord( EscAlControl, ESC_AL_CONTROL_OFFSET);
000050  2202              MOVS     r2,#2
000052  f44f7190          MOV      r1,#0x120
000056  a802              ADD      r0,sp,#8
000058  f7fffffe          BL       HW_EscRead
;;;2976           EscAlControl = SWAPWORD(EscAlControl);
00005c  f8bd0008          LDRH     r0,[sp,#8]
000060  9002              STR      r0,[sp,#8]
;;;2977   /*ET9300 Project Handler :( #else) lines 4002 to 4006 deleted*/
;;;2978   
;;;2979   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 4008 to 4023 deleted*/
;;;2980   
;;;2981               /*ECATCHANGE_START(V5.13) ECAT2*/
;;;2982                   /*Evaluate if register 0x120 Bit5 (Request Explicit DeviceID) is set*/
;;;2983               if ((EscAlControl & (UINT16)STATE_DEVID) == STATE_DEVID)
000062  f8bd0008          LDRH     r0,[sp,#8]
000066  f0000020          AND      r0,r0,#0x20
00006a  2820              CMP      r0,#0x20
00006c  d10a              BNE      |L9.132|
;;;2984               {
;;;2985                   if (bExplicitDevIdRequested == FALSE)
00006e  4849              LDR      r0,|L9.404|
000070  7800              LDRB     r0,[r0,#0]  ; bExplicitDevIdRequested
000072  b918              CBNZ     r0,|L9.124|
;;;2986                   {
;;;2987                       u16IdValue = APPL_GetDeviceID();
000074  f7fffffe          BL       APPL_GetDeviceID
000078  4947              LDR      r1,|L9.408|
00007a  8008              STRH     r0,[r1,#0]
                  |L9.124|
;;;2988                   }
;;;2989   
;;;2990                   bExplicitDevIdRequested = TRUE;
00007c  2001              MOVS     r0,#1
00007e  4945              LDR      r1,|L9.404|
000080  7008              STRB     r0,[r1,#0]
000082  e002              B        |L9.138|
                  |L9.132|
;;;2991               }
;;;2992               else
;;;2993               {
;;;2994                   bExplicitDevIdRequested = FALSE;
000084  2000              MOVS     r0,#0
000086  4943              LDR      r1,|L9.404|
000088  7008              STRB     r0,[r1,#0]
                  |L9.138|
;;;2995               }
;;;2996               /*ECATCHANGE_END(V5.13) ECAT2*/
;;;2997   
;;;2998           /* reset AL Control event and the SM Change event (because the Sync Manager settings will be checked
;;;2999              in AL_ControlInd, too)*/
;;;3000               ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
00008a  f0240411          BIC      r4,r4,#0x11
;;;3001   
;;;3002               AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
00008e  f8bd1008          LDRH     r1,[sp,#8]
000092  b2c8              UXTB     r0,r1
000094  2100              MOVS     r1,#0
000096  f7fffffe          BL       AL_ControlInd
                  |L9.154|
;;;3003   
;;;3004               /* SM-Change-Event was handled too */
;;;3005   
;;;3006   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 4052 to 4054 deleted*/
;;;3007       }
;;;3008   
;;;3009       if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
00009a  f0040010          AND      r0,r4,#0x10
00009e  b1b0              CBZ      r0,|L9.206|
0000a0  483b              LDR      r0,|L9.400|
0000a2  7800              LDRB     r0,[r0,#0]  ; bEcatWaitForAlControlRes
0000a4  b998              CBNZ     r0,|L9.206|
0000a6  483d              LDR      r0,|L9.412|
0000a8  7800              LDRB     r0,[r0,#0]  ; nAlStatus
0000aa  f0000010          AND      r0,r0,#0x10
0000ae  b970              CBNZ     r0,|L9.206|
0000b0  483a              LDR      r0,|L9.412|
0000b2  7800              LDRB     r0,[r0,#0]  ; nAlStatus
0000b4  f0200010          BIC      r0,r0,#0x10
0000b8  2801              CMP      r0,#1
0000ba  d008              BEQ      |L9.206|
;;;3010       {
;;;3011           /* the SM Change event is set (Bit 4 of Register 0x220), when the Byte 6 (Enable, Lo-Byte of Register 0x806, 0x80E, 0x816,...)
;;;3012              of a Sync Manager channel was written */
;;;3013           ALEventReg &= ~(SM_CHANGE_EVENT);
0000bc  f0240410          BIC      r4,r4,#0x10
;;;3014   
;;;3015           /* AL_ControlInd is called with the actual state, so that the correct SM settings will be checked */
;;;3016           AL_ControlInd(nAlStatus & STATE_MASK, 0);
0000c0  4936              LDR      r1,|L9.412|
0000c2  7809              LDRB     r1,[r1,#0]  ; nAlStatus
0000c4  f001000f          AND      r0,r1,#0xf
0000c8  2100              MOVS     r1,#0
0000ca  f7fffffe          BL       AL_ControlInd
                  |L9.206|
;;;3017       }
;;;3018   
;;;3019       if(bEcatWaitForAlControlRes)
0000ce  4830              LDR      r0,|L9.400|
0000d0  7800              LDRB     r0,[r0,#0]  ; bEcatWaitForAlControlRes
0000d2  b108              CBZ      r0,|L9.216|
;;;3020       {
;;;3021           AL_ControlRes();
0000d4  f7fffffe          BL       AL_ControlRes
                  |L9.216|
;;;3022       }
;;;3023       /*The order of mailbox event processing was changed to prevent race condition errors.
;;;3024           The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
;;;3025           1. Handle Mailbox Read event
;;;3026           2. Handle repeat toggle request
;;;3027           3. Handle Mailbox write event
;;;3028       */
;;;3029       if ( bMbxRunning )
0000d8  482c              LDR      r0,|L9.396|
0000da  7800              LDRB     r0,[r0,#0]  ; bMbxRunning
0000dc  2800              CMP      r0,#0
0000de  d054              BEQ      |L9.394|
;;;3030       {
;;;3031           /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control register without notification to the local application
;;;3032           => check if the SyncManger 1 is still enabled*/
;;;3033               if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
0000e0  f8bd0004          LDRH     r0,[sp,#4]
0000e4  f0000001          AND      r0,r0,#1
0000e8  b930              CBNZ     r0,|L9.248|
;;;3034               {
;;;3035                   AL_ControlInd(nAlStatus & STATE_MASK, 0);
0000ea  492c              LDR      r1,|L9.412|
0000ec  7809              LDRB     r1,[r1,#0]  ; nAlStatus
0000ee  f001000f          AND      r0,r1,#0xf
0000f2  2100              MOVS     r1,#0
0000f4  f7fffffe          BL       AL_ControlInd
                  |L9.248|
;;;3036               }
;;;3037   
;;;3038   /*ECATCHANGE_START(V5.13) MBX1*/
;;;3039           if (((sm1Status & SM_STATUS_MBX_BUFFER_FULL) == 0)
0000f8  f8bd0000          LDRH     r0,[sp,#0]
0000fc  f4006000          AND      r0,r0,#0x800
000100  b978              CBNZ     r0,|L9.290|
;;;3040               && bSendMbxIsFull) 
000102  4827              LDR      r0,|L9.416|
000104  7800              LDRB     r0,[r0,#0]  ; bSendMbxIsFull
000106  b160              CBZ      r0,|L9.290|
;;;3041   /*ECATCHANGE_END(V5.13) MBX1*/
;;;3042           {
;;;3043               /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
;;;3044                  to acknowledge the event the first byte of the mailbox has to be written,
;;;3045                  by writing the first byte the mailbox is locked, too */
;;;3046   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 4095 to 4098 deleted*/
;;;3047               u16dummy = 0;
000108  2000              MOVS     r0,#0
00010a  4926              LDR      r1,|L9.420|
00010c  8008              STRH     r0,[r1,#0]
;;;3048               HW_EscWriteWord(u16dummy,u16EscAddrSendMbx);
00010e  2202              MOVS     r2,#2
000110  4825              LDR      r0,|L9.424|
000112  8801              LDRH     r1,[r0,#0]  ; u16EscAddrSendMbx
000114  4823              LDR      r0,|L9.420|
000116  f7fffffe          BL       HW_EscWrite
;;;3049   /*ET9300 Project Handler :( #else) lines 4101 to 4104 deleted*/
;;;3050   
;;;3051               /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
;;;3052                  MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in the send mailbox */
;;;3053               ALEventReg &= ~(MAILBOX_READ_EVENT);
00011a  f4247400          BIC      r4,r4,#0x200
;;;3054               MBX_MailboxReadInd();
00011e  f7fffffe          BL       MBX_MailboxReadInd
                  |L9.290|
;;;3055           }
;;;3056   
;;;3057   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 4112 to 4115 deleted*/
;;;3058               /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */
;;;3059   
;;;3060               if (((sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle)
000122  f8bd0004          LDRH     r0,[sp,#4]
000126  f0000002          AND      r0,r0,#2
00012a  b110              CBZ      r0,|L9.306|
00012c  481f              LDR      r0,|L9.428|
00012e  7800              LDRB     r0,[r0,#0]  ; bMbxRepeatToggle
000130  b138              CBZ      r0,|L9.322|
                  |L9.306|
;;;3061                   || (!(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle))
000132  f8bd0004          LDRH     r0,[sp,#4]
000136  f0000002          AND      r0,r0,#2
00013a  b9d8              CBNZ     r0,|L9.372|
00013c  481b              LDR      r0,|L9.428|
00013e  7800              LDRB     r0,[r0,#0]  ; bMbxRepeatToggle
000140  b1c0              CBZ      r0,|L9.372|
                  |L9.322|
;;;3062               {
;;;3063                   /* Repeat Bit (Bit 1) has toggled, there is a repeat request, in MBX_MailboxRepeatReq the correct
;;;3064                      response will put in the send mailbox again */
;;;3065                   MBX_MailboxRepeatReq();
000142  f7fffffe          BL       MBX_MailboxRepeatReq
;;;3066                   /* acknowledge the repeat request after the send mailbox was updated by writing the Repeat Bit
;;;3067                      in the Repeat Ack Bit (Bit 1) of the PDI Ctrl-Byte of SM 1 (Register 0x80F) */
;;;3068   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 4126 to 4138 deleted*/
;;;3069                   if (bMbxRepeatToggle)
000146  4819              LDR      r0,|L9.428|
000148  7800              LDRB     r0,[r0,#0]  ; bMbxRepeatToggle
00014a  b128              CBZ      r0,|L9.344|
;;;3070                   {
;;;3071                       sm1Activate |= SM_SETTING_REPEAT_ACK; //set repeat acknowledge bit (bit 9)
00014c  f8bd0004          LDRH     r0,[sp,#4]
000150  f4407000          ORR      r0,r0,#0x200
000154  9001              STR      r0,[sp,#4]
000156  e004              B        |L9.354|
                  |L9.344|
;;;3072                   }
;;;3073                   else
;;;3074                   {
;;;3075                       sm1Activate &= ~SM_SETTING_REPEAT_ACK; //clear repeat acknowledge bit (bit 9)
000158  f8bd0004          LDRH     r0,[sp,#4]
00015c  f4207000          BIC      r0,r0,#0x200
000160  9001              STR      r0,[sp,#4]
                  |L9.354|
;;;3076                   }
;;;3077   
;;;3078                   sm1Activate = SWAPWORD(sm1Activate);
000162  f8bd0004          LDRH     r0,[sp,#4]
000166  9001              STR      r0,[sp,#4]
;;;3079                   HW_EscWriteWord(sm1Activate, (ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
000168  2202              MOVS     r2,#2
00016a  f640010e          MOV      r1,#0x80e
00016e  a801              ADD      r0,sp,#4
000170  f7fffffe          BL       HW_EscWrite
                  |L9.372|
;;;3080   /*ET9300 Project Handler :( #else) lines 4150 to 4153 deleted*/
;;;3081               }
;;;3082   
;;;3083   /*ET9300 Project Handler :(#if TEST_APPLICATION) lines 4156 to 4162 deleted*/
;;;3084   
;;;3085           /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an repeat request */
;;;3086           ALEventReg = HW_GetALEventRegister();
000174  f7fffffe          BL       HW_GetALEventRegister
000178  4604              MOV      r4,r0
;;;3087           ALEventReg = SWAPWORD(ALEventReg);
00017a  bf00              NOP      
;;;3088   
;;;3089           if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
00017c  f4047080          AND      r0,r4,#0x100
000180  b118              CBZ      r0,|L9.394|
;;;3090           {
;;;3091               /* SM 0 (Mailbox Write) event is set, when the mailbox was written from the master,
;;;3092                  to acknowledge the event the first byte of the mailbox has to be read,
;;;3093                  which will be done in MBX_CheckAndCopyMailbox */
;;;3094               /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
;;;3095                  MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
;;;3096               ALEventReg &= ~(MAILBOX_WRITE_EVENT);
000182  f4247480          BIC      r4,r4,#0x100
;;;3097               MBX_CheckAndCopyMailbox();
000186  f7fffffe          BL       MBX_CheckAndCopyMailbox
                  |L9.394|
;;;3098   
;;;3099   /*ET9300 Project Handler :(#if TEST_APPLICATION && !MAILBOX_QUEUE) lines 4178 to 4183 deleted*/
;;;3100           }
;;;3101       }
;;;3102   }
00018a  bd3e              POP      {r1-r5,pc}
;;;3103   
                          ENDP

                  |L9.396|
                          DCD      bMbxRunning
                  |L9.400|
                          DCD      bEcatWaitForAlControlRes
                  |L9.404|
                          DCD      bExplicitDevIdRequested
                  |L9.408|
                          DCD      u16IdValue
                  |L9.412|
                          DCD      nAlStatus
                  |L9.416|
                          DCD      bSendMbxIsFull
                  |L9.420|
                          DCD      u16dummy
                  |L9.424|
                          DCD      u16EscAddrSendMbx
                  |L9.428|
                          DCD      bMbxRepeatToggle

                          AREA ||i.ECAT_StateChange||, CODE, READONLY, ALIGN=2

                  ECAT_StateChange PROC
;;;2686   
;;;2687   void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
000000  b570              PUSH     {r4-r6,lr}
;;;2688   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2689       UINT8 Status = alStatus;
000006  4626              MOV      r6,r4
;;;2690   
;;;2691       /*ECATCHANGE_START(V5.13) ESM1*/
;;;2692       /*return in case of invalid parameters*/
;;;2693       if (alStatusCode != 0 && !STATE_VALID(alStatus))
000008  b185              CBZ      r5,|L10.44|
00000a  f004000f          AND      r0,r4,#0xf
00000e  2801              CMP      r0,#1
000010  d00c              BEQ      |L10.44|
000012  f004000f          AND      r0,r4,#0xf
000016  2802              CMP      r0,#2
000018  d008              BEQ      |L10.44|
00001a  f004000f          AND      r0,r4,#0xf
00001e  2804              CMP      r0,#4
000020  d004              BEQ      |L10.44|
000022  f004000f          AND      r0,r4,#0xf
000026  2808              CMP      r0,#8
000028  d000              BEQ      |L10.44|
                  |L10.42|
;;;2694       {
;;;2695           return;
;;;2696       }
;;;2697   
;;;2698       /* call the application requested state transition only once*/
;;;2699       if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
;;;2700       {
;;;2701           return;
;;;2702       }
;;;2703       /*ECATCHANGE_END(V5.13) ESM1*/
;;;2704   
;;;2705   
;;;2706       if(bEcatWaitForAlControlRes)
;;;2707       {
;;;2708           /*State transition is pending*/
;;;2709   
;;;2710           if(bApplEsmPending)
;;;2711           {
;;;2712               /*The generic stack has currently control of the state transition.
;;;2713               In case on an local error force ESM timeout*/
;;;2714               if(alStatusCode != 0)
;;;2715               {
;;;2716                   /*ECATCHANGE_START(V5.13) ESM1*/
;;;2717                   u8LocalErrorState = (alStatus & STATE_MASK);
;;;2718                   /*ECATCHANGE_END(V5.13) ESM1*/
;;;2719                   u16LocalErrorCode = alStatusCode;
;;;2720                   EsmTimeoutCounter = 0;
;;;2721               }
;;;2722               else
;;;2723               { 
;;;2724                   u8LocalErrorState = 0;
;;;2725                   u16LocalErrorCode = alStatusCode;
;;;2726               }
;;;2727           }
;;;2728           else
;;;2729           {
;;;2730               /*complete the state transition*/
;;;2731   
;;;2732               if(alStatusCode != 0)
;;;2733               {
;;;2734                   /*ECATCHANGE_START(V5.13) ESM1*/
;;;2735                   u8LocalErrorState = (alStatus & STATE_MASK);
;;;2736                   /*ECATCHANGE_END(V5.13) ESM1*/
;;;2737                   u16LocalErrorCode = alStatusCode;
;;;2738   
;;;2739                   /*State transition failed due to local application reasons*/
;;;2740                   switch(nEcatStateTrans)
;;;2741                   {
;;;2742                       case INIT_2_PREOP:
;;;2743                       case INIT_2_BOOT:
;;;2744                        
;;;2745                             APPL_StopMailboxHandler();
;;;2746                             MBX_StopMailboxHandler();
;;;2747                       break;
;;;2748                       case PREOP_2_SAFEOP:
;;;2749                             APPL_StopInputHandler();
;;;2750                             StopInputHandler();
;;;2751                       break;
;;;2752                       case SAFEOP_2_OP:
;;;2753                             APPL_StopOutputHandler();
;;;2754                             StopOutputHandler();
;;;2755                       break;
;;;2756                   }
;;;2757   
;;;2758                   /*In case of a failed state transition the */
;;;2759                   Status =  (UINT8)(nEcatStateTrans >> 4);
;;;2760               }
;;;2761               else
;;;2762               {
;;;2763                   /*State transition succeed*/
;;;2764                    
;;;2765                   switch(nEcatStateTrans)
;;;2766                   {
;;;2767                       case INIT_2_PREOP:
;;;2768                       case INIT_2_BOOT:
;;;2769                           bMbxRunning = TRUE;
;;;2770                       break;
;;;2771                       case PREOP_2_SAFEOP:
;;;2772   /*ECATCHANGE_START(V5.13) ECAT1*/
;;;2773   /*ECATCHANGE_END(V5.13) ECAT1*/
;;;2774                           /* initialize the AL Event Mask register (0x204) */
;;;2775                           SetALEventMask(u16ALEventMask);
;;;2776                           bEcatInputUpdateRunning = TRUE;
;;;2777                       break;
;;;2778                       case SAFEOP_2_OP:
;;;2779                             bEcatOutputUpdateRunning = TRUE;
;;;2780                       break;
;;;2781                   }
;;;2782   
;;;2783   
;;;2784   
;;;2785                   Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
;;;2786               }
;;;2787                   /*Pending state transition finished => write AL Status and AL Status Code*/
;;;2788                   bEcatWaitForAlControlRes = FALSE;
;;;2789   
;;;2790                   if (alStatusCode != 0)
;;;2791                   {
;;;2792                       Status |= STATE_CHANGE;
;;;2793                   }
;;;2794   /*ECATCHANGE_START(V5.13) ECAT3*/
;;;2795                   else if (u8LocalErrorState != 0)
;;;2796                   {
;;;2797                       /*a local error is cleared*/
;;;2798                       /*ECATCHANGE_START(V5.13) ESM1*/
;;;2799                       u8LocalErrorState = 0;
;;;2800                       /*ECATCHANGE_END(V5.13) ESM1*/
;;;2801                       u16LocalErrorCode = 0x00;
;;;2802                   }
;;;2803   /*ECATCHANGE_END(V5.13) ECAT3*/
;;;2804   
;;;2805                   SetALStatus(Status,alStatusCode);
;;;2806   
;;;2807           }/*state transition need to be completed by the local application*/
;;;2808       }/*State transition pending*/
;;;2809       else
;;;2810       {
;;;2811           /*ECATCHANGE_START(V5.13) ESM1*/
;;;2812           if ( alStatusCode != 0 && ((alStatus & STATE_MASK) != STATE_OP) && STATE_VALID(alStatus))
;;;2813           {
;;;2814               u8LocalErrorState = (alStatus & STATE_MASK);
;;;2815               /*ECATCHANGE_END(V5.13) ESM1*/
;;;2816               u16LocalErrorCode = alStatusCode;
;;;2817   
;;;2818               /*trigger state transition only state transition from OP to lower state (for all other transitions the corresponding state transition functions shall be used)*/
;;;2819               if ((nAlStatus & STATE_MASK) == STATE_OP)
;;;2820               {
;;;2821                  /* no error pending and the target state is lower than the current one*/
;;;2822                   AL_ControlInd(alStatus, alStatusCode);
;;;2823               }
;;;2824           }
;;;2825           /*ECATCHANGE_START(V5.13) ESM1*/
;;;2826           else if (u8LocalErrorState != 0)
;;;2827           {
;;;2828               /*a local error is gone*/
;;;2829               u8LocalErrorState = 0;
;;;2830               u16LocalErrorCode = 0x00;
;;;2831           }
;;;2832           /*ECATCHANGE_END(V5.13) ESM1*/
;;;2833       }
;;;2834   }
00002a  bd70              POP      {r4-r6,pc}
                  |L10.44|
00002c  4858              LDR      r0,|L10.400|
00002e  7800              LDRB     r0,[r0,#0]            ;2699  ; bEcatWaitForAlControlRes
000030  b940              CBNZ     r0,|L10.68|
000032  4858              LDR      r0,|L10.404|
000034  7800              LDRB     r0,[r0,#0]            ;2699  ; u8LocalErrorState
000036  42a0              CMP      r0,r4                 ;2699
000038  d104              BNE      |L10.68|
00003a  4857              LDR      r0,|L10.408|
00003c  8800              LDRH     r0,[r0,#0]            ;2699  ; u16LocalErrorCode
00003e  42a8              CMP      r0,r5                 ;2699
000040  d100              BNE      |L10.68|
000042  e7f2              B        |L10.42|
                  |L10.68|
000044  4852              LDR      r0,|L10.400|
000046  7800              LDRB     r0,[r0,#0]            ;2706  ; bEcatWaitForAlControlRes
000048  2800              CMP      r0,#0                 ;2706
00004a  d071              BEQ      |L10.304|
00004c  4853              LDR      r0,|L10.412|
00004e  7800              LDRB     r0,[r0,#0]            ;2710  ; bApplEsmPending
000050  b180              CBZ      r0,|L10.116|
000052  b14d              CBZ      r5,|L10.104|
000054  f004000f          AND      r0,r4,#0xf            ;2717
000058  494e              LDR      r1,|L10.404|
00005a  7008              STRB     r0,[r1,#0]            ;2717
00005c  484e              LDR      r0,|L10.408|
00005e  8005              STRH     r5,[r0,#0]            ;2719
000060  2000              MOVS     r0,#0                 ;2720
000062  494f              LDR      r1,|L10.416|
000064  8008              STRH     r0,[r1,#0]            ;2720
000066  e091              B        |L10.396|
                  |L10.104|
000068  2000              MOVS     r0,#0                 ;2724
00006a  494a              LDR      r1,|L10.404|
00006c  7008              STRB     r0,[r1,#0]            ;2724
00006e  484a              LDR      r0,|L10.408|
000070  8005              STRH     r5,[r0,#0]            ;2725
000072  e08b              B        |L10.396|
                  |L10.116|
000074  b335              CBZ      r5,|L10.196|
000076  f004000f          AND      r0,r4,#0xf            ;2735
00007a  4946              LDR      r1,|L10.404|
00007c  7008              STRB     r0,[r1,#0]            ;2735
00007e  4846              LDR      r0,|L10.408|
000080  8005              STRH     r5,[r0,#0]            ;2737
000082  4848              LDR      r0,|L10.420|
000084  8800              LDRH     r0,[r0,#0]            ;2740  ; nEcatStateTrans
000086  2812              CMP      r0,#0x12              ;2740
000088  d006              BEQ      |L10.152|
00008a  2813              CMP      r0,#0x13              ;2740
00008c  d005              BEQ      |L10.154|
00008e  2824              CMP      r0,#0x24              ;2740
000090  d008              BEQ      |L10.164|
000092  2848              CMP      r0,#0x48              ;2740
000094  d110              BNE      |L10.184|
000096  e00a              B        |L10.174|
                  |L10.152|
000098  bf00              NOP                            ;2743
                  |L10.154|
00009a  f7fffffe          BL       APPL_StopMailboxHandler
00009e  f7fffffe          BL       MBX_StopMailboxHandler
0000a2  e009              B        |L10.184|
                  |L10.164|
0000a4  f7fffffe          BL       APPL_StopInputHandler
0000a8  f7fffffe          BL       StopInputHandler
0000ac  e004              B        |L10.184|
                  |L10.174|
0000ae  f7fffffe          BL       APPL_StopOutputHandler
0000b2  f7fffffe          BL       StopOutputHandler
0000b6  bf00              NOP                            ;2755
                  |L10.184|
0000b8  bf00              NOP                            ;2747
0000ba  483a              LDR      r0,|L10.420|
0000bc  8800              LDRH     r0,[r0,#0]            ;2759  ; nEcatStateTrans
0000be  f3c01607          UBFX     r6,r0,#4,#8           ;2759
0000c2  e020              B        |L10.262|
                  |L10.196|
0000c4  4837              LDR      r0,|L10.420|
0000c6  8800              LDRH     r0,[r0,#0]            ;2765  ; nEcatStateTrans
0000c8  2812              CMP      r0,#0x12              ;2765
0000ca  d006              BEQ      |L10.218|
0000cc  2813              CMP      r0,#0x13              ;2765
0000ce  d005              BEQ      |L10.220|
0000d0  2824              CMP      r0,#0x24              ;2765
0000d2  d007              BEQ      |L10.228|
0000d4  2848              CMP      r0,#0x48              ;2765
0000d6  d111              BNE      |L10.252|
0000d8  e00c              B        |L10.244|
                  |L10.218|
0000da  bf00              NOP                            ;2768
                  |L10.220|
0000dc  2001              MOVS     r0,#1                 ;2769
0000de  4932              LDR      r1,|L10.424|
0000e0  7008              STRB     r0,[r1,#0]            ;2769
0000e2  e00b              B        |L10.252|
                  |L10.228|
0000e4  4831              LDR      r0,|L10.428|
0000e6  8800              LDRH     r0,[r0,#0]            ;2775  ; u16ALEventMask
0000e8  f7fffffe          BL       SetALEventMask
0000ec  2001              MOVS     r0,#1                 ;2776
0000ee  4930              LDR      r1,|L10.432|
0000f0  7008              STRB     r0,[r1,#0]            ;2776
0000f2  e003              B        |L10.252|
                  |L10.244|
0000f4  2001              MOVS     r0,#1                 ;2779
0000f6  492f              LDR      r1,|L10.436|
0000f8  7008              STRB     r0,[r1,#0]            ;2779
0000fa  bf00              NOP                            ;2780
                  |L10.252|
0000fc  bf00              NOP                            ;2770
0000fe  4829              LDR      r0,|L10.420|
000100  7800              LDRB     r0,[r0,#0]            ;2785  ; nEcatStateTrans
000102  f000060f          AND      r6,r0,#0xf            ;2785
                  |L10.262|
000106  2000              MOVS     r0,#0                 ;2788
000108  4921              LDR      r1,|L10.400|
00010a  7008              STRB     r0,[r1,#0]            ;2788
00010c  b115              CBZ      r5,|L10.276|
00010e  f0460610          ORR      r6,r6,#0x10           ;2792
000112  e007              B        |L10.292|
                  |L10.276|
000114  481f              LDR      r0,|L10.404|
000116  7800              LDRB     r0,[r0,#0]            ;2795  ; u8LocalErrorState
000118  b120              CBZ      r0,|L10.292|
00011a  2000              MOVS     r0,#0                 ;2799
00011c  491d              LDR      r1,|L10.404|
00011e  7008              STRB     r0,[r1,#0]            ;2799
000120  491d              LDR      r1,|L10.408|
000122  8008              STRH     r0,[r1,#0]            ;2801
                  |L10.292|
000124  4629              MOV      r1,r5                 ;2805
000126  4630              MOV      r0,r6                 ;2805
000128  f7fffffe          BL       SetALStatus
00012c  e02e              B        |L10.396|
00012e  e7ff              B        |L10.304|
                  |L10.304|
000130  b325              CBZ      r5,|L10.380|
000132  f004000f          AND      r0,r4,#0xf            ;2812
000136  2808              CMP      r0,#8                 ;2812
000138  d020              BEQ      |L10.380|
00013a  f004000f          AND      r0,r4,#0xf            ;2812
00013e  2801              CMP      r0,#1                 ;2812
000140  d00b              BEQ      |L10.346|
000142  f004000f          AND      r0,r4,#0xf            ;2812
000146  2802              CMP      r0,#2                 ;2812
000148  d007              BEQ      |L10.346|
00014a  f004000f          AND      r0,r4,#0xf            ;2812
00014e  2804              CMP      r0,#4                 ;2812
000150  d003              BEQ      |L10.346|
000152  f004000f          AND      r0,r4,#0xf            ;2812
000156  2808              CMP      r0,#8                 ;2812
000158  d110              BNE      |L10.380|
                  |L10.346|
00015a  f004000f          AND      r0,r4,#0xf            ;2814
00015e  490d              LDR      r1,|L10.404|
000160  7008              STRB     r0,[r1,#0]            ;2814
000162  480d              LDR      r0,|L10.408|
000164  8005              STRH     r5,[r0,#0]            ;2816
000166  4814              LDR      r0,|L10.440|
000168  7800              LDRB     r0,[r0,#0]            ;2819  ; nAlStatus
00016a  f000000f          AND      r0,r0,#0xf            ;2819
00016e  2808              CMP      r0,#8                 ;2819
000170  d10c              BNE      |L10.396|
000172  4629              MOV      r1,r5                 ;2822
000174  4620              MOV      r0,r4                 ;2822
000176  f7fffffe          BL       AL_ControlInd
00017a  e007              B        |L10.396|
                  |L10.380|
00017c  4805              LDR      r0,|L10.404|
00017e  7800              LDRB     r0,[r0,#0]            ;2826  ; u8LocalErrorState
000180  b120              CBZ      r0,|L10.396|
000182  2000              MOVS     r0,#0                 ;2829
000184  4903              LDR      r1,|L10.404|
000186  7008              STRB     r0,[r1,#0]            ;2829
000188  4903              LDR      r1,|L10.408|
00018a  8008              STRH     r0,[r1,#0]            ;2830
                  |L10.396|
00018c  bf00              NOP      
00018e  e74c              B        |L10.42|
;;;2835   
                          ENDP

                  |L10.400|
                          DCD      bEcatWaitForAlControlRes
                  |L10.404|
                          DCD      u8LocalErrorState
                  |L10.408|
                          DCD      u16LocalErrorCode
                  |L10.412|
                          DCD      bApplEsmPending
                  |L10.416|
                          DCD      EsmTimeoutCounter
                  |L10.420|
                          DCD      nEcatStateTrans
                  |L10.424|
                          DCD      bMbxRunning
                  |L10.428|
                          DCD      u16ALEventMask
                  |L10.432|
                          DCD      bEcatInputUpdateRunning
                  |L10.436|
                          DCD      bEcatOutputUpdateRunning
                  |L10.440|
                          DCD      nAlStatus

                          AREA ||i.EnableSyncManChannel||, CODE, READONLY, ALIGN=1

                  EnableSyncManChannel PROC
;;;407    *////////////////////////////////////////////////////////////////////////////////////////
;;;408    void EnableSyncManChannel(UINT8 channel)
000000  b538              PUSH     {r3-r5,lr}
;;;409    {
000002  4604              MOV      r4,r0
;;;410        UINT16 Offset;
;;;411    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 549 to 569 deleted*/
;;;412        //The register 0x806 is only readable from PDI => writing 0 is valid
;;;413        VARVOLATILE UINT16 smStatus = 0x0000;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;414        Offset = (ESC_SYNCMAN_ACTIVE_OFFSET + (SIZEOF_SM_REGISTER*channel));
000008  00e0              LSLS     r0,r4,#3
00000a  f6000506          ADD      r5,r0,#0x806
;;;415    
;;;416    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 574 to 576 deleted*/
;;;417    
;;;418        HW_EscWriteWord(smStatus,Offset);
00000e  2202              MOVS     r2,#2
000010  4629              MOV      r1,r5
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       HW_EscWrite
;;;419        
;;;420        /*wait until SyncManager is enabled*/
;;;421        do
000018  bf00              NOP      
                  |L11.26|
;;;422        {
;;;423            HW_EscReadWord(smStatus,Offset);
00001a  2202              MOVS     r2,#2
00001c  4629              MOV      r1,r5
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       HW_EscRead
;;;424    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 584 to 586 deleted*/
;;;425    
;;;426        }while((smStatus & SM_SETTING_PDI_DISABLE));
000024  f8bd0000          LDRH     r0,[sp,#0]
000028  f4007080          AND      r0,r0,#0x100
00002c  2800              CMP      r0,#0
00002e  d1f4              BNE      |L11.26|
;;;427    /*ET9300 Project Handler :( #else) lines 589 to 600 deleted*/
;;;428    }
000030  bd38              POP      {r3-r5,pc}
;;;429    
                          ENDP


                          AREA ||i.GetSyncMan||, CODE, READONLY, ALIGN=2

                  GetSyncMan PROC
;;;364    
;;;365    TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
000000  b510              PUSH     {r4,lr}
;;;366    {
000002  4604              MOV      r4,r0
;;;367        HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
000004  f44f6000          MOV      r0,#0x800
000008  eb0001c4          ADD      r1,r0,r4,LSL #3
00000c  2208              MOVS     r2,#8
00000e  4802              LDR      r0,|L12.24|
000010  f7fffffe          BL       HW_EscRead
;;;368    
;;;369    
;;;370    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 462 to 474 deleted*/
;;;371    
;;;372        return &SyncManInfo;
000014  4800              LDR      r0,|L12.24|
;;;373    }
000016  bd10              POP      {r4,pc}
;;;374    
                          ENDP

                  |L12.24|
                          DCD      SyncManInfo

                          AREA ||i.ResetALEventMask||, CODE, READONLY, ALIGN=2

                  ResetALEventMask PROC
;;;276    *////////////////////////////////////////////////////////////////////////////////////////
;;;277    void ResetALEventMask(UINT16 intMask)
000000  b538              PUSH     {r3-r5,lr}
;;;278    {
000002  4604              MOV      r4,r0
;;;279    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 322 to 330 deleted*/
;;;280        UINT16 mask;
;;;281        HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
000004  2202              MOVS     r2,#2
000006  f44f7101          MOV      r1,#0x204
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       HW_EscRead
;;;282        
;;;283    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 334 to 336 deleted*/
;;;284        mask &= intMask;
000010  f8bd0000          LDRH     r0,[sp,#0]
000014  4020              ANDS     r0,r0,r4
000016  9000              STR      r0,[sp,#0]
;;;285    
;;;286    
;;;287        DISABLE_ESC_INT();
000018  f7fffffe          BL       PDI_Disable_Global_Interrupt
00001c  4906              LDR      r1,|L13.56|
00001e  6008              STR      r0,[r1,#0]  ; restore_intsts
;;;288    
;;;289    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 345 to 350 deleted*/
;;;290    
;;;291    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 352 to 354 deleted*/
;;;292        HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
000020  2202              MOVS     r2,#2
000022  f44f7101          MOV      r1,#0x204
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       HW_EscWrite
;;;293        ENABLE_ESC_INT();
00002c  4802              LDR      r0,|L13.56|
00002e  6800              LDR      r0,[r0,#0]  ; restore_intsts
000030  f7fffffe          BL       PDI_Restore_Global_Interrupt
;;;294    }
000034  bd38              POP      {r3-r5,pc}
;;;295    
                          ENDP

000036  0000              DCW      0x0000
                  |L13.56|
                          DCD      restore_intsts

                          AREA ||i.SendSmFailedEmergency||, CODE, READONLY, ALIGN=2

                  SendSmFailedEmergency PROC
;;;440    
;;;441    void    SendSmFailedEmergency(UINT8 channel, UINT8 faultyCode)
000000  b570              PUSH     {r4-r6,lr}
;;;442    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;443        TEMCYMESSAGE EMCYMEM *    pEmcy    = EMCY_GetEmcyBuffer();
000006  f7fffffe          BL       EMCY_GetEmcyBuffer
00000a  4604              MOV      r4,r0
;;;444    
;;;445    
;;;446        if ( pEmcy )
00000c  2c00              CMP      r4,#0
00000e  d064              BEQ      |L14.218|
;;;447        {
;;;448    
;;;449            /* Emergency buffer is available, the faultyCode gives the information about the error reason
;;;450               and has to be decremented to match the following definitions:
;;;451                 8: Sync Manager 2 does not support an odd address
;;;452                 9: Address of Sync Manager 2 is not supported
;;;453                10: Size of Sync Manager 2 is not supported
;;;454                11: Settings of Sync Manager 2 are not supported
;;;455                12: Sync Manager 3 does not support an odd address
;;;456                13: Address of Sync Manager 3 is not supported
;;;457                14: Size of Sync Manager 3 is not supported
;;;458                15: Settings of Sync Manager 3 are not supported
;;;459                16: Sync Manager 4 does not support an odd address
;;;460                17: Address of Sync Manager 4 is not supported
;;;461                18: Size of Sync Manager 4 is not supported
;;;462                19: Settings of Sync Manager 4 are not supported
;;;463                20: Sync Manager 5 does not support an odd address
;;;464                21: Address of Sync Manager 5 is not supported
;;;465                22: Size of Sync Manager 5 is not supported
;;;466                23: Settings of Sync Manager 5 are not supported
;;;467                24: Sync Manager 6 does not support an odd address
;;;468                25: Address of Sync Manager 6 is not supported
;;;469                26: Size of Sync Manager 6 is not supported
;;;470                27: Settings of Sync Manager 6 are not supported
;;;471                28: Sync Manager 7 does not support an odd address
;;;472                29: Address of Sync Manager 7 is not supported
;;;473                30: Size of Sync Manager 7 is not supported
;;;474                31: Settings of Sync Manager 7 are not supported
;;;475            */
;;;476            faultyCode--;
000010  1e68              SUBS     r0,r5,#1
000012  b2c5              UXTB     r5,r0
;;;477            /* the faultyCode is stored in byte 3 of the Emergency */
;;;478            pEmcy->Emcy.RegData[EMCY_OFFS_DIAGCODE] &= ~EMCY_MASK_DIAGCODE;
000014  78a0              LDRB     r0,[r4,#2]
000016  8060              STRH     r0,[r4,#2]
;;;479            pEmcy->Emcy.RegData[EMCY_OFFS_DIAGCODE] |= ERROR_SYNCMANCH(faultyCode, channel) << EMCY_SHIFT_DIAGCODE;
000018  8860              LDRH     r0,[r4,#2]
00001a  eb050186          ADD      r1,r5,r6,LSL #2
00001e  ea402001          ORR      r0,r0,r1,LSL #8
000022  8060              STRH     r0,[r4,#2]
;;;480    
;;;481            /* the correct settings are stored in byte 4-7 of the Emergency */
;;;482            switch (channel)
000024  2e02              CMP      r6,#2
000026  d002              BEQ      |L14.46|
000028  2e03              CMP      r6,#3
00002a  d142              BNE      |L14.178|
00002c  e020              B        |L14.112|
                  |L14.46|
;;;483            {
;;;484            case PROCESS_DATA_OUT:
;;;485                switch (faultyCode)
00002e  b15d              CBZ      r5,|L14.72|
000030  2d01              CMP      r5,#1
000032  d002              BEQ      |L14.58|
000034  2d02              CMP      r5,#2
000036  d119              BNE      |L14.108|
000038  e00c              B        |L14.84|
                  |L14.58|
;;;486                {
;;;487                case SYNCMANCHADDRESS:
;;;488                    /* store the minimum output address in byte 4,5 */
;;;489                    pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA] = SWAPWORD(MIN_PD_WRITE_ADDRESS);
00003a  f44f5180          MOV      r1,#0x1000
00003e  80a1              STRH     r1,[r4,#4]
;;;490                    /* store the maximum output address in byte 6,7 */
;;;491                    pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA+1] = SWAPWORD(MAX_PD_WRITE_ADDRESS);
000040  f64171ff          MOV      r1,#0x1fff
000044  80e1              STRH     r1,[r4,#6]
;;;492                    break;
000046  e011              B        |L14.108|
                  |L14.72|
;;;493                case SYNCMANCHSIZE:
;;;494                    /* store the minimum output size in byte 4,5 */
;;;495                    pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA] = SWAPWORD(nPdOutputSize);
000048  4824              LDR      r0,|L14.220|
00004a  8801              LDRH     r1,[r0,#0]  ; nPdOutputSize
00004c  80a1              STRH     r1,[r4,#4]
;;;496                    /* store the maximum output size in byte 6,7 */
;;;497                    pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA+1] = SWAPWORD(nPdOutputSize);
00004e  8801              LDRH     r1,[r0,#0]  ; nPdOutputSize
000050  80e1              STRH     r1,[r4,#6]
;;;498    /*ET9300 Project Handler :(#if MAX_PD_OUTPUT_SIZE > 0 #else) lines 731 to 736 deleted*/
;;;499                    break;
000052  e00b              B        |L14.108|
                  |L14.84|
;;;500                case SYNCMANCHSETTINGS:
;;;501                    /* store the correct settings for the output sync manager in byte 4-7 */
;;;502                    if (nPdOutputSize)
000054  4821              LDR      r0,|L14.220|
000056  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
000058  b120              CBZ      r0,|L14.100|
;;;503                    {
;;;504                        pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA] = SWAPWORD(0xA); //Diagdata according to ETG.1000 (0x02 + channel *4)
00005a  210a              MOVS     r1,#0xa
00005c  80a1              STRH     r1,[r4,#4]
;;;505    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 744 to 746 deleted*/
;;;506                        pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA+1] = SWAPWORD(SM_SETTING_ENABLE_VALUE);
00005e  2101              MOVS     r1,#1
000060  80e1              STRH     r1,[r4,#6]
000062  e002              B        |L14.106|
                  |L14.100|
;;;507                    }
;;;508                    else
;;;509                    {
;;;510                        pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA] = 0;
000064  2100              MOVS     r1,#0
000066  80a1              STRH     r1,[r4,#4]
;;;511                        pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA+1] = 0;
000068  80e1              STRH     r1,[r4,#6]
                  |L14.106|
;;;512                    }
;;;513                    break;
00006a  bf00              NOP      
                  |L14.108|
00006c  bf00              NOP                            ;492
;;;514                }
;;;515                break;
00006e  e024              B        |L14.186|
                  |L14.112|
;;;516            case PROCESS_DATA_IN:
;;;517                switch (faultyCode)
000070  b15d              CBZ      r5,|L14.138|
000072  2d01              CMP      r5,#1
000074  d002              BEQ      |L14.124|
000076  2d02              CMP      r5,#2
000078  d119              BNE      |L14.174|
00007a  e00c              B        |L14.150|
                  |L14.124|
;;;518                {
;;;519                case SYNCMANCHADDRESS:
;;;520                    /* store the minimum input address in byte 4,5 */
;;;521                    pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA]   = SWAPWORD(MIN_PD_READ_ADDRESS);
00007c  f44f5180          MOV      r1,#0x1000
000080  80a1              STRH     r1,[r4,#4]
;;;522                    /* store the maximum input address in byte 6,7 */
;;;523                    pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA+1] = SWAPWORD(MAX_PD_READ_ADDRESS);
000082  f64171ff          MOV      r1,#0x1fff
000086  80e1              STRH     r1,[r4,#6]
;;;524                    break;
000088  e011              B        |L14.174|
                  |L14.138|
;;;525                case SYNCMANCHSIZE:
;;;526                    /* store the minimum input size in byte 4,5 */
;;;527                    pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA]   = SWAPWORD(nPdInputSize);
00008a  4815              LDR      r0,|L14.224|
00008c  8801              LDRH     r1,[r0,#0]  ; nPdInputSize
00008e  80a1              STRH     r1,[r4,#4]
;;;528                    /* store the maximum input size in byte 6,7 */
;;;529                    pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA+1] = SWAPWORD(nPdInputSize);
000090  8801              LDRH     r1,[r0,#0]  ; nPdInputSize
000092  80e1              STRH     r1,[r4,#6]
;;;530    /*ET9300 Project Handler :(#if MAX_PD_INPUT_SIZE > 0 #else) lines 774 to 779 deleted*/
;;;531                    break;
000094  e00b              B        |L14.174|
                  |L14.150|
;;;532                case SYNCMANCHSETTINGS:
;;;533                    /* store the correct settings for the input sync manager in byte 4-7 */
;;;534                    if (nPdInputSize)
000096  4812              LDR      r0,|L14.224|
000098  8800              LDRH     r0,[r0,#0]  ; nPdInputSize
00009a  b120              CBZ      r0,|L14.166|
;;;535                    {
;;;536    
;;;537                        pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA]   = SWAPWORD(0xE); //Diagdata according to ETG.1000 (0x02 + channel *4)
00009c  210e              MOVS     r1,#0xe
00009e  80a1              STRH     r1,[r4,#4]
;;;538    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 788 to 790 deleted*/
;;;539                        pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA+1] = SWAPWORD(SM_SETTING_ENABLE_VALUE);
0000a0  2101              MOVS     r1,#1
0000a2  80e1              STRH     r1,[r4,#6]
0000a4  e002              B        |L14.172|
                  |L14.166|
;;;540                    }
;;;541                    else
;;;542                    {
;;;543    
;;;544                        pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA]   = 0;
0000a6  2100              MOVS     r1,#0
0000a8  80a1              STRH     r1,[r4,#4]
;;;545                        pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA+1] = 0;
0000aa  80e1              STRH     r1,[r4,#6]
                  |L14.172|
;;;546                    }
;;;547                    break;
0000ac  bf00              NOP      
                  |L14.174|
0000ae  bf00              NOP                            ;524
;;;548                }
;;;549                break;
0000b0  e003              B        |L14.186|
                  |L14.178|
;;;550            default:
;;;551                pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA]   = 0;
0000b2  2100              MOVS     r1,#0
0000b4  80a1              STRH     r1,[r4,#4]
;;;552                pEmcy->Emcy.RegData[EMCY_OFFS_DIAGDATA+1] = 0;
0000b6  80e1              STRH     r1,[r4,#6]
0000b8  bf00              NOP                            ;482
                  |L14.186|
0000ba  bf00              NOP                            ;515
;;;553            }
;;;554    
;;;555            /* set the byte 0,1 of the Emergency to the state transition fault */
;;;556            pEmcy->Emcy.Code = SWAPWORD(EMCY_SM_ERRORCODE);
0000bc  f44f4020          MOV      r0,#0xa000
0000c0  8020              STRH     r0,[r4,#0]
;;;557            /* set the byte 2 of the Emergency to the actual state */
;;;558    
;;;559            pEmcy->Emcy.RegData[EMCY_OFFS_ERRORREGISTER] &= ~EMCY_MASK_ERRORREGISTER;
0000c2  8860              LDRH     r0,[r4,#2]
0000c4  f02000ff          BIC      r0,r0,#0xff
0000c8  8060              STRH     r0,[r4,#2]
;;;560            pEmcy->Emcy.RegData[EMCY_OFFS_ERRORREGISTER] |= nAlStatus << EMCY_SHIFT_ERRORREGISTER;
0000ca  8860              LDRH     r0,[r4,#2]
0000cc  4905              LDR      r1,|L14.228|
0000ce  7809              LDRB     r1,[r1,#0]  ; nAlStatus
0000d0  4308              ORRS     r0,r0,r1
0000d2  8060              STRH     r0,[r4,#2]
;;;561    
;;;562            EMCY_SendEmergency(pEmcy);
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       EMCY_SendEmergency
                  |L14.218|
;;;563        }
;;;564    }
0000da  bd70              POP      {r4-r6,pc}
;;;565    
                          ENDP

                  |L14.220|
                          DCD      nPdOutputSize
                  |L14.224|
                          DCD      nPdInputSize
                  |L14.228|
                          DCD      nAlStatus

                          AREA ||i.SetALEventMask||, CODE, READONLY, ALIGN=2

                  SetALEventMask PROC
;;;301    *////////////////////////////////////////////////////////////////////////////////////////
;;;302    void SetALEventMask(UINT16 intMask)
000000  b538              PUSH     {r3-r5,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 368 to 376 deleted*/
;;;305        UINT16 mask;
;;;306        HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
000004  2202              MOVS     r2,#2
000006  f44f7101          MOV      r1,#0x204
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       HW_EscRead
;;;307        
;;;308    
;;;309    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 381 to 383 deleted*/
;;;310        mask |= intMask;
000010  f8bd0000          LDRH     r0,[sp,#0]
000014  4320              ORRS     r0,r0,r4
000016  9000              STR      r0,[sp,#0]
;;;311    
;;;312        DISABLE_ESC_INT();
000018  f7fffffe          BL       PDI_Disable_Global_Interrupt
00001c  4906              LDR      r1,|L15.56|
00001e  6008              STR      r0,[r1,#0]  ; restore_intsts
;;;313    
;;;314    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 391 to 396 deleted*/
;;;315    
;;;316    /*ET9300 Project Handler :(#if BIG_ENDIAN_FORMAT) lines 398 to 400 deleted*/
;;;317        HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
000020  2202              MOVS     r2,#2
000022  f44f7101          MOV      r1,#0x204
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       HW_EscWrite
;;;318        ENABLE_ESC_INT();
00002c  4802              LDR      r0,|L15.56|
00002e  6800              LDR      r0,[r0,#0]  ; restore_intsts
000030  f7fffffe          BL       PDI_Restore_Global_Interrupt
;;;319    }
000034  bd38              POP      {r3-r5,pc}
;;;320    
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      restore_intsts

                          AREA ||i.SetALStatus||, CODE, READONLY, ALIGN=2

                  SetALStatus PROC
;;;1617   *////////////////////////////////////////////////////////////////////////////////////////
;;;1618   void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
000000  b57c              PUSH     {r2-r6,lr}
;;;1619   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1620       UINT16 Value = alStatusCode;
000006  9401              STR      r4,[sp,#4]
;;;1621   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 2318 to 2320 deleted*/
;;;1622   
;;;1623       /*update global status variable if required*/
;;;1624       if(nAlStatus != alStatus)
000008  484c              LDR      r0,|L16.316|
00000a  7800              LDRB     r0,[r0,#0]  ; nAlStatus
00000c  42a8              CMP      r0,r5
00000e  d001              BEQ      |L16.20|
;;;1625       {
;;;1626           nAlStatus = alStatus;
000010  484a              LDR      r0,|L16.316|
000012  7005              STRB     r5,[r0,#0]
                  |L16.20|
;;;1627       }
;;;1628   
;;;1629       /*Handle Explicit Device ID is requested*/
;;;1630       if(bExplicitDevIdRequested && !(nAlStatus & STATE_CHANGE) && alStatusCode == 0 && ((nAlStatus & STATE_MASK) != STATE_BOOT))
000014  484a              LDR      r0,|L16.320|
000016  7800              LDRB     r0,[r0,#0]  ; bExplicitDevIdRequested
000018  b1a8              CBZ      r0,|L16.70|
00001a  4848              LDR      r0,|L16.316|
00001c  7800              LDRB     r0,[r0,#0]  ; nAlStatus
00001e  f0000010          AND      r0,r0,#0x10
000022  b980              CBNZ     r0,|L16.70|
000024  b97c              CBNZ     r4,|L16.70|
000026  4845              LDR      r0,|L16.316|
000028  7800              LDRB     r0,[r0,#0]  ; nAlStatus
00002a  f000000f          AND      r0,r0,#0xf
00002e  2803              CMP      r0,#3
000030  d009              BEQ      |L16.70|
;;;1631       {
;;;1632   /*ECATCHANGE_START(V5.13) ECAT2*/
;;;1633           Value = u16IdValue;
000032  4844              LDR      r0,|L16.324|
000034  8800              LDRH     r0,[r0,#0]  ; u16IdValue
000036  9001              STR      r0,[sp,#4]
;;;1634   /*ECATCHANGE_END(V5.13) ECAT2*/
;;;1635           nAlStatus |= STATE_DEVID;
000038  4840              LDR      r0,|L16.316|
00003a  7800              LDRB     r0,[r0,#0]  ; nAlStatus
00003c  f0400020          ORR      r0,r0,#0x20
000040  493e              LDR      r1,|L16.316|
000042  7008              STRB     r0,[r1,#0]
000044  e005              B        |L16.82|
                  |L16.70|
;;;1636       }
;;;1637       else
;;;1638       {
;;;1639           nAlStatus &= ~STATE_DEVID;
000046  483d              LDR      r0,|L16.316|
000048  7800              LDRB     r0,[r0,#0]  ; nAlStatus
00004a  f0200020          BIC      r0,r0,#0x20
00004e  493b              LDR      r1,|L16.316|
000050  7008              STRB     r0,[r1,#0]
                  |L16.82|
;;;1640       }
;;;1641   
;;;1642       if (alStatusCode != 0xFFFF)
000052  f64f70ff          MOV      r0,#0xffff
000056  4284              CMP      r4,r0
000058  d008              BEQ      |L16.108|
;;;1643       {
;;;1644   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 2345 to 2349 deleted*/
;;;1645           Value = SWAPWORD(Value);
00005a  f8bd0004          LDRH     r0,[sp,#4]
00005e  9001              STR      r0,[sp,#4]
;;;1646   
;;;1647           HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
000060  2202              MOVS     r2,#2
000062  f44f719a          MOV      r1,#0x134
000066  a801              ADD      r0,sp,#4
000068  f7fffffe          BL       HW_EscWrite
                  |L16.108|
;;;1648       }
;;;1649   
;;;1650   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 2356 to 2361 deleted*/
;;;1651       Value = nAlStatus;
00006c  4833              LDR      r0,|L16.316|
00006e  7800              LDRB     r0,[r0,#0]  ; nAlStatus
000070  9001              STR      r0,[sp,#4]
;;;1652       Value = SWAPWORD(Value);
000072  f8bd0004          LDRH     r0,[sp,#4]
000076  9001              STR      r0,[sp,#4]
;;;1653       HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
000078  2202              MOVS     r2,#2
00007a  f44f7198          MOV      r1,#0x130
00007e  a801              ADD      r0,sp,#4
000080  f7fffffe          BL       HW_EscWrite
;;;1654   
;;;1655       /*The Run LED state is set in Set LED Indication, only the Error LED blink code is set here*/
;;;1656   
;;;1657       /*set Error blink code*/
;;;1658       if(alStatusCode == 0x00 || !(alStatus & STATE_CHANGE))
000084  b114              CBZ      r4,|L16.140|
000086  f0050010          AND      r0,r5,#0x10
00008a  b918              CBNZ     r0,|L16.148|
                  |L16.140|
;;;1659       {
;;;1660           u8EcatErrorLed = LED_OFF;
00008c  2000              MOVS     r0,#0
00008e  492e              LDR      r1,|L16.328|
000090  7008              STRB     r0,[r1,#0]
000092  e016              B        |L16.194|
                  |L16.148|
;;;1661       }
;;;1662       else if((alStatusCode == ALSTATUSCODE_NOSYNCERROR) ||
000094  2c2d              CMP      r4,#0x2d
000096  d007              BEQ      |L16.168|
;;;1663           (alStatusCode == ALSTATUSCODE_SYNCERROR) ||
000098  2c1a              CMP      r4,#0x1a
00009a  d005              BEQ      |L16.168|
;;;1664           (alStatusCode == ALSTATUSCODE_DCPLLSYNCERROR)
00009c  2c32              CMP      r4,#0x32
00009e  d003              BEQ      |L16.168|
;;;1665   /*ECATCHANGE_START(V5.13) ESM1*/
;;;1666           || (u8LocalErrorState > 0))
0000a0  482a              LDR      r0,|L16.332|
0000a2  7800              LDRB     r0,[r0,#0]  ; u8LocalErrorState
0000a4  2800              CMP      r0,#0
0000a6  dd03              BLE      |L16.176|
                  |L16.168|
;;;1667   /*ECATCHANGE_END(V5.13) ESM1*/
;;;1668       {
;;;1669           u8EcatErrorLed = LED_SINGLEFLASH;
0000a8  2001              MOVS     r0,#1
0000aa  4927              LDR      r1,|L16.328|
0000ac  7008              STRB     r0,[r1,#0]
0000ae  e008              B        |L16.194|
                  |L16.176|
;;;1670       }
;;;1671       else if((alStatusCode == ALSTATUSCODE_SMWATCHDOG))
0000b0  2c1b              CMP      r4,#0x1b
0000b2  d103              BNE      |L16.188|
;;;1672       {
;;;1673           u8EcatErrorLed = LED_DOUBLEFLASH;
0000b4  2002              MOVS     r0,#2
0000b6  4924              LDR      r1,|L16.328|
0000b8  7008              STRB     r0,[r1,#0]
0000ba  e002              B        |L16.194|
                  |L16.188|
;;;1674       }
;;;1675       else
;;;1676       {
;;;1677           u8EcatErrorLed = LED_BLINKING;
0000bc  200d              MOVS     r0,#0xd
0000be  4922              LDR      r1,|L16.328|
0000c0  7008              STRB     r0,[r1,#0]
                  |L16.194|
;;;1678       }
;;;1679       u8EcatErrorLed |= LED_OVERRIDE;
0000c2  4821              LDR      r0,|L16.328|
0000c4  7800              LDRB     r0,[r0,#0]  ; u8EcatErrorLed
0000c6  f0400010          ORR      r0,r0,#0x10
0000ca  491f              LDR      r1,|L16.328|
0000cc  7008              STRB     r0,[r1,#0]
;;;1680   
;;;1681       /*The Run LED registers are also written in 16 or 32 Bit access => calculate value*/
;;;1682       switch((alStatus & STATE_MASK))
0000ce  f005000f          AND      r0,r5,#0xf
0000d2  2809              CMP      r0,#9
0000d4  d21a              BCS      |L16.268|
0000d6  e8dff000          TBB      [pc,r0]
0000da  1905              DCB      0x19,0x05
0000dc  09150d19          DCB      0x09,0x15,0x0d,0x19
0000e0  19191100          DCB      0x19,0x19,0x11,0x00
;;;1683       {
;;;1684       case STATE_INIT:
;;;1685           u8EcatRunLed = LED_OFF;
0000e4  2000              MOVS     r0,#0
0000e6  491a              LDR      r1,|L16.336|
0000e8  7008              STRB     r0,[r1,#0]
;;;1686           break;
0000ea  e00f              B        |L16.268|
;;;1687       case STATE_PREOP:
;;;1688           u8EcatRunLed = LED_BLINKING;
0000ec  200d              MOVS     r0,#0xd
0000ee  4918              LDR      r1,|L16.336|
0000f0  7008              STRB     r0,[r1,#0]
;;;1689           break;
0000f2  e00b              B        |L16.268|
;;;1690       case STATE_SAFEOP:
;;;1691           u8EcatRunLed = LED_SINGLEFLASH;
0000f4  2001              MOVS     r0,#1
0000f6  4916              LDR      r1,|L16.336|
0000f8  7008              STRB     r0,[r1,#0]
;;;1692           break;
0000fa  e007              B        |L16.268|
;;;1693       case STATE_OP:
;;;1694           u8EcatRunLed = LED_ON;
0000fc  200f              MOVS     r0,#0xf
0000fe  4914              LDR      r1,|L16.336|
000100  7008              STRB     r0,[r1,#0]
;;;1695           break;
000102  e003              B        |L16.268|
;;;1696       case STATE_BOOT:
;;;1697           u8EcatRunLed = LED_FLICKERING;
000104  200e              MOVS     r0,#0xe
000106  4912              LDR      r1,|L16.336|
000108  7008              STRB     r0,[r1,#0]
;;;1698           break;
00010a  bf00              NOP      
                  |L16.268|
00010c  bf00              NOP                            ;1686
;;;1699       }
;;;1700   
;;;1701       u8EcatRunLed |= LED_OVERRIDE;
00010e  4810              LDR      r0,|L16.336|
000110  7800              LDRB     r0,[r0,#0]  ; u8EcatRunLed
000112  f0400010          ORR      r0,r0,#0x10
000116  490e              LDR      r1,|L16.336|
000118  7008              STRB     r0,[r1,#0]
;;;1702   
;;;1703   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 2418 to 2425 deleted*/
;;;1704       {
;;;1705       UINT16 TmpVar = 0;
00011a  2000              MOVS     r0,#0
00011c  9000              STR      r0,[sp,#0]
;;;1706       TmpVar = SWAPWORD((((UINT16)u8EcatRunLed) | (((UINT16)u8EcatErrorLed)<<8)));
00011e  4608              MOV      r0,r1
000120  7800              LDRB     r0,[r0,#0]  ; u8EcatRunLed
000122  4909              LDR      r1,|L16.328|
000124  7809              LDRB     r1,[r1,#0]  ; u8EcatErrorLed
000126  ea402001          ORR      r0,r0,r1,LSL #8
00012a  9000              STR      r0,[sp,#0]
;;;1707       HW_EscWriteWord(TmpVar,ESC_RUN_LED_OVERRIDE);
00012c  2202              MOVS     r2,#2
00012e  f44f719c          MOV      r1,#0x138
000132  4668              MOV      r0,sp
000134  f7fffffe          BL       HW_EscWrite
;;;1708       }
;;;1709   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS || ESC_16BIT_ACCESS #else) lines 2432 to 2434 deleted*/
;;;1710   }
000138  bd7c              POP      {r2-r6,pc}
;;;1711   
                          ENDP

00013a  0000              DCW      0x0000
                  |L16.316|
                          DCD      nAlStatus
                  |L16.320|
                          DCD      bExplicitDevIdRequested
                  |L16.324|
                          DCD      u16IdValue
                  |L16.328|
                          DCD      u8EcatErrorLed
                  |L16.332|
                          DCD      u8LocalErrorState
                  |L16.336|
                          DCD      u8EcatRunLed

                          AREA ||i.StartInputHandler||, CODE, READONLY, ALIGN=2

                  StartInputHandler PROC
;;;884    
;;;885    UINT16 StartInputHandler(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;886    {
000004  b086              SUB      sp,sp,#0x18
;;;887        TSYNCMAN ESCMEM * pSyncMan;
;;;888    
;;;889    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1312 to 1314 deleted*/
;;;890        UINT16        dcControl;
;;;891    /*ET9300 Project Handler :( #else) lines 1316 to 1318 deleted*/
;;;892    
;;;893        UINT16     wdiv = 0;
000006  2000              MOVS     r0,#0
000008  9004              STR      r0,[sp,#0x10]
;;;894        UINT16     wd = 0;
00000a  9003              STR      r0,[sp,#0xc]
;;;895        UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
00000c  9002              STR      r0,[sp,#8]
;;;896        UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle starts on the next Sync0 signal after Sync1 signal.*/
00000e  9001              STR      r0,[sp,#4]
;;;897        BOOL bSubordinatedCycles = FALSE;
000010  4680              MOV      r8,r0
;;;898    
;;;899        UINT16    nPdInputBuffer = 3;
000012  f04f0a03          MOV      r10,#3
;;;900    
;;;901        UINT16    nPdOutputBuffer = 3;
000016  f04f0903          MOV      r9,#3
;;;902    
;;;903        UINT16 SyncType0x1C32 = 0; /* Helper variable for sync type for SM2 (required if no CoE is supported or no output process data available)*/
00001a  2400              MOVS     r4,#0
;;;904        UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supported or no input process data available)*/
00001c  2500              MOVS     r5,#0
;;;905    
;;;906        UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */
00001e  f64f76ff          MOV      r6,#0xffff
;;;907    
;;;908    /*ET9300 Project Handler :(#if MAX_PD_OUTPUT_SIZE == 0 && MAX_PD_INPUT_SIZE == 0) lines 1346 to 1348 deleted*/
;;;909        u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
000022  48fe              LDR      r0,|L17.1052|
000024  8980              LDRH     r0,[r0,#0xc]  ; sSyncManOutPar
000026  4006              ANDS     r6,r6,r0
;;;910        u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
000028  48fd              LDR      r0,|L17.1056|
00002a  8980              LDRH     r0,[r0,#0xc]  ; sSyncManInPar
00002c  4006              ANDS     r6,r6,r0
;;;911    
;;;912        u16ALEventMask = 0;
00002e  2000              MOVS     r0,#0
000030  49fc              LDR      r1,|L17.1060|
000032  8008              STRH     r0,[r1,#0]
;;;913    
;;;914    
;;;915        /* 
;;;916            --- Check if SyncManager areas overlapping --- 
;;;917        */
;;;918        bEcatFirstOutputsReceived = FALSE;
000034  49fc              LDR      r1,|L17.1064|
000036  7008              STRB     r0,[r1,#0]
;;;919    
;;;920        /* get a pointer to the Sync Manager Channel 2 (Outputs) */
;;;921        pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       GetSyncMan
00003e  4607              MOV      r7,r0
;;;922        /* store the address of the Sync Manager Channel 2 (Outputs) */
;;;923    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1370 to 1372 deleted*/
;;;924        nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
000040  8838              LDRH     r0,[r7,#0]
000042  49fa              LDR      r1,|L17.1068|
000044  8008              STRH     r0,[r1,#0]
;;;925        /* get the number of output buffer used for calculating the address areas */
;;;926        if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
000046  7938              LDRB     r0,[r7,#4]
000048  f0000002          AND      r0,r0,#2
00004c  b108              CBZ      r0,|L17.82|
;;;927        {
;;;928           nPdOutputBuffer = 1;
00004e  f04f0901          MOV      r9,#1
                  |L17.82|
;;;929        }
;;;930    
;;;931    
;;;932        /* get a pointer to the Sync Manager Channel 3 (Inputs) */
;;;933        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
000052  2003              MOVS     r0,#3
000054  f7fffffe          BL       GetSyncMan
000058  4607              MOV      r7,r0
;;;934        /* store the address of the Sync Manager Channel 3 (Inputs)*/
;;;935    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1387 to 1389 deleted*/
;;;936        nEscAddrInputData = pSyncMan->PhysicalStartAddress;
00005a  8838              LDRH     r0,[r7,#0]
00005c  49f4              LDR      r1,|L17.1072|
00005e  8008              STRH     r0,[r1,#0]
;;;937    
;;;938    
;;;939        /* get the number of input buffer used for calculating the address areas */
;;;940        if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
000060  7938              LDRB     r0,[r7,#4]
000062  f0000002          AND      r0,r0,#2
000066  b108              CBZ      r0,|L17.108|
;;;941        {
;;;942            nPdInputBuffer = 1;
000068  f04f0a01          MOV      r10,#1
                  |L17.108|
;;;943        }
;;;944        /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
;;;945           the Sync Manager memory areas for the Mailbox */
;;;946    
;;;947        if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputData < (u16EscAddrSendMbx + u16SendMbxSize)))
00006c  48f0              LDR      r0,|L17.1072|
00006e  8800              LDRH     r0,[r0,#0]  ; nEscAddrInputData
000070  49f0              LDR      r1,|L17.1076|
000072  8809              LDRH     r1,[r1,#0]  ; nPdInputSize
000074  fb01000a          MLA      r0,r1,r10,r0
000078  49ef              LDR      r1,|L17.1080|
00007a  8809              LDRH     r1,[r1,#0]  ; u16EscAddrSendMbx
00007c  4288              CMP      r0,r1
00007e  dd08              BLE      |L17.146|
000080  48ed              LDR      r0,|L17.1080|
000082  8800              LDRH     r0,[r0,#0]  ; u16EscAddrSendMbx
000084  49ed              LDR      r1,|L17.1084|
000086  8809              LDRH     r1,[r1,#0]  ; u16SendMbxSize
000088  4408              ADD      r0,r0,r1
00008a  49e9              LDR      r1,|L17.1072|
00008c  8809              LDRH     r1,[r1,#0]  ; nEscAddrInputData
00008e  4288              CMP      r0,r1
000090  dc12              BGT      |L17.184|
                  |L17.146|
;;;948           || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
000092  48e7              LDR      r0,|L17.1072|
000094  8800              LDRH     r0,[r0,#0]  ; nEscAddrInputData
000096  49e7              LDR      r1,|L17.1076|
000098  8809              LDRH     r1,[r1,#0]  ; nPdInputSize
00009a  fb01000a          MLA      r0,r1,r10,r0
00009e  49e8              LDR      r1,|L17.1088|
0000a0  8809              LDRH     r1,[r1,#0]  ; u16EscAddrReceiveMbx
0000a2  4288              CMP      r0,r1
0000a4  dd10              BLE      |L17.200|
0000a6  48e6              LDR      r0,|L17.1088|
0000a8  8800              LDRH     r0,[r0,#0]  ; u16EscAddrReceiveMbx
0000aa  49e6              LDR      r1,|L17.1092|
0000ac  8809              LDRH     r1,[r1,#0]  ; u16ReceiveMbxSize
0000ae  4408              ADD      r0,r0,r1
0000b0  49df              LDR      r1,|L17.1072|
0000b2  8809              LDRH     r1,[r1,#0]  ; nEscAddrInputData
0000b4  4288              CMP      r0,r1
0000b6  dd07              BLE      |L17.200|
                  |L17.184|
;;;949            )
;;;950        {
;;;951    /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1407 to 1409 deleted*/
;;;952            /* Sync Manager Channel 3 memory area (Inputs) overlaps the Sync Manager memory areas for the Mailbox */
;;;953            SendSmFailedEmergency(PROCESS_DATA_IN, SYNCMANCHADDRESS+1);
0000b8  2102              MOVS     r1,#2
0000ba  2003              MOVS     r0,#3
0000bc  f7fffffe          BL       SendSmFailedEmergency
;;;954            return ALSTATUSCODE_INVALIDSMINCFG;
0000c0  201e              MOVS     r0,#0x1e
                  |L17.194|
;;;955        }
;;;956    
;;;957        if (
;;;958            ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
;;;959            ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAddrOutputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
;;;960            ||
;;;961            ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
;;;962            )
;;;963        {
;;;964    
;;;965            /* Sync Manager Channel 2 memory area (Outputs) overlaps the Sync Manager memory areas for the Mailbox
;;;966               or the Sync Manager Channel 3 memory area (Inputs) */
;;;967    /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1435 to 1438 deleted*/
;;;968            SendSmFailedEmergency(PROCESS_DATA_OUT, SYNCMANCHADDRESS+1);
;;;969            return ALSTATUSCODE_INVALIDSMOUTCFG;
;;;970        }
;;;971    
;;;972        /* 
;;;973            --- Check configured synchronization ---
;;;974        */
;;;975    
;;;976        /* Get the DC Control/Activation register value*/
;;;977    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1450 to 1455 deleted*/
;;;978        /*Read registers 0x980:0x981 (corresponding masks are adapted)*/
;;;979        HW_EscReadWord(dcControl, ESC_DC_UNIT_CONTROL_OFFSET);
;;;980        dcControl = SWAPWORD(dcControl);
;;;981    /*ET9300 Project Handler :( #else) lines 1459 to 1462 deleted*/
;;;982    
;;;983        // Cycle time for Sync0
;;;984            HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
;;;985            cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);
;;;986    
;;;987        // Cycle time for Sync1
;;;988            HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
;;;989            shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);
;;;990    
;;;991    
;;;992        SyncType0x1C32 = sSyncManOutPar.u16SyncType;
;;;993        SyncType0x1C33 = sSyncManInPar.u16SyncType;
;;;994    
;;;995    
;;;996    
;;;997        /* check general DC register plausibility and if configuration is supported
;;;998           - 0x981 DC Active
;;;999           - 0x9A0:0x9A3 Sync0 Cycle
;;;1000          - 0x9A4:0x9A7 Sync1 Cycle
;;;1001       */
;;;1002   /*ET9300 Project Handler :(#if !DC_SUPPORTED) lines 1492 to 1502 deleted*/
;;;1003       if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
;;;1004       {
;;;1005           /* DC unit is active at least one Sync signal shall be generated */
;;;1006           if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
;;;1007           {
;;;1008   /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1508 to 1510 deleted*/
;;;1009               return ALSTATUSCODE_DCINVALIDSYNCCFG;
;;;1010           }
;;;1011   
;;;1012           /* If Sync1 shall only be active if also Sync0 will be generated*/
;;;1013           if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
;;;1014               && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
;;;1015           {
;;;1016   /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1518 to 1520 deleted*/
;;;1017               return ALSTATUSCODE_DCINVALIDSYNCCFG;
;;;1018           }
;;;1019   
;;;1020           if(u16MinSuppSyncType != 0)
;;;1021           {
;;;1022               if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0))
;;;1023                   ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)))
;;;1024               {
;;;1025                   /* Sync0 is not supported but will be generated*/
;;;1026   /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1531 to 1533 deleted*/
;;;1027                   return ALSTATUSCODE_DCINVALIDSYNCCFG;                   
;;;1028       }
;;;1029           }
;;;1030   
;;;1031           {
;;;1032               UINT32 curMinCycleTime = MIN_PD_CYCLE_TIME;
;;;1033               curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
;;;1034   /*ET9300 Project Handler :(#elif MAX_PD_INPUT_SIZE > 0) lines 1544 to 1546 deleted*/
;;;1035   
;;;1036               /*Check if Sync0 cycle time is supported*/
;;;1037               if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
;;;1038               {
;;;1039                       return ALSTATUSCODE_DCSYNC0CYCLETIME;
;;;1040               }
;;;1041           }
;;;1042   
;;;1043   
;;;1044           /* Check if Subordinated cycles are configured */
;;;1045           if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
;;;1046           {
;;;1047               /* For Subordinated cycles both Sync signals shall be active and Sync0 is not configured in single shot (cycle time == 0)*/
;;;1048               if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
;;;1049               {
;;;1050                   bSubordinatedCycles = TRUE;
;;;1051               }
;;;1052           }
;;;1053   
;;;1054           /* Dump an error if subordinated cycles are configured but not supported */
;;;1055           if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
;;;1056           {
;;;1057   /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1571 to 1573 deleted*/
;;;1058                return ALSTATUSCODE_DCINVALIDSYNCCFG;
;;;1059           }
;;;1060       }
;;;1061   
;;;1062   
;;;1063       /*
;;;1064           Check if the user configured Sync Type matches the DC register values (if the Sync Type is supported was already checked in the object write function)
;;;1065       */
;;;1066       if(bSyncSetByUser)
;;;1067       {
;;;1068           if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
;;;1069           {
;;;1070               /* DC out unit not enabled => no DC mode shall be set */
;;;1071               if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
;;;1072                   ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
;;;1073               {
;;;1074   /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1594 to 1596 deleted*/
;;;1075                   return ALSTATUSCODE_DCINVALIDSYNCCFG;
;;;1076               }
;;;1077           } //if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
;;;1078       else
;;;1079       {
;;;1080               if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
;;;1081               {
;;;1082                   /* No Sync 1 is generated => No Sync1 Sync Type shall configured*/
;;;1083                   if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
;;;1084                       ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
;;;1085                   {
;;;1086   /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1611 to 1613 deleted*/
;;;1087                       return ALSTATUSCODE_DCINVALIDSYNCCFG;
;;;1088                   }
;;;1089               } //if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
;;;1090   
;;;1091               if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
;;;1092               {
;;;1093                   /* No Sync 0 is generated => No Sync0 Sync Type shall configured*/
;;;1094                   if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC0)
;;;1095                       ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC0))
;;;1096                   {
;;;1097   /*ET9300 Project Handler :(#if DIAGNOSIS_SUPPORTED) lines 1624 to 1626 deleted*/
;;;1098                       return ALSTATUSCODE_DCINVALIDSYNCCFG;
;;;1099                   }
;;;1100               } //if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
;;;1101   
;;;1102   /*ET9300 Project Handler :(#if !AL_EVENT_ENABLED) lines 1632 to 1654 deleted*/
;;;1103           }
;;;1104       } //if(bSyncSetByUser)
;;;1105       else
;;;1106       {
;;;1107           /* No Sync Type selected by user => Configure Sync Type based on DC register values*/
;;;1108           if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
;;;1109           {
;;;1110               /* Activation or auto activation of the Sync Out Unit is disabled => Free Run or SM Sync is configured*/
;;;1111   
;;;1112               /* AL Event enabled => Configure SM Sync*/
;;;1113               if (nPdOutputSize > 0)
;;;1114               {
;;;1115                   SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
;;;1116                   
;;;1117                   if (nPdInputSize > 0)
;;;1118                   {
;;;1119                       SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
;;;1120                   }
;;;1121                   else
;;;1122                   {
;;;1123                       SyncType0x1C33 = SYNCTYPE_FREERUN;
;;;1124                   }
;;;1125               }
;;;1126               else if (nPdInputSize > 0)
;;;1127               {
;;;1128                   SyncType0x1C32 = SYNCTYPE_FREERUN;
;;;1129                   SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
;;;1130               }
;;;1131               else
;;;1132               {
;;;1133                   SyncType0x1C32 = SYNCTYPE_FREERUN;
;;;1134                   SyncType0x1C33 = SYNCTYPE_FREERUN;
;;;1135               }
;;;1136   /*ET9300 Project Handler :(#if AL_EVENT_ENABLED #else) lines 1691 to 1696 deleted*/
;;;1137   
;;;1138           }
;;;1139           else
;;;1140           {
;;;1141               if (nPdOutputSize > 0)
;;;1142               {
;;;1143                   /* Sync Signal generation is active*/
;;;1144                   if (bSubordinatedCycles)
;;;1145                   {
;;;1146                       SyncType0x1C32 = SYNCTYPE_DCSYNC1;
;;;1147                   }
;;;1148                   else
;;;1149                   {
;;;1150                       SyncType0x1C32 = SYNCTYPE_DCSYNC0;
;;;1151                   }
;;;1152               }
;;;1153               else
;;;1154               {
;;;1155                   SyncType0x1C32 = SYNCTYPE_FREERUN;
;;;1156               }
;;;1157   
;;;1158   
;;;1159               if (nPdInputSize > 0)
;;;1160               {
;;;1161                   if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
;;;1162                   {
;;;1163                       /* If Sync1 is available the inputs will always be mapped with Sync1 */
;;;1164                       SyncType0x1C33 = SYNCTYPE_DCSYNC1;
;;;1165                   }
;;;1166                   else
;;;1167                   {
;;;1168                       /* Map Inputs based on Sync0*/
;;;1169                       SyncType0x1C33 = SYNCTYPE_DCSYNC0;
;;;1170                   }
;;;1171               }
;;;1172               else
;;;1173               {
;;;1174                   SyncType0x1C33 = SYNCTYPE_FREERUN;
;;;1175               }
;;;1176           }
;;;1177       }
;;;1178   
;;;1179       /* Update Cycle time entries if DC Sync Mode enabled */
;;;1180       if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
;;;1181       {
;;;1182           sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
;;;1183           sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
;;;1184   
;;;1185           sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
;;;1186           sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
;;;1187       }
;;;1188       else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
;;;1189       {
;;;1190           sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
;;;1191           sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
;;;1192   
;;;1193           sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
;;;1194           sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
;;;1195       }
;;;1196   
;;;1197       /* Set global flags based on Sync Type */
;;;1198       if ( !b3BufferMode )
;;;1199       {
;;;1200           /* 1-Buffer-Mode configured => For free run it shall be 3Buffer mode*/
;;;1201           if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
;;;1202           {
;;;1203                   return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
;;;1204           }
;;;1205       }
;;;1206   
;;;1207       /* If no free run is supported the EscInt is always enabled*/
;;;1208           if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
;;;1209           {
;;;1210           /* ECAT Synchron Mode, the ESC interrupt is enabled */
;;;1211           bEscIntEnabled = TRUE;
;;;1212       }
;;;1213   
;;;1214           /* Update value for AL Event Mask register (0x204) */
;;;1215           if(bEscIntEnabled)
;;;1216           {
;;;1217               if(nPdOutputSize > 0)
;;;1218               {
;;;1219                   u16ALEventMask = PROCESS_OUTPUT_EVENT;
;;;1220               }
;;;1221               else if(nPdInputSize > 0)
;;;1222               {
;;;1223                   u16ALEventMask = PROCESS_INPUT_EVENT;
;;;1224               }
;;;1225   
;;;1226   /*ET9300 Project Handler :(#elif MAX_PD_INPUT_SIZE > 0) lines 1803 to 1808 deleted*/
;;;1227           }
;;;1228   
;;;1229           if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
;;;1230               || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync to Sync0 or Sync1 is enabled*/
;;;1231           {
;;;1232               /* slave is running in DC-mode */
;;;1233               bDcSyncActive = TRUE;
;;;1234   
;;;1235               /*In case of an Input only application with DC no PDI Isr handling is required*/
;;;1236               if (nPdOutputSize == 0)
;;;1237               {
;;;1238                  u16ALEventMask = 0;
;;;1239               }
;;;1240           }
;;;1241   
;;;1242   
;;;1243   
;;;1244       sSyncManOutPar.u16SyncType = SyncType0x1C32;
;;;1245       sSyncManInPar.u16SyncType = SyncType0x1C33;
;;;1246   
;;;1247       /* Calculate number of Sync0 events within one SM cycle and the Sync0 events on which the inputs has to be latched*/
;;;1248       LatchInputSync0Value = 0;
;;;1249       LatchInputSync0Counter = 0;
;;;1250       u16SmSync0Value = 0;
;;;1251       u16SmSync0Counter = 0;
;;;1252   
;;;1253   
;;;1254       if(bSubordinatedCycles == TRUE)
;;;1255       {
;;;1256           
;;;1257           UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
;;;1258   
;;;1259   
;;;1260           /* get the number of Sync0 event within on SM cycle */
;;;1261           if(shiftTimeSync1 >= cycleTimeSync0)
;;;1262           {
;;;1263   
;;;1264               u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
;;;1265               
;;;1266               if((cycleTimeSync1 % cycleTimeSync0) == 0)
;;;1267               {
;;;1268                   /* if the Sync1cycletime/Sync0cycletime ratio is even one additional tick */
;;;1269                   u16SmSync0Value ++;
;;;1270               }
;;;1271           }
;;;1272           else
;;;1273           {
;;;1274               u16SmSync0Value = 1;
;;;1275           }
;;;1276   
;;;1277           /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the next Sync1 event)*/
;;;1278           LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);
;;;1279   
;;;1280           if ((cycleTimeSync1 % cycleTimeSync0) > 0)
;;;1281           {
;;;1282               LatchInputSync0Value++;
;;;1283           }
;;;1284   
;;;1285       }
;;;1286       else 
;;;1287       {
;;;1288           if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
;;;1289           {
;;;1290               /* if SyncType of 0x1C32 is 2 the Sync0 event is trigger once during a SM cycle */
;;;1291               u16SmSync0Value = 1;
;;;1292           }   
;;;1293   
;;;1294           if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
;;;1295           {
;;;1296               LatchInputSync0Value = 1;
;;;1297           }
;;;1298       }
;;;1299   
;;;1300   
;;;1301   
;;;1302       /* reset the error counter indicating synchronization problems */
;;;1303       sCycleDiag.syncFailedCounter = 0;
;;;1304   
;;;1305   
;;;1306       /*
;;;1307           --- Check watchdog settings ---
;;;1308       */
;;;1309   
;;;1310       /*get the watchdog time (register 0x420). if value is > 0 watchdog is active*/
;;;1311   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1909 to 1916 deleted*/
;;;1312       HW_EscReadWord(wd, ESC_PD_WD_TIME);
;;;1313       wd = SWAPWORD(wd);
;;;1314   
;;;1315       if (nPdOutputSize > 0 &&  wd != 0 )
;;;1316       {
;;;1317       /*get watchdog divider (register 0x400)*/
;;;1318   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 1924 to 1932 deleted*/
;;;1319       HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
;;;1320       wdiv = SWAPWORD(wdiv);
;;;1321           if ( wdiv != 0 )
;;;1322           {
;;;1323               /* the ESC subtracts 2 in register 0x400 so it has to be added here */
;;;1324               UINT32 d = wdiv+2;
;;;1325   
;;;1326   
;;;1327               d *= wd;
;;;1328               /* store watchdog in ms in variable EcatWdValue */
;;;1329               /* watchdog value has to be rounded up */
;;;1330               d = (INT32)(d + 24999);
;;;1331               d /= 25000;
;;;1332               EcatWdValue = (UINT16) d;
;;;1333           }
;;;1334           else
;;;1335           {
;;;1336               wd = 0;
;;;1337               /* wd value has to be set to zero, if the wd is 0 */
;;;1338               EcatWdValue = 0;
;;;1339           }
;;;1340   /*ET9300 Project Handler :(#if !ESC_SM_WD_SUPPORTED) lines 1955 to 1958 deleted*/
;;;1341       }
;;;1342       else
;;;1343       {
;;;1344           /* the watchdog is deactivated or slave has no output process data*/
;;;1345           wdiv = 0;
;;;1346           EcatWdValue = 0;
;;;1347       }
;;;1348   
;;;1349       if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
;;;1350       {
;;;1351           /* if the WD-Trigger in the Sync Manager Channel 2 Control-Byte is set (Bit 6 of Register 0x814)
;;;1352               an error has to be returned */
;;;1353           return ALSTATUSCODE_INVALIDWDCFG;
;;;1354       }
;;;1355   
;;;1356       if ( bEscIntEnabled && nPdOutputSize != 0 )
;;;1357       {
;;;1358           /* ECAT synchron Mode is active, the Sync Manager Channel 2 event
;;;1359              has to activated in the AL-Event mask register */
;;;1360           u16ALEventMask |= PROCESS_OUTPUT_EVENT;
;;;1361       }
;;;1362   /*The application ESM function is separated from this function to handle pending transitions*/
;;;1363   
;;;1364       Sync0WdValue = 0;
;;;1365       Sync0WdCounter = 0;
;;;1366       Sync1WdCounter = 0;
;;;1367       Sync1WdValue = 0;
;;;1368       bDcRunning = FALSE;
;;;1369       bSmSyncSequenceValid = FALSE;
;;;1370       i16WaitForPllRunningTimeout = 0;
;;;1371   
;;;1372   /*ECATCHANGE_START(V5.13) ECAT1*/
;;;1373       /*Get Sync mapped to AL Event indication*/
;;;1374       {
;;;1375           UINT32 u32TmpVar = 0;
;;;1376           HW_EscReadDWord(u32TmpVar, ESC_PDI_CONFIGURATION);
;;;1377           if ((u32TmpVar & ESC_SYNC0_MAPPED_TO_ALEVENT) > 0)
;;;1378           {
;;;1379               u16ALEventMask |= SYNC0_EVENT;
;;;1380           }
;;;1381   
;;;1382           if ((u32TmpVar & ESC_SYNC1_MAPPED_TO_ALEVENT) > 0)
;;;1383           {
;;;1384               u16ALEventMask |= SYNC1_EVENT;
;;;1385           }
;;;1386   /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS || ESC_16BIT_ACCESS #else) lines 2009 to 2021 deleted*/
;;;1387       }
;;;1388   /*ECATCHANGE_END(V5.13) ECAT1*/
;;;1389       sSyncManInPar.u16SmEventMissedCounter = 0;
;;;1390       sSyncManInPar.u16CycleExceededCounter = 0;
;;;1391       sSyncManInPar.u8SyncError = 0;
;;;1392   
;;;1393   
;;;1394       sSyncManOutPar.u16SmEventMissedCounter = 0;
;;;1395       sSyncManOutPar.u16CycleExceededCounter = 0;
;;;1396       sSyncManOutPar.u8SyncError = 0;
;;;1397   /*ET9300 Project Handler :(#if COE_SUPPORTED #else) lines 2037 to 2039 deleted*/
;;;1398   
;;;1399       /* calculate the Sync0/Sync1 watchdog timeouts */
;;;1400       if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
;;;1401       {
;;;1402           /*calculate the Sync0 Watchdog counter value the minimum value is 1 ms
;;;1403               if the sync0 cycle is greater 500us the Sync0 Wd value is 2*Sycn0 cycle */
;;;1404           if(cycleTimeSync0 == 0)
;;;1405           {
;;;1406               Sync0WdValue = 0;
;;;1407           }
;;;1408           else
;;;1409           {
;;;1410               UINT32 Sync0Cycle = cycleTimeSync0/100000;
;;;1411   
;;;1412               if(Sync0Cycle < 5)
;;;1413               {
;;;1414                   /*Sync0 cycle less than 500us*/
;;;1415                   Sync0WdValue = 1;
;;;1416               }
;;;1417               else
;;;1418               {
;;;1419                   Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
;;;1420               }
;;;1421           }
;;;1422   
;;;1423           /* Calculate also the watchdog time for Sync1*/
;;;1424           if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
;;;1425           {
;;;1426               if(shiftTimeSync1 < cycleTimeSync0)
;;;1427           {
;;;1428                   /* Sync 1 has the same cycle time than Sync0 (maybe with a shift (shiftTimeSync1 > 0))*/
;;;1429                   Sync1WdValue = Sync0WdValue;
;;;1430           }
;;;1431           else
;;;1432           {
;;;1433                   /* Sync1 cycle is larger than Sync0 (e.g. subordinated Sync0 cycles) */
;;;1434                   UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
;;;1435                   if(Sync1Cycle < 5)
;;;1436                   {
;;;1437                       /*Sync0 cycle less than 500us*/
;;;1438                       Sync1WdValue = 1;
;;;1439                   }
;;;1440                   else
;;;1441                   {
;;;1442                       Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
;;;1443                   }
;;;1444   
;;;1445                   /* add one Sync0 cycle because the Sync1 cycle starts on the next Sync0 after the Sync1 signal */
;;;1446                   Sync1WdValue += Sync0WdValue/2;
;;;1447               }
;;;1448       }
;;;1449       }
;;;1450   
;;;1451       if(nPdOutputSize > 0)
;;;1452       {
;;;1453           EnableSyncManChannel(PROCESS_DATA_OUT);
;;;1454       }
;;;1455   
;;;1456       if(nPdInputSize > 0)
;;;1457       {
;;;1458           EnableSyncManChannel(PROCESS_DATA_IN);
;;;1459       }
;;;1460   
;;;1461   /*ET9300 Project Handler :(#if TEST_APPLICATION && COE_SUPPORTED) lines 2109 to 2119 deleted*/
;;;1462       /*write initial input data*/
;;;1463       PDO_InputMapping();
;;;1464   
;;;1465       return ALSTATUSCODE_NOERROR;
;;;1466   }
0000c2  b006              ADD      sp,sp,#0x18
0000c4  e8bd87f0          POP      {r4-r10,pc}
                  |L17.200|
0000c8  48d8              LDR      r0,|L17.1068|
0000ca  8800              LDRH     r0,[r0,#0]            ;957  ; nEscAddrOutputData
0000cc  49de              LDR      r1,|L17.1096|
0000ce  8809              LDRH     r1,[r1,#0]            ;957  ; nPdOutputSize
0000d0  fb010009          MLA      r0,r1,r9,r0           ;957
0000d4  49d8              LDR      r1,|L17.1080|
0000d6  8809              LDRH     r1,[r1,#0]            ;957  ; u16EscAddrSendMbx
0000d8  4288              CMP      r0,r1                 ;957
0000da  dd08              BLE      |L17.238|
0000dc  48d6              LDR      r0,|L17.1080|
0000de  8800              LDRH     r0,[r0,#0]            ;958  ; u16EscAddrSendMbx
0000e0  49d6              LDR      r1,|L17.1084|
0000e2  8809              LDRH     r1,[r1,#0]            ;958  ; u16SendMbxSize
0000e4  4408              ADD      r0,r0,r1              ;958
0000e6  49d1              LDR      r1,|L17.1068|
0000e8  8809              LDRH     r1,[r1,#0]            ;958  ; nEscAddrOutputData
0000ea  4288              CMP      r0,r1                 ;958
0000ec  dc25              BGT      |L17.314|
                  |L17.238|
0000ee  48cf              LDR      r0,|L17.1068|
0000f0  8800              LDRH     r0,[r0,#0]            ;959  ; nEscAddrOutputData
0000f2  49d5              LDR      r1,|L17.1096|
0000f4  8809              LDRH     r1,[r1,#0]            ;959  ; nPdOutputSize
0000f6  fb010009          MLA      r0,r1,r9,r0           ;959
0000fa  49d1              LDR      r1,|L17.1088|
0000fc  8809              LDRH     r1,[r1,#0]            ;959  ; u16EscAddrReceiveMbx
0000fe  4288              CMP      r0,r1                 ;959
000100  dd08              BLE      |L17.276|
000102  48cf              LDR      r0,|L17.1088|
000104  8800              LDRH     r0,[r0,#0]            ;959  ; u16EscAddrReceiveMbx
000106  49cf              LDR      r1,|L17.1092|
000108  8809              LDRH     r1,[r1,#0]            ;959  ; u16ReceiveMbxSize
00010a  4408              ADD      r0,r0,r1              ;959
00010c  49c7              LDR      r1,|L17.1068|
00010e  8809              LDRH     r1,[r1,#0]            ;959  ; nEscAddrOutputData
000110  4288              CMP      r0,r1                 ;959
000112  dc12              BGT      |L17.314|
                  |L17.276|
000114  48c5              LDR      r0,|L17.1068|
000116  8800              LDRH     r0,[r0,#0]            ;961  ; nEscAddrOutputData
000118  49cb              LDR      r1,|L17.1096|
00011a  8809              LDRH     r1,[r1,#0]            ;961  ; nPdOutputSize
00011c  fb010009          MLA      r0,r1,r9,r0           ;961
000120  49c3              LDR      r1,|L17.1072|
000122  8809              LDRH     r1,[r1,#0]            ;961  ; nEscAddrInputData
000124  4288              CMP      r0,r1                 ;961
000126  dd0e              BLE      |L17.326|
000128  48c1              LDR      r0,|L17.1072|
00012a  8800              LDRH     r0,[r0,#0]            ;961  ; nEscAddrInputData
00012c  49c1              LDR      r1,|L17.1076|
00012e  8809              LDRH     r1,[r1,#0]            ;961  ; nPdInputSize
000130  4408              ADD      r0,r0,r1              ;961
000132  49be              LDR      r1,|L17.1068|
000134  8809              LDRH     r1,[r1,#0]            ;961  ; nEscAddrOutputData
000136  4288              CMP      r0,r1                 ;961
000138  dd05              BLE      |L17.326|
                  |L17.314|
00013a  2102              MOVS     r1,#2                 ;968
00013c  4608              MOV      r0,r1                 ;968
00013e  f7fffffe          BL       SendSmFailedEmergency
000142  201d              MOVS     r0,#0x1d              ;969
000144  e7bd              B        |L17.194|
                  |L17.326|
000146  2202              MOVS     r2,#2                 ;979
000148  f44f6118          MOV      r1,#0x980             ;979
00014c  a805              ADD      r0,sp,#0x14           ;979
00014e  f7fffffe          BL       HW_EscRead
000152  f8bd0014          LDRH     r0,[sp,#0x14]         ;980
000156  9005              STR      r0,[sp,#0x14]         ;980
000158  2204              MOVS     r2,#4                 ;984
00015a  f44f611a          MOV      r1,#0x9a0             ;984
00015e  a802              ADD      r0,sp,#8              ;984
000160  f7fffffe          BL       HW_EscRead
000164  9802              LDR      r0,[sp,#8]            ;985
000166  9002              STR      r0,[sp,#8]            ;985
000168  2204              MOVS     r2,#4                 ;988
00016a  f64011a4          MOV      r1,#0x9a4             ;988
00016e  a801              ADD      r0,sp,#4              ;988
000170  f7fffffe          BL       HW_EscRead
000174  9801              LDR      r0,[sp,#4]            ;989
000176  9001              STR      r0,[sp,#4]            ;989
000178  48a8              LDR      r0,|L17.1052|
00017a  8844              LDRH     r4,[r0,#2]            ;992  ; sSyncManOutPar
00017c  48a8              LDR      r0,|L17.1056|
00017e  8845              LDRH     r5,[r0,#2]            ;993  ; sSyncManInPar
000180  f8bd0014          LDRH     r0,[sp,#0x14]         ;1003
000184  f4006010          AND      r0,r0,#0x900          ;1003
000188  2800              CMP      r0,#0                 ;1003
00018a  d04d              BEQ      |L17.552|
00018c  f8bd0014          LDRH     r0,[sp,#0x14]         ;1006
000190  f40060c0          AND      r0,r0,#0x600          ;1006
000194  b908              CBNZ     r0,|L17.410|
000196  2030              MOVS     r0,#0x30              ;1009
000198  e793              B        |L17.194|
                  |L17.410|
00019a  f8bd0014          LDRH     r0,[sp,#0x14]         ;1013
00019e  f4007000          AND      r0,r0,#0x200          ;1013
0001a2  b930              CBNZ     r0,|L17.434|
0001a4  f8bd0014          LDRH     r0,[sp,#0x14]         ;1014
0001a8  f4006080          AND      r0,r0,#0x400          ;1014
0001ac  b108              CBZ      r0,|L17.434|
0001ae  2030              MOVS     r0,#0x30              ;1017
0001b0  e787              B        |L17.194|
                  |L17.434|
0001b2  b18e              CBZ      r6,|L17.472|
0001b4  f0060004          AND      r0,r6,#4              ;1022
0001b8  b920              CBNZ     r0,|L17.452|
0001ba  f8bd0014          LDRH     r0,[sp,#0x14]         ;1022
0001be  f4007000          AND      r0,r0,#0x200          ;1022
0001c2  b938              CBNZ     r0,|L17.468|
                  |L17.452|
0001c4  f0060008          AND      r0,r6,#8              ;1023
0001c8  b930              CBNZ     r0,|L17.472|
0001ca  f8bd0014          LDRH     r0,[sp,#0x14]         ;1023
0001ce  f4006080          AND      r0,r0,#0x400          ;1023
0001d2  b108              CBZ      r0,|L17.472|
                  |L17.468|
0001d4  2030              MOVS     r0,#0x30              ;1027
0001d6  e774              B        |L17.194|
                  |L17.472|
0001d8  2100              MOVS     r1,#0                 ;1032
0001da  4890              LDR      r0,|L17.1052|
0001dc  6901              LDR      r1,[r0,#0x10]         ;1033  ; sSyncManOutPar
0001de  9802              LDR      r0,[sp,#8]            ;1037
0001e0  b140              CBZ      r0,|L17.500|
0001e2  9802              LDR      r0,[sp,#8]            ;1037
0001e4  4288              CMP      r0,r1                 ;1037
0001e6  d303              BCC      |L17.496|
0001e8  4a98              LDR      r2,|L17.1100|
0001ea  9802              LDR      r0,[sp,#8]            ;1037
0001ec  4290              CMP      r0,r2                 ;1037
0001ee  d901              BLS      |L17.500|
                  |L17.496|
0001f0  2036              MOVS     r0,#0x36              ;1039
0001f2  e766              B        |L17.194|
                  |L17.500|
0001f4  f8bd0014          LDRH     r0,[sp,#0x14]         ;1045
0001f8  f4007000          AND      r0,r0,#0x200          ;1045
0001fc  b160              CBZ      r0,|L17.536|
0001fe  f8bd0014          LDRH     r0,[sp,#0x14]         ;1045
000202  f4006080          AND      r0,r0,#0x400          ;1045
000206  b138              CBZ      r0,|L17.536|
000208  9801              LDR      r0,[sp,#4]            ;1048
00020a  b128              CBZ      r0,|L17.536|
00020c  e9dd0101          LDRD     r0,r1,[sp,#4]         ;1048
000210  4288              CMP      r0,r1                 ;1048
000212  d301              BCC      |L17.536|
000214  f04f0801          MOV      r8,#1                 ;1050
                  |L17.536|
000218  f1b80f00          CMP      r8,#0                 ;1055
00021c  d004              BEQ      |L17.552|
00021e  f0060010          AND      r0,r6,#0x10           ;1055
000222  b908              CBNZ     r0,|L17.552|
000224  2030              MOVS     r0,#0x30              ;1058
000226  e74c              B        |L17.194|
                  |L17.552|
000228  4889              LDR      r0,|L17.1104|
00022a  7800              LDRB     r0,[r0,#0]            ;1066  ; bSyncSetByUser
00022c  b320              CBZ      r0,|L17.632|
00022e  f8bd0014          LDRH     r0,[sp,#0x14]         ;1068
000232  f4006010          AND      r0,r0,#0x900          ;1068
000236  b948              CBNZ     r0,|L17.588|
000238  2c02              CMP      r4,#2                 ;1071
00023a  d005              BEQ      |L17.584|
00023c  2c03              CMP      r4,#3                 ;1071
00023e  d003              BEQ      |L17.584|
000240  2d02              CMP      r5,#2                 ;1072
000242  d001              BEQ      |L17.584|
000244  2d03              CMP      r5,#3                 ;1072
000246  d14d              BNE      |L17.740|
                  |L17.584|
000248  2030              MOVS     r0,#0x30              ;1075
00024a  e73a              B        |L17.194|
                  |L17.588|
00024c  f8bd0014          LDRH     r0,[sp,#0x14]         ;1080
000250  f4006080          AND      r0,r0,#0x400          ;1080
000254  b928              CBNZ     r0,|L17.610|
000256  2c03              CMP      r4,#3                 ;1083
000258  d001              BEQ      |L17.606|
00025a  2d03              CMP      r5,#3                 ;1084
00025c  d101              BNE      |L17.610|
                  |L17.606|
00025e  2030              MOVS     r0,#0x30              ;1087
000260  e72f              B        |L17.194|
                  |L17.610|
000262  f8bd0014          LDRH     r0,[sp,#0x14]         ;1091
000266  f4007000          AND      r0,r0,#0x200          ;1091
00026a  bb00              CBNZ     r0,|L17.686|
00026c  2c02              CMP      r4,#2                 ;1094
00026e  d001              BEQ      |L17.628|
000270  2d02              CMP      r5,#2                 ;1095
000272  d137              BNE      |L17.740|
                  |L17.628|
000274  2030              MOVS     r0,#0x30              ;1098
000276  e724              B        |L17.194|
                  |L17.632|
000278  f8bd0014          LDRH     r0,[sp,#0x14]         ;1108
00027c  f4006010          AND      r0,r0,#0x900          ;1108
000280  b9b0              CBNZ     r0,|L17.688|
000282  4871              LDR      r0,|L17.1096|
000284  8800              LDRH     r0,[r0,#0]            ;1113  ; nPdOutputSize
000286  2800              CMP      r0,#0                 ;1113
000288  dd08              BLE      |L17.668|
00028a  2401              MOVS     r4,#1                 ;1115
00028c  4869              LDR      r0,|L17.1076|
00028e  8800              LDRH     r0,[r0,#0]            ;1117  ; nPdInputSize
000290  2800              CMP      r0,#0                 ;1117
000292  dd01              BLE      |L17.664|
000294  2522              MOVS     r5,#0x22              ;1119
000296  e025              B        |L17.740|
                  |L17.664|
000298  2500              MOVS     r5,#0                 ;1123
00029a  e023              B        |L17.740|
                  |L17.668|
00029c  4865              LDR      r0,|L17.1076|
00029e  8800              LDRH     r0,[r0,#0]            ;1126  ; nPdInputSize
0002a0  2800              CMP      r0,#0                 ;1126
0002a2  dd02              BLE      |L17.682|
0002a4  2400              MOVS     r4,#0                 ;1128
0002a6  2501              MOVS     r5,#1                 ;1129
0002a8  e01c              B        |L17.740|
                  |L17.682|
0002aa  2400              MOVS     r4,#0                 ;1133
0002ac  2500              MOVS     r5,#0                 ;1134
                  |L17.686|
0002ae  e019              B        |L17.740|
                  |L17.688|
0002b0  4865              LDR      r0,|L17.1096|
0002b2  8800              LDRH     r0,[r0,#0]            ;1141  ; nPdOutputSize
0002b4  2800              CMP      r0,#0                 ;1141
0002b6  dd06              BLE      |L17.710|
0002b8  f1b80f00          CMP      r8,#0                 ;1144
0002bc  d001              BEQ      |L17.706|
0002be  2403              MOVS     r4,#3                 ;1146
0002c0  e002              B        |L17.712|
                  |L17.706|
0002c2  2402              MOVS     r4,#2                 ;1150
0002c4  e000              B        |L17.712|
                  |L17.710|
0002c6  2400              MOVS     r4,#0                 ;1155
                  |L17.712|
0002c8  485a              LDR      r0,|L17.1076|
0002ca  8800              LDRH     r0,[r0,#0]            ;1159  ; nPdInputSize
0002cc  2800              CMP      r0,#0                 ;1159
0002ce  dd08              BLE      |L17.738|
0002d0  f8bd0014          LDRH     r0,[sp,#0x14]         ;1161
0002d4  f4006080          AND      r0,r0,#0x400          ;1161
0002d8  b108              CBZ      r0,|L17.734|
0002da  2503              MOVS     r5,#3                 ;1164
0002dc  e002              B        |L17.740|
                  |L17.734|
0002de  2502              MOVS     r5,#2                 ;1169
0002e0  e000              B        |L17.740|
                  |L17.738|
0002e2  2500              MOVS     r5,#0                 ;1174
                  |L17.740|
0002e4  2c03              CMP      r4,#3                 ;1180
0002e6  d10a              BNE      |L17.766|
0002e8  494c              LDR      r1,|L17.1052|
0002ea  9802              LDR      r0,[sp,#8]            ;1182
0002ec  6248              STR      r0,[r1,#0x24]         ;1182  ; sSyncManOutPar
0002ee  9802              LDR      r0,[sp,#8]            ;1183
0002f0  6048              STR      r0,[r1,#4]            ;1183  ; sSyncManOutPar
0002f2  494b              LDR      r1,|L17.1056|
0002f4  9802              LDR      r0,[sp,#8]            ;1185
0002f6  6248              STR      r0,[r1,#0x24]         ;1185  ; sSyncManInPar
0002f8  9802              LDR      r0,[sp,#8]            ;1186
0002fa  6048              STR      r0,[r1,#4]            ;1186  ; sSyncManInPar
0002fc  e00b              B        |L17.790|
                  |L17.766|
0002fe  2c02              CMP      r4,#2                 ;1188
000300  d109              BNE      |L17.790|
000302  4946              LDR      r1,|L17.1052|
000304  9802              LDR      r0,[sp,#8]            ;1190
000306  6248              STR      r0,[r1,#0x24]         ;1190  ; sSyncManOutPar
000308  9802              LDR      r0,[sp,#8]            ;1191
00030a  6048              STR      r0,[r1,#4]            ;1191  ; sSyncManOutPar
00030c  4944              LDR      r1,|L17.1056|
00030e  9802              LDR      r0,[sp,#8]            ;1193
000310  6248              STR      r0,[r1,#0x24]         ;1193  ; sSyncManInPar
000312  9802              LDR      r0,[sp,#8]            ;1194
000314  6048              STR      r0,[r1,#4]            ;1194  ; sSyncManInPar
                  |L17.790|
000316  484f              LDR      r0,|L17.1108|
000318  7800              LDRB     r0,[r0,#0]            ;1198  ; b3BufferMode
00031a  b918              CBNZ     r0,|L17.804|
00031c  b104              CBZ      r4,|L17.800|
00031e  b90d              CBNZ     r5,|L17.804|
                  |L17.800|
000320  2029              MOVS     r0,#0x29              ;1203
000322  e6ce              B        |L17.194|
                  |L17.804|
000324  b904              CBNZ     r4,|L17.808|
000326  b115              CBZ      r5,|L17.814|
                  |L17.808|
000328  2001              MOVS     r0,#1                 ;1211
00032a  494b              LDR      r1,|L17.1112|
00032c  7008              STRB     r0,[r1,#0]            ;1211
                  |L17.814|
00032e  484a              LDR      r0,|L17.1112|
000330  7800              LDRB     r0,[r0,#0]            ;1215  ; bEscIntEnabled
000332  b180              CBZ      r0,|L17.854|
000334  4844              LDR      r0,|L17.1096|
000336  8800              LDRH     r0,[r0,#0]            ;1217  ; nPdOutputSize
000338  2800              CMP      r0,#0                 ;1217
00033a  dd04              BLE      |L17.838|
00033c  f44f6080          MOV      r0,#0x400             ;1219
000340  4938              LDR      r1,|L17.1060|
000342  8008              STRH     r0,[r1,#0]            ;1219
000344  e007              B        |L17.854|
                  |L17.838|
000346  483b              LDR      r0,|L17.1076|
000348  8800              LDRH     r0,[r0,#0]            ;1221  ; nPdInputSize
00034a  2800              CMP      r0,#0                 ;1221
00034c  dd03              BLE      |L17.854|
00034e  f44f6000          MOV      r0,#0x800             ;1223
000352  4934              LDR      r1,|L17.1060|
000354  8008              STRH     r0,[r1,#0]            ;1223
                  |L17.854|
000356  2c02              CMP      r4,#2                 ;1229
000358  d005              BEQ      |L17.870|
00035a  2c03              CMP      r4,#3                 ;1229
00035c  d003              BEQ      |L17.870|
00035e  2d02              CMP      r5,#2                 ;1230
000360  d001              BEQ      |L17.870|
000362  2d03              CMP      r5,#3                 ;1230
000364  d108              BNE      |L17.888|
                  |L17.870|
000366  2001              MOVS     r0,#1                 ;1233
000368  493c              LDR      r1,|L17.1116|
00036a  7008              STRB     r0,[r1,#0]            ;1233
00036c  4836              LDR      r0,|L17.1096|
00036e  8800              LDRH     r0,[r0,#0]            ;1236  ; nPdOutputSize
000370  b910              CBNZ     r0,|L17.888|
000372  2000              MOVS     r0,#0                 ;1238
000374  492b              LDR      r1,|L17.1060|
000376  8008              STRH     r0,[r1,#0]            ;1238
                  |L17.888|
000378  4828              LDR      r0,|L17.1052|
00037a  8044              STRH     r4,[r0,#2]            ;1244
00037c  4828              LDR      r0,|L17.1056|
00037e  8045              STRH     r5,[r0,#2]            ;1245
000380  2000              MOVS     r0,#0                 ;1248
000382  4937              LDR      r1,|L17.1120|
000384  8008              STRH     r0,[r1,#0]            ;1248
000386  4937              LDR      r1,|L17.1124|
000388  8008              STRH     r0,[r1,#0]            ;1249
00038a  4937              LDR      r1,|L17.1128|
00038c  8008              STRH     r0,[r1,#0]            ;1250
00038e  4937              LDR      r1,|L17.1132|
000390  8008              STRH     r0,[r1,#0]            ;1251
000392  f1b80f01          CMP      r8,#1                 ;1254
000396  d12b              BNE      |L17.1008|
000398  e9dd1201          LDRD     r1,r2,[sp,#4]         ;1257
00039c  1888              ADDS     r0,r1,r2              ;1257
00039e  e9dd1201          LDRD     r1,r2,[sp,#4]         ;1261
0003a2  4291              CMP      r1,r2                 ;1261
0003a4  d310              BCC      |L17.968|
0003a6  9902              LDR      r1,[sp,#8]            ;1264
0003a8  fbb0f1f1          UDIV     r1,r0,r1              ;1264
0003ac  4a2e              LDR      r2,|L17.1128|
0003ae  8011              STRH     r1,[r2,#0]            ;1264
0003b0  9902              LDR      r1,[sp,#8]            ;1266
0003b2  fbb0f2f1          UDIV     r2,r0,r1              ;1266
0003b6  fb010112          MLS      r1,r1,r2,r0           ;1266
0003ba  b941              CBNZ     r1,|L17.974|
0003bc  492a              LDR      r1,|L17.1128|
0003be  8809              LDRH     r1,[r1,#0]            ;1269  ; u16SmSync0Value
0003c0  1c49              ADDS     r1,r1,#1              ;1269
0003c2  4a29              LDR      r2,|L17.1128|
0003c4  8011              STRH     r1,[r2,#0]            ;1269
0003c6  e002              B        |L17.974|
                  |L17.968|
0003c8  2101              MOVS     r1,#1                 ;1274
0003ca  4a27              LDR      r2,|L17.1128|
0003cc  8011              STRH     r1,[r2,#0]            ;1274
                  |L17.974|
0003ce  9902              LDR      r1,[sp,#8]            ;1278
0003d0  fbb0f1f1          UDIV     r1,r0,r1              ;1278
0003d4  4a22              LDR      r2,|L17.1120|
0003d6  8011              STRH     r1,[r2,#0]            ;1278
0003d8  9902              LDR      r1,[sp,#8]            ;1280
0003da  fbb0f2f1          UDIV     r2,r0,r1              ;1280
0003de  fb010112          MLS      r1,r1,r2,r0           ;1280
0003e2  b121              CBZ      r1,|L17.1006|
0003e4  491e              LDR      r1,|L17.1120|
0003e6  8809              LDRH     r1,[r1,#0]            ;1282  ; LatchInputSync0Value
0003e8  1c49              ADDS     r1,r1,#1              ;1282
0003ea  4a1d              LDR      r2,|L17.1120|
0003ec  8011              STRH     r1,[r2,#0]            ;1282
                  |L17.1006|
0003ee  e009              B        |L17.1028|
                  |L17.1008|
0003f0  2c02              CMP      r4,#2                 ;1288
0003f2  d102              BNE      |L17.1018|
0003f4  2001              MOVS     r0,#1                 ;1291
0003f6  491c              LDR      r1,|L17.1128|
0003f8  8008              STRH     r0,[r1,#0]            ;1291
                  |L17.1018|
0003fa  2d03              CMP      r5,#3                 ;1294
0003fc  d002              BEQ      |L17.1028|
0003fe  2001              MOVS     r0,#1                 ;1296
000400  4917              LDR      r1,|L17.1120|
000402  8008              STRH     r0,[r1,#0]            ;1296
                  |L17.1028|
000404  2000              MOVS     r0,#0                 ;1303
000406  491a              LDR      r1,|L17.1136|
000408  8008              STRH     r0,[r1,#0]            ;1303
00040a  2202              MOVS     r2,#2                 ;1312
00040c  f44f6184          MOV      r1,#0x420             ;1312
000410  a803              ADD      r0,sp,#0xc            ;1312
000412  f7fffffe          BL       HW_EscRead
000416  f8bd000c          LDRH     r0,[sp,#0xc]          ;1313
00041a  e02b              B        |L17.1140|
                  |L17.1052|
                          DCD      sSyncManOutPar
                  |L17.1056|
                          DCD      sSyncManInPar
                  |L17.1060|
                          DCD      u16ALEventMask
                  |L17.1064|
                          DCD      bEcatFirstOutputsReceived
                  |L17.1068|
                          DCD      nEscAddrOutputData
                  |L17.1072|
                          DCD      nEscAddrInputData
                  |L17.1076|
                          DCD      nPdInputSize
                  |L17.1080|
                          DCD      u16EscAddrSendMbx
                  |L17.1084|
                          DCD      u16SendMbxSize
                  |L17.1088|
                          DCD      u16EscAddrReceiveMbx
                  |L17.1092|
                          DCD      u16ReceiveMbxSize
                  |L17.1096|
                          DCD      nPdOutputSize
                  |L17.1100|
                          DCD      0xc3500000
                  |L17.1104|
                          DCD      bSyncSetByUser
                  |L17.1108|
                          DCD      b3BufferMode
                  |L17.1112|
                          DCD      bEscIntEnabled
                  |L17.1116|
                          DCD      bDcSyncActive
                  |L17.1120|
                          DCD      LatchInputSync0Value
                  |L17.1124|
                          DCD      LatchInputSync0Counter
                  |L17.1128|
                          DCD      u16SmSync0Value
                  |L17.1132|
                          DCD      u16SmSync0Counter
                  |L17.1136|
                          DCD      sCycleDiag
                  |L17.1140|
000474  9003              STR      r0,[sp,#0xc]          ;1313
000476  486a              LDR      r0,|L17.1568|
000478  8800              LDRH     r0,[r0,#0]            ;1315  ; nPdOutputSize
00047a  2800              CMP      r0,#0                 ;1315
00047c  dd21              BLE      |L17.1218|
00047e  f8bd000c          LDRH     r0,[sp,#0xc]          ;1315
000482  b1f0              CBZ      r0,|L17.1218|
000484  2202              MOVS     r2,#2                 ;1319
000486  0251              LSLS     r1,r2,#9              ;1319
000488  a804              ADD      r0,sp,#0x10           ;1319
00048a  f7fffffe          BL       HW_EscRead
00048e  f8bd0010          LDRH     r0,[sp,#0x10]         ;1320
000492  9004              STR      r0,[sp,#0x10]         ;1320
000494  f8bd0010          LDRH     r0,[sp,#0x10]         ;1321
000498  b170              CBZ      r0,|L17.1208|
00049a  f8bd1010          LDRH     r1,[sp,#0x10]         ;1324
00049e  1c88              ADDS     r0,r1,#2              ;1324
0004a0  f8bd100c          LDRH     r1,[sp,#0xc]          ;1327
0004a4  4348              MULS     r0,r1,r0              ;1327
0004a6  f24611a7          MOV      r1,#0x61a7            ;1330
0004aa  4408              ADD      r0,r0,r1              ;1330
0004ac  1c49              ADDS     r1,r1,#1              ;1331
0004ae  fbb0f0f1          UDIV     r0,r0,r1              ;1331
0004b2  4a5c              LDR      r2,|L17.1572|
0004b4  8010              STRH     r0,[r2,#0]            ;1332
0004b6  e008              B        |L17.1226|
                  |L17.1208|
0004b8  2000              MOVS     r0,#0                 ;1336
0004ba  9003              STR      r0,[sp,#0xc]          ;1336
0004bc  4959              LDR      r1,|L17.1572|
0004be  8008              STRH     r0,[r1,#0]            ;1338
0004c0  e003              B        |L17.1226|
                  |L17.1218|
0004c2  2000              MOVS     r0,#0                 ;1345
0004c4  9004              STR      r0,[sp,#0x10]         ;1345
0004c6  4957              LDR      r1,|L17.1572|
0004c8  8008              STRH     r0,[r1,#0]            ;1346
                  |L17.1226|
0004ca  4856              LDR      r0,|L17.1572|
0004cc  8800              LDRH     r0,[r0,#0]            ;1349  ; EcatWdValue
0004ce  b910              CBNZ     r0,|L17.1238|
0004d0  4855              LDR      r0,|L17.1576|
0004d2  7800              LDRB     r0,[r0,#0]            ;1349  ; bWdTrigger
0004d4  b928              CBNZ     r0,|L17.1250|
                  |L17.1238|
0004d6  4853              LDR      r0,|L17.1572|
0004d8  8800              LDRH     r0,[r0,#0]            ;1349  ; EcatWdValue
0004da  b120              CBZ      r0,|L17.1254|
0004dc  4852              LDR      r0,|L17.1576|
0004de  7800              LDRB     r0,[r0,#0]            ;1349  ; bWdTrigger
0004e0  b908              CBNZ     r0,|L17.1254|
                  |L17.1250|
0004e2  201f              MOVS     r0,#0x1f              ;1353
0004e4  e5ed              B        |L17.194|
                  |L17.1254|
0004e6  4851              LDR      r0,|L17.1580|
0004e8  7800              LDRB     r0,[r0,#0]            ;1356  ; bEscIntEnabled
0004ea  b140              CBZ      r0,|L17.1278|
0004ec  484c              LDR      r0,|L17.1568|
0004ee  8800              LDRH     r0,[r0,#0]            ;1356  ; nPdOutputSize
0004f0  b128              CBZ      r0,|L17.1278|
0004f2  484f              LDR      r0,|L17.1584|
0004f4  8800              LDRH     r0,[r0,#0]            ;1360  ; u16ALEventMask
0004f6  f4406080          ORR      r0,r0,#0x400          ;1360
0004fa  494d              LDR      r1,|L17.1584|
0004fc  8008              STRH     r0,[r1,#0]            ;1360
                  |L17.1278|
0004fe  2000              MOVS     r0,#0                 ;1364
000500  494c              LDR      r1,|L17.1588|
000502  8008              STRH     r0,[r1,#0]            ;1364
000504  494c              LDR      r1,|L17.1592|
000506  8008              STRH     r0,[r1,#0]            ;1365
000508  494c              LDR      r1,|L17.1596|
00050a  8008              STRH     r0,[r1,#0]            ;1366
00050c  494c              LDR      r1,|L17.1600|
00050e  8008              STRH     r0,[r1,#0]            ;1367
000510  494c              LDR      r1,|L17.1604|
000512  7008              STRB     r0,[r1,#0]            ;1368
000514  494c              LDR      r1,|L17.1608|
000516  7008              STRB     r0,[r1,#0]            ;1369
000518  494c              LDR      r1,|L17.1612|
00051a  8008              STRH     r0,[r1,#0]            ;1370
00051c  9000              STR      r0,[sp,#0]            ;1375
00051e  2204              MOVS     r2,#4                 ;1376
000520  f44f71a8          MOV      r1,#0x150             ;1376
000524  4668              MOV      r0,sp                 ;1376
000526  f7fffffe          BL       HW_EscRead
00052a  9800              LDR      r0,[sp,#0]            ;1377
00052c  f4006000          AND      r0,r0,#0x800          ;1377
000530  b128              CBZ      r0,|L17.1342|
000532  483f              LDR      r0,|L17.1584|
000534  8800              LDRH     r0,[r0,#0]            ;1379  ; u16ALEventMask
000536  f0400004          ORR      r0,r0,#4              ;1379
00053a  493d              LDR      r1,|L17.1584|
00053c  8008              STRH     r0,[r1,#0]            ;1379
                  |L17.1342|
00053e  9800              LDR      r0,[sp,#0]            ;1382
000540  f4004000          AND      r0,r0,#0x8000         ;1382
000544  b128              CBZ      r0,|L17.1362|
000546  483a              LDR      r0,|L17.1584|
000548  8800              LDRH     r0,[r0,#0]            ;1384  ; u16ALEventMask
00054a  f0400008          ORR      r0,r0,#8              ;1384
00054e  4938              LDR      r1,|L17.1584|
000550  8008              STRH     r0,[r1,#0]            ;1384
                  |L17.1362|
000552  2000              MOVS     r0,#0                 ;1389
000554  493e              LDR      r1,|L17.1616|
000556  8508              STRH     r0,[r1,#0x28]         ;1389
000558  8548              STRH     r0,[r1,#0x2a]         ;1390
00055a  f8810040          STRB     r0,[r1,#0x40]         ;1391
00055e  493d              LDR      r1,|L17.1620|
000560  8508              STRH     r0,[r1,#0x28]         ;1394
000562  8548              STRH     r0,[r1,#0x2a]         ;1395
000564  f8810040          STRB     r0,[r1,#0x40]         ;1396
000568  f8bd0014          LDRH     r0,[sp,#0x14]         ;1400
00056c  f4007000          AND      r0,r0,#0x200          ;1400
000570  b330              CBZ      r0,|L17.1472|
000572  9802              LDR      r0,[sp,#8]            ;1404
000574  b918              CBNZ     r0,|L17.1406|
000576  2000              MOVS     r0,#0                 ;1406
000578  492e              LDR      r1,|L17.1588|
00057a  8008              STRH     r0,[r1,#0]            ;1406
00057c  e013              B        |L17.1446|
                  |L17.1406|
00057e  4a36              LDR      r2,|L17.1624|
000580  9902              LDR      r1,[sp,#8]            ;1410
000582  fbb1f0f2          UDIV     r0,r1,r2              ;1410
000586  2805              CMP      r0,#5                 ;1412
000588  d203              BCS      |L17.1426|
00058a  2101              MOVS     r1,#1                 ;1415
00058c  4a29              LDR      r2,|L17.1588|
00058e  8011              STRH     r1,[r2,#0]            ;1415
000590  e008              B        |L17.1444|
                  |L17.1426|
000592  f64f71ff          MOV      r1,#0xffff            ;1419
000596  ea010140          AND      r1,r1,r0,LSL #1       ;1419
00059a  220a              MOVS     r2,#0xa               ;1419
00059c  fb91f1f2          SDIV     r1,r1,r2              ;1419
0005a0  4a24              LDR      r2,|L17.1588|
0005a2  8011              STRH     r1,[r2,#0]            ;1419
                  |L17.1444|
0005a4  bf00              NOP                            ;1421
                  |L17.1446|
0005a6  f8bd0014          LDRH     r0,[sp,#0x14]         ;1424
0005aa  f4006080          AND      r0,r0,#0x400          ;1424
0005ae  b138              CBZ      r0,|L17.1472|
0005b0  e9dd0101          LDRD     r0,r1,[sp,#4]         ;1426
0005b4  4288              CMP      r0,r1                 ;1426
0005b6  d204              BCS      |L17.1474|
0005b8  481e              LDR      r0,|L17.1588|
0005ba  8800              LDRH     r0,[r0,#0]            ;1429  ; Sync0WdValue
0005bc  4920              LDR      r1,|L17.1600|
0005be  8008              STRH     r0,[r1,#0]            ;1429
                  |L17.1472|
0005c0  e01c              B        |L17.1532|
                  |L17.1474|
0005c2  e9dd1201          LDRD     r1,r2,[sp,#4]         ;1434
0005c6  4411              ADD      r1,r1,r2              ;1434
0005c8  4a23              LDR      r2,|L17.1624|
0005ca  fbb1f0f2          UDIV     r0,r1,r2              ;1434
0005ce  2805              CMP      r0,#5                 ;1435
0005d0  d203              BCS      |L17.1498|
0005d2  2101              MOVS     r1,#1                 ;1438
0005d4  4a1a              LDR      r2,|L17.1600|
0005d6  8011              STRH     r1,[r2,#0]            ;1438
0005d8  e005              B        |L17.1510|
                  |L17.1498|
0005da  0041              LSLS     r1,r0,#1              ;1442
0005dc  220a              MOVS     r2,#0xa               ;1442
0005de  fbb1f1f2          UDIV     r1,r1,r2              ;1442
0005e2  4a17              LDR      r2,|L17.1600|
0005e4  8011              STRH     r1,[r2,#0]            ;1442
                  |L17.1510|
0005e6  4a13              LDR      r2,|L17.1588|
0005e8  8811              LDRH     r1,[r2,#0]            ;1446  ; Sync0WdValue
0005ea  eb0172d1          ADD      r2,r1,r1,LSR #31      ;1446
0005ee  4b14              LDR      r3,|L17.1600|
0005f0  881b              LDRH     r3,[r3,#0]            ;1446  ; Sync1WdValue
0005f2  eb030262          ADD      r2,r3,r2,ASR #1       ;1446
0005f6  4b12              LDR      r3,|L17.1600|
0005f8  801a              STRH     r2,[r3,#0]            ;1446
0005fa  bf00              NOP                            ;1447
                  |L17.1532|
0005fc  4808              LDR      r0,|L17.1568|
0005fe  8800              LDRH     r0,[r0,#0]            ;1451  ; nPdOutputSize
000600  2800              CMP      r0,#0                 ;1451
000602  dd02              BLE      |L17.1546|
000604  2002              MOVS     r0,#2                 ;1453
000606  f7fffffe          BL       EnableSyncManChannel
                  |L17.1546|
00060a  4814              LDR      r0,|L17.1628|
00060c  8800              LDRH     r0,[r0,#0]            ;1456  ; nPdInputSize
00060e  2800              CMP      r0,#0                 ;1456
000610  dd02              BLE      |L17.1560|
000612  2003              MOVS     r0,#3                 ;1458
000614  f7fffffe          BL       EnableSyncManChannel
                  |L17.1560|
000618  f7fffffe          BL       PDO_InputMapping
00061c  2000              MOVS     r0,#0                 ;1465
00061e  e550              B        |L17.194|
;;;1467   
                          ENDP

                  |L17.1568|
                          DCD      nPdOutputSize
                  |L17.1572|
                          DCD      EcatWdValue
                  |L17.1576|
                          DCD      bWdTrigger
                  |L17.1580|
                          DCD      bEscIntEnabled
                  |L17.1584|
                          DCD      u16ALEventMask
                  |L17.1588|
                          DCD      Sync0WdValue
                  |L17.1592|
                          DCD      Sync0WdCounter
                  |L17.1596|
                          DCD      Sync1WdCounter
                  |L17.1600|
                          DCD      Sync1WdValue
                  |L17.1604|
                          DCD      bDcRunning
                  |L17.1608|
                          DCD      bSmSyncSequenceValid
                  |L17.1612|
                          DCD      i16WaitForPllRunningTimeout
                  |L17.1616|
                          DCD      sSyncManInPar
                  |L17.1620|
                          DCD      sSyncManOutPar
                  |L17.1624|
                          DCD      0x000186a0
                  |L17.1628|
                          DCD      nPdInputSize

                          AREA ||i.StartOutputHandler||, CODE, READONLY, ALIGN=2

                  StartOutputHandler PROC
;;;1477   
;;;1478   UINT16 StartOutputHandler(void)
000000  21ff              MOVS     r1,#0xff
;;;1479   {
;;;1480       /* by default the SO transition should be completed in AlControlRes().
;;;1481          required to support also masters which starts to send process data after the SO transition was triggered
;;;1482          (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)*/
;;;1483       UINT16 result = NOERROR_INWORK;
;;;1484       /*ECATCHANGE_START(V5.13) ESM1*/
;;;1485       if(STATE_VALID(u8LocalErrorState))
000002  4817              LDR      r0,|L18.96|
000004  7800              LDRB     r0,[r0,#0]  ; u8LocalErrorState
000006  f000000f          AND      r0,r0,#0xf
00000a  2801              CMP      r0,#1
00000c  d011              BEQ      |L18.50|
00000e  4814              LDR      r0,|L18.96|
000010  7800              LDRB     r0,[r0,#0]  ; u8LocalErrorState
000012  f000000f          AND      r0,r0,#0xf
000016  2802              CMP      r0,#2
000018  d00b              BEQ      |L18.50|
00001a  4811              LDR      r0,|L18.96|
00001c  7800              LDRB     r0,[r0,#0]  ; u8LocalErrorState
00001e  f000000f          AND      r0,r0,#0xf
000022  2804              CMP      r0,#4
000024  d005              BEQ      |L18.50|
000026  480e              LDR      r0,|L18.96|
000028  7800              LDRB     r0,[r0,#0]  ; u8LocalErrorState
00002a  f000000f          AND      r0,r0,#0xf
00002e  2808              CMP      r0,#8
000030  d102              BNE      |L18.56|
                  |L18.50|
;;;1486   /*ECATCHANGE_END(V5.13) ESM1*/
;;;1487       {
;;;1488           /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode"*/
;;;1489           return u16LocalErrorCode;
000032  480c              LDR      r0,|L18.100|
000034  8800              LDRH     r0,[r0,#0]  ; u16LocalErrorCode
                  |L18.54|
;;;1490       }
;;;1491   /*The application ESM function is separated from this function to handle pending transitions*/
;;;1492   
;;;1493   
;;;1494       /*DC synchronisation is active wait until pll is valid*/
;;;1495       if(bDcSyncActive)
;;;1496       {
;;;1497           i16WaitForPllRunningTimeout = 200;
;;;1498   
;;;1499           i16WaitForPllRunningCnt = 0;
;;;1500       }
;;;1501   
;;;1502   
;;;1503   
;;;1504       sSyncManOutPar.u16SmEventMissedCounter = 0;
;;;1505       sSyncManOutPar.u8SyncError = 0;
;;;1506   
;;;1507   
;;;1508       sSyncManInPar.u16SmEventMissedCounter = 0;
;;;1509       sSyncManInPar.u8SyncError = 0;
;;;1510   
;;;1511   /*ET9300 Project Handler :(#if COE_SUPPORTED #else) lines 2178 to 2180 deleted*/
;;;1512   
;;;1513       return result;
;;;1514   }
000036  4770              BX       lr
                  |L18.56|
000038  480b              LDR      r0,|L18.104|
00003a  7800              LDRB     r0,[r0,#0]            ;1495  ; bDcSyncActive
00003c  b128              CBZ      r0,|L18.74|
00003e  20c8              MOVS     r0,#0xc8              ;1497
000040  4a0a              LDR      r2,|L18.108|
000042  8010              STRH     r0,[r2,#0]            ;1497
000044  2000              MOVS     r0,#0                 ;1499
000046  4a0a              LDR      r2,|L18.112|
000048  8010              STRH     r0,[r2,#0]            ;1499
                  |L18.74|
00004a  2000              MOVS     r0,#0                 ;1504
00004c  4a09              LDR      r2,|L18.116|
00004e  8510              STRH     r0,[r2,#0x28]         ;1504
000050  f8820040          STRB     r0,[r2,#0x40]         ;1505
000054  4a08              LDR      r2,|L18.120|
000056  8510              STRH     r0,[r2,#0x28]         ;1508
000058  f8820040          STRB     r0,[r2,#0x40]         ;1509
00005c  4608              MOV      r0,r1                 ;1513
00005e  e7ea              B        |L18.54|
;;;1515   
                          ENDP

                  |L18.96|
                          DCD      u8LocalErrorState
                  |L18.100|
                          DCD      u16LocalErrorCode
                  |L18.104|
                          DCD      bDcSyncActive
                  |L18.108|
                          DCD      i16WaitForPllRunningTimeout
                  |L18.112|
                          DCD      i16WaitForPllRunningCnt
                  |L18.116|
                          DCD      sSyncManOutPar
                  |L18.120|
                          DCD      sSyncManInPar

                          AREA ||i.StopInputHandler||, CODE, READONLY, ALIGN=2

                  StopInputHandler PROC
;;;1536   
;;;1537   void StopInputHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1538   {
;;;1539       if(nPdOutputSize > 0)
000002  4822              LDR      r0,|L19.140|
000004  8800              LDRH     r0,[r0,#0]  ; nPdOutputSize
000006  2800              CMP      r0,#0
000008  dd02              BLE      |L19.16|
;;;1540       {
;;;1541           /* disable the Sync Manager Channel 2 (outputs) */
;;;1542           DisableSyncManChannel(PROCESS_DATA_OUT);
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       DisableSyncManChannel
                  |L19.16|
;;;1543       }
;;;1544   
;;;1545       if(nPdInputSize > 0)
000010  481f              LDR      r0,|L19.144|
000012  8800              LDRH     r0,[r0,#0]  ; nPdInputSize
000014  2800              CMP      r0,#0
000016  dd02              BLE      |L19.30|
;;;1546       {
;;;1547           /*disable Sync Manager 3 (inputs) if no outputs available*/
;;;1548           DisableSyncManChannel(PROCESS_DATA_IN);
000018  2003              MOVS     r0,#3
00001a  f7fffffe          BL       DisableSyncManChannel
                  |L19.30|
;;;1549       }
;;;1550   
;;;1551       /* reset the events in the AL Event mask register (0x204) */
;;;1552   /*ECATCHANGE_START(V5.13) ECAT1*/
;;;1553   /*ECATCHANGE_END(V5.13) ECAT1*/
;;;1554       {
;;;1555           UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
00001e  240c              MOVS     r4,#0xc
;;;1556           ResetMask |= PROCESS_OUTPUT_EVENT;
000020  f4446480          ORR      r4,r4,#0x400
;;;1557           ResetMask |= PROCESS_INPUT_EVENT;
000024  f4446400          ORR      r4,r4,#0x800
;;;1558   
;;;1559       ResetALEventMask( ~(ResetMask) );
000028  43e1              MVNS     r1,r4
00002a  b288              UXTH     r0,r1
00002c  f7fffffe          BL       ResetALEventMask
;;;1560       }
;;;1561       /* reset the flags */
;;;1562       bEcatFirstOutputsReceived = FALSE;
000030  2000              MOVS     r0,#0
000032  4918              LDR      r1,|L19.148|
000034  7008              STRB     r0,[r1,#0]
;;;1563       bEscIntEnabled = FALSE;
000036  4918              LDR      r1,|L19.152|
000038  7008              STRB     r0,[r1,#0]
;;;1564   /*The application ESM function is separated from this function to handle pending transitions*/
;;;1565   
;;;1566       bDcSyncActive = FALSE;
00003a  4918              LDR      r1,|L19.156|
00003c  7008              STRB     r0,[r1,#0]
;;;1567       bDcRunning = FALSE;
00003e  4918              LDR      r1,|L19.160|
000040  7008              STRB     r0,[r1,#0]
;;;1568       bSmSyncSequenceValid = FALSE;
000042  4918              LDR      r1,|L19.164|
000044  7008              STRB     r0,[r1,#0]
;;;1569       u16SmSync0Value = 0;
000046  4918              LDR      r1,|L19.168|
000048  8008              STRH     r0,[r1,#0]
;;;1570       u16SmSync0Counter = 0;
00004a  4918              LDR      r1,|L19.172|
00004c  8008              STRH     r0,[r1,#0]
;;;1571   
;;;1572       Sync0WdValue = 0;
00004e  4918              LDR      r1,|L19.176|
000050  8008              STRH     r0,[r1,#0]
;;;1573       Sync0WdCounter = 0;
000052  4918              LDR      r1,|L19.180|
000054  8008              STRH     r0,[r1,#0]
;;;1574       Sync1WdCounter = 0;
000056  4918              LDR      r1,|L19.184|
000058  8008              STRH     r0,[r1,#0]
;;;1575       Sync1WdValue = 0;
00005a  4918              LDR      r1,|L19.188|
00005c  8008              STRH     r0,[r1,#0]
;;;1576       LatchInputSync0Value = 0;
00005e  4918              LDR      r1,|L19.192|
000060  8008              STRH     r0,[r1,#0]
;;;1577       LatchInputSync0Counter = 0;
000062  4918              LDR      r1,|L19.196|
000064  8008              STRH     r0,[r1,#0]
;;;1578   
;;;1579   
;;;1580       sSyncManOutPar.u16SmEventMissedCounter = 0;
000066  4918              LDR      r1,|L19.200|
000068  8508              STRH     r0,[r1,#0x28]
;;;1581       sSyncManOutPar.u16CycleExceededCounter = 0;
00006a  8548              STRH     r0,[r1,#0x2a]
;;;1582       sSyncManOutPar.u8SyncError = 0;
00006c  f8810040          STRB     r0,[r1,#0x40]
;;;1583   
;;;1584   
;;;1585       sSyncManInPar.u16SmEventMissedCounter = 0;
000070  4916              LDR      r1,|L19.204|
000072  8508              STRH     r0,[r1,#0x28]
;;;1586       sSyncManInPar.u16CycleExceededCounter = 0;
000074  8548              STRH     r0,[r1,#0x2a]
;;;1587       sSyncManInPar.u8SyncError = 0;
000076  f8810040          STRB     r0,[r1,#0x40]
;;;1588   /*ET9300 Project Handler :(#if COE_SUPPORTED #else) lines 2279 to 2281 deleted*/
;;;1589   
;;;1590       i16WaitForPllRunningTimeout = 0;
00007a  4915              LDR      r1,|L19.208|
00007c  8008              STRH     r0,[r1,#0]
;;;1591   
;;;1592       bWdTrigger = FALSE;
00007e  4915              LDR      r1,|L19.212|
000080  7008              STRB     r0,[r1,#0]
;;;1593       bEcatInputUpdateRunning = FALSE;
000082  4915              LDR      r1,|L19.216|
000084  7008              STRB     r0,[r1,#0]
;;;1594   
;;;1595       /*Indicate no user specified Sync mode*/
;;;1596       bSyncSetByUser = FALSE;
000086  4915              LDR      r1,|L19.220|
000088  7008              STRB     r0,[r1,#0]
;;;1597   }
00008a  bd10              POP      {r4,pc}
;;;1598   
                          ENDP

                  |L19.140|
                          DCD      nPdOutputSize
                  |L19.144|
                          DCD      nPdInputSize
                  |L19.148|
                          DCD      bEcatFirstOutputsReceived
                  |L19.152|
                          DCD      bEscIntEnabled
                  |L19.156|
                          DCD      bDcSyncActive
                  |L19.160|
                          DCD      bDcRunning
                  |L19.164|
                          DCD      bSmSyncSequenceValid
                  |L19.168|
                          DCD      u16SmSync0Value
                  |L19.172|
                          DCD      u16SmSync0Counter
                  |L19.176|
                          DCD      Sync0WdValue
                  |L19.180|
                          DCD      Sync0WdCounter
                  |L19.184|
                          DCD      Sync1WdCounter
                  |L19.188|
                          DCD      Sync1WdValue
                  |L19.192|
                          DCD      LatchInputSync0Value
                  |L19.196|
                          DCD      LatchInputSync0Counter
                  |L19.200|
                          DCD      sSyncManOutPar
                  |L19.204|
                          DCD      sSyncManInPar
                  |L19.208|
                          DCD      i16WaitForPllRunningTimeout
                  |L19.212|
                          DCD      bWdTrigger
                  |L19.216|
                          DCD      bEcatInputUpdateRunning
                  |L19.220|
                          DCD      bSyncSetByUser

                          AREA ||i.StopOutputHandler||, CODE, READONLY, ALIGN=2

                  StopOutputHandler PROC
;;;1523   
;;;1524   void StopOutputHandler(void)
000000  2000              MOVS     r0,#0
;;;1525   {
;;;1526       /* reset the flags that outputs were received and that the slave is in OP */
;;;1527       bEcatFirstOutputsReceived = FALSE;
000002  4902              LDR      r1,|L20.12|
000004  7008              STRB     r0,[r1,#0]
;;;1528       bEcatOutputUpdateRunning = FALSE;
000006  4902              LDR      r1,|L20.16|
000008  7008              STRB     r0,[r1,#0]
;;;1529   }
00000a  4770              BX       lr
;;;1530   
                          ENDP

                  |L20.12|
                          DCD      bEcatFirstOutputsReceived
                  |L20.16|
                          DCD      bEcatOutputUpdateRunning

                          AREA ||i.UpdateEEPROMLoadedState||, CODE, READONLY, ALIGN=2

                  UpdateEEPROMLoadedState PROC
;;;326    *////////////////////////////////////////////////////////////////////////////////////////
;;;327    void UpdateEEPROMLoadedState(void)
000000  b508              PUSH     {r3,lr}
;;;328    {
;;;329    /*ET9300 Project Handler :(#if ESC_32BIT_ACCESS) lines 415 to 420 deleted*/
;;;330        UINT16 TmpVar = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;331        //read EEPROM loaded information
;;;332        HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
000006  2202              MOVS     r2,#2
000008  f2405102          MOV      r1,#0x502
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       HW_EscRead
;;;333        TmpVar = SWAPWORD(TmpVar);
000012  f8bd0000          LDRH     r0,[sp,#0]
000016  9000              STR      r0,[sp,#0]
;;;334    
;;;335    
;;;336        if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
000018  f8bd0000          LDRH     r0,[sp,#0]
00001c  f4006000          AND      r0,r0,#0x800
000020  2800              CMP      r0,#0
000022  dc05              BGT      |L21.48|
;;;337            || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
000024  f8bd0000          LDRH     r0,[sp,#0]
000028  f4005080          AND      r0,r0,#0x1000
00002c  2800              CMP      r0,#0
00002e  dd03              BLE      |L21.56|
                  |L21.48|
;;;338        {
;;;339            EepromLoaded = FALSE;
000030  2000              MOVS     r0,#0
000032  4903              LDR      r1,|L21.64|
000034  7008              STRB     r0,[r1,#0]
000036  e002              B        |L21.62|
                  |L21.56|
;;;340        }
;;;341        else
;;;342        {
;;;343            EepromLoaded = TRUE;
000038  2001              MOVS     r0,#1
00003a  4901              LDR      r1,|L21.64|
00003c  7008              STRB     r0,[r1,#0]
                  |L21.62|
;;;344        }
;;;345    }
00003e  bd08              POP      {r3,pc}
;;;346    
                          ENDP

                  |L21.64|
                          DCD      EepromLoaded

                          AREA ||.data||, DATA, ALIGN=1

                  bBootMode
000000  00                DCB      0x00
                  bEcatOutputUpdateRunning
000001  00                DCB      0x00
                  bEcatInputUpdateRunning
000002  00                DCB      0x00
                  bEcatFirstOutputsReceived
000003  00                DCB      0x00
                  bWdTrigger
000004  00                DCB      0x00
                  bDcSyncActive
000005  00                DCB      0x00
                  EsmTimeoutCounter
000006  0000              DCB      0x00,0x00
                  bDcRunning
000008  0000              DCB      0x00,0x00
                  u16SmSync0Counter
00000a  0000              DCB      0x00,0x00
                  u16SmSync0Value
00000c  0000              DCB      0x00,0x00
                  bSmSyncSequenceValid
00000e  0000              DCB      0x00,0x00
                  i16WaitForPllRunningTimeout
000010  0000              DCB      0x00,0x00
                  i16WaitForPllRunningCnt
000012  0000              DCB      0x00,0x00
                  Sync0WdCounter
000014  0000              DCB      0x00,0x00
                  Sync0WdValue
000016  0000              DCB      0x00,0x00
                  Sync1WdCounter
000018  0000              DCB      0x00,0x00
                  Sync1WdValue
00001a  0000              DCB      0x00,0x00
                  LatchInputSync0Value
00001c  0000              DCB      0x00,0x00
                  LatchInputSync0Counter
00001e  0000              DCB      0x00,0x00
                  b32BitDc
000020  00                DCB      0x00
                  bEscIntEnabled
000021  00                DCB      0x00
                  b3BufferMode
000022  0000              DCB      0x00,0x00
                  u16LocalErrorCode
000024  0000              DCB      0x00,0x00
                  u8LocalErrorState
000026  00                DCB      0x00
                  bApplEsmPending
000027  00                DCB      0x00
                  bEcatWaitForAlControlRes
000028  0000              DCB      0x00,0x00
                  nEcatStateTrans
00002a  0000              DCB      0x00,0x00
                  u8EcatErrorLed
00002c  00                DCB      0x00
                  u8EcatRunLed
00002d  00                DCB      0x00
                  nPdInputSize
00002e  0000              DCB      0x00,0x00
                  nPdOutputSize
000030  0000              DCB      0x00,0x00
                  nMaxSyncMan
000032  0000              DCB      0x00,0x00
                  nMaxEscAddress
000034  0000              DCB      0x00,0x00
                  nAlStatus
000036  00                DCB      0x00
                  bExplicitDevIdRequested
000037  00                DCB      0x00
                  EcatWdValue
000038  0000              DCB      0x00,0x00
                  nEscAddrOutputData
00003a  0000              DCB      0x00,0x00
                  nEscAddrInputData
00003c  0000              DCB      0x00,0x00
                  u16ALEventMask
00003e  0000              DCB      0x00,0x00
                  u16IdValue
000040  0000              DCB      0x00,0x00
                  u16dummy
000042  0000              DCB      0x00,0x00
                  SMActivate
000044  0000              DCW      0x0000
                  SyncManInfo
000046  0000              DCB      0x00,0x00
                          DCDU     0x00000000
00004c  0000              DCB      0x00,0x00
                  EepromLoaded
00004e  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "etherCAT\\ecatslv.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_ecatslv_c_b44608ff____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_ecatslv_c_b44608ff____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_ecatslv_c_b44608ff____REVSH|
#line 402
|__asm___9_ecatslv_c_b44608ff____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_ecatslv_c_b44608ff____RRX|
#line 587
|__asm___9_ecatslv_c_b44608ff____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
